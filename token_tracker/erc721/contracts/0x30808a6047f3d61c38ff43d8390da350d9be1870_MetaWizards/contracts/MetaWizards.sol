/* SPDX-License-Identifier: MIT



                    [][][][][][][][]  [][][][]  [][][][][][]   [[][][][]]
                    [][][][][][][][]  [][][][]  [][][][][][]  [][][][][][]
                    [][]  [][]  [][]  [][]          [][]      [][]    [][]
                    [][]  [][]  [][]  [][][][]      [][]      [][]    [][]
                    [][]  [][]  [][]  [][][][]      [][]      [][][][][][]
                    [][]        [][]  [][]          [][]      [][][][][][]
                    [][]        [][]  [][][][]      [][]      [][]    [][]
                    [][]        [][]  [][][][]      [][]      [][]    [][]


[][]        [][]  [][][][]  [][][][][][]   [[][][][]]   [][][][][]]   [][][][]]      [][][][][][]
[][]        [][]  [][][][]  [][][][][][]  [][][][][][]  [][][][][][]  [][][][][]    [][]    [][]
[][]        [][]    [][]           [][]   [][]    [][]  [][]    [][]  [][]   [][]   [][]        
[][]  [][]  [][]    [][]         [][]     [][]    [][]  [][]   [][]   [][]    [][]  [][][][][][]
[][]  [][]  [][]    [][]       [][]       [][][][][][]  [][][][][]    [][]    [][]  [][][][][][]
[][]  [][]  [][]    [][]     [][]         [][][][][][]  [][][][][]    [][]   [][]           [][]
[][][][][][][][]  [][][][]  [][][][][][]  [][]    [][]  [][]   [][]   [][][][][]    [][]    [][]
[][][][][][][][]  [][][][]  [][][][][][]  [][]    [][]  [][]    [][]  [][][][]]    [][][][][][]



* Generated by Cyberscape Labs and Adaptia Studio
* Email cyberscape.eth@gmail.com for your NFT launch needs


*/



pragma solidity ^0.8.10;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "erc721a/contracts/ERC721A.sol";


/*//////////////////////////////////////
            CUSTOM ERRORS
//////////////////////////////////////*/
/// @notice Thrown when completing transaction will exceed collection supply
error ExceededMintSupply();
/// @notice Thrown when transaction sender is not on whitelist
error NotOnMintList();
/// @notice Thrown when the attempted sale is not actve
error SaleNotActive();
/// @notice Thrown when the message value is less than the required amount
error ValueTooLow();
/// @notice Thrown when the amount minted exceeds max allowed
error MintingTooMany();
/// @notice Thrown when the input address is 0
error ZeroAddress();
/// @notice Thrown when input data does not equal what was required
error InvalidData();



/**
    @title Meta Wizards NFT
    @author @0x_digitalnomad with Cyberscape Labs
*/

contract MetaWizards is ERC721A, Ownable, ReentrancyGuard {

    using Strings for uint256;

    /*//////////////////////////////////////
                STATE VARIABLES
    //////////////////////////////////////*/
    enum MintStatus {
        CLOSED,
        PRESALE,
        PUBLIC,
        SOLDOUT
    }
    /// Active mint phase status
    MintStatus public mintStatus = MintStatus.CLOSED;

    /// Maximum number of NFTs that can exist
    uint16 public collectionSize;
    /// Maximum number that can be minted in public and presales
    uint16 public maxAvailableSupply;
    /// Amont of collection size reserved for marketing
    uint16 public reserveSupply;
    /// Amount that has been minted for marketing
    uint16 public devMintCount;
    /// Maximum that can be minted per wallet
    uint16 public maxWallet = 2;
    // Whether the individual NFTs have been revealed
    bool public revealed = false;
    uint256 public presalePrice = 0.17 ether;
    uint256 public salePrice = 0.19 ether;
    uint32 private mintData;
    string private baseURI;
    string private unrevealedURI;

    mapping(address => bool) private mintList;


    /*//////////////////////////////////////
                EVENTS
    //////////////////////////////////////*/
    event ChangeBaseURI(string _baseURI);
    event UpdateSaleState(string _sale);
    event Mint(address _minter, uint256 _amount, string _type);


    /*//////////////////////////////////////
                CONSTRUCTOR
    //////////////////////////////////////*/
    constructor(uint16 collectionSize_, uint16 reserveSupply_, uint32 mintData_) ERC721A("Meta Wizards", "MWIZ") {
        collectionSize = collectionSize_;
        reserveSupply = reserveSupply_;
        mintData = mintData_;

        maxAvailableSupply = collectionSize - reserveSupply;
    }


    /*//////////////////////////////////////
                MODIFIERS
    //////////////////////////////////////*/
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Caller is another contract");
        _;
    }


    /*//////////////////////////////////////
                MINTING FUNCTIONS
    //////////////////////////////////////*/

    /**
    Dev mint function to reserve a supply for giveaways, collaborations, and marketing
        @param _address The address to mint to
        @param _amount The amount to mint
    */
    function devMint(address _address, uint16 _amount)
        external
        onlyOwner
    {
        if (_address == address(0)) revert ZeroAddress();
        if (_amount + devMintCount > reserveSupply) revert ExceededMintSupply();

        _safeMint(_address, _amount);
        devMintCount += _amount;
        emit Mint(_address, _amount, "Dev");
    }

    /**
        Public and presale minting function
        @param _amount The amount to mint
        @param _data Private data required to mint
    */
    function mint (uint16 _amount, uint32 _data)
        external
        payable
        callerIsUser
        nonReentrant
    {
        if (mintStatus != MintStatus.PRESALE && mintStatus != MintStatus.PUBLIC) revert SaleNotActive();
        if (_data != mintData) revert InvalidData();
        if (_addressData[msg.sender].balance + _amount > maxWallet) revert MintingTooMany();
        if (_amount + totalSupply() > maxAvailableSupply) revert ExceededMintSupply();

        if (mintStatus == MintStatus.PRESALE) {
            if (!mintList[msg.sender]) revert NotOnMintList();
            if (msg.value != presalePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Presale");
        } else if (mintStatus == MintStatus.PUBLIC) {
            if (msg.value != salePrice * _amount) revert ValueTooLow();

            _safeMint(msg.sender, _amount);
            emit Mint(msg.sender, _amount, "Public");
        }
    }

    
    /*//////////////////////////////////////
                SETTERS
    //////////////////////////////////////*/
    
    /**
        Update the pre-reveal URI for all tokens
        @param _unrevealedURI The new URI for all tokens (pre-reveal)
    */
    function setUnrevealedURI(string calldata _unrevealedURI)
        external
        onlyOwner
    {
        unrevealedURI = _unrevealedURI;
    }

    /**
        Update the revealed base URI for tokens
        @param _tokenBaseURI The new base URI for tokens (post-reveal)
    */
    function setBaseURI(string calldata _tokenBaseURI)
        external
        onlyOwner
    {
        baseURI = _tokenBaseURI;
        emit ChangeBaseURI(_tokenBaseURI);
    }

    /**
        Update the price for the public sale or presale.
        @param _saleType Either 0 for public sale or 1 for presale
        @param _price The new price in gwei
    */
    function setPrice(uint8 _saleType, uint256 _price)
        external
        onlyOwner
    {
        if (_saleType == 0) {           // 0 = Presale
            presalePrice = _price;
        } else if (_saleType == 1) {    // 1 = Public Sale
            salePrice = _price;
        } else {
            revert InvalidData();
        }
    }

    /**
        Update the private mint data
        @param _data New data for minting
    */
    function setMintData(uint32 _data)
        external
        onlyOwner
    {
        mintData = _data;
    }

    /**
        Update the maximum available per wallet
        @param _max New max amount of mints per wallet
    */
    function setMaxWallet(uint16 _max)
        external
        onlyOwner
    {
        maxWallet = _max;
    }


    /*//////////////////////////////////////
                GETTERS
    //////////////////////////////////////*/ 
    
    /**
        Returns the complete URI for a token
        @return URI The complete metadata URI
    */
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");
        
        if (revealed == false) {
            return unrevealedURI;
        } else {
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), '.json')) : '';
        }
    }

    /**
        Retrieve the currently active mint phase
        @return status A string indicating the active mint phase
    */
    function getMintStatus()
        external
        view
        returns(string memory)
    {
        if (mintStatus == MintStatus.CLOSED) {
            return "Closed";
        } else if (mintStatus == MintStatus.PRESALE){
            return "Presale";
        } else if (mintStatus == MintStatus.PUBLIC) {
            return "Public Sale";
        } else { //mintStatus == MintStatus.SoldOut
            return "Sold Out";
        }
    }

    /**
        Determine whether an address is on the mint list and how many mints remain. (Non-whitelisted addresses will return 0)
        @param _addr The address to check
        @return isWhitelisted The amount of NFTs the address can still mint
    */
    function getMintList(address _addr)
        external
        view
        returns(bool)
    {
        return mintList[_addr];
    }

    /*//////////////////////////////////////
                MISC
    //////////////////////////////////////*/

    /**
        Add an array of addresses to the mint list
        @param _addr An array of addresses to add
    */
    function addToMintList(address[] calldata _addr)
        external
        onlyOwner
    {
        for (uint16 i = 0; i < _addr.length; i++) {
            if (_addr[i] == address(0)) revert ZeroAddress();
            
            mintList[_addr[i]] = true;
        }
    }

    /**
        Remove an array of addresses from the mint list
        @param _addr An array of addresses to remove
    */
    function removeFromMintList(address[] calldata _addr)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addr.length; i++) {
            if (_addr[i] == address(0)) revert ZeroAddress();
            
            mintList[_addr[i]] = false;
        }
    }
    
    /**
        Reveal or unreveal the images for the individual NFTs
        @param _reveal 'true' to reveal 'false' to unreveal
    */
    function reveal(bool _reveal) external onlyOwner {
        revealed = _reveal;
    }

    /**
        Close any active sale, or set mintStatus to 'sold out' if total supply == collection size
    */
    function closeSale() external onlyOwner {
        if (totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
            emit UpdateSaleState("Sold Out");
        } else {
            mintStatus = MintStatus.CLOSED;
            emit UpdateSaleState("Closed");
        }
    }

    /**
        Start the presale
    */
    function startPresale() external onlyOwner {
        mintStatus = MintStatus.PRESALE;
        emit UpdateSaleState("Presale");
    }

    /**
        Start the public sale
    */
    function startPublicSale() external onlyOwner {
        mintStatus = MintStatus.PUBLIC;
        emit UpdateSaleState("Public");
    }

    /**
        Withdrawal funds from the contract
    */
    function withdrawl() external onlyOwner {
        uint totalBalance = address(this).balance;
        payable(msg.sender).transfer(totalBalance);
    }
}