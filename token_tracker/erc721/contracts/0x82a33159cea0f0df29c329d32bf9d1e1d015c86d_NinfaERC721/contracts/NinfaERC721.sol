// SPDX-License-Identifier: MIT

pragma solidity 0.8.13;

import { DecodeTokenURI } from "./utils/DecodeTokenURI.sol";
import "./ERC2981.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";


/**
    ███    ██ ██ ███    ██ ███████  █████  
    ████   ██ ██ ████   ██ ██      ██   ██ 
    ██ ██  ██ ██ ██ ██  ██ █████   ███████ 
    ██  ██ ██ ██ ██  ██ ██ ██      ██   ██ 
    ██   ████ ██ ██   ████ ██      ██   ██                                                                               
 */

/// @custom:security-contact tech@ninfa.io
contract NinfaERC721 is ERC2981, AccessControl, ERC721Enumerable  {

    using DecodeTokenURI for bytes;

    bytes32 private constant MINTER_ROLE = 0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6; // keccak256("MINTER_ROLE"); // one or more smart contracts allowed to call the mint function, eg. the Marketplace contract
    string private _baseTokenURI; // Base URI
    mapping(uint256 => bytes32) private _tokenURIs; // Optional mapping for token URIs
    
    /**
     * @dev Grants `DEFAULT_ADMIN_ROLE`, `MINTER_ROLE` to the account that deploys the contract.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI // e.g. https://gateway.pinata.cloud/ipfs/
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;

        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    /**
     * Optional function to set the base URI
     */
    function setBaseURI(string memory baseURI_) external  {
        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender), "NinfaERC721: must be admin");
        _baseTokenURI = baseURI_;
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}. It needs to be overridden because the new OZ contracts concatenate _baseURI + tokenId instead of _baseURI + _tokenURI
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "NinfaERC721: nonexistent token");

        return string( // once hex decoded base58 is converted to string, we get the initial IPFS hash
            abi.encodePacked(
                _baseTokenURI,
                abi.encodePacked( // full bytes of base58 + hex encoded IPFS hash example.
                    bytes2(0x1220), // prepending 2 bytes IPFS hash identifier that was removed before storing the hash in order to fit in bytes32. 0x1220 is "Qm" base58 and hex encoded
                    _tokenURIs[tokenId] // tokenURI (IPFS hash) with its first 2 bytes truncated, base58 and hex encoded returned as bytes32
                ).toBase58()
            )
        );
    }

    /**
     * @dev Creates a new token for `msg.sender`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     * See {ERC721-_mint}.
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE` role.
     */
    function mint(bytes32 _tokenURI, address _to) external {
        require(hasRole(MINTER_ROLE, msg.sender), "NinfaERC721: must be minter"); // MINTER_ROLE is assigned to contracts such as the marketplace, NOT artists in this case.
        artists[totalSupply()] = payable(_to); // set tokenID before minting otherwise the total supply will get increamented
        _safeMint(_to, totalSupply() ); // using total supply as counter, since tokens cannot be burned we don't need a separate counter
        
        _setTokenURI(totalSupply() - 1, _tokenURI); // set URI after minting otherwise it throws because the token doesn't exist yet; the token id just minted will be equal to totalSupply() - 1.
    }

    /**
     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.
     * Since Openzeppelin contracts v4.0 the _setTokenURI() function was removed, instead we must append the tokenID directly to this variable returned by _baseURI() internal function.
     * This contract implements all the required functionality from ERC721URIStorage, which is the OpenZeppelin extension for supporting _setTokenURI.
     * See https://forum.openzeppelin.com/t/why-doesnt-openzeppelin-erc721-contain-settokenuri/6373 and https://forum.openzeppelin.com/t/function-settokenuri-in-erc721-is-gone-with-pragma-0-8-0/5978/2
     *
     * Requirements:
     *
     * - `tokenId` must exist.
     */
    function _setTokenURI(uint256 tokenId, bytes32 _tokenURI) internal virtual {
        require(_exists(tokenId), "NinfaERC721: nonexistent token");
        _tokenURIs[tokenId] = _tokenURI;
    }

    /**
     * @dev overrides the base function which is empty by default, see {ERC721-_baseURI}
     */
    function _baseURI() internal view virtual override returns (string memory) {
        return _baseTokenURI;
    }

    /**
     * @dev The following function override is required by Solidity.
     */
    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        virtual
        override(ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @dev See {IERC165-supportsInterface}. The following function override is required by Solidity.
     */
    function supportsInterface(bytes4 interfaceId)
        public
        view
        virtual
        override( ERC2981, AccessControl, ERC721Enumerable )
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }

}