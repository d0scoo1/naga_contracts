// SPDX-License-Identifier: MIT

///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
////_____ ///////////////__  __ _ //////_ /////
///|  __ \//////////////|  \/  (_)/////| |/////
///| |__) |__ _ _ __ ___| \  / |_ _ __ | |_////
///|  _  // _` | '__/ _ \ |\/| | | '_ \| __|///
///| | \ \ (_| | | |  __/ |  | | | | | | |_ ///
///|_|  \_\__,_|_|//\___|_|  |_|_|_| |_|\__|///
///////////////////////////////////////////////
///////////////////////////////////////////////
///////////////////////////////////////////////
pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

// import "@openzeppelin/contracts/utils/Counters.sol";
import "./Counters.sol"; // OZ Counters with increment only
import "./Whitelist.sol";

contract RareMintGalaxyPass is ERC721, ERC721Enumerable, ERC721Burnable, Ownable, Whitelist, ReentrancyGuard {
    using Counters for Counters.Counter;
    using SafeERC20 for IERC20;

    Counters.Counter private _tokenIdCounter;

    string private _baseTokenURI;
    string private baseExtension = ".json";
    bool public saleEnabled;
    bool public onlyWhitelisted = true;
    address public paymentToken; // address(0) = ETH , otherwise ERC20 token contract address
    uint256 public price = 5 ether / 10; // default price = 0.5 ETH
    uint256 public nftLimit;
    uint256 public nftPerAddressLimit = 2;

    mapping(address => uint256) public addressMintedBalance;

    event SetBaseURI(string baseTokenURI);
    event SetSaleEnabled(bool saleEnabled);
    event SetOnlyWhitelisted(bool onlyWhitelisted);
    event SetPrice(address indexed paymentToken, uint256 price);
    event SetNftLimit(uint256 nftLimit);
    event SetNftPerAddressLimit(uint256 limit);
    event SafePullETH(address indexed user, uint256 balance);
    event SafePullERC20(address indexed user, uint256 balance);

    /**
     * @dev Token URIs will be autogenerated based on `baseURI` and their token IDs.
     * See {ERC721-tokenURI}.
     */
    constructor(
        string memory name,
        string memory symbol,
        string memory baseTokenURI
    ) ERC721(name, symbol) {
        _baseTokenURI = baseTokenURI;
    }

    /* ========================================================================================= */
    /*                                     Public User Functions                                 */
    /* ========================================================================================= */

    /**
     * @notice User can pay (with ETH or ERC20 tokes) and mint one NFT
     * @dev To play it double safe, we use a ReentrancyGuard
     * @dev https://samczsun.com/the-dangers-of-surprising-code/
     */
    function safeMintUser(uint256 quantity_) public payable nonReentrant {
        require(saleEnabled, "sale is currently disabled");
        require(_tokenIdCounter.current() <= nftLimit, "no more NFTs left to mint");
        require(_tokenIdCounter.current() + quantity_ <= nftLimit, "try a smaller mint quantity");

        if (onlyWhitelisted) {
            require(isWhiteListed(msg.sender), "account is not whitelisted");
            require(addressMintedBalance[msg.sender] < nftPerAddressLimit, "max NFT per address exceeded");
        }

        if (paymentToken == address(0)) {
            require(msg.value == quantity_ * price, "ETH sent does not match price");
        } else {
            IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), quantity_ * price);
        }

        // enable multi quantity mint
        for (uint256 i = 0; i < quantity_; i++) {
            addressMintedBalance[msg.sender] += 1;
            _tokenIdCounter.increment();
            _safeMint(msg.sender, _tokenIdCounter.current()); // includes emit Transfer(address(0), to, tokenId);
        }
    }

    function getLastTokenId() external view returns (uint256) {
        return _tokenIdCounter.current();
    }

    function getSupply() external view returns (uint256) {
        return _tokenIdCounter.current();
    }

    function baseURI() external view returns (string memory) {
        return _baseURI();
    }

    /**
     * @dev See {IERC721Metadata-tokenURI}.
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");

        string memory currentBaseUri = _baseURI();
        return bytes(currentBaseUri).length > 0 ? string(abi.encodePacked(currentBaseUri, Strings.toString(tokenId), baseExtension)) : "";
    }

    /* ========================================================================================= */
    /*                                            Management                                     */
    /* ========================================================================================= */

    function setBaseURI(string memory baseTokenURI) public onlyOwner {
        _baseTokenURI = baseTokenURI;
        emit SetBaseURI(baseTokenURI);
    }

    function setSaleEnabled(bool _state) public onlyOwner {
        saleEnabled = _state;
        emit SetSaleEnabled(_state);
    }

    function setOnlyWhitelisted(bool _state) public onlyOwner {
        onlyWhitelisted = _state;
        emit SetOnlyWhitelisted(_state);
    }

    function setPrice(address _paymentToken, uint256 _price) public onlyOwner {
        require(price > 0, "Price can not be zero");
        price = _price;
        paymentToken = _paymentToken;
        emit SetPrice(_paymentToken, _price);
    }

    function setNftLimit(uint256 _nftLimit) public onlyOwner {
        require(_nftLimit >= _tokenIdCounter.current(), "limit less than already minted");
        nftLimit = _nftLimit;
        emit SetNftLimit(_nftLimit);
    }

    function setNftPerAddressLimit(uint256 _limit) public onlyOwner {
        require(_limit > 0, "limit can not be zero");
        nftPerAddressLimit = _limit;
        emit SetNftPerAddressLimit(_limit);
    }

    /**
     * @notice withdraw ETH from contract
     */
    function safePullETH() external onlyOwner {
        uint256 balance = address(this).balance;
        payable(msg.sender).transfer(balance);
        emit SafePullETH(msg.sender, balance);
    }

    /**
     * @notice withdraw all ERC20 tokens for a given token contract address from contract
     */
    function safePullERC20(address erc20) external onlyOwner {
        uint256 balance = IERC20(erc20).balanceOf(address(this));
        IERC20(erc20).safeTransfer(msg.sender, balance);
        emit SafePullERC20(msg.sender, balance);
    }

    /* ========================================================================================= */
    /*           The following functions are overrides required by Solidity.                     */
    /* ========================================================================================= */

    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal override(ERC721, ERC721Enumerable) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}
