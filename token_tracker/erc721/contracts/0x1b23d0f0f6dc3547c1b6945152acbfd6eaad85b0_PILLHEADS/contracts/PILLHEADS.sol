/*
            ...
        ,░░░░░░░░░░
       ╖╢▒▒▒░╜▒▒▒▒▒▒░░
      ╓▒▒▓▓╣▄▒▒▒▒▒▒▒▒▒▒x╓╓▄▄▄@mmmm▄▄▄╖,.
      ║▒▒▒▓▓▓▓▓╣╣╝╙   ▐▓▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▀Ñ▄,
       ▒▒▒╢▓▓▓▀░    ░,▓╣╣▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒╜▒▒▒▀▄
       ╙▒▒╢▓╜░░░░▄▄▓█▓▓╣╢▒▒▒▒▒▒▒▒▒▒▒▒▒░   ▒▒▒ 'X░╖
         ╙▒░▄███████▓▓▓╣╢╣╢╣▒▒▒▒▒▄████▄▄  ▒▒▒   ░▓▒▒
         ╓░██████▓▓▓▓▓▓╣╢╢╣╢╢╣▒▄█▒▒▒▒▒░'▀▄▒▒▒ ▄▄░▒▒▄▒,
        ┌╢█▓▓▓▓▓▓▓▓▓▓▓╣╢╢╢▒╢╣╣▒█▒▒▒▒▒▒░  █▌▒▒  ▀█▒▒▒█▒╖
        ╫█╢▓▓▓▓▓▓▓▓▓▓▓╣╢╣╢╢╢╣╢▒█▒▒▒▒▒▒░  █▌▒▒   ▐█▌▒▒▌▒┐
       ╟▒▒╢╢▓▓▓▓▓▓▓▓▓╣╢╢╢╣╢╢▒╢╢▒█▄▒▒▒▒ ▄█▀▒▒▒    ▀█▒▒▒▒╢
       ╢█╢╢╢╣▓▓▓▓▓▓▓▒▒▒▒╣╢╢╢╢╣▒▒▒▒▀▀▀▀▀   ▒▒▒    ▒██▒▒█╢L
      ]╢▌╢╢╢╣╢▓▓▓▓██▀▒▒▀██▒╢▒╣▒▒▒▒▒▒▒▒    ▒▒▒    ▒██▒▒█▒╡
      ]╢▌╣╢╢╢╢╢╣██▒╢╢╢╢╣╣▒█▌╢╢▒╢▒▒▒╣▒▒    ▒▒▒    ▒██▒▒█╢▌
       ╢█╢╣╣╢╢╣╢█╣╢╢╢╢╢╣╣╢▒█╢▒▒▒▒▒▒▒▒▒    ▒▒▒    ▒██▒▒█╢F
       ╫▐▒╢╣╢╢╢╣██╢╣╢╢╢╣▒▒█▌▒▒▒▒▒▒▒▒▒▒    ▒▒▒    ▐█▒▒▒▌╫
        ╢█╢╢╢╢╣╣╣▒██▄▒▒▄██▒╢▒▒▒▒▒▒▒▒▒▒    ▒▒▒   ,█▌▒▒█╢▓
        ╙▒█╢╢╣╣╢╣╢╣╣▒▒▒▒▒▒▒▒▒▒▒╢▒▒▒▒▒▒    ▒▒▒  ╓█▀▒▒█▒▓
         ╙▒█▒╢╢╢▒▒╢╣╢▒╢╢╢▒▒▒▒▒╢▒▒▒▒▒▒▒    ▒▒▒░▄█ ▒▒█▒▓
          `╬▀▄╢╢▒██▒╢╢╣╢╢╢▒▒╢╢▒▒▒▒▒▒▒▒    ▒▒██▀  ▄▀╫╝
            ╙▒▀▄▒╢▒███▄▒╢╢╢╢▒▒╢╣▒▒▒▒▒▒░ ▄▄██▒░ ╓╜▒▓
              ╙╣▒▓▒╢▒▒▀████▄▄▄▄▒▄▄▄▄███▀▀ ▒▒▒@" r`
                "╩╣▒▀▒▒▒▒▒▒▒▒▀▀▀▀▀▒▒▒▒░ ,A▀▒▒╝`
                    ╙╩▓▒▒▀▒▒▒▒▒▒▒▒▒▒▀▒░-  ┘`
                         `"╙╨▓▓▓▓▓▓▓▓`
                             ]▓▓██▓▓▌
                             ╟▓▓▓▓▓▓▓
                    .╒▄▄Φ╖╖┐,╫▓▓▓▓▓▓▓▓▓▓██▌▄▄▄▄▄
               ╓█████τ██▓▓▓▓▓▓▓▓▓▓▓╫▓▓▓▓▓█▓██████▓▓▄▄,
         ╓g╫▓▓▓▓██████▒▓▓▓▓▓▓▓▓▓▓▓╣╣╣▓▓▓▓▓███████▓▓▓▓▓▓▓▓
       g▓▓▓▓▓▓▓▓███████▒▓▓▓▓▓▓▓▓▓▓▓╣╢╢╢▓▌▓███████▓▓▓▓▓▓▓▓▓
      j▓▓▓▓▓▓▓▓█████████▒▓▓▓▓▓▓▓▓▓▓▓╣╣╢▓╫████████▓▓▓▓▓▓▓▓▓
       ▓▓▓▓▓▓▓▓██████████▌▓▓╢▓▓▓▓▓╣╢▓▓╢▓█████████▓▓▓▓▓▓▓▓▌
       ▓▓▓▓▓▓▓▓▓████████████▓▀█████▓▓████████████▓███▓▓▓▓U
       ╠▓▓▓▓███▓███████████ 𝙋𝙄𝙇𝙇𝙃𝙀𝘼𝘿𝙎 ███████████████▓▓▓▓
        ▓▓▓██████████████████████████████████████████▓▓▓█
        ▓▓▓▓█████████████████████████████████████████▓▓▓█
        ╟▓▓▓▓████████████████████████████████████████▓▓▓▓
        '▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀"


@founder   cfw
           cfw.eth
           @iamcfw

@tech      white lights
           whitelights.eth
           @iamwhitelights

@SPDX-License-Identifier: MIT

*/

pragma solidity ^0.8.13;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "./RaribleV1Royalties.sol";
import "./ERC2981.sol";


contract PILLHEADS is ERC721Burnable, ERC721Pausable, RaribleV1Royalties, ERC2981, AccessControl {

  event Frozen();

  address payable public paymentSplitter = payable(0x000000000000000000000000000000000000dEaD);
  address payable public royaltySplitter = payable(0x000000000000000000000000000000000000dEaD);
  uint256 public bps = 1000;

  bool public frozen = false;
  uint256 public presale1ActivationTime = 1655410800;
  uint256 public presale2ActivationTime = 1655583600;
  uint256 public saleActivationTime = 1655670000;
  uint256 public presalePrice = 100000000000000000;
  uint256 public salePrice = 140000000000000000;
  uint256 public mintsLeft = 6655;
  uint256 public constant MINTS_MAX = 6655;
  string public apiBaseURL;
  string public provenanceHash;

  // Admin identifier
  bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

  // Soulbinding transfer lock -- true upon deploy
  bool public soulbound = true;

  // Merkle Tree root hashes for happylist presale phases
  bytes32 private presale1Root = bytes32(0);
  bytes32 private presale2Root = bytes32(0);

  mapping(address => bool) public presale1Claimed;
  mapping(address => bool) public presale2Claimed;

  // EIP712
  struct Unit { string logIn; }
  string private constant EIP712_DOMAIN  = "EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)";
  string private constant UNIT_TYPE = "Unit(string logIn)";
  bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(abi.encodePacked(EIP712_DOMAIN));
  bytes32 private constant UNIT_TYPEHASH = keccak256(abi.encodePacked(UNIT_TYPE));
  bytes32 private constant DOMAIN_SEPARATOR = keccak256(abi.encode(
    EIP712_DOMAIN_TYPEHASH, // type
    keccak256("PILLHEADS"), // name
    keccak256("1"), // version
    1, // network
    0x3EFfDc0A9F4CDB249C886f4a65970fe14D6677Bb // address hash
  ));

  constructor() ERC721("Pillheads", "PILLHEADS") {
    _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);
  }

  modifier onlyOwner() {
    require(hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "Caller is not owner");
    _;
  }

  modifier onlyAdmin() {
    require(hasRole(ADMIN_ROLE, _msgSender()) || hasRole(DEFAULT_ADMIN_ROLE, _msgSender()), "Caller is not admin");
    _;
  }

  function withdraw() public onlyOwner {
    uint256 balance = address(this).balance;
    paymentSplitter.transfer(balance);
  }

  function supportsInterface(bytes4 interfaceId) public view override(ERC721, RaribleV1Royalties, ERC2981, AccessControl ) returns (bool) {
    return super.supportsInterface(interfaceId);
  }

  function setPaymentSplitter(address payable newAddress) external onlyAdmin {
    paymentSplitter = newAddress;
  }

  function setRoyaltySplitter(address payable newAddress, uint256 newBps) external onlyAdmin {
    royaltySplitter = newAddress;
    bps = newBps;
  }

  function setSoulbound(bool bound) external onlyAdmin {
    soulbound = bound;
  }

  function setPresalePrice(uint256 price) external onlyAdmin {
    presalePrice = price;
  }

  function setSalePrice(uint256 price) external onlyAdmin {
    salePrice = price;
  }

  function setProvenanceHash(string memory hash) external onlyAdmin {
    provenanceHash = hash;
  }

  function setPresale1ActivationTime(uint256 timestampInSeconds) external onlyAdmin {
    presale1ActivationTime = timestampInSeconds;
  }

  function setPresale2ActivationTime(uint256 timestampInSeconds) external onlyAdmin {
    presale2ActivationTime = timestampInSeconds;
  }

  function setSaleActivationTime(uint256 timestampInSeconds) external onlyAdmin {
    saleActivationTime = timestampInSeconds;
  }

  function setPresale1MerkleRoot(bytes32 newRoot) external onlyAdmin {
    presale1Root = newRoot;
  }

  function setPresale2MerkleRoot(bytes32 newRoot) external onlyAdmin {
    presale2Root = newRoot;
  }

  function setAPIBaseURL(string memory url) external onlyAdmin {
    require(frozen == false, "Frozen");
    apiBaseURL = url;
  }

  function presale1Activated() public view returns (bool) {
    return block.timestamp >= presale1ActivationTime;
  }

  function presale2Activated() public view returns (bool) {
    return block.timestamp >= presale2ActivationTime;
  }

  function saleActivated() public view returns (bool) {
    return block.timestamp >= saleActivationTime;
  }

  function _baseURI() internal view override returns (string memory) {
    return apiBaseURL;
  }

  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
    require(_exists(tokenId), "DNE");

    string memory baseURI = _baseURI();
    return bytes(baseURI).length > 0
      ? string(abi.encodePacked(baseURI, tokenID2str(tokenId), ".json"))
      : "";
  }

  function freezeMetadata() external onlyOwner {
    frozen = true;
    emit Frozen();
  }

  /*
   * In case we need to stop transfers AND minting.
   */
  function pause() external onlyAdmin {
    _pause();
  }

  /*
   * In case the emergency is no longer an issue.
   */
  function unpause() external onlyAdmin {
    _unpause();
  }

  function mintOwner(address[] memory addresses) public onlyOwner {
    require(addresses.length <= mintsLeft, "ExceedsSupply");
    for(uint i; i < addresses.length;) {
      // reduce the total pop after minting
      _safeMint(addresses[i], MINTS_MAX - mintsLeft + 1);
      unchecked { mintsLeft--; }
      unchecked { i++; }
    }
  }

  /*
   * The first five parameters of this are used to validate the call.
   * If the max mint, v, r, s, or the merkle proof are incorrect this reverts.
   * If they are all correct, the user can mint <= to their maxMints.
   * After that, they can never mint in this presale again.
   */
  function mintPresale1(uint256 maxMints, uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] calldata merkleProof, uint256 amount) public payable {
    require(presale1Activated(), "TooEarly");
    require(amount <= mintsLeft, "ExceedsSupply");
    require(presalePrice * amount == msg.value, "BadPrice");
    require(verify(msg.sender, sigV, sigR, sigS) == true, "BadSignature");
    require(checkPresale1MerkleProof(merkleProof, maxMints), "BadProof");
    require(amount <= maxMints, "ExceedsPresaleMax");
    require(!presale1Claimed[msg.sender], "Claimed");

    // mint their tokens
    for(uint i; i < amount;) {
      // reduce the total pop after minting
      _safeMint(msg.sender, MINTS_MAX - mintsLeft + 1);
      unchecked { mintsLeft--; }
      unchecked { i++; }
    }

    // lock them out of re-entering presale 1
    unchecked { presale1Claimed[msg.sender] = true; }
  }

  /*
   * The first four parameters of this are used to validate the call.
   * If the v, r, s, or the merkle proof are incorrect this reverts.
   * If they are all correct, the user can mint one token.
   * After that, they can never mint in this presale again.
   */
  function mintPresale2(uint8 sigV, bytes32 sigR, bytes32 sigS, bytes32[] calldata merkleProof, uint256 amount) public payable {
    require(presale2Activated(), "TooEarly");
    require(amount <= mintsLeft, "ExceedsSupply");
    require(presalePrice * amount == msg.value, "BadPrice");
    require(verify(msg.sender, sigV, sigR, sigS) == true, "BadSignature");
    require(checkPresale2MerkleProof(merkleProof), "BadProof");
    require(amount <= 2, "ExceedsPresaleMax");
    require(!presale2Claimed[msg.sender], "Claimed");

    // mint their tokens
    for(uint i; i < amount;) {
      // reduce the total pop after minting
      _safeMint(msg.sender, MINTS_MAX - mintsLeft + 1);
      unchecked { mintsLeft--; }
      unchecked { i++; }
    }

    // lock them out of re-entering presale 2
    unchecked { presale2Claimed[msg.sender] = true; }
  }

  /*
   * For minting pets publicly for ethereum.
   */
  function mintSale(uint8 sigV, bytes32 sigR, bytes32 sigS, uint256 amount) public payable {
    require(saleActivated(), "TooEarly");
    require(amount <= mintsLeft, "ExceedsSupply");
    require(salePrice * amount == msg.value, "BadPrice");
    require(verify(msg.sender, sigV, sigR, sigS) == true, "BadSignature");

    // mint their tokens
    for(uint i; i < amount;) {
      // reduce the total pop after minting
      _safeMint(msg.sender, MINTS_MAX - mintsLeft + 1);
      unchecked { mintsLeft--; }
      unchecked { i++; }
    }
  }

  /*
   * @dev ERC721 -- see _beforeTokenTransfer
   * @dev Locks transfers at times - See _validateTokenTransferability
   */
  function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal override(ERC721, ERC721Pausable) {
    super._beforeTokenTransfer(from, to, tokenId);
    _validateTokenTransferability(from);
  }

  function _validateTokenTransferability(address from) internal view {
    require(!soulbound || from == address(0), "Soulbound");
  }

  /**
   * @dev See {IERC721-setApprovalForAll}.
   */
  function setApprovalForAll(address operator, bool approved) public virtual override {
      require(!soulbound, "Soulbound");
      _setApprovalForAll(_msgSender(), operator, approved);
  }

  /*
   * Rarible/Foundation Royalties Protocol
   */
  function getFeeRecipients(uint256 id) public view override returns (address payable[] memory) {
    require(_exists(id), "DNE");
    address payable[] memory result = new address payable[](1);
    result[0] = royaltySplitter;
    return result;
  }

  /*
   * Rarible/Foundation Royalties Protocol
   */
  function getFeeBps(uint256 id) public view override returns (uint[] memory) {
    require(_exists(id), "DNE");
    uint[] memory result = new uint[](1);
    result[0] = bps;
    return result;
  }

  /*
   * ERC2981 Royalties Standard
   */
  function royaltyInfo(uint256, uint256 _value, bytes calldata _data) external view override returns (address _receiver, uint256 _royaltyAmount, bytes memory _royaltyPaymentData) {
    return (royaltySplitter, _value / (bps / 100), _data);
  }

  /*
   * Generates the hash representation of the struct Unit for EIP-712 usage
   */
  function hashUnit(Unit memory unitobj) private pure returns (bytes32) {
    return keccak256(abi.encodePacked(
      "\x19\x01",
      DOMAIN_SEPARATOR,
      keccak256(abi.encode(
        UNIT_TYPEHASH,
        keccak256(bytes(unitobj.logIn))
      ))
    ));
  }

  /*
   * EIP-712 signature check verification
   */
  function verify(
    address signer,
    uint8 sigV,
    bytes32 sigR,
    bytes32 sigS
  ) private pure returns (bool) {
    Unit memory msgObj = Unit({
      logIn: "Sign this message to login!"
    });

    return signer == ecrecover(hashUnit(msgObj), sigV, sigR, sigS);
  }

  function checkPresale1MerkleProof(bytes32[] calldata merkleProof, uint256 amount) internal view returns (bool){
    bytes32 leaf = keccak256(abi.encodePacked(msg.sender, amount));
    require(MerkleProof.verify(merkleProof, presale1Root, leaf), "BadProof");
    return true;
  }

  function checkPresale2MerkleProof(bytes32[] calldata merkleProof) internal view returns (bool) {
    bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
    require(MerkleProof.verify(merkleProof, presale2Root, leaf), "BadProof");
    return true;
  }

  /*
   * @dev For returning ERC20s we dont know what to do with
   *      if people have issues they can contact owner/devs
   *      and we can send back their tokens.
   */
  function recoverERC20s(IERC20 token, address to, uint256 amount) external onlyAdmin {
    token.approve(address(this), amount);
    token.transferFrom(address(this), to, amount);
  }

  function tokenID2str(uint256 _i) internal pure returns (string memory str) {
    // unused case unless there is a token ID of 0. we don't have one.
    // if (_i == 0) {
    //   return "0";
    // }

    uint256 j = _i;
    uint256 length;
    while (j != 0) {
      length++;
      j /= 10;
    }
    bytes memory bstr = new bytes(length);
    uint256 k = length;
    j = _i;
    while (j != 0) {
      bstr[--k] = bytes1(uint8(48 + j % 10));
      j /= 10;
    }
    str = string(bstr);
  }
}


