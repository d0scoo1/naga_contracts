{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File: contracts/MerkleProof.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/IWhitelistable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n* Edit  : Squeebo\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\nabstract contract IWhitelistable {\r\n\t// Errors\r\n\terror IWhitelistable_NOT_SET();\r\n\terror IWhitelistable_CONSUMED();\r\n\terror IWhitelistable_FORBIDDEN();\r\n\terror IWhitelistable_NO_ALLOWANCE();\r\n\r\n\tbytes32 private _root;\r\n\tmapping( address => uint256 ) private _consumed;\r\n\r\n\tmodifier isWhitelisted( address account_, bytes32[] memory proof_, uint256 passMax_, uint256 qty_ ) {\r\n\t\tif ( qty_ > passMax_ ) {\r\n\t\t\trevert IWhitelistable_FORBIDDEN();\r\n\t\t}\r\n\r\n\t\tuint256 _allowed_ = _checkWhitelistAllowance( account_, proof_, passMax_ );\r\n\r\n\t\tif ( _allowed_ < qty_ ) {\r\n\t\t\trevert IWhitelistable_FORBIDDEN();\r\n\t\t}\r\n\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the pass to protect the whitelist.\r\n\t*/\r\n\tfunction _setWhitelist( bytes32 root_ ) internal virtual {\r\n\t\t_root = root_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the amount that `account_` is allowed to access from the whitelist.\r\n\t* \r\n\t* Requirements:\r\n\t* \r\n\t* - `_root` must be set.\r\n\t* \r\n\t* See {IWhitelistable-_consumeWhitelist}.\r\n\t*/\r\n\tfunction _checkWhitelistAllowance( address account_, bytes32[] memory proof_, uint256 passMax_ ) internal view returns ( uint256 ) {\r\n\t\tif ( _root == 0 ) {\r\n\t\t\trevert IWhitelistable_NOT_SET();\r\n\t\t}\r\n\r\n\t\tif ( _consumed[ account_ ] >= passMax_ ) {\r\n\t\t\trevert IWhitelistable_CONSUMED();\r\n\t\t}\r\n\r\n\t\tif ( ! _computeProof( account_, proof_ ) ) {\r\n\t\t\trevert IWhitelistable_FORBIDDEN();\r\n\t\t}\r\n\r\n\t\tuint256 _res_;\r\n\t\tunchecked {\r\n\t\t\t_res_ = passMax_ - _consumed[ account_ ];\r\n\t\t}\r\n\r\n\t\treturn _res_;\r\n\t}\r\n\r\n\tfunction _computeProof( address account_, bytes32[] memory proof_ ) private view returns ( bool ) {\r\n\t\tbytes32 leaf = keccak256(abi.encodePacked(account_));\r\n\t\treturn MerkleProof.processProof( proof_, leaf ) == _root;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Consumes `amount_` pass passes from `account_`.\r\n\t* \r\n\t* Note: Before calling this function, eligibility should be checked through {IWhitelistable-checkWhitelistAllowance}.\r\n\t*/\r\n\tfunction _consumeWhitelist( address account_, uint256 qty_ ) internal {\r\n\t\tunchecked {\r\n\t\t\t_consumed[ account_ ] += qty_;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// File: contracts/ITradable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\ncontract OwnableDelegateProxy {}\r\n\r\ncontract ProxyRegistry {\r\n\tmapping( address => OwnableDelegateProxy ) public proxies;\r\n}\r\n\r\nabstract contract ITradable {\r\n\t// OpenSea proxy registry address\r\n\taddress[] internal _proxyRegistries;\r\n\r\n\tfunction _setProxyRegistry( address proxyRegistryAddress_ ) internal {\r\n\t\t_proxyRegistries.push( proxyRegistryAddress_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Checks if `operator_` is the registered proxy for `tokenOwner_`.\r\n\t* \r\n\t* Note: Use this function to allow whitelisting of registered proxy.\r\n\t*/\r\n\tfunction _isRegisteredProxy( address tokenOwner_, address operator_ ) internal view returns ( bool ) {\r\n\t\tfor ( uint256 i; i < _proxyRegistries.length; i++ ) {\r\n\t\t\tProxyRegistry _proxyRegistry_ = ProxyRegistry( _proxyRegistries[ i ] );\r\n\t\t\tif ( address( _proxyRegistry_.proxies( tokenOwner_ ) ) == operator_ ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n}\r\n// File: contracts/IPausable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\nabstract contract IPausable {\r\n\t// Errors\r\n\terror IPausable_SALE_NOT_CLOSED();\r\n\terror IPausable_SALE_NOT_OPEN();\r\n\terror IPausable_PRESALE_NOT_OPEN();\r\n\r\n\t// Enum to represent the sale state, defaults to ``CLOSED``.\r\n\tenum SaleState { CLOSED, PRESALE, SALE }\r\n\r\n\t// The current state of the contract\r\n\tSaleState public saleState;\r\n\r\n\t/**\r\n\t* @dev Emitted when the sale state changes\r\n\t*/\r\n\tevent SaleStateChanged( SaleState indexed previousState, SaleState indexed newState );\r\n\r\n\t/**\r\n\t* @dev Sale state can have one of 3 values, ``CLOSED``, ``PRESALE``, or ``SALE``.\r\n\t*/\r\n\tfunction _setSaleState( SaleState newState_ ) internal virtual {\r\n\t\tSaleState _previousState_ = saleState;\r\n\t\tsaleState = newState_;\r\n\t\temit SaleStateChanged( _previousState_, newState_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is not ``CLOSED``.\r\n\t*/\r\n\tmodifier saleClosed {\r\n\t\tif ( saleState != SaleState.CLOSED ) {\r\n\t\t\trevert IPausable_SALE_NOT_CLOSED();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is not ``SALE``.\r\n\t*/\r\n\tmodifier saleOpen {\r\n\t\tif ( saleState != SaleState.SALE ) {\r\n\t\t\trevert IPausable_SALE_NOT_OPEN();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if sale state is not ``PRESALE``.\r\n\t*/\r\n\tmodifier presaleOpen {\r\n\t\tif ( saleState != SaleState.PRESALE ) {\r\n\t\t\trevert IPausable_PRESALE_NOT_OPEN();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n}\r\n\r\n// File: contracts/IOwnable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n* @dev Contract module which provides a basic access control mechanism, where\r\n* there is an account (an owner) that can be granted exclusive access to\r\n* specific functions.\r\n*\r\n* By default, the owner account will be the one that deploys the contract. This\r\n* can later be changed with {transferOwnership}.\r\n*\r\n* This module is used through inheritance. It will make available the modifier\r\n* `onlyOwner`, which can be applied to your functions to restrict their use to\r\n* the owner.\r\n*/\r\nabstract contract IOwnable {\r\n\t// Errors\r\n\terror IOwnable_NOT_OWNER();\r\n\r\n\t// The owner of the contract\r\n\taddress private _owner;\r\n\r\n\t/**\r\n\t* @dev Emitted when contract ownership changes.\r\n\t*/\r\n\tevent OwnershipTransferred( address indexed previousOwner, address indexed newOwner );\r\n\r\n\t/**\r\n\t* @dev Initializes the contract setting the deployer as the initial owner.\r\n\t*/\r\n\tfunction _initIOwnable( address owner_ ) internal {\r\n\t\t_owner = owner_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Returns the address of the current owner.\r\n\t*/\r\n\tfunction owner() public view virtual returns ( address ) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwner() {\r\n\t\tif ( owner() != msg.sender ) {\r\n\t\t\trevert IOwnable_NOT_OWNER();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t* Can only be called by the current owner.\r\n\t*/\r\n\tfunction transferOwnership( address newOwner_ ) public virtual onlyOwner {\r\n\t\taddress _oldOwner_ = _owner;\r\n\t\t_owner = newOwner_;\r\n\t\temit OwnershipTransferred( _oldOwner_, newOwner_ );\r\n\t}\r\n}\r\n\r\n// File: contracts/IERC2981.sol\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\ninterface IERC2981 {\r\n  /**\r\n  * @dev ERC165 bytes to add to interface array - set in parent contract\r\n  * implementing this standard\r\n  *\r\n  * bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\r\n  * bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n  * _registerInterface(_INTERFACE_ID_ERC2981);\r\n  *\r\n  * @notice Called with the sale price to determine how much royalty\r\n  *           is owed and to whom.\r\n  * @param _tokenId - the NFT asset queried for royalty information\r\n  * @param _salePrice - the sale price of the NFT asset specified by _tokenId\r\n  * @return receiver - address of who should be sent the royalty payment\r\n  * @return royaltyAmount - the royalty payment amount for _salePrice\r\n  */\r\n  function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\n// File: contracts/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: contracts/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: contracts/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: contracts/ERC2981Base.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\nabstract contract ERC2981Base is IERC165, IERC2981 {\r\n\t// Errors\r\n\terror IERC2981_INVALID_ROYALTIES();\r\n\r\n\t// Royalty rate is stored out of 10,000 instead of a percentage to allow for\r\n\t// up to two digits below the unit such as 2.5% or 1.25%.\r\n\tuint private constant ROYALTY_BASE = 10000;\r\n\r\n\t// Represents the percentage of royalties on each sale on secondary markets.\r\n\t// Set to 0 to have no royalties.\r\n\tuint256 private _royaltyRate;\r\n\r\n\t// Address of the recipient of the royalties.\r\n\taddress private _royaltyRecipient;\r\n\r\n\tfunction _initERC2981Base( address royaltyRecipient_, uint256 royaltyRate_ ) internal {\r\n\t\t_setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC2981-royaltyInfo}.\r\n\t* \r\n\t* Note: This function should be overriden to revert on a query for non existent token.\r\n\t*/\r\n\tfunction royaltyInfo( uint256, uint256 salePrice_ ) public view virtual override returns ( address, uint256 ) {\r\n\t\tif ( salePrice_ == 0 || _royaltyRate == 0 ) {\r\n\t\t\treturn ( _royaltyRecipient, 0 );\r\n\t\t}\r\n\t\tuint256 _royaltyAmount_ = _royaltyRate * salePrice_ / ROYALTY_BASE;\r\n\t\treturn ( _royaltyRecipient, _royaltyAmount_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Sets the royalty rate to `royaltyRate_` and the royalty recipient to `royaltyRecipient_`.\r\n\t* \r\n\t* Requirements: \r\n\t* \r\n\t* - `royaltyRate_` cannot be higher than `ROYALTY_BASE`;\r\n\t*/\r\n\tfunction _setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) internal virtual {\r\n\t\tif ( royaltyRate_ > ROYALTY_BASE ) {\r\n\t\t\trevert IERC2981_INVALID_ROYALTIES();\r\n\t\t}\r\n\t\t_royaltyRate      = royaltyRate_;\r\n\t\t_royaltyRecipient = royaltyRecipient_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC165-supportsInterface}.\r\n\t*/\r\n\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\r\n\t\treturn \r\n\t\t\tinterfaceId_ == type( IERC2981 ).interfaceId ||\r\n\t\t\tinterfaceId_ == type( IERC165 ).interfaceId;\r\n\t}\r\n}\r\n\r\n// File: contracts/IERC721.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts/IERC721Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n    /**\r\n     * @dev Returns the token collection name.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the token collection symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n     */\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts/ERC721Batch.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Required interface of an ERC721 compliant contract.\r\n*/\r\nabstract contract ERC721Batch is Context, IERC721Metadata {\r\n\t// Errors\r\n\terror IERC721_APPROVE_OWNER();\r\n\terror IERC721_APPROVE_CALLER();\r\n\terror IERC721_CALLER_NOT_APPROVED();\r\n\terror IERC721_NONEXISTANT_TOKEN();\r\n\terror IERC721_NON_ERC721_RECEIVER();\r\n\terror IERC721_NULL_ADDRESS_BALANCE();\r\n\terror IERC721_NULL_ADDRESS_TRANSFER();\r\n\r\n\t// Token name\r\n\tstring private _name;\r\n\r\n\t// Token symbol\r\n\tstring private _symbol;\r\n\r\n\t// Token Base URI\r\n\tstring private _baseURI;\r\n\r\n\t// Token IDs\r\n\tuint256 private _numTokens;\r\n\r\n\t// List of owner addresses\r\n\tmapping( uint256 => address ) private _owners;\r\n\r\n\t// Mapping from token ID to approved address\r\n\tmapping( uint256 => address ) private _tokenApprovals;\r\n\r\n\t// Mapping from owner to operator approvals\r\n\tmapping( address => mapping( address => bool ) ) private _operatorApprovals;\r\n\r\n\t/**\r\n\t* @dev Ensures the token exist. \r\n\t* A token exists if it has been minted and is not owned by the null address.\r\n\t* \r\n\t* @param tokenId_ uint256 ID of the token to verify\r\n\t*/\r\n\tmodifier exists( uint256 tokenId_ ) {\r\n\t\tif ( ! _exists( tokenId_ ) ) {\r\n\t\t\trevert IERC721_NONEXISTANT_TOKEN();\r\n\t\t}\r\n\t\t_;\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function returning the number of tokens in `tokenOwner_`'s account.\r\n\t\t*/\r\n\t\tfunction _balanceOf( address tokenOwner_ ) internal view virtual returns ( uint256 ) {\r\n\t\t\tif ( tokenOwner_ == address( 0 ) ) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _supplyMinted_ = _supplyMinted();\r\n\t\t\tuint256 _count_ = 0;\r\n\t\t\taddress _currentTokenOwner_;\r\n\t\t\tfor ( uint256 i; i < _supplyMinted_; i++ ) {\r\n\t\t\t\tif ( _owners[ i ] != address( 0 ) ) {\r\n\t\t\t\t\t_currentTokenOwner_ = _owners[ i ];\r\n\t\t\t\t}\r\n\t\t\t\tif ( tokenOwner_ == _currentTokenOwner_ ) {\r\n\t\t\t\t\t_count_++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn _count_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n\t\t* The call is not executed if the target address is not a contract.\r\n\t\t*\r\n\t\t* @param from_ address representing the previous owner of the given token ID\r\n\t\t* @param to_ target address that will receive the tokens\r\n\t\t* @param tokenId_ uint256 ID of the token to be transferred\r\n\t\t* @param data_ bytes optional data to send along with the call\r\n\t\t* @return bool whether the call correctly returned the expected magic value\r\n\t\t*/\r\n\t\tfunction _checkOnERC721Received( address from_, address to_, uint256 tokenId_, bytes memory data_ ) internal virtual returns ( bool ) {\r\n\t\t\t// This method relies on extcodesize, which returns 0 for contracts in\r\n\t\t\t// construction, since the code is only stored at the end of the\r\n\t\t\t// constructor execution.\r\n\t\t\t// \r\n\t\t\t// IMPORTANT\r\n\t\t\t// It is unsafe to assume that an address not flagged by this method\r\n\t\t\t// is an externally-owned account (EOA) and not a contract.\r\n\t\t\t//\r\n\t\t\t// Among others, the following types of addresses will not be flagged:\r\n\t\t\t//\r\n\t\t\t//  - an externally-owned account\r\n\t\t\t//  - a contract in construction\r\n\t\t\t//  - an address where a contract will be created\r\n\t\t\t//  - an address where a contract lived, but was destroyed\r\n\t\t\tuint256 _size_;\r\n\t\t\tassembly {\r\n\t\t\t\t_size_ := extcodesize( to_ )\r\n\t\t\t}\r\n\r\n\t\t\t// If address is a contract, check that it is aware of how to handle ERC721 tokens\r\n\t\t\tif ( _size_ > 0 ) {\r\n\t\t\t\ttry IERC721Receiver( to_ ).onERC721Received( _msgSender(), from_, tokenId_, data_ ) returns ( bytes4 retval ) {\r\n\t\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t\t}\r\n\t\t\t\tcatch ( bytes memory reason ) {\r\n\t\t\t\t\tif ( reason.length == 0 ) {\r\n\t\t\t\t\t\trevert IERC721_NON_ERC721_RECEIVER();\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tassembly {\r\n\t\t\t\t\t\t\trevert( add( 32, reason ), mload( reason ) )\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether a token exists. \r\n\t\t* A token exists if it has been minted and is not owned by the null address.\r\n\t\t* \r\n\t\t* @param tokenId_ uint256 ID of the token to verify\r\n\t\t* \r\n\t\t* @return bool whether the token exists\r\n\t\t*/\r\n\t\tfunction _exists( uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n\t\t\treturn tokenId_ < _numTokens;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n\t\t*/\r\n\t\tfunction _initERC721BatchMetadata( string memory name_, string memory symbol_ ) internal {\r\n\t\t\t_name   = name_;\r\n\t\t\t_symbol = symbol_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed \r\n\t\t* to manage tokens on behalf of `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ address that owns tokens\r\n\t\t* @param operator_ address that tries to manage tokens\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to handle the token\r\n\t\t*/\r\n\t\tfunction _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual returns ( bool ) {\r\n\t\t\treturn _operatorApprovals[ tokenOwner_ ][ operator_ ];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed to handle `tokenId_`\r\n\t\t* \r\n\t\t* Note: To avoid multiple checks for the same data, it is assumed that existence of `tokeId_` \r\n\t\t* has been verified prior via {_exists}\r\n\t\t* If it hasn't been verified, this function might panic\r\n\t\t* \r\n\t\t* @param operator_ address that tries to handle the token\r\n\t\t* @param tokenId_ uint256 ID of the token to be handled\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to handle the token\r\n\t\t*/\r\n\t\tfunction _isApprovedOrOwner( address tokenOwner_, address operator_, uint256 tokenId_ ) internal view virtual returns ( bool ) {\r\n\t\t\tbool _isApproved_ = operator_ == tokenOwner_ ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\toperator_ == _tokenApprovals[ tokenId_ ] ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t_isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t\treturn _isApproved_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens and transfers them to `to_`.\r\n\t\t* \r\n\t\t* This internal function can be used to perform token minting.\r\n\t\t* \r\n\t\t* Emits a {ConsecutiveTransfer} event.\r\n\t\t*/\r\n\t\tfunction _mint( address to_, uint256 qty_ ) internal virtual {\r\n\t\t\tuint256 _firstToken_ = _numTokens;\r\n\t\t\tuint256 _lastToken_ = _firstToken_ + qty_ - 1;\r\n\r\n\t\t\t_owners[ _firstToken_ ] = to_;\r\n\t\t\tif ( _lastToken_ > _firstToken_ ) {\r\n\t\t\t\t_owners[ _lastToken_ ] = to_;\r\n\t\t\t}\r\n\t\t\tfor ( uint256 i; i < qty_; i ++ ) {\r\n\t\t\t\temit Transfer( address( 0 ), to_, _firstToken_ + i );\r\n\t\t\t}\r\n\t\t\t_numTokens = _lastToken_ + 1;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning the owner of the `tokenId_` token.\r\n\t\t* \r\n\t\t* @param tokenId_ uint256 ID of the token to verify\r\n\t\t* \r\n\t\t* @return address the address of the token owner\r\n\t\t*/\r\n\t\tfunction _ownerOf( uint256 tokenId_ ) internal view virtual returns ( address ) {\r\n\t\t\tuint256 _tokenId_ = tokenId_;\r\n\t\t\taddress _tokenOwner_ = _owners[ _tokenId_ ];\r\n\t\t\twhile ( _tokenOwner_ == address( 0 ) ) {\r\n\t\t\t\t_tokenId_ --;\r\n\t\t\t\t_tokenOwner_ = _owners[ _tokenId_ ];\r\n\t\t\t}\r\n\r\n\t\t\treturn _tokenOwner_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function used to set the base URI of the collection.\r\n\t\t*/\r\n\t\tfunction _setBaseURI( string memory baseURI_ ) internal virtual {\r\n\t\t\t_baseURI = baseURI_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning the total number of tokens minted\r\n\t\t* \r\n\t\t* @return uint256 the number of tokens that have been minted so far\r\n\t\t*/\r\n\t\tfunction _supplyMinted() internal view virtual returns ( uint256 ) {\r\n\t\t\treturn _numTokens;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t\t*/\r\n\t\tfunction _toString( uint256 value ) internal pure returns ( string memory ) {\r\n\t\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\t\t\tif ( value == 0 ) {\r\n\t\t\t\treturn \"0\";\r\n\t\t\t}\r\n\t\t\tuint256 temp = value;\r\n\t\t\tuint256 digits;\r\n\t\t\twhile ( temp != 0 ) {\r\n\t\t\t\tdigits ++;\r\n\t\t\t\ttemp /= 10;\r\n\t\t\t}\r\n\t\t\tbytes memory buffer = new bytes( digits );\r\n\t\t\twhile ( value != 0 ) {\r\n\t\t\t\tdigits -= 1;\r\n\t\t\t\tbuffer[ digits ] = bytes1( uint8( 48 + uint256( value % 10 ) ) );\r\n\t\t\t\tvalue /= 10;\r\n\t\t\t}\r\n\t\t\treturn string( buffer );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Transfers `tokenId_` from `from_` to `to_`.\r\n\t\t*\r\n\t\t* This internal function can be used to implement alternative mechanisms to perform \r\n\t\t* token transfer, such as signature-based, or token burning.\r\n\t\t* \r\n\t\t* Emits a {Transfer} event.\r\n\t\t*/\r\n\t\tfunction _transfer( address from_, address to_, uint256 tokenId_ ) internal virtual {\r\n\t\t\t_tokenApprovals[ tokenId_ ] = address( 0 );\r\n\t\t\tuint256 _previousId_ = tokenId_ > 0 ? tokenId_ - 1 : 0;\r\n\t\t\tuint256 _nextId_     = tokenId_ + 1;\r\n\t\t\tbool _previousShouldUpdate_ = _previousId_ < tokenId_ &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_exists( _previousId_ ) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_owners[ _previousId_ ] == address( 0 );\r\n\t\t\tbool _nextShouldUpdate_ = _exists( _nextId_ ) &&\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t_owners[ _nextId_ ] == address( 0 );\r\n\r\n\t\t\tif ( _previousShouldUpdate_ ) {\r\n\t\t\t\t_owners[ _previousId_ ] = from_;\r\n\t\t\t}\r\n\r\n\t\t\tif ( _nextShouldUpdate_ ) {\r\n\t\t\t\t_owners[ _nextId_ ] = from_;\r\n\t\t\t}\r\n\r\n\t\t\t_owners[ tokenId_ ] = to_;\r\n\r\n\t\t\temit Transfer( from_, to_, tokenId_ );\r\n\t\t}\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev See {IERC721-approve}.\r\n\t\t*/\r\n\t\tfunction approve( address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == _tokenOwner_ ) {\r\n\t\t\t\trevert IERC721_APPROVE_OWNER();\r\n\t\t\t}\r\n\r\n\t\t\t_tokenApprovals[ tokenId_ ] = to_;\r\n\t\t\temit Approval( _tokenOwner_, to_, tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-safeTransferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction safeTransferFrom( address, address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_NULL_ADDRESS_TRANSFER();\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\r\n\t\t\tif ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, \"\" ) ) {\r\n\t\t\t\trevert IERC721_NON_ERC721_RECEIVER();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-safeTransferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction safeTransferFrom( address, address to_, uint256 tokenId_, bytes calldata data_ ) external virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_NULL_ADDRESS_TRANSFER();\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\r\n\t\t\tif ( ! _checkOnERC721Received( _tokenOwner_, to_, tokenId_, data_ ) ) {\r\n\t\t\t\trevert IERC721_NON_ERC721_RECEIVER();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-setApprovalForAll}.\r\n\t\t*/\r\n\t\tfunction setApprovalForAll( address operator_, bool approved_ ) public virtual override {\r\n\t\t\taddress _account_ = _msgSender();\r\n\t\t\tif ( operator_ == _account_ ) {\r\n\t\t\t\trevert IERC721_APPROVE_CALLER();\r\n\t\t\t}\r\n\r\n\t\t\t_operatorApprovals[ _account_ ][ operator_ ] = approved_;\r\n\t\t\temit ApprovalForAll( _account_, operator_, approved_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721-transferFrom}.\r\n\t\t* \r\n\t\t* Note: We can ignore `from_` as we can compare everything to the actual token owner, \r\n\t\t* but we cannot remove this parameter to stay in conformity with IERC721\r\n\t\t*/\r\n\t\tfunction transferFrom( address, address to_, uint256 tokenId_ ) external virtual exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\r\n\t\t\tif ( to_ == address( 0 ) ) {\r\n\t\t\t\trevert IERC721_NULL_ADDRESS_TRANSFER();\r\n\t\t\t}\r\n\r\n\t\t\t_transfer( _tokenOwner_, to_, tokenId_ );\r\n\t\t}\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Returns the number of tokens in `tokenOwner_`'s account.\r\n\t\t*/\r\n\t\tfunction balanceOf( address tokenOwner_ ) external view virtual returns ( uint256 ) {\r\n\t\t\treturn _balanceOf( tokenOwner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the account approved for `tokenId_` token.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction getApproved( uint256 tokenId_ ) external view virtual exists( tokenId_ ) returns ( address ) {\r\n\t\t\treturn _tokenApprovals[ tokenId_ ];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns if the `operator_` is allowed to manage all of the assets of `tokenOwner_`.\r\n\t\t*\r\n\t\t* See {setApprovalForAll}\r\n\t\t*/\r\n\t\tfunction isApprovedForAll( address tokenOwner_, address operator_ ) external view virtual returns ( bool ) {\r\n\t\t\treturn _isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Metadata-name}.\r\n\t\t*/\r\n\t\tfunction name() public view virtual override returns ( string memory ) {\r\n\t\t\treturn _name;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the owner of the `tokenId_` token.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction ownerOf( uint256 tokenId_ ) external view virtual exists( tokenId_ ) returns ( address ) {\r\n\t\t\treturn _ownerOf( tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC165-supportsInterface}.\r\n\t\t*/\r\n\t\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override returns ( bool ) {\r\n\t\t\treturn \r\n\t\t\t\tinterfaceId_ == type( IERC721Metadata ).interfaceId ||\r\n\t\t\t\tinterfaceId_ == type( IERC721 ).interfaceId ||\r\n\t\t\t\tinterfaceId_ == type( IERC165 ).interfaceId;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Metadata-symbol}.\r\n\t\t*/\r\n\t\tfunction symbol() public view virtual override returns ( string memory ) {\r\n\t\t\treturn _symbol;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC721Metadata-tokenURI}.\r\n\t\t*/\r\n\t\tfunction tokenURI( uint256 tokenId_ ) public view virtual override exists( tokenId_ ) returns ( string memory ) {\r\n\t\t\treturn bytes( _baseURI ).length > 0 ? string( abi.encodePacked( _baseURI, _toString( tokenId_ ) ) ) : _toString( tokenId_ );\r\n\t\t}\r\n}\r\n\r\n// File: contracts/ERC721BatchStakable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\n/**\r\n* @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n* the Metadata extension and the Enumerable extension.\r\n* \r\n* Note: This implementation is only compatible with a sequential order of tokens minted.\r\n* If you need to mint tokens in a random order, you will need to override the following functions:\r\n* Note also that this implementations is fairly inefficient and as such, \r\n* those functions should be avoided inside non-view functions.\r\n*/\r\nabstract contract ERC721BatchStakable is ERC721Batch, IERC721Receiver {\r\n\t// Mapping of tokenId to stakeholder address\r\n\tmapping( uint256 => address ) internal _stakedOwners;\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function returning the number of tokens staked by `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction _balanceOfStaked( address tokenOwner_ ) internal view virtual returns ( uint256 ) {\r\n\t\t\tif ( tokenOwner_ == address( 0 ) ) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _supplyMinted_ = _supplyMinted();\r\n\t\t\tuint256 _count_ = 0;\r\n\t\t\tfor ( uint256 i; i < _supplyMinted_; i++ ) {\r\n\t\t\t\tif ( _stakedOwners[ i ] == tokenOwner_ ) {\r\n\t\t\t\t\t_count_++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn _count_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that mints `qtyMinted_` tokens and stakes `qtyStaked_` of them to the count of `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction _mintAndStake( address tokenOwner_, uint256 qtyMinted_, uint256 qtyStaked_ ) internal {\r\n\t\t\tuint256 _qtyNotStaked_;\r\n\t\t\tuint256 _qtyStaked_ = qtyStaked_;\r\n\t\t\tif ( qtyStaked_ > qtyMinted_ ) {\r\n\t\t\t\t_qtyStaked_ = qtyMinted_;\r\n\t\t\t}\r\n\t\t\telse if ( qtyStaked_ < qtyMinted_ ) {\r\n\t\t\t\t_qtyNotStaked_ = qtyMinted_ - qtyStaked_;\r\n\t\t\t}\r\n\t\t\tif ( _qtyStaked_ > 0 ) {\r\n\t\t\t\t_mintInContract( tokenOwner_, _qtyStaked_ );\r\n\t\t\t}\r\n\t\t\tif ( _qtyNotStaked_ > 0 ) {\r\n\t\t\t\t_mint( tokenOwner_, _qtyNotStaked_ );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that mints `qtyStaked_` tokens and stakes them to the count of `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction _mintInContract( address tokenOwner_, uint256 qtyStaked_ ) internal {\r\n\t\t\tuint256 _currentToken_ = _supplyMinted();\r\n\t\t\tuint256 _lastToken_ = _currentToken_ + qtyStaked_ - 1;\r\n\r\n\t\t\twhile ( _currentToken_ <= _lastToken_ ) {\r\n\t\t\t\t_stakedOwners[ _currentToken_ ] = tokenOwner_;\r\n\t\t\t\t_currentToken_ ++;\r\n\t\t\t}\r\n\r\n\t\t\t_mint( address( this ), qtyStaked_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function returning the owner of the staked token number `tokenId_`.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction _ownerOfStaked( uint256 tokenId_ ) internal view virtual returns ( address ) {\r\n\t\t\treturn _stakedOwners[ tokenId_ ];\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that stakes the token number `tokenId_` to the count of `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction _stake( address tokenOwner_, uint256 tokenId_ ) internal {\r\n\t\t\t_stakedOwners[ tokenId_ ] = tokenOwner_;\r\n\t\t\t_transfer( tokenOwner_, address( this ), tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Internal function that unstakes the token `tokenId_` and transfers it back to `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction _unstake( address tokenOwner_, uint256 tokenId_ ) internal {\r\n\t\t\t_transfer( address( this ), tokenOwner_, tokenId_ );\r\n\t\t\tdelete _stakedOwners[ tokenId_ ];\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Stakes the token `tokenId_` to the count of its owner.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be allowed to manage `tokenId_` or its owner's tokens.\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction stake( uint256 tokenId_ ) external exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\t\t\t_stake( _tokenOwner_, tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Unstakes the token `tokenId_` and returns it to its owner.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be allowed to manage `tokenId_` or its owner's tokens.\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction unstake( uint256 tokenId_ ) external exists( tokenId_ ) {\r\n\t\t\taddress _operator_ = _msgSender();\r\n\t\t\taddress _tokenOwner_ = _ownerOfStaked( tokenId_ );\r\n\t\t\tbool _isApproved_ = _isApprovedOrOwner( _tokenOwner_, _operator_, tokenId_ );\r\n\r\n\t\t\tif ( ! _isApproved_ ) {\r\n\t\t\t\trevert IERC721_CALLER_NOT_APPROVED();\r\n\t\t\t}\r\n\t\t\t_unstake( _tokenOwner_, tokenId_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Returns the number of tokens owned by `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction balanceOf( address tokenOwner_ ) public view virtual override returns ( uint256 balance ) {\r\n\t\t\treturn _balanceOfStaked( tokenOwner_ ) + _balanceOf( tokenOwner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the number of tokens staked by `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction balanceOfStaked( address tokenOwner_ ) public view virtual returns ( uint256 ) {\r\n\t\t\treturn _balanceOfStaked( tokenOwner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the owner of token number `tokenId_`.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction ownerOf( uint256 tokenId_ ) public view virtual override exists( tokenId_ ) returns ( address ) {\r\n\t\t\taddress _tokenOwner_ = _ownerOf( tokenId_ );\r\n\t\t\tif ( _tokenOwner_ == address( this ) ) {\r\n\t\t\t\treturn _ownerOfStaked( tokenId_ );\r\n\t\t\t}\r\n\t\t\treturn _tokenOwner_;\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the owner of staked token number `tokenId_`.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction ownerOfStaked( uint256 tokenId_ ) public view virtual exists( tokenId_ ) returns ( address ) {\r\n\t\t\treturn _ownerOfStaked( tokenId_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            PURE            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Signals that this contract knows how to handle ERC721 tokens.\r\n\t\t*/\r\n\t\tfunction onERC721Received( address, address, uint256, bytes memory ) public override pure returns ( bytes4 ) {\r\n\t\t\treturn type( IERC721Receiver ).interfaceId;\r\n\t\t}\r\n\t// **************************************\r\n}\r\n\r\n// File: contracts/IERC721Enumerable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Enumerable is IERC721 {\r\n    /**\r\n     * @dev Returns the total amount of tokens stored by the contract.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n     */\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * Use along with {totalSupply} to enumerate all tokens.\r\n     */\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\n\r\n// File: contracts/ERC721BatchEnumerable.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\n/**\r\n* @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n* the Metadata extension and the Enumerable extension.\r\n* \r\n* Note: This implementation is only compatible with a sequential order of tokens minted.\r\n* If you need to mint tokens in a random order, you will need to override the following functions:\r\n* Note also that this implementations is fairly inefficient and as such, \r\n* those functions should be avoided inside non-view functions.\r\n*/\r\nabstract contract ERC721BatchEnumerable is ERC721Batch, IERC721Enumerable {\r\n\t// Errors\r\n\terror IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS();\r\n\terror IERC721Enumerable_INDEX_OUT_OF_BOUNDS();\r\n\r\n\t/**\r\n\t* @dev See {IERC165-supportsInterface}.\r\n\t*/\r\n\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override(IERC165, ERC721Batch) returns ( bool ) {\r\n\t\treturn \r\n\t\t\tinterfaceId_ == type( IERC721Enumerable ).interfaceId ||\r\n\t\t\tsuper.supportsInterface( interfaceId_ );\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC721Enumerable-tokenByIndex}.\r\n\t*/\r\n\tfunction tokenByIndex( uint256 index_ ) public view virtual override returns ( uint256 ) {\r\n\t\tif ( index_ >= _supplyMinted() ) {\r\n\t\t\trevert IERC721Enumerable_INDEX_OUT_OF_BOUNDS();\r\n\t\t}\r\n\t\treturn index_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n\t*/\r\n\tfunction tokenOfOwnerByIndex( address tokenOwner_, uint256 index_ ) public view virtual override returns ( uint256 tokenId ) {\r\n\t\tuint256 _supplyMinted_ = _supplyMinted();\r\n\t\tif ( index_ >= _balanceOf( tokenOwner_ ) ) {\r\n\t\t\trevert IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS();\r\n\t\t}\r\n\r\n\t\tuint256 _count_ = 0;\r\n\t\tfor ( uint256 i = 0; i < _supplyMinted_; i++ ) {\r\n\t\t\tif ( _exists( i ) && tokenOwner_ == _ownerOf( i ) ) {\r\n\t\t\t\tif ( index_ == _count_ ) {\r\n\t\t\t\t\treturn i;\r\n\t\t\t\t}\r\n\t\t\t\t_count_++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t* @dev See {IERC721Enumerable-totalSupply}.\r\n\t*/\r\n\tfunction totalSupply() public view virtual override returns ( uint256 ) {\r\n\t\tuint256 _supplyMinted_ = _supplyMinted();\r\n\t\tuint256 _count_ = 0;\r\n\t\tfor ( uint256 i; i < _supplyMinted_; i++ ) {\r\n\t\t\tif ( _exists( i ) ) {\r\n\t\t\t\t_count_++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn _count_;\r\n\t}\r\n}\r\n\r\n// File: contracts/CCFoundersKeys.sol\r\n\r\n\r\n\r\n/**\r\n* Author: Lambdalf the White\r\n*/\r\n\r\npragma solidity 0.8.10;\r\n\r\n\r\n\r\ncontract CCFoundersKeys is ERC721BatchEnumerable, ERC721BatchStakable, ERC2981Base, IOwnable, IPausable, ITradable, IWhitelistable {\r\n\t// Events\r\n\tevent PaymentReleased( address indexed from, address[] indexed tos, uint256[] indexed amounts );\r\n\r\n\t// Errors\r\n\terror CCFoundersKeys_ARRAY_LENGTH_MISMATCH();\r\n\terror CCFoundersKeys_FORBIDDEN();\r\n\terror CCFoundersKeys_INCORRECT_PRICE();\r\n\terror CCFoundersKeys_INSUFFICIENT_KEY_BALANCE();\r\n\terror CCFoundersKeys_MAX_BATCH();\r\n\terror CCFoundersKeys_MAX_RESERVE();\r\n\terror CCFoundersKeys_MAX_SUPPLY();\r\n\terror CCFoundersKeys_NO_ETHER_BALANCE();\r\n\terror CCFoundersKeys_TRANSFER_FAIL();\r\n\r\n\t// Founders Key whitelist mint price\r\n\tuint public immutable WL_MINT_PRICE; // = 0.069 ether;\r\n\r\n\t// Founders Key public mint price\r\n\tuint public immutable PUBLIC_MINT_PRICE; // = 0.1 ether;\r\n\r\n\t// Max supply\r\n\tuint public immutable MAX_SUPPLY;\r\n\r\n\t// Max TX\r\n\tuint public immutable MAX_BATCH;\r\n\r\n\t// 2C Safe wallet ~ 90%\r\n\taddress private immutable _CC_SAFE;\r\n\r\n\t// 2C Operations wallet ~ 5%\r\n\taddress private immutable _CC_CHARITY;\r\n\r\n\t// 2C Founders wallet ~ 2.5%\r\n\taddress private immutable _CC_FOUNDERS;\r\n\r\n\t// 2C Community wallet ~ 2.5%\r\n\taddress private immutable _CC_COMMUNITY;\r\n\r\n\t// Mapping of Anon holders to amount of free key claimable\r\n\tmapping( address => uint256 ) public anonClaimList;\r\n\r\n\tuint256 private _reserve;\r\n\r\n\tconstructor(\r\n\t\tuint256 reserve_,\r\n\t\tuint256 maxBatch_,\r\n\t\tuint256 maxSupply_,\r\n\t\tuint256 royaltyRate_,\r\n\t\tuint256 wlMintPrice_,\r\n\t\tuint256 publicMintPrice_,\r\n\t\tstring memory name_,\r\n\t\tstring memory symbol_,\r\n\t\tstring memory baseURI_,\r\n\t\t// address devAddress_,\r\n\t\taddress[] memory wallets_\r\n\t) {\r\n\t\taddress _contractOwner_ = _msgSender();\r\n\t\t_initIOwnable( _contractOwner_ );\r\n\t\t_initERC2981Base( _contractOwner_, royaltyRate_ );\r\n\t\t_initERC721BatchMetadata( name_, symbol_ );\r\n\t\t_setBaseURI( baseURI_ );\r\n\t\t_CC_SAFE          = wallets_[ 0 ];\r\n\t\t_CC_CHARITY       = wallets_[ 1 ];\r\n\t\t_CC_FOUNDERS      = wallets_[ 2 ];\r\n\t\t_CC_COMMUNITY     = wallets_[ 3 ];\r\n\t\t_reserve          = reserve_;\r\n\t\tMAX_BATCH         = maxBatch_;\r\n\t\tMAX_SUPPLY        = maxSupply_;\r\n\t\tWL_MINT_PRICE     = wlMintPrice_;\r\n\t\tPUBLIC_MINT_PRICE = publicMintPrice_;\r\n\t\t// _mintAndStake( devAddress_, 5 );\r\n\t}\r\n\r\n\t// **************************************\r\n\t// *****          INTERNAL          *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Internal function returning whether `operator_` is allowed to manage tokens on behalf of `tokenOwner_`.\r\n\t\t* \r\n\t\t* @param tokenOwner_ address that owns tokens\r\n\t\t* @param operator_ address that tries to manage tokens\r\n\t\t* \r\n\t\t* @return bool whether `operator_` is allowed to manage the token\r\n\t\t*/\r\n\t\tfunction _isApprovedForAll( address tokenOwner_, address operator_ ) internal view virtual override returns ( bool ) {\r\n\t\t\treturn _isRegisteredProxy( tokenOwner_, operator_ ) ||\r\n\t\t\t\t\t\t super._isApprovedForAll( tokenOwner_, operator_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Replacement for Solidity's `transfer`: sends `amount_` wei to\r\n\t\t* `recipient_`, forwarding all available gas and reverting on errors.\r\n\t\t*\r\n\t\t* https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t\t* of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t\t* imposed by `transfer`, making them unable to receive funds via\r\n\t\t* `transfer`. {sendValue} removes this limitation.\r\n\t\t*\r\n\t\t* https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t\t*\r\n\t\t* IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t\t* taken to not create reentrancy vulnerabilities. Consider using\r\n\t\t* {ReentrancyGuard} or the\r\n\t\t* https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t\t*/\r\n\t\tfunction _sendValue( address payable recipient_, uint256 amount_ ) internal {\r\n\t\t\tif ( address( this ).balance < amount_ ) {\r\n\t\t\t\trevert CCFoundersKeys_INCORRECT_PRICE();\r\n\t\t\t}\r\n\t\t\t( bool _success_, ) = recipient_.call{ value: amount_ }( \"\" );\r\n\t\t\tif ( ! _success_ ) {\r\n\t\t\t\trevert CCFoundersKeys_TRANSFER_FAIL();\r\n\t\t\t}\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****           PUBLIC           *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens and transfers them to the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.PRESALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must be whitelisted.\r\n\t\t*/\r\n\t\tfunction claim( uint256 qty_ ) external presaleOpen {\r\n\t\t\taddress _account_   = _msgSender();\r\n\t\t\tif ( qty_ > anonClaimList[ _account_ ] ) {\r\n\t\t\t\trevert CCFoundersKeys_FORBIDDEN();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _endSupply_ = _supplyMinted() + qty_;\r\n\t\t\tif ( _endSupply_ > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tanonClaimList[ _account_ ] -= qty_;\r\n\t\t\t}\r\n\t\t\t_mint( _account_, qty_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens, stakes `qtyStaked_` of them to the count of the caller, and transfers the remaining to them.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.PRESALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must be whitelisted.\r\n\t\t* - If `qtyStaked_` is higher than `qty_`, only `qty_` tokens are staked.\r\n\t\t*/\r\n\t\tfunction claimAndStake( uint256 qty_, uint256 qtyStaked_ ) external presaleOpen {\r\n\t\t\taddress _account_   = _msgSender();\r\n\t\t\tif ( qty_ > anonClaimList[ _account_ ] ) {\r\n\t\t\t\trevert CCFoundersKeys_FORBIDDEN();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _endSupply_ = _supplyMinted() + qty_;\r\n\t\t\tif ( _endSupply_ > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tunchecked {\r\n\t\t\t\tanonClaimList[ _account_ ] -= qty_;\r\n\t\t\t}\r\n\t\t\t_mintAndStake( _account_, qty_, qtyStaked_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints a token and transfers it to the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.PRESALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must send enough ether to pay for 1 token at presale price.\r\n\t\t* - Caller must be whitelisted.\r\n\t\t*/\r\n\t\tfunction mintPreSale( bytes32[] memory proof_ ) external payable presaleOpen isWhitelisted( _msgSender(), proof_, 1, 1 ) {\r\n\t\t\tif ( _supplyMinted() + 1 > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tif ( WL_MINT_PRICE != msg.value ) {\r\n\t\t\t\trevert CCFoundersKeys_INCORRECT_PRICE();\r\n\t\t\t}\r\n\r\n\t\t\taddress _account_    = _msgSender();\r\n\t\t\t_consumeWhitelist( _account_, 1 );\r\n\t\t\t_mint( _account_, 1 );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints a token and stakes it to the count of the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.PRESALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must send enough ether to pay for 1 token at presale price.\r\n\t\t* - Caller must be whitelisted.\r\n\t\t*/\r\n\t\tfunction mintPreSaleAndStake( bytes32[] memory proof_ ) external payable presaleOpen isWhitelisted( _msgSender(), proof_, 1, 1 ) {\r\n\t\t\tif ( _supplyMinted() + 1 > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tif ( WL_MINT_PRICE != msg.value ) {\r\n\t\t\t\trevert CCFoundersKeys_INCORRECT_PRICE();\r\n\t\t\t}\r\n\r\n\t\t\taddress _account_    = _msgSender();\r\n\t\t\t_consumeWhitelist( _account_, 1 );\r\n\t\t\t_mintAndStake( _account_, 1, 1 );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens and transfers them to the caller.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.SALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must send enough ether to pay for `qty_` tokens at public sale price.\r\n\t\t*/\r\n\t\tfunction mint( uint256 qty_ ) external payable saleOpen {\r\n\t\t\tif ( qty_ > MAX_BATCH ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_BATCH();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _endSupply_  = _supplyMinted() + qty_;\r\n\t\t\tif ( _endSupply_ > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tif ( qty_ * PUBLIC_MINT_PRICE != msg.value ) {\r\n\t\t\t\trevert CCFoundersKeys_INCORRECT_PRICE();\r\n\t\t\t}\r\n\t\t\taddress _account_    = _msgSender();\r\n\t\t\t_mint( _account_, qty_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Mints `qty_` tokens, stakes `qtyStaked_` of them to the count of the caller, and transfers the remaining to them.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Sale state must be {SaleState.SALE}.\r\n\t\t* - There must be enough tokens left to mint outside of the reserve.\r\n\t\t* - Caller must send enough ether to pay for `qty_` tokens at public sale price.\r\n\t\t* - If `qtyStaked_` is higher than `qty_`, only `qty_` tokens are staked.\r\n\t\t*/\r\n\t\tfunction mintAndStake( uint256 qty_, uint256 qtyStaked_ ) external payable saleOpen {\r\n\t\t\tif ( qty_ > MAX_BATCH ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_BATCH();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _endSupply_  = _supplyMinted() + qty_;\r\n\t\t\tif ( _endSupply_ > MAX_SUPPLY - _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_SUPPLY();\r\n\t\t\t}\r\n\r\n\t\t\tif ( qty_ * PUBLIC_MINT_PRICE != msg.value ) {\r\n\t\t\t\trevert CCFoundersKeys_INCORRECT_PRICE();\r\n\t\t\t}\r\n\t\t\taddress _account_    = _msgSender();\r\n\t\t\t_mintAndStake( _account_, qty_, qtyStaked_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****       CONTRACT_OWNER       *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Mints `amounts_` tokens and transfers them to `accounts_`.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - `accounts_` and `amounts_` must have the same length.\r\n\t\t* - There must be enough tokens left in the reserve.\r\n\t\t*/\r\n\t\tfunction airdrop( address[] memory accounts_, uint256[] memory amounts_ ) external onlyOwner {\r\n\t\t\tuint256 _len_ = amounts_.length;\r\n\t\t\tif ( _len_ != accounts_.length ) {\r\n\t\t\t\trevert CCFoundersKeys_ARRAY_LENGTH_MISMATCH();\r\n\t\t\t}\r\n\t\t\tuint _totalQty_;\r\n\t\t\tfor ( uint256 i = _len_; i > 0; i -- ) {\r\n\t\t\t\t_totalQty_ += amounts_[ i - 1 ];\r\n\t\t\t}\r\n\t\t\tif ( _totalQty_ > _reserve ) {\r\n\t\t\t\trevert CCFoundersKeys_MAX_RESERVE();\r\n\t\t\t}\r\n\t\t\tunchecked {\r\n\t\t\t\t_reserve -= _totalQty_;\r\n\t\t\t}\r\n\t\t\tfor ( uint256 i = _len_; i > 0; i -- ) {\r\n\t\t\t\t_mint( accounts_[ i - 1], amounts_[ i - 1] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Saves `accounts_` in the anon claim list.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - Sale state must be {SaleState.CLOSED}.\r\n\t\t* - `accounts_` and `amounts_` must have the same length.\r\n\t\t*/\r\n\t\tfunction setAnonClaimList( address[] memory accounts_, uint256[] memory amounts_ ) external onlyOwner saleClosed {\r\n\t\t\tuint256 _len_ = amounts_.length;\r\n\t\t\tif ( _len_ != accounts_.length ) {\r\n\t\t\t\trevert CCFoundersKeys_ARRAY_LENGTH_MISMATCH();\r\n\t\t\t}\r\n\t\t\tfor ( uint256 i; i < _len_; i ++ ) {\r\n\t\t\t\tanonClaimList[ accounts_[ i ] ] = amounts_[ i ];\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {ITradable-setProxyRegistry}.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setProxyRegistry( address proxyRegistryAddress_ ) external onlyOwner {\r\n\t\t\t_setProxyRegistry( proxyRegistryAddress_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Updates the royalty recipient and rate.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setRoyaltyInfo( address royaltyRecipient_, uint256 royaltyRate_ ) external onlyOwner {\r\n\t\t\t_setRoyaltyInfo( royaltyRecipient_, royaltyRate_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IPausable-setSaleState}.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction setSaleState( SaleState newState_ ) external onlyOwner {\r\n\t\t\t_setSaleState( newState_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IWhitelistable-setWhitelist}.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t* - Sale state must be {SaleState.CLOSED}.\r\n\t\t*/\r\n\t\tfunction setWhitelist( bytes32 root_ ) external onlyOwner saleClosed {\r\n\t\t\t_setWhitelist( root_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Withdraws all the money stored in the contract and splits it amongst the set wallets.\r\n\t\t* \r\n\t\t* Requirements:\r\n\t\t* \r\n\t\t* - Caller must be the contract owner.\r\n\t\t*/\r\n\t\tfunction withdraw() external onlyOwner {\r\n\t\t\tuint256 _balance_ = address(this).balance;\r\n\t\t\tif ( _balance_ == 0 ) {\r\n\t\t\t\trevert CCFoundersKeys_NO_ETHER_BALANCE();\r\n\t\t\t}\r\n\r\n\t\t\tuint256 _safeShare_ = _balance_ * 900 / 1000;\r\n\t\t\tuint256 _charityShare_ = _balance_ * 50 / 1000;\r\n\t\t\tuint256 _othersShare_ = _charityShare_ / 2;\r\n\t\t\t_sendValue( payable( _CC_COMMUNITY ), _othersShare_ );\r\n\t\t\t_sendValue( payable( _CC_FOUNDERS ), _othersShare_ );\r\n\t\t\t_sendValue( payable( _CC_CHARITY ), _charityShare_ );\r\n\t\t\t_sendValue( payable( _CC_SAFE ), _safeShare_ );\r\n\r\n\t\t\taddress[] memory _tos_ = new address[]( 4 );\r\n\t\t\t_tos_[ 0 ] = _CC_COMMUNITY;\r\n\t\t\t_tos_[ 1 ] = _CC_FOUNDERS;\r\n\t\t\t_tos_[ 2 ] = _CC_CHARITY;\r\n\t\t\t_tos_[ 3 ] = _CC_SAFE;\r\n\t\t\tuint256[] memory _amounts_ = new uint256[]( 4 );\r\n\t\t\t_amounts_[ 0 ] = _othersShare_;\r\n\t\t\t_amounts_[ 1 ] = _othersShare_;\r\n\t\t\t_amounts_[ 2 ] = _charityShare_;\r\n\t\t\t_amounts_[ 3 ] = _safeShare_;\r\n\t\t\temit PaymentReleased( address( this ), _tos_, _amounts_ );\r\n\t\t}\r\n\t// **************************************\r\n\r\n\t// **************************************\r\n\t// *****            VIEW            *****\r\n\t// **************************************\r\n\t\t/**\r\n\t\t* @dev Returns the number of tokens owned by `tokenOwner_`.\r\n\t\t*/\r\n\t\tfunction balanceOf( address tokenOwner_ ) public view virtual override(ERC721Batch, ERC721BatchStakable) returns ( uint256 balance ) {\r\n\t\t\treturn ERC721BatchStakable.balanceOf( tokenOwner_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev Returns the owner of token number `tokenId_`.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction ownerOf( uint256 tokenId_ ) public view virtual override(ERC721Batch, ERC721BatchStakable) exists( tokenId_ ) returns ( address ) {\r\n\t\t\treturn ERC721BatchStakable.ownerOf( tokenId_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC2981-royaltyInfo}.\r\n\t\t*\r\n\t\t* Requirements:\r\n\t\t*\r\n\t\t* - `tokenId_` must exist.\r\n\t\t*/\r\n\t\tfunction royaltyInfo( uint256 tokenId_, uint256 salePrice_ ) public view virtual override exists( tokenId_ ) returns ( address, uint256 ) {\r\n\t\t\treturn super.royaltyInfo( tokenId_, salePrice_ );\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t* @dev See {IERC165-supportsInterface}.\r\n\t\t*/\r\n\t\tfunction supportsInterface( bytes4 interfaceId_ ) public view virtual override(ERC721BatchEnumerable, ERC721Batch, ERC2981Base) returns ( bool ) {\r\n\t\t\treturn \r\n\t\t\t\tinterfaceId_ == type( IERC2981 ).interfaceId ||\r\n\t\t\t\tERC721Batch.supportsInterface( interfaceId_ ) ||\r\n\t\t\t\tERC721BatchEnumerable.supportsInterface( interfaceId_ );\r\n\t\t}\r\n\t// **************************************\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"reserve_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBatch_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyRate_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wlMintPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"publicMintPrice_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"wallets_\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_ARRAY_LENGTH_MISMATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_FORBIDDEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_INCORRECT_PRICE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_INSUFFICIENT_KEY_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_MAX_BATCH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_MAX_RESERVE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_MAX_SUPPLY\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_NO_ETHER_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCFoundersKeys_TRANSFER_FAIL\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC2981_INVALID_ROYALTIES\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721Enumerable_INDEX_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721Enumerable_OWNER_INDEX_OUT_OF_BOUNDS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_APPROVE_CALLER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_APPROVE_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_CALLER_NOT_APPROVED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NONEXISTANT_TOKEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NON_ERC721_RECEIVER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NULL_ADDRESS_BALANCE\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IERC721_NULL_ADDRESS_TRANSFER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IOwnable_NOT_OWNER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_PRESALE_NOT_OPEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_SALE_NOT_CLOSED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IPausable_SALE_NOT_OPEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IWhitelistable_CONSUMED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IWhitelistable_FORBIDDEN\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IWhitelistable_NOT_SET\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IWhitelistable_NO_ALLOWANCE\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address[]\",\"name\":\"tos\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"enum IPausable.SaleState\",\"name\":\"previousState\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"enum IPausable.SaleState\",\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"SaleStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_BATCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUBLIC_MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WL_MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"airdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"anonClaimList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"}],\"name\":\"balanceOfStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qtyStaked_\",\"type\":\"uint256\"}],\"name\":\"claimAndStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"qty_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"qtyStaked_\",\"type\":\"uint256\"}],\"name\":\"mintAndStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"mintPreSale\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"mintPreSaleAndStake\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOfStaked\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"enum IPausable.SaleState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"setAnonClaimList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxyRegistryAddress_\",\"type\":\"address\"}],\"name\":\"setProxyRegistry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"royaltyRecipient_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyRate_\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IPausable.SaleState\",\"name\":\"newState_\",\"type\":\"uint8\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root_\",\"type\":\"bytes32\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CCFoundersKeys", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000003f5000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000015b3000000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000f5232269808000000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c00000000000000000000000000000000000000000000000000000000000000220000000000000000000000000000000000000000000000000000000000000001c436f6c6c6563746f727320436c756220466f756e64657273204b65790000000000000000000000000000000000000000000000000000000000000000000000044343464b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003868747470733a2f2f636f6c6c6563746f7273636c75622e696f2f6170692f666f756e646572732f6d657461646174613f746f6b656e49443d00000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000730243c9a5c8c1a092a3eb4fc2e0d8796501cfb40000000000000000000000005efc2f54d6d104d1fad6716776b408d56a373a890000000000000000000000004a37e5ff83b739a1d543feefa43b73712957da5b0000000000000000000000001d014a0d021667c6afb3f97eb13e4c7bf1dc94a9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://161d9fed2d15321556ab0a7c3fd07cb94c59e02dcc41f6f3f24781a25c00f651"}]}