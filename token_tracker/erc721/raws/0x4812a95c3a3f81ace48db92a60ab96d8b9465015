{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/CustomToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport { LibDiamond } from  \\\"../libraries/LibDiamond.sol\\\";\\nimport '@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol';\\nimport \\\"../libraries/MyNFTTokenLibrary.sol\\\";\\nimport { AppStorage, Trait } from \\\"../libraries/LibAppStorage.sol\\\";\\nimport { ERC721Base } from '@solidstate/contracts/token/ERC721/base/ERC721Base.sol';\\nimport { ERC721BaseStorage } from '@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol';\\nimport { ERC165 } from '@solidstate/contracts/introspection/ERC165.sol';\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ncontract CustomToken is ERC721Enumerable, ERC721Base {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n    using MyNFTTokenLibrary for uint8;\\n\\n    AppStorage private s;\\n\\n   // This implements ERC-165.\\n    function supportsInterface(bytes4 _interfaceId) external override pure returns (bool) {\\n        return true;\\n    }\\n     /**\\n     * @dev Converts a digit from 0 - 10000 into its corresponding rarity based on the given rarity tier.\\n     * @param _randinput The input from 0 - 10000 to use for rarity gen.\\n     * @param _rarityTier The tier to use.\\n     */\\n    function rarityGen(uint256 _randinput, uint8 _rarityTier)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        uint16 currentLowerBound = 0;\\n        for (uint8 i = 0; i < s.TIERS[_rarityTier].length; i++) {\\n            uint16 thisPercentage = s.TIERS[_rarityTier][i];\\n            if (\\n                _randinput >= currentLowerBound &&\\n                _randinput < currentLowerBound + thisPercentage\\n            ) {\\n                return s.LETTERS[i];\\n            }\\n            currentLowerBound = currentLowerBound + thisPercentage;\\n        }\\n\\n        revert();\\n    }\\n\\n    /**\\n     * @dev Mint internal, this is to avoid code duplication.\\n     */\\n    function mintInternal() internal {\\n        uint256 _totalSupply = totalSupply();\\n        require(_totalSupply < s.MAX_SUPPLY);\\n        require(!MyNFTTokenLibrary.isContract(msg.sender));\\n        uint256 thisTokenId = _totalSupply;\\n        s.tokenIdToHash[thisTokenId] = hash(thisTokenId, msg.sender, 0);\\n        s.hashToMinted[s.tokenIdToHash[thisTokenId]] = true;\\n        _mint(msg.sender, thisTokenId);\\n    }\\n\\n    /**\\n     * @dev Mints new tokens.\\n     */\\n    function mint() public {\\n        return mintInternal();\\n    }\\n\\n    /**\\n     * @dev Generates a 7 digit hash from a tokenId, address, and random number.\\n     * @param _t The token id to be used within the hash.\\n     * @param _a The address to be used within the hash.\\n     * @param _c The custom nonce to be used within the hash.\\n     */\\n    function hash(\\n        uint256 _t,\\n        address _a,\\n        uint256 _c\\n    ) internal returns (string memory) {\\n        require(_c < 80);\\n\\n        // This will generate a 7 character string.\\n        //The last 6 digits are random, the first is a, due to the nft not being burned.\\n        string memory currentHash = \\\"\\\";\\n\\n        for (uint8 i = 0; i < 6; i++) {\\n            s.SEED_NONCE++;\\n            uint16 _randinput = uint16(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            block.timestamp,\\n                            block.coinbase,\\n                            block.difficulty,\\n                            _t,\\n                            _a,\\n                            _c,\\n                            s.SEED_NONCE\\n                        )\\n                    )\\n                ) % 10000\\n            );\\n\\n            currentHash = string(\\n                abi.encodePacked(currentHash, rarityGen(_randinput, i))\\n            );\\n        }\\n\\n        if (s.hashToMinted[currentHash]) return hash(_t, _a, _c + 1);\\n\\n        return currentHash;\\n    }\\n  // custom code...\\n   /**\\n     * @dev Returns the SVG and metadata for a token Id\\n     * @param _tokenId The tokenId to return the SVG and metadata for.\\n     */\\n    function tokenURI(uint256 _tokenId)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        require(ERC721BaseStorage.layout().exists(_tokenId));\\n\\n        string memory thisName = s.name;\\n\\n        string memory tokenHash = s.tokenIdToHash[_tokenId];\\n        string memory name = string(abi.encodePacked(\\\"\\\", thisName, \\\" #\\\", MyNFTTokenLibrary.toString(_tokenId)));\\n        string memory bio = string(abi.encodePacked(\\\"Stored 100% on-chain. \\\", s.name, \\\" #\\\", MyNFTTokenLibrary.toString(_tokenId)));\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    MyNFTTokenLibrary.encode(\\n                        bytes(\\n                            string(\\n                                abi.encodePacked(\\n                                    '{\\\"name\\\": \\\"',\\n                                    name,\\n                                    '\\\", \\\"description\\\": \\\"',\\n                                    bio,\\n                                    '\\\",\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                                    MyNFTTokenLibrary.encode(\\n                                        bytes(hashToSVG(tokenHash))\\n                                    ),\\n                                    '\\\",\\\"attributes\\\":',\\n                                    hashToMetadata(tokenHash),\\n                                    \\\"}\\\"\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Hash to metadata function\\n     */\\n    function hashToMetadata(string memory _hash)\\n        internal\\n        view\\n        returns (string memory)\\n    {\\n        string memory metadataString = '';\\n\\n        for (uint8 i = 0; i < 6;) {\\n            uint256 thisTraitIndex = letterToNumber(\\n                MyNFTTokenLibrary.substring(_hash, i, i + 1)\\n            );\\n\\n            metadataString = string(\\n                abi.encodePacked(\\n                    metadataString,\\n                    '{\\\"trait_type\\\":\\\"',\\n                    s.traitTypes[i][thisTraitIndex].traitType,\\n                    '\\\",\\\"value\\\":\\\"',\\n                    s.traitTypes[i][thisTraitIndex].traitName,\\n                    '\\\"}'\\n                )\\n            );\\n\\n            if (i != 5)\\n                metadataString = string(abi.encodePacked(metadataString, \\\",\\\"));\\n            unchecked {\\n              ++i;\\n            }\\n        }\\n\\n        return string(abi.encodePacked(\\\"[\\\", metadataString, \\\"]\\\"));\\n    }\\n\\n     /**\\n     * @dev Hash to SVG function\\n     */\\n    function hashToSVG(string memory _hash)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n\\n        string memory svgString = \\\"\\\";\\n        bool[24][24][24] memory placedPixels;\\n\\n        for (uint8 i = 0; i < 6; i++) {\\n            uint8 thisTraitIndex = letterToNumber(MyNFTTokenLibrary.substring(_hash, i, i + 1));\\n\\n            for (\\n                uint8 k = 0;\\n                k < s.traitTypes[i][thisTraitIndex].pixelCount.length;\\n                k++\\n            ) {\\n                string memory da = \\\"\\\";\\n                for (\\n                    uint8 p = 0;\\n                    p < s.traitTypes[i][thisTraitIndex].pixelCount.length;\\n                    p++\\n                )  {\\n                    if (p == k) {\\n                        da = string(abi.encodePacked(da, \\\"inline;\\\"));\\n                    } else {\\n                        da = string(abi.encodePacked(da, \\\"none;\\\"));\\n                    }\\n                }\\n                if (s.traitTypes[i][thisTraitIndex].pixelCount[k] > 0)  {\\n                    svgString = string(\\n                            abi.encodePacked(\\n                                svgString,\\n                                \\\"<g>\\\",\\n                                \\\"<animate id='\\\", s.LETTERS[k], \\\"' attributeName='display' values='\\\", da, \\\"' repeatCount='indefinite' dur='0.45s' begin='0s'/>\\\"\\n                        )\\n                    );\\n                }\\n                for (\\n                    uint256 j = 0;\\n                    j < s.traitTypes[i][thisTraitIndex].pixelCount[k];\\n                    j++\\n                ) {\\n                    string memory thisPixel = MyNFTTokenLibrary.substring(\\n                        s.traitTypes[i][thisTraitIndex].pixels[k],\\n                        j * 4,\\n                        j * 4 + 4\\n                    );\\n\\n                    uint8 x = letterToNumber(\\n                        MyNFTTokenLibrary.substring(thisPixel, 0, 1)\\n                    );\\n                    uint8 y = letterToNumber(\\n                        MyNFTTokenLibrary.substring(thisPixel, 1, 2)\\n                    );\\n\\n                    if (placedPixels[k][x][y]) continue;\\n\\n                    string memory color = MyNFTTokenLibrary.substring(thisPixel, 2, 4);\\n\\n                    svgString = string(\\n                        abi.encodePacked(\\n                            svgString,\\n                            \\\"<rect class='c\\\",\\n                            color,\\n                            \\\"' x='\\\",\\n                            x.toString(),\\n                            \\\"' y='\\\",\\n                            y.toString(),\\n                            \\\"'></rect>\\\"\\n                        )\\n                    );\\n\\n                    placedPixels[k][x][y] = true;\\n                }\\n\\n                if (s.traitTypes[i][thisTraitIndex].pixelCount[k] > 0)  {\\n                    svgString = string(\\n                            abi.encodePacked(\\n                                svgString,\\n                                \\\"</g>\\\"\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n\\n        svgString = string(\\n            abi.encodePacked(\\n                '<svg id=\\\"svg\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 24 24\\\"> ',\\n                svgString,\\n                \\\"<style>rect{width:1px;height:1px;}#svg{shape-rendering: crispedges;}.c00{fill:#000000}.c01{fill:#222034}.c02{fill:#45283c}.c03{fill:#663931}.c04{fill:#8f563b}.c05{fill:#df7126}.c06{fill:#d9a066}.c07{fill:#eec39a}.c08{fill:#fbf236}.c09{fill:#99e550}.c10{fill:#6abe30}.c11{fill:#37946e}.c12{fill:#4b692f}.c13{fill:#524b24}.c14{fill:#323c39}.c15{fill:#3f3f74}.c16{fill:#306082}.c17{fill:#5b6ee1}.c18{fill:#639bff}.c19{fill:#5fcde4}.c20{fill:#cbdbfc}.c21{fill:#ffffff}.c22{fill:#9badb7}.c23{fill:#847e87}.c24{fill:#696a6a}.c25{fill:#595652}.c26{fill:#76428a}.c27{fill:#ac3232}.c28{fill:#d95763}.c29{fill:#d77bba}.c30{fill:#8f974a}.c31{fill:#8a6f30}.c32{fill:#814848}.c33{fill:#9d4a4a}.c34{fill:#403640}.c35{fill:#868282}.c36{fill:#424058}.c37{fill:#2f315a}.c38{fill:#34378b}.c39{fill:#dcd530}.c40{fill:#fefff4}.c41{fill:#e3e1e1}.c42{fill:#634464}.c43{fill:#7d4881}.c44{fill:#b549bc}.c45{fill:#343cff}.c46{fill:#f6d953}.c47{fill:#bd8228}.c48{fill:#ebb337}</style>\\\",\\n                \\\"</svg>\\\"\\n            )\\n        );\\n\\n        return svgString;\\n    }\\n\\n\\n    /**\\n     * @dev Helper function to reduce pixel size within contract\\n     */\\n    function letterToNumber(string memory _inputLetter)\\n        internal\\n        view\\n        returns (uint8)\\n    {\\n        for (uint8 i = 0; i < s.LETTERS.length;) {\\n            if (\\n                keccak256(abi.encodePacked((s.LETTERS[i]))) ==\\n                keccak256(abi.encodePacked((_inputLetter)))\\n            ) return i;\\n            unchecked { ++i; }\\n        }\\n        revert();\\n    }\\n\\n   modifier onlyOwner() {\\n        require(s._owner == msg.sender, \\\"only owner\\\");\\n        _;\\n    }\\n\\n\\n        /**\\n     * @dev Clears the traits.\\n    //  */\\n    // function clearTraits() public onlyOwner {\\n    //     for (uint256 i = 0; i < 6; i++) {\\n    //         delete s.traitTypes[i];\\n    //     }\\n    // }\\n\\n    /**\\n     * @dev Add a trait type\\n     * @param _traitTypeIndex The trait type index\\n     * @param traits Array of traits to add\\n     */\\n\\n    function addTraitType(uint256 _traitTypeIndex, Trait[] memory traits)\\n        public\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < traits.length; i++) {\\n            s.traitTypes[_traitTypeIndex].push(\\n                Trait(\\n                    traits[i].traitName,\\n                    traits[i].traitType,\\n                    traits[i].pixels,\\n                    traits[i].pixelCount\\n                )\\n            );\\n        }\\n\\n        return;\\n    }\\n\\n    /**\\n     * @dev Returns the wallet of a given wallet. Mainly for ease for frontend devs.\\n     * @param _wallet The wallet to get the tokens of.\\n     */\\n    function walletOfOwner(address _wallet)\\n        public\\n        view\\n        returns (uint256[] memory)\\n    {\\n        uint256 tokenCount = _balanceOf(_wallet);\\n\\n        uint256[] memory tokensId = new uint256[](tokenCount);\\n        for (uint256 i; i < tokenCount; i++) {\\n            tokensId[i] = tokenOfOwnerByIndex(_wallet, i);\\n        }\\n        return tokensId;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);            \\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }    \\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\\n\\nabstract contract ERC721Enumerable is\\n    IERC721Enumerable,\\n    ERC721EnumerableInternal\\n{\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _tokenOfOwnerByIndex(owner, index);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenByIndex(uint256 index)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _tokenByIndex(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/MyNFTTokenLibrary.sol\": {\r\n      \"content\": \"// Forked from Anonymice\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary MyNFTTokenLibrary {\\n    string internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {\\n\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n\\n                // read 3 bytes\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function parseInt(string memory _a)\\n        internal\\n        pure\\n        returns (uint8 _parsedInt)\\n    {\\n        bytes memory bresult = bytes(_a);\\n        uint8 mint = 0;\\n        for (uint8 i = 0; i < bresult.length; i++) {\\n            if (\\n                (uint8(uint8(bresult[i])) >= 48) &&\\n                (uint8(uint8(bresult[i])) <= 57)\\n            ) {\\n                mint *= 10;\\n                mint += uint8(bresult[i]) - 48;\\n            }\\n        }\\n        return mint;\\n    }\\n\\n    function substring(\\n        string memory str,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex - startIndex);\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            result[i - startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/libraries/LibAppStorage.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\nstruct Trait {\\n    string traitName;\\n    string traitType;\\n    string[] pixels;\\n    uint256[] pixelCount;\\n}\\n\\nstruct AppStorage {\\n  mapping(uint256 => Trait[]) traitTypes;\\n  mapping(string => bool) hashToMinted;\\n  mapping(uint256 => string) tokenIdToHash;\\n  mapping(uint256 => string) tokenIdToName;\\n  mapping(uint256 => string) tokenIdToBio;\\n  mapping(uint256 => uint256) tokenIdToLevel;\\n\\tmapping (string => bool) nameReserved;\\n  uint256 LAST_MINT_TIME;\\n  uint256 MAX_SUPPLY;\\n  uint256 SEED_NONCE;\\n  uint16[][20] TIERS;\\n  string name;\\n  string[] LETTERS;\\n  address _owner;\\n}\\n\\nlibrary LibAppStorage {\\n\\n    function diamondStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n\\n    function abs(int256 x) internal pure returns (uint256) {\\n        return uint256(x >= 0 ? x : -x);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { IERC721 } from '../IERC721.sol';\\nimport { IERC721Receiver } from '../IERC721Receiver.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\\n\\n/**\\n * @notice Base ERC721 implementation, excluding optional extensions\\n */\\nabstract contract ERC721Base is IERC721, ERC721BaseInternal {\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownerOf(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _isApprovedForAll(account, operator);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            'ERC721: transfer caller is not owner or approved'\\n        );\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public payable override {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            'ERC721: transfer caller is not owner or approved'\\n        );\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function approve(address operator, uint256 tokenId)\\n        public\\n        payable\\n        override\\n    {\\n        _handleApproveMessageValue(operator, tokenId, msg.value);\\n        address owner = ownerOf(tokenId);\\n        require(operator != owner, 'ERC721: approval to current owner');\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            'ERC721: approve caller is not owner nor approved for all'\\n        );\\n        _approve(operator, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function setApprovalForAll(address operator, bool status) public override {\\n        require(operator != msg.sender, 'ERC721: approve to caller');\\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\\n            operator\\n        ] = status;\\n        emit ApprovalForAll(msg.sender, operator, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\n\\nlibrary ERC721BaseStorage {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Base');\\n\\n    struct Layout {\\n        EnumerableMap.UintToAddressMap tokenOwners;\\n        mapping(address => EnumerableSet.UintSet) holderTokens;\\n        mapping(uint256 => address) tokenApprovals;\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function exists(Layout storage l, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return l.tokenOwners.contains(tokenId);\\n    }\\n\\n    function totalSupply(Layout storage l) internal view returns (uint256) {\\n        return l.tokenOwners.length();\\n    }\\n\\n    function tokenOfOwnerByIndex(\\n        Layout storage l,\\n        address owner,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return l.holderTokens[owner].at(index);\\n    }\\n\\n    function tokenByIndex(Layout storage l, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 tokenId, ) = l.tokenOwners.at(index);\\n        return tokenId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { ERC165Storage } from './ERC165Storage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165 is IERC165 {\\n    using ERC165Storage for ERC165Storage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Map implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableMap {\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct AddressToAddressMap {\\n        Map _inner;\\n    }\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function at(AddressToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address, address)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        address addressKey;\\n        assembly {\\n            addressKey := mload(add(key, 20))\\n        }\\n        return (addressKey, address(uint160(uint256(value))));\\n    }\\n\\n    function at(UintToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (uint256, address)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function contains(AddressToAddressMap storage map, address key)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function contains(UintToAddressMap storage map, uint256 key)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(AddressToAddressMap storage map)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _length(map._inner);\\n    }\\n\\n    function length(UintToAddressMap storage map)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _length(map._inner);\\n    }\\n\\n    function get(AddressToAddressMap storage map, address key)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return\\n            address(\\n                uint160(\\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\\n                )\\n            );\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function set(\\n        AddressToAddressMap storage map,\\n        address key,\\n        address value\\n    ) internal returns (bool) {\\n        return\\n            _set(\\n                map._inner,\\n                bytes32(uint256(uint160(key))),\\n                bytes32(uint256(uint160(value)))\\n            );\\n    }\\n\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(AddressToAddressMap storage map, address key)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function remove(UintToAddressMap storage map, uint256 key)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function _at(Map storage map, uint256 index)\\n        private\\n        view\\n        returns (bytes32, bytes32)\\n    {\\n        require(\\n            map._entries.length > index,\\n            'EnumerableMap: index out of bounds'\\n        );\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _contains(Map storage map, bytes32 key)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, 'EnumerableMap: nonexistent key');\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) {\\n            uint256 index = keyIndex - 1;\\n            MapEntry storage last = map._entries[map._entries.length - 1];\\n\\n            // move last entry to now-vacant index\\n\\n            map._entries[index] = last;\\n            map._indexes[last._key] = index + 1;\\n\\n            // clear last index\\n\\n            map._entries.pop();\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        require(\\n            set._values.length > index,\\n            'EnumerableSet: index out of bounds'\\n        );\\n        return set._values[index];\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 index = valueIndex - 1;\\n            bytes32 last = set._values[set._values.length - 1];\\n\\n            // move last value to now-vacant index\\n\\n            set._values[index] = last;\\n            set._indexes[last] = index + 1;\\n\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Enumerable {\\n    /**\\n     * @notice get total token supply\\n     * @return total supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice get token of given owner at given internal storage index\\n     * @param owner token holder to query\\n     * @param index position in owner's token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        external\\n        view\\n        returns (uint256 tokenId);\\n\\n    /**\\n     * @notice get token at given internal storage index\\n     * @param index position in global token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenByIndex(uint256 index)\\n        external\\n        view\\n        returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\nimport { ERC721BaseInternal } from '../base/ERC721BaseInternal.sol';\\n\\nabstract contract ERC721EnumerableInternal is ERC721BaseInternal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _totalSupply() internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().totalSupply();\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenOfOwnerByIndex(address owner, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ERC721BaseStorage.layout().tokenOfOwnerByIndex(owner, index);\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenByIndex(uint256 index) internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().tokenByIndex(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { IERC721Internal } from '../IERC721Internal.sol';\\nimport { IERC721Receiver } from '../IERC721Receiver.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\n\\n/**\\n * @notice Base ERC721 internal functions\\n */\\nabstract contract ERC721BaseInternal is IERC721Internal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    function _balanceOf(address account) internal view returns (uint256) {\\n        require(\\n            account != address(0),\\n            'ERC721: balance query for the zero address'\\n        );\\n        return ERC721BaseStorage.layout().holderTokens[account].length();\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\\n        require(owner != address(0), 'ERC721: invalid owner');\\n        return owner;\\n    }\\n\\n    function _getApproved(uint256 tokenId) internal view returns (address) {\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        require(\\n            l.exists(tokenId),\\n            'ERC721: approved query for nonexistent token'\\n        );\\n\\n        return l.tokenApprovals[tokenId];\\n    }\\n\\n    function _isApprovedForAll(address account, address operator)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            ERC721BaseStorage.layout().exists(tokenId),\\n            'ERC721: query for nonexistent token'\\n        );\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        return (spender == owner ||\\n            _getApproved(tokenId) == spender ||\\n            _isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), 'ERC721: mint to the zero address');\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        require(!l.exists(tokenId), 'ERC721: token already minted');\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, '');\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner = _ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        _approve(address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n        l.holderTokens[owner].remove(tokenId);\\n        l.tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            _ownerOf(tokenId) == from,\\n            'ERC721: transfer of token that is not own'\\n        );\\n        require(to != address(0), 'ERC721: transfer to the zero address');\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        _approve(address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n        l.holderTokens[from].remove(tokenId);\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    function _approve(address operator, uint256 tokenId) internal {\\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\\n        emit Approval(_ownerOf(tokenId), operator, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes memory returnData = to.functionCall(\\n            abi.encodeWithSelector(\\n                IERC721Receiver(to).onERC721Received.selector,\\n                msg.sender,\\n                from,\\n                tokenId,\\n                data\\n            ),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n\\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\\n        return returnValue == type(IERC721Receiver).interfaceId;\\n    }\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\\n     * @param operator beneficiary of approval\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Partial ERC721 interface needed by internal functions\\n */\\ninterface IERC721Internal {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed operator,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\nimport { IERC721Internal } from './IERC721Internal.sol';\\n\\n/**\\n * @notice ERC721 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721 is IERC721Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given address\\n     * @return balance quantity of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice query the owner of given token\\n     * @param tokenId token to query\\n     * @return owner token owner\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice grant approval to given account to spend token\\n     * @param operator address to be approved\\n     * @param tokenId token to approve\\n     */\\n    function approve(address operator, uint256 tokenId) external payable;\\n\\n    /**\\n     * @notice get approval status for given token\\n     * @param tokenId token to query\\n     * @return operator address approved to spend token\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\\n     * @param operator address to be approved\\n     * @param status approval status\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return status whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC165Storage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return l.supportedInterfaces[interfaceId];\\n    }\\n\\n    function setSupportedInterface(\\n        Layout storage l,\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal {\\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\\n        l.supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_traitTypeIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"traitName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"traitType\",\"type\":\"string\"},{\"internalType\":\"string[]\",\"name\":\"pixels\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"pixelCount\",\"type\":\"uint256[]\"}],\"internalType\":\"struct Trait[]\",\"name\":\"traits\",\"type\":\"tuple[]\"}],\"name\":\"addTraitType\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"hashToSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CustomToken", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}