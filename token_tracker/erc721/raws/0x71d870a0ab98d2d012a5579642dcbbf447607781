{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/ghoulBalls.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {Owned} from \\\"solmate/auth/Owned.sol\\\";\\nimport {libImg} from \\\"../src/libImg.sol\\\";\\nimport {png} from \\\"../src/png.sol\\\";\\nimport {json} from \\\"../src/JSON.sol\\\";\\n\\ninterface IBasedGhouls {\\n    function ownerOf(uint256 id) external view returns (address owner);\\n}\\n\\ncontract ghoulBalls is ERC721, Owned(msg.sender) {\\n\\n    uint32 constant WIDTH_AND_HEIGHT = 128;\\n    int256 constant CIRCLE_RADIUS = 69;\\n\\n    IBasedGhouls ghouls = IBasedGhouls(0xeF1a89cbfAbE59397FfdA11Fc5DF293E9bC5Db90);\\n\\n    mapping(uint256 => bytes) internal colours;\\n\\n    function _hash(bytes memory SAUCE) internal pure returns(bytes memory) {\\n        return abi.encodePacked(keccak256(SAUCE));\\n    }\\n\\n    function toUint256(bytes memory _bytes) internal pure returns (uint256) {\\n        require(_bytes.length >= 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(_bytes, 0x20))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    // Each RGB is 3 bytes, determine number of balls that will be in the PNG then generate the colours\\n    function _generateColour(uint256 id) internal view returns(bytes memory) {\\n        uint256 randomish = toUint256(_hash(abi.encodePacked(id, msg.sender, block.timestamp)));\\n\\n        if((randomish % 69) > 60) {\\n            return abi.encodePacked((uint144(randomish))); //6\\n        } else if((randomish % 69) > 50) {\\n            return abi.encodePacked((uint96(randomish))); //4\\n        } else if((randomish % 69) > 40) {\\n            return abi.encodePacked((uint48(randomish))); //2\\n        } else {\\n            return abi.encodePacked((uint24(randomish))); //1\\n        }\\n        \\n    }\\n\\n    function mint_the_ball(uint256 id) public {\\n        require(id < 10000, \\\"invalid ball.\\\");\\n        if (id<6666) {\\n            require(ghouls.ownerOf(id) == msg.sender, \\\"not your ghoul.\\\");\\n        }\\n        require(_ownerOf[id] == address(0), \\\"someone else got this ghoulBall.\\\");\\n\\n        colours[id] = _generateColour(id);\\n\\n        _mint(msg.sender, id);\\n    }\\n\\n    function click_for_utility(uint256 id) public {\\n        _burn(id);\\n    }\\n\\n    function getPalette(uint256 id) internal view returns (bytes3[] memory) {\\n        bytes memory _coloursArr = colours[id];\\n\\n        bytes3[] memory palette = new bytes3[](_coloursArr.length/3);\\n\\n        for(uint256 i = 0; i<palette.length; i++) {\\n            palette[i] = \\n                bytes3(\\n                    bytes.concat(\\n                        _coloursArr[i*3],\\n                        _coloursArr[i*3+1],\\n                        _coloursArr[i*3+2]\\n                    )\\n                );\\n        }\\n\\n        return palette;\\n    }\\n\\n    function tokenPNG(uint256 id) public view returns (string memory) {\\n        bytes3[] memory _palette = getPalette(id);\\n\\n        libImg.IMAGE memory imgPixels = libImg.IMAGE(\\n            WIDTH_AND_HEIGHT,\\n            WIDTH_AND_HEIGHT,\\n            new bytes(WIDTH_AND_HEIGHT*WIDTH_AND_HEIGHT+1)\\n        );\\n        \\n        return png.encodedPNG(WIDTH_AND_HEIGHT, WIDTH_AND_HEIGHT, _palette, libImg.drawImage(imgPixels, _palette.length), true);\\n\\n    }\\n\\n    function tokenAttributes(uint256 id) internal view returns (string memory) {\\n        bytes memory plte = colours[id];\\n\\n        string memory palettes;\\n        bool last;\\n\\n        for (uint256 i = 0; i<plte.length/3; i++) {\\n            last = (i == (plte.length/3-1)) ? true : false;\\n\\n            palettes = string.concat(\\n                palettes,\\n                json._attr(\\n                    string.concat('ball ', json.toString(i+1)),\\n                    string.concat(\\n                        json.toString(uint8(plte[i*3])),\\n                        ', ',\\n                        json.toString(uint8(plte[i*3+1])),\\n                        ', ',\\n                        json.toString(uint8(plte[i*3+2]))\\n                    ),\\n                    last\\n                )\\n            );\\n        }\\n\\n        // we attach the number of balls, and colour palette to the ERC721 JSON\\n        return string.concat(\\n            json._attr('ball count', json.toString(plte.length/3)),\\n            palettes\\n        );\\n\\n    }\\n\\n    function tokenURI(uint256 id) public view override returns (string memory) {\\n        return json.formattedMetadata(\\n            'ghoulBalls',\\n            \\\"ghoulBalls are fully onchain PNGs that evolve with every block, absolutely rugging the right-click savers after everyblock. No roadmap, no development, no utility, no marketing, and nothing more. They promise nothing and deliver even less. They're just PNGs.\\\",\\n            tokenPNG(id),\\n            tokenAttributes(id)\\n        );\\n    }\\n\\n    //never know if they'll rug us again with a v3\\n    function updateGhoulAddr(address ghoulAddr) public onlyOwner {\\n        ghouls = IBasedGhouls(ghoulAddr);\\n    }\\n    \\n    constructor() ERC721(\\\"ghoulBalls\\\", unicode\\\"\ud83c\udf8a\\\"){}\\n\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/auth/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract Owned {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnerUpdated(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libImg.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.13;\\n\\nlibrary libImg {\\n\\n    struct IMAGE{\\n        uint256 width;\\n        uint256 height;\\n        bytes pixels;\\n    }\\n\\n    function toIndex(int256 _x, int256 _y, uint256 _width) internal pure returns (uint256 index){\\n        unchecked{\\n            index = uint256(_y) * (_width +1) + uint256(_x) + 1;\\n        }\\n        \\n    }\\n\\n    function assignMidPoint(uint256 seed, uint256 width, uint256 height) internal pure returns (int256 x, int256 y) {\\n\\n        x = int256(\\n                (\\n                    ((seed >> 2*8) % width) +\\n                    (width / 2)\\n                ) /2\\n            );\\n\\n        y = int256(\\n                (\\n                    ((seed) % height) +\\n                    (height / 2)\\n\\n                ) /2\\n            );\\n\\n\\n    }\\n\\n    function rasterFilledCircle(IMAGE memory img, int256 xMid, int256 yMid, int256 r, bytes1 idxColour) internal pure returns (IMAGE memory) {\\n\\n        int256 xSym;\\n        int256 ySym;\\n        int256 x = 0;\\n        int256 y = int(r);\\n\\n        unchecked {\\n            for (x = xMid - r ; x <= xMid; x++) {\\n                for (y = yMid - r ; y <= yMid; y++) {\\n                    if ((x - xMid)*(x - xMid) + (y - yMid)*(y - yMid) <= r*r) \\n                    {\\n                        xSym = xMid - (x - xMid);\\n                        ySym = yMid - (y - yMid);\\n                        // (x, y), (x, ySym), (xSym , y), (xSym, ySym) are in the circle\\n                        if (x >= 0 && y >= 0) {\\n                            img.pixels[toIndex(x, y,img.width)] = idxColour;\\n                        }\\n                        if (x >= 0 && ySym >= 0) {\\n                            img.pixels[toIndex(x, ySym,img.width)] = idxColour;\\n                        }\\n                        if (xSym >= 0 && y >= 0) {\\n                            img.pixels[toIndex(xSym, y,img.width)] = idxColour;\\n                        }\\n                        if (xSym >= 0 && ySym >= 0) {\\n                            img.pixels[toIndex(xSym, ySym,img.width)] = idxColour;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return img;\\n    }\\n\\n    function drawImage(IMAGE memory img, uint256 circleCount) internal view returns (bytes memory){\\n\\n        IMAGE memory tempImg;\\n        int256 xMid;\\n        int256 yMid;\\n        uint256 randoSeed;\\n\\n        for (uint8 i = 0; i<circleCount; i++) {\\n            randoSeed = uint256(keccak256(abi.encodePacked(block.timestamp, i)));\\n            (xMid, yMid) = assignMidPoint(randoSeed, img.width, img.height);\\n\\n            tempImg = rasterFilledCircle(img, xMid, yMid, int256(18), bytes1(i+1));\\n        }\\n        \\n        return tempImg.pixels;\\n\\n    }\\n\\n}\"\r\n    },\r\n    \"src/png.sol\": {\r\n      \"content\": \" // SPDX-License-Identifier: Unlicense\\n/*\\n * @title Onchain PNGs\\n * @author Colin Platt <colin@numerate.tech>\\n *\\n * @dev PNG encoding tools written in Solidity for producing read-only onchain PNG files.\\n */\\n\\npragma solidity =0.8.13;\\n\\nlibrary png {\\n    \\n    struct RGBA {\\n        bytes1 red;\\n        bytes1 green;\\n        bytes1 blue;\\n    }\\n\\n    function rgbToPalette(bytes1 red, bytes1 green, bytes1 blue) internal pure returns (bytes3) {\\n        return bytes3(abi.encodePacked(red, green, blue));\\n    }\\n\\n    function rgbToPalette(RGBA memory _rgb) internal pure returns (bytes3) {\\n        return bytes3(abi.encodePacked(_rgb.red, _rgb.green, _rgb.blue));\\n    }\\n\\n    function calculateBitDepth(uint256 _length) internal pure returns (uint256) {\\n        if (_length < 3) {\\n            return 2;\\n        } else if(_length < 5) {\\n            return 4;\\n        } else if(_length < 17) {\\n            return 16;\\n        } else {\\n            return 256;\\n        }\\n    }\\n\\n    function formatPalette(bytes3[] memory _palette, bool _8bit) internal pure returns (bytes memory) {\\n        require(_palette.length <= 256, \\\"PNG: Palette too large.\\\");\\n\\n        uint256 depth = _8bit? uint256(256) : calculateBitDepth(_palette.length);\\n        bytes memory paletteObj;\\n\\n        for (uint i = 0; i<_palette.length; i++) {\\n            paletteObj = abi.encodePacked(paletteObj, _palette[i]);\\n        }\\n\\n        for (uint i = _palette.length; i<depth-1; i++) {\\n            paletteObj = abi.encodePacked(paletteObj, bytes3(0x000000));\\n        }\\n\\n        return abi.encodePacked(\\n            uint32(depth*3),\\n            'PLTE',\\n            bytes3(0x000000),\\n            paletteObj\\n        );\\n    }\\n\\n    function _tRNS(uint256 _bitDepth, uint256 _palette) internal pure returns (bytes memory) {\\n\\n        bytes memory tRNSObj = abi.encodePacked(bytes1(0x00));\\n\\n        for (uint i = 0; i<_palette; i++) {\\n            tRNSObj = abi.encodePacked(tRNSObj, bytes1(0xFF));\\n        }\\n\\n        for (uint i = _palette; i<_bitDepth-1; i++) {\\n            tRNSObj = abi.encodePacked(tRNSObj, bytes1(0x00));\\n        }\\n\\n        return abi.encodePacked(\\n            uint32(_bitDepth),\\n            'tRNS',\\n            tRNSObj\\n        );\\n    }\\n\\n    function rawPNG(uint32 width, uint32 height, bytes3[] memory palette, bytes memory pixels, bool force8bit) internal pure returns (bytes memory) {\\n\\n        uint256[256] memory crcTable = calcCrcTable();\\n\\n        // Write PLTE\\n        bytes memory plte = formatPalette(palette, force8bit);\\n\\n        // Write tRNS\\n        bytes memory tRNS = png._tRNS(\\n            force8bit ? 256 : calculateBitDepth(palette.length),\\n            palette.length\\n            );\\n\\n        // Write IHDR\\n        bytes21 header = bytes21(abi.encodePacked(\\n                uint32(13),\\n                'IHDR',\\n                width,\\n                height,\\n                bytes5(0x0803000000)\\n            )\\n        );\\n\\n        bytes7 deflate = bytes7(\\n            abi.encodePacked(\\n                bytes2(0x78DA),\\n                pixels.length > 65535 ? bytes1(0x00) :  bytes1(0x01),\\n                png.byte2lsb(uint16(pixels.length)),\\n                ~png.byte2lsb(uint16(pixels.length))\\n            )\\n        );\\n\\n        bytes memory zlib = abi.encodePacked('IDAT', deflate, pixels, _adler32(pixels));\\n\\n        return abi.encodePacked(\\n            bytes8(0x89504E470D0A1A0A),\\n            header, \\n            _CRC(crcTable, abi.encodePacked(header),4),\\n            plte, \\n            _CRC(crcTable, abi.encodePacked(plte),4),\\n            tRNS, \\n            _CRC(crcTable, abi.encodePacked(tRNS),4),\\n            uint32(zlib.length-4),\\n            zlib,\\n            _CRC(crcTable, abi.encodePacked(zlib), 0), \\n            bytes12(0x0000000049454E44AE426082)\\n        );\\n\\n    }\\n\\n    function encodedPNG(uint32 width, uint32 height, bytes3[] memory palette, bytes memory pixels, bool force8bit) internal pure returns (string memory) {\\n        return string.concat('data:image/png;base64,', base64encode(rawPNG(width, height, palette, pixels, force8bit)));\\n    }\\n\\n\\n\\n\\n\\n\\n    // @dev Does not check out of bounds\\n    function coordinatesToIndex(uint256 _x, uint256 _y, uint256 _width) internal pure returns (uint256 index) {\\n            index = _y * (_width + 1) + _x + 1;\\n\\t}\\n\\n    \\n\\n    \\n\\n\\n\\n\\n\\n\\n\\n\\n    /////////////////////////// \\n    /// Checksums\\n\\n    // need to check faster ways to do this\\n    function calcCrcTable() internal pure returns (uint256[256] memory crcTable) {\\n        uint256 c;\\n\\n        unchecked{\\n            for(uint256 n = 0; n < 256; n++) {\\n                c = n;\\n                for (uint256 k = 0; k < 8; k++) {\\n                    if(c & 1 == 1) {\\n                        c = 0xedb88320 ^ (c >>1);\\n                    } else {\\n                        c = c >> 1;\\n                    }\\n                }\\n                crcTable[n] = c;\\n            }\\n        }\\n    }\\n\\n    function _CRC(uint256[256] memory crcTable, bytes memory chunk, uint256 offset) internal pure returns (bytes4) {\\n\\n        uint256 len = chunk.length;\\n\\n        uint32 c = uint32(0xffffffff);\\n        unchecked{\\n            for(uint256 n = offset; n < len; n++) {\\n                c = uint32(crcTable[(c^uint8(chunk[n])) & 0xff] ^ (c >> 8));\\n            }\\n        }\\n        return bytes4(c)^0xffffffff;\\n\\n    }\\n\\n    \\n    function _adler32(bytes memory _data) internal pure returns (bytes4) {\\n        uint32 a = 1;\\n        uint32 b = 0;\\n\\n        uint256 _len = _data.length;\\n\\n        unchecked {\\n            for (uint256 i = 0; i < _len; i++) {\\n                a = (a + uint8(_data[i])) % 65521; //may need to convert to uint32\\n                b = (b + a) % 65521;\\n            }\\n        }\\n\\n        return bytes4((b << 16) | a);\\n\\n    }\\n\\n    /////////////////////////// \\n    /// Utilities\\n\\n    function byte2lsb(uint16 _input) internal pure returns (bytes2) {\\n\\n        return byte2lsb(bytes2(_input));\\n\\n    }\\n\\n    function byte2lsb(bytes2 _input) internal pure returns (bytes2) {\\n\\n        return bytes2(abi.encodePacked(bytes1(_input << 8), bytes1(_input)));\\n\\n    }\\n\\n    function _toBuffer(bytes memory _bytes) internal pure returns (bytes1[] memory) {\\n\\n        uint256 _length = _bytes.length;\\n\\n        bytes1[] memory byteArray = new bytes1[](_length);\\n        bytes memory tempBytes;\\n\\n        unchecked{\\n            for (uint256 i = 0; i<_length; i++) {\\n                assembly {\\n                    // Get a location of some free memory and store it in tempBytes as\\n                    // Solidity does for memory variables.\\n                    tempBytes := mload(0x40)\\n\\n                    // The first word of the slice result is potentially a partial\\n                    // word read from the original array. To read it, we calculate\\n                    // the length of that partial word and start copying that many\\n                    // bytes into the array. The first word we copy will start with\\n                    // data we don't care about, but the last `lengthmod` bytes will\\n                    // land at the beginning of the contents of the new array. When\\n                    // we're done copying, we overwrite the full first word with\\n                    // the actual length of the slice.\\n                    let lengthmod := and(1, 31)\\n\\n                    // The multiplication in the next line is necessary\\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                    // the following copy loop was copying the origin's length\\n                    // and then ending prematurely not copying everything it should.\\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                    let end := add(mc, 1)\\n\\n                    for {\\n                        // The multiplication in the next line has the same exact purpose\\n                        // as the one above.\\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), i)\\n                    } lt(mc, end) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        mstore(mc, mload(cc))\\n                    }\\n\\n                    mstore(tempBytes, 1)\\n\\n                    //update free-memory pointer\\n                    //allocating the array padded to 32 bytes like the compiler does now\\n                    mstore(0x40, and(add(mc, 31), not(31)))\\n                }\\n\\n                byteArray[i] = bytes1(tempBytes);\\n\\n            }\\n        }\\n        \\n        return byteArray;\\n    }\\n\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function base64encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n\\n\\n}\"\r\n    },\r\n    \"src/JSON.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\n/*\\n * @title ERC721 JSON metadata\\n * @author Colin Platt <colin@numerate.tech>\\n *\\n * @dev JSON utilities for base64 encoded ERC721 JSON metadata schema\\n */\\npragma solidity ^0.8.12;\\n\\nlibrary json {\\n    \\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    /// @dev JSON requires that double quotes be escaped or JSONs will not build correctly\\n    /// string.concat also requires an escape, use \\\\\\\\\\\" or the constant DOUBLE_QUOTES to represent \\\" in JSON\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    string constant DOUBLE_QUOTES = '\\\\\\\\\\\"';\\n\\n    function formattedMetadata(\\n        string memory name,\\n        string memory description,\\n        string memory pngImg,\\n        string memory attributes\\n    )   internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat(\\n            'data:application/json;base64,',\\n            encode(\\n                bytes(\\n                    string.concat(\\n                    '{',\\n                    _prop('name', name),\\n                    _prop('description', description),\\n                    _xmlImage(pngImg),\\n                    _objectSq('attributes', attributes),\\n                    '}'\\n                    )\\n                )\\n            )\\n        );\\n    }\\n    \\n    function _xmlImage(string memory _pngImg)\\n        internal\\n        pure\\n        returns (string memory) \\n    {\\n        return _prop(\\n                        'image',\\n                        string.concat(\\n                            'data:image/svg+xml;base64,',\\n                            encode(\\n                                bytes(string.concat(\\n                                    '<svg width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">  <image x=\\\"0\\\" y=\\\"0\\\" width=\\\"128\\\" height=\\\"128\\\" preserveAspectRatio=\\\"xMidYMid\\\" xlink:href=\\\"',\\n                                    _pngImg,\\n                                    '\\\"/></svg>'\\n                                ))\\n                            )\\n                        ),\\n                        false\\n        );\\n    }\\n\\n    function _prop(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('\\\"', _key, '\\\": ', '\\\"', _val, '\\\", ');\\n    }\\n\\n    function _prop(string memory _key, string memory _val, bool last)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if(last) {\\n            return string.concat('\\\"', _key, '\\\": ', '\\\"', _val, '\\\"');\\n        } else {\\n            return string.concat('\\\"', _key, '\\\": ', '\\\"', _val, '\\\", ');\\n        }\\n        \\n    }\\n\\n    function _object(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('\\\"', _key, '\\\": ', '{', _val, '}');\\n    }\\n\\n    function _objectSq(string memory _key, string memory _val)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('\\\"', _key, '\\\": ', '[', _val, ']');\\n    }\\n\\n    function _attr(string memory _trait_type, string memory _value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return string.concat('{\\\"trait_type\\\": \\\"', _trait_type, '\\\", ', '\\\"value\\\" : \\\"', _value, '\\\"}, ');\\n    }\\n\\n    function _attr(string memory _trait_type, string memory _value, bool last)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (last) {\\n            return string.concat('{\\\"trait_type\\\": \\\"', _trait_type, '\\\", ', '\\\"value\\\" : \\\"', _value, '\\\"}');\\n        } else {\\n            return string.concat('{\\\"trait_type\\\": \\\"', _trait_type, '\\\", ', '\\\"value\\\" : \\\"', _value, '\\\"}, ');\\n        }\\n        \\n    }\\n\\n     \\n     /**\\n     * taken from Openzeppelin\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * taken from Openzeppelin\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solidity-trigonometry/=lib/solidity-trigonometry/src/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"click_for_utility\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"mint_the_ball\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenPNG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ghoulAddr\",\"type\":\"address\"}],\"name\":\"updateGhoulAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ghoulBalls", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}