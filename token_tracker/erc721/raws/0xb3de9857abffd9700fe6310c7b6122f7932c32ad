{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Comics/MimeticComic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport { ERC721 } from \\\"./ERC721/ERC721.sol\\\";\\r\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport { IMimeticComic } from \\\"./IMimeticComic.sol\\\";\\r\\nimport { Base64 } from \\\"./Base64.sol\\\"; \\r\\nimport { Strings } from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport { IMirror } from \\\"./IMirror.sol\\\";\\r\\nimport { IERC2981 } from \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Mimetic Comic w/ Phantom Ownership\\r\\n * @author @nftchance and @masonthechain \\r\\n * @dev Implementation of EIP-721 Non-Fungible Token Standard, including the \\r\\n *      Metadata extension and combining with the usage of Mimetic Metadata, \\r\\n *      Phantom Ownership, and EIP-2309. Many of the features included in this \\r\\n *      contract will be limited time use / reserved for the future. \\r\\n * @dev The use of hooks is not enabled by default which will leave some \\r\\n *      indexers not having the most up to date ownership record. Hooks solve \\r\\n *      this, however full benefits can only be enjoyed after migration.\\r\\n */\\r\\ncontract MimeticComic is\\r\\n      ERC721\\r\\n    , Ownable\\r\\n    , IMimeticComic\\r\\n{\\r\\n    using Strings for uint8;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                    TOKEN METADATA STORAGE/LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    ///@dev Comic series metadata info and redemption time period.\\r\\n    struct Series {\\r\\n        string description;     // Token description in displays\\r\\n        string ipfsHash;        // Comic book cover\\r\\n        uint256 issuanceEnd;    // When this issue can no longer be focused\\r\\n    }\\r\\n\\r\\n    ///@dev Comic series index to series data.\\r\\n    mapping(uint8 => Series) public seriesToSeries;\\r\\n\\r\\n    ///@dev Token id to comic series index.\\r\\n    mapping(uint256 => uint256) internal tokenToSeries;\\r\\n\\r\\n    ///@dev Number of comic series indexes stored in a single index.\\r\\n    uint256 public constant PACKED = 64;\\r\\n    \\r\\n    ///@dev Number of bytes a series can take up.\\r\\n    uint256 public constant PACKED_SHIFT = 4;\\r\\n    \\r\\n    ///@dev Number of tokens required for end-of-road redemption.\\r\\n    uint256 public constant REDEMPTION_QUALIFIER = 13;\\r\\n\\r\\n    ///@dev Nuclear Nerds token id to comic wildcard condition truth.\\r\\n    mapping(uint256 => bool) internal nerdToWildcard;\\r\\n\\r\\n    ///@dev The default description of the collection and tokens.\\r\\n    string private collectionDescription;\\r\\n\\r\\n    ///@dev Disclaimer message appended to wildcard tokens for buyer safety.\\r\\n    string private wildcardDescription;\\r\\n\\r\\n    ///@dev Disclaimer message appended to tokens that have been redeemed.\\r\\n    string private redeemedDescription;\\r\\n\\r\\n    ///@dev Management of redemption booleans bitpacked to lower storage needs.\\r\\n    ///@notice `tokens` as it is a bitpacked mapping returned.\\r\\n    mapping(uint256 => uint256) public tokensToRedeemed;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                      COLLECTION STATE MANAGEMENT\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    ///@dev Controls whether or not wildcards can be loaded.\\r\\n    bool public wildcardsLocked;\\r\\n\\r\\n    ///@dev Controls whether or not master actions can be called.\\r\\n    bool public masterLocked;\\r\\n\\r\\n    ///@dev Controls all series progression within the collection.\\r\\n    bool public locked;\\r\\n\\r\\n    ///@dev Nuclear Nerd contracts that call transferHooks upon transfer.\\r\\n    mapping(address => bool) public hooks;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            ROYALTY LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n    \\r\\n    ///@dev IPFS hash to the contract URI json.\\r\\n    string public contractURIHash;\\r\\n\\r\\n    ///@dev On-chain royalty basis points.\\r\\n    uint256 public royaltyBasis = 690;\\r\\n    \\r\\n    ///@dev The floating point percentage used for royalty calculation.\\r\\n    uint256 private constant percentageTotal = 10000;\\r\\n\\r\\n    ///@dev Team address that receives royalties from secondary sales.\\r\\n    address public royaltyReceiver;\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 EVENTS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    ///@dev EIP-2309 standard for more efficient ownership indexing events.\\r\\n    event ConsecutiveTransfer(\\r\\n          uint256 indexed fromTokenId\\r\\n        , uint256 toTokenId\\r\\n        , address indexed fromAddress\\r\\n        , address indexed toAddress\\r\\n    );\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                                 ERRORS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    error CollectionStateInvalid();\\r\\n    error CollectionMasterLocked();\\r\\n    error CollectionWildcardsLocked();\\r\\n\\r\\n    error HookCallerMismatch();\\r\\n\\r\\n    error TokenMinted();\\r\\n    error TokenDoesNotExist();\\r\\n    error TokenOwnerMismatch();\\r\\n    error TokenNotWildcard();\\r\\n    error TokenBundleInvalid();\\r\\n    error TokenRedeemed();\\r\\n\\r\\n    error SeriesNotLoaded();\\r\\n    error SeriesAlreadyLoaded();\\r\\n    error SeriesAlreadyLocked();\\r\\n    error SeriesNotLocked();\\r\\n    error SeriesDirectionProhibited();\\r\\n    error SeriesBundleInvalid();\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                               CONSTRUCTOR\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    constructor(\\r\\n          string memory _name\\r\\n        , string memory _symbol\\r\\n        , string memory _seriesZeroDescription\\r\\n        , string memory _seriesZeroHash\\r\\n        , string memory _collectionDescription\\r\\n        , string memory _wildcardDescription\\r\\n        , string memory _redeemedDescription        \\r\\n        , address _nerds\\r\\n        , address _royaltyReceiver\\r\\n        , string memory _contractURIHash\\r\\n    ) ERC721(\\r\\n          _name\\r\\n        , _symbol\\r\\n        , _nerds\\r\\n    ) {\\r\\n        ///@dev Initialize series 0 that everyone starts with.\\r\\n        seriesToSeries[0] = Series(\\r\\n              _seriesZeroDescription\\r\\n            , _seriesZeroHash\\r\\n            , 42069\\r\\n        );\\r\\n\\r\\n        collectionDescription = _collectionDescription;\\r\\n        wildcardDescription = _wildcardDescription;\\r\\n        redeemedDescription = _redeemedDescription;\\r\\n\\r\\n        royaltyReceiver = _royaltyReceiver;\\r\\n        contractURIHash = _contractURIHash;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                              MODIFIERS\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    ///@dev Prevents master locked actions.\\r\\n    modifier onlyMasterUnlocked() {\\r\\n        if(masterLocked) revert CollectionMasterLocked();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///@dev Prevents unlocked actions.\\r\\n    modifier onlyUnlocked() {\\r\\n        if(locked) revert SeriesAlreadyLocked();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///@dev Prevents locked actions.\\r\\n    modifier onlyLocked() {\\r\\n        if(!locked) revert SeriesNotLocked();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///@dev Prevents actions not on a non-loaded series.\\r\\n    modifier onlyLoaded(uint8 _series) {\\r\\n        if(bytes(seriesToSeries[_series].ipfsHash).length == 0)\\r\\n            revert SeriesNotLoaded();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    ///@dev Prevents actions on tokenIds greater than max supply.\\r\\n    modifier onlyInRange(uint256 _tokenId) {\\r\\n        if(_tokenId > MAX_SUPPLY - 1) revert TokenDoesNotExist();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                        METADATA INTILIAZATION\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the Nuclear Nerds team migrate the primary Nuclear\\r\\n     *         Nerds collection without having to migrate comics and \\r\\n     *         having instant updates as the comics would follow the migration.\\r\\n     *         As soon as utilization has completed the enabling of\\r\\n     *         master lock will prevent this function from ever being used\\r\\n     *         again. Contract ownership is delegated to multi-sig for \\r\\n     *         maximum security.\\r\\n     * @notice THIS WOULD NOT BE IMPLEMENTED IF IT WAS NOT NEEDED. ;) \\r\\n     *         (Short time horizon on the usage and locking.)\\r\\n     * @param _mirror The address of the parent token to mirror ownership of.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be contract owner\\r\\n     * - `masterLocked` must be false (default value)\\r\\n     */\\r\\n    function loadMirror(\\r\\n        address _mirror\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    { \\r\\n        mirror = IMirror(_mirror);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Loads the wildcards that have direct redemption at the\\r\\n     *         locking-point for physical transformation.\\r\\n     * @dev This function can only be ran once so that wildcards cannot\\r\\n     *      be adjusted past the time of being established.\\r\\n     * @param _tokenIds The ids of the tokens that are wildcards.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be contract owner\\r\\n     * - `wildcardsLocked` hash must be false (default value).\\r\\n     */\\r\\n    function loadWildcards(\\r\\n        uint256[] calldata _tokenIds\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        onlyOwner()\\r\\n    {\\r\\n        if(wildcardsLocked) revert CollectionWildcardsLocked();\\r\\n        \\r\\n        wildcardsLocked = true;\\r\\n\\r\\n        for(\\r\\n            uint8 i;\\r\\n            i < _tokenIds.length;\\r\\n            i++\\r\\n        ) {\\r\\n            nerdToWildcard[_tokenIds[i]] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows token holders to emit an event with\\r\\n     *         'refreshed' ownership that using the mirrored ownership\\r\\n     *         of the parent token. This way, indexers will pick up the new\\r\\n     *         ownership for far cheaper still without having to write \\r\\n     *         ownership.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     * @dev This is not needed for primary-use however, this is here for\\r\\n     *      future-proofing backup for any small issues that \\r\\n     *      take place upon delivery or future roll outs of new platforms. The \\r\\n     *      primary of this use would be that the comic has not been seperated, \\r\\n     *      but has found it's in a smart contract that needs the hook to \\r\\n     *      complete processing.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - token must NOT be claimed\\r\\n     * - sender must be owner of the token.\\r\\n     */\\r\\n    function refreshToken(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n    {\\r\\n        if(_exists(_tokenId)) revert TokenMinted();\\r\\n  \\r\\n        address _owner = mirror.ownerOf(_tokenId);\\r\\n        \\r\\n        if(_msgSender() != _owner) revert TokenOwnerMismatch();\\r\\n\\r\\n        emit Transfer(\\r\\n              address(this)\\r\\n            , _owner\\r\\n            , _tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Bundle version of token refreshing. This can only be called\\r\\n     *         if all tokens are still paired and the caller is the owner\\r\\n     *         of all comics being called.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - all tokens must NOT be claimed.\\r\\n     * - sender must be owner of all tokens.\\r\\n     */\\r\\n    function refreshTokenBundle(\\r\\n        uint256[] calldata _tokenIds\\r\\n    )\\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n    {\\r\\n        if(!mirror.isOwnerOf(\\r\\n              _msgSender()\\r\\n            , _tokenIds\\r\\n        )) revert TokenOwnerMismatch();\\r\\n\\r\\n        for(\\r\\n            uint256 i;\\r\\n            i < _tokenIds.length;\\r\\n            i++\\r\\n        ) {\\r\\n            if(_exists(_tokenIds[i])) revert TokenMinted();\\r\\n\\r\\n            emit Transfer(\\r\\n                  address(this)\\r\\n                , _msgSender()\\r\\n                , _tokenIds[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the Nuclear Nerds team to emit an event with\\r\\n     *         'refreshed' ownership utilizing the mirrored ownership\\r\\n     *         of the parent token.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     * @dev This is not needed for primary-use however, this is here for\\r\\n     *      future-proofing backup for any small issues that \\r\\n     *      take place upon delivery or future roll outs of new platforms. The \\r\\n     *      primary of this use would be that the comic has not been seperated, \\r\\n     *      but has found it's in a smart contract that needs the hook to \\r\\n     *      complete processing.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner.\\r\\n     */\\r\\n    function loadCollectionOwners(\\r\\n          uint256 _fromTokenId\\r\\n        , uint256 _toTokenId\\r\\n    )\\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    {\\r\\n        for(\\r\\n            uint256 tokenId = _fromTokenId;\\r\\n            tokenId < _toTokenId;\\r\\n            tokenId++\\r\\n        ) { \\r\\n            address _owner = mirror.ownerOf(tokenId);\\r\\n\\r\\n            emit Transfer(\\r\\n                  address(0)\\r\\n                , _owner\\r\\n                , tokenId\\r\\n            );\\r\\n\\r\\n            require(\\r\\n                _checkOnERC721Received(\\r\\n                      address(0)\\r\\n                    , _owner\\r\\n                    , tokenId\\r\\n                    , \\\"\\\"\\r\\n                )\\r\\n                , \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the Nuclear Nerds team to emit Transfer events to a \\r\\n     *         a specific target. \\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     * @dev This is not needed for primary-use however,\\r\\n     *      this is here for future-proofing/backup for any small issues that \\r\\n     *      take place upon delivery or future roll outs of new platforms.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner.\\r\\n     * - length of `to` must be the same length as the range of token ids.\\r\\n     */\\r\\n    function loadCollectionCalldata(\\r\\n            uint256 _fromTokenId\\r\\n          , uint256 _toTokenId\\r\\n          , address[] calldata _to\\r\\n    )\\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    { \\r\\n        uint256 length =  _toTokenId - _fromTokenId + 1;\\r\\n\\r\\n        if(length != _to.length) revert CollectionStateInvalid();\\r\\n\\r\\n        uint256 index;\\r\\n        for(\\r\\n            uint256 tokenId = _fromTokenId;\\r\\n            tokenId <= _toTokenId;\\r\\n            tokenId++\\r\\n        ) { \\r\\n            emit Transfer(\\r\\n                  address(0)\\r\\n                , _to[index++]\\r\\n                , tokenId\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Utilizes EIP-2309 to most efficiently emit the Transfer events\\r\\n     *         needed to notify the platforms that this token exists.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner\\r\\n     */\\r\\n    function loadCollection2309(\\r\\n            uint256 _fromTokenId\\r\\n          , uint256 _toTokenId\\r\\n    ) \\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    { \\r\\n        emit ConsecutiveTransfer(\\r\\n              _fromTokenId\\r\\n            , _toTokenId\\r\\n            , address(0)\\r\\n            , address(this)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Utilizes EIP-2309 to refresh the ownership of tokens in a \\r\\n     *         collective batch. This is to be fired after tokens have been \\r\\n     *         minted.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner\\r\\n     */\\r\\n    function loadCollection2309From(\\r\\n            uint256 _fromTokenId\\r\\n          , uint256 _toTokenId\\r\\n          , address _from\\r\\n    ) \\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    { \\r\\n        emit ConsecutiveTransfer(\\r\\n              _fromTokenId\\r\\n            , _toTokenId\\r\\n            , _from\\r\\n            , address(this)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Utilizes EIP-2309 to most efficiently emit the Transfer events\\r\\n     *         needed to notify the platforms that this token exists of a \\r\\n     *         specific range of token ids AND receivers.\\r\\n     * @notice Does not update the real ownership state and merely notifies the\\r\\n     *         platforms of an ownership record 'change' that they need \\r\\n     *         to catalog.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner\\r\\n     */\\r\\n    function loadCollection2309To(\\r\\n            uint256 _fromTokenId\\r\\n          , uint256 _toTokenId\\r\\n          , address _to\\r\\n    ) \\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    { \\r\\n        emit ConsecutiveTransfer(\\r\\n              _fromTokenId\\r\\n            , _toTokenId\\r\\n            , address(0)\\r\\n            , _to\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows owners of contract to initialize a new series of \\r\\n     *         the comic as Chapter 12 cannot be published on the same\\r\\n     *         day as Chapter 1.\\r\\n     * @dev Fundamentally, a series is 'just' an IPFS hash.\\r\\n     * @param _series The index of the series being initialized.\\r\\n     * @param _ipfsHash The ipfs hash of the cover image of the series.\\r\\n     * @param _issuanceEnd When the issue can no longer be focused.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - `locked` must be false.\\r\\n     * - sender must be contract owner\\r\\n     * `_series` hash must not be set.\\r\\n     */\\r\\n    function loadSeries(\\r\\n          uint8 _series\\r\\n        , string memory _description\\r\\n        , string memory _ipfsHash\\r\\n        , uint256 _issuanceEnd\\r\\n    )\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        onlyUnlocked()\\r\\n        onlyOwner()\\r\\n    {\\r\\n        if(bytes(seriesToSeries[_series].ipfsHash).length != 0) {\\r\\n            revert SeriesAlreadyLoaded();\\r\\n        }\\r\\n\\r\\n        seriesToSeries[_series] = Series(\\r\\n              _description\\r\\n            , _ipfsHash\\r\\n            , _issuanceEnd\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            LOCK MANAGEMENT\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @notice Locks the emission of Nuclear Nerd team member called \\r\\n     *         loadCollection(x). By default this will remain open,\\r\\n     *         however with time and the completed release of series\\r\\n     *         the community may prefer the contract reach a truly \\r\\n     *         immutable and decentralized state.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - sender must be contract owner\\r\\n     */\\r\\n    function masterLock()\\r\\n        public\\r\\n        virtual\\r\\n        onlyOwner()\\r\\n    {\\r\\n        masterLocked = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Locks the series upgrading of the collection preventing any\\r\\n     *         further series from being added and preventing holders\\r\\n     *         from upgrading their series any further.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be contract owner\\r\\n     */\\r\\n    function lock()\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        onlyOwner()\\r\\n    {     \\r\\n        locked = true;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            HOOK MANAGEMENT\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @notice Allows The Nuclear Nerd team to connect Transfer hooks\\r\\n     *         to the comic state of a token.\\r\\n     * @dev Future feature. This can also be completely disabled and \\r\\n     *      then locked to prevent any new team additions of hook contracts.\\r\\n     * @param _hook The address of the contract to accept an incoming \\r\\n     *              event from.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - `masterLocked` must be false.\\r\\n     * - sender must be contract owner.\\r\\n     */\\r\\n    function toggleHook(\\r\\n        address _hook\\r\\n    )\\r\\n        public\\r\\n        onlyMasterUnlocked()\\r\\n        onlyOwner()\\r\\n    {\\r\\n        hooks[_hook] = !hooks[_hook];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Handles the processing when a parent token of this\\r\\n     *         is transferred. To be procesed within the handling of \\r\\n     *         of the parent token. With this, ownership\\r\\n     *         of the child token will update immediately across all\\r\\n     *         indexers, marketplaces and tools.\\r\\n     * @dev Only emits an event for children tokens that haven't been seperated.\\r\\n     * @param _from The address transferring the parent token.\\r\\n     * @param _to The address transferring the child token.\\r\\n     * @param _tokenId The id of the parent:child token being transferred.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be an enabled hook contract.\\r\\n     */\\r\\n    function transferHook(\\r\\n          address _from\\r\\n        , address _to\\r\\n        , uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        if(!hooks[_msgSender()]) revert HookCallerMismatch();\\r\\n\\r\\n        if(!_exists(_tokenId)) {\\r\\n            delete _tokenApprovals[_tokenId][_from];\\r\\n            emit Approval(\\r\\n                  _from\\r\\n                , address(0)\\r\\n                , _tokenId\\r\\n            );\\r\\n\\r\\n            emit Transfer(\\r\\n                  _from\\r\\n                , _to\\r\\n                , _tokenId\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Handles the processing when a parent token of this\\r\\n     *         is transferred. To be procesed within the handling of \\r\\n     *         of the parent token. With this, ownership\\r\\n     *         of the child token will update immediately across all\\r\\n     *         indexers, marketplaces and tools.\\r\\n     * @dev Only emits an event for children tokens that haven't been seperated.\\r\\n     * @param _from The address transferring the parent token.\\r\\n     * @param _to The address transferring the child token.\\r\\n     * @param _tokenId The id of the parent:child token being transferred.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be an enabled hook contract.\\r\\n     */\\r\\n    function safeTransferHook(\\r\\n          address _from\\r\\n        , address _to\\r\\n        , uint256 _tokenId\\r\\n        , bytes memory _data\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        if(!hooks[_msgSender()]) revert HookCallerMismatch();\\r\\n\\r\\n        if(!_exists(_tokenId)) {\\r\\n            delete _tokenApprovals[_tokenId][_from];\\r\\n            emit Approval(\\r\\n                  _from\\r\\n                , address(0)\\r\\n                , _tokenId\\r\\n            );\\r\\n\\r\\n            emit Transfer(\\r\\n                  _from\\r\\n                , _to\\r\\n                , _tokenId\\r\\n            );\\r\\n\\r\\n            require(\\r\\n                  _checkOnERC721Received(\\r\\n                        _from\\r\\n                      , _to\\r\\n                      , _tokenId\\r\\n                      , _data\\r\\n                  )\\r\\n                , \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            COMIC METADATA\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the ipfs image url.\\r\\n     * @param _series The index of the series we are getting the image for.\\r\\n     * @return ipfsString The url to ipfs where the image is represented. \\r\\n     * \\r\\n     * Requires:\\r\\n     * - Series index provided must be loaded.\\r\\n     * - Token of id must exist.\\r\\n     */\\r\\n    function seriesImage(\\r\\n        uint8 _series\\r\\n    )\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyLoaded(_series)\\r\\n        returns (\\r\\n            string memory ipfsString\\r\\n        )\\r\\n    {\\r\\n        ipfsString = string(\\r\\n            abi.encodePacked(\\r\\n                  \\\"ipfs://\\\"\\r\\n                , seriesToSeries[_series].ipfsHash\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the series JSON metadata that conforms to standards.\\r\\n     * @dev The response from this function is not intended for on-chain usage.\\r\\n     * @param _series The index of the series we are getting the image for.\\r\\n     * @return metadataString The JSON string of the metadata that represents\\r\\n     *                        the supplied series. \\r\\n     * \\r\\n     * Requires:\\r\\n     * - Series index provided must be loaded.\\r\\n     * - Token of id must exist.\\r\\n     */\\r\\n    function seriesMetadata(\\r\\n          uint8 _series\\r\\n        , uint256 _tokenId\\r\\n        , bool redeemed\\r\\n        , bool exists\\r\\n        , bool wildcard\\r\\n        , uint256 votes\\r\\n    ) \\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyLoaded(_series)\\r\\n        returns (\\r\\n            string memory metadataString\\r\\n        )\\r\\n    {\\r\\n        ///@dev Append active series \\r\\n        ///@note Nerds special prologue of #00 and all series below 10 are 0 padded\\r\\n        metadataString = string(\\r\\n            abi.encodePacked(\\r\\n                  '{\\\"trait_type\\\":\\\"Series\\\",\\\"value\\\":\\\"#'\\r\\n                , _series < 10 ? string(\\r\\n                    abi.encodePacked(\\r\\n                          \\\"0\\\"\\r\\n                        , _series.toString()\\r\\n                    )\\r\\n                ) : _series.toString()\\r\\n                , '\\\"},'\\r\\n            )\\r\\n        );\\r\\n\\r\\n        ///@dev Reflect the state of the series the comic is currently at\\r\\n        ///@note Minting if issues is still open -- Limited if issues is closed and no more comics can evolve to this stage (series supply is functionally max supply locked)\\r\\n        metadataString = string(\\r\\n            abi.encodePacked(\\r\\n                  metadataString\\r\\n                , string(\\r\\n                    abi.encodePacked(\\r\\n                         '{\\\"trait_type\\\":\\\"Edition\\\",\\\"value\\\":\\\"'\\r\\n                        , seriesToSeries[_series].issuanceEnd < block.timestamp ? \\\"Limited\\\" : \\\"Minting\\\"\\r\\n                        , '\\\"},'\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n        \\r\\n        ///@dev Append metadata to reflect the Pairing Status of the token\\r\\n        ///@note When appended the ownership of the token is automatically updating until the pairing is broken through transferring or claiming.\\r\\n        metadataString = string(\\r\\n            abi.encodePacked(\\r\\n                  metadataString\\r\\n                , string(\\r\\n                    abi.encodePacked(\\r\\n                        '{\\\"trait_type\\\":\\\"Nerd\\\",\\\"value\\\":\\\"'\\r\\n                        , !exists ? string(\\r\\n                            abi.encodePacked(\\r\\n                                  \\\"#\\\"\\r\\n                                , _tokenId.toString()\\r\\n                            )\\r\\n                        ) : \\\"Unpaired\\\"\\r\\n                        , '\\\"},'\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n\\r\\n        ///@dev Adds the Schrodinger trait if applicable and reflects the status of usage\\r\\n        if(wildcard) { \\r\\n            metadataString = string(\\r\\n                abi.encodePacked(\\r\\n                      metadataString\\r\\n                    , '{\\\"trait_type\\\":\\\"Schrodinger'\\r\\n                    , \\\"'\\\"\\r\\n                    , 's Cat\\\",\\\"value\\\":\\\"'\\r\\n                    , redeemed ? \\\"Dead\\\" : \\\"Alive\\\"\\r\\n                    , '\\\"},'\\r\\n                )\\r\\n            );\\r\\n\\r\\n        ///@dev Show whether or not the token has been used for the physical comic redemption -- does not show on Schrodingers\\r\\n        } else { \\r\\n            metadataString = string(\\r\\n                abi.encodePacked(\\r\\n                      metadataString\\r\\n                    , string(\\r\\n                        abi.encodePacked(\\r\\n                            '{\\\"trait_type\\\":\\\"Status\\\",\\\"value\\\":\\\"'\\r\\n                            , redeemed ? \\\"Redeemed\\\" : \\\"Unredeemed\\\"\\r\\n                            , '\\\"},'\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        ///@dev Reflect the current number of Story Votes the owner of a Comic token earns through ownership.\\r\\n        metadataString = string(\\r\\n            abi.encodePacked(\\r\\n                  metadataString\\r\\n                , string(\\r\\n                    abi.encodePacked(\\r\\n                        '{\\\"display_type\\\":\\\"number\\\",\\\"trait_type\\\":\\\"Story Votes\\\",\\\"value\\\":\\\"'\\r\\n                        , votes.toString()\\r\\n                        , '\\\",\\\"max_value\\\":\\\"12\\\"}'\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the active series of the token to be retrieved.\\r\\n     * @dev Pick the number out from where it lives. All this does is pull down\\r\\n     *      the number that we've stored in the data packed index. With the \\r\\n     *      cumulative number in hand we nagivate into the proper bits and \\r\\n     *      make sure we return the properly cased number.\\r\\n     * @param _tokenId The token to retrieve the comic book series for.\\r\\n     * @return series The index of the series the retrieved comic represents.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenSeries(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyInRange(_tokenId)\\r\\n        returns (\\r\\n            uint8 series\\r\\n        )\\r\\n    {\\r\\n        series = uint8(\\r\\n            (\\r\\n                tokenToSeries[_tokenId / PACKED] >> (\\r\\n                    (_tokenId % PACKED) * PACKED_SHIFT\\r\\n                )\\r\\n            ) & 0xF\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the number of votes for a token.\\r\\n     * @param _tokenId The comic tokenId to check votes for.\\r\\n     * @return The number of votes the token actively contributes. \\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenVotes(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyInRange(_tokenId)\\r\\n        returns (\\r\\n            uint8\\r\\n        ) \\r\\n    {\\r\\n        if(nerdToWildcard[_tokenId]) return 12;\\r\\n        \\r\\n        return tokenSeries(_tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determines if a Comic has been used for redemption.\\r\\n     * @param _tokenId The comic tokenId being checked.\\r\\n     * @return bool url to ipfs where the image is represented.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenRedeemed(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public \\r\\n        view \\r\\n        onlyInRange(_tokenId)\\r\\n        returns(\\r\\n            bool\\r\\n        )\\r\\n    {\\r\\n        uint256 flag = (\\r\\n            tokensToRedeemed[_tokenId / 256] >> _tokenId % 256\\r\\n        ) & uint256(1);\\r\\n\\r\\n        return (flag == 1 ? true : false);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the ipfs image url for a given token.\\r\\n     * @param _tokenId The comic tokenId desired to be updated.\\r\\n     * @return The url to ipfs where the image is represented.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenImage(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyInRange(_tokenId)\\r\\n        returns (\\r\\n            string memory\\r\\n        )\\r\\n    {\\r\\n        return seriesImage(tokenSeries(_tokenId));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the series JSON metadata that conforms to standards.\\r\\n     * @dev The response from this function is not intended for on-chain usage.\\r\\n     * @param _tokenId The comic tokenId desired to be updated.\\r\\n     * @return The JSON string of the metadata that represents\\r\\n     *         the supplied series.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenMetadata(\\r\\n        uint256 _tokenId\\r\\n    ) \\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyInRange(_tokenId)\\r\\n        returns (\\r\\n            string memory\\r\\n        )\\r\\n    {\\r\\n        return seriesMetadata(\\r\\n              tokenSeries(_tokenId)\\r\\n            , _tokenId\\r\\n            , tokenRedeemed(_tokenId)\\r\\n            , _exists(_tokenId)\\r\\n            , nerdToWildcard[_tokenId]\\r\\n            , tokenVotes(_tokenId)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Generates the on-chain metadata for each non-fungible 1155.\\r\\n     * @param _tokenId The id of the token to get the uri data for.\\r\\n     * @return uri encoded json in the form of a string detailing the \\r\\n     *         retrieved token.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - token id must exist\\r\\n     */\\r\\n    function tokenURI(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        view\\r\\n        onlyInRange(_tokenId)\\r\\n        returns (\\r\\n            string memory uri\\r\\n        )        \\r\\n    { \\r\\n        uint8 series = tokenSeries(_tokenId);\\r\\n\\r\\n        uri = seriesToSeries[series].description;\\r\\n\\r\\n        if(nerdToWildcard[_tokenId]) { \\r\\n            uri = string(\\r\\n                abi.encodePacked(\\r\\n                      uri\\r\\n                    , wildcardDescription\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if(tokenRedeemed(_tokenId)) { \\r\\n            uri = string(\\r\\n                abi.encodePacked(\\r\\n                      uri\\r\\n                    , redeemedDescription\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // Build the metadata string and return it as encoded data\\r\\n        uri = string(\\r\\n            abi.encodePacked(\\r\\n                  \\\"data:application/json;base64,\\\"\\r\\n                , Base64.encode(\\r\\n                    bytes(  \\r\\n                        abi.encodePacked(\\r\\n                              '{\\\"name\\\":\\\"Nuclear Nerds Comic #'\\r\\n                            , _tokenId.toString()\\r\\n                            , '\\\",\\\"description\\\":\\\"'\\r\\n                            , collectionDescription\\r\\n                            , uri\\r\\n                            , '\\\",\\\"image\\\":\\\"'\\r\\n                            , seriesImage(series)\\r\\n                            , '?owner='\\r\\n                            , Strings.toHexString(\\r\\n                                    uint160(ownerOf(_tokenId))\\r\\n                                , 20\\r\\n                             )\\r\\n                            , '\\\",\\\"attributes\\\":['\\r\\n                            , tokenMetadata(_tokenId)\\r\\n                            , ']}'\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Helper function to assist in determining whether a Nuclear Nerd\\r\\n     *         has been used to claim a comic.\\r\\n     * @dev This function will return false if even one of the tokenId \\r\\n     *      parameters has been previously used to claim.\\r\\n     * @param _tokenIds The tokenIds of the Nuclear Nerds being checked \\r\\n     *                  for their claiming status.\\r\\n     */\\r\\n    function isClaimable(\\r\\n        uint256[] calldata _tokenIds\\r\\n    ) \\r\\n        public\\r\\n        view\\r\\n        returns (\\r\\n            bool\\r\\n        )\\r\\n    {\\r\\n        for(\\r\\n            uint256 i; \\r\\n            i < _tokenIds.length;\\r\\n            i++\\r\\n        ) {\\r\\n            if(_exists(_tokenIds[i])) \\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Helper function to used to determine if an array of \\r\\n     *         tokens can still be used to redeem a physical.\\r\\n     * @dev This function will return false if even one of the tokenId\\r\\n     *      parameters has been previously used to claim.\\r\\n     * @param _tokenIds The tokenIds of the comcis being checked.\\r\\n     */\\r\\n    function isRedeemable(\\r\\n        uint256[] calldata _tokenIds\\r\\n    )\\r\\n        public\\r\\n        view \\r\\n        returns ( \\r\\n            bool\\r\\n        )\\r\\n    {\\r\\n        for(\\r\\n            uint256 i;\\r\\n            i < _tokenIds.length;\\r\\n            i++ \\r\\n        ) { \\r\\n            if(tokenRedeemed(_tokenIds[i]))\\r\\n                return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            COMIC CONTROL\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @notice Allows holders of a Nuclear Nerd to claim a comic.\\r\\n     * @dev This mint function acts as the single token call for claiming\\r\\n     *      multiple tokens at a time.\\r\\n     * @param _tokenId The tokenId of the Nuclear Nerd being used \\r\\n     *                  to claim a Comic.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be owner of mirrored token.\\r\\n     * - token of id must NOT exist.\\r\\n     */\\r\\n    function claimComic(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        public\\r\\n        virtual\\r\\n    {\\r\\n        if (\\r\\n            mirror.ownerOf(_tokenId) != _msgSender()\\r\\n        ) revert TokenOwnerMismatch();\\r\\n\\r\\n        _mint(\\r\\n              _msgSender()\\r\\n            , _tokenId\\r\\n        );\\r\\n    }    \\r\\n\\r\\n    /**\\r\\n     * @notice Allows holders of Nuclear Nerds to claim a comic for each \\r\\n     *         Nerd they own.\\r\\n     * @dev This function should be used with reason in mind. A holder with 100 \\r\\n     *      Nerds is far more likely to have a Nerd purchased in a\\r\\n     *      long-pending transaction given low gas urgency. \\r\\n     * @param _tokenIds The tokenIds of the Nuclear Nerds being used \\r\\n     *                  to claim Comics.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - sender must be owner of all mirrored tokens.\\r\\n     * - all ids of token must NOT exist.\\r\\n     */\\r\\n    function claimComicBundle(\\r\\n          uint256[] calldata _tokenIds\\r\\n    ) \\r\\n        public\\r\\n        virtual \\r\\n    {\\r\\n        if(!mirror.isOwnerOf(\\r\\n              _msgSender()\\r\\n            , _tokenIds\\r\\n        )) revert TokenOwnerMismatch();\\r\\n\\r\\n        for(\\r\\n            uint256 i; \\r\\n            i < _tokenIds.length;\\r\\n            i++\\r\\n        ) {\\r\\n            _mint(\\r\\n                  _msgSender()\\r\\n                , _tokenIds[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Focuses a specific comic on a specific series.\\r\\n     * @dev Every _series has at most 8 bits so we can bitpack 32 of them \\r\\n     *      (8 * 32 = 256) into a single storage slot of a uint256. \\r\\n     *      This saves a significant amount of money because setting a \\r\\n     *      non-zero slot consumes 20,000 gas where as it only costs 5,000 \\r\\n     *      gas. So it is cheaper to store 31/32 times.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - series being upgraded to must have been loaded.\\r\\n     * - message sender must be the token owner.\\r\\n     * - comic cannot be downgraded.\\r\\n     * - cannot upgrade to series with closed issuance.\\r\\n     */\\r\\n    function _focusSeries(\\r\\n          uint8 _series\\r\\n        , uint256 _tokenId\\r\\n    )\\r\\n        internal\\r\\n        onlyLoaded(_series)\\r\\n    {        \\r\\n        if(_msgSender() != ownerOf(_tokenId)) revert TokenOwnerMismatch();\\r\\n    \\r\\n        uint256 seriesIndex = _tokenId / PACKED;\\r\\n        uint256 bitShift = (_tokenId % PACKED) * PACKED_SHIFT;\\r\\n\\r\\n        if(uint8(\\r\\n            (tokenToSeries[seriesIndex] >> bitShift) & 0xF\\r\\n        ) > _series) revert SeriesDirectionProhibited();\\r\\n\\r\\n        if(seriesToSeries[_series].issuanceEnd < block.timestamp) {\\r\\n            revert SeriesAlreadyLocked();\\r\\n        }\\r\\n\\r\\n        tokenToSeries[seriesIndex] =\\r\\n              (tokenToSeries[seriesIndex] & ~(0xF << bitShift)) \\r\\n            | (uint256(_series) << bitShift);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the holder of a comic to progress\\r\\n     *         the comic token to a subsequent issued series.\\r\\n     * @dev Once a comic has progressed to the next issued series,\\r\\n     *      it cannot be reverted back to a previous series.\\r\\n     * @dev A token can progress from an early series to any series\\r\\n     *      in the future provided Comics have not been locked.\\r\\n     * @param _series The desired series index.\\r\\n     * @param _tokenId The comic tokenId desired to be updated.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - series of index must be unlocked.\\r\\n     */\\r\\n    function focusSeries(\\r\\n          uint8 _series\\r\\n        , uint256 _tokenId\\r\\n    ) \\r\\n        override\\r\\n        public\\r\\n        virtual\\r\\n        onlyUnlocked()\\r\\n    {\\r\\n        _focusSeries(\\r\\n              _series\\r\\n            , _tokenId\\r\\n        );\\r\\n    }\\r\\n \\r\\n    /**\\r\\n     * @notice Allows the holder to focus multiple comics with multiple series\\r\\n     *         in the same transaction so that they can update a series of\\r\\n     *         comics all at once without having to go through pain.\\r\\n     * @dev Once a comic has progressed to the next issued series,\\r\\n     *      it cannot be reverted back to a previous series.\\r\\n     * @dev A token can progress from an early series to any series\\r\\n     * @param _series The array of desired series to be focused by tokenId.\\r\\n     * @param _tokenIds The array of tokenIds to be focused.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - series of index must be unlocked.\\r\\n     * - series array and token id array lengths must be the same.\\r\\n     */\\r\\n    function focusSeriesBundle(\\r\\n          uint8[] calldata _series\\r\\n        , uint256[] calldata _tokenIds\\r\\n    ) \\r\\n        public\\r\\n        virtual\\r\\n        onlyUnlocked()\\r\\n    {\\r\\n        if(_series.length != _tokenIds.length) revert SeriesBundleInvalid();\\r\\n\\r\\n        for(\\r\\n            uint256 i;\\r\\n            i < _series.length;\\r\\n            i++\\r\\n        ) {\\r\\n            _focusSeries(\\r\\n                  _series[i]\\r\\n                , _tokenIds[i]\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Toggles the redemption stage for a token id.\\r\\n     * @dev Implements the boolean bitpacking of 256 values into a single \\r\\n     *      storage slot. This means, that while we've created a gas-consuming\\r\\n     *      mechanism we've minimized cost to the highest extent. A boolean is \\r\\n     *      only 1 bit of information, but is typically 8 bits in solidity.\\r\\n     *      With bitpacking, we can stuff 256 values into a single storage slot\\r\\n     *      making it cheaper for the following 255 comics. This cost-savings \\r\\n     *      scales through the entire collection.\\r\\n     * \\r\\n     * Requires:\\r\\n     * - message sender must be the token owner\\r\\n     * - cannot already be redeemed\\r\\n     */\\r\\n    function _redeemComic(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        internal\\r\\n    {\\r\\n        if(ownerOf(_tokenId) != _msgSender()) revert TokenOwnerMismatch();\\r\\n\\r\\n        uint256 tokenIndex = _tokenId / 256;\\r\\n        uint256 tokenShift =  _tokenId % 256;\\r\\n\\r\\n        if(((\\r\\n            tokensToRedeemed[tokenIndex] >> tokenShift\\r\\n        ) & uint256(1)) == 1) revert TokenRedeemed();\\r\\n\\r\\n        tokensToRedeemed[tokenIndex] = (\\r\\n            tokensToRedeemed[tokenIndex] | uint256(1) << tokenShift\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a holder to redee an array of tokens.\\r\\n     * @dev The utilization of this function is not fully gated, though the \\r\\n     *      return for 'redeeming comics' is dependent on external criteria. \\r\\n     *      Nothing is earned or entitled by the redemption of a Comic unless \\r\\n     *      in the defined times and opportunities.\\r\\n     * @dev Interface calls are extremely expensive. It is worthwhile to use \\r\\n     *      the higher level processing that is available.\\r\\n     * @param _tokenIds The ids of the tokens to redeem.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - collection evolution must be locked preventing any future focusing.\\r\\n     * - token ids array length must be equal to redemption capacity\\r\\n     */\\r\\n    function redeemComics(\\r\\n          uint256[] calldata _tokenIds\\r\\n    ) \\r\\n        public\\r\\n        virtual\\r\\n        onlyLocked()\\r\\n    {\\r\\n        if(\\r\\n            _tokenIds.length != REDEMPTION_QUALIFIER\\r\\n        ) revert TokenBundleInvalid();\\r\\n\\r\\n        for (\\r\\n            uint256 i; \\r\\n            i < _tokenIds.length; \\r\\n            i++\\r\\n        ) {\\r\\n            _redeemComic(_tokenIds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a wildcard holder to redeem their token.\\r\\n     * @dev The utilization of this function is not fully gated, though the\\r\\n     *      return for 'redeeming comics' is dependent on external criteria. \\r\\n     *      Nothing is earned or entitled by the redemption of a Comic unless \\r\\n     *      in the defined times and opportunities.\\r\\n     * @dev Interface calls are extremely expensive. It is worthwhile to use \\r\\n     *      the higher level processing that is available.\\r\\n     * @param _tokenId The id of the token to redeem.\\r\\n     *\\r\\n     * Requires:\\r\\n     * - collection evolution must be locked preventing any future focusing.\\r\\n     * - token id must be a wildcard representative of a wildcard Nuclear Nerd.\\r\\n     */\\r\\n    function redeemWildcardComic(\\r\\n        uint256 _tokenId\\r\\n    ) \\r\\n        public\\r\\n        virtual\\r\\n        onlyLocked()\\r\\n    {   \\r\\n        if(!nerdToWildcard[_tokenId]) revert TokenNotWildcard();\\r\\n\\r\\n        _redeemComic(_tokenId);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            ERC721 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override\\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        return\\r\\n            interfaceId == type(IERC2981).interfaceId ||\\r\\n            interfaceId == type(IMimeticComic).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /*//////////////////////////////////////////////////////////////\\r\\n                            ERC2981 LOGIC\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n    \\r\\n    /**\\r\\n     * @notice Allows the Nuclear Nerds team to adjust contract-level metadata\\r\\n     * @param _contractURIHash The ipfs hash of the contract metadata\\r\\n     */\\r\\n    function setContractURI(\\r\\n        string memory _contractURIHash\\r\\n    )\\r\\n        public\\r\\n        onlyOwner()\\r\\n    { \\r\\n        contractURIHash = _contractURIHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the accesible url of the contract level metadata\\r\\n     */\\r\\n    function contractURI() \\r\\n        public \\r\\n        view \\r\\n        returns (\\r\\n            string memory\\r\\n        ) \\r\\n    {\\r\\n        return string(\\r\\n            abi.encodePacked(\\r\\n                  \\\"ipfs://\\\"\\r\\n                , contractURIHash\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Allows the Nuclear Nerds team to adjust where royalties\\r\\n    *         are paid out if necessary.\\r\\n    * @param _royaltyReceiver The address to send royalties to\\r\\n    */\\r\\n    function setRoyaltyReceiver(\\r\\n        address _royaltyReceiver\\r\\n    ) \\r\\n        public \\r\\n        onlyOwner() \\r\\n    {\\r\\n        require(\\r\\n              _royaltyReceiver != address(0)\\r\\n            , \\\"Royalties: new recipient is the zero address\\\"\\r\\n        );\\r\\n\\r\\n        royaltyReceiver = _royaltyReceiver;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Allows the Nuclear Nerds team to adjust the on-chain\\r\\n    *         royalty basis points.\\r\\n    * @param _royaltyBasis The new basis points earned in royalties\\r\\n    */\\r\\n    function setRoyaltyBasis(\\r\\n        uint256 _royaltyBasis\\r\\n    )\\r\\n        public\\r\\n        onlyOwner()\\r\\n    {\\r\\n        royaltyBasis = _royaltyBasis;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice EIP-2981 compliant view function for marketplaces\\r\\n    *         to calculate the royalty percentage and what address\\r\\n    *         receives them. \\r\\n    * @param _salePrice Total price of secondary sale\\r\\n    * @return address of receiver and the amount of payment to send\\r\\n    */\\r\\n    function royaltyInfo(\\r\\n          uint256\\r\\n        , uint256 _salePrice\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        returns (\\r\\n              address\\r\\n            , uint256\\r\\n        ) \\r\\n    {\\r\\n        return (\\r\\n              royaltyReceiver\\r\\n            , (_salePrice * royaltyBasis) / percentageTotal\\r\\n        );\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Comics/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\r\\n\\r\\nimport { IMirror } from \\\"../IMirror.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice This implementation of ERC721 is focused on mirroring the ownership \\r\\n *         of an existing collection to provide the initial ownership record.\\r\\n *         With this, functionally the token deployed is attached to the mirror \\r\\n *         --> until being detached. <--\\r\\n *         Once the Comic token has moved wallets independently, it functions \\r\\n *         as a normal ERC721 with it's own ownership.\\r\\n */\\r\\ncontract ERC721 is \\r\\n      Context\\r\\n    , ERC165\\r\\n    , IERC721\\r\\n    , IERC721Metadata \\r\\n{\\r\\n    using Address for address;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    ///@dev Token name\\r\\n    string private _name;\\r\\n\\r\\n    ///@dev Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    uint256 internal constant MAX_SUPPLY = 8999;\\r\\n\\r\\n    ///@dev hard coding in a max range of _owners is required.\\r\\n    address[MAX_SUPPLY] internal _owners;\\r\\n\\r\\n    ///@dev Mapping from token ID to approved address\\r\\n    ///@notice This is outside of the standard implementation as it is \\r\\n    ///        token:holder due to an ownership record that mirrors\\r\\n    ///        the parent. Once a token has been seperated from it's\\r\\n    ///        parent, approvals are cleared upon transfer. While \\r\\n    ///        paired, approvals are tied to the owning address.\\r\\n    ///        This has been accepted as this is also how operator \\r\\n    ///        approvals function by default.\\r\\n    mapping(uint256 => mapping(address => address)) internal _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\r\\n\\r\\n    IMirror public mirror;\\r\\n\\r\\n    constructor(\\r\\n          string memory name_\\r\\n        , string memory symbol_\\r\\n        , address _mirror\\r\\n    ) {\\r\\n        _name = name_;\\r\\n        _symbol = symbol_;\\r\\n        mirror = IMirror(_mirror);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(\\r\\n        bytes4 interfaceId\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override(ERC165, IERC165) \\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        return\\r\\n            interfaceId == type(IERC721).interfaceId ||\\r\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the balance of address utilizing the existing ownership *         records of comic books / nerds\\r\\n     * @dev See {IERC721-balanceOf}.\\r\\n     * @dev This is extremely gassy and IS NOT intended for on-chain usage.\\r\\n     * @param account The address to check the total balance of.\\r\\n     * @return Amount of tokens that are owned by account\\r\\n     */\\r\\n    function balanceOf(\\r\\n        address account\\r\\n    ) \\r\\n        override\\r\\n        public\\r\\n        view \\r\\n        returns(\\r\\n            uint256\\r\\n        ) \\r\\n    {\\r\\n        require(\\r\\n              account != address(0)\\r\\n            , \\\"ERC721: balance query for the zero address\\\"\\r\\n        );\\r\\n\\r\\n        uint256 counter;\\r\\n\\r\\n        for (\\r\\n            uint256 i; \\r\\n            i < MAX_SUPPLY; \\r\\n            i++\\r\\n        ) {\\r\\n            if (ERC721.ownerOf(i) == account)\\r\\n                counter++;\\r\\n        }\\r\\n\\r\\n        return counter;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-ownerOf}.\\r\\n     * @notice Overrides the default functionality of ownerOf() to utilize \\r\\n     *         phantom ownership of the tokens until they are first\\r\\n     *         transferred.\\r\\n     */\\r\\n    function ownerOf(\\r\\n        uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            address\\r\\n        ) \\r\\n    {\\r\\n        address _owner = _owners[tokenId];\\r\\n        \\r\\n        if(_owner != address(0))\\r\\n            return _owner;\\r\\n\\r\\n        return mirror.ownerOf(tokenId);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @notice Returns the entire ownership record of the comic books up to \\r\\n     *         the max supply.\\r\\n     */\\r\\n    function owners()\\r\\n        external \\r\\n        view \\r\\n        returns(\\r\\n            address[MAX_SUPPLY] memory\\r\\n        ) \\r\\n    {\\r\\n        return _owners;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-name}.\\r\\n     */\\r\\n    function name() \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            string memory\\r\\n        ) \\r\\n    {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-symbol}.\\r\\n     */\\r\\n    function symbol() \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            string memory\\r\\n        ) \\r\\n    {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-tokenURI}.\\r\\n     */\\r\\n    function tokenURI(\\r\\n        uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            string memory\\r\\n        ) \\r\\n    {\\r\\n        require(\\r\\n              _exists(tokenId)\\r\\n            , \\\"ERC721Metadata: URI query for nonexistent token\\\"\\r\\n        );\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\r\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\r\\n     * by default, can be overriden in child contracts.\\r\\n     */\\r\\n    function _baseURI() \\r\\n        internal \\r\\n        view \\r\\n        virtual \\r\\n        returns (\\r\\n            string memory\\r\\n        ) \\r\\n    {\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-approve}.\\r\\n     */\\r\\n    function approve(\\r\\n          address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        virtual \\r\\n        override \\r\\n    {\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(\\r\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\r\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n        );\\r\\n\\r\\n        _approve(\\r\\n              to\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-getApproved}.\\r\\n     */\\r\\n    function getApproved(\\r\\n        uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            address\\r\\n        ) \\r\\n    {\\r\\n        require(\\r\\n              tokenId < MAX_SUPPLY\\r\\n            , \\\"ERC721: approved query for nonexistent token\\\"\\r\\n        );\\r\\n\\r\\n        address _owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        return _tokenApprovals[tokenId][_owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(\\r\\n          address operator\\r\\n        , bool approved\\r\\n    ) \\r\\n        public \\r\\n        virtual \\r\\n        override \\r\\n    {\\r\\n        _setApprovalForAll(\\r\\n              _msgSender()\\r\\n            , operator\\r\\n            , approved\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(\\r\\n          address owner\\r\\n        , address operator\\r\\n    ) \\r\\n        public \\r\\n        view \\r\\n        virtual \\r\\n        override \\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        return _operatorApprovals[owner][operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-transferFrom}.\\r\\n     */\\r\\n    function transferFrom(\\r\\n          address from\\r\\n        , address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        virtual \\r\\n        override \\r\\n    {\\r\\n        require(\\r\\n          _isApprovedOrOwner(\\r\\n              _msgSender()\\r\\n            , tokenId\\r\\n          )\\r\\n        , \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n        _transfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n          address from\\r\\n        , address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        public \\r\\n        virtual \\r\\n        override \\r\\n    {\\r\\n        safeTransferFrom(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n            , \\\"\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n          address from\\r\\n        , address to\\r\\n        , uint256 tokenId\\r\\n        , bytes memory _data\\r\\n    ) \\r\\n        public \\r\\n        virtual \\r\\n        override \\r\\n    {\\r\\n        require(\\r\\n          _isApprovedOrOwner(\\r\\n              _msgSender()\\r\\n            , tokenId\\r\\n          )\\r\\n        , \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n        _safeTransfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n            , _data\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking \\r\\n     *      first that contract recipients are aware of the ERC721 protocol to \\r\\n     *      prevent tokens from being forever locked.\\r\\n     *\\r\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\r\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _safeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) internal virtual {\\r\\n        _transfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        require(\\r\\n              _checkOnERC721Received(\\r\\n                  from\\r\\n                , to\\r\\n                , tokenId\\r\\n                , _data\\r\\n              )\\r\\n            , \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted (`_mint`),\\r\\n     * and stop existing when they are burned (`_burn`).\\r\\n     */\\r\\n    function _exists(\\r\\n        uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        view \\r\\n        virtual \\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        return _owners[tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function _isApprovedOrOwner(\\r\\n          address spender\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        view \\r\\n        virtual \\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        require(\\r\\n              tokenId < MAX_SUPPLY\\r\\n            , \\\"ERC721: operator query for nonexistent token\\\"\\r\\n        );\\r\\n        address owner = ERC721.ownerOf(tokenId);\\r\\n        return (\\r\\n               spender == owner \\r\\n            || getApproved(tokenId) == spender \\r\\n            || isApprovedForAll(owner, spender)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must not exist.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _safeMint(\\r\\n          address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        _safeMint(\\r\\n              to\\r\\n            , tokenId\\r\\n            , \\\"\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\r\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\r\\n     */\\r\\n    function _safeMint(\\r\\n          address to\\r\\n        , uint256 tokenId\\r\\n        , bytes memory _data\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        _mint(\\r\\n              to\\r\\n            , tokenId\\r\\n        );\\r\\n        require(\\r\\n              _checkOnERC721Received(\\r\\n                  address(0)\\r\\n                , to\\r\\n                , tokenId\\r\\n                , _data\\r\\n              )\\r\\n            , \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `tokenId` and transfers it to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must not exist.\\r\\n     * - `to` cannot be the zero address.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _mint(\\r\\n          address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n        _beforeTokenTransfer(\\r\\n              address(0)\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(\\r\\n              address(0)\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        _afterTokenTransfer(\\r\\n              address(0)\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(\\r\\n        uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        address _owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        _beforeTokenTransfer(\\r\\n              _owner\\r\\n            , address(0)\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        // Clear approvals\\r\\n        delete _tokenApprovals[tokenId][_owner];\\r\\n        emit Approval(\\r\\n              _owner\\r\\n            , address(0)\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        delete _owners[tokenId];\\r\\n\\r\\n        emit Transfer(\\r\\n              _owner\\r\\n            , address(0)\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        _afterTokenTransfer(\\r\\n              _owner\\r\\n            , address(0)\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _transfer(\\r\\n          address from\\r\\n        , address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        address _owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        require(\\r\\n              _owner == from\\r\\n            , \\\"ERC721: transfer from incorrect owner\\\"\\r\\n        );\\r\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n        _beforeTokenTransfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        delete _tokenApprovals[tokenId][_owner];\\r\\n        emit Approval(\\r\\n              _owner\\r\\n            , address(0)\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        _owners[tokenId] = to;\\r\\n\\r\\n        emit Transfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n\\r\\n        _afterTokenTransfer(\\r\\n              from\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `to` to operate on `tokenId`\\r\\n     *\\r\\n     * Emits a {Approval} event.\\r\\n     */\\r\\n    function _approve(\\r\\n          address to\\r\\n        , uint256 tokenId\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        address _owner = ERC721.ownerOf(tokenId);\\r\\n\\r\\n        _tokenApprovals[tokenId][_owner] = to;\\r\\n        emit Approval(\\r\\n              _owner\\r\\n            , to\\r\\n            , tokenId\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits a {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(\\r\\n          address owner\\r\\n        , address operator\\r\\n        , bool approved\\r\\n    ) \\r\\n        internal \\r\\n        virtual \\r\\n    {\\r\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\r\\n        _operatorApprovals[owner][operator] = approved;\\r\\n        emit ApprovalForAll(owner, operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n     * The call is not executed if the target address is not a contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) \\r\\n        internal \\r\\n        returns (\\r\\n            bool\\r\\n        ) \\r\\n    {\\r\\n        if (to.isContract()) {\\r\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\r\\n                return retval == IERC721Receiver.onERC721Received.selector;\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n                } else {\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual {}\\r\\n\\r\\n    /**\\r\\n     * @dev Hook that is called after any transfer of tokens. This includes\\r\\n     * minting and burning.\\r\\n     *\\r\\n     * Calling conditions:\\r\\n     *\\r\\n     * - when `from` and `to` are both non-zero.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n     */\\r\\n    function _afterTokenTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal virtual {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Comics/IMimeticComic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IMimeticComic {\\r\\n    function loadSeries(\\r\\n          uint8 _series\\r\\n        , string memory _description\\r\\n        , string memory _ipfsHash\\r\\n        , uint256 _issuanceEnd\\r\\n    )\\r\\n        external;\\r\\n\\r\\n    function lock()\\r\\n        external;\\r\\n\\r\\n    function seriesImage(\\r\\n        uint8 _series\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory ipfsString\\r\\n        );\\r\\n\\r\\n    function seriesMetadata(\\r\\n          uint8 _series\\r\\n        , uint256 _tokenId\\r\\n        , bool redeemed\\r\\n        , bool exists\\r\\n        , bool wildcard\\r\\n        , uint256 votes\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory metadataString\\r\\n        );\\r\\n\\r\\n    function tokenSeries(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint8 series\\r\\n        );\\r\\n\\r\\n    function tokenImage(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory\\r\\n        );\\r\\n\\r\\n    function tokenMetadata(\\r\\n        uint256 _tokenId\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            string memory\\r\\n        );\\r\\n\\r\\n    function focusSeries(\\r\\n          uint8 _series\\r\\n        , uint256 _tokenId\\r\\n    )\\r\\n        external;\\r\\n}\"\r\n    },\r\n    \"contracts/Comics/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0;\\r\\n\\r\\n/// @title Base64\\r\\n/// @author Brecht Devos - <brecht@loopring.org>\\r\\n/// @notice Provides functions for encoding/decoding base64\\r\\nlibrary Base64 {\\r\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\r\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\r\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\r\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\r\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\r\\n\\r\\n    function encode(bytes memory data) internal pure returns (string memory) {\\r\\n        if (data.length == 0) return '';\\r\\n\\r\\n        // load the table into memory\\r\\n        string memory table = TABLE_ENCODE;\\r\\n\\r\\n        // multiply by 4/3 rounded up\\r\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\r\\n\\r\\n        // add some extra buffer at the end required for the writing\\r\\n        string memory result = new string(encodedLen + 32);\\r\\n\\r\\n        assembly {\\r\\n            // set the actual output length\\r\\n            mstore(result, encodedLen)\\r\\n\\r\\n            // prepare the lookup table\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // input ptr\\r\\n            let dataPtr := data\\r\\n            let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n            // result ptr, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // run over the input, 3 bytes at a time\\r\\n            for {} lt(dataPtr, endPtr) {}\\r\\n            {\\r\\n                // read 3 bytes\\r\\n                dataPtr := add(dataPtr, 3)\\r\\n                let input := mload(dataPtr)\\r\\n\\r\\n                // write 4 characters\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\r\\n                resultPtr := add(resultPtr, 1)\\r\\n            }\\r\\n\\r\\n            // padding with '='\\r\\n            switch mod(mload(data), 3)\\r\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\r\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n\\r\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\r\\n        bytes memory data = bytes(_data);\\r\\n\\r\\n        if (data.length == 0) return new bytes(0);\\r\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\r\\n\\r\\n        // load the table into memory\\r\\n        bytes memory table = TABLE_DECODE;\\r\\n\\r\\n        // every 4 characters represent 3 bytes\\r\\n        uint256 decodedLen = (data.length / 4) * 3;\\r\\n\\r\\n        // add some extra buffer at the end required for the writing\\r\\n        bytes memory result = new bytes(decodedLen + 32);\\r\\n\\r\\n        assembly {\\r\\n            // padding with '='\\r\\n            let lastBytes := mload(add(data, mload(data)))\\r\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\r\\n                decodedLen := sub(decodedLen, 1)\\r\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\r\\n                    decodedLen := sub(decodedLen, 1)\\r\\n                }\\r\\n            }\\r\\n\\r\\n            // set the actual output length\\r\\n            mstore(result, decodedLen)\\r\\n\\r\\n            // prepare the lookup table\\r\\n            let tablePtr := add(table, 1)\\r\\n\\r\\n            // input ptr\\r\\n            let dataPtr := data\\r\\n            let endPtr := add(dataPtr, mload(data))\\r\\n\\r\\n            // result ptr, jump over length\\r\\n            let resultPtr := add(result, 32)\\r\\n\\r\\n            // run over the input, 4 characters at a time\\r\\n            for {} lt(dataPtr, endPtr) {}\\r\\n            {\\r\\n               // read 4 characters\\r\\n               dataPtr := add(dataPtr, 4)\\r\\n               let input := mload(dataPtr)\\r\\n\\r\\n               // write 3 bytes\\r\\n               let output := add(\\r\\n                   add(\\r\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\r\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\r\\n                   add(\\r\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\r\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\r\\n                    )\\r\\n                )\\r\\n                mstore(resultPtr, shl(232, output))\\r\\n                resultPtr := add(resultPtr, 3)\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return result;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Comics/IMirror.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IMirror {\\r\\n    function ownerOf(uint256 tokenId_) \\r\\n        external \\r\\n        view \\r\\n        returns (\\r\\n            address\\r\\n        );\\r\\n\\r\\n    function isOwnerOf(\\r\\n          address account\\r\\n        , uint256[] calldata _tokenIds\\r\\n    ) \\r\\n        external \\r\\n        view \\r\\n        returns (\\r\\n            bool\\r\\n        );\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_seriesZeroDescription\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_seriesZeroHash\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_collectionDescription\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_wildcardDescription\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_redeemedDescription\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_nerds\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_contractURIHash\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CollectionMasterLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionStateInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CollectionWildcardsLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HookCallerMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesAlreadyLoaded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesAlreadyLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesBundleInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesDirectionProhibited\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesNotLoaded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SeriesNotLocked\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenBundleInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNotWildcard\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenOwnerMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenRedeemed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"ConsecutiveTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PACKED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PACKED_SHIFT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDEMPTION_QUALIFIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimComic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimComicBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURIHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_series\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"focusSeries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[]\",\"name\":\"_series\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"focusSeriesBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hooks\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"isClaimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"isRedeemable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"loadCollection2309\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"loadCollection2309From\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"loadCollection2309To\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"loadCollectionCalldata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toTokenId\",\"type\":\"uint256\"}],\"name\":\"loadCollectionOwners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mirror\",\"type\":\"address\"}],\"name\":\"loadMirror\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_series\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_issuanceEnd\",\"type\":\"uint256\"}],\"name\":\"loadSeries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"loadWildcards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mirror\",\"outputs\":[{\"internalType\":\"contract IMirror\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"internalType\":\"address[8999]\",\"name\":\"\",\"type\":\"address[8999]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"redeemComics\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"redeemWildcardComic\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"refreshToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"refreshTokenBundle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyBasis\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_series\",\"type\":\"uint8\"}],\"name\":\"seriesImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"ipfsString\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_series\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"wildcard\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"votes\",\"type\":\"uint256\"}],\"name\":\"seriesMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"metadataString\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"seriesToSeries\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"issuanceEnd\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractURIHash\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_royaltyBasis\",\"type\":\"uint256\"}],\"name\":\"setRoyaltyBasis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"}],\"name\":\"setRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_hook\",\"type\":\"address\"}],\"name\":\"toggleHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenImage\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenMetadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenRedeemed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenSeries\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"series\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenVotes\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensToRedeemed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wildcardsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MimeticComic", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000018000000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000004200000000000000000000000000000000000000000000000000000000000000480000000000000000000000000000000000000000000000000000000000000068000000000000000000000000000000000000000000000000000000000000007800000000000000000000000000f78c6eee3c89ff37fd9ef96bd685830993636f2000000000000000000000000efc83375b4bf4e9011a8bc716bdaada4e043e90d000000000000000000000000000000000000000000000000000000000000084000000000000000000000000000000000000000000000000000000000000000134e75636c656172204e6572647320436f6d696300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a4e45524453434f4d49430000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002272a2a43484150544552202330303a2054686520426567696e6e696e67206f662074686520456e642a2a5c6e5c6e47726f756e64205a65726f206f66206f7572204e75636c656172204e6572642773204f726967696e2053746f72792c2043686170746572202330302c2054686520426567696e6e696e67206f662074686520456e642c2074616b65732075732066726f6d207468652073747265657473206f6620436f6c6f7261646f20537072696e677320746f206465657020696e736964652043686579656e6e65204d6f756e7461696e2c20686f6d6520746f20746865204e6f72746820416d65726963616e204165726f737061636520446566656e736520436f6d6d616e6420616e642074686520776f726c642773206d6f73742064616e6765726f757320e2809c6c61756e6368e2809d20627574746f6e2e205468616e6b7320746f204169726d616e204e6f726d20616e64206f6e6520657863657074696f6e616c6c79206a7569637920636865657365737465616b2c207375666669636520697420746f207361792c207468696e677320646f206e6f74207475726e206f75742077656c6c20666f722068756d616e6974792e5c6e5c6e5b526561642053657269657320305d28687474703a2f2f6e75636c6561726e657264732e6d7970696e6174612e636c6f75642f697066732f516d57534234564c37677269366952474378315748534741616e5a50336f67664679516e5650566868357273776d295c6e5c6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e516d564e4c455a736d6444464457413875674635526d37445a5a7952753537663232613364456a5a794b4d57396a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001dc54686572652061726520382c393939204e75636c656172204e6572647320436f6d696320546f6b656e732c20656163682075706772616461626c6520746f20746865206c617465737420436f6d696320697373756520647572696e672074686174206973737565277320757067726164652077696e646f772e20446f696e6720736f2077696c6c206368616e67652074686520646973706c617920617274206f662074686520436f6d696320746f6b656e20746f2074686520636f76657220617274206f6620746861742069737375652e204f6e63652075706772616465642c206120436f6d696320746f6b656e2063616e6e6f7420676f206261636b776172647320746f20612070726576696f75732069737375652e2052656d656d6265723a2074686520696e697469616c206169722d64726f70206f662074686520436f6d696320746f6b656e20697320617474616368656420746f207468617420746f6b656e27732027706172656e7427204e6572642e20496620796f752073656c6c20796f7572204e65726420776974686f75742027756e70616972696e672720796f757220436f6d69632c20796f757220436f6d696320746f6b656e2077696c6c20626520736f6c64207769746820796f7572204e6572642e5c6e5c6e0000000000000000000000000000000000000000000000000000000000000000000000cb5468697320436f6d696320746f6b656e20706f737365737365732074686520536368726f64696e676572204d79737465727920547261697420616e642063616e2062652072656465656d656420666f722074686520506879736963616c20416e74686f6c6f67792061742074686520656e64206f6620536561736f6e20312e20497420616c736f2067697665732074686520686f6c64657220696d6d6564696174652061636365737320746f203132206164646974696f6e616c2053746f727920566f7465732e5c6e5c6e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000885468697320436f6d696320746f6b656e20686173206265656e2072656465656d656420666f72206120506879736963616c20416e74686f6c6f677920616e642063616e6e6f742062652072657573656420696e20746861742063617061636974792e20466f72206d6f726520696e666f726d6174696f6e20766965772070726f706572746965732e000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e516d5769577367366a70364d7076586b544b674367636f38316b5a3846544a53637a66625336424a683234697453000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}