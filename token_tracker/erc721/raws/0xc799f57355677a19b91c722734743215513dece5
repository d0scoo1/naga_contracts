{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Colonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./interfaces/IColonist.sol\\\";\\r\\nimport \\\"./interfaces/ITColonist.sol\\\";\\r\\nimport \\\"./interfaces/IHColonist.sol\\\";\\r\\nimport \\\"./interfaces/IEON.sol\\\";\\r\\nimport \\\"./interfaces/IPytheas.sol\\\";\\r\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\r\\n\\r\\ncontract Colonist is IColonist, ERC721, Pausable {\\r\\n    /*///////////////////////////////////////////////////////\\r\\n                    Global STATE\\r\\n    ///////////////////////////////////////////////////////*/\\r\\n\\r\\n    event ColonistMinted(uint256 indexed tokenId);\\r\\n    event ColonistBurned(uint256 indexed tokenId);\\r\\n    event ColonistStolen(uint256 indexed tokenId);\\r\\n    event ColonistNamed(uint256 indexed tokenId, string newName);\\r\\n\\r\\n    // toggle naming\\r\\n    bool public namingActive;\\r\\n\\r\\n    // max number of tokens that can be minted - 60000\\r\\n    uint256 public MAX_TOKENS = 60000;\\r\\n\\r\\n    // number of ERC721s for sale in eth\\r\\n    uint256 public PAID_TOKENS = 10000;\\r\\n\\r\\n    // an arbatrary counter to dish out IDs\\r\\n    uint16 public override minted;\\r\\n\\r\\n    // counter of colonist in circulation\\r\\n    uint256 public override totalCir;\\r\\n\\r\\n    // counter of _mint to honors amount\\r\\n    uint256 public honorMints;\\r\\n\\r\\n    // max number of colonist to mint to honor members\\r\\n    uint256 public constant maxHonorMints = 450;\\r\\n\\r\\n    // cost to name\\r\\n    uint256 public constant costToName = 2000 ether;\\r\\n\\r\\n    // mapping from tokenId to a struct containing the colonist token's traits\\r\\n    mapping(uint256 => Colonist) public tokenTraitsColonist;\\r\\n\\r\\n    // mapping from tokenId to a stuct containing the honors colonist\\r\\n    mapping(uint256 => HColonist) public tokenTraitsHonors;\\r\\n    mapping(uint256 => bool) public isHonors;\\r\\n\\r\\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\\r\\n    // used to ensure there are no duplicates\\r\\n    mapping(uint256 => uint256) public existingCombinations;\\r\\n\\r\\n    // Mapping from token ID to name\\r\\n    mapping(uint256 => string) private _tokenName;\\r\\n    mapping(uint256 => bool) private _hasName;\\r\\n\\r\\n    // Mapping if certain name string has already been reserved\\r\\n    mapping(string => bool) private _nameReserved;\\r\\n\\r\\n    // address => used in allowing system communication between contracts\\r\\n    mapping(address => bool) private admins;\\r\\n\\r\\n    // list of probabilities for each trait type\\r\\n    uint8[][8] public rarities;\\r\\n    uint8[][8] public aliases;\\r\\n\\r\\n    // reference to the Pytheas for transfers without approval\\r\\n    IPytheas public pytheas;\\r\\n\\r\\n    // reference to Traits\\r\\n    ITColonist public traits;\\r\\n\\r\\n    // reference to honors traits\\r\\n    IHColonist public honorTraits;\\r\\n\\r\\n    //reference to Randomizer\\r\\n    IRandomizer public randomizer;\\r\\n\\r\\n    //reference to EON\\r\\n    IEON public EON;\\r\\n\\r\\n    address public pirateGames;\\r\\n\\r\\n    address private imperialGuildTreasury;\\r\\n\\r\\n    address public auth;\\r\\n\\r\\n    /**\\r\\n     * instantiates contract and rarity tables\\r\\n     */\\r\\n    constructor() ERC721(\\\"ShatteredEon\\\", \\\"Colonists\\\") {\\r\\n        auth = msg.sender;\\r\\n        admins[msg.sender] = true;\\r\\n\\r\\n        // Saves users gas by making lookup O(1)\\r\\n        // A.J. Walker's Alias Algorithm\\r\\n        // Credit to WolfGame devs\\r\\n        // colonist\\r\\n        // background\\r\\n        rarities[0] = [255, 255, 255, 255, 255];\\r\\n        aliases[0] = [4, 1, 0, 3, 2];\\r\\n        // body\\r\\n        rarities[1] = [255, 220, 210, 255, 220, 200];\\r\\n        aliases[1] = [0, 1, 2, 3, 4, 5];\\r\\n        // shirt\\r\\n        rarities[2] = [120, 150, 150, 120, 20, 200, 255, 255, 190, 255, 40];\\r\\n        aliases[2] = [6, 7, 6, 7, 9, 6, 7, 9, 0, 1, 0];\\r\\n        // jacket\\r\\n        rarities[3] = [\\r\\n            20,\\r\\n            100,\\r\\n            205,\\r\\n            185,\\r\\n            235,\\r\\n            195,\\r\\n            215,\\r\\n            190,\\r\\n            215,\\r\\n            130,\\r\\n            40,\\r\\n            30,\\r\\n            220,\\r\\n            255\\r\\n        ];\\r\\n        aliases[3] = [3, 13, 5, 13, 13, 9, 13, 7, 13, 3, 13, 13, 12, 13];\\r\\n        // jaw\\r\\n        rarities[4] = [255, 255, 100, 110, 250, 125, 245, 40, 200, 35, 255];\\r\\n        aliases[4] = [0, 1, 1, 6, 0, 2, 1, 6, 9, 2, 1];\\r\\n        // hair\\r\\n        rarities[5] = [\\r\\n            245,\\r\\n            245,\\r\\n            120,\\r\\n            245,\\r\\n            200,\\r\\n            245,\\r\\n            245,\\r\\n            122,\\r\\n            220,\\r\\n            225,\\r\\n            175,\\r\\n            40,\\r\\n            25,\\r\\n            233\\r\\n        ];\\r\\n        aliases[5] = [1, 4, 5, 8, 9, 13, 13, 9, 8, 5, 4, 1, 13, 1];\\r\\n        // eyes\\r\\n        rarities[6] = [60, 225, 200, 50, 90, 200, 145, 125, 50, 255];\\r\\n        aliases[6] = [2, 1, 9, 1, 9, 5, 1, 1, 9, 9];\\r\\n        //held\\r\\n        rarities[7] = [\\r\\n            220,\\r\\n            245,\\r\\n            139,\\r\\n            120,\\r\\n            120,\\r\\n            230,\\r\\n            190,\\r\\n            35,\\r\\n            40,\\r\\n            245,\\r\\n            190,\\r\\n            90,\\r\\n            134\\r\\n        ];\\r\\n        aliases[7] = [0, 1, 5, 4, 6, 10, 1, 0, 1, 5, 4, 1, 0];\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setContracts(\\r\\n        address _traits,\\r\\n        address _honorTraits,\\r\\n        address _pytheas,\\r\\n        address _rand,\\r\\n        address _pirateGames,\\r\\n        address _eon\\r\\n    ) external onlyOwner {\\r\\n        traits = ITColonist(_traits);\\r\\n        honorTraits = IHColonist(_honorTraits);\\r\\n        pytheas = IPytheas(_pytheas);\\r\\n        randomizer = IRandomizer(_rand);\\r\\n        EON = IEON(_eon);\\r\\n        pirateGames = _pirateGames;\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                    EXTERNAL\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    /**\\r\\n     * Mint a token - any payment / game logic should be handled in the game contract.\\r\\n     * This will just generate random traits and mint a token to a designated address.\\r\\n     */\\r\\n    function _mintColonist(address recipient, uint256 seed) external override {\\r\\n        require(admins[msg.sender], \\\"Only Admins\\\");\\r\\n        require(minted + 1 <= MAX_TOKENS, \\\"All colonists deployed\\\");\\r\\n        minted++;\\r\\n        totalCir++;\\r\\n        generateColonist(minted, seed);\\r\\n        if (tx.origin != recipient && recipient != address(pytheas)) {\\r\\n            // Stolen!\\r\\n            emit ColonistStolen(minted);\\r\\n        }\\r\\n        _mint(recipient, minted);\\r\\n    }\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id) external whenNotPaused {\\r\\n        require(admins[msg.sender], \\\"Only Admins\\\");\\r\\n        require(minted + 1 <= MAX_TOKENS, \\\"All colonist deployed\\\");\\r\\n        minted++;\\r\\n        totalCir++;\\r\\n        generateHonors(minted, id);\\r\\n        _mint(recipient, minted);\\r\\n    }\\r\\n\\r\\n    function _mintToHonors(address recipient, uint256 seed) external override {\\r\\n        require(admins[msg.sender], \\\"Only Admins\\\");\\r\\n        require(minted + 1 <= MAX_TOKENS, \\\"All colonists deployed\\\");\\r\\n        require(\\r\\n            honorMints + 1 <= maxHonorMints,\\r\\n            \\\"All honor mints have been sent\\\"\\r\\n        );\\r\\n        minted++;\\r\\n        totalCir++;\\r\\n        generateColonist(minted, seed);\\r\\n        _mint(recipient, minted);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Burn a token - any game logic should be handled before this function.\\r\\n     */\\r\\n    function burn(uint256 tokenId) external override whenNotPaused {\\r\\n        require(admins[msg.sender]);\\r\\n        require(\\r\\n            ownerOf[tokenId] == tx.origin ||\\r\\n                msg.sender == address(pytheas) ||\\r\\n                msg.sender == address(pirateGames),\\r\\n            \\\"Colonist: Not Owner\\\"\\r\\n        );\\r\\n        totalCir--;\\r\\n        _burn(tokenId);\\r\\n        emit ColonistBurned(tokenId);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public override(ERC721, IColonist) {\\r\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\r\\n\\r\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n        // allow admin contracts to send without approval\\r\\n        if (!admins[msg.sender]) {\\r\\n            require(\\r\\n                msg.sender == from ||\\r\\n                    msg.sender == getApproved[id] ||\\r\\n                    isApprovedForAll[from][msg.sender],\\r\\n                \\\"NOT_AUTHORIZED\\\"\\r\\n            );\\r\\n        }\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        unchecked {\\r\\n            balanceOf[from]--;\\r\\n\\r\\n            balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        ownerOf[id] = to;\\r\\n\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(from, to, id);\\r\\n    }\\r\\n\\r\\n    function generateColonist(uint256 tokenId, uint256 seed)\\r\\n        internal\\r\\n        returns (Colonist memory t)\\r\\n    {\\r\\n        t = selectColTraits(tokenId, seed);\\r\\n        if (existingCombinations[structToHashCol(t)] == 0) {\\r\\n            tokenTraitsColonist[tokenId] = t;\\r\\n            existingCombinations[structToHashCol(t)] = tokenId;\\r\\n            emit ColonistMinted(tokenId);\\r\\n            return t;\\r\\n        }\\r\\n        return generateColonist(tokenId, randomizer.random(seed));\\r\\n    }\\r\\n\\r\\n    function generateHonors(uint256 tokenId, uint8 id)\\r\\n        internal\\r\\n        returns (HColonist memory q)\\r\\n    {\\r\\n        q.Legendary = id;\\r\\n        tokenTraitsHonors[minted] = q;\\r\\n        isHonors[minted] = true;\\r\\n        emit ColonistMinted(tokenId);\\r\\n        return q;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\\r\\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\\r\\n     * probability & alias tables are generated off-chain beforehand\\r\\n     * @param seed portion of the 256 bit seed to remove trait correlation\\r\\n     * @param traitType the trait type to select a trait for\\r\\n     * @return the ID of the randomly selected trait\\r\\n     */\\r\\n    function selectTrait(uint16 seed, uint8 traitType)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint8)\\r\\n    {\\r\\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\\r\\n        // If a selected random trait probability is selected (biased coin) return that trait\\r\\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\\r\\n        return aliases[traitType][trait];\\r\\n    }\\r\\n\\r\\n    function selectGen(uint256 tokenId) internal pure returns (uint8 gen) {\\r\\n        if (tokenId <= (60000 / 6)) return 0; //0k-10k\\r\\n        if (tokenId <= (60000 * 8) / 24) return 1; //10k-20k\\r\\n        if (tokenId <= (60000 * 12) / 24) return 2; //20k-30k\\r\\n        if (tokenId <= (60000 * 16) / 24) return 3; //30k-40k\\r\\n        if (tokenId <= (60000 * 20) / 24) return 4; //40k-50k\\r\\n        if (tokenId <= (60000 * 22) / 24) return 5;\\r\\n        //50k-60k\\r\\n        else return 5;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * selects the species and all of its traits based on the seed value\\r\\n     * @param seed a pseudorandom 256 bit number to derive traits from\\r\\n     * @return t -  a struct of randomly selected traits\\r\\n     */\\r\\n    function selectColTraits(uint256 tokenId, uint256 seed)\\r\\n        internal\\r\\n        view\\r\\n        returns (Colonist memory t)\\r\\n    {\\r\\n        t.isColonist = true;\\r\\n        seed >>= 16;\\r\\n        t.background = selectTrait(uint16(seed & 0xFFFF), 0);\\r\\n        seed >>= 16;\\r\\n        t.body = selectTrait(uint16(seed & 0xFFFF), 1);\\r\\n        seed >>= 16;\\r\\n        t.shirt = selectTrait(uint16(seed & 0xFFFF), 2);\\r\\n        seed >>= 16;\\r\\n        t.jacket = selectTrait(uint16(seed & 0xFFFF), 3);\\r\\n        seed >>= 16;\\r\\n        t.jaw = selectTrait(uint16(seed & 0xFFFF), 4);\\r\\n        seed >>= 16;\\r\\n        t.hair = selectTrait(uint16(seed & 0xFFFF), 5);\\r\\n        seed >>= 16;\\r\\n        t.eyes = selectTrait(uint16(seed & 0xFFFF), 6);\\r\\n        seed >>= 16;\\r\\n        t.held = selectTrait(uint16(seed & 0xFFFF), 7);\\r\\n        uint8 gen = selectGen(tokenId);\\r\\n        t.gen = gen;\\r\\n    }\\r\\n\\r\\n    function structToHashCol(Colonist memory s)\\r\\n        internal\\r\\n        pure\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        s.background,\\r\\n                        s.body,\\r\\n                        s.shirt,\\r\\n                        s.jacket,\\r\\n                        s.jaw,\\r\\n                        s.hair,\\r\\n                        s.eyes,\\r\\n                        s.held,\\r\\n                        s.gen\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return _tokenName[index];\\r\\n    }\\r\\n\\r\\n    function isNameReserved(string memory nameString)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _nameReserved[toLower(nameString)];\\r\\n    }\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) public view returns (bool) {\\r\\n        return _hasName[tokenId];\\r\\n    }\\r\\n\\r\\n    function nameColonist(uint256 tokenId, string memory newName) public {\\r\\n        require(namingActive == true, \\\"naming not yet available\\\");\\r\\n        require(ownerOf[tokenId] == msg.sender, \\\"Not your colonist to name\\\");\\r\\n        require(hasBeenNamed(tokenId) == false, \\\"Colonist already named\\\");\\r\\n        require(validateName(newName) == true, \\\"Not a valid name\\\");\\r\\n        require(isNameReserved(newName) == false, \\\"Name already reserved\\\");\\r\\n\\r\\n        //   IERC20(_eonAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\\r\\n\\r\\n        toggleReserveName(newName, true);\\r\\n        toggleHasName(tokenId, true);\\r\\n        _tokenName[tokenId] = newName;\\r\\n        EON.burn(_msgSender(), costToName);\\r\\n        emit ColonistNamed(tokenId, newName);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\\r\\n     */\\r\\n    function toggleReserveName(string memory str, bool isReserve) internal {\\r\\n        _nameReserved[toLower(str)] = isReserve;\\r\\n    }\\r\\n\\r\\n    function toggleHasName(uint256 tokenId, bool hasName) internal {\\r\\n        _hasName[tokenId] = hasName;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\\r\\n     */\\r\\n    function validateName(string memory str) public pure returns (bool) {\\r\\n        bytes memory b = bytes(str);\\r\\n        if (b.length < 1) return false;\\r\\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\\r\\n        if (b[0] == 0x20) return false; // Leading space\\r\\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\\r\\n\\r\\n        bytes1 lastChar = b[0];\\r\\n\\r\\n        for (uint256 i; i < b.length; i++) {\\r\\n            bytes1 char = b[i];\\r\\n\\r\\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\\r\\n\\r\\n            if (\\r\\n                !(char >= 0x30 && char <= 0x39) && //9-0\\r\\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\\r\\n                !(char >= 0x61 && char <= 0x7A) && //a-z\\r\\n                !(char == 0x20) //space\\r\\n            ) return false;\\r\\n\\r\\n            lastChar = char;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts the string to lowercase\\r\\n     */\\r\\n    function toLower(string memory str) public pure returns (string memory) {\\r\\n        bytes memory bStr = bytes(str);\\r\\n        bytes memory bLower = new bytes(bStr.length);\\r\\n        for (uint256 i = 0; i < bStr.length; i++) {\\r\\n            // Uppercase character\\r\\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\\r\\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\\r\\n            } else {\\r\\n                bLower[i] = bStr[i];\\r\\n            }\\r\\n        }\\r\\n        return string(bLower);\\r\\n    }\\r\\n\\r\\n    function getMaxTokens() external view override returns (uint256) {\\r\\n        return MAX_TOKENS;\\r\\n    }\\r\\n\\r\\n    function getPaidTokens() external view override returns (uint256) {\\r\\n        return PAID_TOKENS;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause minting\\r\\n     */\\r\\n    function setPaused(bool _paused) external onlyOwner {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables an address to mint / burn\\r\\n     * @param addr the address to enable\\r\\n     */\\r\\n    function addAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * disables an address from minting / burning\\r\\n     * @param addr the address to disbale\\r\\n     */\\r\\n    function removeAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = false;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        auth = newOwner;\\r\\n    }\\r\\n\\r\\n    function toggleNameing(bool _namingActive) external onlyOwner {\\r\\n        namingActive = _namingActive;\\r\\n    }\\r\\n\\r\\n    function setImperialGuildTreasury(address _imperialTreasury)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        imperialGuildTreasury = _imperialTreasury;\\r\\n    }\\r\\n\\r\\n    /** Traits */\\r\\n\\r\\n    function getTokenTraitsColonist(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        override(IColonist)\\r\\n        returns (Colonist memory)\\r\\n    {\\r\\n        return tokenTraitsColonist[tokenId];\\r\\n    }\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        override(IColonist)\\r\\n        returns (HColonist memory)\\r\\n    {\\r\\n        return tokenTraitsHonors[tokenId];\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (string memory)\\r\\n    {\\r\\n        if (isHonors[tokenId]) {\\r\\n            return honorTraits.tokenURI(tokenId);\\r\\n        }\\r\\n        return traits.tokenURI(tokenId);\\r\\n    }\\r\\n\\r\\n    function isOwner(uint256 tokenId) public view returns (address) {\\r\\n        address addr = ownerOf[tokenId];\\r\\n        return addr;\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public override(ERC721, IColonist) {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    \\\"\\\"\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes memory data\\r\\n    ) public override(ERC721, IColonist) {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    data\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // For OpenSeas\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return auth;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved[id] ||\\n                isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IColonist {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Colonist {\\r\\n        bool isColonist;\\r\\n        uint8 background;\\r\\n        uint8 body;\\r\\n        uint8 shirt;\\r\\n        uint8 jacket;\\r\\n        uint8 jaw;\\r\\n        uint8 eyes;\\r\\n        uint8 hair;\\r\\n        uint8 held;\\r\\n        uint8 gen;\\r\\n    }\\r\\n\\r\\n    struct HColonist {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function totalCir() external returns (uint256);\\r\\n\\r\\n    function _mintColonist(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintToHonors(address recipient, uint256 seed) external;\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getMaxTokens() external view returns (uint256);\\r\\n\\r\\n    function getPaidTokens() external view returns (uint256);\\r\\n\\r\\n    function getTokenTraitsColonist(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Colonist memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HColonist memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function nameColonist(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IEON {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IHColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IHColonist {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPytheas.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPytheas {\\r\\n    function addColonistToPytheas(address account, uint16[] calldata tokenIds)\\r\\n        external;\\r\\n\\r\\n    function claimColonistFromPytheas(address account, uint16[] calldata tokenIds, bool unstake)\\r\\n        external;\\r\\n\\r\\n    function getColonistMined(address account, uint16 tokenId)\\r\\n        external\\r\\n        returns (uint256);\\r\\n\\r\\n    function handleJoinPirates(address addr, uint16 tokenId) external;\\r\\n\\r\\n    function payUp(\\r\\n        uint16 tokenId,\\r\\n        uint256 amtMined,\\r\\n        address addr\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITColonist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITColonist {\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ColonistBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ColonistMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"ColonistNamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ColonistStolen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EON\",\"outputs\":[{\"internalType\":\"contract IEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PAID_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"_mintColonist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"_mintHonors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"_mintToHonors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"costToName\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPaidTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsColonist\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isColonist\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"background\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"shirt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"jacket\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"jaw\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"held\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"gen\",\"type\":\"uint8\"}],\"internalType\":\"struct IColonist.Colonist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsHonors\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"internalType\":\"struct IColonist.HColonist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasBeenNamed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"honorMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"honorTraits\",\"outputs\":[{\"internalType\":\"contract IHColonist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isHonors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"nameString\",\"type\":\"string\"}],\"name\":\"isNameReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHonorMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"nameColonist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"namingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pirateGames\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pytheas\",\"outputs\":[{\"internalType\":\"contract IPytheas\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomizer\",\"outputs\":[{\"internalType\":\"contract IRandomizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_honorTraits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pytheas\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pirateGames\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eon\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_imperialTreasury\",\"type\":\"address\"}],\"name\":\"setImperialGuildTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"toLower\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_namingActive\",\"type\":\"bool\"}],\"name\":\"toggleNameing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenNameByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsColonist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isColonist\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"background\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"body\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"shirt\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"jacket\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"jaw\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"held\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"gen\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsHonors\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCir\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"contract ITColonist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"validateName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Colonist", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}