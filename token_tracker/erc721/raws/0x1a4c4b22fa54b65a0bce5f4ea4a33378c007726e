{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Collection of functions related to the address type\\r\\n */\\r\\nlibrary Address {\\r\\n\\t/**\\r\\n\\t * @dev Returns true if `account` is a contract.\\r\\n\\t *\\r\\n\\t * [IMPORTANT]\\r\\n\\t * ====\\r\\n\\t * It is unsafe to assume that an address for which this function returns\\r\\n\\t * false is an externally-owned account (EOA) and not a contract.\\r\\n\\t *\\r\\n\\t * Among others, `isContract` will return false for the following\\r\\n\\t * types of addresses:\\r\\n\\t *\\r\\n\\t *  - an externally-owned account\\r\\n\\t *  - a contract in construction\\r\\n\\t *  - an address where a contract will be created\\r\\n\\t *  - an address where a contract lived, but was destroyed\\r\\n\\t * ====\\r\\n\\t */\\r\\n\\tfunction isContract(address account) internal view returns (bool) {\\r\\n\\t\\t// This method relies on extcodesize, which returns 0 for contracts in\\r\\n\\t\\t// construction, since the code is only stored at the end of the\\r\\n\\t\\t// constructor execution.\\r\\n\\r\\n\\t\\tuint256 size;\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\tsize := extcodesize(account)\\r\\n\\t\\t}\\r\\n\\t\\treturn size \\u003e 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n\\t * `recipient`, forwarding all available gas and reverting on errors.\\r\\n\\t *\\r\\n\\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n\\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n\\t * imposed by `transfer`, making them unable to receive funds via\\r\\n\\t * `transfer`. {sendValue} removes this limitation.\\r\\n\\t *\\r\\n\\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n\\t *\\r\\n\\t * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n\\t * taken to not create reentrancy vulnerabilities. Consider using\\r\\n\\t * {ReentrancyGuard} or the\\r\\n\\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n\\t */\\r\\n\\tfunction sendValue(address payable recipient, uint256 amount) internal {\\r\\n\\t\\trequire(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n\\t\\t(bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n\\t\\trequire(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Performs a Solidity function call using a low level `call`. A\\r\\n\\t * plain `call` is an unsafe replacement for a function call: use this\\r\\n\\t * function instead.\\r\\n\\t *\\r\\n\\t * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n\\t * function (like regular Solidity function calls).\\r\\n\\t *\\r\\n\\t * Returns the raw returned data. To convert to the expected return value,\\r\\n\\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `target` must be a contract.\\r\\n\\t * - calling `target` with `data` must not revert.\\r\\n\\t *\\r\\n\\t * _Available since v3.1._\\r\\n\\t */\\r\\n\\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n\\t\\treturn functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n\\t * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n\\t *\\r\\n\\t * _Available since v3.1._\\r\\n\\t */\\r\\n\\tfunction functionCall(\\r\\n\\t\\taddress target,\\r\\n\\t\\tbytes memory data,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal returns (bytes memory) {\\r\\n\\t\\treturn functionCallWithValue(target, data, 0, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n\\t * but also transferring `value` wei to `target`.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - the calling contract must have an ETH balance of at least `value`.\\r\\n\\t * - the called Solidity function must be `payable`.\\r\\n\\t *\\r\\n\\t * _Available since v3.1._\\r\\n\\t */\\r\\n\\tfunction functionCallWithValue(\\r\\n\\t\\taddress target,\\r\\n\\t\\tbytes memory data,\\r\\n\\t\\tuint256 value\\r\\n\\t) internal returns (bytes memory) {\\r\\n\\t\\treturn functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n\\t * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n\\t *\\r\\n\\t * _Available since v3.1._\\r\\n\\t */\\r\\n\\tfunction functionCallWithValue(\\r\\n\\t\\taddress target,\\r\\n\\t\\tbytes memory data,\\r\\n\\t\\tuint256 value,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal returns (bytes memory) {\\r\\n\\t\\trequire(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n\\t\\trequire(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n\\t\\t(bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n\\t\\treturn verifyCallResult(success, returndata, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n\\t * but performing a static call.\\r\\n\\t *\\r\\n\\t * _Available since v3.3._\\r\\n\\t */\\r\\n\\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n\\t\\treturn functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n\\t * but performing a static call.\\r\\n\\t *\\r\\n\\t * _Available since v3.3._\\r\\n\\t */\\r\\n\\tfunction functionStaticCall(\\r\\n\\t\\taddress target,\\r\\n\\t\\tbytes memory data,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal view returns (bytes memory) {\\r\\n\\t\\trequire(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n\\t\\t(bool success, bytes memory returndata) = target.staticcall(data);\\r\\n\\t\\treturn verifyCallResult(success, returndata, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n\\t * but performing a delegate call.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n\\t\\treturn functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\r\\n\\t * but performing a delegate call.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction functionDelegateCall(\\r\\n\\t\\taddress target,\\r\\n\\t\\tbytes memory data,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal returns (bytes memory) {\\r\\n\\t\\trequire(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n\\t\\t(bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n\\t\\treturn verifyCallResult(success, returndata, errorMessage);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn\\u0027t, either by bubbling the\\r\\n\\t * revert reason using the provided one.\\r\\n\\t *\\r\\n\\t * _Available since v4.3._\\r\\n\\t */\\r\\n\\tfunction verifyCallResult(\\r\\n\\t\\tbool success,\\r\\n\\t\\tbytes memory returndata,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal pure returns (bytes memory) {\\r\\n\\t\\tif (success) {\\r\\n\\t\\t\\treturn returndata;\\r\\n\\t\\t} else {\\r\\n\\t\\t\\t// Look for revert reason and bubble it up if present\\r\\n\\t\\t\\tif (returndata.length \\u003e 0) {\\r\\n\\t\\t\\t\\t// The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n\\t\\t\\t\\tassembly {\\r\\n\\t\\t\\t\\t\\tlet returndata_size := mload(returndata)\\r\\n\\t\\t\\t\\t\\trevert(add(32, returndata), returndata_size)\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t} else {\\r\\n\\t\\t\\t\\trevert(errorMessage);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n\\tfunction _msgSender() internal view virtual returns (address) {\\r\\n\\t\\treturn msg.sender;\\r\\n\\t}\\r\\n\\r\\n\\tfunction _msgData() internal view virtual returns (bytes calldata) {\\r\\n\\t\\treturn msg.data;\\r\\n\\t}\\r\\n}\"},\"Delegated.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\n\\r\\n/*************************\\r\\n* @author: Squeebo       *\\r\\n* @license: BSD-3-Clause *\\r\\n**************************/\\r\\n\\r\\ncontract Delegated is Ownable{\\r\\n  mapping(address =\\u003e bool) internal _delegates;\\r\\n\\r\\n  constructor(){\\r\\n\\t_delegates[owner()] = true;\\r\\n  }\\r\\n\\r\\n  modifier onlyDelegates {\\r\\n\\trequire(_delegates[msg.sender], \\\"Invalid delegate\\\" );\\r\\n\\t_;\\r\\n  }\\r\\n\\r\\n  //onlyOwner\\r\\n  function isDelegate( address addr ) external view onlyOwner returns ( bool ){\\r\\n\\treturn _delegates[addr];\\r\\n  }\\r\\n\\r\\n  function setDelegate( address addr, bool isDelegate_ ) external onlyOwner{\\r\\n\\t_delegates[addr] = isDelegate_;\\r\\n  }\\r\\n}\"},\"DimWits.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./PaymentSplitter.sol\\\";\\r\\nimport \\\"./Delegated.sol\\\";\\r\\nimport \\\"./ERC721EnumerableB.sol\\\";\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\n/****************************************\\r\\n * @author: Squeebo                     *\\r\\n * @team:   X-11                        *\\r\\n ****************************************\\r\\n *   Blimpie-ERC721 provides low-gas    *\\r\\n *           mints + transfers          *\\r\\n ****************************************/\\r\\n\\r\\ncontract DimWits is Delegated, ERC721EnumerableB, PaymentSplitter {\\r\\n\\tusing Strings for uint;\\r\\n\\r\\n\\tuint public MAX_SUPPLY = 7777;\\r\\n\\r\\n\\tbool public isActive   = false;\\r\\n\\tbool public isActiveWL = false;\\r\\n\\tuint public maxOrder   = 7;\\r\\n\\tuint public wlPrice    = 0.04 ether;\\r\\n\\tuint public price\\t   = 0.05 ether;\\r\\n\\r\\n\\tstring private _baseTokenURI = \\u0027\\u0027;\\r\\n\\tstring private _tokenURISuffix = \\u0027\\u0027;\\r\\n\\r\\n\\tmapping(address =\\u003e uint[]) private _balances;\\r\\n\\tmapping(address =\\u003e bool) public _whitelist;\\r\\n\\r\\n\\taddress[] private addressList = [\\r\\n\\t\\t0x7aa4720178a05654D48182aCF853b4eC1fe5f7E5,\\r\\n\\t\\t0xaC1F6F85c6e5Fc2C451e4f06fADAe1FF90077677,\\r\\n\\t\\t0xFa0f99C04a5E2fc967eb218E4e9678a0378bBD99,\\r\\n\\t\\t0xA6B0765819Fc970865660A31B1eB8F0e3a07F6a9,\\r\\n\\t\\t0x9B4146F5C28AAa1F6D66C93dcd042cF72bc8Ee85,\\r\\n\\t\\t0xC9312853bcD4662c316419aCd4A5552e8DEdEfe7\\r\\n\\t];\\r\\n\\tuint[] private shareList = [\\r\\n\\t\\t75,\\r\\n\\t\\t25,\\r\\n\\t\\t20,\\r\\n\\t\\t10,\\r\\n\\t\\t50,\\r\\n\\t\\t820\\r\\n\\t];\\r\\n\\r\\n\\tconstructor()\\r\\n\\t\\tDelegated()\\r\\n\\t\\tERC721B(\\\"DimWits\\\", \\\"DWS\\\")\\r\\n\\t\\tPaymentSplitter(addressList, shareList)  {\\r\\n\\t}\\r\\n\\r\\n\\t//external\\r\\n\\tfallback() external payable {}\\r\\n\\r\\n\\tfunction mint( uint quantity ) external payable {\\r\\n\\t\\trequire( isActive,        \\t\\t\\t\\t\\\"Sale is not active\\\"\\t\\t);\\r\\n\\t\\trequire( quantity \\u003c= maxOrder,          \\\"Order too big\\\"             );\\r\\n\\t\\trequire( msg.value \\u003e= price * quantity, \\\"Ether sent is not correct\\\" );\\r\\n\\r\\n\\t\\tuint256 supply = totalSupply();\\r\\n\\t\\trequire( supply + quantity \\u003c= MAX_SUPPLY, \\\"Mint/order exceeds supply\\\" );\\r\\n\\t\\tfor(uint i = 0; i \\u003c quantity; ++i){\\r\\n\\t\\t\\t_safeMint( msg.sender, supply++, \\\"\\\" );\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction whitelistMint( uint quantity ) external payable {\\r\\n\\t\\trequire( isActiveWL,        \\t\\t\\t\\\"Whitelist sale is not active\\\");\\r\\n\\t\\trequire( _whitelist[msg.sender], \\t\\t\\\"Not whitelisted\\\"\\t\\t\\t  );\\r\\n\\t\\trequire( quantity \\u003c= maxOrder,          \\\"Order too big\\\"               );\\r\\n\\t\\trequire( msg.value \\u003e= wlPrice * quantity, \\\"Ether sent is not correct\\\" );\\r\\n\\r\\n\\t\\tuint256 supply = totalSupply();\\r\\n\\t\\trequire( supply + quantity \\u003c= MAX_SUPPLY, \\\"Mint/order exceeds supply\\\" );\\r\\n\\t\\tfor(uint i = 0; i \\u003c quantity; ++i){\\r\\n\\t\\t\\t_safeMint( msg.sender, supply++, \\\"\\\" );\\r\\n\\t\\t}  \\r\\n\\t}\\r\\n\\r\\n\\t//external delegated\\r\\n\\tfunction gift(uint[] calldata quantity, address[] calldata recipient) external onlyDelegates{\\r\\n\\t\\trequire(quantity.length == recipient.length, \\\"Must provide equal quantities and recipients\\\" );\\r\\n\\r\\n\\t\\tuint totalQuantity = 0;\\r\\n\\t\\tuint256 supply = totalSupply();\\r\\n\\t\\tfor(uint i = 0; i \\u003c quantity.length; ++i){\\r\\n\\t\\t\\ttotalQuantity += quantity[i];\\r\\n\\t\\t}\\r\\n\\t\\trequire( supply + totalQuantity \\u003c= MAX_SUPPLY, \\\"Mint/order exceeds supply\\\" );\\r\\n\\t\\tdelete totalQuantity;\\r\\n\\r\\n\\t\\tfor(uint i = 0; i \\u003c recipient.length; ++i){\\r\\n\\t\\t\\tfor(uint j = 0; j \\u003c quantity[i]; ++j){\\r\\n\\t\\t\\t\\t_safeMint( recipient[i], supply++, \\\"Sent with love\\\" );\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction setWhitelist(address[] memory _addresses) external onlyDelegates {\\r\\n\\t\\tfor(uint i = 0; i \\u003c _addresses.length; ++i) {\\r\\n\\t\\t\\t_whitelist[_addresses[i]] = true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction removeFromWhitelist(address[] memory _addresses) external onlyDelegates {\\r\\n\\t\\tfor(uint i = 0; i \\u003c _addresses.length; ++i) {\\r\\n\\t\\t\\tdelete _whitelist[_addresses[i]];\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\tfunction setWhitelistActive(bool isActiveWL_) external onlyDelegates {\\r\\n\\t\\tif( isActiveWL != isActiveWL_ ) \\r\\n\\t\\t\\tisActiveWL = isActiveWL_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setActive(bool isActive_) external onlyDelegates{\\r\\n\\t\\tif( isActive != isActive_ )\\r\\n\\t\\t\\tisActive = isActive_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setMaxOrder(uint maxOrder_) external onlyDelegates{\\r\\n\\t\\tif( maxOrder != maxOrder_ )\\r\\n\\t\\t\\tmaxOrder = maxOrder_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setPrice(uint price_, uint wlprice_) external onlyDelegates{\\r\\n\\t\\tif( price != price_ )\\r\\n\\t\\t\\tprice = price_;\\r\\n\\r\\n\\t\\tif( wlPrice != wlprice_)\\r\\n\\t\\t\\twlPrice = wlprice_;\\r\\n\\t}\\r\\n\\r\\n\\tfunction setBaseURI(string calldata _newBaseURI, string calldata _newSuffix) external onlyDelegates{\\r\\n\\t\\t_baseTokenURI = _newBaseURI;\\r\\n\\t\\t_tokenURISuffix = _newSuffix;\\r\\n\\t}\\r\\n\\r\\n\\t//external owner\\r\\n\\tfunction setMaxSupply(uint maxSupply) external onlyOwner{\\r\\n\\t\\tif( MAX_SUPPLY != maxSupply ){\\r\\n\\t\\t\\trequire(maxSupply \\u003e= totalSupply(), \\\"Specified supply is lower than current balance\\\" );\\r\\n\\t\\t\\tMAX_SUPPLY = maxSupply;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t//public\\r\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n\\t\\trequire(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n\\t\\treturn _balances[owner].length;\\r\\n\\t}\\r\\n\\r\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256 tokenId) {\\r\\n\\t\\trequire(index \\u003c ERC721B.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\r\\n\\t\\treturn _balances[owner][index];\\r\\n\\t}\\r\\n\\r\\n\\tfunction tokenURI(uint tokenId) external view virtual override returns (string memory) {\\r\\n\\t\\trequire(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\r\\n\\t\\treturn string(abi.encodePacked(_baseTokenURI, tokenId.toString(), _tokenURISuffix));\\r\\n\\t}\\r\\n\\r\\n\\t//internal\\r\\n\\tfunction _beforeTokenTransfer(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) internal override virtual {\\r\\n\\t\\taddress zero = address(0);\\r\\n\\t\\tif( from != zero || to == zero ){\\r\\n\\t\\t\\t//find this token and remove it\\r\\n\\t\\t\\tuint length = _balances[from].length;\\r\\n\\t\\t\\tfor( uint i; i \\u003c length; ++i ){\\r\\n\\t\\t\\t\\tif( _balances[from][i] == tokenId ){\\r\\n\\t\\t\\t\\t\\t_balances[from][i] = _balances[from][length - 1];\\r\\n\\t\\t\\t\\t\\t_balances[from].pop();\\r\\n\\t\\t\\t\\t\\tbreak;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\tdelete length;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif( from == zero || to != zero ){\\r\\n\\t\\t\\t_balances[to].push( tokenId );\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n\\t/**\\r\\n\\t * @dev See {IERC165-supportsInterface}.\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n\\t\\treturn interfaceId == type(IERC165).interfaceId;\\r\\n\\t}\\r\\n}\"},\"ERC721B.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./IERC721Metadata.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./IERC721Receiver.sol\\\";\\r\\n\\r\\n/*************************\\r\\n* @author: Squeebo       *\\r\\n* @license: BSD-3-Clause *\\r\\n**************************/\\r\\n\\r\\nabstract contract ERC721B is Context, ERC165, IERC721, IERC721Metadata {\\r\\n\\tusing Address for address;\\r\\n\\r\\n\\t// Token name\\r\\n\\tstring private _name;\\r\\n\\r\\n\\t// Token symbol\\r\\n\\tstring private _symbol;\\r\\n\\r\\n\\t// Mapping from token ID to owner address\\r\\n\\taddress[] internal _owners;\\r\\n\\r\\n\\t// Mapping from token ID to approved address\\r\\n\\tmapping(uint256 =\\u003e address) private _tokenApprovals;\\r\\n\\r\\n\\t// Mapping from owner to operator approvals\\r\\n\\tmapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\r\\n\\t */\\r\\n\\tconstructor(string memory name_, string memory symbol_) {\\r\\n\\t\\t_name = name_;\\r\\n\\t\\t_symbol = symbol_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC165-supportsInterface}.\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\r\\n\\t\\treturn\\r\\n\\t\\t\\tinterfaceId == type(IERC721).interfaceId ||\\r\\n\\t\\t\\tinterfaceId == type(IERC721Metadata).interfaceId ||\\r\\n\\t\\t\\tsuper.supportsInterface(interfaceId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-balanceOf}.\\r\\n\\t */\\r\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\\r\\n\\t\\trequire(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\r\\n\\r\\n\\t\\tuint count = 0;\\r\\n\\t\\tuint length = _owners.length;\\r\\n\\t\\tfor( uint i = 0; i \\u003c length; ++i ){\\r\\n\\t\\t  if( owner == _owners[i] ){\\r\\n\\t\\t\\t++count;\\r\\n\\t\\t  }\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdelete length;\\r\\n\\t\\treturn count;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-ownerOf}.\\r\\n\\t */\\r\\n\\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\\r\\n\\t\\taddress owner = _owners[tokenId];\\r\\n\\t\\trequire(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\r\\n\\t\\treturn owner;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721Metadata-name}.\\r\\n\\t */\\r\\n\\tfunction name() public view virtual override returns (string memory) {\\r\\n\\t\\treturn _name;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721Metadata-symbol}.\\r\\n\\t */\\r\\n\\tfunction symbol() public view virtual override returns (string memory) {\\r\\n\\t\\treturn _symbol;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-approve}.\\r\\n\\t */\\r\\n\\tfunction approve(address to, uint256 tokenId) public virtual override {\\r\\n\\t\\taddress owner = ERC721B.ownerOf(tokenId);\\r\\n\\t\\trequire(to != owner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n\\t\\trequire(\\r\\n\\t\\t\\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\r\\n\\t\\t\\t\\\"ERC721: approve caller is not owner nor approved for all\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t_approve(to, tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-getApproved}.\\r\\n\\t */\\r\\n\\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\\r\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\r\\n\\r\\n\\t\\treturn _tokenApprovals[tokenId];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-setApprovalForAll}.\\r\\n\\t */\\r\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\\r\\n\\t\\trequire(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\r\\n\\r\\n\\t\\t_operatorApprovals[_msgSender()][operator] = approved;\\r\\n\\t\\temit ApprovalForAll(_msgSender(), operator, approved);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-isApprovedForAll}.\\r\\n\\t */\\r\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\r\\n\\t\\treturn _operatorApprovals[owner][operator];\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-transferFrom}.\\r\\n\\t */\\r\\n\\tfunction transferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) public virtual override {\\r\\n\\t\\t//solhint-disable-next-line max-line-length\\r\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\r\\n\\t\\t_transfer(from, to, tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-safeTransferFrom}.\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) public virtual override {\\r\\n\\t\\tsafeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721-safeTransferFrom}.\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) public virtual override {\\r\\n\\t\\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\r\\n\\t\\t_safeTransfer(from, to, tokenId, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n\\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n\\t *\\r\\n\\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\r\\n\\t *\\r\\n\\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\r\\n\\t * implement alternative mechanisms to perform token transfer, such as signature-based.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `from` cannot be the zero address.\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t * - `tokenId` token must exist and be owned by `from`.\\r\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction _safeTransfer(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal virtual {\\r\\n\\t\\t_transfer(from, to, tokenId);\\r\\n\\t\\trequire(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns whether `tokenId` exists.\\r\\n\\t *\\r\\n\\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n\\t *\\r\\n\\t * Tokens start existing when they are minted (`_mint`),\\r\\n\\t * and stop existing when they are burned (`_burn`).\\r\\n\\t */\\r\\n\\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n\\t\\treturn tokenId \\u003c _owners.length \\u0026\\u0026 _owners[tokenId] != address(0);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must exist.\\r\\n\\t */\\r\\n\\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\r\\n\\t\\trequire(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\r\\n\\t\\taddress owner = ERC721B.ownerOf(tokenId);\\r\\n\\t\\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Safely mints `tokenId` and transfers it to `to`.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must not exist.\\r\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction _safeMint(address to, uint256 tokenId) internal virtual {\\r\\n\\t\\t_safeMint(to, tokenId, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\r\\n\\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\r\\n\\t */\\r\\n\\tfunction _safeMint(\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) internal virtual {\\r\\n\\t\\t_mint(to, tokenId);\\r\\n\\t\\trequire(\\r\\n\\t\\t\\t_checkOnERC721Received(address(0), to, tokenId, _data),\\r\\n\\t\\t\\t\\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\r\\n\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mints `tokenId` and transfers it to `to`.\\r\\n\\t *\\r\\n\\t * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must not exist.\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction _mint(address to, uint256 tokenId) internal virtual {\\r\\n\\t\\trequire(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n\\t\\trequire(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(address(0), to, tokenId);\\r\\n\\t\\t_owners.push(to);\\r\\n\\r\\n\\t\\temit Transfer(address(0), to, tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Destroys `tokenId`.\\r\\n\\t * The approval is cleared when the token is burned.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must exist.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction _burn(uint256 tokenId) internal virtual {\\r\\n\\t\\taddress owner = ERC721B.ownerOf(tokenId);\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(owner, address(0), tokenId);\\r\\n\\r\\n\\t\\t// Clear approvals\\r\\n\\t\\t_approve(address(0), tokenId);\\r\\n\\t\\t_owners[tokenId] = address(0);\\r\\n\\r\\n\\t\\temit Transfer(owner, address(0), tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Transfers `tokenId` from `from` to `to`.\\r\\n\\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t * - `tokenId` token must be owned by `from`.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction _transfer(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) internal virtual {\\r\\n\\t\\trequire(ERC721B.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\r\\n\\t\\trequire(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\r\\n\\r\\n\\t\\t_beforeTokenTransfer(from, to, tokenId);\\r\\n\\r\\n\\t\\t// Clear approvals from the previous owner\\r\\n\\t\\t_approve(address(0), tokenId);\\r\\n\\t\\t_owners[tokenId] = to;\\r\\n\\r\\n\\t\\temit Transfer(from, to, tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Approve `to` to operate on `tokenId`\\r\\n\\t *\\r\\n\\t * Emits a {Approval} event.\\r\\n\\t */\\r\\n\\tfunction _approve(address to, uint256 tokenId) internal virtual {\\r\\n\\t\\t_tokenApprovals[tokenId] = to;\\r\\n\\t\\temit Approval(ERC721B.ownerOf(tokenId), to, tokenId);\\r\\n\\t}\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n\\t * The call is not executed if the target address is not a contract.\\r\\n\\t *\\r\\n\\t * @param from address representing the previous owner of the given token ID\\r\\n\\t * @param to target address that will receive the tokens\\r\\n\\t * @param tokenId uint256 ID of the token to be transferred\\r\\n\\t * @param _data bytes optional data to send along with the call\\r\\n\\t * @return bool whether the call correctly returned the expected magic value\\r\\n\\t */\\r\\n\\tfunction _checkOnERC721Received(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes memory _data\\r\\n\\t) private returns (bool) {\\r\\n\\t\\tif (to.isContract()) {\\r\\n\\t\\t\\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\r\\n\\t\\t\\t\\treturn retval == IERC721Receiver.onERC721Received.selector;\\r\\n\\t\\t\\t} catch (bytes memory reason) {\\r\\n\\t\\t\\t\\tif (reason.length == 0) {\\r\\n\\t\\t\\t\\t\\trevert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\r\\n\\t\\t\\t\\t} else {\\r\\n\\t\\t\\t\\t\\tassembly {\\r\\n\\t\\t\\t\\t\\t\\trevert(add(32, reason), mload(reason))\\r\\n\\t\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t} else {\\r\\n\\t\\t\\treturn true;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Hook that is called before any token transfer. This includes minting\\r\\n\\t * and burning.\\r\\n\\t *\\r\\n\\t * Calling conditions:\\r\\n\\t *\\r\\n\\t * - When `from` and `to` are both non-zero, ``from``\\u0027s `tokenId` will be\\r\\n\\t * transferred to `to`.\\r\\n\\t * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n\\t * - When `to` is zero, ``from``\\u0027s `tokenId` will be burned.\\r\\n\\t * - `from` and `to` are never both zero.\\r\\n\\t *\\r\\n\\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n\\t */\\r\\n\\tfunction _beforeTokenTransfer(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) internal virtual {}\\r\\n}\"},\"ERC721EnumerableB.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC721B.sol\\\";\\r\\nimport \\\"./IERC721Enumerable.sol\\\";\\r\\n\\r\\n/*************************\\r\\n* @author: Squeebo       *\\r\\n* @license: BSD-3-Clause *\\r\\n**************************/\\r\\n\\r\\n/**\\r\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\r\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\r\\n * account.\\r\\n */\\r\\nabstract contract ERC721EnumerableB is ERC721B, IERC721Enumerable {\\r\\n\\t/**\\r\\n\\t * @dev See {IERC165-supportsInterface}.\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721B) returns (bool) {\\r\\n\\t\\treturn interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\r\\n\\t */\\r\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256 tokenId) {\\r\\n\\t\\trequire(index \\u003c ERC721B.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\r\\n\\r\\n\\t\\tuint count;\\r\\n\\t\\tuint length = _owners.length;\\r\\n\\t\\tfor( uint i; i \\u003c length; ++i ){\\r\\n\\t\\t\\tif( owner == _owners[i] ){\\r\\n\\t\\t\\t\\tif( count == index ){\\r\\n\\t\\t\\t\\t\\tdelete count;\\r\\n\\t\\t\\t\\t\\tdelete length;\\r\\n\\t\\t\\t\\t\\treturn i;\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\telse\\r\\n\\t\\t\\t\\t\\t++count;\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tdelete count;\\r\\n\\t\\tdelete length;\\r\\n\\t\\trequire(false, \\\"ERC721Enumerable: owner index out of bounds\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721Enumerable-totalSupply}.\\r\\n\\t */\\r\\n\\tfunction totalSupply() public view virtual override returns (uint256) {\\r\\n\\t\\treturn _owners.length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev See {IERC721Enumerable-tokenByIndex}.\\r\\n\\t */\\r\\n\\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\r\\n\\t\\trequire(index \\u003c ERC721EnumerableB.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\r\\n\\t\\treturn index;\\r\\n\\t}\\r\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n\\t/**\\r\\n\\t * @dev Returns true if this contract implements the interface defined by\\r\\n\\t * `interfaceId`. See the corresponding\\r\\n\\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n\\t * to learn more about how these ids are created.\\r\\n\\t *\\r\\n\\t * This function call must use less than 30 000 gas.\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n\\t/**\\r\\n\\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n\\t */\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n\\t */\\r\\n\\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n\\t */\\r\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the number of tokens in ``owner``\\u0027s account.\\r\\n\\t */\\r\\n\\tfunction balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the owner of the `tokenId` token.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must exist.\\r\\n\\t */\\r\\n\\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n\\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `from` cannot be the zero address.\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t * - `tokenId` token must exist and be owned by `from`.\\r\\n\\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n\\t *\\r\\n\\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `from` cannot be the zero address.\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t * - `tokenId` token must be owned by `from`.\\r\\n\\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction transferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId\\r\\n\\t) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n\\t * The approval is cleared when the token is transferred.\\r\\n\\t *\\r\\n\\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The caller must own the token or be an approved operator.\\r\\n\\t * - `tokenId` must exist.\\r\\n\\t *\\r\\n\\t * Emits an {Approval} event.\\r\\n\\t */\\r\\n\\tfunction approve(address to, uint256 tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the account approved for `tokenId` token.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `tokenId` must exist.\\r\\n\\t */\\r\\n\\tfunction getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Approve or remove `operator` as an operator for the caller.\\r\\n\\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The `operator` cannot be the caller.\\r\\n\\t *\\r\\n\\t * Emits an {ApprovalForAll} event.\\r\\n\\t */\\r\\n\\tfunction setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n\\t *\\r\\n\\t * See {setApprovalForAll}\\r\\n\\t */\\r\\n\\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - `from` cannot be the zero address.\\r\\n\\t * - `to` cannot be the zero address.\\r\\n\\t * - `tokenId` token must exist and be owned by `from`.\\r\\n\\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n\\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n\\t *\\r\\n\\t * Emits a {Transfer} event.\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes calldata data\\r\\n\\t) external;\\r\\n}\"},\"IERC721Enumerable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Enumerable is IERC721 {\\r\\n\\t/**\\r\\n\\t * @dev Returns the total amount of tokens stored by the contract.\\r\\n\\t */\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\r\\n\\t * Use along with {balanceOf} to enumerate all of ``owner``\\u0027s tokens.\\r\\n\\t */\\r\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\r\\n\\t * Use along with {totalSupply} to enumerate all tokens.\\r\\n\\t */\\r\\n\\tfunction tokenByIndex(uint256 index) external view returns (uint256);\\r\\n}\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n\\t/**\\r\\n\\t * @dev Returns the token collection name.\\r\\n\\t */\\r\\n\\tfunction name() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the token collection symbol.\\r\\n\\t */\\r\\n\\tfunction symbol() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n\\t */\\r\\n\\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n\\t/**\\r\\n\\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n\\t * by `operator` from `from`, this function is called.\\r\\n\\t *\\r\\n\\t * It must return its Solidity selector to confirm the token transfer.\\r\\n\\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n\\t *\\r\\n\\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n\\t */\\r\\n\\tfunction onERC721Received(\\r\\n\\t\\taddress operator,\\r\\n\\t\\taddress from,\\r\\n\\t\\tuint256 tokenId,\\r\\n\\t\\tbytes calldata data\\r\\n\\t) external returns (bytes4);\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n\\taddress private _owner;\\r\\n\\r\\n\\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n\\t */\\r\\n\\tconstructor() {\\r\\n\\t\\t_setOwner(_msgSender());\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the address of the current owner.\\r\\n\\t */\\r\\n\\tfunction owner() public view virtual returns (address) {\\r\\n\\t\\treturn _owner;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Throws if called by any account other than the owner.\\r\\n\\t */\\r\\n\\tmodifier onlyOwner() {\\r\\n\\t\\trequire(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n\\t\\t_;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Leaves the contract without owner. It will not be possible to call\\r\\n\\t * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n\\t *\\r\\n\\t * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n\\t * thereby removing any functionality that is only available to the owner.\\r\\n\\t */\\r\\n\\tfunction renounceOwnership() public virtual onlyOwner {\\r\\n\\t\\t_setOwner(address(0));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n\\t * Can only be called by the current owner.\\r\\n\\t */\\r\\n\\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n\\t\\trequire(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n\\t\\t_setOwner(newOwner);\\r\\n\\t}\\r\\n\\r\\n\\tfunction _setOwner(address newOwner) private {\\r\\n\\t\\taddress oldOwner = _owner;\\r\\n\\t\\t_owner = newOwner;\\r\\n\\t\\temit OwnershipTransferred(oldOwner, newOwner);\\r\\n\\t}\\r\\n}\"},\"PaymentSplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PaymentSplitter\\r\\n * @dev This contract allows to split Ether payments among a group of accounts. The sender does not need to be aware\\r\\n * that the Ether will be split in this way, since it is handled transparently by the contract.\\r\\n *\\r\\n * The split can be in equal parts or in any other arbitrary proportion. The way this is specified is by assigning each\\r\\n * account to a number of shares. Of all the Ether that this contract receives, each account will then be able to claim\\r\\n * an amount proportional to the percentage of total shares they were assigned.\\r\\n *\\r\\n * `PaymentSplitter` follows a _pull payment_ model. This means that payments are not automatically forwarded to the\\r\\n * accounts but kept in this contract, and the actual transfer is triggered as a separate step by calling the {release}\\r\\n * function.\\r\\n */\\r\\ncontract PaymentSplitter is Context {\\r\\n\\tevent PayeeAdded(address account, uint256 shares);\\r\\n\\tevent PaymentReleased(address to, uint256 amount);\\r\\n\\tevent PaymentReceived(address from, uint256 amount);\\r\\n\\r\\n\\tuint256 private _totalShares;\\r\\n\\tuint256 private _totalReleased;\\r\\n\\r\\n\\tmapping(address =\\u003e uint256) private _shares;\\r\\n\\tmapping(address =\\u003e uint256) private _released;\\r\\n\\taddress[] private _payees;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\\r\\n\\t * the matching position in the `shares` array.\\r\\n\\t *\\r\\n\\t * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\\r\\n\\t * duplicates in `payees`.\\r\\n\\t */\\r\\n\\tconstructor(address[] memory payees, uint256[] memory shares_) payable {\\r\\n\\t\\trequire(payees.length == shares_.length, \\\"PaymentSplitter: payees and shares length mismatch\\\");\\r\\n\\t\\trequire(payees.length \\u003e 0, \\\"PaymentSplitter: no payees\\\");\\r\\n\\r\\n\\t\\tfor (uint256 i = 0; i \\u003c payees.length; i++) {\\r\\n\\t\\t\\t_addPayee(payees[i], shares_[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev The Ether received will be logged with {PaymentReceived} events. Note that these events are not fully\\r\\n\\t * reliable: it\\u0027s possible for a contract to receive Ether without triggering this function. This only affects the\\r\\n\\t * reliability of the events, and not the actual splitting of Ether.\\r\\n\\t *\\r\\n\\t * To learn more about this see the Solidity documentation for\\r\\n\\t * https://solidity.readthedocs.io/en/latest/contracts.html#fallback-function[fallback\\r\\n\\t * functions].\\r\\n\\t */\\r\\n\\treceive() external payable virtual {\\r\\n\\t\\temit PaymentReceived(_msgSender(), msg.value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Getter for the total shares held by payees.\\r\\n\\t */\\r\\n\\tfunction totalShares() public view returns (uint256) {\\r\\n\\t\\treturn _totalShares;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Getter for the total amount of Ether already released.\\r\\n\\t */\\r\\n\\tfunction totalReleased() public view returns (uint256) {\\r\\n\\t\\treturn _totalReleased;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Getter for the amount of shares held by an account.\\r\\n\\t */\\r\\n\\tfunction shares(address account) public view returns (uint256) {\\r\\n\\t\\treturn _shares[account];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Getter for the amount of Ether already released to a payee.\\r\\n\\t */\\r\\n\\tfunction released(address account) public view returns (uint256) {\\r\\n\\t\\treturn _released[account];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Getter for the address of the payee number `index`.\\r\\n\\t */\\r\\n\\tfunction payee(uint256 index) public view returns (address) {\\r\\n\\t\\treturn _payees[index];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Triggers a transfer to `account` of the amount of Ether they are owed, according to their percentage of the\\r\\n\\t * total shares and their previous withdrawals.\\r\\n\\t */\\r\\n\\tfunction release(address payable account) public virtual {\\r\\n\\t\\trequire(_shares[account] \\u003e 0, \\\"PaymentSplitter: account has no shares\\\");\\r\\n\\r\\n\\t\\tuint256 totalReceived = address(this).balance + _totalReleased;\\r\\n\\t\\tuint256 payment = (totalReceived * _shares[account]) / _totalShares - _released[account];\\r\\n\\r\\n\\t\\trequire(payment != 0, \\\"PaymentSplitter: account is not due payment\\\");\\r\\n\\r\\n\\t\\t_released[account] = _released[account] + payment;\\r\\n\\t\\t_totalReleased = _totalReleased + payment;\\r\\n\\r\\n\\t\\tAddress.sendValue(account, payment);\\r\\n\\t\\temit PaymentReleased(account, payment);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Add a new payee to the contract.\\r\\n\\t * @param account The address of the payee to add.\\r\\n\\t * @param shares_ The number of shares owned by the payee.\\r\\n\\t */\\r\\n\\tfunction _addPayee(address account, uint256 shares_) private {\\r\\n\\t\\trequire(account != address(0), \\\"PaymentSplitter: account is the zero address\\\");\\r\\n\\t\\trequire(shares_ \\u003e 0, \\\"PaymentSplitter: shares are 0\\\");\\r\\n\\t\\trequire(_shares[account] == 0, \\\"PaymentSplitter: account already has shares\\\");\\r\\n\\r\\n\\t\\t_payees.push(account);\\r\\n\\t\\t_shares[account] = shares_;\\r\\n\\t\\t_totalShares = _totalShares + shares_;\\r\\n\\t\\temit PayeeAdded(account, shares_);\\r\\n\\t}\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n// CAUTION\\r\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\r\\n// because it relies on the compiler\\u0027s built in overflow checks.\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity\\u0027s arithmetic operations.\\r\\n *\\r\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\r\\n * now has built in overflow checking.\\r\\n */\\r\\nlibrary SafeMath {\\r\\n\\t/**\\r\\n\\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tuint256 c = a + b;\\r\\n\\t\\t\\tif (c \\u003c a) return (false, 0);\\r\\n\\t\\t\\treturn (true, c);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tif (b \\u003e a) return (false, 0);\\r\\n\\t\\t\\treturn (true, a - b);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t// Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n\\t\\t\\t// benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n\\t\\t\\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n\\t\\t\\tif (a == 0) return (true, 0);\\r\\n\\t\\t\\tuint256 c = a * b;\\r\\n\\t\\t\\tif (c / a != b) return (false, 0);\\r\\n\\t\\t\\treturn (true, c);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tif (b == 0) return (false, 0);\\r\\n\\t\\t\\treturn (true, a / b);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\r\\n\\t *\\r\\n\\t * _Available since v3.4._\\r\\n\\t */\\r\\n\\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\tif (b == 0) return (false, 0);\\r\\n\\t\\t\\treturn (true, a % b);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the addition of two unsigned integers, reverting on\\r\\n\\t * overflow.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `+` operator.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - Addition cannot overflow.\\r\\n\\t */\\r\\n\\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn a + b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n\\t * overflow (when the result is negative).\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - Subtraction cannot overflow.\\r\\n\\t */\\r\\n\\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn a - b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n\\t * overflow.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `*` operator.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - Multiplication cannot overflow.\\r\\n\\t */\\r\\n\\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn a * b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the integer division of two unsigned integers, reverting on\\r\\n\\t * division by zero. The result is rounded towards zero.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `/` operator.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The divisor cannot be zero.\\r\\n\\t */\\r\\n\\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn a / b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n\\t * reverting when dividing by zero.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n\\t * invalid opcode to revert (consuming all remaining gas).\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The divisor cannot be zero.\\r\\n\\t */\\r\\n\\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n\\t\\treturn a % b;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n\\t * overflow (when the result is negative).\\r\\n\\t *\\r\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n\\t * message unnecessarily. For custom revert reasons use {trySub}.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `-` operator.\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - Subtraction cannot overflow.\\r\\n\\t */\\r\\n\\tfunction sub(\\r\\n\\t\\tuint256 a,\\r\\n\\t\\tuint256 b,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal pure returns (uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\trequire(b \\u003c= a, errorMessage);\\r\\n\\t\\t\\treturn a - b;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\r\\n\\t * division by zero. The result is rounded towards zero.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n\\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n\\t * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The divisor cannot be zero.\\r\\n\\t */\\r\\n\\tfunction div(\\r\\n\\t\\tuint256 a,\\r\\n\\t\\tuint256 b,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal pure returns (uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\trequire(b \\u003e 0, errorMessage);\\r\\n\\t\\t\\treturn a / b;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n\\t * reverting with custom message when dividing by zero.\\r\\n\\t *\\r\\n\\t * CAUTION: This function is deprecated because it requires allocating memory for the error\\r\\n\\t * message unnecessarily. For custom revert reasons use {tryMod}.\\r\\n\\t *\\r\\n\\t * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n\\t * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n\\t * invalid opcode to revert (consuming all remaining gas).\\r\\n\\t *\\r\\n\\t * Requirements:\\r\\n\\t *\\r\\n\\t * - The divisor cannot be zero.\\r\\n\\t */\\r\\n\\tfunction mod(\\r\\n\\t\\tuint256 a,\\r\\n\\t\\tuint256 b,\\r\\n\\t\\tstring memory errorMessage\\r\\n\\t) internal pure returns (uint256) {\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\trequire(b \\u003e 0, errorMessage);\\r\\n\\t\\t\\treturn a % b;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n\\tbytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n\\t */\\r\\n\\tfunction toString(uint256 value) internal pure returns (string memory) {\\r\\n\\t\\t// Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n\\t\\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n\\t\\tif (value == 0) {\\r\\n\\t\\t\\treturn \\\"0\\\";\\r\\n\\t\\t}\\r\\n\\t\\tuint256 temp = value;\\r\\n\\t\\tuint256 digits;\\r\\n\\t\\twhile (temp != 0) {\\r\\n\\t\\t\\tdigits++;\\r\\n\\t\\t\\ttemp /= 10;\\r\\n\\t\\t}\\r\\n\\t\\tbytes memory buffer = new bytes(digits);\\r\\n\\t\\twhile (value != 0) {\\r\\n\\t\\t\\tdigits -= 1;\\r\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n\\t\\t\\tvalue /= 10;\\r\\n\\t\\t}\\r\\n\\t\\treturn string(buffer);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n\\t */\\r\\n\\tfunction toHexString(uint256 value) internal pure returns (string memory) {\\r\\n\\t\\tif (value == 0) {\\r\\n\\t\\t\\treturn \\\"0x00\\\";\\r\\n\\t\\t}\\r\\n\\t\\tuint256 temp = value;\\r\\n\\t\\tuint256 length = 0;\\r\\n\\t\\twhile (temp != 0) {\\r\\n\\t\\t\\tlength++;\\r\\n\\t\\t\\ttemp \\u003e\\u003e= 8;\\r\\n\\t\\t}\\r\\n\\t\\treturn toHexString(value, length);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n\\t */\\r\\n\\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n\\t\\tbytes memory buffer = new bytes(2 * length + 2);\\r\\n\\t\\tbuffer[0] = \\\"0\\\";\\r\\n\\t\\tbuffer[1] = \\\"x\\\";\\r\\n\\t\\tfor (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n\\t\\t\\tbuffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\r\\n\\t\\t\\tvalue \\u003e\\u003e= 4;\\r\\n\\t\\t}\\r\\n\\t\\trequire(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n\\t\\treturn string(buffer);\\r\\n\\t}\\r\\n}\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"quantity\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"recipient\",\"type\":\"address[]\"}],\"name\":\"gift\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActiveWL\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isDelegate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"payee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isActive_\",\"type\":\"bool\"}],\"name\":\"setActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_newSuffix\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isDelegate_\",\"type\":\"bool\"}],\"name\":\"setDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxOrder_\",\"type\":\"uint256\"}],\"name\":\"setMaxOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wlprice_\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isActiveWL_\",\"type\":\"bool\"}],\"name\":\"setWhitelistActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReleased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wlPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DimWits", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5601e3ce0d35031ed5b817d4c694c10ba0216bea9654bfbd6cf8ec5a6a1b8c1d"}]}