{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Blank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// @author mouradif.eth\\n\\npragma solidity 0.8.14;\\n\\nimport \\\"../interfaces/IBlank.sol\\\";\\nimport \\\"./BlankGenesis.sol\\\";\\n\\ncontract Blank is IBlank, BlankGenesis {\\n// ################################################################ //\\n//                                                      .           //\\n//                                          .::=+*##%%%%*.          //\\n//                                      -=*%@@@@@@@@@@@@=           //\\n//                                  :=*%@@@@@@@%##%@@@@+.           //\\n//                               :=#@@@@@@#+-:.  :%@@@*.            //\\n//                             -*@@@@@#+-.      :%@@@#.             //\\n//                           -*@@@@@+:         =%@@@*.              //\\n//                         .*@@@@%=.         =#@@@%-                //\\n//                        -%@@@@*:        :+%@@@@+:                 //\\n//                       +@@@@#-       :+#@@@@@@#:                  //\\n//                      +@@@@+.      .-===++%@@@@%:                 //\\n//                     +@@@@=              .*@@@@=                  //\\n//                    +@@@@=              -%@@@@=                   //\\n//                   +@@@@=             =#@@@@#-                    //\\n//                  -%@@@*.         :=*%@@@@#=                      //\\n//                 :#@@@#:  ..:-=*#%@@@@@@*-                        //\\n//                 +@@@@=-*%%@@@@@@@@@@#+:                          //\\n//                :%@@@@@@@@@@@@%##+-:.                             //\\n//                +@@@@@@@@*+-:.                                    //\\n//               :%@@@@@%+:                                         //\\n//               =@@@@@#.                                           //\\n//              .#@@@@#.                                            //\\n//              -%@@@*.                                             //\\n//              *@@@@-             Blank.                           //\\n//                                 Made with <3 by a team of        //\\n//                                 passionate innovators            //\\n//             *@@@@@-                                              //\\n//             *@@@@@-             Smart Contract by:               //\\n//             +%%%%%-             Mouradif                         //\\n//                                                                  //\\n//                                                                  //\\n// ################################################################ //\\n/**\\n *  Blank Studio Genesis NFT Contracts\\n *\\n *  Blank.sol: The Blank contract\\n *  BlankGenesis.sol: Public mint functions and withdraw\\n *  BlankBase.sol: Minting rules, validation functions\\n *  ERC721.sol: NFT implementation heavily inspired from the latest ERC721A\\n *\\n *  The Heart\\n *\\n *  Blank. is forging a new frontier of innovation and creativity in the rapidly\\n *  emerging NFT space.\\n *  Blank. will encourage pure expression and provide ways for this expression to\\n *  be seen and appreciated.\\n *  With our unique curation and innovative style, it is never impossible.\\n *\\n *  Mutual Trust & Respect\\n *\\n *  Blank. is built on trust and respect. We know innovation takes time to\\n *  understand and adapt. Side by side, we can build and grow the Blank. ecosystem.\\n *\\n *  Xpression\\n *\\n *  We welcome every thought and idea from the community that shapes us. Express yourself\\n *  without reserve or shame, and show your creativity unapologetically. Blank. is an open\\n *  canvas for bringing your Xpression to life.\\n *\\n *  Degens vs Innovators\\n *\\n *  There is a fine line between degens and innovators. At Blank. no one is afraid to live\\n *  on the apex.\\n *  We test the limits and, as the space evolves, need to grow and innovate alongside it.\\n *\\n **/\\n}\\n\"\r\n    },\r\n    \"interfaces/IBlank.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"./IERC721A.sol\\\";\\n\\ninterface IBlank is IERC721A {\\n  // TODO:\\n}\\n\"\r\n    },\r\n    \"contracts/BlankGenesis.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"./BlankBase.sol\\\";\\n\\ncontract BlankGenesis is BlankBase {\\n\\n    /// @notice Free Mint for the devs\\n    ///         - Only Role Admin (deployer)\\n    ///         - Can't exceed the genesis supply\\n    ///         - Can't devMint more than DEV_SUPPLY\\n    function devMint()\\n    public\\n    onlyOwner\\n    hasSubgroupSupply(DEV_SUPPLY, devMints)\\n    {\\n        devMints++;\\n        _mint(msg.sender);\\n    }\\n\\n    /// @notice Free Mint for the project owners\\n    ///         - After mint has started\\n    ///         - One mint per address\\n    ///         - Can't exceed the freeMints supply\\n    ///         - Caller address must be signed by the Free Mint Approver\\n    function freeMint(bytes calldata signature)\\n    public\\n    mintHasStarted\\n    canStillMint\\n    isMintApproved(freeMintApprover, signature)\\n    hasSubgroupSupply(FREE_SUPPLY, freeMints)\\n    {\\n        freeMints++;\\n        _mint(msg.sender);\\n    }\\n\\n    /// @notice Regular Mint for the blanklisted addresses\\n    ///         - After mint has started\\n    ///         - One mint per address\\n    ///         - Can't exceed the Genesis supply minus reserved tokens (free and dev mints)\\n    ///         - Caller address must be signed by the Blank List Approver\\n    function blankListMint(bytes calldata signature)\\n    public\\n    payable\\n    mintHasStarted\\n    canStillMint\\n    isMintApproved(blankApprover, signature)\\n    hasTokenSupply(GENESIS_SUPPLY - DEV_SUPPLY - FREE_SUPPLY + devMints + freeMints)\\n    hasTheRightAmount\\n    {\\n        _mint(msg.sender);\\n    }\\n\\n    /// @notice Regular Mint for the blanklisted addresses\\n    ///         - After mint has started\\n    ///         - One mint per address\\n    ///         - Can't exceed the Genesis supply minus reserved tokens (free and dev mints)\\n    ///         - Caller address must be signed by the Reserve List Approver\\n    function reserveListMint(bytes calldata signature)\\n    public\\n    payable\\n    reserveHasStarted\\n    canStillMint\\n    isMintApproved(reserveApprover, signature)\\n    hasTokenSupply(GENESIS_SUPPLY - DEV_SUPPLY - FREE_SUPPLY + devMints + freeMints)\\n    hasTheRightAmount\\n    {\\n        _mint(msg.sender);\\n    }\\n\\n    /// @notice This function will be called by the Gen2 contract to burn 4 32x32 canvases into one 64x64\\n    ///         All the validation will be made in there (checking that the 4 tokens are in the right spot mainly)\\n    ///         It will burn the 4 tokens on the Gen2 and mint one here allowing their owner to ascend into genesis\\n    function burnIntoGenesis(address ascendant)\\n    public\\n    onlyGen2Contract\\n    hasSubgroupSupply(GEN2_SUPPLY, gen2Mints)\\n    {\\n        gen2Mints++;\\n        _mint(ascendant);\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/IERC721A.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721A Contracts v4.0.0\\n// Creator: Chiru Labs\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of an ERC721A compliant contract.\\n */\\ninterface IERC721A {\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error ApprovalCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error ApprovalQueryForNonexistentToken();\\n\\n    /**\\n     * The caller cannot approve to their own address.\\n     */\\n    error ApproveToCaller();\\n\\n    /**\\n     * The caller cannot approve to the current owner.\\n     */\\n    error ApprovalToCurrentOwner();\\n\\n    /**\\n     * Cannot query the balance for the zero address.\\n     */\\n    error BalanceQueryForZeroAddress();\\n\\n    /**\\n     * Cannot mint to the zero address.\\n     */\\n    error MintToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error OwnerQueryForNonexistentToken();\\n\\n    /**\\n     * The caller must own the token or be an approved operator.\\n     */\\n    error TransferCallerNotOwnerNorApproved();\\n\\n    /**\\n     * The token must be owned by `from`.\\n     */\\n    error TransferFromIncorrectOwner();\\n\\n    /**\\n     * Cannot safely transfer to a contract that does not implement the ERC721Receiver interface.\\n     */\\n    error TransferToNonERC721ReceiverImplementer();\\n\\n    /**\\n     * Cannot transfer to the zero address.\\n     */\\n    error TransferToZeroAddress();\\n\\n    /**\\n     * The token does not exist.\\n     */\\n    error URIQueryForNonexistentToken();\\n\\n    struct TokenOwnership {\\n        // The address of the owner.\\n        address addr;\\n        // Keeps track of the start time of ownership with minimal overhead for tokenomics.\\n        uint64 startTimestamp;\\n        // Whether the token has been burned.\\n        bool burned;\\n    }\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     *\\n     * Burned tokens are calculated here, use `_totalMinted()` if you want to count just minted tokens.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    // ==============================\\n    //            IERC165\\n    // ==============================\\n\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n\\n    // ==============================\\n    //            IERC721\\n    // ==============================\\n\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    // ==============================\\n    //        IERC721Metadata\\n    // ==============================\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/BlankBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\ncontract BlankBase is ERC721, Ownable {\\n    /// @dev Addresses that can approve restricted mints\\n    address internal freeMintApprover = 0xb681cFf9A2Ed00756A7144afd9378455751b0A8e;\\n    address internal blankApprover = 0x074631a146ABF0103453507094084f29982F7e0e;\\n    address internal reserveApprover = 0x3a192C386db33C3d65c1a34dBE562860A61BEA4b;\\n\\n    /// @dev Infos of the Gen2 contract\\n    address internal gen2Contract;\\n\\n    /// @notice Mint configuration\\n    uint256 public constant MINT_PRICE = 0.29 ether;\\n    uint256 public constant GENESIS_SUPPLY = 400;\\n    uint256 public constant DEV_SUPPLY = 4;\\n    uint256 public constant FREE_SUPPLY = 25;\\n    uint256 public constant GEN2_SUPPLY = 3200; // 12800 divided by 4;\\n\\n    /// @notice Mint start timestamp\\n    uint256 public mintStartTimestamp = 1653987600; // May 31st 2022, 10AM BST\\n    uint256 public whitelistMintDuration = 12 hours;\\n\\n    /// @notice Mint counters for subgroups with dedicated supply\\n    uint256 public devMints;\\n    uint256 public freeMints;\\n    uint256 public gen2Mints;\\n\\n    /// @dev Modifier to ensure the message signer is the one expected\\n    modifier isMintApproved(address approver, bytes calldata signature) {\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(abi.encodePacked(msg.sender))\\n            )\\n        );\\n        require(\\n            ECDSA.recover(hash, signature) == approver,\\n            \\\"You have not been approved for this mint\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Modifier to ensure the caller hasn't already minted\\n    modifier canStillMint() {\\n        require(!hasMinted(msg.sender), \\\"You can only mint once\\\"); // YOMO: You Only Mint Once\\n        _;\\n    }\\n\\n    /// @dev Modifier to ensure the max supply won't be exceeded by a genesis mint transaction\\n    modifier hasTokenSupply(uint256 supply) {\\n        require(_currentIndex < supply, \\\"Mint supply reached\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier to ensure the max supply won't be exceeded by a genesis mint transaction\\n    modifier hasSubgroupSupply(uint256 supply, uint256 current) {\\n        require(current < supply, \\\"Mint supply reached for this category\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks that the mint has started and that devs have already minted token 0\\n    modifier mintHasStarted() {\\n        require(\\n            block.timestamp >= mintStartTimestamp && _currentIndex > 0,\\n            \\\"Mint has not started\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @dev Modifier that checks that the reserve list can mint\\n    modifier reserveHasStarted() {\\n        require(\\n            block.timestamp >= mintStartTimestamp + whitelistMintDuration && _currentIndex > 0,\\n            \\\"Reserve Mint has not started\\\"\\n        );\\n        _;\\n    }\\n\\n\\n    /// @dev Modifier to ensure the right amount has been sent (no more, no less)\\n    modifier hasTheRightAmount() {\\n        require(msg.value == MINT_PRICE, \\\"You must send the right amount\\\");\\n        _;\\n    }\\n\\n    /// @dev Modifier to ensure the call was made by the Gen2 contract\\n    modifier onlyGen2Contract() {\\n        require(msg.sender == gen2Contract, \\\"Caller must be Blank Gen 2\\\");\\n        _;\\n    }\\n\\n    /// @dev Contract constructor. Initializes the base URI that serves Metadata\\n    constructor() ERC721(\\\"Blank.\\\", \\\"BLNK\\\") {\\n        _baseURI = \\\"https://api.blankstudio.art/metadata/\\\";\\n    }\\n\\n    /// @notice Update the base URI that serves the Metadata\\n    function setBaseURI(string calldata uri) public onlyOwner {\\n        _baseURI = uri;\\n    }\\n\\n    /// @notice Change the Freemint Approver\\n    function setFreeMintApprover(address approver) public onlyOwner {\\n        require(approver != freeMintApprover, \\\"Nothing to change\\\");\\n        freeMintApprover = approver;\\n    }\\n\\n    /// @notice Change the BlankList Approver\\n    function setBlankApprover(address approver) public onlyOwner {\\n        require(approver != blankApprover, \\\"Nothing to change\\\");\\n        blankApprover = approver;\\n    }\\n\\n    /// @notice Change the Reserve Approver\\n    function setReserveApprover(address approver) public onlyOwner {\\n        require(approver != reserveApprover, \\\"Nothing to change\\\");\\n        reserveApprover = approver;\\n    }\\n\\n    /// @notice Updates the mint start timestamp\\n    function setMintStartTimestamp(uint256 timestamp) public onlyOwner {\\n        mintStartTimestamp = timestamp;\\n    }\\n\\n    /// @notice Sets the address of the Gen2 contract\\n    function setGen2(address gen2) public onlyOwner\\n    {\\n        require(gen2Contract == address(0), \\\"Gen2 was already initialized\\\");\\n        gen2Contract = gen2;\\n    }\\n\\n    /// @notice\\n    function withdraw()\\n    public\\n    onlyOwner\\n    {\\n        uint256 balance = address(this).balance;\\n        require(balance > 0, \\\"I'm Broke!\\\");\\n        (bool success, ) = payable(owner()).call{value: balance}(\\\"\\\");\\n        require(success, \\\"Get Blanked!\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// ERC721 Contract\\n// Creator: Blank Studio\\n// Based on ERC721A by Chiru Labs\\n\\npragma solidity 0.8.14;\\n\\nimport '../interfaces/IERC721A.sol';\\n\\n/**\\n * @dev ERC721 token receiver interface.\\n */\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension. Built to optimize for lower gas.\\n *\\n * - Each mint is indivitual (no batch mint)\\n * - Any given address can only mint once\\n * - Tokens are sequentially minted starting at 0\\n * - Tokens are not burnable\\n */\\nabstract contract ERC721 is IERC721A {\\n    // last 12 bits (Where the total balance including Gen2 should fit)\\n    uint256 private constant BALANCE_BITMASK = 0xfff;\\n\\n    // 13th bit that will be active if the address already minted\\n    uint256 private constant ALREADY_MINTED_BITMASK = 0x1000;\\n\\n    // The tokenId of the next token to be minted.\\n    uint256 internal _currentIndex;\\n\\n    // Token name\\n    string public name;\\n\\n    // Token symbol\\n    string public symbol;\\n\\n    // Metadata Base URI\\n    string internal _baseURI;\\n\\n    // Mapping from token ID to owner's address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to balance\\n    // Bits Layout:\\n    // - [0..12]    `balance`\\n    // - [13]       `alreadyMinted`\\n    mapping(address => uint256) private _packedAddressData;\\n\\n    // Mapping from token ID to approved address.\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the total number of tokens in existence.\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _currentIndex;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n        return _packedAddressData[owner] & BALANCE_BITMASK;\\n    }\\n\\n    /**\\n     * @dev Returns true if an address has already minted\\n     */\\n    function hasMinted(address owner) public view returns (bool) {\\n        return (_packedAddressData[owner] & ALREADY_MINTED_BITMASK) > 0;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public override {\\n        if (to == _owners[tokenId]) revert ApprovalToCurrentOwner();\\n\\n        if (msg.sender != _owners[tokenId])\\n            if (!isApprovedForAll(_owners[tokenId], msg.sender)) {\\n                revert ApprovalCallerNotOwnerNorApproved();\\n            }\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(_owners[tokenId], to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        if (operator == msg.sender) revert ApproveToCaller();\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See https://docs.opensea.io/docs/contract-level-metadata\\n     */\\n    function contractURI() public view virtual returns (string memory) {\\n        return string(abi.encodePacked(_baseURI, \\\"contract.json\\\"));\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view returns (string memory)\\n    {\\n        return string(abi.encodePacked(_baseURI, _toString(tokenId), \\\".json\\\"));\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        _transfer(from, to, tokenId);\\n        if (to.code.length != 0)\\n            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            }\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        // The interface IDs are constants representing the first 4 bytes of the XOR of\\n        // all function selectors in the interface. See: https://eips.ethereum.org/EIPS/eip-165\\n        // e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`\\n        return\\n        interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.\\n        interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.\\n        interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.\\n    }\\n\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     */\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return tokenId < _currentIndex; // If within bounds\\n    }\\n\\n    /**\\n     * @dev Equivalent to `_safeMint(to, '')`.\\n     */\\n    function _safeMint(address to) internal {\\n        _safeMint(to, '');\\n    }\\n\\n    /**\\n     * @dev Safely mints 1 token and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement\\n     *   {IERC721Receiver-onERC721Received}, which is called for each safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(\\n        address to,\\n        bytes memory _data\\n    ) internal {\\n        if (to == address(0)) revert MintToZeroAddress();\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n            // Updates:\\n            // - balance++\\n            // - alreadyMinted = true\\n            _packedAddressData[to] = (_packedAddressData[to] + 1) | ALREADY_MINTED_BITMASK;\\n\\n            // Updates:\\n            // - `address` to the owner.\\n            _owners[_currentIndex] = to;\\n\\n            if (to.code.length != 0) {\\n                emit Transfer(address(0), to, _currentIndex);\\n                if (!_checkContractOnERC721Received(address(0), to, _currentIndex++, _data)) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                }\\n            } else {\\n                emit Transfer(address(0), to, _currentIndex++);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Mints 1 token and transfers them to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `quantity` must be greater than 0.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to) internal {\\n        if (to == address(0)) revert MintToZeroAddress();\\n\\n        // Overflows are incredibly unrealistic.\\n        // balance or numberMinted overflow if current value of either + quantity > 1.8e19 (2**64) - 1\\n        // updatedIndex overflows if _currentIndex + quantity > 1.2e77 (2**256) - 1\\n        unchecked {\\n        // Updates:\\n        // - balance++\\n        // - alreadyMinted = true\\n        _packedAddressData[to] = (_packedAddressData[to] + 1) | ALREADY_MINTED_BITMASK;\\n\\n        // Updates:\\n            // - `address` to the owner.\\n            // - `startTimestamp` to the timestamp of minting.\\n            // - `nextInitialized` to `quantity == 1`.\\n            _owners[_currentIndex] = to;\\n\\n            emit Transfer(address(0), to, _currentIndex++);\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) private {\\n        if (_owners[tokenId] != from) revert TransferFromIncorrectOwner();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        if (\\n            msg.sender != from &&\\n            !isApprovedForAll(from, msg.sender) &&\\n            getApproved(tokenId) != msg.sender\\n        ) revert TransferCallerNotOwnerNorApproved();\\n\\n        // Clear approvals from the previous owner.\\n        delete _tokenApprovals[tokenId];\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        // Counter overflow is incredibly unrealistic as tokenId would have to be 2**256.\\n        unchecked {\\n            // We can directly increment and decrement the balances.\\n            _packedAddressData[from]--; // Updates: `balance -= 1`.\\n            _packedAddressData[to]--; // Updates: `balance += 1`.\\n\\n            // Updates:\\n            // - `address` to the next owner.\\n            // - `startTimestamp` to the timestamp of transfering.\\n            // - `nextInitialized` to `true`.\\n            _owners[tokenId] = to;\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkContractOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (\\n            bytes4 retval\\n        ) {\\n            return retval == IERC721Receiver(to).onERC721Received.selector;\\n        } catch (bytes memory reason) {\\n            if (reason.length == 0) {\\n                revert TransferToNonERC721ReceiverImplementer();\\n            } else {\\n                assembly {\\n                    revert(add(32, reason), mload(reason))\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function _toString(uint256 value) internal pure returns (string memory ptr) {\\n        assembly {\\n        // The maximum value of a uint256 contains 78 digits (1 byte per digit),\\n        // but we allocate 128 bytes to keep the free memory pointer 32-byte word aliged.\\n        // We will need 1 32-byte word to store the length,\\n        // and 3 32-byte words to store a maximum of 78 digits. Total: 32 + 3 * 32 = 128.\\n            ptr := add(mload(0x40), 128)\\n        // Update the free memory pointer to allocate.\\n            mstore(0x40, ptr)\\n\\n        // Cache the end of the memory to calculate the length later.\\n            let end := ptr\\n\\n        // We write the string from the rightmost digit to the leftmost digit.\\n        // The following is essentially a do-while loop that also handles the zero case.\\n        // Costs a bit more than early returning for the zero case,\\n        // but cheaper in terms of deployment and overall runtime costs.\\n            for {\\n            // Initialize and perform the first pass without check.\\n                let temp := value\\n            // Move the pointer 1 byte leftwards to point to an empty character slot.\\n                ptr := sub(ptr, 1)\\n            // Write the character to the pointer. 48 is the ASCII index of '0'.\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n                temp := div(temp, 10)\\n            } temp {\\n            // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n            } { // Body of the for loop.\\n                ptr := sub(ptr, 1)\\n                mstore8(ptr, add(48, mod(temp, 10)))\\n            }\\n\\n            let length := sub(end, ptr)\\n        // Move the pointer 32 bytes leftwards to make room for the length.\\n            ptr := sub(ptr, 32)\\n        // Store the length.\\n            mstore(ptr, length)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"URIQueryForNonexistentToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEV_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FREE_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN2_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GENESIS_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"blankListMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ascendant\",\"type\":\"address\"}],\"name\":\"burnIntoGenesis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"freeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freeMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gen2Mints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"reserveListMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"setBlankApprover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"setFreeMintApprover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gen2\",\"type\":\"address\"}],\"name\":\"setGen2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setMintStartTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approver\",\"type\":\"address\"}],\"name\":\"setReserveApprover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Blank", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}