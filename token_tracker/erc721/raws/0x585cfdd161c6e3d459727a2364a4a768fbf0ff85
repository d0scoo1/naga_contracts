{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) internal balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved[id] ||\\n                isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/Pirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./interfaces/IPirates.sol\\\";\\nimport \\\"./interfaces/ITPirates.sol\\\";\\nimport \\\"./interfaces/IHPirates.sol\\\";\\nimport \\\"./interfaces/IOrbitalBlockade.sol\\\";\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\nimport \\\"./interfaces/IEON.sol\\\";\\n\\ncontract Pirates is IPirates, ERC721, Pausable {\\n    struct LastWrite {\\n        uint64 time;\\n        uint64 blockNum;\\n    }\\n\\n    event PirateNamed(uint256 indexed tokenId, string newName);\\n    event PirateMinted(uint256 indexed tokenId);\\n    event PirateStolen(uint256 indexed tokenId);\\n\\n    // tally of the number of pirates that have been minted\\n    uint16 public override piratesMinted;\\n\\n    // an arbatrary counter to dish out IDs\\n    uint16 public override minted;\\n    //\\n    uint256 public migrated;\\n\\n    // toggle naming\\n    bool public namingActive;\\n\\n    // number of max pirates that can exist with the total minted to keep a 10:1 ratio\\n\\n    uint256 public constant MAX_PIRATES = 6000;\\n\\n    // cost to name\\n    uint256 public constant costToName = 2000 ether; //2000 EON\\n\\n    // mapping from tokenId to a struct containing the colonist token's traits\\n    mapping(uint256 => Pirate) public tokenTraitsPirate;\\n\\n    // mapping from tokenId to a stuct containing the honors pirates\\n    mapping(uint256 => HPirates) public tokenTraitsHonors;\\n    mapping(uint256 => bool) public isHonors;\\n\\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\\n    // used to ensure there are no duplicates\\n    mapping(uint256 => uint256) public existingCombinations;\\n\\n    // Mapping from token ID to name\\n    mapping(uint256 => string) private _tokenName;\\n\\n    mapping(uint256 => bool) private _hasName;\\n\\n    // Mapping if certain name string has already been reserved\\n    mapping(string => bool) private _nameReserved;\\n\\n    // Tracks the last block and timestamp that a caller has written to state.\\n    // Disallow some access to functions if they occur while a change is being written.\\n    mapping(address => LastWrite) private lastWriteAddress;\\n    mapping(uint256 => LastWrite) private lastWriteToken;\\n\\n    // list of probabilities for each trait type\\n    uint8[][9] public rarities;\\n    uint8[][9] public aliases;\\n\\n    // reference to the orbital for transfers without approval\\n    IOrbitalBlockade public orbital;\\n\\n    // reference to Traits\\n    ITPirates public traits;\\n\\n    // reference to honors traits\\n    IHPirates public honorTraits;\\n\\n    //reference to Randomizer\\n    IRandomizer public randomizer;\\n\\n    //referenve to EON\\n    IEON public EON;\\n\\n    //reference to the original pirates contract\\n    IPirates public originalPirates;\\n\\n    address public auth;\\n\\n    // address => used in allowing system communication between contracts\\n    mapping(address => bool) private admins;\\n\\n    // Imperial Guild Treasury\\n    address private imperialGuildTreasury;\\n\\n    /**\\n     * instantiates contract and rarity tables\\n     */\\n    constructor() ERC721(\\\"ShatteredEon\\\", \\\"Pirates Migrated\\\") {\\n        minted = 151;\\n        piratesMinted = 151;\\n        _pause();\\n        \\n        auth = msg.sender;\\n        admins[msg.sender] = true;\\n\\n        //PIRATES\\n        //sky\\n        rarities[0] = [200, 200, 200, 200, 200, 255];\\n        aliases[0] = [1, 2, 0, 4, 3, 5];\\n        //cockpit\\n        rarities[1] = [255];\\n        aliases[1] = [0];\\n        //base\\n        rarities[2] = [\\n            255,\\n            255,\\n            255,\\n            255,\\n            200,\\n            200,\\n            200,\\n            200,\\n            40,\\n            40,\\n            40,\\n            40,\\n            150,\\n            150,\\n            150,\\n            150,\\n            255,\\n            255,\\n            255,\\n            255\\n        ];\\n        aliases[2] = [\\n            16,\\n            17,\\n            18,\\n            19,\\n            7,\\n            6,\\n            5,\\n            4,\\n            3,\\n            2,\\n            1,\\n            0,\\n            16,\\n            17,\\n            18,\\n            19,\\n            0,\\n            1,\\n            2,\\n            3\\n        ];\\n        //engine\\n        rarities[3] = [\\n            150,\\n            150,\\n            150,\\n            150,\\n            255,\\n            255,\\n            255,\\n            255,\\n            100,\\n            100,\\n            100,\\n            100,\\n            255,\\n            255,\\n            255,\\n            255,\\n            40,\\n            40,\\n            40,\\n            40\\n        ];\\n        aliases[3] = [\\n            8,\\n            9,\\n            10,\\n            11,\\n            12,\\n            13,\\n            14,\\n            15,\\n            15,\\n            14,\\n            13,\\n            12,\\n            7,\\n            6,\\n            5,\\n            4,\\n            8,\\n            9,\\n            10,\\n            11\\n        ];\\n        //nose\\n        rarities[4] = [\\n            255,\\n            255,\\n            255,\\n            255,\\n            150,\\n            150,\\n            150,\\n            150,\\n            255,\\n            255,\\n            255,\\n            255,\\n            120,\\n            120,\\n            120,\\n            120,\\n            40,\\n            40,\\n            40,\\n            40\\n        ];\\n        aliases[4] = [\\n            0,\\n            1,\\n            2,\\n            3,\\n            15,\\n            14,\\n            13,\\n            12,\\n            11,\\n            10,\\n            9,\\n            8,\\n            3,\\n            2,\\n            1,\\n            0,\\n            12,\\n            13,\\n            14,\\n            15\\n        ];\\n        //wing\\n        rarities[5] = [\\n            120,\\n            120,\\n            120,\\n            120,\\n            40,\\n            40,\\n            40,\\n            40,\\n            150,\\n            150,\\n            150,\\n            150,\\n            255,\\n            255,\\n            255,\\n            255,\\n            255,\\n            255,\\n            255,\\n            255\\n        ];\\n        aliases[5] = [\\n            19,\\n            18,\\n            17,\\n            16,\\n            3,\\n            2,\\n            1,\\n            0,\\n            0,\\n            1,\\n            2,\\n            3,\\n            19,\\n            18,\\n            17,\\n            16,\\n            15,\\n            14,\\n            13,\\n            12\\n        ];\\n        //weapon1\\n        rarities[6] = [255, 150, 220, 220, 120, 30];\\n        aliases[6] = [0, 0, 0, 0, 0, 0];\\n        //weapon2\\n        rarities[7] = [255, 150, 30, 100, 20, 200];\\n        aliases[7] = [0, 0, 0, 0, 0, 0];\\n        //rank\\n        rarities[8] = [12, 160, 73, 255];\\n        aliases[8] = [2, 3, 3, 3];\\n    }\\n\\n    modifier requireContractsSet() {\\n        require(\\n            address(traits) != address(0) &&\\n                address(orbital) != address(0) &&\\n                address(randomizer) != address(0)\\n        );\\n        _;\\n    }\\n\\n      modifier blockIfChangingAddress() {\\n        require(admins[msg.sender] || lastWriteAddress[tx.origin].blockNum < block.number, \\\"Your trying the cheat\\\");\\n        _;\\n    }\\n\\n     modifier blockIfChangingToken(uint256 tokenId) {\\n        require(admins[msg.sender] || lastWriteToken[tokenId].blockNum < block.number, \\\"Your trying the cheat\\\");\\n        _;\\n    }\\n\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == auth);\\n        _;\\n    }\\n\\n    function setContracts(\\n        address _traits,\\n        address _honorTraits,\\n        address _orbital,\\n        address _rand,\\n        address _eon,\\n        address _originalPirates\\n    ) external onlyOwner {\\n        traits = ITPirates(_traits);\\n        honorTraits = IHPirates(_honorTraits);\\n        orbital = IOrbitalBlockade(_orbital);\\n        randomizer = IRandomizer(_rand);\\n        EON = IEON(_eon);\\n        originalPirates = IPirates(_originalPirates);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                    EXTERNAL\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mintPirate(address recipient, uint256 seed)\\n        external\\n        override\\n        whenNotPaused\\n    {\\n        require(admins[msg.sender], \\\"Only Admins\\\");\\n        require(piratesMinted + 1 <= MAX_PIRATES, \\\"Pirate forces are full\\\");\\n        minted++;\\n        piratesMinted++;\\n        generatePirate(minted, seed);\\n        if (tx.origin != recipient && recipient != address(orbital)) {\\n            // Stolen!\\n            emit PirateStolen(minted);\\n        }\\n        _mint(recipient, minted);\\n    }\\n\\n    function _mintHonors(address recipient, uint8 id)\\n        external\\n        whenNotPaused\\n        onlyOwner\\n    {\\n        require(minted + 1 <= MAX_PIRATES, \\\"All Pirates Minted\\\");\\n        minted++;\\n        piratesMinted++;\\n        generateHonors(minted, id);\\n        _mint(recipient, minted);\\n    }\\n\\n    /**\\n     * Burn a token - any game logic should be handled before this function.\\n     */\\n    function burn(uint256 tokenId) external override whenNotPaused {\\n        require(admins[msg.sender]);\\n        require(ownerOf[tokenId] == tx.origin, \\\"not owner\\\");\\n        _burn(tokenId);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public override(ERC721, IPirates) {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n        // allow admin contracts to send without approval\\n        if (!admins[msg.sender]) {\\n            require(\\n                msg.sender == from ||\\n                    msg.sender == getApproved[id] ||\\n                    isApprovedForAll[from][msg.sender],\\n                \\\"NOT_AUTHORIZED\\\"\\n            );\\n        }\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function generatePirate(uint256 tokenId, uint256 seed)\\n        internal\\n        returns (Pirate memory p)\\n    {\\n        p = selectPiTraits(seed);\\n        if (existingCombinations[structToHashPi(p)] == 0) {\\n            tokenTraitsPirate[tokenId] = p;\\n            existingCombinations[structToHashPi(p)] = tokenId;\\n            emit PirateMinted(tokenId);\\n            return p;\\n        }\\n        return generatePirate(tokenId, randomizer.random(seed));\\n    }\\n\\n    function generateHonors(uint256 tokenId, uint8 id)\\n        internal\\n        returns (HPirates memory r)\\n    {\\n        r.Legendary = id;\\n        tokenTraitsHonors[minted] = r;\\n        isHonors[minted] = true;\\n        emit PirateMinted(tokenId);\\n        return r;\\n    }\\n\\n    /**\\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\\n     * probability & alias tables are generated off-chain beforehand\\n     * @param seed portion of the 256 bit seed to remove trait correlation\\n     * @param traitType the trait type to select a trait for\\n     * @return the ID of the randomly selected trait\\n     */\\n    function selectTrait(uint16 seed, uint8 traitType)\\n        internal\\n        view\\n        returns (uint8)\\n    {\\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\\n        // If a selected random trait probability is selected (biased coin) return that trait\\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\\n        return aliases[traitType][trait];\\n    }\\n\\n    function selectPiTraits(uint256 seed)\\n        internal\\n        view\\n        returns (Pirate memory p)\\n    {\\n        p.isPirate = true;\\n        seed >>= 16;\\n        p.sky = selectTrait(uint16(seed & 0xFFFF), 0);\\n        seed >>= 16;\\n        p.cockpit = selectTrait(uint16(seed & 0xFFFF), 1);\\n        seed >>= 16;\\n        p.base = selectTrait(uint16(seed & 0xFFFF), 2);\\n        seed >>= 16;\\n        p.engine = selectTrait(uint16(seed & 0xFFFF), 3);\\n        seed >>= 16;\\n        p.nose = selectTrait(uint16(seed & 0xFFFF), 4);\\n        seed >>= 16;\\n        p.wing = selectTrait(uint16(seed & 0xFFFF), 5);\\n        seed >>= 16;\\n        p.weapon1 = selectTrait(uint16(seed & 0xFFFF), 6);\\n        seed >>= 16;\\n        p.weapon2 = selectTrait(uint16(seed & 0xFFFF), 7);\\n        seed >>= 16;\\n        p.rank = selectTrait(uint16(seed & 0xFFFF), 8);\\n    }\\n\\n    function structToHashPi(Pirate memory q) internal pure returns (uint256) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        q.sky,\\n                        q.cockpit,\\n                        q.base,\\n                        q.engine,\\n                        q.nose,\\n                        q.wing,\\n                        q.weapon1,\\n                        q.weapon2,\\n                        q.rank\\n                    )\\n                )\\n            );\\n    }\\n\\n        \\n    function updateOriginAccess(uint16[] memory tokenIds) external override {\\n        require(admins[_msgSender()], \\\"Only admins can call this\\\");\\n        uint64 blockNum = uint64(block.number);\\n        uint64 time = uint64(block.timestamp);\\n        lastWriteAddress[tx.origin] = LastWrite(time, blockNum);\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            lastWriteToken[tokenIds[i]] = LastWrite(time, blockNum);\\n        }\\n    }\\n\\n    function tokenNameByIndex(uint256 index)\\n        public\\n        view\\n        returns (string memory)\\n    {\\n        return _tokenName[index];\\n    }\\n\\n    function isNameReserved(string memory nameString)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return _nameReserved[toLower(nameString)];\\n    }\\n\\n    function hasBeenNamed(uint256 tokenId) public view returns (bool) {\\n        return _hasName[tokenId];\\n    }\\n\\n    function namePirate(uint256 tokenId, string memory newName) public {\\n        require(namingActive == true, \\\"naming not yet availanle\\\");\\n        require(ownerOf[tokenId] == msg.sender, \\\"Not your pirate to name\\\");\\n        require(hasBeenNamed(tokenId) == false, \\\"Pirate already named\\\");\\n        require(validateName(newName) == true, \\\"Not a valid name\\\");\\n        require(isNameReserved(newName) == false, \\\"Name already reserved\\\");\\n\\n        //   IERC20(_eonAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\\n\\n        toggleReserveName(newName, true);\\n        toggleHasName(tokenId, true);\\n        _tokenName[tokenId] = newName;\\n        EON.burn(msg.sender, costToName);\\n        emit PirateNamed(tokenId, newName);\\n    }\\n\\n    /**\\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\\n     */\\n    function toggleReserveName(string memory str, bool isReserve) internal {\\n        _nameReserved[toLower(str)] = isReserve;\\n    }\\n\\n    function toggleHasName(uint256 tokenId, bool hasName) internal {\\n        _hasName[tokenId] = hasName;\\n    }\\n\\n    /**\\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\\n     */\\n    function validateName(string memory str) public pure returns (bool) {\\n        bytes memory b = bytes(str);\\n        if (b.length < 1) return false;\\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\\n        if (b[0] == 0x20) return false; // Leading space\\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\\n\\n        bytes1 lastChar = b[0];\\n\\n        for (uint256 i; i < b.length; i++) {\\n            bytes1 char = b[i];\\n\\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\\n\\n            if (\\n                !(char >= 0x30 && char <= 0x39) && //9-0\\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\\n                !(char >= 0x61 && char <= 0x7A) && //a-z\\n                !(char == 0x20) //space\\n            ) return false;\\n\\n            lastChar = char;\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Converts the string to lowercase\\n     */\\n    function toLower(string memory str) public pure returns (string memory) {\\n        bytes memory bStr = bytes(str);\\n        bytes memory bLower = new bytes(bStr.length);\\n        for (uint256 i = 0; i < bStr.length; i++) {\\n            // Uppercase character\\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\\n            } else {\\n                bLower[i] = bStr[i];\\n            }\\n        }\\n        return string(bLower);\\n    }\\n\\n      /**\\n   * creates identical tokens in the new contract\\n   * and burns any original tokens\\n   * @param tokenIds the ids of the tokens to migrate\\n   */\\n  function migrate(uint16[] calldata tokenIds) external whenNotPaused {\\n    for (uint16 i = 0; i < tokenIds.length; i++) {\\n      require(originalPirates.isOwner(tokenIds[i]) == msg.sender, \\\"THIEF!\\\");\\n       tokenTraitsPirate[tokenIds[i]] = originalPirates.getTokenTraitsPirate(tokenIds[i]);\\n      originalPirates.burn(tokenIds[i]);\\n      _mint(address(orbital), tokenIds[i]);\\n      migrated++;\\n    }\\n    orbital.addPiratesToCrew(msg.sender, tokenIds); \\n\\n  }\\n\\n    /**\\n     * enables owner to pause / unpause minting\\n     */\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\n        if (_paused) _pause();\\n        else _unpause();\\n    }\\n\\n    function getBalance(address tokenOwner)\\n        public\\n        view\\n        returns (uint256)\\n        \\n    {\\n        //Prevent chencking balance in the same block it's being modified..\\n        require(\\n            admins[msg.sender] ||\\n                lastWriteAddress[tokenOwner].blockNum < block.number,\\n            \\\"no checking balance in the same block it's being modified\\\"\\n        );\\n        return balanceOf[tokenOwner];\\n    }\\n\\n      function getTokenWriteBlock(uint256 tokenId) external view override returns(uint64) {\\n        require(\\n            admins[msg.sender], \\n            \\\"Only admins can call this\\\"\\n            );\\n        return lastWriteToken[tokenId].blockNum;\\n    }\\n\\n    /**\\n     * enables an address to mint / burn\\n     * @param addr the address to enable\\n     */\\n    function addAdmin(address addr) external onlyOwner {\\n        admins[addr] = true;\\n    }\\n\\n    /**\\n     * disables an address from minting / burning\\n     * @param addr the address to disbale\\n     */\\n    function removeAdmin(address addr) external onlyOwner {\\n        admins[addr] = false;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        auth = newOwner;\\n    }\\n\\n    function toggleNameing(bool _namingActive) external onlyOwner {\\n        namingActive = _namingActive;\\n    }\\n\\n    function setImperialGuildTreasury(address _imperialTreasury)\\n        external\\n        onlyOwner\\n    {\\n        imperialGuildTreasury = _imperialTreasury;\\n    }\\n\\n    /** Traits */\\n\\n    function getTokenTraitsPirate(uint256 tokenId)\\n        external\\n        view\\n        override\\n        blockIfChangingAddress blockIfChangingToken (tokenId) \\n        returns (Pirate memory)\\n    {\\n        return tokenTraitsPirate[tokenId];\\n    }\\n\\n    function getTokenTraitsHonors(uint256 tokenId) \\n        external\\n        view\\n        override\\n        returns (HPirates memory)\\n    {\\n        return tokenTraitsHonors[tokenId];\\n    }\\n\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        override\\n        blockIfChangingAddress blockIfChangingToken (tokenId) \\n        returns (string memory)\\n    {\\n        if (isHonors[tokenId]) {\\n            return honorTraits.tokenURI(tokenId);\\n        }\\n        return traits.tokenURI(tokenId);\\n    }\\n\\n    function isOwner(uint256 tokenId) blockIfChangingToken(tokenId) public view returns (address) {\\n        address addr = ownerOf[tokenId];\\n        return addr;\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public override(ERC721, IPirates) blockIfChangingToken(id) {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public override(ERC721, IPirates) blockIfChangingToken(id) {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    // For OpenSeas\\n    function owner() public view virtual returns (address) {\\n        return auth;\\n    }\\n    }\\n\\n\"\r\n    },\r\n    \"contracts/interfaces/IEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IEON {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IHPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IHPirates {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOrbitalBlockade {\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external;\\n    \\n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\\n        external;\\n\\n    function payPirateTax(uint256 amount) external;\\n\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function updateOriginAccess(uint16[] memory tokenIds) external;\\r\\n\\r\\n    function getTokenWriteBlock(uint256 tokenId) \\r\\n    external \\r\\n    view  \\r\\n    returns(uint64);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITPirates {\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PirateMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"PirateNamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PirateStolen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EON\",\"outputs\":[{\"internalType\":\"contract IEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PIRATES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"_mintHonors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"_mintPirate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"costToName\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsHonors\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"internalType\":\"struct IPirates.HPirates\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsPirate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPirate\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"sky\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cockpit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"engine\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"wing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rank\",\"type\":\"uint8\"}],\"internalType\":\"struct IPirates.Pirate\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenWriteBlock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasBeenNamed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"honorTraits\",\"outputs\":[{\"internalType\":\"contract IHPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isHonors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"nameString\",\"type\":\"string\"}],\"name\":\"isNameReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"namePirate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"namingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbital\",\"outputs\":[{\"internalType\":\"contract IOrbitalBlockade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originalPirates\",\"outputs\":[{\"internalType\":\"contract IPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piratesMinted\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomizer\",\"outputs\":[{\"internalType\":\"contract IRandomizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_honorTraits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orbital\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_originalPirates\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_imperialTreasury\",\"type\":\"address\"}],\"name\":\"setImperialGuildTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"toLower\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_namingActive\",\"type\":\"bool\"}],\"name\":\"toggleNameing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenNameByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsHonors\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsPirate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPirate\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"sky\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cockpit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"engine\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"wing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rank\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"contract ITPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"tokenIds\",\"type\":\"uint16[]\"}],\"name\":\"updateOriginAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"validateName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Pirates", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}