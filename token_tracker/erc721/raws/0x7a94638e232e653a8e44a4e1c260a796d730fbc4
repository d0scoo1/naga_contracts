{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// ................................................................................\r\n//       ..........................................................................\r\n//         ............8888........................................................\r\n//           ..........8::8............888888888888................................\r\n//               .......888.........88D~~~~~~~~~~~~88..............................\r\n//                 ......88........8~~~~~~~~~~~~~~~~~DD............................\r\n// ......................888...~8:~8~~~~~~~~~~~~~~~~~~~~8..........................\r\n// ........................8...888D~~~~~~~~~~~~~~~~~~~~~8..........................\r\n// ........................8.8D~~~~~~~~~~~~~~~~~~~~~~~~~~88........................\r\n// ........................88~~~~~~~~~~~~~~~~~~~~~~~~~~~~88........................\r\n// ........................:8~~~~~~~~~~~~~888888N~~~~~~~~88........................\r\n// ........................8~~~~~~~~..:8888D..:8888D8~:~~8D........................\r\n// ........................8~~~~~~~88................888~~~8.......................\r\n// ........................8~~~~~888..................:8~~~8.......................\r\n// ........................8~~~~~88....:88........88..:88~~8.......................\r\n// ................    ...:8~~~~88D....8  8......8  8..:8~~8.......................\r\n// ............:.         .8~~~~8......8  8......8  8..:8~~8.......................\r\n// ............           .8~~~~888....8  8......8  8..:8~~8.......................\r\n// ............           .8~~~~~88....:88~......:88..:88~~8.......................\r\n// ............           .8~~~~~888................:888~~~8.......................\r\n// ........               .8~~~~~~~88..............:88:~~~~8.......................\r\n// ........               .8~~~~~~~~8888888......8888~~~~~~8.......................\r\n// ........:...............8~~~~~~~~~~~8~DDDDDDDDD~~~~~~~~~8.......................\r\n// ........................8~~~~~~~~~~~8~~~~~~~~~~~~~~~~~~~8.......................\r\n// .........................8~~~~~~~~~~8~~~:D8DDDDDD~~~~~88........................\r\n// .........................8888~~~~~~~~8~~~~D8..8D~~~~~888........................\r\n// .........................8===D8D~~~~~8~~~~~~88~~~~~~88..........................\r\n// .........................8==D===888D~8~~~~~~~~~~8888=8..........................\r\n// .........................8==D=======++88++++++++=====8..........................\r\n// ........................88==D=========88=============8..........................\r\n// ......................88==88D=========88============8=88........................\r\n// .....................8=====+8888=====8==========8888====8.......................\r\n// ....................D====888====8888888888888888========88......................\r\n// ..................88===+D8=========+88======++++++88O++==8......................\r\n// .................8?===88==========88=888888888++++++=8====88D...................\r\n// .................8===888=========8===8================88===+8...................\r\n// .................8===8===========8===888========8..8==88===+8...................\r\n// ................8==+88==========8=====88========8..88=88=====8..................\r\n// ................8==+D===========D=====88========88..8=888====8..................\r\n// ................8==+D=========88======88=========+8.8==+8====8..................\r\n// ................8=88=========888======88===============+8====D88................\r\n// ................8=88=========8===88888D8===============+8=====88................\r\n// ................8=88=========8888D8D=D=8===============+8=====88................\r\n// ................8=88=========8=+DDD====================+8=====88................\r\n// ................8=88========8888=======================+8=====88................\r\n// ................8=88========88=========================+8=====88................\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n\t/**\r\n\t * @dev Returns true if this contract implements the interface defined by\r\n\t * `interfaceId`. See the corresponding\r\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n\t * to learn more about how these ids are created.\r\n\t *\r\n\t * This function call must use less than 30 000 gas.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n\t/**\r\n\t * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n\t */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n\t/**\r\n\t * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n\t */\r\n\tevent Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n\t/**\r\n\t * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n\t */\r\n\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n\t/**\r\n\t * @dev Returns the number of tokens in ``owner``'s account.\r\n\t */\r\n\tfunction balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n\t/**\r\n\t * @dev Returns the owner of the `tokenId` token.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n\t * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Transfers `tokenId` token from `from` to `to`.\r\n\t *\r\n\t * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must be owned by `from`.\r\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) external;\r\n\r\n\t/**\r\n\t * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n\t * The approval is cleared when the token is transferred.\r\n\t *\r\n\t * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The caller must own the token or be an approved operator.\r\n\t * - `tokenId` must exist.\r\n\t *\r\n\t * Emits an {Approval} event.\r\n\t */\r\n\tfunction approve(address to, uint256 tokenId) external;\r\n\r\n\t/**\r\n\t * @dev Returns the account approved for `tokenId` token.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n\t/**\r\n\t * @dev Approve or remove `operator` as an operator for the caller.\r\n\t * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The `operator` cannot be the caller.\r\n\t *\r\n\t * Emits an {ApprovalForAll} event.\r\n\t */\r\n\tfunction setApprovalForAll(address operator, bool _approved) external;\r\n\r\n\t/**\r\n\t * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n\t *\r\n\t * See {setApprovalForAll}\r\n\t */\r\n\tfunction isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes calldata data\r\n\t) external;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n\t/**\r\n\t * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n\t * by `operator` from `from`, this function is called.\r\n\t *\r\n\t * It must return its Solidity selector to confirm the token transfer.\r\n\t * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n\t *\r\n\t * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n\t */\r\n\tfunction onERC721Received(\r\n\t\taddress operator,\r\n\t\taddress from,\r\n\t\tuint256 tokenId,\r\n\t\tbytes calldata data\r\n\t) external returns (bytes4);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n */\r\ninterface IERC721Metadata is IERC721 {\r\n\t/**\r\n\t * @dev Returns the token collection name.\r\n\t */\r\n\tfunction name() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the token collection symbol.\r\n\t */\r\n\tfunction symbol() external view returns (string memory);\r\n\r\n\t/**\r\n\t * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n\t */\r\n\tfunction tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n\t/**\r\n\t * @dev Returns true if `account` is a contract.\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * It is unsafe to assume that an address for which this function returns\r\n\t * false is an externally-owned account (EOA) and not a contract.\r\n\t *\r\n\t * Among others, `isContract` will return false for the following\r\n\t * types of addresses:\r\n\t *\r\n\t *  - an externally-owned account\r\n\t *  - a contract in construction\r\n\t *  - an address where a contract will be created\r\n\t *  - an address where a contract lived, but was destroyed\r\n\t * ====\r\n\t *\r\n\t * [IMPORTANT]\r\n\t * ====\r\n\t * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n\t *\r\n\t * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n\t * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n\t * constructor.\r\n\t * ====\r\n\t */\r\n\tfunction isContract(address account) internal view returns (bool) {\r\n\t\t// This method relies on extcodesize/address.code.length, which returns 0\r\n\t\t// for contracts in construction, since the code is only stored at the end\r\n\t\t// of the constructor execution.\r\n\r\n\t\treturn account.code.length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n\t * `recipient`, forwarding all available gas and reverting on errors.\r\n\t *\r\n\t * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n\t * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n\t * imposed by `transfer`, making them unable to receive funds via\r\n\t * `transfer`. {sendValue} removes this limitation.\r\n\t *\r\n\t * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n\t *\r\n\t * IMPORTANT: because control is transferred to `recipient`, care must be\r\n\t * taken to not create reentrancy vulnerabilities. Consider using\r\n\t * {ReentrancyGuard} or the\r\n\t * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n\t */\r\n\tfunction sendValue(address payable recipient, uint256 amount) internal {\r\n\t\trequire(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\t\t(bool success, ) = recipient.call{value: amount}(\"\");\r\n\t\trequire(success, \"Address: unable to send value, recipient may have reverted\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Performs a Solidity function call using a low level `call`. A\r\n\t * plain `call` is an unsafe replacement for a function call: use this\r\n\t * function instead.\r\n\t *\r\n\t * If `target` reverts with a revert reason, it is bubbled up by this\r\n\t * function (like regular Solidity function calls).\r\n\t *\r\n\t * Returns the raw returned data. To convert to the expected return value,\r\n\t * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `target` must be a contract.\r\n\t * - calling `target` with `data` must not revert.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionCall(target, data, \"Address: low-level call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n\t * `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, 0, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but also transferring `value` wei to `target`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - the calling contract must have an ETH balance of at least `value`.\r\n\t * - the called Solidity function must be `payable`.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value\r\n\t) internal returns (bytes memory) {\r\n\t\treturn functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n\t * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n\t *\r\n\t * _Available since v3.1._\r\n\t */\r\n\tfunction functionCallWithValue(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tuint256 value,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\t\trequire(isContract(target), \"Address: call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\t\treturn functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a static call.\r\n\t *\r\n\t * _Available since v3.3._\r\n\t */\r\n\tfunction functionStaticCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal view returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.staticcall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\t\treturn functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n\t * but performing a delegate call.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction functionDelegateCall(\r\n\t\taddress target,\r\n\t\tbytes memory data,\r\n\t\tstring memory errorMessage\r\n\t) internal returns (bytes memory) {\r\n\t\trequire(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\t\t(bool success, bytes memory returndata) = target.delegatecall(data);\r\n\t\treturn verifyCallResult(success, returndata, errorMessage);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n\t * revert reason using the provided one.\r\n\t *\r\n\t * _Available since v4.3._\r\n\t */\r\n\tfunction verifyCallResult(\r\n\t\tbool success,\r\n\t\tbytes memory returndata,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (bytes memory) {\r\n\t\tif (success) {\r\n\t\t\treturn returndata;\r\n\t\t} else {\r\n\t\t\t// Look for revert reason and bubble it up if present\r\n\t\t\tif (returndata.length > 0) {\r\n\t\t\t\t// The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n\t\t\t\tassembly {\r\n\t\t\t\t\tlet returndata_size := mload(returndata)\r\n\t\t\t\t\trevert(add(32, returndata), returndata_size)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\trevert(errorMessage);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n\tfunction _msgSender() internal view virtual returns (address) {\r\n\t\treturn msg.sender;\r\n\t}\r\n\r\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\r\n\t\treturn msg.data;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n\t */\r\n\tfunction toString(uint256 value) internal pure returns (string memory) {\r\n\t\t// Inspired by OraclizeAPI's implementation - MIT licence\r\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 digits;\r\n\t\twhile (temp != 0) {\r\n\t\t\tdigits++;\r\n\t\t\ttemp /= 10;\r\n\t\t}\r\n\t\tbytes memory buffer = new bytes(digits);\r\n\t\twhile (value != 0) {\r\n\t\t\tdigits -= 1;\r\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\t\t\tvalue /= 10;\r\n\t\t}\r\n\t\treturn string(buffer);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n\t */\r\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\r\n\t\tif (value == 0) {\r\n\t\t\treturn \"0x00\";\r\n\t\t}\r\n\t\tuint256 temp = value;\r\n\t\tuint256 length = 0;\r\n\t\twhile (temp != 0) {\r\n\t\t\tlength++;\r\n\t\t\ttemp >>= 8;\r\n\t\t}\r\n\t\treturn toHexString(value, length);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n\t */\r\n\tfunction toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\t\tbytes memory buffer = new bytes(2 * length + 2);\r\n\t\tbuffer[0] = \"0\";\r\n\t\tbuffer[1] = \"x\";\r\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\t\t\tbuffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n\t\t\tvalue >>= 4;\r\n\t\t}\r\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\r\n\t\treturn string(buffer);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\t\treturn interfaceId == type(IERC165).interfaceId;\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721A] Non-Fungible Token Standard, including\r\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n * {ERC721Enumerable}.\r\n */\r\ncontract ERC721A is Context, ERC165, IERC721, IERC721Metadata {\r\n\tusing Address for address;\r\n\tusing Strings for uint256;\r\n\r\n\r\n\tuint256 private currentIndex = 0;\r\n\tuint256 public maxBatchSize = 35;\r\n\r\n\t// Token name\r\n\tstring private _name;\r\n\r\n\t// Token symbol\r\n\tstring private _symbol;\r\n\r\n\t// Mapping from token ID to owner address\r\n\tmapping(uint256 => address) private _owners;\r\n\r\n\t// Mapping owner address to token count\r\n\tmapping(address => uint256) private _balances;\r\n\r\n\t// Mapping from token ID to approved address\r\n\tmapping(uint256 => address) private _tokenApprovals;\r\n\r\n\t// Mapping from owner to operator approvals\r\n\tmapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n\t/**\r\n\t * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n\t */\r\n\tconstructor(string memory name_, string memory symbol_) {\r\n\t\t_name = name_;\r\n\t\t_symbol = symbol_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC165-supportsInterface}.\r\n\t */\r\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n\t\treturn\r\n\t\t\tinterfaceId == type(IERC721).interfaceId ||\r\n\t\t\tinterfaceId == type(IERC721Metadata).interfaceId ||\r\n\t\t\tsuper.supportsInterface(interfaceId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-balanceOf}.\r\n\t */\r\n\tfunction balanceOf(address owner) public view virtual override returns (uint256) {\r\n\t\trequire(owner != address(0), \"ERC721A: balance query for the zero address\");\r\n\t\treturn _balances[owner];\r\n\t}\r\n\r\n\tfunction ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\t\trequire(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\r\n\r\n\t\tuint256 lowestTokenToCheck;\r\n\t\tif (tokenId >= maxBatchSize) {\r\n\t\t\tlowestTokenToCheck = tokenId - maxBatchSize + 1;\r\n\t\t}\r\n\r\n\t\tfor (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\r\n\t\t\taddress owner = _owners[curr];\r\n\t\t\tif (owner != address(0)) {\r\n\t\t\t\treturn owner;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trevert(\"ERC721A: unable to determine the owner of token\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-ownerOf}.\r\n\t */\r\n\t// function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n\t//     return ownershipOf(tokenId);\r\n\t// }\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-name}.\r\n\t */\r\n\tfunction name() public view virtual override returns (string memory) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-symbol}.\r\n\t */\r\n\tfunction symbol() public view virtual override returns (string memory) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721Metadata-tokenURI}.\r\n\t */\r\n\tfunction tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\t\trequire(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n\t\tstring memory baseURI = _baseURI();\r\n\t\treturn bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n\t * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n\t * by default, can be overriden in child contracts.\r\n\t */\r\n\tfunction _baseURI() internal view virtual returns (string memory) {\r\n\t\treturn \"\";\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-approve}.\r\n\t */\r\n\tfunction approve(address to, uint256 tokenId) public virtual override {\r\n\t\taddress owner = ERC721A.ownerOf(tokenId);\r\n\t\trequire(to != owner, \"ERC721A: approval to current owner\");\r\n\r\n\t\trequire(\r\n\t\t\t_msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\t\t\t\"ERC721A: approve caller is not owner nor approved for all\"\r\n\t\t);\r\n\r\n\t\t_approve(to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-getApproved}.\r\n\t */\r\n\tfunction getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n\t\trequire(_exists(tokenId), \"ERC721A: approved query for nonexistent token\");\r\n\r\n\t\treturn _tokenApprovals[tokenId];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-setApprovalForAll}.\r\n\t */\r\n\tfunction setApprovalForAll(address operator, bool approved) public virtual override {\r\n\t\t_setApprovalForAll(_msgSender(), operator, approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-isApprovedForAll}.\r\n\t */\r\n\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n\t\treturn _operatorApprovals[owner][operator];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-transferFrom}.\r\n\t */\r\n\tfunction transferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public virtual override {\r\n\t\t//solhint-disable-next-line max-line-length\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721A: transfer caller is not owner nor approved\");\r\n\r\n\t\t_transfer(from, to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) public virtual override {\r\n\t\tsafeTransferFrom(from, to, tokenId, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev See {IERC721-safeTransferFrom}.\r\n\t */\r\n\tfunction safeTransferFrom(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) public virtual override {\r\n\t\trequire(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721A: transfer caller is not owner nor approved\");\r\n\t\t_safeTransfer(from, to, tokenId, _data);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n\t * are aware of the ERC721A protocol to prevent tokens from being forever locked.\r\n\t *\r\n\t * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n\t *\r\n\t * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n\t * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `from` cannot be the zero address.\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must exist and be owned by `from`.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _safeTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) internal virtual {\r\n\t\t_transfer(from, to, tokenId);\r\n\t\trequire(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721A: transfer to non ERC721Receiver implementer\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns whether `tokenId` exists.\r\n\t *\r\n\t * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n\t *\r\n\t * Tokens start existing when they are minted (`_mint`),\r\n\t * and stop existing when they are burned (`_burn`).\r\n\t */\r\n\tfunction _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n\t\treturn tokenId < currentIndex;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t */\r\n\tfunction _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n\t\trequire(_exists(tokenId), \"ERC721A: operator query for nonexistent token\");\r\n\t\taddress owner = ERC721A.ownerOf(tokenId);\r\n\t\treturn (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Safely mints `tokenId` and transfers it to `to`.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must not exist.\r\n\t * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _safeMint(address to, uint256 quantity) internal virtual {\r\n\t\t_safeMint(to, quantity, \"\");\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Same as {xref-ERC721A-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n\t * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n\t */\r\n\tfunction _safeMint(\r\n\t\taddress to,\r\n\t\tuint256 quantity,\r\n\t\tbytes memory _data\r\n\t) internal virtual {\r\n\t\tuint256 startTokenId = currentIndex;\r\n\t\trequire(to != address(0), \"ERC721A: mint to the zero address\");\r\n\t\trequire(!_exists(startTokenId), \"ERC721A: token already minted\");\r\n\r\n\t\t_beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n\t\t_balances[to] += quantity;\r\n\t\t_owners[startTokenId] =to;\r\n\r\n\t\tuint256 updatedIndex = startTokenId;\r\n\r\n\t\tfor (uint256 i = 0; i < quantity; i++) {\r\n\t\t\temit Transfer(address(0), to, updatedIndex);\r\n\t\t\trequire(\r\n\t\t\t\t_checkOnERC721Received(address(0), to, updatedIndex, _data),\r\n\t\t\t\t\"ERC721A: transfer to non ERC721Receiver implementer\"\r\n\t\t\t);\r\n\t\t\tupdatedIndex++;\r\n\t\t}\r\n\r\n\t\tcurrentIndex = updatedIndex;\r\n\r\n\t\t_afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Destroys `tokenId`.\r\n\t * The approval is cleared when the token is burned.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `tokenId` must exist.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _burn(uint256 tokenId) internal virtual {\r\n\t\taddress owner = ERC721A.ownerOf(tokenId);\r\n\r\n\t\t_beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n\t\t// Clear approvals\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[owner] -= 1;\r\n\t\tdelete _owners[tokenId];\r\n\r\n\t\temit Transfer(owner, address(0), tokenId);\r\n\r\n\t\t_afterTokenTransfer(owner, address(0), tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers `tokenId` from `from` to `to`.\r\n\t *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - `to` cannot be the zero address.\r\n\t * - `tokenId` token must be owned by `from`.\r\n\t *\r\n\t * Emits a {Transfer} event.\r\n\t */\r\n\tfunction _transfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal virtual {\r\n\t\trequire(ERC721A.ownerOf(tokenId) == from, \"ERC721A: transfer from incorrect owner\");\r\n\t\trequire(to != address(0), \"ERC721A: transfer to the zero address\");\r\n\r\n\t\t_beforeTokenTransfer(from, to, tokenId);\r\n\r\n\t\t// Clear approvals from the previous owner\r\n\t\t_approve(address(0), tokenId);\r\n\r\n\t\t_balances[from] -= 1;\r\n\t\t_balances[to] += 1;\r\n\t\t_owners[tokenId] = to;\r\n\t\tif(_owners[tokenId+1] == address(0))\r\n\t\t\t_owners[tokenId+1] = from;\r\n\r\n\t\temit Transfer(from, to, tokenId);\r\n\r\n\t\t_afterTokenTransfer(from, to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve `to` to operate on `tokenId`\r\n\t *\r\n\t * Emits a {Approval} event.\r\n\t */\r\n\tfunction _approve(address to, uint256 tokenId) internal virtual {\r\n\t\t_tokenApprovals[tokenId] = to;\r\n\t\temit Approval(ERC721A.ownerOf(tokenId), to, tokenId);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approve `operator` to operate on all of `owner` tokens\r\n\t *\r\n\t * Emits a {ApprovalForAll} event.\r\n\t */\r\n\tfunction _setApprovalForAll(\r\n\t\taddress owner,\r\n\t\taddress operator,\r\n\t\tbool approved\r\n\t) internal virtual {\r\n\t\trequire(owner != operator, \"ERC721A: approve to caller\");\r\n\t\t_operatorApprovals[owner][operator] = approved;\r\n\t\temit ApprovalForAll(owner, operator, approved);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n\t * The call is not executed if the target address is not a contract.\r\n\t *\r\n\t * @param from address representing the previous owner of the given token ID\r\n\t * @param to target address that will receive the tokens\r\n\t * @param tokenId uint256 ID of the token to be transferred\r\n\t * @param _data bytes optional data to send along with the call\r\n\t * @return bool whether the call correctly returned the expected magic value\r\n\t */\r\n\tfunction _checkOnERC721Received(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId,\r\n\t\tbytes memory _data\r\n\t) private returns (bool) {\r\n\t\tif (to.isContract()) {\r\n\t\t\ttry IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n\t\t\t\treturn retval == IERC721Receiver.onERC721Received.selector;\r\n\t\t\t} catch (bytes memory reason) {\r\n\t\t\t\tif (reason.length == 0) {\r\n\t\t\t\t\trevert(\"ERC721A: transfer to non ERC721Receiver implementer\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tassembly {\r\n\t\t\t\t\t\trevert(add(32, reason), mload(reason))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getTotalSupply() public view returns(uint256) {\r\n\t\treturn currentIndex;\r\n\t}\r\n\t/**\r\n\t * @dev Hook that is called before any token transfer. This includes minting\r\n\t * and burning.\r\n\t *\r\n\t * Calling conditions:\r\n\t *\r\n\t * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n\t * transferred to `to`.\r\n\t * - When `from` is zero, `tokenId` will be minted for `to`.\r\n\t * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n\t * - `from` and `to` are never both zero.\r\n\t *\r\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n\t */\r\n\tfunction _beforeTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal virtual {}\r\n\r\n\t/**\r\n\t * @dev Hook that is called after any transfer of tokens. This includes\r\n\t * minting and burning.\r\n\t *\r\n\t * Calling conditions:\r\n\t *\r\n\t * - when `from` and `to` are both non-zero.\r\n\t * - `from` and `to` are never both zero.\r\n\t *\r\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n\t */\r\n\tfunction _afterTokenTransfer(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 tokenId\r\n\t) internal virtual {}\r\n\r\n\tfunction _beforeTokenTransfers(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 startTokenId,\r\n\t\tuint256 quantity\r\n\t) internal virtual {}\r\n\r\n\tfunction _afterTokenTransfers(\r\n\t\taddress from,\r\n\t\taddress to,\r\n\t\tuint256 startTokenId,\r\n\t\tuint256 quantity\r\n\t) internal virtual {}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n\taddress private _owner;\r\n\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\t/**\r\n\t * @dev Initializes the contract setting the deployer as the initial owner.\r\n\t */\r\n\tconstructor() {\r\n\t\t_transferOwnership(_msgSender());\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the address of the current owner.\r\n\t */\r\n\tfunction owner() public view virtual returns (address) {\r\n\t\treturn _owner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Leaves the contract without owner. It will not be possible to call\r\n\t * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n\t *\r\n\t * NOTE: Renouncing ownership will leave the contract without an owner,\r\n\t * thereby removing any functionality that is only available to the owner.\r\n\t */\r\n\tfunction renounceOwnership() public virtual onlyOwner {\r\n\t\t_transferOwnership(address(0));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Can only be called by the current owner.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) public virtual onlyOwner {\r\n\t\trequire(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\t\t_transferOwnership(newOwner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n\t * Internal function without access restriction.\r\n\t */\r\n\tfunction _transferOwnership(address newOwner) internal virtual {\r\n\t\taddress oldOwner = _owner;\r\n\t\t_owner = newOwner;\r\n\t\temit OwnershipTransferred(oldOwner, newOwner);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Trees proofs.\r\n *\r\n * The proofs can be generated using the JavaScript library\r\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n *\r\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n */\r\nlibrary MerkleProof {\r\n\t/**\r\n\t * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n\t * defined by `root`. For this, a `proof` must be provided, containing\r\n\t * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n\t * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n\t */\r\n\tfunction verify(\r\n\t\tbytes32[] memory proof,\r\n\t\tbytes32 root,\r\n\t\tbytes32 leaf\r\n\t) internal pure returns (bool) {\r\n\t\treturn processProof(proof, leaf) == root;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n\t * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n\t * hash matches the root of the tree. When processing the proof, the pairs\r\n\t * of leafs & pre-images are assumed to be sorted.\r\n\t *\r\n\t * _Available since v4.4._\r\n\t */\r\n\tfunction processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n\t\tbytes32 computedHash = leaf;\r\n\t\tfor (uint256 i = 0; i < proof.length; i++) {\r\n\t\t\tbytes32 proofElement = proof[i];\r\n\t\t\tif (computedHash <= proofElement) {\r\n\t\t\t\t// Hash(current computed hash + current element of the proof)\r\n\t\t\t\tcomputedHash = _efficientHash(computedHash, proofElement);\r\n\t\t\t} else {\r\n\t\t\t\t// Hash(current element of the proof + current computed hash)\r\n\t\t\t\tcomputedHash = _efficientHash(proofElement, computedHash);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn computedHash;\r\n\t}\r\n\r\n\tfunction _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n\t\tassembly {\r\n\t\t\tmstore(0x00, a)\r\n\t\t\tmstore(0x20, b)\r\n\t\t\tvalue := keccak256(0x00, 0x40)\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tuint256 c = a + b;\r\n\t\t\tif (c < a) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b > a) return (false, 0);\r\n\t\t\treturn (true, a - b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t\t// benefit is lost if 'b' is also tested.\r\n\t\t\t// See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n\t\t\tif (a == 0) return (true, 0);\r\n\t\t\tuint256 c = a * b;\r\n\t\t\tif (c / a != b) return (false, 0);\r\n\t\t\treturn (true, c);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a / b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n\t *\r\n\t * _Available since v3.4._\r\n\t */\r\n\tfunction tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n\t\tunchecked {\r\n\t\t\tif (b == 0) return (false, 0);\r\n\t\t\treturn (true, a % b);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the addition of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `+` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Addition cannot overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a + b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the multiplication of two unsigned integers, reverting on\r\n\t * overflow.\r\n\t *\r\n\t * Counterpart to Solidity's `*` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Multiplication cannot overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a * b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting when dividing by zero.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n\t\treturn a % b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n\t * overflow (when the result is negative).\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {trySub}.\r\n\t *\r\n\t * Counterpart to Solidity's `-` operator.\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - Subtraction cannot overflow.\r\n\t */\r\n\tfunction sub(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b <= a, errorMessage);\r\n\t\t\treturn a - b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n\t * division by zero. The result is rounded towards zero.\r\n\t *\r\n\t * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n\t * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n\t * uses an invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction div(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a / b;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n\t * reverting with custom message when dividing by zero.\r\n\t *\r\n\t * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n\t * message unnecessarily. For custom revert reasons use {tryMod}.\r\n\t *\r\n\t * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n\t * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n\t * invalid opcode to revert (consuming all remaining gas).\r\n\t *\r\n\t * Requirements:\r\n\t *\r\n\t * - The divisor cannot be zero.\r\n\t */\r\n\tfunction mod(\r\n\t\tuint256 a,\r\n\t\tuint256 b,\r\n\t\tstring memory errorMessage\r\n\t) internal pure returns (uint256) {\r\n\t\tunchecked {\r\n\t\t\trequire(b > 0, errorMessage);\r\n\t\t\treturn a % b;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Companions is ERC721A, Ownable\r\n{\r\n\tusing SafeMath for uint256;\r\n\r\n\tIERC721 starContract;\r\n\r\n\tstring public baseURI;\r\n\tstring public provenanceHash;\r\n\r\n\tuint256 public maxSupply = 10000;\r\n\tuint256 public maxBatchAmount = 400;\r\n\r\n\tuint256 public holderMintedAmount;\r\n\tuint256 public adminMintedAmount;\r\n\tuint256 public whitelistMintedAmount;\r\n\tuint256 public publicMintedAmount;\r\n\r\n\tuint256 public whitelistMintPrice = 0.042 ether;\r\n\tuint256 public publicMintPrice;\r\n\tuint256 public publicMaxPerTransaction = 10;\r\n\tuint256 public startingIndexBlock;\r\n\tuint256 public startingIndex;\r\n\r\n\tbool public holderMintActive = false;\r\n\tbool public whitelistMintActive = false;\r\n\tbool public publicMintActive = false;\r\n\r\n\tmapping(uint256 => bool) public usedStarIds;\r\n\tmapping(uint256 => uint256) public matchStarComp;\r\n\tmapping(address => bool) public mintedWhitelist;\r\n\r\n\tbytes32 private whitelistRoot;\r\n\tbytes32 private tieredWhitelistRoot;\r\n\r\n\r\n\t/**\r\n\t* @dev TheSolaVerse: Companions\r\n\t*/\r\n\tconstructor() ERC721A(\"The SolaVerse: Companions\", \"Companion\") {}\r\n\r\n\r\n\t/**\r\n\t* @dev Calculate the total amount minted so far.\r\n\t*/\r\n\tfunction totalSupply() public view returns (uint256)\r\n\t{\r\n\t\treturn holderMintedAmount.add(adminMintedAmount).add(whitelistMintedAmount).add(publicMintedAmount);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev SOLA-STAR holder wallets.\r\n\t*/\r\n\tfunction holderMint(uint256[] memory _ids) public\r\n\t{\r\n\t\trequire(holderMintActive, \"Holder mint is paused.\");\r\n\t\trequire(_ids.length <= maxBatchAmount, \"Can't mint that many.\");\r\n\r\n\t\tfor (uint256 i=0; i<_ids.length; i++)\r\n\t\t{\r\n\t\t\trequire(starContract.ownerOf(_ids[i]) == msg.sender, \"You don't own this one.\");\r\n\t\t\trequire(!usedStarIds[_ids[i]], \"This one was already used for minting.\");\r\n\t\t}\r\n\r\n\t\t_safeMint(msg.sender, _ids.length);\r\n\r\n\t\tfor (uint256 i=0; i<_ids.length; i++)\r\n\t\t{\r\n\t\t\tusedStarIds[_ids[i]] = true;\r\n\t\t\tmatchStarComp[_ids[i]] = holderMintedAmount + i;\r\n\t\t}\r\n\r\n\t\tholderMintedAmount += _ids.length;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Whitelisted wallets.\r\n\t*/\r\n\tfunction whitelistMint(bytes32[] memory _proof, uint256 _num_tokens) public payable\r\n\t{\r\n\t\trequire(whitelistMintActive, \"Whitelist mint is paused.\");\r\n\t\trequire(mintedWhitelist[msg.sender] == false, \"Already minted.\");\r\n\t\trequire(msg.value == _num_tokens.mul(whitelistMintPrice), \"Insufficient funds.\");\r\n\r\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender));\r\n\t\trequire(MerkleProof.verify(_proof, whitelistRoot, leaf), \"Invalid proof.\");\r\n\r\n\t\t_safeMint(msg.sender, _num_tokens);\r\n\r\n\t\twhitelistMintedAmount += _num_tokens;\r\n\t\tmintedWhitelist[msg.sender] = true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Whitelisted wallets with Tiers.\r\n\t*/\r\n\tfunction tieredWhitelistMint(bytes32[] memory _proof, uint256 _num_tokens) public payable\r\n\t{\r\n\t\trequire(whitelistMintActive, \"Whitelist mint is paused.\");\r\n\t\trequire(mintedWhitelist[msg.sender] == false, \"Already minted.\");\r\n\t\trequire(msg.value == _num_tokens.mul(whitelistMintPrice), \"Insufficient funds.\");\r\n\r\n\t\tbytes32 leaf = keccak256(abi.encodePacked(msg.sender, _num_tokens));\r\n\t\trequire(MerkleProof.verify(_proof, tieredWhitelistRoot, leaf), \"Invalid proof.\");\r\n\r\n\t\t_safeMint(msg.sender, _num_tokens);\r\n\r\n\t\twhitelistMintedAmount += _num_tokens;\r\n\t\tmintedWhitelist[msg.sender] = true;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Public mint.\r\n\t*/\r\n\tfunction publicMint(uint256 _num_tokens) public payable\r\n\t{\r\n\t\trequire(publicMintActive, \"Public mint is paused.\");\r\n\t\trequire(publicMintPrice > 0, \"Public mint price not set.\");\r\n\t\trequire(msg.value == publicMintPrice.mul(_num_tokens), \"Insufficient funds.\");\r\n\t\trequire(_num_tokens <= publicMaxPerTransaction, \"Can't mint that many at once.\");\r\n\t\trequire(totalSupply().add(_num_tokens) <= maxSupply, \"Can't mint that many.\");\r\n\r\n\t\t_safeMint(msg.sender, _num_tokens);\r\n\r\n\t\tpublicMintedAmount += _num_tokens;\r\n\r\n\t\tif (startingIndexBlock == 0 && (totalSupply() == maxSupply))\r\n\t\t{\r\n\t\t\tstartingIndexBlock = block.number;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Admin mint.\r\n\t*/\r\n\tfunction adminMint(address _to, uint256 _num_tokens) public onlyOwner\r\n\t{\r\n\t\trequire(_num_tokens <= maxBatchAmount, \"Can't mint that many.\");\r\n\r\n\t\t_safeMint(_to, _num_tokens);\r\n\r\n\t\tadminMintedAmount += _num_tokens;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Link to the SOLA-STAR NFT contract to check ownership during holderMint.\r\n\t*/\r\n\tfunction setStarContract(address _addr) public onlyOwner\r\n\t{\r\n\t\tstarContract = IERC721(_addr);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Set the Merkle Root for the Whitelist.\r\n\t*/\r\n\tfunction setWhitelistMerkleRoot(bytes32 _root) public onlyOwner\r\n\t{\r\n\t\twhitelistRoot = _root;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Set the Merkle Root for the Tiered Whitelist.\r\n\t*/\r\n\tfunction setTieredWhitelistMerkleRoot(bytes32 _root) public onlyOwner\r\n\t{\r\n\t\ttieredWhitelistRoot = _root;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Toggle the Holder Mint status.\r\n\t*/\r\n\tfunction toggleHolderMint() public onlyOwner\r\n\t{\r\n\t\tholderMintActive = !holderMintActive;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Toggle the Whitelist Mint status.\r\n\t*/\r\n\tfunction toggleWhitelistMint() public onlyOwner\r\n\t{\r\n\t\twhitelistMintActive = !whitelistMintActive;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Toggle the Public Mint status.\r\n\t*/\r\n\tfunction togglepublicMint() public onlyOwner\r\n\t{\r\n\t\tpublicMintActive = !publicMintActive;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Set the cost of the tokens for the public mint.\r\n\t*/\r\n\tfunction setPublicMintPrice(uint256 _price) public onlyOwner\r\n\t{\r\n\t\tpublicMintPrice = _price;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Update the BaseURI for the reveals.\r\n\t*/\r\n\tfunction setBaseURI(string memory _newBaseURI) public onlyOwner\r\n\t{\r\n\t\tbaseURI = _newBaseURI;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Get the Base URI.\r\n\t*/\r\n\tfunction _baseURI() internal view virtual override returns (string memory)\r\n\t{\r\n\t\treturn baseURI;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Finalize starting index.\r\n\t */\r\n\tfunction finalizeStartingIndex() public onlyOwner\r\n\t{\r\n\t\trequire(startingIndex == 0, \"Starting index already set.\");\r\n\t\trequire(startingIndexBlock != 0, \"Starting index block not set.\");\r\n\r\n\t\tstartingIndex = uint256(blockhash(startingIndexBlock)) % maxSupply;\r\n\r\n\t\tif (block.number.sub(startingIndexBlock) > 255)\r\n\t\t{\r\n\t\t\tstartingIndex = uint256(blockhash(block.number.sub(1))) % maxSupply;\r\n\t\t}\r\n\r\n\t\tif (startingIndex == 0)\r\n\t\t{\r\n\t\t\tstartingIndex = startingIndex.add(1);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Set the starting index block for the collection, essentially unblocking setting starting index.\r\n\t */\r\n\tfunction emergencySetStartingIndexBlock() public onlyOwner\r\n\t{\r\n\t\trequire(startingIndex == 0, \"Starting index already set.\");\r\n\r\n\t\tstartingIndexBlock = block.number;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @dev Set provenance once it's calculated.\r\n\t *\r\n\t * @param _provenance_hash string memory\r\n\t */\r\n\tfunction setProvenanceHash(string memory _provenance_hash) public onlyOwner\r\n\t{\r\n\t\tprovenanceHash = _provenance_hash;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t* @dev Withdraw the balance from the contract.\r\n\t*/\r\n\tfunction withdraw() public onlyOwner\r\n\t{\r\n\t\tuint256 balance = address(this).balance;\r\n\t\trequire(balance > 0, \"Balance is 0\");\r\n\t\tpayable(msg.sender).transfer(balance);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_num_tokens\",\"type\":\"uint256\"}],\"name\":\"adminMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencySetStartingIndexBlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalizeStartingIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"holderMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"holderMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"matchStarComp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBatchAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBatchSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mintedWhitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"provenanceHash\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMaxPerTransaction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_num_tokens\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_provenance_hash\",\"type\":\"string\"}],\"name\":\"setProvenanceHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setPublicMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setStarContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setTieredWhitelistMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"setWhitelistMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingIndexBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_num_tokens\",\"type\":\"uint256\"}],\"name\":\"tieredWhitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleHolderMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleWhitelistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglepublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedStarIds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_num_tokens\",\"type\":\"uint256\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Companions", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "8888", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7a22df7f68a496a33697571902d2346760033d22c8991c7b01d36f3e05a09d28"}]}