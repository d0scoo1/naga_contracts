{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@solidstate/contracts/access/IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173Internal } from './IERC173Internal.sol';\\n\\n/**\\n * @title Contract ownership standard interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-173\\n */\\ninterface IERC173 is IERC173Internal {\\n    /**\\n     * @notice get the ERC173 contract owner\\n     * @return conrtact owner\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice transfer contract ownership to new account\\n     * @param account address of new owner\\n     */\\n    function transferOwnership(address account) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/IERC173Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC173 interface needed by internal functions\\n */\\ninterface IERC173Internal {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173 } from '../IERC173.sol';\\n\\ninterface IOwnable is IERC173 {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173Internal } from '../IERC173Internal.sol';\\n\\ninterface IOwnableInternal is IERC173Internal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable } from './IOwnable.sol';\\n\\ninterface ISafeOwnable is IOwnable {\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function nomineeOwner() external view returns (address);\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/ISafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\n\\ninterface ISafeOwnableInternal is IOwnableInternal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173 } from '../IERC173.sol';\\nimport { IOwnable } from './IOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173\\n */\\nabstract contract Ownable is IOwnable, OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC173\\n     */\\n    function transferOwnership(address account) public virtual onlyOwner {\\n        _transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal is IOwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n\\n    function _owner() internal view virtual returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    function _transferOwnership(address account) internal virtual {\\n        OwnableStorage.layout().setOwner(account);\\n        emit OwnershipTransferred(msg.sender, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Ownable, OwnableStorage } from './Ownable.sol';\\nimport { ISafeOwnable } from './ISafeOwnable.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { SafeOwnableInternal } from './SafeOwnableInternal.sol';\\n\\n/**\\n * @title Ownership access control based on ERC173 with ownership transfer safety check\\n */\\nabstract contract SafeOwnable is ISafeOwnable, Ownable, SafeOwnableInternal {\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function nomineeOwner() public view virtual returns (address) {\\n        return _nomineeOwner();\\n    }\\n\\n    /**\\n     * @inheritdoc ISafeOwnable\\n     */\\n    function acceptOwnership() public virtual onlyNomineeOwner {\\n        _acceptOwnership();\\n    }\\n\\n    function _transferOwnership(address account)\\n        internal\\n        virtual\\n        override(OwnableInternal, SafeOwnableInternal)\\n    {\\n        super._transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ISafeOwnableInternal } from './ISafeOwnableInternal.sol';\\nimport { OwnableInternal } from './OwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\nimport { SafeOwnableStorage } from './SafeOwnableStorage.sol';\\n\\nabstract contract SafeOwnableInternal is ISafeOwnableInternal, OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n    using SafeOwnableStorage for SafeOwnableStorage.Layout;\\n\\n    modifier onlyNomineeOwner() {\\n        require(\\n            msg.sender == _nomineeOwner(),\\n            'SafeOwnable: sender must be nominee owner'\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice get the nominated owner who has permission to call acceptOwnership\\n     */\\n    function _nomineeOwner() internal view virtual returns (address) {\\n        return SafeOwnableStorage.layout().nomineeOwner;\\n    }\\n\\n    /**\\n     * @notice accept transfer of contract ownership\\n     */\\n    function _acceptOwnership() internal virtual {\\n        OwnableStorage.Layout storage l = OwnableStorage.layout();\\n        emit OwnershipTransferred(l.owner, msg.sender);\\n        l.setOwner(msg.sender);\\n        SafeOwnableStorage.layout().setNomineeOwner(address(0));\\n    }\\n\\n    /**\\n     * @notice set nominee owner, granting permission to call acceptOwnership\\n     */\\n    function _transferOwnership(address account) internal virtual override {\\n        SafeOwnableStorage.layout().setNomineeOwner(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/SafeOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary SafeOwnableStorage {\\n    struct Layout {\\n        address nomineeOwner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.SafeOwnable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setNomineeOwner(Layout storage l, address nomineeOwner) internal {\\n        l.nomineeOwner = nomineeOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { ERC165Storage } from './ERC165Storage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165 is IERC165 {\\n    using ERC165Storage for ERC165Storage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view returns (bool) {\\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC165Storage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return l.supportedInterfaces[interfaceId];\\n    }\\n\\n    function setSupportedInterface(\\n        Layout storage l,\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal {\\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\\n        l.supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/IProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IProxy {\\n    fallback() external payable;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../utils/AddressUtils.sol';\\nimport { IProxy } from './IProxy.sol';\\n\\n/**\\n * @title Base proxy contract\\n */\\nabstract contract Proxy is IProxy {\\n    using AddressUtils for address;\\n\\n    /**\\n     * @notice delegate all calls to implementation contract\\n     * @dev reverts if implementation address contains no code, for compatibility with metamorphic contracts\\n     * @dev memory location in use by assembly may be unsafe in other contexts\\n     */\\n    fallback() external payable virtual {\\n        address implementation = _getImplementation();\\n\\n        require(\\n            implementation.isContract(),\\n            'Proxy: implementation must be contract'\\n        );\\n\\n        assembly {\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice get logic implementation address\\n     * @return implementation address\\n     */\\n    function _getImplementation() internal virtual returns (address);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/ISolidStateDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ISafeOwnable } from '../../access/ownable/ISafeOwnable.sol';\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\nimport { IDiamondBase } from './base/IDiamondBase.sol';\\nimport { IDiamondReadable } from './readable/IDiamondReadable.sol';\\nimport { IDiamondWritable } from './writable/IDiamondWritable.sol';\\n\\ninterface ISolidStateDiamond is\\n    IDiamondBase,\\n    IDiamondReadable,\\n    IDiamondWritable,\\n    ISafeOwnable,\\n    IERC165\\n{\\n    receive() external payable;\\n\\n    /**\\n     * @notice get the address of the fallback contract\\n     * @return fallback address\\n     */\\n    function getFallbackAddress() external view returns (address);\\n\\n    /**\\n     * @notice set the address of the fallback contract\\n     * @param fallbackAddress fallback address\\n     */\\n    function setFallbackAddress(address fallbackAddress) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnable, Ownable, OwnableInternal, OwnableStorage } from '../../access/ownable/Ownable.sol';\\nimport { ISafeOwnable, SafeOwnable } from '../../access/ownable/SafeOwnable.sol';\\nimport { IERC173 } from '../../access/IERC173.sol';\\nimport { ERC165, IERC165, ERC165Storage } from '../../introspection/ERC165.sol';\\nimport { DiamondBase, DiamondBaseStorage } from './base/DiamondBase.sol';\\nimport { DiamondReadable, IDiamondReadable } from './readable/DiamondReadable.sol';\\nimport { DiamondWritable, IDiamondWritable } from './writable/DiamondWritable.sol';\\nimport { ISolidStateDiamond } from './ISolidStateDiamond.sol';\\n\\n/**\\n * @title SolidState \\\"Diamond\\\" proxy reference implementation\\n */\\nabstract contract SolidStateDiamond is\\n    ISolidStateDiamond,\\n    DiamondBase,\\n    DiamondReadable,\\n    DiamondWritable,\\n    SafeOwnable,\\n    ERC165\\n{\\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\\n    using ERC165Storage for ERC165Storage.Layout;\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    constructor() {\\n        ERC165Storage.Layout storage erc165 = ERC165Storage.layout();\\n        bytes4[] memory selectors = new bytes4[](12);\\n\\n        // register DiamondWritable\\n\\n        selectors[0] = IDiamondWritable.diamondCut.selector;\\n\\n        erc165.setSupportedInterface(type(IDiamondWritable).interfaceId, true);\\n\\n        // register DiamondReadable\\n\\n        selectors[1] = IDiamondReadable.facets.selector;\\n        selectors[2] = IDiamondReadable.facetFunctionSelectors.selector;\\n        selectors[3] = IDiamondReadable.facetAddresses.selector;\\n        selectors[4] = IDiamondReadable.facetAddress.selector;\\n\\n        erc165.setSupportedInterface(type(IDiamondReadable).interfaceId, true);\\n\\n        // register ERC165\\n\\n        selectors[5] = IERC165.supportsInterface.selector;\\n\\n        erc165.setSupportedInterface(type(IERC165).interfaceId, true);\\n\\n        // register SafeOwnable\\n\\n        selectors[6] = Ownable.owner.selector;\\n        selectors[7] = SafeOwnable.nomineeOwner.selector;\\n        selectors[8] = Ownable.transferOwnership.selector;\\n        selectors[9] = SafeOwnable.acceptOwnership.selector;\\n\\n        erc165.setSupportedInterface(type(IERC173).interfaceId, true);\\n\\n        // register Diamond\\n\\n        selectors[10] = SolidStateDiamond.getFallbackAddress.selector;\\n        selectors[11] = SolidStateDiamond.setFallbackAddress.selector;\\n\\n        // diamond cut\\n\\n        FacetCut[] memory facetCuts = new FacetCut[](1);\\n\\n        facetCuts[0] = FacetCut({\\n            target: address(this),\\n            action: IDiamondWritable.FacetCutAction.ADD,\\n            selectors: selectors\\n        });\\n\\n        DiamondBaseStorage.layout().diamondCut(facetCuts, address(0), '');\\n\\n        // set owner\\n\\n        OwnableStorage.layout().setOwner(msg.sender);\\n    }\\n\\n    receive() external payable {}\\n\\n    /**\\n     * @inheritdoc ISolidStateDiamond\\n     */\\n    function getFallbackAddress() external view returns (address) {\\n        return DiamondBaseStorage.layout().fallbackAddress;\\n    }\\n\\n    /**\\n     * @inheritdoc ISolidStateDiamond\\n     */\\n    function setFallbackAddress(address fallbackAddress) external onlyOwner {\\n        DiamondBaseStorage.layout().fallbackAddress = fallbackAddress;\\n    }\\n\\n    function _transferOwnership(address account)\\n        internal\\n        virtual\\n        override(OwnableInternal, SafeOwnable)\\n    {\\n        super._transferOwnership(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/DiamondBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { Proxy } from '../../Proxy.sol';\\nimport { IDiamondBase } from './IDiamondBase.sol';\\nimport { DiamondBaseStorage } from './DiamondBaseStorage.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy base contract\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\nabstract contract DiamondBase is IDiamondBase, Proxy {\\n    /**\\n     * @inheritdoc Proxy\\n     */\\n    function _getImplementation() internal view override returns (address) {\\n        // inline storage layout retrieval uses less gas\\n        DiamondBaseStorage.Layout storage l;\\n        bytes32 slot = DiamondBaseStorage.STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n\\n        address implementation = address(bytes20(l.facets[msg.sig]));\\n\\n        if (implementation == address(0)) {\\n            implementation = l.fallbackAddress;\\n            require(\\n                implementation != address(0),\\n                'DiamondBase: no facet found for function signature'\\n            );\\n        }\\n\\n        return implementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/DiamondBaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { IDiamondWritable } from '../writable/IDiamondWritable.sol';\\n\\n/**\\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\\n */\\nlibrary DiamondBaseStorage {\\n    using AddressUtils for address;\\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\\n\\n    struct Layout {\\n        // function selector => (facet address, selector slot position)\\n        mapping(bytes4 => bytes32) facets;\\n        // total number of selectors registered\\n        uint16 selectorCount;\\n        // array of selector slots with 8 selectors per slot\\n        mapping(uint256 => bytes32) selectorSlots;\\n        address fallbackAddress;\\n    }\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK =\\n        bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.DiamondBase');\\n\\n    event DiamondCut(\\n        IDiamondWritable.FacetCut[] facetCuts,\\n        address target,\\n        bytes data\\n    );\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @notice update functions callable on Diamond proxy\\n     * @param l storage layout\\n     * @param facetCuts array of structured Diamond facet update data\\n     * @param target optional recipient of initialization delegatecall\\n     * @param data optional initialization call data\\n     */\\n    function diamondCut(\\n        Layout storage l,\\n        IDiamondWritable.FacetCut[] memory facetCuts,\\n        address target,\\n        bytes memory data\\n    ) internal {\\n        unchecked {\\n            uint256 originalSelectorCount = l.selectorCount;\\n            uint256 selectorCount = originalSelectorCount;\\n            bytes32 selectorSlot;\\n\\n            // Check if last selector slot is not full\\n            if (selectorCount & 7 > 0) {\\n                // get last selectorSlot\\n                selectorSlot = l.selectorSlots[selectorCount >> 3];\\n            }\\n\\n            for (uint256 i; i < facetCuts.length; i++) {\\n                IDiamondWritable.FacetCut memory facetCut = facetCuts[i];\\n                IDiamondWritable.FacetCutAction action = facetCut.action;\\n\\n                require(\\n                    facetCut.selectors.length > 0,\\n                    'DiamondBase: no selectors specified'\\n                );\\n\\n                if (action == IDiamondWritable.FacetCutAction.ADD) {\\n                    (selectorCount, selectorSlot) = l.addFacetSelectors(\\n                        selectorCount,\\n                        selectorSlot,\\n                        facetCut\\n                    );\\n                } else if (action == IDiamondWritable.FacetCutAction.REPLACE) {\\n                    l.replaceFacetSelectors(facetCut);\\n                } else if (action == IDiamondWritable.FacetCutAction.REMOVE) {\\n                    (selectorCount, selectorSlot) = l.removeFacetSelectors(\\n                        selectorCount,\\n                        selectorSlot,\\n                        facetCut\\n                    );\\n                }\\n            }\\n\\n            if (selectorCount != originalSelectorCount) {\\n                l.selectorCount = uint16(selectorCount);\\n            }\\n\\n            // If last selector slot is not full\\n            if (selectorCount & 7 > 0) {\\n                l.selectorSlots[selectorCount >> 3] = selectorSlot;\\n            }\\n\\n            emit DiamondCut(facetCuts, target, data);\\n            initialize(target, data);\\n        }\\n    }\\n\\n    function addFacetSelectors(\\n        Layout storage l,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        IDiamondWritable.FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            require(\\n                facetCut.target == address(this) ||\\n                    facetCut.target.isContract(),\\n                'DiamondBase: ADD target has no code'\\n            );\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = l.facets[selector];\\n\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    'DiamondBase: selector already added'\\n                );\\n\\n                // add facet for selector\\n                l.facets[selector] =\\n                    bytes20(facetCut.target) |\\n                    bytes32(selectorCount);\\n                uint256 selectorInSlotPosition = (selectorCount & 7) << 5;\\n\\n                // clear selector position in slot and add selector\\n                selectorSlot =\\n                    (selectorSlot &\\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    l.selectorSlots[selectorCount >> 3] = selectorSlot;\\n                    selectorSlot = 0;\\n                }\\n\\n                selectorCount++;\\n            }\\n\\n            return (selectorCount, selectorSlot);\\n        }\\n    }\\n\\n    function removeFacetSelectors(\\n        Layout storage l,\\n        uint256 selectorCount,\\n        bytes32 selectorSlot,\\n        IDiamondWritable.FacetCut memory facetCut\\n    ) internal returns (uint256, bytes32) {\\n        unchecked {\\n            require(\\n                facetCut.target == address(0),\\n                'DiamondBase: REMOVE target must be zero address'\\n            );\\n\\n            uint256 selectorSlotCount = selectorCount >> 3;\\n            uint256 selectorInSlotIndex = selectorCount & 7;\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = l.facets[selector];\\n\\n                require(\\n                    address(bytes20(oldFacet)) != address(0),\\n                    'DiamondBase: selector not found'\\n                );\\n\\n                require(\\n                    address(bytes20(oldFacet)) != address(this),\\n                    'DiamondBase: selector is immutable'\\n                );\\n\\n                if (selectorSlot == 0) {\\n                    selectorSlotCount--;\\n                    selectorSlot = l.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n\\n                // adding a block here prevents stack too deep error\\n                {\\n                    // replace selector with last selector in l.facets\\n                    lastSelector = bytes4(\\n                        selectorSlot << (selectorInSlotIndex << 5)\\n                    );\\n\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        l.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(l.facets[lastSelector]);\\n                    }\\n\\n                    delete l.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = l.selectorSlots[\\n                        oldSelectorsSlotCount\\n                    ];\\n\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n\\n                    // update storage with the modified slot\\n                    l.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    selectorSlot =\\n                        (selectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n\\n                if (selectorInSlotIndex == 0) {\\n                    delete l.selectorSlots[selectorSlotCount];\\n                    selectorSlot = 0;\\n                }\\n            }\\n\\n            selectorCount = (selectorSlotCount << 3) | selectorInSlotIndex;\\n\\n            return (selectorCount, selectorSlot);\\n        }\\n    }\\n\\n    function replaceFacetSelectors(\\n        Layout storage l,\\n        IDiamondWritable.FacetCut memory facetCut\\n    ) internal {\\n        unchecked {\\n            require(\\n                facetCut.target.isContract(),\\n                'DiamondBase: REPLACE target has no code'\\n            );\\n\\n            for (uint256 i; i < facetCut.selectors.length; i++) {\\n                bytes4 selector = facetCut.selectors[i];\\n                bytes32 oldFacet = l.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n\\n                require(\\n                    oldFacetAddress != address(0),\\n                    'DiamondBase: selector not found'\\n                );\\n\\n                require(\\n                    oldFacetAddress != address(this),\\n                    'DiamondBase: selector is immutable'\\n                );\\n\\n                require(\\n                    oldFacetAddress != facetCut.target,\\n                    'DiamondBase: REPLACE target is identical'\\n                );\\n\\n                // replace old facet address\\n                l.facets[selector] =\\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\\n                    bytes20(facetCut.target);\\n            }\\n        }\\n    }\\n\\n    function initialize(address target, bytes memory data) private {\\n        require(\\n            (target == address(0)) == (data.length == 0),\\n            'DiamondBase: invalid initialization parameters'\\n        );\\n\\n        if (target != address(0)) {\\n            if (target != address(this)) {\\n                require(\\n                    target.isContract(),\\n                    'DiamondBase: initialization target has no code'\\n                );\\n            }\\n\\n            (bool success, ) = target.delegatecall(data);\\n\\n            if (!success) {\\n                assembly {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/base/IDiamondBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IProxy } from '../../IProxy.sol';\\n\\ninterface IDiamondBase is IProxy {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/DiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondReadable } from './IDiamondReadable.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy introspection contract\\n * @dev derived from https://github.com/mudgen/diamond-2 (MIT license)\\n */\\nabstract contract DiamondReadable is IDiamondReadable {\\n    /**\\n     * @inheritdoc IDiamondReadable\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets) {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        diamondFacets = new Facet[](l.selectorCount);\\n\\n        uint8[] memory numFacetSelectors = new uint8[](l.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\\n            bytes32 slot = l.selectorSlots[slotIndex];\\n\\n            for (\\n                uint256 selectorSlotIndex;\\n                selectorSlotIndex < 8;\\n                selectorSlotIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                address facet = address(bytes20(l.facets[selector]));\\n\\n                bool continueLoop;\\n\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (diamondFacets[facetIndex].target == facet) {\\n                        diamondFacets[facetIndex].selectors[\\n                            numFacetSelectors[facetIndex]\\n                        ] = selector;\\n                        // probably will never have more than 256 functions from one facet contract\\n                        require(numFacetSelectors[facetIndex] < 255);\\n                        numFacetSelectors[facetIndex]++;\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (continueLoop) {\\n                    continue;\\n                }\\n\\n                diamondFacets[numFacets].target = facet;\\n                diamondFacets[numFacets].selectors = new bytes4[](\\n                    l.selectorCount\\n                );\\n                diamondFacets[numFacets].selectors[0] = selector;\\n                numFacetSelectors[numFacets] = 1;\\n                numFacets++;\\n            }\\n        }\\n\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\n            bytes4[] memory selectors = diamondFacets[facetIndex].selectors;\\n\\n            // setting the number of selectors\\n            assembly {\\n                mstore(selectors, numSelectors)\\n            }\\n        }\\n\\n        // setting the number of facets\\n        assembly {\\n            mstore(diamondFacets, numFacets)\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDiamondReadable\\n     */\\n    function facetFunctionSelectors(address facet)\\n        external\\n        view\\n        returns (bytes4[] memory selectors)\\n    {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        selectors = new bytes4[](l.selectorCount);\\n\\n        uint256 numSelectors;\\n        uint256 selectorIndex;\\n\\n        // loop through function selectors\\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\\n            bytes32 slot = l.selectorSlots[slotIndex];\\n\\n            for (\\n                uint256 selectorSlotIndex;\\n                selectorSlotIndex < 8;\\n                selectorSlotIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n\\n                if (facet == address(bytes20(l.facets[selector]))) {\\n                    selectors[numSelectors] = selector;\\n                    numSelectors++;\\n                }\\n            }\\n        }\\n\\n        // set the number of selectors in the array\\n        assembly {\\n            mstore(selectors, numSelectors)\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDiamondReadable\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses)\\n    {\\n        DiamondBaseStorage.Layout storage l = DiamondBaseStorage.layout();\\n\\n        addresses = new address[](l.selectorCount);\\n        uint256 numFacets;\\n        uint256 selectorIndex;\\n\\n        for (uint256 slotIndex; selectorIndex < l.selectorCount; slotIndex++) {\\n            bytes32 slot = l.selectorSlots[slotIndex];\\n\\n            for (\\n                uint256 selectorSlotIndex;\\n                selectorSlotIndex < 8;\\n                selectorSlotIndex++\\n            ) {\\n                selectorIndex++;\\n\\n                if (selectorIndex > l.selectorCount) {\\n                    break;\\n                }\\n\\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\\n                address facet = address(bytes20(l.facets[selector]));\\n\\n                bool continueLoop;\\n\\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\n                    if (facet == addresses[facetIndex]) {\\n                        continueLoop = true;\\n                        break;\\n                    }\\n                }\\n\\n                if (continueLoop) {\\n                    continue;\\n                }\\n\\n                addresses[numFacets] = facet;\\n                numFacets++;\\n            }\\n        }\\n\\n        // set the number of facet addresses in the array\\n        assembly {\\n            mstore(addresses, numFacets)\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc IDiamondReadable\\n     */\\n    function facetAddress(bytes4 selector)\\n        external\\n        view\\n        returns (address facet)\\n    {\\n        facet = address(bytes20(DiamondBaseStorage.layout().facets[selector]));\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/readable/IDiamondReadable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Diamond proxy introspection interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondReadable {\\n    struct Facet {\\n        address target;\\n        bytes4[] selectors;\\n    }\\n\\n    /**\\n     * @notice get all facets and their selectors\\n     * @return diamondFacets array of structured facet data\\n     */\\n    function facets() external view returns (Facet[] memory diamondFacets);\\n\\n    /**\\n     * @notice get all selectors for given facet address\\n     * @param facet address of facet to query\\n     * @return selectors array of function selectors\\n     */\\n    function facetFunctionSelectors(address facet)\\n        external\\n        view\\n        returns (bytes4[] memory selectors);\\n\\n    /**\\n     * @notice get addresses of all facets used by diamond\\n     * @return addresses array of facet addresses\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory addresses);\\n\\n    /**\\n     * @notice get the address of the facet associated with given selector\\n     * @param selector function selector to query\\n     * @return facet facet address (zero address if not found)\\n     */\\n    function facetAddress(bytes4 selector)\\n        external\\n        view\\n        returns (address facet);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/DiamondWritable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableInternal } from '../../../access/ownable/OwnableInternal.sol';\\nimport { DiamondBaseStorage } from '../base/DiamondBaseStorage.sol';\\nimport { IDiamondWritable } from './IDiamondWritable.sol';\\n\\n/**\\n * @title EIP-2535 \\\"Diamond\\\" proxy update contract\\n */\\nabstract contract DiamondWritable is IDiamondWritable, OwnableInternal {\\n    using DiamondBaseStorage for DiamondBaseStorage.Layout;\\n\\n    /**\\n     * @inheritdoc IDiamondWritable\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata facetCuts,\\n        address target,\\n        bytes calldata data\\n    ) external onlyOwner {\\n        DiamondBaseStorage.layout().diamondCut(facetCuts, target, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/proxy/diamond/writable/IDiamondWritable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Diamond proxy upgrade interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-2535\\n */\\ninterface IDiamondWritable {\\n    enum FacetCutAction {\\n        ADD,\\n        REPLACE,\\n        REMOVE\\n    }\\n\\n    event DiamondCut(FacetCut[] facetCuts, address target, bytes data);\\n\\n    struct FacetCut {\\n        address target;\\n        FacetCutAction action;\\n        bytes4[] selectors;\\n    }\\n\\n    /**\\n     * @notice update diamond facets and optionally execute arbitrary initialization function\\n     * @param facetCuts array of structured Diamond facet update data\\n     * @param target optional target of initialization delegatecall\\n     * @param data optional initialization function call data\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata facetCuts,\\n        address target,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC1155Internal } from './IERC1155Internal.sol';\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\n\\n/**\\n * @title ERC1155 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/1155\\n */\\ninterface IERC1155 is IERC1155Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given token held by given address\\n     * @param account address to query\\n     * @param id token to query\\n     * @return token balance\\n     */\\n    function balanceOf(address account, uint256 id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice query the balances of given tokens held by given addresses\\n     * @param accounts addresss to query\\n     * @param ids tokens to query\\n     * @return token balances\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given operator to spend held tokens\\n     * @param operator address whose approval status to update\\n     * @param status whether operator should be considered approved\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice transfer tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param id token ID\\n     * @param amount quantity of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @notice transfer batch of tokens between given addresses, checking for ERC1155Receiver implementation if applicable\\n     * @param from sender of tokens\\n     * @param to receiver of tokens\\n     * @param ids list of token IDs\\n     * @param amounts list of quantities of tokens to transfer\\n     * @param data data payload\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/IERC1155Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\n\\n/**\\n * @title Partial ERC1155 interface needed by internal functions\\n */\\ninterface IERC1155Internal {\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 value\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed account,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC1155 metadata extensions\\n */\\nlibrary ERC1155MetadataStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\\n\\n    struct Layout {\\n        string baseURI;\\n        mapping(uint256 => string) tokenURIs;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\\n\\n/**\\n * @title ERC1155Metadata interface\\n */\\ninterface IERC1155Metadata is IERC1155MetadataInternal {\\n    /**\\n     * @notice get generated URI for given token\\n     * @return token URI\\n     */\\n    function uri(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC1155Metadata interface needed by internal functions\\n */\\ninterface IERC1155MetadataInternal {\\n    event URI(string value, uint256 indexed tokenId);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { UintUtils } from './UintUtils.sol';\\n\\nlibrary AddressUtils {\\n    using UintUtils for uint256;\\n\\n    function toString(address account) internal pure returns (string memory) {\\n        return uint256(uint160(account)).toHexString(20);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title utility functions for uint256 operations\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts/ (MIT license)\\n */\\nlibrary UintUtils {\\n    bytes16 private constant HEX_SYMBOLS = '0123456789abcdef';\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0x00';\\n        }\\n\\n        uint256 length = 0;\\n\\n        for (uint256 temp = value; temp != 0; temp >>= 8) {\\n            unchecked {\\n                length++;\\n            }\\n        }\\n\\n        return toHexString(value, length);\\n    }\\n\\n    function toHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = '0';\\n        buffer[1] = 'x';\\n\\n        unchecked {\\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\\n                buffer[i] = HEX_SYMBOLS[value & 0xf];\\n                value >>= 4;\\n            }\\n        }\\n\\n        require(value == 0, 'UintUtils: hex length insufficient');\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@solidstate/contracts/access/ownable/OwnableInternal.sol\\\";\\nimport \\\"@solidstate/contracts/introspection/ERC165Storage.sol\\\";\\nimport \\\"@solidstate/contracts/proxy/diamond/SolidStateDiamond.sol\\\";\\nimport \\\"@solidstate/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@solidstate/contracts/token/ERC1155/metadata/IERC1155Metadata.sol\\\";\\nimport \\\"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\\\";\\n\\nimport \\\"../vendor/ERC2981/IERC2981Royalties.sol\\\";\\nimport \\\"../vendor/ERC2981/ERC2981Storage.sol\\\";\\nimport \\\"../vendor/OpenSea/OpenSeaCompatible.sol\\\";\\nimport \\\"../vendor/OpenSea/OpenSeaProxyStorage.sol\\\";\\n\\nimport \\\"./LandStorage.sol\\\";\\nimport \\\"./LandTypes.sol\\\";\\n\\ncontract LandProxy is SolidStateDiamond {\\n\\tusing ERC165Storage for ERC165Storage.Layout;\\n\\n\\tconstructor() {\\n\\t\\tERC165Storage.layout().setSupportedInterface(type(IERC1155).interfaceId, true);\\n\\t\\tERC165Storage.layout().setSupportedInterface(type(IERC1155Metadata).interfaceId, true);\\n\\t\\tERC165Storage.layout().setSupportedInterface(type(IERC2981Royalties).interfaceId, true);\\n\\t}\\n}\\n\\ncontract LandProxyInitializer {\\n\\tfunction init(\\n\\t\\tLandInitArgs memory landInit,\\n\\t\\tRoyaltyInfo memory royaltyInit,\\n\\t\\tOpenSeaProxyInitArgs memory osInit,\\n\\t\\tstring memory contractURI,\\n\\t\\tstring memory baseURI\\n\\t) external {\\n\\t\\t// Init ERC1155Metadata\\n\\t\\tERC1155MetadataStorage.layout().baseURI = baseURI;\\n\\t\\tOpenSeaCompatibleStorage.layout().contractURI = contractURI;\\n\\n\\t\\t// Init Land\\n\\t\\tLandStorage.layout().mintState = uint8(MintState.CLOSED);\\n\\t\\tLandStorage.layout().price = 0.2 ether;\\n\\n\\t\\tLandStorage.layout().signer = landInit.signer;\\n\\t\\tLandStorage.layout().avatars = landInit.avatars;\\n\\n\\t\\tLandStorage.layout().avatarClaim = landInit.avatarClaim;\\n\\n\\t\\t// loop thru the zones for sale\\n\\t\\tfor (uint8 i = 0; i < landInit.zones.length; i++) {\\n\\t\\t\\tLandStorage._addZone(landInit.zones[i]);\\n\\t\\t}\\n\\n\\t\\t// Init Royalties\\n\\t\\tERC2981Storage.layout().royalties = royaltyInit;\\n\\n\\t\\t// Init Opensea Proxy\\n\\t\\tOpenSeaProxyStorage._setProxies(osInit);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { MintState, Zone } from \\\"./LandTypes.sol\\\";\\n\\nlibrary LandStorage {\\n\\tstruct Layout {\\n\\t\\tuint8 mintState;\\n\\t\\tuint16 index; // current incremental index of zone id's\\n\\t\\tuint64 price;\\n\\t\\taddress signer;\\n\\t\\taddress avatars;\\n\\t\\tZone avatarClaim; // zoneId is zero\\n\\t\\tmapping(uint256 => address) claimedAvatars;\\n\\t\\tmapping(uint16 => Zone) zones;\\n\\t\\tmapping(address => bool) proxies;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"io.frogland.contracts.storage.LandStorage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n\\n\\t// Adders\\n\\n\\tfunction _addClaimCount(uint16 count) internal {\\n\\t\\tlayout().avatarClaim.count += count;\\n\\t}\\n\\n\\tfunction _addCount(uint16 index, uint16 count) internal {\\n\\t\\tZone storage zone = _getZone(index);\\n\\t\\t_addCount(zone, count);\\n\\t}\\n\\n\\tfunction _addCount(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.count += count;\\n\\t}\\n\\n\\tfunction _addInventory(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.max += count;\\n\\t}\\n\\n\\tfunction _removeInventory(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.max -= count;\\n\\t}\\n\\n\\tfunction _addZone(Zone memory zone) internal {\\n\\t\\tuint16 index = _getIndex();\\n\\t\\tindex += 1;\\n\\t\\tlayout().zones[index] = zone;\\n\\t\\t_setIndex(index);\\n\\t}\\n\\n\\t// Getters\\n\\n\\tfunction _getClaimedAvatar(uint256 tokenId) internal view returns (address) {\\n\\t\\treturn layout().claimedAvatars[tokenId];\\n\\t}\\n\\n\\tfunction _getIndex() internal view returns (uint16 index) {\\n\\t\\treturn layout().index;\\n\\t}\\n\\n\\tfunction _getPrice() internal view returns (uint64) {\\n\\t\\treturn layout().price;\\n\\t}\\n\\n\\tfunction _getSigner() internal view returns (address) {\\n\\t\\treturn layout().signer;\\n\\t}\\n\\n\\tfunction _getZone(uint16 index) internal view returns (Zone storage) {\\n\\t\\tif (index == 0) {\\n\\t\\t\\treturn layout().avatarClaim;\\n\\t\\t}\\n\\t\\treturn layout().zones[index];\\n\\t}\\n\\n\\t// Setters\\n\\n\\tfunction _setAvatars(address avatars) internal {\\n\\t\\tlayout().avatars = avatars;\\n\\t}\\n\\n\\tfunction _setClaimedAvatar(uint256 tokenId, address claimedBy) internal {\\n\\t\\tlayout().claimedAvatars[tokenId] = claimedBy;\\n\\t}\\n\\n\\tfunction _setClaimedAvatars(uint256[] memory tokenIds, address claimedBy) internal {\\n\\t\\tfor (uint256 index = 0; index < tokenIds.length; index++) {\\n\\t\\t\\tuint256 tokenId = tokenIds[index];\\n\\t\\t\\t_setClaimedAvatar(tokenId, claimedBy);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setIndex(uint16 index) internal {\\n\\t\\tlayout().index = index;\\n\\t}\\n\\n\\tfunction _setInventory(Zone storage zone, uint16 maxCount) internal {\\n\\t\\tzone.max = maxCount;\\n\\t}\\n\\n\\tfunction _setPrice(uint64 price) internal {\\n\\t\\tlayout().price = price;\\n\\t}\\n\\n\\tfunction _setProxy(address proxy, bool enabled) internal {\\n\\t\\tlayout().proxies[proxy] = enabled;\\n\\t}\\n\\n\\tfunction _setSigner(address signer) internal {\\n\\t\\tlayout().signer = signer;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// Enums\\n\\nenum MintState {\\n\\tCLOSED,\\n\\tCLAIM,\\n\\tPRESALE,\\n\\tPUBLIC\\n}\\n\\n// Init Args\\n\\nstruct LandInitArgs {\\n\\taddress signer;\\n\\taddress avatars;\\n\\tuint64 price;\\n\\tZone avatarClaim;\\n\\tZone[] zones;\\n}\\n\\n// Structs\\n\\n// waves for sale\\n// each tranche is mapped to a zone by Id\\n// except zone 0 which is the claim\\n// the first 10k are the claim\\nstruct Zone {\\n\\tuint8 zoneId;\\n\\tuint16 count;\\n\\tuint16 max;\\n\\tuint24 startIndex;\\n\\tuint24 endIndex;\\n}\\n\\n// requests\\n\\nstruct ClaimRequest {\\n\\taddress to;\\n\\tuint64 deadline; // block.timestamp\\n\\tuint256[] tokenIds;\\n}\\n\\nstruct MintRequest {\\n\\taddress to;\\n\\tuint64 deadline; // block.timestamp\\n\\tuint8 zoneId;\\n\\tuint16 count;\\n}\\n\\nstruct MintManyRequest {\\n\\taddress to;\\n\\tuint64 deadline;\\n\\tuint16[] count; // array by zone index\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ERC2981/ERC2981Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nstruct RoyaltyInfo {\\n\\taddress recipient;\\n\\tuint24 amount;\\n}\\n\\nlibrary ERC2981Storage {\\n\\tstruct Layout {\\n\\t\\tRoyaltyInfo royalties;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT =\\n\\t\\tkeccak256(\\\"IERC2981Royalties.contracts.storage.ERC2981Storage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ERC2981/IERC2981Royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IERC2981Royalties\\n/// @dev Interface for the ERC2981 - Token Royalty standard\\ninterface IERC2981Royalties {\\n\\t/// @notice Called with the sale price to determine how much royalty\\n\\t//          is owed and to whom.\\n\\t/// @param _tokenId - the NFT asset queried for royalty information\\n\\t/// @param _value - the sale price of the NFT asset specified by _tokenId\\n\\t/// @return _receiver - address of who should be sent the royalty payment\\n\\t/// @return _royaltyAmount - the royalty payment amount for value sale price\\n\\tfunction royaltyInfo(uint256 _tokenId, uint256 _value)\\n\\t\\texternal\\n\\t\\tview\\n\\t\\treturns (address _receiver, uint256 _royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/IOpenSeaCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOpenSeaCompatible {\\n\\t/**\\n\\t * Get the contract metadata\\n\\t */\\n\\tfunction contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/OpenSeaCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOpenSeaCompatible } from \\\"./IOpenSeaCompatible.sol\\\";\\n\\nlibrary OpenSeaCompatibleStorage {\\n\\tstruct Layout {\\n\\t\\tstring contractURI;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT =\\n\\t\\tkeccak256(\\\"com.opensea.contracts.storage.OpenSeaCompatibleStorage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n}\\n\\nabstract contract OpenSeaCompatibleInternal {\\n\\tfunction _setContractURI(string memory contractURI) internal virtual {\\n\\t\\tOpenSeaCompatibleStorage.layout().contractURI = contractURI;\\n\\t}\\n}\\n\\nabstract contract OpenSeaCompatible is OpenSeaCompatibleInternal, IOpenSeaCompatible {\\n\\tfunction contractURI() external view returns (string memory) {\\n\\t\\treturn OpenSeaCompatibleStorage.layout().contractURI;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/OpenSeaProxyStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nstruct OpenSeaProxyInitArgs {\\n\\taddress os721Proxy;\\n\\taddress os1155Proxy;\\n}\\n\\nlibrary OpenSeaProxyStorage {\\n\\tstruct Layout {\\n\\t\\taddress os721Proxy;\\n\\t\\taddress os1155Proxy;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"com.opensea.contracts.storage.proxy\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setProxies(OpenSeaProxyInitArgs memory init) internal {\\n\\t\\t_setProxies(init.os721Proxy, init.os1155Proxy);\\n\\t}\\n\\n\\tfunction _setProxies(address os721Proxy, address os1155Proxy) internal {\\n\\t\\tlayout().os721Proxy = os721Proxy;\\n\\t\\tlayout().os1155Proxy = os1155Proxy;\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritable.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondWritable.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondWritable.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondWritable.FacetCut[]\",\"name\":\"facetCuts\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"selectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondReadable.Facet[]\",\"name\":\"diamondFacets\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFallbackAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nomineeOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fallbackAddress\",\"type\":\"address\"}],\"name\":\"setFallbackAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "LandProxy", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x2705793dab6e93bd59a02df6bdcad909e44ecd1a", "SwarmSource": ""}]}