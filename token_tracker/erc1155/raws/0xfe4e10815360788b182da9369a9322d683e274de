{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ApeRunnersSerum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"./base/Controllable.sol\\\";\\nimport \\\"sol-temple/src/tokens/ERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\n/// @title Ape Runners Serum\\n/// @author naomsa <https://twitter.com/naomsa666>\\ncontract ApeRunnersSerum is Ownable, Pausable, Controllable, ERC1155 {\\n  using Strings for uint256;\\n\\n  /* -------------------------------------------------------------------------- */\\n  /*                                Sale Details                                */\\n  /* -------------------------------------------------------------------------- */\\n\\n  /// @notice Utility token contract address.\\n  IRUN public utilityToken;\\n\\n  /* -------------------------------------------------------------------------- */\\n  /*                              Metadata Details                              */\\n  /* -------------------------------------------------------------------------- */\\n\\n  /// @notice Base metadata uri.\\n  string public baseURI;\\n\\n  /// @notice Base metadata uri extension.\\n  string public baseExtension;\\n\\n  constructor(\\n    string memory newBaseURI,\\n    string memory newBaseExtension,\\n    address newUtilityToken\\n  ) {\\n    // Set variables\\n    baseURI = newBaseURI;\\n    baseExtension = newBaseExtension;\\n    utilityToken = IRUN(newUtilityToken);\\n  }\\n\\n  /* -------------------------------------------------------------------------- */\\n  /*                                 Sale Logic                                 */\\n  /* -------------------------------------------------------------------------- */\\n\\n  /// @notice Buy one or more serums.\\n  /// @param serum Serum id to buy.\\n  /// @param amount Amount to buy.\\n  function buy(uint256 serum, uint256 amount) external {\\n    require(\\n      serum == 1 || serum == 2 || serum == 3,\\n      \\\"Query for nonexisting serum\\\"\\n    );\\n\\n    require(\\n      totalSupply[serum] + amount <= maxSuppply(serum),\\n      \\\"Serum max supply exceeded\\\"\\n    );\\n\\n    require(amount > 0, \\\"Invalid buy amount\\\");\\n\\n    utilityToken.burn(msg.sender, price(serum) * amount);\\n    _mint(msg.sender, serum, amount, \\\"\\\");\\n  }\\n\\n  /// @notice Retrieve serum cost.\\n  /// @param serum Serum 1, 2 or 3.\\n  function price(uint256 serum) public pure returns (uint256) {\\n    if (serum == 1) return 300 ether;\\n    else if (serum == 2) return 900 ether;\\n    else if (serum == 3) return 3000 ether;\\n    else revert(\\\"Query for nonexisting serum\\\");\\n  }\\n\\n  /// @notice Retrieve serum max supply.\\n  /// @param serum Serum 1, 2 or 3.\\n  function maxSuppply(uint256 serum) public pure returns (uint256) {\\n    if (serum == 1) return 4500;\\n    else if (serum == 2) return 490;\\n    else if (serum == 3) return 10;\\n    else revert(\\\"Query for nonexisting serum\\\");\\n  }\\n\\n  /* -------------------------------------------------------------------------- */\\n  /*                                 Owner Logic                                */\\n  /* -------------------------------------------------------------------------- */\\n\\n  /// @notice Set baseURI to `newBaseURI`.\\n  /// @param newBaseURI New base uri.\\n  function setBaseURI(string memory newBaseURI) external onlyOwner {\\n    baseURI = newBaseURI;\\n  }\\n\\n  /// @notice Set baseExtension to `newBaseExtension`.\\n  /// @param newBaseExtension New base uri.\\n  function setBaseExtension(string memory newBaseExtension) external onlyOwner {\\n    baseExtension = newBaseExtension;\\n  }\\n\\n  /// @notice Set utilityToken to `newUtilityToken`.\\n  /// @param newUtilityToken New utility token.\\n  function setUtilityToken(address newUtilityToken) external onlyOwner {\\n    utilityToken = IRUN(newUtilityToken);\\n  }\\n\\n  /// @notice Toggle if the contract is paused.\\n  function togglePaused() external onlyOwner {\\n    if (paused()) _unpause();\\n    else _pause();\\n  }\\n\\n  /* -------------------------------------------------------------------------- */\\n  /*                               ERC-1155 Logic                               */\\n  /* -------------------------------------------------------------------------- */\\n\\n  /// @notice Mint new tokens with `ids` at `amounts` to `to`.\\n  /// @param to Address of the recipient.\\n  /// @param ids Array of token ids.\\n  /// @param amounts Array of amounts.\\n  function mint(\\n    address to,\\n    uint256[] calldata ids,\\n    uint256[] calldata amounts\\n  ) external onlyController {\\n    _mintBatch(to, ids, amounts, \\\"\\\");\\n  }\\n\\n  /// @notice Burn tokens with `ids` at `amounts` from `from`.\\n  /// @param from Address of the owner.\\n  /// @param ids Array of token ids.\\n  /// @param amounts Array of amounts.\\n  function burn(\\n    address from,\\n    uint256[] calldata ids,\\n    uint256[] calldata amounts\\n  ) external onlyController {\\n    _burnBatch(from, ids, amounts);\\n  }\\n\\n  /// @notice See {ERC1155-uri}.\\n  function uri(uint256 id) public view override returns (string memory) {\\n    require(super.exists(id), \\\"Query for nonexisting serum\\\");\\n    return string(abi.encodePacked(baseURI, id.toString(), baseExtension));\\n  }\\n\\n  /// @notice See {ERC1155-_beforeTokenTransfer}.\\n  /// @dev Overriden to block transactions while the contract is paused (avoiding bugs).\\n  function _beforeTokenTransfer(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal override {\\n    require(!super.paused() || msg.sender == super.owner(), \\\"Pausable: paused\\\");\\n    super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n  }\\n}\\n\\ninterface IRUN {\\n  function mint(address to, uint256 amount) external;\\n\\n  function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/base/Controllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/// @title Controllable\\nabstract contract Controllable {\\n  /// @notice address => is controller.\\n  mapping(address => bool) private _isController;\\n\\n  /// @notice Require the caller to be a controller.\\n  modifier onlyController() {\\n    require(\\n      _isController[msg.sender],\\n      \\\"Controllable: Caller is not a controller\\\"\\n    );\\n    _;\\n  }\\n\\n  /// @notice Check if `addr` is a controller.\\n  function isController(address addr) public view returns (bool) {\\n    return _isController[addr];\\n  }\\n\\n  /// @notice Set the `addr` controller status to `status`.\\n  function _setController(address addr, bool status) internal {\\n    _isController[addr] = status;\\n  }\\n}\\n\"\r\n    },\r\n    \"sol-temple/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @title ERC1155\\n * @author naomsa <https://twitter.com/naomsa666>\\n * @notice A complete ERC1155 implementation including supply tracking and\\n * enumerable functions. Completely gas optimized and extensible.\\n */\\nabstract contract ERC1155 is IERC165, IERC1155, IERC1155MetadataURI {\\n  /*         _           _            */\\n  /*        ( )_        ( )_          */\\n  /*    ___ | ,_)   _ _ | ,_)   __    */\\n  /*  /',__)| |   /'_` )| |   /'__`\\\\  */\\n  /*  \\\\__, \\\\| |_ ( (_| || |_ (  ___/  */\\n  /*  (____/`\\\\__)`\\\\__,_)`\\\\__)`\\\\____)  */\\n\\n  /// @notice See {ERC1155-balanceOf}.\\n  mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n  /// @notice See {ERC1155-isApprovedForAll}.\\n  mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n  /// @notice Tracker for tokens in circulation by Id.\\n  mapping(uint256 => uint256) public totalSupply;\\n\\n  /*   _                            */\\n  /*  (_ )                _         */\\n  /*   | |    _      __  (_)   ___  */\\n  /*   | |  /'_`\\\\  /'_ `\\\\| | /'___) */\\n  /*   | | ( (_) )( (_) || |( (___  */\\n  /*  (___)`\\\\___/'`\\\\__  |(_)`\\\\____) */\\n  /*              ( )_) |           */\\n  /*               \\\\___/'           */\\n\\n  /// @notice See {ERC1155Metadata_URI-uri}.\\n  function uri(uint256) public view virtual returns (string memory);\\n\\n  /// @notice See {ERC1155-balanceOfBatch}.\\n  function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n    public\\n    view\\n    virtual\\n    returns (uint256[] memory)\\n  {\\n    require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n    uint256[] memory batchBalances = new uint256[](accounts.length);\\n    for (uint256 i = 0; i < accounts.length; i++) batchBalances[i] = balanceOf[accounts[i]][ids[i]];\\n\\n    return batchBalances;\\n  }\\n\\n  /// @notice See {ERC1155-setApprovalForAll}.\\n  function setApprovalForAll(address operator, bool approved) public virtual {\\n    _setApprovalForAll(msg.sender, operator, approved);\\n  }\\n\\n  /// @notice See {ERC1155-safeTransferFrom}.\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes memory data\\n  ) public virtual {\\n    require(from == msg.sender || isApprovedForAll[from][msg.sender], \\\"ERC1155: caller is not owner nor approved\\\");\\n    _safeTransferFrom(from, to, id, amount, data);\\n  }\\n\\n  /// @notice See {ERC1155-safeBatchTransferFrom}.\\n  function safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) public virtual {\\n    require(\\n      from == msg.sender || isApprovedForAll[from][msg.sender],\\n      \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n    );\\n    _safeBatchTransferFrom(from, to, ids, amounts, data);\\n  }\\n\\n  /// @notice Indicates whether any token exist with a given id, or not./\\n  function exists(uint256 id) public view virtual returns (bool) {\\n    return totalSupply[id] > 0;\\n  }\\n\\n  /*             _                               _    */\\n  /*   _        ( )_                            (_ )  */\\n  /*  (_)  ___  | ,_)   __   _ __   ___     _ _  | |  */\\n  /*  | |/' _ `\\\\| |   /'__`\\\\( '__)/' _ `\\\\ /'_` ) | |  */\\n  /*  | || ( ) || |_ (  ___/| |   | ( ) |( (_| | | |  */\\n  /*  (_)(_) (_)`\\\\__)`\\\\____)(_)   (_) (_)`\\\\__,_)(___) */\\n\\n  /// @notice Transfers `amount` tokens of token type `id` from `from` to `to`.\\n  function _safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes memory data\\n  ) internal virtual {\\n    require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n    _trackSupplyBeforeTransfer(from, to, _asSingletonArray(id), _asSingletonArray(amount));\\n\\n    _beforeTokenTransfer(msg.sender, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n    require(balanceOf[from][id] >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n    unchecked {\\n      balanceOf[from][id] -= amount;\\n    }\\n    balanceOf[to][id] += amount;\\n\\n    emit TransferSingle(msg.sender, from, to, id, amount);\\n    _checkOnERC1155Received(msg.sender, from, to, id, amount, data);\\n    _afterTokenTransfer(msg.sender, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n  }\\n\\n  /// @notice Safe version of the batchTransferFrom function.\\n  function _safeBatchTransferFrom(\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal virtual {\\n    require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n    require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n    _trackSupplyBeforeTransfer(from, to, ids, amounts);\\n\\n    _beforeTokenTransfer(msg.sender, from, to, ids, amounts, data);\\n\\n    for (uint256 i = 0; i < ids.length; ++i) {\\n      require(balanceOf[from][ids[i]] >= amounts[i], \\\"ERC1155: insufficient balance for transfer\\\");\\n      unchecked {\\n        balanceOf[from][ids[i]] -= amounts[i];\\n        balanceOf[to][ids[i]] += amounts[i];\\n      }\\n    }\\n\\n    emit TransferBatch(msg.sender, from, to, ids, amounts);\\n    _checkOnERC1155BatchReceived(msg.sender, from, to, ids, amounts, data);\\n    _afterTokenTransfer(msg.sender, from, to, ids, amounts, data);\\n  }\\n\\n  /// @notice Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n  function _mint(\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes memory data\\n  ) internal virtual {\\n    require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n    _trackSupplyBeforeTransfer(address(0), to, _asSingletonArray(id), _asSingletonArray(amount));\\n\\n    _beforeTokenTransfer(msg.sender, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n    balanceOf[to][id] += amount;\\n    emit TransferSingle(msg.sender, address(0), to, id, amount);\\n    _checkOnERC1155Received(msg.sender, address(0), to, id, amount, data);\\n    _afterTokenTransfer(msg.sender, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n  }\\n\\n  /// @notice Batch version of {mint}.\\n  function _mintBatch(\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal virtual {\\n    require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n    require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n    _trackSupplyBeforeTransfer(address(0), to, ids, amounts);\\n\\n    _beforeTokenTransfer(msg.sender, address(0), to, ids, amounts, data);\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      balanceOf[to][ids[i]] += amounts[i];\\n    }\\n\\n    emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n    _checkOnERC1155BatchReceived(msg.sender, address(0), to, ids, amounts, data);\\n    _afterTokenTransfer(msg.sender, address(0), to, ids, amounts, data);\\n  }\\n\\n  /// @notice Destroys `amount` tokens of token type `id` from `from`\\n  function _burn(\\n    address from,\\n    uint256 id,\\n    uint256 amount\\n  ) internal virtual {\\n    _trackSupplyBeforeTransfer(from, address(0), _asSingletonArray(id), _asSingletonArray(amount));\\n\\n    _beforeTokenTransfer(msg.sender, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n    require(balanceOf[from][id] >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n    unchecked {\\n      balanceOf[from][id] -= amount;\\n    }\\n\\n    emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    _afterTokenTransfer(msg.sender, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n  }\\n\\n  /// @notice Batch version of {burn}.\\n  function _burnBatch(\\n    address from,\\n    uint256[] memory ids,\\n    uint256[] memory amounts\\n  ) internal virtual {\\n    require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n    _trackSupplyBeforeTransfer(from, address(0), ids, amounts);\\n\\n    _beforeTokenTransfer(msg.sender, from, address(0), ids, amounts, \\\"\\\");\\n\\n    for (uint256 i = 0; i < ids.length; i++) {\\n      require(balanceOf[from][ids[i]] >= amounts[i], \\\"ERC1155: burn amount exceeds balance\\\");\\n      unchecked {\\n        balanceOf[from][ids[i]] -= amounts[i];\\n      }\\n    }\\n\\n    emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    _afterTokenTransfer(msg.sender, from, address(0), ids, amounts, \\\"\\\");\\n  }\\n\\n  /// @notice Approve `operator` to operate on all of `owner` tokens\\n  function _setApprovalForAll(\\n    address owner,\\n    address operator,\\n    bool approved\\n  ) internal virtual {\\n    require(owner != operator, \\\"ERC1155: setting approval status for self\\\");\\n    isApprovedForAll[owner][operator] = approved;\\n    emit ApprovalForAll(owner, operator, approved);\\n  }\\n\\n  /// @notice Hook that is called before any token transfer.\\n  function _beforeTokenTransfer(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal virtual {}\\n\\n  /// @notice Hook that is called after any token transfer.\\n  function _afterTokenTransfer(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) internal virtual {}\\n\\n  /// @notice Internal helper for tracking token supply before transfers.\\n  function _trackSupplyBeforeTransfer(\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts\\n  ) private {\\n    if (from == address(0)) {\\n      for (uint256 i = 0; i < ids.length; i++) {\\n        totalSupply[ids[i]] += amounts[i];\\n      }\\n    }\\n\\n    if (to == address(0)) {\\n      for (uint256 i = 0; i < ids.length; i++) {\\n        totalSupply[ids[i]] -= amounts[i];\\n      }\\n    }\\n  }\\n\\n  /// @notice ERC1155Receiver callback checking and calling helper for single transfers.\\n  function _checkOnERC1155Received(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256 id,\\n    uint256 amount,\\n    bytes memory data\\n  ) private {\\n    if (to.code.length > 0) {\\n      try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 returnValue) {\\n        require(returnValue == 0xf23a6e61, \\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n      } catch {\\n        revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n      }\\n    }\\n  }\\n\\n  /// @notice ERC1155Receiver callback checking and calling helper for batch transfers.\\n  function _checkOnERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    address to,\\n    uint256[] memory ids,\\n    uint256[] memory amounts,\\n    bytes memory data\\n  ) private {\\n    if (to.code.length > 0) {\\n      try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 returnValue) {\\n        require(returnValue == 0xbc197c81, \\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n      } catch {\\n        revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n      }\\n    }\\n  }\\n\\n  /// @notice Helper for single item arrays.\\n  function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n    uint256[] memory array = new uint256[](1);\\n    array[0] = element;\\n\\n    return array;\\n  }\\n\\n  /*    ___  _   _  _ _      __   _ __  */\\n  /*  /',__)( ) ( )( '_`\\\\  /'__`\\\\( '__) */\\n  /*  \\\\__, \\\\| (_) || (_) )(  ___/| |    */\\n  /*  (____/`\\\\___/'| ,__/'`\\\\____)(_)    */\\n  /*               | |                  */\\n  /*               (_)                  */\\n\\n  /// @notice See {ERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n    return\\n      interfaceId == type(IERC1155).interfaceId || // ERC1155\\n      interfaceId == type(IERC1155MetadataURI).interfaceId || // ERC1155MetadataURI\\n      interfaceId == type(IERC165).interfaceId; // ERC165\\n  }\\n}\\n\\ninterface IERC1155Receiver {\\n  function onERC1155Received(\\n    address operator,\\n    address from,\\n    uint256 id,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n\\n  function onERC1155BatchReceived(\\n    address operator,\\n    address from,\\n    uint256[] calldata ids,\\n    uint256[] calldata values,\\n    bytes calldata data\\n  ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 512\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"newBaseExtension\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"newUtilityToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseExtension\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serum\",\"type\":\"uint256\"}],\"name\":\"maxSuppply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"serum\",\"type\":\"uint256\"}],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseExtension\",\"type\":\"string\"}],\"name\":\"setBaseExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUtilityToken\",\"type\":\"address\"}],\"name\":\"setUtilityToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"togglePaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityToken\",\"outputs\":[{\"internalType\":\"contract IRUN\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ApeRunnersSerum", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "512", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000007a4bf1a6bcdf461cdd25473ebedc510c737ccf60000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d566f71477170555a6952487a6b4a705450456346424a4654447a614b635a3457696e3866724e416f366532562f0000000000000000000000000000000000000000000000000000000000000000000000000000000000052e6a736f6e000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}