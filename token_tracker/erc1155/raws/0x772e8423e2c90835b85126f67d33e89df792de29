{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Merkle library \r\n/// @author Modified from (https://github.com/miguelmota/merkletreejs[merkletreejs])\r\n/// License-Identifier: MIT\r\nlibrary MerkleProof {\r\n    /// @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n    /// defined by `root` - for this, a `proof` must be provided, containing\r\n    /// sibling hashes on the branch from the leaf to the root of the tree - each\r\n    /// pair of leaves and each pair of pre-images are assumed to be sorted\r\n    function verify(\r\n        bytes32[] calldata proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i; i < proof.length; ) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = _efficientHash(computedHash, proofElement);\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = _efficientHash(proofElement, computedHash);\r\n            }\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n        // check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Core SVG utility library which helps us construct\r\n/// onchain SVGs with a simple, web-like API\r\n/// @author Modified from (https://github.com/w1nt3r-eth/hot-chain-svg)\r\n/// License-Identifier: MIT\r\nlibrary SVG {\r\n    /// -----------------------------------------------------------------------\r\n    /// Constants\r\n    /// -----------------------------------------------------------------------\r\n\r\n    string internal constant NULL = '';\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Elements\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _text(string memory props, string memory children)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return _el('text', props, children);\r\n    }\r\n\r\n    function _rect(string memory props, string memory children)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return _el('rect', props, children);\r\n    }\r\n\r\n    function _image(string memory href, string memory props)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return\r\n            _el('image', string.concat(_prop('href', href), ' ', props), NULL);\r\n    }\r\n\r\n    function _cdata(string memory content)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string.concat('<![CDATA[', content, ']]>');\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Generics\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev a generic element, can be used to construct any SVG (or HTML) element\r\n    function _el(\r\n        string memory tag,\r\n        string memory props,\r\n        string memory children\r\n    ) internal pure returns (string memory) {\r\n        return\r\n            string.concat(\r\n                '<',\r\n                tag,\r\n                ' ',\r\n                props,\r\n                '>',\r\n                children,\r\n                '</',\r\n                tag,\r\n                '>'\r\n            );\r\n    }\r\n\r\n    /// @dev an SVG attribute\r\n    function _prop(string memory key, string memory val)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string.concat(key, '=', '\"', val, '\" ');\r\n    }\r\n\r\n    /// @dev converts an unsigned integer to a string\r\n    function _uint2str(uint256 i)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (i == 0) {\r\n            return '0';\r\n        }\r\n        uint256 j = i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (i != 0) {\r\n            k = k - 1;\r\n            uint8 temp = (48 + uint8(i - (i / 10) * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n/// @notice JSON utilities for base64 encoded ERC721 JSON metadata scheme\r\n/// @author Modified from (https://github.com/ColinPlatt/libSVG/blob/main/src/Utils.sol)\r\n/// License-Identifier: MIT\r\nlibrary JSON {\r\n    /// @dev Base64 encoding/decoding table \r\n    string internal constant TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n    function _formattedMetadata(\r\n        string memory name,\r\n        string memory description,\r\n        string memory svgImg\r\n    )   internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string.concat(\r\n            'data:application/json;base64,',\r\n            _encode(\r\n                bytes(\r\n                        string.concat(\r\n                            '{',\r\n                            _prop('name', name),\r\n                            _prop('description', description),\r\n                            _xmlImage(svgImg),\r\n                            '}'\r\n                        )\r\n                )\r\n            )\r\n        );\r\n    }\r\n    \r\n    function _xmlImage(string memory svgImg)\r\n        internal\r\n        pure\r\n        returns (string memory) \r\n    {\r\n        return _prop(\r\n                        'image',\r\n                        string.concat(\r\n                            'data:image/svg+xml;base64,',\r\n                            _encode(bytes(svgImg))\r\n                        ),\r\n                        true\r\n                );\r\n    }\r\n\r\n    function _prop(string memory key, string memory val)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string.concat('\"', key, '\": ', '\"', val, '\", ');\r\n    }\r\n\r\n    function _prop(string memory key, string memory val, bool last)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (last) {\r\n            return string.concat('\"', key, '\": ', '\"', val, '\"');\r\n        } else {\r\n            return string.concat('\"', key, '\": ', '\"', val, '\", ');\r\n        }\r\n        \r\n    }\r\n\r\n    function _object(string memory key, string memory val)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        return string.concat('\"', key, '\": ', '{', val, '}');\r\n    }\r\n\r\n    /// @dev converts `bytes` to `string` representation\r\n    function _encode(bytes memory data) internal pure returns (string memory) {\r\n        // Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\r\n        // https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\r\n        if (data.length == 0) return '';\r\n\r\n        // Loads the table into memory\r\n        string memory table = TABLE;\r\n\r\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\r\n        // and split into 4 numbers of 6 bits.\r\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\r\n        // - `data.length + 2`  -> Round up\r\n        // - `/ 3`              -> Number of 3-bytes chunks\r\n        // - `4 *`              -> 4 characters for each chunk\r\n        string memory result = new string(4 * ((data.length + 2) / 3));\r\n\r\n        assembly {\r\n            // Prepare the lookup table (skip the first \"length\" byte)\r\n            let tablePtr := add(table, 1)\r\n\r\n            // Prepare result pointer, jump over length\r\n            let resultPtr := add(result, 32)\r\n\r\n            // Run over the input, 3 bytes at a time\r\n            for {\r\n                let dataPtr := data\r\n                let endPtr := add(data, mload(data))\r\n            } lt(dataPtr, endPtr) {\r\n\r\n            } {\r\n                // Advance 3 bytes\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                // To write each character, shift the 3 bytes (18 bits) chunk\r\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\r\n                // and apply logical AND with 0x3F which is the number of\r\n                // the previous character in the ASCII table prior to the Base64 Table\r\n                // The result is then added to the table to get the character to write,\r\n                // and finally write it in the result pointer but with a left shift\r\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\r\n                resultPtr := add(resultPtr, 1) // Advance\r\n            }\r\n\r\n            // When data `bytes` is not exactly 3 bytes long\r\n            // it is padded with `=` characters at the end\r\n            switch mod(mload(data), 3)\r\n            case 1 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n                mstore8(sub(resultPtr, 2), 0x3d)\r\n            }\r\n            case 2 {\r\n                mstore8(sub(resultPtr, 1), 0x3d)\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\n/// License-Identifier: GPL-2.0-or-later\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        for (uint256 i; i < data.length; ) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                if (result.length < 68) revert();\r\n                    \r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                    \r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Non-transferable multi-token based on ERC-1155\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\n/// License-Identifier AGPL-3.0-only\r\nabstract contract NTERC1155 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 amount\r\n    );\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ERC1155 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             METADATA LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function uri(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC1155 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory balances)\r\n    {\r\n        require(owners.length == ids.length, \"LENGTH_MISMATCH\");\r\n\r\n        balances = new uint256[](owners.length);\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the array index counter which cannot possibly overflow.\r\n        unchecked {\r\n            for (uint256 i = 0; i < owners.length; ++i) {\r\n                balances[i] = balanceOf[owners[i]][ids[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC-165 Interface ID for ERC-165\r\n            interfaceId == 0xd9b67a26 || // ERC-165 Interface ID for ERC-1155\r\n            interfaceId == 0x0e89341c; // ERC-165 Interface ID for ERC1155MetadataURI\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\r\n                    ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        balanceOf[from][id] -= amount;\r\n\r\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC-1155 tokens\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\n/// License-Identifier AGPL-3.0-only\r\nabstract contract ERC1155TokenReceiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes calldata\r\n    ) external virtual returns (bytes4) {\r\n        return ERC1155TokenReceiver.onERC1155Received.selector;\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO access manager\r\ncontract KaliAccessManager is Multicall, NTERC1155 {\r\n    /// -----------------------------------------------------------------------\r\n    /// Library Usage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    using MerkleProof for bytes32[];\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event ListCreated(address indexed operator, uint256 id);\r\n    event MerkleRootSet(uint256 id, bytes32 merkleRoot);\r\n    event AccountListed(address indexed account, uint256 id, bool approved);\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error NotOperator();\r\n    error SignatureExpired();\r\n    error InvalidSignature();\r\n    error ListClaimed();\r\n    error NotListed();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// EIP-712 Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    uint256 private immutable INITIAL_CHAIN_ID;\r\n    bytes32 private immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// List Storage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    uint256 public listCount;\r\n\r\n    string public constant name = 'Access';\r\n    string public constant symbol = 'AXS';\r\n\r\n    mapping(uint256 => address) public operatorOf;\r\n    mapping(uint256 => bytes32) public merkleRoots;\r\n    mapping(uint256 => string) private uris;\r\n    \r\n    modifier onlyOperator(uint256 id) {\r\n        if (msg.sender != operatorOf[id]) revert NotOperator();\r\n        _;\r\n    }\r\n\r\n    struct Listing {\r\n        address account;\r\n        bool approval;\r\n    }\r\n\r\n    function uri(uint256 id) public view override returns (string memory) {\r\n        if (bytes(uris[id]).length == 0) {\r\n            return _buildURI(id);\r\n        } else {\r\n            return uris[id];\r\n        }\r\n    }\r\n    \r\n    function _buildURI(uint256 id) private pure returns (string memory) {\r\n        return\r\n            JSON._formattedMetadata(\r\n                string.concat('Access #', SVG._uint2str(id)), \r\n                'Kali Access Manager', \r\n                string.concat(\r\n                '<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"300\" height=\"300\" style=\"background:#191919\">',\r\n                SVG._text(\r\n                    string.concat(\r\n                        SVG._prop('x', '20'),\r\n                        SVG._prop('y', '40'),\r\n                        SVG._prop('font-size', '22'),\r\n                        SVG._prop('fill', 'white')\r\n                    ),\r\n                    string.concat(\r\n                        SVG._cdata('Access List #'),\r\n                        SVG._uint2str(id)\r\n                    )\r\n                ),\r\n                SVG._rect(\r\n                    string.concat(\r\n                        SVG._prop('fill', 'maroon'),\r\n                        SVG._prop('x', '20'),\r\n                        SVG._prop('y', '50'),\r\n                        SVG._prop('width', SVG._uint2str(160)),\r\n                        SVG._prop('height', SVG._uint2str(10))\r\n                    ),\r\n                    SVG.NULL\r\n                ),\r\n                SVG._text(\r\n                    string.concat(\r\n                        SVG._prop('x', '20'),\r\n                        SVG._prop('y', '90'),\r\n                        SVG._prop('font-size', '12'),\r\n                        SVG._prop('fill', 'white')\r\n                    ),\r\n                    string.concat(\r\n                        SVG._cdata('The holder of this token can enjoy')\r\n                    )\r\n                ),\r\n                SVG._text(\r\n                    string.concat(\r\n                        SVG._prop('x', '20'),\r\n                        SVG._prop('y', '110'),\r\n                        SVG._prop('font-size', '12'),\r\n                        SVG._prop('fill', 'white')\r\n                    ),\r\n                    string.concat(SVG._cdata('access to restricted functions.'))\r\n                ),\r\n                SVG._image(\r\n                    'https://gateway.pinata.cloud/ipfs/Qmb2AWDjE8GNUob83FnZfuXLj9kSs2uvU9xnoCbmXhH7A1', \r\n                    string.concat(\r\n                        SVG._prop('x', '215'),\r\n                        SVG._prop('y', '220'),\r\n                        SVG._prop('width', '80')\r\n                    )\r\n                ),\r\n                '</svg>'\r\n            )\r\n        );\r\n    }\r\n        \r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor() {\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = _computeDomainSeparator();\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// EIP-712 Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : _computeDomainSeparator();\r\n    }\r\n\r\n    function _computeDomainSeparator() private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                    keccak256(bytes('KaliAccessManager')),\r\n                    keccak256('1'),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// List Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function createList(\r\n        address[] calldata accounts, \r\n        bytes32 merkleRoot, \r\n        string calldata metadata\r\n    ) external payable returns (uint256 id) {\r\n        // cannot realistically overflow on human timescales\r\n        unchecked {\r\n            id = ++listCount;\r\n        }\r\n\r\n        operatorOf[id] = msg.sender;\r\n\r\n        if (accounts.length != 0) {\r\n            for (uint256 i; i < accounts.length; ) {\r\n                _listAccount(accounts[i], id, true);\r\n                // cannot realistically overflow on human timescales\r\n                unchecked {\r\n                    ++i;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (merkleRoot != 0) {\r\n            merkleRoots[id] = merkleRoot;\r\n            emit MerkleRootSet(id, merkleRoot);\r\n        }\r\n        \r\n        if (bytes(metadata).length != 0) {\r\n            uris[id] = metadata;\r\n            emit URI(metadata, id);\r\n        }\r\n        \r\n        emit ListCreated(msg.sender, id);\r\n    }\r\n\r\n    function listAccounts(uint256 id, Listing[] calldata listings) external payable onlyOperator(id) {\r\n        for (uint256 i; i < listings.length; ) {\r\n            _listAccount(listings[i].account, id, listings[i].approval);\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function listAccountBySig(\r\n        address account,\r\n        uint256 id,\r\n        bool approved,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external payable {\r\n        if (block.timestamp > deadline) revert SignatureExpired();\r\n\r\n        address recoveredAddress = ecrecover(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    '\\x19\\x01',\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(\r\n                        abi.encode(\r\n                            keccak256(\r\n                                'List(address account,uint256 id,bool approved,uint256 deadline)'\r\n                            ),\r\n                            account,\r\n                            id,\r\n                            approved,\r\n                            deadline\r\n                        )\r\n                    )\r\n                )\r\n            ),\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n\r\n        if (recoveredAddress == address(0) || recoveredAddress != operatorOf[id]) revert InvalidSignature();\r\n\r\n        _listAccount(account, id, approved);\r\n    }\r\n\r\n    function _listAccount(\r\n        address account,\r\n        uint256 id,\r\n        bool approved\r\n    ) private {\r\n        approved ? _mint(account, id, 1, '') : _burn(account, id, 1);\r\n        emit AccountListed(account, id, approved);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Merkle Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function setMerkleRoot(uint256 id, bytes32 merkleRoot) external payable onlyOperator(id) {\r\n        merkleRoots[id] = merkleRoot;\r\n        emit MerkleRootSet(id, merkleRoot);\r\n    }\r\n\r\n    function claimList(\r\n        address account,\r\n        uint256 id,\r\n        bytes32[] calldata merkleProof\r\n    ) external payable {\r\n        if (balanceOf[account][id] != 0) revert ListClaimed();\r\n        if (!merkleProof.verify(merkleRoots[id], keccak256(abi.encodePacked(account)))) revert NotListed();\r\n\r\n        _listAccount(account, id, true);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// URI Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function setURI(uint256 id, string calldata metadata) external payable onlyOperator(id) {\r\n        uris[id] = metadata;\r\n        emit URI(metadata, id);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"AccountListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ListCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"MerkleRootSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claimList\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"createList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"listAccountBySig\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approval\",\"type\":\"bool\"}],\"internalType\":\"struct KaliAccessManager.Listing[]\",\"name\":\"listings\",\"type\":\"tuple[]\"}],\"name\":\"listAccounts\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"listCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"merkleRoots\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operatorOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"}],\"name\":\"setURI\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "KaliAccessManager", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0a0a5299f59871985f417656fdeba4dee65dd2127b81e41e47ce33c105040147"}]}