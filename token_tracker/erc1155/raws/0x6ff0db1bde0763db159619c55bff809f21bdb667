{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ElyGenesisCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: APGL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Ownable} from \\\"./Ownable.sol\\\";\\nimport {ERC1155} from \\\"./solmate/tokens/ERC1155.sol\\\";\\n\\n/// @title ElyGenesisCollection\\n/// @notice Minting contract for Ely's Genesis Collection (https://twitter.com/ratkingnft).\\n/// @author 0xMetas (https://twitter.com/0xMetas)\\ncontract ElyGenesisCollection is ERC1155, Ownable {\\n    //////////////////////\\n    /// External State ///\\n    //////////////////////\\n\\n    /// @notice The name of the contract.\\n    /// @dev EIP-1155 doesn't define `name()` so that the metadata JSON returned by `uri` is\\n    /// the definitive name, but it's provided for compatibility with existing front-ends.\\n    string public constant name = \\\"Ely Genesis Collection\\\"; // solhint-disable-line const-name-snakecase\\n\\n    /// @notice The symbol of the contract.\\n    /// @dev EIP-1155 doesn't define `symbol()` because it isn't a \\\"globally useful piece of\\n    /// data\\\", but, again, it's provided for compatibility with existing front-ends.\\n    string public constant symbol = \\\"ELYGENESIS\\\"; // solhint-disable-line const-name-snakecase\\n\\n    /// @notice The price of each token.\\n    uint256 public constant PRICE = 0.05 ether;\\n\\n    /// @notice The maximum supply of all tokens.\\n    uint256 public constant MAX_SUPPLY = 500;\\n\\n    /// @notice The maximum supply of each token.\\n    uint256 public constant MAX_SUPPLY_PER_ID = 100;\\n\\n    /// @notice True if the metadata (URI) can no longer be modified.\\n    bool public metadataFrozen = false;\\n\\n    /// @notice The maximum number of tokens you can purchase in a single transaction.\\n    uint256 public transactionLimit = 3;\\n\\n    /// @notice True if the sale is open.\\n    bool public purchaseable = false;\\n\\n    /// @notice The total supply of all tokens.\\n    /// @dev EIP-1155 requires enumeration off-chain, but the contract provides `totalSupplyAll`\\n    /// for convenience, and compatibility with marketplaces and other front-ends.\\n    uint256 public totalSupplyAll = 0;\\n\\n    /// @notice The total supply of an individual token.\\n    /// @dev See `totalSupplyAll`.\\n    uint8[5] public totalSupply;\\n\\n    //////////////////////\\n    /// Internal State ///\\n    //////////////////////\\n\\n    /// @dev The ids available to mint. This array is used when generating a random index for the mint.\\n    /// Ids are removed from this array when their max amount has been minted.\\n    uint8[] private availableIds = [0, 1, 2, 3, 4];\\n\\n    /// @dev The 'dynamic' length of the `availableIds` array. Since it's a static array, it's actual\\n    /// length cannot be modified, so this variable is used instead.\\n    uint8 private availableIdsLength = 5;\\n\\n    /// @dev The base of the generated URI returned by `uri(uint256)`.\\n    string private baseUri;\\n\\n    //////////////\\n    /// Errors ///\\n    //////////////\\n\\n    error WithdrawFail();\\n    error FrozenMetadata();\\n    error NotPurchaseable();\\n    error SoldOut();\\n    error InsufficientValue();\\n    error InvalidPurchaseAmount();\\n    error ExternalAccountOnly();\\n\\n    //////////////\\n    /// Events ///\\n    //////////////\\n\\n    event PermanentURI(string uri, uint256 indexed id);\\n    event Purchaseable(bool state);\\n    event TransactionLimit(uint256 previousLimit, uint256 newLimit);\\n\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() {}\\n\\n    /// @notice Purchase `amount` number of tokens.\\n    /// @param amount The number of tokens to purchase.\\n    function purchase(uint256 amount) public payable {\\n        if (!purchaseable) revert NotPurchaseable();\\n        if (amount + totalSupplyAll > MAX_SUPPLY) revert SoldOut();\\n        if (msg.value != amount * PRICE) revert InsufficientValue();\\n        if (msg.sender.code.length != 0) revert ExternalAccountOnly();\\n        if (amount > transactionLimit || amount < 1)\\n            revert InvalidPurchaseAmount();\\n\\n        for (uint256 i; i < amount; ) {\\n            uint256 idx = getPseudorandom() % availableIdsLength;\\n            uint256 id = availableIds[idx];\\n\\n            _mint(msg.sender, id, 1, \\\"\\\");\\n\\n            // `totalSupplyAll` needs to be incremented in the loop to provide a unique nonce for\\n            // each call to `getPseudorandom()`.\\n            unchecked {\\n                ++i;\\n                ++totalSupplyAll;\\n                ++totalSupply[id];\\n            }\\n\\n            // Remove the token from `availableIds` if it's reached the supply limit\\n            if (totalSupply[id] == MAX_SUPPLY_PER_ID) removeIndex(idx);\\n        }\\n    }\\n\\n    /// @notice Returns a deterministically generated URI for the given token ID.\\n    /// @return string\\n    function uri(uint256 id) public view override returns (string memory) {\\n        return\\n            bytes(baseUri).length > 0\\n                ? string(abi.encodePacked(baseUri, toString(id), \\\".json\\\"))\\n                : \\\"\\\";\\n    }\\n\\n    //////////////////////\\n    /// Administration ///\\n    //////////////////////\\n\\n    /// @notice Prevents any future changes to the URI of any token ID.\\n    /// @dev Emits a `PermanentURI(string, uint256 indexed)` event for each token ID with the permanent URI.\\n    function freezeMetadata() public onlyOwner {\\n        metadataFrozen = true;\\n        for (uint256 i = 0; i < 5; ++i) {\\n            emit PermanentURI(uri(i), i);\\n        }\\n    }\\n\\n    /// @notice Updates the base of the generated URI returned by `uri(uint256)`.\\n    /// @dev The URI event isn't emitted because there is no applicable ID to emit the event for. The\\n    /// baseURI given here applies to all token IDs.\\n    function setBaseUri(string memory newBaseUri) public onlyOwner {\\n        if (metadataFrozen == true) revert FrozenMetadata();\\n        baseUri = newBaseUri;\\n    }\\n\\n    /// @notice Sets the current state of the sale. `false` will disable sale, `true` will enable it.\\n    function setPurchaseable(bool state) public onlyOwner {\\n        purchaseable = state;\\n        emit Purchaseable(purchaseable);\\n    }\\n\\n    /// @notice Withdraws entire balance of this contract to the `owner` address.\\n    function withdrawEth() public onlyOwner {\\n        (bool success, ) = owner.call{value: address(this).balance}(\\\"\\\");\\n        if (!success) revert WithdrawFail();\\n    }\\n\\n    /// @notice Sets the maximum purchase amount per transaction.\\n    function setTransactionLimit(uint256 newTransactionLimit) public onlyOwner {\\n        emit TransactionLimit(transactionLimit, newTransactionLimit);\\n        transactionLimit = newTransactionLimit;\\n    }\\n\\n    ////////////////\\n    /// Internal ///\\n    ////////////////\\n\\n    /// @dev Generates a pseudorandom number to use when determining an ID for purchase. True randomness isn't\\n    /// necessary because IDs have no rarity (no ID is inherently more valuable than another).\\n    function getPseudorandom() internal view returns (uint256) {\\n        // solhint-disable not-rely-on-time\\n        unchecked {\\n            return\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            block.timestamp,\\n                            msg.sender,\\n                            totalSupplyAll\\n                        )\\n                    )\\n                );\\n        }\\n        // solhint-enable not-rely-on-time\\n    }\\n\\n    /// @dev Removes the specified index from the `availableIds` array. This function is used when the max supply\\n    /// of the token ID at `index` has already been purchased. The index isn't checked because useage is internal.\\n    function removeIndex(uint256 index) internal {\\n        availableIds[index] = availableIds[availableIdsLength - 1];\\n        availableIdsLength--;\\n    }\\n\\n    /// @dev Taken from OpenZeppelin's implementation\\n    /// (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol)\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/solmate/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 ownersLength = owners.length; // Saves MLOADs.\\n\\n        require(ownersLength == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < ownersLength; i++) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.0;\\n\\n/// @title Ownable\\n/// @notice Provides a modifier to authenticate contract owner.\\n/// @dev The default owner is the contract deployer, but this can be modified\\n/// afterwards using `transferOwnership`. There is no check when transferring\\n/// ownership so ensure you don't use `address(0)` unintentionally. The modifier\\n/// to guard functions with is `onlyOwner`.\\n/// @author 0xMetas\\n/// @author Based on OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol)\\nabstract contract Ownable {\\n    /// @notice This emits when the owner changes.\\n    /// @param previousOwner The address of the previous owner.\\n    /// @param newOwner The address of the new owner.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @dev Error thrown when `onlyOwner` is called by an address other than `owner`.\\n    error NotOwner();\\n\\n    /// @notice The address of the owner.\\n    address public owner;\\n\\n    /// @dev Sets the value of `owner` to `msg.sender`.\\n    constructor() {\\n        owner = msg.sender;\\n    }\\n\\n    /// @dev Reverts if `msg.sender` is not `owner`.\\n    modifier onlyOwner() {\\n        if (msg.sender != owner) revert NotOwner();\\n        _;\\n    }\\n\\n    /// @notice Sets the `owner` address to a new one.\\n    /// @dev Use `address(0)` to renounce ownership.\\n    /// @param newOwner The address of the new owner of the contract.\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        emit OwnershipTransferred(owner, newOwner);\\n        owner = newOwner;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ExternalAccountOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FrozenMetadata\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPurchaseAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPurchaseable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SoldOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WithdrawFail\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"PermanentURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"Purchaseable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"TransactionLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY_PER_ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"freezeMetadata\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metadataFrozen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchaseable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseUri\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"setPurchaseable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTransactionLimit\",\"type\":\"uint256\"}],\"name\":\"setTransactionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transactionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ElyGenesisCollection", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}