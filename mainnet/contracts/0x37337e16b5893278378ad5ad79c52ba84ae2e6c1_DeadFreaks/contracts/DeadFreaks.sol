// SPDX-License-Identifier: MIT
pragma solidity ^0.8.11;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/interfaces/IERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC721.sol";
import "@openzeppelin/contracts/interfaces/IERC1155.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "./NonblockingReceiver.sol";

/*

                                                      .*-
            .-:                                        @@#
           .@@#                                        @@@%.
           %%%*                                        #@*@%.
          *@:@+                                        +@:*@@-
         +@--@-                                        -@= #@@-
        =@* *@:                                        :@#  %@@-
       -@@  %@.                                        .@@  .@@@.
      .@@- .@@.                                         @@:- =@@%
      #@#  +@@.       Dead Freaks Resurrection          @@+%  #@@=
     -@@:  %@@.                                         @@*@  .@@%
     @@#   @@@.                                         @@*@   *@@:
    =@@:   @@@.                                        .@@*%   :@@#
    @@%    @@@-       +=                ..      .+-    -@###    %@@:
   =@@=    @@@=     .%@@       #@:     *@#     =@@@:   +@+@=    +@@*
   %@@     @#@%     %@+@:     %@#%    *@*@    *@*:@#   #@=@:    .@@%
  .@@*     *#@@    +@--@+   .%@=:@=  +@+.@+  *@#  %@+  @@=@      @@@
  *@@=     .@#@-  :@* :@*  .%@*  #@..@@  #@.:@@   -@@..@%**      #@@
  %@@:      %#@% .@@   @%  %@%   -@+*@*  -@##@+    %@#+@+%.      *@@.
  @@@:      :=@@:%@=   *@-+@@.    @@@@.   %@@@.    .@@@@.-       +@@-
  @@@.        +@@@#    :@%@@+     *@@*    .*%-      :@@=         :@@=
 :@@@:         *@#      +@@*       +*                             #@+
 -@*@=                   ::                                       :@+
 .+ *=                                                             #=


 Contract by loltapes.eth

*/
contract DeadFreaks is ERC721, ERC2981, Ownable, ReentrancyGuard, NonblockingReceiver {
  using Strings for uint256;

  // @dev Provenance hash for provably fair reveal. See our website for more info
  string public constant PROVENANCE_HASH = "e494bf6bedaf8ae78c09e94c414e115d5b73843ec253771bef8e461b738a12c8";

  // @dev Generated by contract at RANDOMIZER_ADDRESS_BSC and manually set
  uint256 public OFFSET_VALUE;

  // @notice Address of the randomizer contract on Binance Smart Chain for offset and legendaries
  // @dev Using BSC for cheap VRF from Chainlink
  string public constant RANDOMIZER_ADDRESS_BSC = "0xccaD0A7929AdB6987f84275FfCe3ED151A54Df7C";

  string public baseUri;
  string public placeholderUri;

  uint256 public immutable CHAIN_SUPPLY;
  uint256 public immutable CHAIN_OFFSET;
  uint256 currentTokenId;

  uint256 public gasForDestinationLzReceive = 350000;

  uint256 public mintActiveFrom;

  uint256 public remainingTeamSupply;

  mapping(address => bool) public walletMinted;

  /* @dev Allow to freeze metadata, disallowing any further updates for the base uri */
  bool public metadataFrozen;

  bool public isRevealing;
  bool public revealed;

  modifier whenMetadataNotFrozen {
    require(!metadataFrozen, "Metadata is frozen");
    _;
  }

  modifier whenNotContract {
    require(msg.sender == tx.origin, "No-No to Mojo Jojo's mojo");
    _;
  }

  constructor(
    uint256 supply,
    uint256 offset,
    uint256 teamSupply,
    string memory _placeholderUri,
    address _layerZeroEndpoint,
    address royaltyReceiver
  ) ERC721("Dead Freaks Resurrection", "DFR") {
    CHAIN_SUPPLY = supply;
    CHAIN_OFFSET = offset;
    currentTokenId = CHAIN_OFFSET;

    remainingTeamSupply = teamSupply;

    placeholderUri = _placeholderUri;

    // default royalties
    _setDefaultRoyalty(royaltyReceiver, 1000);

    // multichain via NonblockingReceiver.sol
    endpoint = ILayerZeroEndpoint(_layerZeroEndpoint);
  }

  function _baseURI() internal view virtual override returns (string memory) {
    return baseUri;
  }

  function tokenURI(uint256 tokenId) public view override returns (string memory) {
    // one uri for all placeholders before reveal
    if (!revealed) {
      require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
      return placeholderUri;
    } else {
      return super.tokenURI(tokenId);
    }
  }

  function mintActive() external view returns (bool) {
    return mintActiveFrom > 0 && block.timestamp >= mintActiveFrom;
  }

  /*
   * @notice Mint. While minting is free we do accept donations :)
   */
  function mint(uint256 amount)
  external
  payable
  whenNotContract
  nonReentrant
  {
    require(mintActiveFrom > 0 && block.timestamp >= mintActiveFrom, "Mint inactive");
    require(amount > 0, "Mint at least 1");
    require(amount < 4, "Max 3 per tx");
    require(!walletMinted[msg.sender], "Max 1 mint per wallet");
    require(currentTokenId + amount <= CHAIN_OFFSET + CHAIN_SUPPLY, "Over supply on this chain");

    for (uint i = 0; i < amount; i++) {
      _safeMint(msg.sender, ++currentTokenId);
    }

    walletMinted[msg.sender] = true;
  }

  function mintTeam(uint256 amount) external onlyOwner {
    require(amount > 0, "Mint at least 1");
    require(amount <= remainingTeamSupply, "Over team supply");
    require(currentTokenId + amount <= CHAIN_OFFSET + CHAIN_SUPPLY, "Over supply on this chain");

    for (uint i = 0; i < amount; i++) {
      _safeMint(msg.sender, ++currentTokenId);
    }
    remainingTeamSupply -= amount;
  }

  function setMintActiveFrom(uint256 startTimestamp) external onlyOwner {
    mintActiveFrom = startTimestamp;
  }

  // @dev Separate from `reveal` to lock contracts on all chains before leaking the metadata uri
  function prepareReveal() external onlyOwner {
    //    require(nextTokenId == CHAIN_OFFSET + CHAIN_SUPPLY, "Can only reveal after mint is complete");
    require(!isRevealing && !revealed, "Already revealed");
    isRevealing = true;
  }

  // @dev Avoid rare snipes while metadata is up but marketplaces have not indexed everything.
  //  Checked in _beforeTokenTransfer and traverseChains
  function reveal(string calldata uri, uint256 offset) external whenMetadataNotFrozen onlyOwner {
    require(isRevealing, "Call prepareReveal first");
    require(bytes(uri).length > 0, "Reveal needs to set base uri");
    require(offset > 0, "Reveal needs to set non zero offset");
    require(!revealed, "Already revealed");

    baseUri = uri;
    OFFSET_VALUE = offset;
  }

  // @dev Separated from `reveal` to reveal on each chain and unlock after marketplaces are updated
  function finishReveal() external onlyOwner {
    require(!revealed, "Already revealed");
    require(isRevealing, "Call prepareReveal first");

    isRevealing = false;
    revealed = true;
  }

  function freezeMetadata() external whenMetadataNotFrozen onlyOwner {
    require(bytes(baseUri).length > 0, "Need something to freeze");
    require(revealed, "Must be revealed before the freeze");
    metadataFrozen = true;
  }

  // @dev Emergency for metadata fixes
  function setBaseUri(string calldata uri) external whenMetadataNotFrozen onlyOwner {
    baseUri = uri;
  }

  // @dev Emergency for metadata fixes
  function setPlaceholderUri(string calldata uri) external whenMetadataNotFrozen onlyOwner {
    placeholderUri = uri;
  }

  function withdraw() external onlyOwner {
    require(payable(owner()).send(address(this).balance));
  }

  // @notice Set token royalties
  // @param value points (using 2 decimals - 10_000 = 100%, 100 = 1%)
  function setRoyalties(address receiver, uint96 value) external onlyOwner {
    _setDefaultRoyalty(receiver, value);
  }

  // @dev allow to retrieve ERC20 tokens (wrongfully) sent to the contract
  function withdrawERC20(IERC20 token, address toAddress, uint256 amount) external onlyOwner {
    token.transfer(toAddress, amount);
  }

  // @dev allow to retrieve ERC721 tokens (wrongfully) sent to the contract
  function withdrawERC721(IERC721 token, address toAddress, uint256 tokenId) external onlyOwner {
    token.transferFrom(address(this), toAddress, tokenId);
  }

  // @dev allow to retrieve ERC1155 tokens (wrongfully) sent to the contract
  function withdrawERC1155(IERC1155 token, address toAddress, uint256 tokenId) external onlyOwner {
    token.safeTransferFrom(address(this), toAddress, tokenId, token.balanceOf(address(this), tokenId), "");
  }

  function _beforeTokenTransfer(
    address from,
    address to,
    uint256 tokenId
  ) internal override {
    require(!isRevealing, "Transfers paused during reveal");
  }

  // OMNI

  // @notice Transfers the nft from your address on the source chain to the same address on the destination chain
  function traverseChains(uint16 _chainId, uint tokenId) public payable {
    // Avoid rare snipes while metadata is up but marketplaces have not indexed everything
    require(!isRevealing, "Traversals paused during reveal");
    require(msg.sender == ownerOf(tokenId), "You must own the token");
    require(trustedRemoteLookup[_chainId].length > 0, "This chain is unavailable");

    // burn NFT, eliminating it from circulation on src chain
    _burn(tokenId);

    // encode the payload with the values to send
    bytes memory payload = abi.encode(msg.sender, tokenId);

    // encode adapterParams to specify more gas for the destination
    uint16 version = 1;
    bytes memory adapterParams = abi.encodePacked(version, gasForDestinationLzReceive);

    // get the fees we need to pay to LayerZero + Relayer to cover message delivery
    // you will be refunded for extra gas paid
    (uint messageFee,) = endpoint.estimateFees(_chainId, address(this), payload, false, adapterParams);

    require(msg.value >= messageFee, "send value not enough to cover messageFee. Send gas for message fees");

    endpoint.send{value : msg.value}(
      _chainId, // destination chainId
      trustedRemoteLookup[_chainId], // destination address of nft contract
      payload, // encoded payload
      payable(msg.sender), // refund address
      address(0x0), // 'zroPaymentAddress'; unused
      adapterParams                       // txParameters
    );
  }

  // @dev Called when receiving a token from a trusted contract. See NonblockingReceiver.sol
  function _LzReceive(
    uint16 _srcChainId,
    bytes memory _srcAddress,
    uint64 _nonce,
    bytes memory _payload
  ) internal override {
    (address toAddr, uint tokenId) = abi.decode(_payload, (address, uint));
    // mint the tokens back into existence
    _safeMint(toAddr, tokenId);
  }

  // just in case this fixed variable limits us from future integrations
  function setGasForDestinationLzReceive(uint256 gas) external onlyOwner {
    gasForDestinationLzReceive = gas;
  }

  function supportsInterface(bytes4 interfaceId)
  public
  view
  virtual
  override(ERC721, ERC2981)
  returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }
}
