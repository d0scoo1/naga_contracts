// SPDX-License-Identifier: MIT

/**
ccloool:::cc::::cc:::::cccccloooooool;;loddc...............,:'....''...,cc...''...,ll.................';:;,',,'',,;,';:;;:lll::clc;;;;;
ccccllc:::cc:::::::::::c:clccllloolllooooodo,.............,loc'.......:dkkl,;odooodxxl:;;'..............',...........''.';ccc:;:c;....'
::::::::::cc::::::;;:::cclllcccloooollloooddl:,,;:,...';clooddo,.....,lxkkxxxkkkxxxxxddxxdoc,.':cllc;'.....''.''..........,,,'.''......
::::::;;:;::;;;;;;;::::ccclllccllllllloooooooooooool:clddddddddo:..';ldxkkxxxxxxxxxxdxxdddxxdodxxxxxxxo:,'cdddxxdolldl::,.........;clc'
:;;;;;:;:;:;;;;:::;;:::::cclccllccllllddolodoooooddododddodoodxddoodddoxkxxxxxxxdxxddxxdooddoddxkxxkkkkkxdkOxxkOOkkOOkkko:,'';c:';dkOkd
;,,,;;;;::;;,,;;::;,;:;;::cccccccllllllolooooooooooooollooloooodddoooddxkxddxxddddxddxxoodddddddxxxkkkkkkxkkxkkkkkkxkOkxkOOxxkkkxxkkOOO
,,,,;;,;;;,,,,;;;;;,;;;;;::::ccclollccclloollllloolllllcccclooodoodddddddxdodddddddddddddddddooodddxkxkOkxkxxkOkkkxxkkOkkkOOOkkOOkxkkkO
',,,,,',,,,,,,,,,'',,,,',,;::ccccccclcccloollolllolllcclccllccloooddddoodxddxddxdoooododdoloolodxdddxxxkkkxxkkOkkkkkkxxdxkkkOOkkOkxkkxk
'',,,'''''''''''....'''''',;::::::cc:c::clc:clllllllllcccc:ccclloodxdoodooooddddoooooooooollooooodxxxkxkkxkxkkkkkkxxkxxdxkkkkxxkkkxkOkx
'''''..'''...''........''..',,,,;:c:;;;;:c::cccccclllcccc::::cclllodooloolloddooolllloololcclollddddxkxddkkxxkkkxxxxkkkkxxkkxxdkOkkxxkO
.............................''',,,,,,,;::::::cc::::ccc::;;;;;::clccccllollllooollccccllccccclllooooodxddxxxxkxxxxxxxkkkkxxxdxxxkkxxxxx
.......................................',,;:;;;:;;;;;:;;,,,,,,;;:cc:::cllc:cccllcccc:;:c::::ccccllooodddddkkxxxxddxxxxxxxxxddxxxxkkxxxx
..........................................''',,,,;;,,,''......'',;;,,,;:::;:::cc::::;:::;;;;;;;:ccllooolododddxdddxxxddxddxxxdodxxxxxdd
..................'',,..,;;...................''.''''.................'',;;;;:::;,,,,,,'''..',,;:cccllloooloddxoodxkxddodddxxoodxddddoo
...............',;;;;coxxxkxolllc:,........';coddol:'.............:lllll;'''',,,..;coddddol:,...,;:oxkxxolloodddkOO0kdoooodddoooddoddoo
.....',,;,',,,,,,;;;,:OXXXXXXXXXXXKOd:;;,:dOKXXXXXXXOl'....,,;:;;xKXXXN0;......;lk0XXXXXXXXX0xc...,kXXXklllclold0XXKklllllooolloooooooo
'',,,,,,,,,,',,,,,,,'l0XXKkddxxxOKXXXx:;;lkKOxdllxKXXKd;;;;:::lkKXXXXXX0c..'',o0XXXKkdddoxOKXXO:..,OXXKo,;;:clcdKXX0dccc::ccccccclllccl
''',,'',,,,''''''''''oXXXk:,,,;,:OXXXx;,;,;c;,,,,c0XXXd,',;,;d0XX0KXXXXkc:::oOXXX0xl:::;;:coxoc:;'lKXXO,..'.',;xXXXOc,,''',,;,,;:cc:::c
'''''''''''''''''''.,xXXXOdoooddOKXKk:'',,'':oddx0XXKx;''',lkKXKdo0NXXKo::::xXXX0o;;::;;;:::;::::cOXXX0dlllllooOXXKo'...........,;;;,,;
'...'...''....'.....;OXXXXXXXXXXXXXx;...''.'oXNXXXXKo,''.;dKXKxc,lKXXX0c,;,cOXXXd;,,;;;,;;,;;;;::l0XXXXXXXXXXXXXXX0c',;clc:;,;;........
....................cKXX0ollllodOXXKo'......:oooxKXX0c..cOXXXOolokXXXX0ol;.:OXXXd''',,,,,''',,,,,l0XXKOkkxkxxk0XXX0lclllccclloo:,'..,,'
....................dXXXd'......oKXXk'...'.......dXXXx.'kNXXXXXXXXXXXXXNK:.'dXXX0c'..''''';l:,'',dKXXOl:::::clkXXXkc::cc::::ccc:c:;;;;,
...................'kXXXkcccclld0XXKo..;d0kl:;;:o0XXKl..clllllllxKXXXKdlc...'xXXXKxlc::clx0X0o'.,xXXXx;,,;;;:l0XXKd::::::;;::c:;;;,''..
...................;0NXXXXXXXXXXXKkc...l0XXXXKKXXXKOc...........cKXXXO;.......ckKXXXXXXXXXX0d:..;OXXKc....',;oKXX0c,'''',',;;;;'.......
...................,ooooooooooolc,...',,:lx000KKKOd;...,:;......:k000Oxooc;;;:clllodxxxdol:'....'lddl'......':oodc'.........'.........,
.................................':codxxooddxkxxkxxocodxkkxdoooccododdxxddxkxxkxoc;;;,..''',;'...........'...........'...........';coox
................................,cxxxkxdxxdodxddodxddxkxdxkxdddoooooddodddxxdxkxoodddollddooddo:'.,cl:::ll:'..':lc::lollccc,'..'cdxdxxx
....................;c:;;col:;:llooxkxxdodxdoodxdolodxxoloddkdlooodxdodxxddddddxdododdoooooooddollooddoolllc:clodxdooodxddxxdlooxxddkOk
::;;;;:;'...';;cc:cloodoodooolllllloxxdllddoxdoddooooddoddooddddolldooddloollllooloooooddoloolodolloooodoooolooloooolodxxdodooooxxoodxo
dlclocldolllccclooolloolol:cooolccclllollodooooollooccloollodddoloolllolldlcllooooodocclooloolllllollloxolollccoollooolodloollllddlcodl
:lccllolcoool::cclllllc:ccccllcc::lccldollccc:lolcllcllol:cclooollllloolllccldllllll::cc:ccloodolcccccloccc:ccccoolllooooodoloccddlcddo
cccccc::c:cllc:::c::cccclclc:cc;;:::::cccc:;::cllccc:clllc:lcccclclllool::ccclc:ll::cccc:::ccccccc:::lllccc:::cclccllcccloollcc:looooll
c:,,,,;;:;;;::;;,,;;:::::::;,,;,;:;;;::::cc::;,;:cc::cllcc:clol::;:cccllc:;:cc:;:;;cl:;;;;;;;;,;c:;;;:clc;;::::;;;;:cccccll:clc:ldolc;:
,,,,,,,,'',,,,,,;:;,,,,',,,,,,;,,,''',,,,,'',,,,,;:;;:::;:;;cc::;;::::::;,,,',;,,',;:;,''',,,,,;,'',,',,,,,,,;,,,,,;;;:;:clc:c:cddc:ccc
..'...........''''''....''...''..............'..'''''';:;,,',,',,,,,;:,,,'''..'...''.....''...''..'''''.........'..',;;,,,,,:;,:ol;;;;,
...........................................................''''''''..'..'.'...........................................'.','''..;dc,'''.
,;;;;;;;;,,,''''.......'',,;;::cccccccccccc::;;,'..............................',;;::cccc::;;,,'''''',,;;:::cc:;,'.............lx:'....
0KK0KKKK0000OOOOOkOOOOOO0000KKKKKKKKKKKKKKKKKKKK0Okdolc:;;,'''''',,,,;::clodxkO00KKKKKKKXKKKKK00000000KKKKKKKKKKKOkdl:,.......cOx,....;
KKKKKKKK00KKK0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KKKKK00K00000000KK0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0Oxddddk0Ko..:ok0
KKKKKKKKKKKKKKK00KKKKKKKKKKKK0KKKKKKKKK0KKKKKKKKKKK0KKK00KKKKK00KKKKKK00KKKKKKKKKKKKKKKKKKKK00KKKKKKKKKK00KKKKKKKKKKKKKKKKKKK0KKl'oKK00
*/

pragma solidity ^0.8.4;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Royalty.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

import "@openzeppelin/contracts/interfaces/IERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC721.sol";

import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

import "./BeachLibrary.sol";

interface IERC20Burnable {
  function burnFrom(address account, uint256 amount) external;
}

interface ISeafood {
  function decimals() external view returns (uint8);
}

contract Beach is ERC721Enumerable, ERC721Royalty, Ownable {
  bool private _revealed = false;
  string private _baseURIPath = "https://url.b34ch.xyz/ipfs/";
  string private _placeholderURI = "Qmb4efNTGFfFeMmYNoMWKwhPkvQkfeNLo4kgZqi72JAL6S";
  string[2] private _revealedPath = ["", ""];
  bool private _frozen = false;

  bytes32 public waveListMerkleRoot;
  uint public MAX_SUPPLY = 1337;
  uint public MAX_PER_WALLET = 5;
  uint public MAX_PER_TX = 3;
  string public provenance = "e36178f2da4018955176de7fc70fa1fdc0dc0679f36d42f60d5a6cafe9691ba1";

  address private _lobster;
  address private _seafood;

  uint private _mintBlock;

  string[] private _TRAITS;
  string[] private _DICT;

  mapping(uint256 => string) private _beachNames;
  mapping(uint256 => uint16[8]) private _beachMetadata;
  mapping(string => bool) private _existingNames;

  uint private AMOUNT_NEEDED_FOR_NAME_CHANGE = 50;

  // PaymentSplitter
  mapping(address => uint8) private _shares;
  mapping(address => uint256) private _released;
  mapping(address => uint256) private _balances;
  address[] private _payees;
  uint256 private _totalShares;
  uint256 private _totalSplit;
  uint256 private _amountReleased;

  event PayeeAdded(address indexed account, uint8 shares);
  event PayeeUpdated(address indexed account, uint8 shares);
  event PaymentReleased(address indexed account, uint256 amount);
  event Revealed();
  event NameChanged(uint256 tokenId, string name);

  constructor(address lobster_, uint blockToMint_, string[] memory traits_) ERC721("B34CH DAO", "B34CH") {
    _lobster = lobster_;
    _setDefaultRoyalty(address(this), 1000);
    _mintBlock = blockToMint_ > 100000 ? blockToMint_ : block.number + blockToMint_;
    _TRAITS = traits_;
  }

  function setMerkleRoot(bytes32 waveListRoot_) external onlyOwner {
    waveListMerkleRoot = waveListRoot_;
  }

  function setSeafood(address seafood_) external onlyOwner {
    _seafood = seafood_;
  }

  receive() external payable {
  }

  /**
   * @dev Returns the wallet of a given wallet. Mainly for ease for frontend devs.
   * @param wallet_ The wallet to get the tokens of.
   */
  function walletOfOwner(address wallet_)
  public
  view
  returns (uint256[] memory)
  {
    return BeachLibrary.walletOfOwner(wallet_, address(this));
  }

  // Function intended to be triggered by the DAO in case the Gateway or Network has an issue
  function updateBaseURI(string memory uri_) external onlyOwner {
    require(!_frozen, "B: Frozen");
    _baseURIPath = uri_;
  }

  /**
   * @dev Allows the owner to freeze the path so it can't be changed anymore once it has settled
   */
  function freezeMetadata() external onlyOwner {
    _frozen = true;
  }

  /**
   * @dev Gets the path after reveal. The image folder is too big so it had to be split in 2 folders at ID 1000
   * @param tokenId_ TokenId to retrieve the path for
   */
  function getRevealedPath(uint256 tokenId_) internal view returns (string memory) {
    return tokenId_ <= 1000 ? _revealedPath[0] : _revealedPath[1];
  }

  /**
   * @dev Builds the contract JSON from on-chain data to serve marketplaces
   */
  function contractURI() public view returns (string memory) {
    return BeachLibrary.buildContractURI(address(this));
  }

  /**
   * @dev Returns the metadata for a token Id
   * @param tokenId_ The tokenId to return the metadata for.
   */
  function tokenURI(uint256 tokenId_)
  public
  view
  override
  returns (string memory)
  {
    _exists(tokenId_);

    return BeachLibrary.buildTokenURI(
      tokenId_,
      beachName(tokenId_),
      BeachLibrary.getImagePath(tokenId_, _revealed, _baseURIPath, getRevealedPath(tokenId_), _placeholderURI, true),
      BeachLibrary.getImagePath(tokenId_, _revealed, _baseURIPath, getRevealedPath(tokenId_), _placeholderURI, false),
      _revealed ? BeachLibrary.dictToMetadata(tokenId_, _TRAITS, _DICT, _beachMetadata) : '[]');
  }

  /**
   * @dev Function mostly for UI / UX so anyone can know whether the mint is opened and block has been reached
   */
  function isMintLive() public view returns (bool) {
    return block.number > _mintBlock;
  }

  /**
   * @dev Mints one or more B34CH NFT up to the MAX per TX and MAX per Wallet.
   *      NOTE: During first phase of the mint (the first 137 NFTs), the MAX is over-ridden to 1.
   *      If you have been WaveListed, the right pricing will apply automatically.
   *      Call getMyPriceForNextMint() in order to know exactly how much you need to send.
   * @param count_ The amount of NFTs to mint at once
   * @param merkleProof_ The array of proofs needed to calculate your wallet all the way to the root to validate it
   */
  function gimmeBeaches(uint8 count_, bytes32[] calldata merkleProof_) external payable {
    require(block.number > _mintBlock, "B: Mint block not ready");
    require((count_ > 0 && count_ <= MAX_PER_TX) && (balanceOf(_msgSender()) + count_ <= MAX_PER_WALLET), "B: Too many beaches");
    require(_msgSender() == tx.origin, "B: No contracts");
    require((totalSupply() < 137 && balanceOf(_msgSender()) == 0 && count_ == 1) || totalSupply() >= 137, "B: Only 1 in 1st wave");

    uint mintPrice = getMyPriceForNextMint(merkleProof_);
    require(msg.value == mintPrice * count_, "B: Minting amount incorrect");

    for (uint8 i = 0; i < count_; i++) {
      _mintABeach(_msgSender());
    }
  }

  /**
   * @dev Function to validate of your wallet address is present within the merkle tree or if your balance of LobsterDAO
   *      NFT is positive.
   * @param merkleProof_ The array of proofs needed to calculate your wallet all the way to the root to validate it
   */
  function amIWaveListed(bytes32[] calldata merkleProof_) public view returns (bool) {
    bool isWaveList = merkleProof_.length > 0 ? MerkleProof.verify(merkleProof_, waveListMerkleRoot, keccak256(abi.encodePacked(_msgSender()))) : false;
    return resolveLobster(_msgSender()) >= 1 || isWaveList;
  }

  /**
   * @dev Function to enable the owner to rescue mints or giveaways if required. Not intended to be used.
   * @param to_ the address to mint to
   */
  function safeMint(address to_) public onlyOwner {
    _mintABeach(to_);
  }

  /**
   * @dev Internal function to enable the owner to rescue mints or giveaways if required. Not intended to be used.
   * @param to_ the address to mint to
   */
  function _mintABeach(address to_) internal {
    require(totalSupply() < MAX_SUPPLY, "B: max supply reached");
    _safeMint(to_, totalSupply() + 1);
  }

  /**
   * @dev Method to set the name of the NFT and update metadata accordingly so it's visible on OpenSea / on-chain.
   *      The method will make sure you are renaming tokens you own.
   *      The name needs to be unique, do not contain invalid characters (mostly just ASCII are allowed) and be short
   *      enough.
   * @param tokenId_ the token to rename
   * @param name_ the new name
   */
  function setName(uint tokenId_, string memory name_) external {
    require(ownerOf(tokenId_) == _msgSender(), "B: You do not own this token");
    require(BeachLibrary.validateName(name_), "B: Name is not valid");
    require(!nameExists(name_), "B: Name requested is already used");

    // The setName process is free until seafood exists
    if (_seafood != address(0x0)) {
      require(resolveSeafoodBalance(_msgSender()) > AMOUNT_NEEDED_FOR_NAME_CHANGE, "B: You do not have enough balance");
      // Burn $BEACH
      _burnSeafoodToken(AMOUNT_NEEDED_FOR_NAME_CHANGE);
    }

    _setName(tokenId_, name_);
  }

  /**
   * @dev Internal method to propagate the name change, focused on name changing (minus validations)
   * @param tokenId_ the token to rename
   * @param name_ the new name
   */
  function _setName(uint tokenId_, string memory name_) private {
    if (bytes(_beachNames[tokenId_]).length > 0) {
      _existingNames[_beachNames[tokenId_]] = false;
    }
    _beachNames[tokenId_] = name_;
    _existingNames[BeachLibrary.toLower(name_)] = true;
    emit NameChanged(tokenId_, name_);
  }

  /**
   * @dev Public method to find whether a name is unique or exists already
   * @param name_ the name top search for
   */
  function nameExists(string memory name_) public view returns (bool) {
    return _existingNames[BeachLibrary.toLower(name_)];
  }

  /**
   * @dev Helper function to return the name of a beach. It will default the name if the name has never been set,
   *      to save gas during mint.
   * @param tokenId_ The token ID to return the name of
   */
  function beachName(uint tokenId_) public view returns (string memory) {
    _exists(tokenId_);

    bool isEmpty = keccak256(abi.encodePacked(_beachNames[tokenId_])) == keccak256(abi.encodePacked("")) || keccak256(abi.encodePacked(_beachNames[tokenId_])) == keccak256(bytes(BeachLibrary.toString(tokenId_)));
    return string(abi.encodePacked("Beach ", isEmpty ? string(abi.encodePacked("#", BeachLibrary.toString(tokenId_))) : _beachNames[tokenId_]));
  }

  /**
   * @dev Internal helper function to return the balance of the $Seafood token
   * @param account_ The account to retrieve the balance of
   */
  function resolveSeafoodBalance(address account_) internal view returns (uint) {
    return IERC20(_seafood).balanceOf(account_);
  }

  /**
   * @dev Takes a high order amount (for example 10) and returns fully decimal'ed value (10 * 10 ** 18)
   * @param amount_ The amount to calculate for
   */
  function _toFullDecimals(uint amount_) private view returns (uint) {
    return amount_ * 10 ** ISeafood(_seafood).decimals();
  }

  /**
   * @dev Internal helper to burn seafood token to change name, if $seafood address has been set
   * @param amount_ The amount to burn, in high order (you want to burn 10 $SEAFOOD, amount_ will be 10)
   */
  function _burnSeafoodToken(uint amount_) private returns (bool) {
    require(resolveSeafoodBalance(_msgSender()) >= _toFullDecimals(amount_), "B: Not enough balance");
    IERC20Burnable(_seafood).burnFrom(_msgSender(), _toFullDecimals(amount_));
    return true;
  }

  // The following functions are overrides required by Solidity.
  function _burn(uint256 tokenId) internal override(ERC721, ERC721Royalty) {}

  function _beforeTokenTransfer(address from, address to, uint256 tokenId)
  internal
  override(ERC721, ERC721Enumerable)
  {
    super._beforeTokenTransfer(from, to, tokenId);
  }

  function supportsInterface(bytes4 interfaceId)
  public
  view
  override(ERC721Enumerable, ERC721Royalty)
  returns (bool)
  {
    return super.supportsInterface(interfaceId);
  }

  // Beach-specific functions

  /***************************
   *      Reveal / Mint      *
   ***************************/

  /**
   * @dev Sets the dictionary to build the metadata array from
   * @param dict_ The dictionary, basically a simple string array
   */
  function setDict(string[] memory dict_) public onlyOwner {
    require(!_frozen, "B: Frozen");
    _DICT = dict_;
  }

  /**
   * @dev This method is very important and sets the metadata that will be used later to build the TokenURI JSON for
   *      each and every NFT. It is index based off of the dictionary in order to save space and gas cost.
   *      This method effectively prepares for the reveal to happen. It is re-callable until metadata has been frozen
   *      to allow for fixing potential mistakes. The process has been tested and validated, but, we never know, and
   *      since metadata will be on-chain and virtually frozen, we better make sure.
   * @param range_ is the range of metadata currently being uploaded, since the whole thing needs to happen in X tx
   * @param metadata_ the metadata itself
   */
  function setMetadata(uint16[2] calldata range_, uint16[][] calldata metadata_) external onlyOwner {
    require(!_frozen && range_[0] > 0 && range_[0] < range_[1] && range_[1] <= 1338, "B: Range incorrect");
    for (uint i = 0; i < range_[1] - range_[0]; i++) {
      uint tokenId_ = i + range_[0];

      _beachMetadata[tokenId_][0] = metadata_[i][0];
      _beachMetadata[tokenId_][1] = metadata_[i][1];
      _beachMetadata[tokenId_][2] = metadata_[i][2];
      _beachMetadata[tokenId_][3] = metadata_[i][3];
      _beachMetadata[tokenId_][4] = metadata_[i][4];
      _beachMetadata[tokenId_][5] = metadata_[i][5];
      _beachMetadata[tokenId_][6] = metadata_[i][6];
      _beachMetadata[tokenId_][7] = metadata_[i][7];
    }
  }

  function revealState() public view returns (bool) {
    return _revealed;
  }

  /**
   * @dev Reveals the collection and sets the IPFS folders
   * @param paths_ An array of 2 IPFS paths to set the images for TokenURI JSON building
   */
  function reveal(string[] calldata paths_) external onlyOwner {
    require(!_revealed, "B: already revealed");
    _revealed = true;
    _revealedPath[0] = paths_[0];
    _revealedPath[1] = paths_[1];
    emit Revealed();
  }

  /**
   * @dev Internal helper to check the lobsters balance
   * @param target_ The target to check the balance for
   */
  function resolveLobster(address target_) public view returns (uint) {
    return IERC721(_lobster).balanceOf(target_);
  }

  /**
   * @dev A really important method that returns the price for the mint given current supply and whether you're
   *      WaveListed or not. It does *not* check whether you are *actually* WaveListed, this is just to get price ranges
   * @param isWaveList_ whether or not your are WaveListed. This method does not verify.
   */
  function getMintPrice(bool isWaveList_) public view returns (uint) {
    uint cId = totalSupply() + 1;
    uint zero = 0 ether;
    uint one = 1 ether;
    uint t1 = 0.037 ether;
    uint t2 = 0.073 ether;
    uint t3 = 0.1 ether;
    uint t4 = 0.1337 ether;

    if (cId <= 137) {
      return isWaveList_ ? zero : one;
    } else if (cId > 137 && cId <= 317) {
      return isWaveList_ ? t1 : t2;
    } else if (cId > 317 && cId <= 713) {
      return isWaveList_ ? t2 : t3;
    } else if (cId > 713) {
      return isWaveList_ ? t3 : t4;
    }
    return 1 ether;
  }

  /**
   * @dev This method is the one that will be used for Mint and UI / UX to tell you your mint price.
   *      It will check the provided merkleProof and your Lobster balance to confirm whether you're WaveListed or not.
   * @param merkleProof_ The array of proofs to confirm your address is in the Merkle Tree or not
   */
  function getMyPriceForNextMint(bytes32[] calldata merkleProof_) public view returns (uint) {
    return getMintPrice(amIWaveListed(merkleProof_));
  }

  /***************************
   *                         *
   *    ================     *
   *    Payment Splitter     *
   *    ================     *
   *                         *
   *  All the methods under  *
   *  exist to manage        *
   *  Payment Splitting      *
   *  during mint and after  *
   *                         *
   ***************************/

  function _addPayee(address account_, uint8 shares_) private {
    require(account_ != address(0), "PS: No 0");
    require(shares_ > 0, "PS: Shares = 0");
    require(_totalShares + shares_ < 256, "PS: Max shares");
    require(_payees.length < 256, "PS: Too many sh");

    // Flush outstanding balances to ensure that new payees don't mess things up
    _splitOutstandingBalance();

    // We're checking this one after the balance have been frozen in order to make sure we can't add an address twice
    require(_shares[account_] == 0 && _released[account_] == 0 && _balances[account_] == 0, "PS: Account exists");

    _payees.push(account_);
    _shares[account_] = shares_;
    _totalShares += shares_;

    emit PayeeAdded(account_, shares_);
  }

  function addPayee(address account_, uint8 shares_) external onlyOwner {
    _addPayee(account_, shares_);
  }

  function addPayeesBatch(address[] calldata accounts_, uint8[] calldata shares_) external onlyOwner {
    for (uint8 i = 0; i < accounts_.length; i++) {
      _addPayee(accounts_[i], shares_[i]);
    }
  }

  function _updatePayee(address account_, uint8 shares_) private {
    require(account_ != address(0), "PS: Address can't be 0");
    require(_released[account_] > 0 || _balances[account_] > 0, "PS: Account doesn't exist");
    require(_totalShares - _shares[account_] + shares_ < 256, "PS: Max shares reached");

    // Flush outstanding balances to ensure that new payees don't mess things up
    _splitOutstandingBalance();

    _totalShares -= _shares[account_];

    // Update shares
    _shares[account_] = shares_;

    // Adjust total shares
    _totalShares += shares_;

    emit PayeeUpdated(account_, shares_);
  }

  function updatePayee(address account_, uint8 shares_) external onlyOwner {
    _updatePayee(account_, shares_);
  }

  function updatePayeesBatch(address[] calldata accounts_, uint8[] calldata shares_) external onlyOwner {
    for (uint8 i = 0; i < accounts_.length; i++) {
      _updatePayee(accounts_[i], shares_[i]);
    }
  }

  function _split(uint amount) private {
    for (uint8 i = 0; i < _payees.length; i++) {
      // Only calculate if the shares are not 0 to avoid un-needed calculations
      if (_shares[_payees[i]] == 0) {
        delete _payees[i];
        continue;
      }

      // Last account gets the dust
      uint256 amountSplit = i < _payees.length - 1 ? amount * _shares[_payees[i]] / _totalShares : address(this).balance - (_totalSplit - _amountReleased);
      _balances[_payees[i]] += amountSplit;
      _totalSplit += amountSplit;
    }
  }

  function _splitOutstandingBalance() internal {
    uint outstandingBalance = address(this).balance - (_totalSplit - _amountReleased);
    _split(outstandingBalance);
  }

  function split() external onlyAccountOrOwner(_msgSender()) {
    _splitOutstandingBalance();
  }

  // dev: This is not supposed to be used. More like an emergency withdraw
  //      It assumes that owner() is the DAO address.
  function withdrawEthFunds() external onlyOwner {
    Address.sendValue(payable(owner()), address(this).balance);
  }

  function withdrawERC20Funds(address ERC20_) external onlyOwner {
    IERC20(ERC20_).transfer(owner(), IERC20(ERC20_).balanceOf(address(this)));
  }

  function release(address payable account) external onlyAccountOrOwner(account) {
    require(_balances[account] > 0, "PS: No balance");

    _splitOutstandingBalance();

    // Non-re-entrant pre-tx
    uint256 amountToSend = _balances[account];
    _balances[account] = 0;

    Address.sendValue(account, amountToSend);

    // Post-tx book-keeping
    _released[account] += amountToSend;
    _amountReleased += amountToSend;

    emit PaymentReleased(account, amountToSend);
  }

  function accountDetails(address account_) public view onlyAccountOrOwner(account_) returns (uint8, uint256, uint256, uint256) {
    return (_shares[account_], _released[account_], _balances[account_], _totalShares);
  }

  function balanceAvailable() public view returns (uint256) {
    return address(this).balance;
  }

  function totalReceived() public view returns (uint256) {
    return address(this).balance + _amountReleased;
  }

  modifier onlyAccountOrOwner(address account) {
    require(owner() == _msgSender() || account == _msgSender(), "Not the owner or account owner");
    _;
  }
}
