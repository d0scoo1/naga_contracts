// SPDX-License-Identifier: MIT
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

/*
 ____                   _           _         
|  _ \                 | |         | |        
| |_) | __ _ ___  ___  | |     __ _| |__  ___ 
|  _ < / _` / __|/ _ \ | |    / _` | '_ \/ __|
| |_) | (_| \__ \  __/ | |___| (_| | |_) \__ \
|____/ \__,_|___/\___| |______\__,_|_.__/|___/
                                              
*/

pragma solidity ^0.8.7;

/**
 * @title Crypto
 * @author BaseLabs
 */
contract Crypto {
    bytes constant ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    /**
     * @notice base58 is used to calculate the base58 encoded value of given bytes.
     * This algorithm was migrated from github.com/mr-tron/base58 to solidity by our developers.
     * Note that it is not yet optimized for gas, so please use it only in read-only scenarios.
     * @param data_ bytes.
     * @return base58 encoded results.
     */
    function base58(bytes memory data_) public pure returns (bytes memory){
        uint256 size = data_.length;
        uint256 zeroCount;
        while (zeroCount < size && data_[zeroCount] == 0) {
            zeroCount++;
        }
        size = zeroCount + (size - zeroCount)*8351/6115+1;
        bytes memory slot = new bytes(size);
        uint32 carry;
        int256 m;
        int256 high = int256(size) - 1;
        for (uint256 i = 0; i < data_.length; i++) {
            m = int256(size - 1);
            for (carry = uint8(data_[i]); m > high || carry != 0; m--) {
                carry = carry + 256 * uint8(slot[uint256(m)]);
                slot[uint256(m)] = bytes1(uint8(carry % 58));
                carry /= 58;
            }
            high = m;
        }
        uint256 n;
        for (n = zeroCount; n < size && slot[n] == 0; n++) {}
        size = slot.length - (n - zeroCount);
        bytes memory out = new bytes(size);
        for (uint256 i = 0; i < size; i++) {
            uint256 j = i + n - zeroCount;
            out[i] = ALPHABET[uint8(slot[j])];
        }
        return out;
    }

    /**
     * @notice cidv0 is used to convert sha256 hash to cid(v0) used by IPFS.
     * @param sha256Hash_ sha256 hash generated by anything.
     * @return IPFS cid that meets the version0 specification.
     */
    function cidv0(bytes32 sha256Hash_) public pure returns (string memory) {
        bytes memory hashString = new bytes(34);
        hashString[0] = 0x12;
        hashString[1] = 0x20;
        for (uint256 i = 0; i < sha256Hash_.length; i++) {
            hashString[i+2] = sha256Hash_[i];
        }
        return string(base58(hashString));
    }
}

/**
 * @title CheersUp
 * @author BaseLabs
 */
contract CheersUp is ERC721, Pausable, Ownable, ReentrancyGuard, Crypto {
    event RevealingURIChanged(string uri);
    event Refunded(address indexed from, address indexed to, uint256 indexed tokenId);
    event CheersUpRevealed(uint256 indexed cucpTokenId, uint256 indexed cheersUpTokenId);
    event TokenHashSet(uint256 indexed tokenId, bytes32 tokenHash);
    event ProvenanceUpdated(string procenance);
    event Withdraw(address indexed account, uint256 amount);
    event Deposit(address indexed account, uint256 amount);
    event CUCPContractAddressChanged(address indexed contractAddress);
    event MaintainerAddressChanged(address indexed maintainer);
    event RefundConfigChanged(RefundConfig config);

    event ContractSealed();

    struct RefundConfig {
        uint256 startTime;
        uint256 endTime;
        uint256 price;
        address beneficiary;
    }
    uint256 public constant MAX_TOKEN = 5000;

    string public provenance;
    string public revealingURI;
    address public cucpContractAddress;
    address public maintainerAddress;
    bool public contractSealed;
    RefundConfig public refundConfig;

    uint256[MAX_TOKEN] internal _randIndices;
    uint256 private _numberMinted;
    mapping(uint256 => bytes32) private _tokenHashes;

    constructor(
        string memory revealingURI_,
        address cucpContractAddress_,
        address maintainerAddress_,
        string memory provenance_
    ) ERC721("Cheers UP", "CUP") {
        revealingURI = revealingURI_;
        cucpContractAddress = cucpContractAddress_;
        maintainerAddress = maintainerAddress_;
        provenance = provenance_;
    }


    /***********************************|
    |               Core                |
    |__________________________________*/

    /**
     * @notice mint is used to randomly generate a token for address_. 
     * It can only be called by the CheersUpPeriod contract.
     * @param address_ specify which address will get the token.
     * @param cucpTokenId_ defines which tokenId in the CheersUpPeriod contract this call originates from.
     * @return randomly generated TokenId
     */
    function mint(address address_, uint256 cucpTokenId_) public returns(uint256) {
        require(_msgSender() == cucpContractAddress, "not authorized");
        require(_numberMinted + 1 <= MAX_TOKEN, "mint would exceed max supply");
        require(cucpTokenId_ < MAX_TOKEN, "tokenId is invalid");
        uint256 tokenId = getRandomTokenId();
        _safeMint(address_, tokenId);
        unchecked {
            _numberMinted += 1;
        }
        emit CheersUpRevealed(cucpTokenId_, tokenId);
        return tokenId;
    }

    /**
     * @notice getRandomTokenId is used to randomly select an unused tokenId.
     * @return randomly selected tokenId.
     */
    function getRandomTokenId() internal returns (uint256) {
        unchecked {
            uint256 remain = MAX_TOKEN - _numberMinted;
            uint256 pos = unsafeRandom() % remain;
            uint256 val = _randIndices[pos] == 0 ? pos : _randIndices[pos];
            _randIndices[pos] = _randIndices[remain - 1] == 0 ? remain - 1 : _randIndices[remain - 1];
            return val;
        }
    }

    /**
     * @notice unsafeRandom is used to generate a random number by on-chain randomness. 
     * Please note that on-chain random is potentially manipulated by miners, and most scenarios suggest using VRF.
     * @return randomly generated number.
     */
    function unsafeRandom() internal view returns (uint256) {
        unchecked {
            return uint256(keccak256(abi.encodePacked(
                blockhash(block.number-1), 
                block.difficulty, 
                block.timestamp, 
                block.coinbase,
                _numberMinted, 
                tx.origin
            )));
        }
    }

    /**
     * @notice The NFT holder can use this method to perform refund token
     * and a certain amount of ETH will be sent to the caller.
     * @param tokenId_ which token to refund
     */
    function refund(uint256 tokenId_) external callerIsUser nonReentrant {
        require(isRefundEnabled(), "refund has not enabled");
        require(address(this).balance > refundConfig.price, "insufficient contract funds");
        address from = _msgSender();
        address to = refundConfig.beneficiary;
        require(ownerOf(tokenId_) == from, "caller is not owner");
        safeTransferFrom(from, to, tokenId_);
        payable(from).transfer(refundConfig.price);
        emit Refunded(from, to, tokenId_);
    }

    /**
     * @notice issuer have permission to burn token.
     * @param tokenIds_ list of tokenId
     */
    function burn(uint256[] calldata tokenIds_) external onlyOwner nonReentrant  {
        for (uint256 i = 0; i < tokenIds_.length; i++) {
            uint256 tokenId = tokenIds_[i];
            require(ownerOf(tokenId) == _msgSender(), "caller is not owner");
            _burn(tokenId);
        }
    }

    /**
     * @notice issuer have permission to deposit ETH into the contract, which is used to support the refund logic.
     */
    function deposit() external payable onlyOwner nonReentrant {
        emit Deposit(_msgSender(), msg.value);
    }

    /**
     * @notice issuer withdraws the ETH temporarily stored in the contract through this method.
     */
    function withdraw() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        payable(_msgSender()).transfer(balance);
        emit Withdraw(_msgSender(), balance);
    }


    /***********************************|
    |             Brewing               |
    |__________________________________*/

    event BrewingStarted(uint256 indexed tokenId, address indexed account);
    event BrewingStopped(uint256 indexed tokenId, address indexed account);
    event BrewingInterrupted(uint256 indexed tokenId);
    event BrewingTokenTransfered(address indexed from, address indexed to, uint256 indexed tokenId);
    event BrewingAllowedFlagChanged(bool isBrewingAllowed);
    struct BrewingStatus {
        uint256 lastStartTime;
        uint256 total;
        bool brewingTransferLockTempRelease;
    }
    bool public isBrewingAllowed;
    mapping(uint256 => BrewingStatus) private _brewingStatuses;

    /**
     * @notice safeTransferWhileBrewing is used to safely transfer tokens without changing the brewing state.
     * @param from_ cannot be the zero address.
     * @param to_ cannot be the zero address.
     * @param tokenId_ token must exist and be owned by `from`.
     */
    function safeTransferWhileBrewing(address from_, address to_, uint256 tokenId_) external nonReentrant {
        require(ownerOf(tokenId_) == _msgSender(), "caller is not owner");
        _brewingStatuses[tokenId_].brewingTransferLockTempRelease = true;
        safeTransferFrom(from_, to_, tokenId_);
        _brewingStatuses[tokenId_].brewingTransferLockTempRelease = false;
        if (_brewingStatuses[tokenId_].lastStartTime != 0) {
            emit BrewingTokenTransfered(from_, to_, tokenId_);
        }
    }

    /**
     * @notice setIsBrewingAllowed is used to set the global switch to control whether users are allowed to brew.
     * @param isBrewingAllowed_ set to true to allow
     */
    function setIsBrewingAllowed(bool isBrewingAllowed_) external onlyOwner {
        isBrewingAllowed = isBrewingAllowed_;
        emit BrewingAllowedFlagChanged(isBrewingAllowed);
    }

    /**
     * @notice getTokenBrewingStatus is used to get the detailed brewing status of a specific token.
     * @param tokenId_ token id
     * @return isBrewing_ whether the current token is brewing.
     * @return current_ how long the token has been brewing in the hands of the current hodler.
     * @return total_ total amount of brewing since the token minted.
     */
    function getTokenBrewingStatus(uint256 tokenId_) external view returns (bool isBrewing_, uint256 current_, uint256 total_) {
        require(_exists(tokenId_), "query for nonexistent token");
        BrewingStatus memory status = _brewingStatuses[tokenId_];
        if (status.lastStartTime != 0) {
            isBrewing_ = true;
            current_ = block.timestamp - status.lastStartTime;
        }
        total_ = status.total + current_;
    }

    /**
     * @notice setTokenBrewingState is used to modify the Brewing state of the Token, 
     * only the Owner of the Token has this permission.
     * @param tokenIds_ list of tokenId
     * @param state_ If true, brew will be started. If false, brew will be stopped.
     */
    function setTokenBrewingState(uint256[] calldata tokenIds_, bool state_) external nonReentrant {
        unchecked {
            for (uint256 i = 0; i < tokenIds_.length; i++) {
                uint256 tokenId = tokenIds_[i];
                require(ownerOf(tokenId) == _msgSender(), "caller is not owner");
                BrewingStatus storage status = _brewingStatuses[tokenId];
                uint256 lastStartTime = status.lastStartTime;
                if (state_ && lastStartTime == 0) {
                    require(isBrewingAllowed, "brewing is not allowed");
                    status.lastStartTime = block.timestamp;
                    emit BrewingStarted(tokenId, _msgSender());
                } else if (!state_ && lastStartTime > 0) {
                    status.total += block.timestamp - lastStartTime;
                    status.lastStartTime = 0;
                    emit BrewingStopped(tokenId, _msgSender());
                }
            }
        }
    }

    /**
     * @notice interruptTokenBrewing gives the issuer the right to forcibly interrupt the brewing state of the token.
     * One scenario of using it is: someone may maliciously place low-priced brewing tokens on
     * the secondary market (because brewing tokens cannot be traded).
     * @param tokenIds_ the tokenId list to operate
     */
    function interruptTokenBrewing(uint256[] calldata tokenIds_) external atLeastMaintainer {
        for (uint256 i = 0; i < tokenIds_.length; i++) {
            uint256 tokenId = tokenIds_[i];
            require(_exists(tokenId), "operate for nonexistent token");
            BrewingStatus storage status = _brewingStatuses[tokenId];
            require(status.lastStartTime != 0, "brewing is not started");
            unchecked {
                status.total += block.timestamp - status.lastStartTime;
                status.lastStartTime = 0;
            }
            emit BrewingStopped(tokenId, _msgSender());
            emit BrewingInterrupted(tokenId);
        }
    }


    /***********************************|
    |             Getter                |
    |__________________________________*/


    /**
     * @notice totalMinted is used to return the total number of tokens minted. 
     * Note that it does not decrease as the token is burnt.
     */
    function totalMinted() public view returns (uint256) {
        return _numberMinted;
    }

    /**
     * @notice isRevealEnabled is used to return whether the refund has been enabled
     */
    function isRefundEnabled() public view returns (bool) {
        if (refundConfig.endTime > 0 && block.timestamp > refundConfig.endTime) {
            return false;
        }
        return refundConfig.startTime > 0 &&
            block.timestamp > refundConfig.startTime &&
            refundConfig.price > 0 && 
            refundConfig.beneficiary != address(0);
    }

    /**
     * @notice tokenURI will return the URI of the metadata of the token, 
     * if the Token has not completed reveal, then it will return the revealingURI.
     * @return metadata uri
     */
    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
        require(_exists(tokenId), "query for nonexistent token");
        bytes32 hash = _tokenHashes[tokenId];
        if (hash == "") {
            return revealingURI;
        }
        return string(abi.encodePacked("ipfs://", cidv0(hash)));
    }


    /***********************************|
    |             Setter                |
    |__________________________________*/


    /**
     * @notice setProvenance is used to allow the issuer to modify the provenance in special cases.
     * This process is under the supervision of the community.
     */
    function setProvenance(string memory provenance_) external onlyOwner {
        provenance = provenance_;
        emit ProvenanceUpdated(provenance);
    }

    /**
     * @notice setRevealingURI is used to allow the issuer to modify the revealingURI in special cases.
     * This process is under the supervision of the community.
     */
    function setRevealingURI(string memory revealingURI_) external onlyOwner {
        revealingURI = revealingURI_;
        emit RevealingURIChanged(revealingURI);
    }

    /**
     * @notice setCUCPContractAddress is used to allow the issuer to modify the cucpContractAddress in special cases.
     * This process is under the supervision of the community.
     */
    function setCUCPContractAddress(address address_) external onlyOwner {
        cucpContractAddress = address_;
        emit CUCPContractAddressChanged(address_);
    }

    /**
     * @notice setMaintainerAddress is used to allow the issuer to modify the maintainerAddress
     */
    function setMaintainerAddress(address maintainerAddress_) external onlyOwner {
        maintainerAddress = maintainerAddress_;
        emit MaintainerAddressChanged(maintainerAddress_);
    }

    /**
     * @notice setRefundConfig allows issuer to set refundConfig
     */
    function setRefundConfig(RefundConfig calldata config_) external onlyOwner {
        require(config_.beneficiary != address(0), "beneficiary is required");
        refundConfig = config_;
        emit RefundConfigChanged(config_);
    }

    /**
     * @notice setTokenHash is used to set the ipfs hash of the token
     * This process is under the supervision of the community.
     */
    function setTokenHash(uint256 tokenId_, bytes32 tokenHash_) public atLeastMaintainer {
        _tokenHashes[tokenId_] = tokenHash_;
        emit TokenHashSet(tokenId_, tokenHash_);
    }

    /**
     * @notice similar to setTokenHash, but in bulk
     */
    function batchSetTokenHash(uint256[] calldata tokenIds_, bytes32[] calldata tokenHashes_) external atLeastMaintainer {
        require(tokenIds_.length == tokenHashes_.length, "tokenIds_ and tokenHashes_ length mismatch");
        require(tokenIds_.length > 0, "no tokenId");
        for (uint256 i = 0; i < tokenIds_.length; i++) {
            setTokenHash(tokenIds_[i], tokenHashes_[i]);
        }
    }



    /***********************************|
    |          Pause & Hooks            |
    |__________________________________*/

    /**
     * @notice hook function, used to intercept the transfer of token.
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 tokenId
    ) internal virtual override {
        require(!paused(), "token transfer paused");
        if (!_brewingStatuses[tokenId].brewingTransferLockTempRelease) {
            require(_brewingStatuses[tokenId].lastStartTime == 0, "token is brewing");
        }
        super._beforeTokenTransfer(from, to, tokenId);
    }

    /**
     * @notice for the purpose of protecting user assets, under extreme conditions, 
     * the circulation of all tokens in the contract needs to be frozen.
     * This process is under the supervision of the community.
     */
    function emergencyPause() external onlyOwner notSealed {
        _pause();
    }

    /**
     * @notice unpause the contract
     */
    function unpause() external onlyOwner notSealed {
        _unpause();
    }

    /**
     * @notice when the project is stable enough, the issuer will call sealContract 
     * to give up the permission to call emergencyPause and unpause.
     */
    function sealContract() external onlyOwner {
        contractSealed = true;
        emit ContractSealed();
    }



    /***********************************|
    |              Modifier             |
    |__________________________________*/


    /**
     * @notice for security reasons, CA is not allowed to call sensitive methods.
     */
    modifier callerIsUser() {
        require(tx.origin == _msgSender(), "the caller is another contract");
        _;
    }

    /**
     * @notice function call is only allowed when the contract has not been sealed
     */
    modifier notSealed() {
        require(!contractSealed, "contract sealed");
        _;
    }
    /**
     * @notice only owner or maintainer has the permission to call this method
     */
    modifier atLeastMaintainer() {
        require(owner() == _msgSender() || 
            (maintainerAddress != address(0) && maintainerAddress == _msgSender()), 
            "not authorized");
        _;
    }
}

// QmWYifytzWVJdoaacoKJWBbe7BVJ4pR47VBmB6FSMFa4dB