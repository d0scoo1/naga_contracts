// SPDX-License-Identifier: MIT

/*
* Generated by @0x_digitalnomad
* Email 0xdigitalnomad@gmail.com for your NFT launch needs
*/


pragma solidity ^0.8.10; 


import "@openzeppelin/contracts/access/Ownable.sol";
import "erc721a/contracts/ERC721A.sol";


/*//////////////////////////////////////
                ERRORS
//////////////////////////////////////*/
/// @notice Thrown when completing transaction will exceed collection supply
error ExceededMintSupply();
/// @notice Thrown when completing transaction will exceed max dev supply
error ExceededDevSupply();
/// @notice Thrown when transaction sender is not on whitelist
error NotOnMintList();
/// @notice Thrown when the attempted sale is not actve
error SaleNotActive();
/// @notice Thrown when the message value is less than the required amount
error ValueTooLow();
/// @notice Thrown when the amount minted exceeds max allowed per txn
error MintingTooMany();
/// @notice Thrown when the input address is 0
error ZeroAddress();


contract CycloTurtles is ERC721A, Ownable { 

    /*//////////////////////////////////////
                STATE VARIABLES
    //////////////////////////////////////*/
    enum MintStatus {
        CLOSED,
        PRESALE,
        PUBLIC,
        SOLDOUT
    }
    MintStatus public mintStatus = MintStatus.CLOSED;

    uint256 public constant collectionSize = 8888;
    uint256 public constant maxDevMint = 779;           // Includes 200 gift supply and 579 airdrop
    uint256 public constant maxAvailableMint = 8109;
    uint256 public constant maxPerTxn = 10;
    uint256 public constant presalePrice = 0.05 ether;
    uint256 public constant salePrice = 0.08 ether;
    uint256 public devMintCount;
    uint256 public mintCount;
    string private baseURI;
    string private unrevealedURI;
    bool public revealed = false;

    mapping(address => bool) public mintList;


    /*//////////////////////////////////////
                EVENTS
    //////////////////////////////////////*/
    event ChangeBaseURI(string _baseURI);
    event StartSale(string _sale);
    event Mint(address _minter, uint256 _amount, string _type);
    event AddToMintList(address _address);
    event RemoveFromMintList(address _address);

    /*//////////////////////////////////////
                CONSTRUCTOR
    //////////////////////////////////////*/
    constructor() ERC721A("CycloTurtles", "TURTLES") {} // "CycloTurtles", "TURTLES"

    /*//////////////////////////////////////
                MODIFIERS
    //////////////////////////////////////*/
    modifier callerIsUser() {
        require(tx.origin == msg.sender, "Caller is another contract");
        _;
    }

    /*//////////////////////////////////////
                MINTING FUNCTIONS
    //////////////////////////////////////*/

    // Dev Mint
    function devMint(address _address, uint256 _amount)
        external
        onlyOwner
    {
        if (_address == address(0)) revert ZeroAddress();
        if (devMintCount + _amount > maxDevMint) revert ExceededDevSupply();

        _safeMint(_address, _amount);
        devMintCount += _amount;
        emit Mint(_address, _amount, "Dev");
    }

    // Presale Mint
    function presaleMint (uint256 _amount)
        external
        payable
        callerIsUser
    {
        if (mintStatus != MintStatus.PRESALE) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (!mintList[msg.sender]) revert NotOnMintList();
        if (mintCount + _amount > maxAvailableMint) revert ExceededMintSupply();
        if (msg.value < presalePrice * _amount) revert ValueTooLow();

        _safeMint(msg.sender, _amount);
        mintCount += _amount;
        emit Mint(msg.sender, _amount, "Presale");
    }

    // Sale Mint
    function saleMint(uint256 _amount)
        external
        payable
        callerIsUser
    {
        if (mintStatus != MintStatus.PUBLIC) revert SaleNotActive();
        if (_amount > maxPerTxn) revert MintingTooMany();
        if (mintCount + _amount > maxAvailableMint) revert ExceededMintSupply();
        if (msg.value < salePrice * _amount) revert ValueTooLow();

        _safeMint(msg.sender, _amount);
        mintCount += _amount;
        emit Mint(msg.sender, _amount, "Public Sale");

        if(totalSupply() == collectionSize) {
            mintStatus = MintStatus.SOLDOUT;
        }
    }
    
    /*//////////////////////////////////////
                SETTERS
    //////////////////////////////////////*/
    function setUnrevealedURI(string calldata _unrevealedURI)
        external
        onlyOwner
    {
        unrevealedURI = _unrevealedURI;
    }

    function setBaseURI(string calldata _tokenBaseURI)
        external
        onlyOwner
    {
        baseURI = _tokenBaseURI;
        emit ChangeBaseURI(_tokenBaseURI);
    }

    /*//////////////////////////////////////
                GETTERS
    //////////////////////////////////////*/
    function tokenURI(uint256 tokenId)
        public
        view
        virtual
        override
        returns (string memory)
    {
        require(_exists(tokenId), "URI query for nonexistent token");
        
        if (revealed == false) {
            return unrevealedURI;
        } else {
            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId)) : '';
        }
    }

    function getMintStatus()
        external
        view
        returns(string memory)
    {
        if (mintStatus == MintStatus.CLOSED) {
            return "Closed";
        } else if (mintStatus == MintStatus.PRESALE){
            return "Presale";
        } else if (mintStatus == MintStatus.PUBLIC) {
            return "Public Sale";
        } else { //workflow == WorkflowStatus.SoldOut
            return "Sold Out";
        }
    }

    /*//////////////////////////////////////
                MISC
    //////////////////////////////////////*/
    function addToMintList(address[] calldata _addresses)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addresses.length; i++) {
            if (_addresses[i] == address(0)) revert ZeroAddress();
            if (mintList[_addresses[i]] == false) {
                mintList[_addresses[i]] = true;
            }
        }
    }

    function removeFromMintList(address[] calldata _addresses)
        external
        onlyOwner
    {
        for (uint i = 0; i < _addresses.length; i++) {
            if (_addresses[i] == address(0)) revert ZeroAddress();
            if (mintList[_addresses[i]] == true) {
                mintList[_addresses[i]] = false;
            }
        }
    }
    
    function reveal() external onlyOwner {
        revealed = true;
    }

    function pauseSale() external onlyOwner {
        mintStatus = MintStatus.CLOSED;
    }

    function startPresale() external onlyOwner {
        mintStatus = MintStatus.PRESALE;
        emit StartSale("Presale");
    }

    function startPublicSale() external onlyOwner {
        mintStatus = MintStatus.PUBLIC;
        emit StartSale("Public");
    }

    function withdrawl() external onlyOwner {
        uint balance = address(this).balance;
        payable(msg.sender).transfer(balance);
    }
}