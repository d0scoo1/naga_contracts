// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@((((........(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@....................@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@..................,,,....(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@...................******@@....@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@(.....................*****@@@@...@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@***********@@@@..........................................*******@@@@@..@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@#****************#@@&%%%%%%%//////.........................,*******@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@**********@@@********@@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%...........*****@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@*********@@@@@@*******@@%%%%%%%%%%%%%%%%%%%**********%%%%%%%%///.........((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@*********@@@@@@*******@@%%%%%%%%%%%%%%%%%                 %%%%%%%%%%%........@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@####@@@@@@@#********@@....//%%%%%%%%%%%%%%%%  %%%%%%%%%% *%%%%%%%%%%%%%%%%//....(@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@***********@@@@@@......%%%%%   %%%       %%%                %%%%%%%%%%%.....@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@***********#@@@@@@@@@@@@    ...   %%*       %%*                %%%%%%%%%%%%%//...((@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@********@@@@@@@@@@@@@@@@@@@@@@@                                %%%%%%%%%%%%%%%%%....@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@#*****@@@@@@@@@@@@@@@@@                                   %%%%%%%%%%%////......((@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@*****@@@@@@@@@@@@@@@                       %%%%          ..............@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@****@@@@@@@@@@@@@@@              ########              ..@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@***@(     ,(((@@@@@%%(                        %%@@@  .....(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@@    (((.....@@@@@(                 @@@@@@............@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@****@#((((((........((@@@@@@@@@@@@@@@@@@(((................@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@****@@.........................................*****........@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***#@@@@@@@.................................,,****@(.......@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@****@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**@@@@@@@@@@@@@@@@........................,****@/      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**@@@@@@@@@@@@@@@@.........**..............****@@      @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@@@@@@@@@@@@@.........**,..............****#@@//@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@@@@@@@@@@@@@.........***#@((..............,@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@@@@@@@@@@@@@@.*********@@@@@.............@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@***@@@@@@@@@@@@@@@@(((@@@@@@@@@@@@@((((((((@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**@@@@@@@@@@@@@@@........@@@@@@@@@@.......@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**@@@@@@@@@@@@.........@@@@@@@@@@.......@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@**@@@@@@@@............@@@@@@@..........@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
//
// Forgotten Babies Wizard Orphanage
//
// 10k, on-chain Baby Wizard NFTs
// https://www.forgottenbabies.com
//
// Twitter: https://twitter.com/babywizards
//
// Inspired by Forgotten Runes Wizard Cult
// Made with love by BillGains.eth and AcidEater
// 90% of funds raised go direct to Lore Masters DAO to pay artists to do cool things!!!
//
//
//
//
//
//  !magic
//    !dragons
//      !milk
//        !pilk
//          !burningbabies
//
//
//
//
//  Don't sleep...
//
//
//
// SPDX-License-Identifier: MIT

pragma solidity ^0.8.10;


import "erc721a/extensions/ERC721ABurnable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "@openzeppelin/contracts/interfaces/IERC20.sol";
import "@openzeppelin/contracts/interfaces/IERC2981.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract BabyWizards is ERC721ABurnable, Ownable, ReentrancyGuard {

  enum ReleaseMode{ CLOSED, DEV, PRE_SALE, OPEN, ENDED }
  ReleaseMode public currentMode;

  mapping(address => uint256) private _mintedPerAddress;
  mapping(address => uint256) private _freeBabyRedeemed;
  bytes32 private _presaleMerkleRoot;
  bytes32 private _freeAdoptMerkleRoot;
  uint256 private MAX_PER_ADDRESS;
  uint256 public maxSupply;
  uint256 public price;
  address public openSeaProxyRegistryAddress;
  bool private _isOpenSeaProxyActive = true;
  string private baseTokenURI;
  bool public baseTokenURILocked;
  address private _aeAddress;
  address private _lmdAddress = 0x6EAb2d42FEf9aad0036Bc145b5F451799e3FB3F7;


  // Simple Eth check, assuming no freebies.
  modifier requireCorrectEth(uint256 adoptCount) {
    require(msg.value == price * adoptCount, "Sent incorrect Ether");
    _;
  }

  /// @param adoptCount The amount of babies intended to be adopted.
  /// @dev All of our validations that we check before a mint.
  modifier validateAdoption(uint256 adoptCount) {
    require(
        _mintedPerAddress[msg.sender] + adoptCount <= MAX_PER_ADDRESS,
        "Exceeds wallet limit"
    );
    require(totalSupply() + adoptCount <= maxSupply, "Would exceed max supply");
    _;
 }

 modifier validatePreSaleAction() {
   require(currentMode == ReleaseMode.PRE_SALE || currentMode == ReleaseMode.OPEN, "Not presale time yet");
   _;
 }

 /// @dev Dev time?
 modifier validateDevsAction() {
   require(currentMode == ReleaseMode.DEV, "Not dev time yet");
   _;
 }

 /// @param baseTokenURI_ The starting baseTokenURI, we'll change this later to lock in the data on Arweave.
 /// @param maxSupply_ How many items are mintable?
 /// @param price_ Price per token
 /// @param openSeaProxyRegistryAddress_ The OpenSea proxy address, set at run time so we can easily swap between testnet and mainnet.
 /// @dev The constructor!
 constructor(
     uint256 maxSupply_,
     string memory baseTokenURI_,
     uint256 price_,
     uint256 MAX_PER_ADDRESS_,
     address openSeaProxyRegistryAddress_)
     ERC721A("BabyWizards", "BABIES")
 {
     maxSupply = maxSupply_;
     baseTokenURI = baseTokenURI_;
     MAX_PER_ADDRESS = MAX_PER_ADDRESS_;
     price = price_;
     openSeaProxyRegistryAddress = openSeaProxyRegistryAddress_;
 }

 /// @notice Returns whether or not you, the person calling this method, have adopted a baby.
 function freeBabyClaimed(address a) external view returns (bool){
   return _freeBabyRedeemed[a] == 1;
 }

 function generalAdoption(uint adoptCount) validateAdoption(adoptCount) requireCorrectEth(adoptCount) nonReentrant external payable {
     require(currentMode == ReleaseMode.OPEN, "It's not go time yet.");
     mint(msg.sender, adoptCount, true);
 }

 /// @param _merkleProof The proof generated by the front end, to see if you have written lore.


 function generalFreeAdoption(bytes32[] memory _merkleProof, uint adoptCount) validateAdoption(adoptCount) nonReentrant external payable {
     require(currentMode == ReleaseMode.OPEN, "It's not go time yet.");

     bytes32 leaf = keccak256(abi.encodePacked(msg.sender));

     // The amount we're charging (e.g, the amount we're validating) will depend on
     // if we detected a free mint match. If so we check for a lesser amount of eth.
     uint adoptionFeesToCharge = adoptCount;
     if(MerkleProof.verify(_merkleProof, _freeAdoptMerkleRoot, leaf)){
       if(_freeBabyRedeemed[msg.sender] != 1){ // if the baby is NOT already redeemed, mark it as used and let us use the free one.
         adoptionFeesToCharge = adoptionFeesToCharge - 1;
         _freeBabyRedeemed[msg.sender] = 1;
       }
     }

     require(msg.value == price * adoptionFeesToCharge, "Sent incorrect Ether");
     mint(msg.sender, adoptCount, true);
 }

 /**
 @param merkleProof Your Merkle proof to check that you're on the presale list.
 @param freeMerkleProof Proof for your presence on the free mint list.
 @param adoptCount Amount to mint.
 @notice This is the mint function called by folks before the general sale, assuming they're allow-listed.
 @dev We don't need to enforce any specific limits on number of presale units minted, since the allow list itself
 will limit participants, plus the limit of mints per address checked in `validateBuild`.
 */
 function preSaleAdoption(bytes32[] memory merkleProof, bytes32[] memory freeMerkleProof, uint adoptCount) validateAdoption(adoptCount) validatePreSaleAction nonReentrant external payable {
   bytes32 leaf = keccak256(abi.encodePacked(msg.sender));
   require(MerkleProof.verify(merkleProof, _presaleMerkleRoot, leaf), "Not on allowlist");

   // You can get your free mint during the presale, which is in another Merkle Tree.
   // The amount we're charging (e.g, the amount we're validating) will depend on
   // if we detected a free mint match. If so we check for a lesser amount of eth.
   uint adoptionFeesToCharge = adoptCount;
   if(MerkleProof.verify(freeMerkleProof, _freeAdoptMerkleRoot, leaf)){
     if(_freeBabyRedeemed[msg.sender] != 1){ // if the free is NOT already redeemed, mark it as used and let us use the free one.
       adoptionFeesToCharge = adoptionFeesToCharge - 1;
       _freeBabyRedeemed[msg.sender] = 1;
     }
   }

   require(msg.value == price * adoptionFeesToCharge, "Sent incorrect Ether");
   mint(msg.sender, adoptCount, true);
 }

 /// @dev This is purely for internal testing. Let's us verify a proof for the given sender against the Free Mint Merkle Root.
 function verifyPresale(bytes32[] memory _merkleProof, address sender) view external onlyOwner returns (bool) {
   bytes32 leaf = keccak256(abi.encodePacked(sender));
   return MerkleProof.verify(_merkleProof, _presaleMerkleRoot, leaf);
 }

 function setFreeBabyMerkleRoot(bytes32 merkRoot) external onlyOwner {
   _freeAdoptMerkleRoot = merkRoot;
 }

 function setMaxAdopt(uint256 newNumber) external onlyOwner {
   MAX_PER_ADDRESS = newNumber;
 }

 function setPresaleMerkleRoot(bytes32 merkRoot) external onlyOwner {
   _presaleMerkleRoot = merkRoot;
 }

 /// @dev After we cut over to the permaweb base URI, lock it up so we can't change it back. This is a one-time operation! Don't mess it up!
 function lockBaseTokenURI() external onlyOwner {
   baseTokenURILocked = true;
 }

///@dev change openSeaProxyRegistryAddress in case issues with migration.

 function openSeaProxy(address newAddress) external onlyOwner {
   openSeaProxyRegistryAddress = newAddress;
 }

 /// @param baseTokenURI_ The new baseTokenURI
 /// @dev Need this so we can set the new base URI for the cut over to permaweb.
 function setBaseURI(string memory baseTokenURI_) external onlyOwner {
     require(!baseTokenURILocked, "setBaseURI is locked");
     baseTokenURI = baseTokenURI_;
 }

 // Copy + pasted in the ERC721A in order to override.
 function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
     require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
     string memory baseURI = baseTokenURI;
     return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, Strings.toString(tokenId), '.json')) : "";
 }

 /// @dev Sets the various wallets for withdrawl.
 function setWalletAddresses(address a) external onlyOwner {
   _aeAddress = a;
 }

 function getWalletAddresses() view external onlyOwner returns(address aeAddress, address lmdAddress){
   return (_aeAddress, _lmdAddress);
 }

 /// @dev Set our current mode to DEV.
 function startDevTeam() external onlyOwner {
   setSaleStatus(ReleaseMode.DEV);
 }

 /// @dev Set our current mode to PRE_SALE.
 function startPreSale() external onlyOwner {
   require(currentMode == ReleaseMode.CLOSED, "You already started presale.");
   setSaleStatus(ReleaseMode.PRE_SALE);
   mint(msg.sender, 100, false);

 }

 /// @dev Set our current mode to OPEN, for the general sale.
 function startGeneralSale() external onlyOwner {
   setSaleStatus(ReleaseMode.OPEN);
 }

 /// @dev End the sale (ENDED)
 function endSale() external onlyOwner {
   setSaleStatus(ReleaseMode.ENDED);
 }

 /// @dev Sets the current state to the given status.
 function setSaleStatus(ReleaseMode newStatus) private onlyOwner {
   currentMode = newStatus;
 }

 /// @dev Get paid
 function withdraw() external nonReentrant onlyOwner {
   // Some percentage magic:
   uint256 balance = address(this).balance;
   uint256 tenPercent = balance / 100 * 10;
   payable(_aeAddress).transfer(tenPercent);
   uint256 remaining = address(this).balance;
   payable(_lmdAddress).transfer(remaining);
 }

 /// @param to Who are we minting for?
 /// @param countTowardsWalletLimit Allows us to indicate if this should count towards the "X NFTs per Wallet" limit, or if we bypass that.
 /// @dev Our internal mint method, that handles some universal book-keeping.
 function mint(address to, uint256 count, bool countTowardsWalletLimit) private {
     if(countTowardsWalletLimit){
       _mintedPerAddress[to] += count;
     }
     _safeMint(to, count);
 }

 function isApprovedForAll(address owner, address operator)
     public
     view
     override
     returns (bool)
 {
     // Get a reference to OpenSea's proxy registry contract by instantiating
     // the contract using the already existing address.
     OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(
         openSeaProxyRegistryAddress
     );
     if (_isOpenSeaProxyActive && address(proxyRegistry.proxies(owner)) == operator) {
         return true;
     }

     return super.isApprovedForAll(owner, operator);
 }

 function setIsOpenSeaProxyActive(bool isOpenSeaProxyActive_) external onlyOwner {
   _isOpenSeaProxyActive = isOpenSeaProxyActive_;
 }

 /// @notice In case any wayward tokens make their way over.
 function withdrawTokens(IERC20 token) external onlyOwner {
     uint256 balance = token.balanceOf(address(this));
     token.transfer(msg.sender, balance);
 }

 // @dev Overriding to add support for Royalties
 function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool)
 {
     return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);
 }

 /// @notice Royalties
 function royaltyInfo(uint256 tokenId, uint256 salePrice)
     external
     view
     returns (address receiver, uint256 royaltyAmount)
 {
     require(_exists(tokenId), "Nonexistent token");
     return (_aeAddress, (salePrice * 5) / 100);
 }

 /// @dev Allow us to receive arbitrary ETH if sent directly. Mostly want this for test purposes.
 receive() external payable {}

}

contract OwnableDelegateProxy { }
contract OpenSeaProxyRegistry {
    mapping(address => OwnableDelegateProxy) public proxies;
}
