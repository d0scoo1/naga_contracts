// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK00KKKKKK0kdol:::lOKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KKK00KOxc,. .. 'dKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000K0kdo;.    'kKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000KKK
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KKK0kdlc.    .dKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000000
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KK00KKOl:;.    .dKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000000
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0K0o;........';:d0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK000000
// KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0KKKKKKx,.   ..'.....,xKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK00000000
// KKKKKKKKKKKKKKKKK000KKKKKKKKKKKKKKKKKKOkkOO0K0o.   ..........l0K0KKKKKKKKKKKKKKKKKKKKKKKKKK000000000
// KKKKKKKKKKKKKKKKK000KKKKKKKKKKKKKKKKKOolllok00:   ...........'o0KKKKKKKKKKKKKKKKKKKKKKKKKKKKK0000000
// KKKKKKKKKKKKKKKKK000KKKKKKKKKKKKKKKKKklllllok0o.    .....  ...,o0KKKKKKKKKKKKKKKKKKKKKKKKKKKKKKK0000
// KKKKKKKKKKKKKKKKK0000KKKKKKKKKKKKKKKKxlllllox00o.     ......,'',o0KKKKKK00KKKKKKKKKKKKKKKKKKK0000000
// KKKKKKKKKKKKKKKKK0000KKKKKKKKKKKKKKKK0xdlldkkO0l. .........'od;.,o0KKK0KKKKKKKKKKKKKKKKKKKKK00000000
// KKKKKKKKKKKKKKKKK0000KKKKKKKKKKKKKKK0KOdolok0KO: ...........:Ok;.,d00KKKKKKKKKKKKKKKKKKKKKKK00000000
// KKKKKKKKKKKKKKKKK0000KKKKKKKKKKKKKKKKOolllld00d. .......'...,xKx'.;xK00000KKKKKKKKKKKKKKKKKK00000000
// KKKKKKKKKKKKKKKK00000KKKKKKKKKKKKKKKOdllllok00l. ............l00l'.:k0000000KKKKKKKKKKKKKKKKKK000000
// KKKKKKKKKKKKKKK0000000KKKKKKKKKKK0K0xlllllokO0l. .........',:d0K0l;lk0000000KKKKKKKKKKKKKKKKKK000000
// KKKKKKKKKKKKKKKK000000KKKKKKKKKKKKKOolllllloOOc'.........,d000K000xx0K0K0000KKKKKKKKKKKKKK0000000000
// KKKKKKKKKKKKKKKKK00000KKKKKKKKKK0kxollllllllxkodc....... .o000KK00000K000000KKKKKKKKKKKK000000000000
// KKKKKKKKKKKKKKKK0000000KKKKKKKKKOollllllllllolod;.......  ;OK0KK0KK000000000KKKKKKKKKKKK000000000000
// KKKKKKKKKKKKKKK000000000KKKKKKKK0xllllllllc;'..........   .dKK0KK0K000000000KKKKKKKKKKKK000000000000
// KKKKKKKKKKKKKKK000000000KKKKKK0Kklllllllll:...........'.   'd0K00000000000000KKKKKKKKKK0000000000000
// KKKKKKKKKKKKKKK000000000KKKKKKK0xllllllllc,.... ......,:.  ..o0K0000000000000KKKKKKKKK00000000000000
// KKKKKKKKKKK0000000000000KKKKKKKkollllllllc.............ox,  ..cO0000000000000KKKKKKKK000000000000000
// KKKKKK00000000000000000000KKKK00OOkkdlldkd,.''......,ldk0k;.  .,x0000O0000000KKKKKKK0000000000000000
// KKKK00000000000000000000000KK0000000xllkK0klcc' ....oKKK00Oc.   'd000000000000KKK0000000000000000000
// 00000000000000000000000000000000000OoloO000xl;. .. ,k0000000l.  ..oO00OO0000000000000000000000000000
// 0000000000000000OO00OOOOO0000000000dlok00OOko'  ...cO00000000l. ..cOOOOO0OO0000000000000000000OOOO00
// 0000000000000000OOOOOOOO00000O000OxlokO0OOOOd,.'.':d0O000OO00Oo;c::xOOOOOOOO00000000000000000OOOOOOO
// xxkxxxkkkkkkOOkkkkkkkkkkkkkOOdoddolldkOkOkkkdcldl,'cxxxkOkkkkkkocloddkxxxxkkkkkkOOOOkkkkkkkkkxxxxkxx
// ddooooddddddxxdddxxxdxddddxxxdooollloooollllcclc;;;:cccclolllll;';lolooollollloddodddooollllllllllll
// xxxxxxxxxxxxxxxxxxxkxxxxkkkxkkxxxxxxxxxxxdoc:::cddddxxxxddddoolc:cldooooooooooooooddoooooooooooooooo
// xxxxxxxxxkxxxxxxxxxxxxxxxxxxkkxkkxxxxxxxxxxxxxxxxdddxxxxxxdddxddddddooooooooodoooddddddxxxdddxxxdddo

// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/finance/PaymentSplitter.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Burnable.sol";

contract That_Little_Girl_Was_Me is ERC721Enumerable, Ownable, PaymentSplitter, ERC721Burnable {
    using Strings for uint256;

    // The total tokens minted to an address. Does not matter if tokens are transferred out
    mapping(address => uint256) public addressMintCount;

    string public constant PROVENANCE = "f5d7976fb11cd6fd742000d6965aceea"; // MD5-hashed IPFS CID for provenance

    string public baseTokenURI; // Can be combined with the tokenId to create the metadata URI
    uint256 public maxMintCount = 12; // The maximum number of tokens an address can mint (excluding allowlist mints)
    bool public publicSaleActive = false; // Non-admin users can only mint new tokens when this flag is set to true
    uint256 public constant MINT_PRICE = 0.068 ether; // Public mint price
    uint256 public constant MAX_TOTAL_SUPPLY = 4444; // The maximum total supply of tokens

    uint256 private constant MAX_TOKEN_ITERATIONS = 40; // Used to prevent out-of-gas errors when looping
    string private _baseURIextended;

    event SetBaseURI(address _from);
    event SetMaxMintCount(address _from, uint256 count);
    event TogglePublicSale(address _from, bool isActive);

    constructor(string memory _baseUri, address[] memory _payees, uint256[] memory _shares) ERC721("That Little Girl Was Me", "TLGWM") PaymentSplitter(_payees, _shares) {
        _baseURIextended = _baseUri;
    }

    // Allows the contract owner to set a new base URI string
    function setBaseURI(string calldata baseURI) external onlyOwner {
        _baseURIextended = baseURI;
        emit SetBaseURI(msg.sender);
    }

    function _baseURI() internal view virtual override returns (string memory) {
        return _baseURIextended;
    }

    // Public mint function
    function mint(uint256 amount) external payable {
        uint256 supply = totalSupply();
        uint256 mintCount = addressMintCount[msg.sender];
        require(publicSaleActive, "Public sale is not yet active");
        require(amount > 0, "Mint amount can't be zero");
        require(supply + amount <= MAX_TOTAL_SUPPLY, "Max mint amount is reached");
        require(
            mintCount + amount <= maxMintCount,
            "Exceed the Max Amount to mint."
        );
        require(amount * MINT_PRICE == msg.value, "Check mint price");
			
        for (uint256 i = 0; i < amount; i++) {
            _safeMint(msg.sender , supply + i);
        }
        addressMintCount[msg.sender] = mintCount + amount;
    }

    // Only accessible by the contract owner. This function is used to mint tokens for the team.
    function ownerMint(uint256 amount, address recipient) external onlyOwner {
        uint256 supply = totalSupply();
        require(amount > 0, "Mint amount can't be zero");
        require(amount <= MAX_TOKEN_ITERATIONS, "You cannot mint this many in one transaction."); // Used to avoid OOG errors.
        require(supply + amount <= MAX_TOTAL_SUPPLY, "Max supply is reached");
        
        for (uint256 i = 0; i < amount; i++) {
            _safeMint(recipient , supply + i);
        }
    }

    // Used to get the list of token IDs owned by a user (address). Will not work for wallets with over 40 tokens
    function listTokens(address user) external view returns(uint256[] memory) {
        uint256 tokenCount = 0;
        uint256[] memory tokensId = new uint256[](0);
        tokenCount = balanceOf(user);
        
        if (tokenCount > MAX_TOKEN_ITERATIONS) {
            tokenCount = MAX_TOKEN_ITERATIONS; // limits the returned token count to avoid OOG errors
        }

        if (tokenCount > 0) {
            tokensId = new uint256[](tokenCount);
            for(uint256 i = 0; i < tokenCount; i++){
                tokensId[i] = tokenOfOwnerByIndex(user, i);
            }
        }
        return tokensId;
    }

    // An owner-only function which toggles the public sale on/off
    function togglePublicSale() external onlyOwner {
        publicSaleActive = !publicSaleActive;
        emit TogglePublicSale(msg.sender, publicSaleActive);
    }

    // Allows the owner to update the max mint count, up to a limit of 40 (to avoid OOG errors)
    function setMaxMintCount(uint256 count) external onlyOwner {
        require(count <= MAX_TOKEN_ITERATIONS, "Count must be less than or equal to 40");
        maxMintCount = count;
        emit SetMaxMintCount(msg.sender, count);
    }

    // The following functions are overrides required by Solidity.

    function _beforeTokenTransfer(address from, address to, uint256 tokenId)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}