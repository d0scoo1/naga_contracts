// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

/**
// @title Movr Regisrtry Contract.
// @notice This is the main contract that is called using fund movr.
// This contains all the bridge and middleware ids.
// RouteIds signify which bridge to be used.
// Middleware Id signifies which aggregator will be used for swapping if required.
*/
interface ISocketRegistry {
    ///@notice RouteData stores information for a route
    struct RouteData {
        address route;
        bool isEnabled;
        bool isMiddleware;
    }

    function routes(uint256) external view returns (RouteData memory);

    //
    // Events
    //
    event NewRouteAdded(
        uint256 routeID,
        address route,
        bool isEnabled,
        bool isMiddleware
    );
    event RouteDisabled(uint256 routeID);
    event ExecutionCompleted(
        uint256 middlewareID,
        uint256 bridgeID,
        uint256 inputAmount
    );

    /**
    // @param id route id of middleware to be used
    // @param optionalNativeAmount is the amount of native asset that the route requires
    // @param inputToken token address which will be swapped to
    // BridgeRequest inputToken
    // @param data to be used by middleware
    */
    struct MiddlewareRequest {
        uint256 id;
        uint256 optionalNativeAmount;
        address inputToken;
        bytes data;
    }

    /**
    // @param id route id of bridge to be used
    // @param optionalNativeAmount optinal native amount, to be used
    // when bridge needs native token along with ERC20
    // @param inputToken token addresss which will be bridged
    // @param data bridgeData to be used by bridge
    */
    struct BridgeRequest {
        uint256 id;
        uint256 optionalNativeAmount;
        address inputToken;
        bytes data;
    }

    /**
    // @param receiverAddress Recipient address to recieve funds on destination chain
    // @param toChainId Destination ChainId
    // @param amount amount to be swapped if middlewareId is 0  it will be
    // the amount to be bridged
    // @param middlewareRequest middleware Requestdata
    // @param bridgeRequest bridge request data
    */
    struct UserRequest {
        address receiverAddress;
        uint256 toChainId;
        uint256 amount;
        MiddlewareRequest middlewareRequest;
        BridgeRequest bridgeRequest;
    }

    /**
    // @notice function responsible for calling the respective implementation
    // depending on the bridge to be used
    // If the middlewareId is 0 then no swap is required,
    // we can directly bridge the source token to wherever required,
    // else, we first call the Swap Impl Base for swapping to the required
    // token and then start the bridging
    // @dev It is required for isMiddleWare to be true for route 0 as it is a special case
    // @param _userRequest calldata follows the input data struct
    */
    function outboundTransferTo(UserRequest calldata _userRequest)
        external
        payable;
}
