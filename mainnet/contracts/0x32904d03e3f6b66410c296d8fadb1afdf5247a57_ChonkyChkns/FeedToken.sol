// SPDX-License-Identifier: MIT

pragma solidity >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/math/SafeMath.sol";
import {ChonkyChkns} from "./ChonkyChkns.sol";

interface IFeedToken {
    function updateFeedCountOnMint(address _user) external;

    function updateFeedCountOnTransfer(address _from, address _to) external;

    function updateFeedCount(address _user) external;

    function getTotalClaimable(address _user) external view returns (uint256);

    function burn(address _from, uint256 _amount) external;

    function reward(address _user, uint256 _amount) external;

    function spend(address _user, uint256 _amount) external;
}

contract FeedToken is ERC20("Feed", "FEED"), Ownable {
    // CONSTANTS
    uint256 public constant SECONDS_IN_DAY = 86400;

    // settable configs
    uint256 public GENESIS_RATE = 5 ether; // feed / day generated by genesis tokens
    uint256 public STANDARD_RATE = 1 ether; // feed per day generated by normal tokens
    uint256 public FEED_PRODUCTION_END_DATE; // date feed production ends

    mapping(address => uint256) public feedCount;
    mapping(address => uint256) public lastUpdate;

    ChonkyChkns public chonkyContract;

    // Map of contracts that have the ability to modify feed balances on tokens,
    // to perform tasks such as:
    // - FEED giveaways
    // - spending FEED to buy ChonkyChkns traits (ChonkyChkns's CustomTraitManager will be on the list)
    mapping(address => bool) public balanceModifiersList;

    constructor(address _chonkyChkns) {
        chonkyContract = ChonkyChkns(_chonkyChkns);
        addTrustedContract(_chonkyChkns);
        FEED_PRODUCTION_END_DATE = block.timestamp + 5 * 365 * 24 * 60 * 60;
    }

    function addTrustedContract(address _contract) public onlyOwner {
        balanceModifiersList[_contract] = true;
    }

    function removeTrustedContract(address _contract) external onlyOwner {
        balanceModifiersList[_contract] = false;
    }

    // FEED COUNT UPDATE FUNCTIONS

    // Called specifically when minting tokens.
    function updateFeedCountOnMint(address _user) external {
        require(_msgSender() == address(chonkyContract), "Can't call this");
        uint256 time = Math.min(block.timestamp, FEED_PRODUCTION_END_DATE);
        _updateFeedCountAtTime(_user, time);
    }

    // Called specfically when a token is transferring ownership
    function updateFeedCountOnTransfer(address _from, address _to) external {
        require(_msgSender() == address(chonkyContract), "Can't call this");
        uint256 time = Math.min(block.timestamp, FEED_PRODUCTION_END_DATE);
        _updateFeedCountAtTime(_from, time);
        if (_to != address(0)) {
            _updateFeedCountAtTime(_to, time);
        }
    }

    // Can be called at any time to have getTotalClaimable() amount reflected in feedCount() balance.
    function updateFeedCount(address _user) external {
        uint256 time = Math.min(block.timestamp, FEED_PRODUCTION_END_DATE);
        _updateFeedCountAtTime(_user, time);
    }

    // WITHDRAW FUNCTION

    // Withdraw (mint) the current feed balance of a particular address to that address.
    // Pending claimable portion of feed balance is withdrawn as well.
    function withdrawFeed(address _to) external {
        require(_msgSender() == _to, "Can only be called by owner of withdrawing address");
        uint256 feedToBeClaimed = getTotalClaimable(_to);
        if (feedToBeClaimed > 0) {
            feedCount[_to] = 0;
            lastUpdate[_to] = Math.min(
                block.timestamp,
                FEED_PRODUCTION_END_DATE
            );
            _mint(_to, feedToBeClaimed);
        }
    }

    // FUNCTIONS CALLABLE BY TRUSTED CONTRACTS (used for FEED gamification features)

    function reward(address _user, uint256 _amount) external {
        require(_isTrustedCaller(), "Can only be called by trusted address");
        feedCount[_user] = getTotalClaimable(_user) + _amount;
        lastUpdate[_user] = Math.min(block.timestamp, FEED_PRODUCTION_END_DATE);
    }

    function spend(address _user, uint256 _amount) external {
        require(_isTrustedCaller(), "Can only be called by trusted address");

        uint256 currentBalance = getTotalClaimable(_user);
        // Amount in excess of user's feedCount balance that needs to be burned from their wallet.
        uint256 feedCountDiff = _amount - Math.min(_amount, currentBalance);
        if (feedCountDiff > 0) {
            _burn(_user, feedCountDiff);
        }
        // Set feed count based on remaining amount that needs to be spent from balance
        feedCount[_user] = currentBalance + feedCountDiff - _amount;
        lastUpdate[_user] = Math.min(block.timestamp, FEED_PRODUCTION_END_DATE);
    }

    function burn(address _from, uint256 _amount) external {
        require(_isTrustedCaller(), "Can only be called by trusted address");
        _burn(_from, _amount);
    }

    // VIEW FUNCTIONS

    function getTotalClaimable(address _user) public view returns (uint256) {
        // lastUpdate[_user] is upper bounded by FEED_PRODUCTION_END_DATE - this will not underflow
        uint256 timeSinceLastUpdate;
        unchecked {
            timeSinceLastUpdate =
                Math.min(block.timestamp, FEED_PRODUCTION_END_DATE) -
                lastUpdate[_user];
        }

        uint256 numGenesisOwned = chonkyContract.numGenesisOwned(_user);
        uint256 numStandardOwned = chonkyContract.numStandardOwned(_user);
        uint256 genesisPending = numGenesisOwned > 0
            ? _getPendingFeed(
                numGenesisOwned,
                GENESIS_RATE,
                timeSinceLastUpdate
            )
            : 0;
        uint256 normalPending = numStandardOwned > 0
            ? _getPendingFeed(
                numStandardOwned,
                STANDARD_RATE,
                timeSinceLastUpdate
            )
            : 0;
        return feedCount[_user] + genesisPending + normalPending;
    }

    // INTERNAL FUNCTIONS

    function _isTrustedCaller() internal view returns (bool) {
        return balanceModifiersList[_msgSender()];
    }

    function _updateFeedCountAtTime(address _user, uint256 time) internal {
        uint256 lastUpdateTime = lastUpdate[_user];
        if (lastUpdateTime > 0) {
            uint256 numGenesisOwned = chonkyContract.numGenesisOwned(_user);
            uint256 numStandardOwned = chonkyContract.numStandardOwned(_user);
            uint256 timeSinceLastUpdate = time - lastUpdateTime;
            uint256 totalPending;
            // Non-zero conditionals - Slight optimization for those only holding one token type
            if (numGenesisOwned > 0) {
                totalPending += _getPendingFeed(
                    numGenesisOwned,
                    GENESIS_RATE,
                    timeSinceLastUpdate
                );
            }
            if (numStandardOwned > 0) {
                totalPending += _getPendingFeed(
                    numStandardOwned,
                    STANDARD_RATE,
                    timeSinceLastUpdate
                );
            }
            feedCount[_user] += totalPending;
        }
        lastUpdate[_user] = time;
    }

    // get number of feed pending given number of chkn tokens, feed rate per day, time elapsed
    function _getPendingFeed(
        uint256 _numTokens,
        uint256 _rate,
        uint256 _timeElapsed
    ) internal pure returns (uint256) {
        return _numTokens * ((_rate * _timeElapsed) / SECONDS_IN_DAY);
    }
}
