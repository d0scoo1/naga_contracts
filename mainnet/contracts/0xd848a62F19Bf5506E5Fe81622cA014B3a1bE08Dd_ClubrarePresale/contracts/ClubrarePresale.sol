// SPDX-License-Identifier: MIT
pragma solidity ^0.8.7;
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title ClubrarePresale
 * @notice It distributes MPWR tokens to ILO users.
 */
contract ClubrarePresale is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, PausableUpgradeable {
    using SafeMathUpgradeable for uint256;
    using SafeERC20Upgradeable for IERC20Upgradeable;

    IERC20Upgradeable public mpwrToken;

    /// @dev Prasale active / inactive
    bool public saleActive;

    /// @dev Merkle root for a whitelist users
    bytes32 private merkleRoot;

    /// @dev Price to participate in presale
    uint256 public tokenPrice;

    /// @dev How many tokens user will get in Presale
    uint256 public tokenPerUser;

    /// @dev Total ETH Raised in Presale
    uint256 public totalRaised;

    /// @dev User info who participated in Presale
    struct UserInfo {
        uint256 tokensClaimed;
        uint256 startTime;
        uint256 endTime;
        uint256 lastClaimedTime;
        uint256 tokenPerSeconds;
        uint256 tokenPerUser;
        bool isDone;
    }
    mapping(address => UserInfo) public userInfo;

    event Claimed(address indexed user, uint256 claimAmount);
    event Harvest(address indexed user, uint256 amount);
    event Withdraw(address indexed user, uint256 amount);
    event WithdrawToken(address indexed user, uint256 amount);

    /**
     * @notice Initializer
     *
     * @param _mpwrToken MPWR token address
     */
    function initialize(address _mpwrToken) external initializer {
        require(_mpwrToken != address(0), "Invalid token address");

        __Context_init();
        __Ownable_init();
        __ReentrancyGuard_init();
        __Pausable_init();

        mpwrToken = IERC20Upgradeable(_mpwrToken);
        tokenPrice = 1 ether;
        tokenPerUser = 100 ether;

        _pause();
    }

    /**
     * @notice Update Merkel Root to Whitelist users
     * @param _merkleRoot for whitelist users
     */
    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {
        merkleRoot = _merkleRoot;
    }

    /**
     * @notice Update Token Price
     * @param _tokenPrice Eth price for Presale
     */
    function updateTokenPrice(uint256 _tokenPrice) external onlyOwner {
        tokenPrice = _tokenPrice;
    }

    /**
     * @notice Update Token per User
     * @param _tokenPerUser MPWR token for per user
     */
    function updateTokenPerUser(uint256 _tokenPerUser) external onlyOwner {
        tokenPerUser = _tokenPerUser;
    }

    /**
     * @notice Unpause presale
     */
    function unpause() external onlyOwner {
        _unpause();
    }

    /**
     * @notice pause presale
     */
    function pause() external onlyOwner {
        _pause();
    }

    /**
     * @notice on/off presale
     */
    function toggleSale() external onlyOwner {
        saleActive = !saleActive;
    }

    /**
     * @notice get curren active merkel root
     */
    function getMerkleRoot() external view returns (bytes32) {
        return merkleRoot;
    }

    /**
     * @notice check user whitelist or not
     * @param _merkleProof merkelProof generated by MerkelTree for current MerkelRoot
     */
    function checkWhitelist(bytes32[] memory _merkleProof) external view returns (bool) {
        bytes32 sender = keccak256(abi.encodePacked(_msgSender()));
        return MerkleProof.verify(_merkleProof, merkleRoot, sender);
    }

    /**
     * @notice calculate token per seconds for 1 year
     */
    function _getTokenPerSeconds() internal view returns (uint256) {
        return tokenPerUser.div(365).div(24).div(60).div(60);
    }

    /**
     * @notice internal method to calculate Claimable Amount
     * @param _endTime current block time
     * @param _user user address
     * @dev calculate pending rewards from last withdraw time to current time
     */
    function _calculateTokens(uint256 _endTime, address _user) internal view returns (uint256) {
        UserInfo memory uInfo = userInfo[_user];

        uint256 _from = uInfo.lastClaimedTime;
        uint256 _totalTime = _endTime.sub(_from);
        if (_totalTime <= 0) {
            return 0;
        }

        return _totalTime.mul(uInfo.tokenPerSeconds);
    }

    /**
     * @notice Harvest in Presale by current ETH price
     * @param _merkleProof merkelProof generated by MerkelTree for current MerkelRoot to verify its whitelist or not
     * @dev Only whitelist user can harvest and it will give MPWR token set in tokenPerUser
     */
    function harvest(bytes32[] memory _merkleProof) external payable whenNotPaused nonReentrant {
        require(saleActive, "Sale is not active");

        UserInfo storage uInfo = userInfo[_msgSender()];

        require(!uInfo.isDone, "Already Participated");
        require(msg.value == tokenPrice, "Wrong Value!");

        bytes32 sender = keccak256(abi.encodePacked(_msgSender()));
        require(MerkleProof.verify(_merkleProof, merkleRoot, sender), "You are not whitelisted");

        uInfo.startTime = block.timestamp;
        uInfo.endTime = block.timestamp + 365 days;
        uInfo.lastClaimedTime = block.timestamp;
        uInfo.tokenPerSeconds = _getTokenPerSeconds();
        uInfo.tokenPerUser = tokenPerUser;
        uInfo.isDone = true;

        totalRaised += msg.value;

        emit Harvest(_msgSender(), msg.value);
    }

    /**
     * @notice Claim Rewards
     * @dev User who harvest can claim their rewards in MPWR for 1 year
     */
    function claimReward() external whenNotPaused nonReentrant {
        UserInfo storage uInfo = userInfo[_msgSender()];

        require(uInfo.isDone, "You are not eligible to claim this rewards!");
        require(uInfo.endTime > uInfo.lastClaimedTime, "You already claimed!");

        uint256 endTime = block.timestamp;
        if (endTime > uInfo.endTime) {
            endTime = uInfo.endTime;
        }
        uint256 _rewards = _calculateTokens(endTime, _msgSender());
        require(_rewards > 0, "Not available to claim");

        uInfo.lastClaimedTime = endTime;
        uInfo.tokensClaimed += _rewards;

        mpwrToken.safeTransfer(_msgSender(), _rewards);

        emit Claimed(_msgSender(), _rewards);
    }

    /**
     * @notice Calculate Claimable Amount
     * @param _user userAddress to calculate Tokens
     */
    function calculateTokens(address _user) external view returns (uint256) {
        UserInfo memory uInfo = userInfo[_user];

        if (!uInfo.isDone) {
            return 0;
        }
        if (uInfo.endTime <= uInfo.lastClaimedTime) {
            return 0;
        }

        uint256 _endTime = block.timestamp;
        if (_endTime > uInfo.endTime) {
            _endTime = uInfo.endTime;
        }

        return _calculateTokens(_endTime, _user);
    }

    /**
     * @notice Withdraw ETH balance raised in contract
     * @param _to address where to withdraw
     */
    function withdraw(address _to) external onlyOwner {
        require(_to != address(0), "address is invalid");

        payable(_to).transfer(address(this).balance);
        emit Withdraw(_to, address(this).balance);
    }

    /**
     * @notice Withdraw MPWR token from contract
     * @param _to address where to withdraw
     */
    function withdrawToken(address _to) external onlyOwner {
        require(_to != address(0), "address is invalid");

        mpwrToken.safeTransfer(_to, mpwrToken.balanceOf(address(this)));
        emit WithdrawToken(_to, mpwrToken.balanceOf(address(this)));
    }
}
