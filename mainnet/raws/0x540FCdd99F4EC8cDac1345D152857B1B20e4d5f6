{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/storage/Home_Storage/src/Unification/github.com/xfund-vor/contracts/dev/BlockhashStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.12;\\n\\n/**\\n * @title BlockhashStore\\n * @notice This contract provides a way to access blockhashes older than\\n *   the 256 block limit imposed by the BLOCKHASH opcode.\\n *   You may assume that any blockhash stored by the contract is correct.\\n *   Note that the contract depends on the format of serialized Ethereum\\n *   blocks. If a future hardfork of Ethereum changes that format, the\\n *   logic in this contract may become incorrect and an updated version\\n *   would have to be deployed.\\n */\\ncontract BlockhashStore {\\n    mapping(uint256 => bytes32) internal _sBlockhashes;\\n\\n    /**\\n     * @notice stores blockhash of the earliest block still available through BLOCKHASH.\\n     */\\n    function storeEarliest() external {\\n        store(block.number - 256);\\n    }\\n\\n    /**\\n     * @notice gets a blockhash from the store. If no hash is known, this function reverts.\\n     * @param n the number of the block whose blockhash should be returned\\n     */\\n    function getBlockhash(uint256 n) external view returns (bytes32) {\\n        bytes32 h = _sBlockhashes[n];\\n        require(h != 0x0, \\\"blockhash not found in store\\\");\\n        return h;\\n    }\\n\\n    /**\\n     * @notice stores blockhash of a given block, assuming it is available through BLOCKHASH\\n     * @param n the number of the block whose blockhash should be stored\\n     */\\n    function store(uint256 n) public {\\n        bytes32 h = blockhash(n);\\n        require(h != 0x0, \\\"blockhash(n) failed\\\");\\n        _sBlockhashes[n] = h;\\n    }\\n\\n    /**\\n     * @notice stores blockhash after verifying blockheader of child/subsequent block\\n     * @param n the number of the block whose blockhash should be stored\\n     * @param header the rlp-encoded blockheader of block n+1. We verify its correctness by checking\\n     *   that it hashes to a stored blockhash, and then extract parentHash to get the n-th blockhash.\\n     */\\n    function storeVerifyHeader(uint256 n, bytes memory header) public {\\n        require(\\n            keccak256(header) == _sBlockhashes[n + 1],\\n            \\\"header has unknown blockhash\\\"\\n        );\\n\\n        // At this point, we know that header is the correct blockheader for block n+1.\\n\\n        // The header is an rlp-encoded list. The head item of that list is the 32-byte blockhash of the parent block.\\n        // Based on how rlp works, we know that blockheaders always have the following form:\\n        // 0xf9____a0PARENTHASH...\\n        //   ^ ^   ^\\n        //   | |   |\\n        //   | |   +--- PARENTHASH is 32 bytes. rlpenc(PARENTHASH) is 0xa || PARENTHASH.\\n        //   | |\\n        //   | +--- 2 bytes containing the sum of the lengths of the encoded list items\\n        //   |\\n        //   +--- 0xf9 because we have a list and (sum of lengths of encoded list items) fits exactly into two bytes.\\n        //\\n        // As a consequence, the PARENTHASH is always at offset 4 of the rlp-encoded block header.\\n\\n        bytes32 parentHash;\\n        assembly {\\n            parentHash := mload(add(header, 36)) // 36 = 32 byte offset for length prefix of ABI-encoded array\\n            //    +  4 byte offset of PARENTHASH (see above)\\n        }\\n\\n        _sBlockhashes[n] = parentHash;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getBlockhash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"store\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storeEarliest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"header\",\"type\":\"bytes\"}],\"name\":\"storeVerifyHeader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BlockhashStore", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}