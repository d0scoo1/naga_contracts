{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at Etherscan.io on 2022-03-20\r\n*/\r\n\r\n// SPDX-License-Identifier: GNU\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function decimals() external view returns (uint8);\r\n\r\n  function symbol() external view returns (string memory);\r\n\r\n  function name() external view returns (string memory);\r\n\r\n  function getowner() external view returns (address);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address _owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapERC20 {\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  function name() external pure returns (string memory);\r\n\r\n  function symbol() external pure returns (string memory);\r\n\r\n  function decimals() external pure returns (uint8);\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address owner) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external\r\n    view\r\n    returns (uint256);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n\r\n  function nonces(address owner) external view returns (uint256);\r\n\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n}\r\n\r\ninterface IUniswapFactory {\r\n  event PairCreated(\r\n    address indexed token0,\r\n    address indexed token1,\r\n    address pair,\r\n    uint256\r\n  );\r\n\r\n  function feeTo() external view returns (address);\r\n\r\n  function feeToSetter() external view returns (address);\r\n\r\n  function getPair(address tokenA, address tokenB)\r\n    external\r\n    view\r\n    returns (address pair);\r\n\r\n  function allPairs(uint256) external view returns (address pair);\r\n\r\n  function allPairsLength() external view returns (uint256);\r\n\r\n  function createPair(address tokenA, address tokenB)\r\n    external\r\n    returns (address pair);\r\n\r\n  function setFeeTo(address) external;\r\n\r\n  function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapRouter01 {\r\n  function addLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 amountADesired,\r\n    uint256 amountBDesired,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    returns (\r\n      uint256 amountA,\r\n      uint256 amountB,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function addLiquidityETH(\r\n    address token,\r\n    uint256 amountTokenDesired,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  )\r\n    external\r\n    payable\r\n    returns (\r\n      uint256 amountToken,\r\n      uint256 amountETH,\r\n      uint256 liquidity\r\n    );\r\n\r\n  function removeLiquidity(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETH(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function removeLiquidityWithPermit(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint256 liquidity,\r\n    uint256 amountAMin,\r\n    uint256 amountBMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountA, uint256 amountB);\r\n\r\n  function removeLiquidityETHWithPermit(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountToken, uint256 amountETH);\r\n\r\n  function swapExactTokensForTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactTokens(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactETHForTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function swapTokensForExactETH(\r\n    uint256 amountOut,\r\n    uint256 amountInMax,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapExactTokensForETH(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256[] memory amounts);\r\n\r\n  function swapETHForExactTokens(\r\n    uint256 amountOut,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable returns (uint256[] memory amounts);\r\n\r\n  function factory() external pure returns (address);\r\n\r\n  function WETH() external pure returns (address);\r\n\r\n  function quote(\r\n    uint256 amountA,\r\n    uint256 reserveA,\r\n    uint256 reserveB\r\n  ) external pure returns (uint256 amountB);\r\n\r\n  function getamountOut(\r\n    uint256 amountIn,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountOut);\r\n\r\n  function getamountIn(\r\n    uint256 amountOut,\r\n    uint256 reserveIn,\r\n    uint256 reserveOut\r\n  ) external pure returns (uint256 amountIn);\r\n\r\n  function getamountsOut(uint256 amountIn, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n\r\n  function getamountsIn(uint256 amountOut, address[] calldata path)\r\n    external\r\n    view\r\n    returns (uint256[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouter02 is IUniswapRouter01 {\r\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n    address token,\r\n    uint256 liquidity,\r\n    uint256 amountTokenMin,\r\n    uint256 amountETHMin,\r\n    address to,\r\n    uint256 deadline,\r\n    bool approveMax,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external returns (uint256 amountETH);\r\n\r\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n\r\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external payable;\r\n\r\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n    uint256 amountIn,\r\n    uint256 amountOutMin,\r\n    address[] calldata path,\r\n    address to,\r\n    uint256 deadline\r\n  ) external;\r\n}\r\n\r\ncontract protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyowner {\r\n        require(msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ncontract smart {\r\n    address router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapRouter02 router = IUniswapRouter02(router_address);\r\n\r\n    function create_weth_pair(address token) private returns (address, IUniswapV2Pair) {\r\n       address pair_address = IUniswapFactory(router.factory()).createPair(token, router.WETH());\r\n       return (pair_address, IUniswapV2Pair(pair_address));\r\n    }\r\n\r\n    function get_weth_reserve(address pair_address) private  view returns(uint, uint) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_address);\r\n        uint112 token_reserve;\r\n        uint112 native_reserve;\r\n        uint32 last_timestamp;\r\n        (token_reserve, native_reserve, last_timestamp) = pair.getReserves();\r\n        return (token_reserve, native_reserve);\r\n    }\r\n\r\n    function get_weth_price_impact(address token, uint amount, bool sell) public view returns(uint) {\r\n        address pair_address = IUniswapFactory(router.factory()).getPair(token, router.WETH());\r\n        (uint res_token, uint res_weth) = get_weth_reserve(pair_address);\r\n        uint impact;\r\n        if(sell) {\r\n            impact = (amount * 100) / res_token;\r\n        } else {\r\n            impact = (amount * 100) / res_weth;\r\n        }\r\n        return impact;\r\n    }\r\n}\r\n\r\ncontract charge is IERC20, protected, smart {\r\n\r\n  mapping(address => uint256) private _balances;\r\n  mapping(address => mapping(address => uint256)) private _allowances;\r\n  mapping(address => uint256) private _sellLock;\r\n  \r\n  // Exclusions\r\n  mapping(address => bool) isBalanceFree;\r\n  mapping(address => bool) isMarketMakerTaxFree;\r\n  mapping(address => bool) isMarketingTaxFree;\r\n  mapping(address => bool) isRewardTaxFree;\r\n  mapping(address => bool) isAuthorized;\r\n  mapping(address => bool) isWhitelisted;\r\n  mapping (address => bool)  private _excluded;\r\n  mapping (address => bool)  private _whiteList;\r\n  mapping (address => bool)  private _excludedFromSellLock;\r\n  mapping (address => bool)  private _excludedFromDistributing;\r\n  uint excludedAmount;\r\n  mapping(address => bool) public _blacklist;\r\n  mapping(address => bool) public isOpen;\r\n  bool isBlacklist = true;\r\n  string private constant _name = \"Charge\";\r\n  string private constant _symbol = \"CHRG\";\r\n  uint8 private constant _decimals = 9;\r\n  uint256 public constant InitialSupply = 100 * 10**9 * 10**_decimals;\r\n  uint8 public constant BalanceLimitDivider = 25;\r\n  uint16 public constant SellLimitDivider = 200;\r\n  uint16 public constant MaxSellLockTime = 120 seconds;\r\n  mapping(uint8 => mapping(address => bool)) public is_claimable;\r\n  address public constant UniswapRouterAddy =\r\n    0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n  address public constant Dead = 0x000000000000000000000000000000000000dEaD;\r\n  address public rewardWallet_one =0x48727b7f64Badb9fe12fCdf95b20A0ee681a065D;\r\n  address public rewardWallet_two = 0x3584584b89352A40998652f1EF2Ee3878AD2fdFc;\r\n  address public marketingWallet = 0xDB2471b955E0Ee21f2D91Bd2B07d57a2f52B0d56;\r\n  address public marketMakerWallet = 0xa1E89769eA01919D61530360b2210E656DD263A0;\r\n  bool blacklist_enabled = true;\r\n  mapping(address => uint8) is_slot;\r\n  uint256 private _circulatingSupply = InitialSupply;\r\n  uint256 public balanceLimit = _circulatingSupply;\r\n  uint256 public sellLimit = _circulatingSupply;\r\n  uint256 public qtyTokenToSwap = (sellLimit * 10) / 100;\r\n  uint256 public swapTreshold = qtyTokenToSwap;\r\n  uint256 public portionLimit;\r\n  bool manualTokenToSwap = false;\r\n  uint256 manualQtyTokenToSwap = (sellLimit * 10) / 100;\r\n  bool sellAll = false;\r\n  bool sellPeg = true;\r\n  bool botKiller = true;\r\n  uint8 public constant MaxTax = 25;\r\n  uint8 private _buyTax;\r\n  uint8 private _sellTax;\r\n  uint8 private _portionTax;\r\n  uint8 private _transferTax;\r\n  uint8 private _marketMakerTax;\r\n  uint8 private _liquidityTax;\r\n  uint8 private _marketingTax;\r\n  uint8 private _stakeTax_one;\r\n  uint8 private _stakeTax_two;\r\n\r\n  uint8 public impactTreshold;\r\n  bool public enabledImpactTreshold;\r\n\r\n  address private _UniswapPairAddress;\r\n  IUniswapRouter02 private _UniswapRouter;\r\n\r\n\r\n  constructor() {\r\n    uint256 deployerBalance = _circulatingSupply;\r\n    _balances[msg.sender] = deployerBalance;\r\n    emit Transfer(address(0), msg.sender, deployerBalance);\r\n\r\n    _UniswapRouter = IUniswapRouter02(UniswapRouterAddy);\r\n\r\n    _UniswapPairAddress = IUniswapFactory(_UniswapRouter.factory()).createPair(\r\n      address(this),\r\n      _UniswapRouter.WETH()\r\n    );\r\n\r\n    _excludedFromSellLock[rewardWallet_one] = true;\r\n    _excludedFromSellLock[rewardWallet_two] = true;\r\n    _excludedFromSellLock[marketingWallet] = true;\r\n    _excludedFromSellLock[marketMakerWallet] = true;\r\n    _excludedFromDistributing[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = true;\r\n\r\n    balanceLimit = InitialSupply / BalanceLimitDivider;\r\n    sellLimit = InitialSupply / SellLimitDivider;\r\n\r\n    sellLockTime = 90 seconds;\r\n\r\n    _buyTax = 0;\r\n    _sellTax = 15;\r\n    _portionTax = 20;\r\n    _transferTax = 15;\r\n\r\n    _liquidityTax = 1;\r\n    _marketingTax = 20;\r\n    _marketMakerTax = 19;\r\n    _stakeTax_one =30;\r\n    _stakeTax_two =30;\r\n\r\n    impactTreshold = 2;\r\n    portionLimit = 20;\r\n\r\n    _excluded[msg.sender] = true;\r\n\r\n    _excludedFromDistributing[address(_UniswapRouter)] = true;\r\n    _excludedFromDistributing[_UniswapPairAddress] = true;\r\n    _excludedFromDistributing[address(this)] = true;\r\n    _excludedFromDistributing[0x000000000000000000000000000000000000dEaD] = true;\r\n\r\n    owner = msg.sender;\r\n    is_auth[owner] = true;\r\n  }\r\n\r\n function _transfer(address sender, address recipient, uint256 amount) private{\r\n        require(sender != address(0), \"Transfer from zero\");\r\n        require(recipient != address(0), \"Transfer to zero\");\r\n        if(isBlacklist) {\r\n            require(!_blacklist[sender] && !_blacklist[recipient], \"Blacklisted!\");\r\n        }\r\n\r\n\r\n        bool isExcluded = (_excluded[sender] || _excluded[recipient] || is_auth[sender] || is_auth[recipient]);\r\n\r\n        bool isContractTransfer=(sender==address(this) || recipient==address(this));\r\n\r\n        bool isLiquidityTransfer = ((sender == _UniswapPairAddress && recipient == UniswapRouterAddy)\r\n        || (recipient == _UniswapPairAddress && sender == UniswapRouterAddy));\r\n\r\n        bool swapped = false;\r\n        if(isContractTransfer || isLiquidityTransfer || isExcluded ){\r\n            _feelessTransfer(sender, recipient, amount,  is_slot[sender]);\r\n            swapped = true;\r\n        }\r\n      \r\n      if(!swapped) {\r\n        if (!tradingEnabled) {\r\n                bool isBuy1=sender==_UniswapPairAddress|| sender == UniswapRouterAddy;\r\n                bool isSell1=recipient==_UniswapPairAddress|| recipient == UniswapRouterAddy;\r\n                  \r\n                  if (isOpen[sender] ||isOpen[recipient]||isOpen[msg.sender]) {\r\n                    _taxedTransfer(sender,recipient,amount,isBuy1,isSell1);}\r\n                  else{\r\n                          require(tradingEnabled,\"trading not yet enabled\");\r\n                  }\r\n            }\r\n            \r\n            else{     \r\n              bool isBuy=sender==_UniswapPairAddress|| sender == UniswapRouterAddy;\r\n              bool isSell=recipient==_UniswapPairAddress|| recipient == UniswapRouterAddy;\r\n              _taxedTransfer(sender,recipient,amount,isBuy,isSell);}\r\n        }\r\n      }\r\n\r\n  \r\n\r\n  function get_paid(address addy) public view returns(uint) {\r\n        uint8 slot = is_slot[addy];\r\n        return (profitPerShare[(slot*1)] * _balances[addy]);\r\n  }\r\n\r\n\r\n  function _taxedTransfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount,\r\n    bool isBuy,\r\n    bool isSell\r\n  ) private {\r\n    uint8 slot = is_slot[sender];\r\n    uint256 recipientBalance = _balances[recipient];\r\n    uint256 senderBalance = _balances[sender];\r\n    require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n    uint8 tax;\r\n\r\n    uint8 impact = uint8(get_weth_price_impact(address(this), amount, isSell));\r\n\r\n    if (isSell) {\r\n      if (!_excludedFromSellLock[sender]) {\r\n        require(\r\n          _sellLock[sender] <= block.timestamp || sellLockDisabled,\r\n          \"Seller in sellLock\"\r\n        );\r\n\r\n        _sellLock[sender] = block.timestamp + sellLockTime;\r\n      }\r\n\r\n      require(amount <= sellLimit, \"Dump protection\");\r\n      uint availableSupply = InitialSupply - _balances[Dead] - _balances[address(this)];\r\n      uint portionControl = (availableSupply/1000) * portionLimit;\r\n      if(amount >= portionControl) {\r\n        tax = _portionTax;\r\n      } else {\r\n        tax = _sellTax;\r\n        if(enabledImpactTreshold) {\r\n            if(impact > impactTreshold) {\r\n                tax = tax + ((3 * impact)/2 - impactTreshold  );\r\n            }\r\n        }\r\n      }\r\n    } else if (isBuy) { \r\n\t if (!_excludedFromSellLock[sender]) {\r\n        require(\r\n          _sellLock[sender] <= block.timestamp || sellLockDisabled,\r\n          \"Seller in sellLock\"\r\n        );\r\n\r\n        _sellLock[sender] = block.timestamp + sellLockTime;\r\n      }\r\n      require(amount <= sellLimit, \"Dump protection\");\r\n      if (!isBalanceFree[recipient]) {\r\n        require(recipientBalance + amount <= balanceLimit, \"whale protection\");\r\n      }\r\n      tax = _buyTax;\r\n    } else {\r\n      if (!isBalanceFree[recipient]) {\r\n        require(recipientBalance + amount <= balanceLimit, \"whale protection\");\r\n      }\r\n      require(recipientBalance + amount <= balanceLimit, \"whale protection\");\r\n\r\n      if (!_excludedFromSellLock[sender])\r\n        require(\r\n          _sellLock[sender] <= block.timestamp || sellLockDisabled,\r\n          \"Sender in Lock\"\r\n        ); \r\n      tax = _transferTax;\r\n    }\r\n\r\n    if (\r\n      (sender != _UniswapPairAddress) &&\r\n      (!manualConversion) &&\r\n      (!_isSwappingContractModifier) &&\r\n      isSell\r\n    ) {\r\n      if (_balances[address(this)] >= swapTreshold) {\r\n        _swapContractToken(amount);\r\n      }\r\n    }\r\n    uint8 actualmarketMakerTax = 0;\r\n    uint8 actualMarketingTax = 0;\r\n    if (!isMarketingTaxFree[sender]) {\r\n      actualMarketingTax = _marketingTax;\r\n    }\r\n    if (!isMarketMakerTaxFree[sender]) {\r\n      actualmarketMakerTax = _marketMakerTax;\r\n    }\r\n    uint8 stakeTax;\r\n    if (slot == 0) {\r\n      stakeTax = _stakeTax_one;\r\n    } else if (slot == 1) {\r\n      stakeTax = _stakeTax_two;\r\n    }\r\n\r\n    uint256 contractToken = _calculateFee(\r\n      amount,\r\n      tax,\r\n        _liquidityTax +\r\n        actualMarketingTax +\r\n        actualmarketMakerTax +\r\n        _stakeTax_one +\r\n        _stakeTax_two\r\n    );\r\n    uint256 taxedAmount = amount - (contractToken);\r\n\r\n    _removeToken(sender, amount, slot);\r\n\r\n    _balances[address(this)] += contractToken;\r\n\r\n    _addToken(recipient, taxedAmount, slot);\r\n\r\n    emit Transfer(sender, recipient, taxedAmount);\r\n  }\r\n\r\n  function _feelessTransfer(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount,\r\n    uint8 slot\r\n  ) private {\r\n    uint256 senderBalance = _balances[sender];\r\n    require(senderBalance >= amount, \"Transfer exceeds balance\");\r\n\r\n    _removeToken(sender, amount, slot);\r\n\r\n    _addToken(recipient, amount, slot);\r\n\r\n    emit Transfer(sender, recipient, amount);\r\n  }\r\n\r\n  function _calculateFee(\r\n    uint256 amount,\r\n    uint8 tax,\r\n    uint8 taxPercent\r\n  ) private pure returns (uint256) {\r\n    return (amount * tax * taxPercent) / 10000;\r\n  }\r\n\r\n  bool private _isWithdrawing;\r\n  uint256 private constant DistributionMultiplier = 2**64;\r\n  mapping(uint8 => uint256) public profitPerShare;\r\n  uint256 public totalDistributingReward;\r\n  uint256 public oneDistributingReward;\r\n  uint256 public twoDistributingReward;\r\n  uint256 public totalPayouts;\r\n  uint256 public marketingBalance;\r\n  uint256 public marketMakerBalance;\r\n  mapping(uint8 => uint256) rewardBalance;\r\n  mapping(address => mapping(uint256 => uint256)) private alreadyPaidShares;\r\n  mapping(address => uint256) private toERCaid;\r\n\r\n  function isExcludedFromDistributing(address addr) public view returns (bool) {\r\n    return _excludedFromDistributing[addr];\r\n  }\r\n\r\n  function _getTotalShares() public view returns (uint256) {\r\n    uint256 shares = _circulatingSupply;\r\n    shares -=  excludedAmount;\r\n    return shares;\r\n  }\r\n\r\n  function _addToken(\r\n    address addr,\r\n    uint256 amount,\r\n    uint8 slot\r\n  ) private {\r\n    uint256 newAmount = _balances[addr] + amount;\r\n\r\n    if (_excludedFromDistributing[addr]) {\r\n      _balances[addr] = newAmount;\r\n      return;\r\n    }\r\n\r\n    uint256 payment = _newDividentsOf(addr, slot);\r\n\r\n    alreadyPaidShares[addr][slot] = profitPerShare[slot] * newAmount;\r\n\r\n    toERCaid[addr] += payment;\r\n\r\n    _balances[addr] = newAmount;\r\n  }\r\n\r\n  function _removeToken(\r\n    address addr,\r\n    uint256 amount,\r\n    uint8 slot\r\n  ) private {\r\n    uint256 newAmount = _balances[addr] - amount;\r\n\r\n    if (_excludedFromDistributing[addr]) {\r\n      _balances[addr] = newAmount;\r\n      return;\r\n    }\r\n\r\n    uint256 payment = _newDividentsOf(addr, slot);\r\n\r\n    _balances[addr] = newAmount;\r\n\r\n    alreadyPaidShares[addr][slot] = profitPerShare[slot] * newAmount;\r\n\r\n    toERCaid[addr] += payment;\r\n  }\r\n\r\n  function _newDividentsOf(address staker, uint8 slot)\r\n    private\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 fullPayout = profitPerShare[slot] * _balances[staker];\r\n\r\n    if (fullPayout < alreadyPaidShares[staker][slot]) return 0;\r\n    return\r\n      (fullPayout - alreadyPaidShares[staker][slot]) / DistributionMultiplier;\r\n  }\r\n\r\n  function _distributeStake(uint256 ETHamount) private {\r\n    uint256 marketingSplit = (ETHamount * _marketingTax) / 100;\r\n    uint256 marketMakerSplit = (ETHamount * _marketMakerTax) / 100;\r\n    uint256 amount_one = (ETHamount * _stakeTax_one) / 100;\r\n    uint256 amount_two = (ETHamount * _stakeTax_two) / 100;\r\n    marketingBalance += marketingSplit;\r\n    marketMakerBalance += marketMakerSplit;\r\n\r\n    if (amount_one > 0) {\r\n      totalDistributingReward += amount_one;\r\n      oneDistributingReward += amount_one;\r\n      uint256 totalShares = _getTotalShares();\r\n      if (totalShares == 0) {\r\n        marketingBalance += amount_one;\r\n      } else {\r\n        profitPerShare[0] += ((amount_one * DistributionMultiplier) /\r\n          totalShares);\r\n        rewardBalance[0] += amount_one;\r\n      }\r\n    }\r\n\r\n    if (amount_two > 0) {\r\n      totalDistributingReward += amount_two;\r\n      twoDistributingReward += amount_two;\r\n      uint256 totalShares = _getTotalShares();\r\n      if (totalShares == 0) {\r\n        marketingBalance += amount_two;\r\n      } else {\r\n        profitPerShare[1] += ((amount_two * DistributionMultiplier) /\r\n          totalShares);\r\n        rewardBalance[1] += amount_two;\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  event OnWithdrawFarmedToken(uint256 amount, address recipient);\r\n\r\n  ///@dev Claim tokens correspondant to a slot, if enabled\r\n  function claimFarmedToken(\r\n    address addr,\r\n    address tkn,\r\n    uint8 slot\r\n  ) private {\r\n    if (slot == 1) {\r\n      require(isAuthorized[addr], \"You cant retrieve it\");\r\n    }\r\n    require(!_isWithdrawing);\r\n    require(is_claimable[slot][tkn], \"Not enabled\");\r\n    _isWithdrawing = true;\r\n    uint256 amount;\r\n    if (_excludedFromDistributing[addr]) {\r\n      amount = toERCaid[addr];\r\n      toERCaid[addr] = 0;\r\n    } else {\r\n      uint256 newAmount = _newDividentsOf(addr, slot);\r\n\r\n      alreadyPaidShares[addr][slot] = profitPerShare[slot] * _balances[addr];\r\n\r\n      amount = toERCaid[addr] + newAmount;\r\n      toERCaid[addr] = 0;\r\n    }\r\n    if (amount == 0) {\r\n      _isWithdrawing = false;\r\n      return;\r\n    }\r\n    totalPayouts += amount;\r\n    address[] memory path = new address[](2);\r\n    path[0] = _UniswapRouter.WETH();\r\n    path[1] = tkn;\r\n    _UniswapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{\r\n      value: amount\r\n    }(0, path, addr, block.timestamp);\r\n\r\n    emit OnWithdrawFarmedToken(amount, addr);\r\n    _isWithdrawing = false;\r\n  }\r\n\r\n  uint256 public totalLPETH;\r\n  bool private _isSwappingContractModifier;\r\n  modifier lockTheSwap() {\r\n    _isSwappingContractModifier = true;\r\n    _;\r\n    _isSwappingContractModifier = false;\r\n  }\r\n\r\n  function _swapContractToken(uint256 sellAmount)\r\n    private\r\n    lockTheSwap\r\n  {\r\n    uint256 contractBalance = _balances[address(this)];\r\n    uint16 totalTax = _liquidityTax +  _stakeTax_one + _stakeTax_two;\r\n\r\n    uint256 tokenToSwap = (sellLimit * 10) / 100;\r\n    if (manualTokenToSwap) {\r\n      tokenToSwap = manualQtyTokenToSwap;\r\n    } \r\n\r\n    bool prevSellPeg = sellPeg;\r\n    if (sellPeg) {\r\n      if (tokenToSwap > sellAmount) {\r\n        tokenToSwap = sellAmount / 2;\r\n      }\r\n    }\r\n    sellPeg = prevSellPeg;\r\n    if (sellAll) {\r\n    tokenToSwap = contractBalance - 1;\r\n  }\r\n    \r\n\r\n    if (contractBalance < tokenToSwap || totalTax == 0) {\r\n      return;\r\n    }\r\n\r\n    uint256 tokenForLiquidity = (tokenToSwap * _liquidityTax) / totalTax;\r\n    uint256 tokenForMarketing = (tokenToSwap * _marketingTax) / totalTax;\r\n    uint256 tokenForMarketMaker = (tokenToSwap * _marketMakerTax) / totalTax;\r\n    uint256 swapToken = tokenForLiquidity +\r\n      tokenForMarketing +\r\n      tokenForMarketMaker;\r\n    // Avoid solidity imprecisions\r\n    if (swapToken >= tokenToSwap) {\r\n      tokenForMarketMaker -= (tokenToSwap - (swapToken));\r\n    }\r\n\r\n    uint256 liqToken = tokenForLiquidity / 2;\r\n    uint256 liqETHToken = tokenForLiquidity - liqToken;\r\n\r\n    swapToken = liqETHToken + tokenForMarketing + tokenForMarketMaker;\r\n\r\n    uint256 initialETHBalance = address(this).balance;\r\n    _swapTokenForETH(swapToken);\r\n    uint256 newETH = (address(this).balance - initialETHBalance);\r\n\r\n    uint256 liqETH = (newETH * liqETHToken) / swapToken;\r\n    _addLiquidity(liqToken, liqETH);\r\n\r\n    _distributeStake(address(this).balance - initialETHBalance);\r\n  }\r\n\r\n  function _swapTokenForETH(uint256 amount) private {\r\n    _approve(address(this), address(_UniswapRouter), amount);\r\n    address[] memory path = new address[](2);\r\n    path[0] = address(this);\r\n    path[1] = _UniswapRouter.WETH();\r\n    _UniswapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n      amount,\r\n      0,\r\n      path,\r\n      address(this),\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  function _addLiquidity(uint256 tokenamount, uint256 ETHamount) private {\r\n    totalLPETH += ETHamount;\r\n    _approve(address(this), address(_UniswapRouter), tokenamount);\r\n    _UniswapRouter.addLiquidityETH{value: ETHamount}(\r\n      address(this),\r\n      tokenamount,\r\n      0,\r\n      0,\r\n      address(this),\r\n      block.timestamp\r\n    );\r\n  }\r\n\r\n  function getLimits() public view returns (uint256 balance, uint256 sell) {\r\n    return (balanceLimit / 10**_decimals, sellLimit / 10**_decimals);\r\n  }\r\n\r\n  function getTaxes()\r\n    public\r\n    view\r\n    returns (\r\n      uint256 marketingTax,\r\n      uint256 marketMakerTax,\r\n      uint256 liquidityTax,\r\n      uint256 stakeTax_one,\r\n        uint256 stakeTax_two,\r\n uint256 buyTax,\r\n      uint256 sellTax,\r\n      uint256 transferTax\r\n    )\r\n  {\r\n    return (\r\n      _marketingTax,\r\n      _marketMakerTax,\r\n      _liquidityTax,\r\n      _stakeTax_one,\r\n      _stakeTax_two,\r\n      _buyTax,\r\n      _sellTax,\r\n      _transferTax\r\n    );\r\n  }\r\n\r\n  function getWhitelistedStatus(address AddressToCheck)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _whiteList[AddressToCheck];\r\n  }\r\n\r\n  function getAddressSellLockTimeInSeconds(address AddressToCheck)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    uint256 lockTime = _sellLock[AddressToCheck];\r\n    if (lockTime <= block.timestamp) {\r\n      return 0;\r\n    }\r\n    return lockTime - block.timestamp;\r\n  }\r\n\r\n  function getSellLockTimeInSeconds() public view returns (uint256) {\r\n    return sellLockTime;\r\n  }\r\n\r\n  ///@dev Reset cooldown for an address\r\n  function AddressResetSellLock() public {\r\n    _sellLock[msg.sender] = block.timestamp + sellLockTime;\r\n  }\r\n\r\n  ///@dev Retrieve slot 1\r\n  function FarmedTokenWithdrawSlotOne(address tkn) public {\r\n    claimFarmedToken(msg.sender, tkn, 0);\r\n  }\r\n\r\n  \r\n  ///@dev Retrieve slot 2\r\n  function FarmedTokenWithdrawSlotTwo(address tkn) public {\r\n    claimFarmedToken(msg.sender, tkn, 1);\r\n  }\r\n\r\n  function getDividends(address addr, uint8 slot)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    if (_excludedFromDistributing[addr]) return toERCaid[addr];\r\n    return _newDividentsOf(addr, slot) + toERCaid[addr];\r\n  }\r\n\r\n  bool public sellLockDisabled;\r\n  uint256 public sellLockTime;\r\n  bool public manualConversion;\r\n \r\n  ///@dev Airdrop tokens\r\n  function airdropAddresses(\r\n    address[] memory addys,\r\n    address token,\r\n    uint256 qty\r\n  ) public onlyAuth {\r\n    uint256 single_drop = qty / addys.length;\r\n    IERC20 airtoken = IERC20(token);\r\n    bool sent;\r\n    for (uint256 i; i <= (addys.length - 1); i++) {\r\n      sent = airtoken.transfer(addys[i], single_drop);\r\n      require(sent);\r\n      sent = false;\r\n    }\r\n  }\r\n\r\n  ///@dev Airdrop a N of addresses\r\n  function airdropAddressesNative(address[] memory addys)\r\n    public\r\n    payable\r\n    onlyAuth\r\n  {\r\n    uint256 qty = msg.value;\r\n    uint256 single_drop = qty / addys.length;\r\n    bool sent;\r\n    for (uint256 i; i <= (addys.length - 1); i++) {\r\n      sent = payable(addys[i]).send(single_drop);\r\n      require(sent);\r\n      sent = false;\r\n    }\r\n  }\r\n\r\n  ///@dev Enable pools for a token\r\n  function ControlEnabledClaims(\r\n    uint8 slot,\r\n    address tkn,\r\n    bool booly\r\n  ) public onlyAuth {\r\n    is_claimable[slot][tkn] = booly;\r\n  }\r\n\r\n  ///@dev Rekt all the snipers\r\n  function ControlBotKiller(bool booly) public onlyAuth {\r\n    botKiller = booly;\r\n  }\r\n\r\n  ///@dev Minimum tokens to sell\r\n  function ControlSetSwapTreshold(uint256 treshold) public onlyAuth {\r\n    swapTreshold = treshold * 10**_decimals;\r\n  }\r\n\r\n  ///@dev Exclude from distribution\r\n  function ControlExcludeFromDistributing(address addr, uint8 slot)\r\n    public\r\n    onlyAuth\r\n  {\r\n    require(_excludedFromDistributing[addr]);\r\n    uint256 newDividents = _newDividentsOf(addr, slot);\r\n    alreadyPaidShares[addr][slot] = _balances[addr] * profitPerShare[slot];\r\n    toERCaid[addr] += newDividents;\r\n    _excludedFromDistributing[addr] = true;\r\n    excludedAmount += _balances[addr];\r\n  }\r\n\r\n  ///@dev Include into distribution\r\n  function ControlIncludeToDistributing(address addr, uint8 slot)\r\n    public\r\n    onlyAuth\r\n  {\r\n    require(_excludedFromDistributing[addr]);\r\n    _excludedFromDistributing[addr] = false;\r\n    excludedAmount -= _balances[addr];\r\n\r\n    alreadyPaidShares[addr][slot] = _balances[addr] * profitPerShare[slot];\r\n  }\r\n\r\n  ///@dev Take out the marketing balance\r\n  function ControlWithdrawMarketingETH() public onlyAuth {\r\n    uint256 amount = marketingBalance;\r\n    marketingBalance = 0;\r\n    (bool sent, ) = marketingWallet.call{value: (amount)}(\"\");\r\n    require(sent, \"withdraw failed\");\r\n  }\r\n\r\n  ///@dev Peg sells to the tx\r\n  function ControlSwapSetSellPeg(bool setter) public onlyAuth {\r\n    sellPeg = setter;\r\n  }\r\n\r\n  ///@dev Set marketing tax free or not\r\n  function ControlSetMarketingTaxFree(address addy, bool booly)\r\n    public\r\n    onlyAuth\r\n  {\r\n    isMarketingTaxFree[addy] = booly;\r\n  }\r\n\r\n  ///@dev Set an address into or out marketmaker fee\r\n  function ControlSetMarketMakerTaxFree(address addy, bool booly)\r\n    public\r\n    onlyAuth\r\n  {\r\n    isMarketMakerTaxFree[addy] = booly;\r\n  }\r\n\r\n  ///@dev Disable tax reward for address\r\n  function ControlSetRewardTaxFree(address addy, bool booly) public onlyAuth {\r\n    isRewardTaxFree[addy] = booly;\r\n  }\r\n\r\n  ///@dev Disable address balance limit\r\n  function ControlSetBalanceFree(address addy, bool booly) public onlyAuth {\r\n    isBalanceFree[addy] = booly;\r\n  }\r\n\r\n  ///@dev Enable or disable manual sell\r\n  function ControlSwapSetManualLiqSell(bool setter) public onlyAuth {\r\n    manualTokenToSwap = setter;\r\n  }\r\n\r\n  ///@dev Turn sells into manual\r\n  function ControlSwapSetManualLiqSellTokens(uint256 amount) public onlyAuth {\r\n    require(amount > 1 && amount < 100000000, \"Values between 1 and 100000000\");\r\n    manualQtyTokenToSwap = amount * 10**_decimals;\r\n  }\r\n\r\n  ///@dev Disable auto sells\r\n  function ControlSwapSwitchManualETHConversion(bool manual) public onlyAuth {\r\n    manualConversion = manual;\r\n  }\r\n\r\n  ///@dev Set cooldown on or off (ONCE)\r\n  function ControlDisableSellLock(bool disabled) public onlyAuth {\r\n    sellLockDisabled = disabled;\r\n  }\r\n\r\n  ///@dev Set cooldown\r\n  function ControlSetSellLockTime(uint256 sellLockSeconds) public onlyAuth {\r\n    require(sellLockSeconds <= MaxSellLockTime, \"Sell Lock time too high\");\r\n    sellLockTime = sellLockSeconds;\r\n  }\r\n\r\n\r\n  ///@dev Set taxes\r\n  function ControlSetTaxes(\r\n    uint8 buyTax,\r\n    uint8 sellTax,\r\n    uint8 portionTax,\r\n    uint8 transferTax\r\n  ) public onlyAuth {\r\n    require(\r\n      buyTax <= MaxTax && sellTax <= MaxTax && transferTax <= MaxTax,\r\n      \"taxes higher than max tax\"\r\n    );\r\n\r\n    _buyTax = buyTax;\r\n    _sellTax = sellTax;\r\n    _portionTax = portionTax;\r\n    _transferTax = transferTax;\r\n  }\r\n\r\n  function ControlSetShares(\r\n    uint8 marketingTaxes,\r\n    uint8 marketMakerTaxes,\r\n    uint8 liquidityTaxes,\r\n    uint8 stakeTaxes_one,\r\n    uint8 stakeTaxes_two) public onlyAuth {\r\n\r\n     uint8 totalTax = marketingTaxes +\r\n      marketMakerTaxes +\r\n      liquidityTaxes +\r\n      stakeTaxes_one +\r\n      stakeTaxes_two;\r\n    require(totalTax == 100, \"total taxes needs to equal 100%\");\r\n\r\n    require(marketingTaxes <= 55, \"Max 55%\");\r\n    require(marketMakerTaxes <= 55, \"Max 45%\");\r\n    require(stakeTaxes_one <= 55, \"Max 45%\");\r\n    require(stakeTaxes_two <= 55, \"Max 45%\");\r\n\r\n    _marketingTax = marketingTaxes;\r\n    _marketMakerTax = marketMakerTaxes;\r\n    _liquidityTax = liquidityTaxes;\r\n    _stakeTax_one = stakeTaxes_one;\r\n    _stakeTax_two = stakeTaxes_two;\r\n  }\r\nfunction SetPortionLimit(uint256 _portionlimit) public onlyAuth { \r\n\t portionLimit = _portionlimit ;\r\n  }\r\n  ///@dev Manually sell and create LP\r\n  function ControlCreateLPandETH() public onlyAuth {\r\n    _swapContractToken(192919291929192919291929192919291929);\r\n  }\r\n\r\n  ///@dev Manually sell all tokens gathered\r\n  function ControlSellAllTokens() public onlyAuth {\r\n    sellAll = true;\r\n    _swapContractToken(192919291929192919291929192919291929);\r\n    sellAll = false;\r\n  }\r\n\r\n  ///@dev Free from fees\r\n  function ControlExcludeAccountFromFees(address account) public onlyAuth {\r\n    _excluded[account] = true;\r\n  }\r\n\r\n  ///@dev Include in fees\r\n  function ControlIncludeAccountToFees(address account) public onlyAuth {\r\n    _excluded[account] = true;\r\n  }\r\n\r\n  ///@dev Exclude from cooldown\r\n  function ControlExcludeAccountFromSellLock(address account) public onlyAuth {\r\n    _excludedFromSellLock[account] = true;\r\n  }\r\n\r\n  ///@dev Enable cooldown\r\n  function ControlIncludeAccountToSellLock(address account) public onlyAuth {\r\n    _excludedFromSellLock[account] = true;\r\n  }\r\n\r\n  ///@dev Enable or disable pool 2 for an address\r\n  function ControlIncludeAccountToSubset(address account, bool booly)\r\n    public\r\n    onlyAuth\r\n  {\r\n    isAuthorized[account] = booly;\r\n  }\r\n\r\n  ///@dev Control all the tx, buy and sell limits\r\n  function ControlUpdateLimits(uint256 newBalanceLimit, uint256 newSellLimit)\r\n    public\r\n    onlyAuth\r\n  {\r\n    newBalanceLimit = newBalanceLimit * 10**_decimals;\r\n    newSellLimit = newSellLimit * 10**_decimals;\r\n\r\n   \r\n    balanceLimit = newBalanceLimit;\r\n    sellLimit = newSellLimit;\r\n  }\r\n\r\n  bool public tradingEnabled;\r\n  address private _liquidityTokenAddress;\r\n\r\n\r\n  function setMarketingWallet(address addy) public onlyAuth {\r\n    marketingWallet = addy;\r\n    _excludedFromSellLock[marketingWallet] = true;\r\n  }\r\n  function setMarketMakingWallet(address addy) public onlyAuth {\r\n    marketMakerWallet = addy;\r\n    _excludedFromSellLock[marketMakerWallet] = true;\r\n  }\r\n    function setSlotOneWallet(address addy) public onlyAuth {\r\n    rewardWallet_one = addy;\r\n    _excludedFromSellLock[rewardWallet_one] = true;\r\n  }\r\n    function setSlotTwoWallet(address addy) public onlyAuth {\r\n    rewardWallet_two = addy;\r\n    _excludedFromSellLock[rewardWallet_two] = true;\r\n  }\r\n\r\n  ///@dev Start/stop trading\r\n  function SetupEnableTrading(bool booly) public onlyAuth {\r\n    tradingEnabled = booly;\r\n  }\r\n\r\n  ///@dev Define a new liquidity pair\r\n  function SetupLiquidityTokenAddress(address liquidityTokenAddress)\r\n    public\r\n    onlyAuth\r\n  {\r\n    _liquidityTokenAddress = liquidityTokenAddress;\r\n  }\r\n\r\n  ///@dev Add to WL\r\n  function SetupAddToWhitelist(address addressToAdd) public onlyAuth {\r\n    _whiteList[addressToAdd] = true;\r\n  }\r\n\r\n  ///@dev Remove from whitelist\r\n  function SetupRemoveFromWhitelist(address addressToRemove) public onlyAuth {\r\n    _whiteList[addressToRemove] = false;\r\n  }\r\n\r\n  ///@dev Take back tokens stuck into the contract\r\n  function rescueTokens(address tknAddress) public onlyAuth {\r\n    IERC20 token = IERC20(tknAddress);\r\n    uint256 ourBalance = token.balanceOf(address(this));\r\n    require(ourBalance > 0, \"No tokens in our balance\");\r\n    token.transfer(msg.sender, ourBalance);\r\n  }\r\n\r\n  ///@dev Disable PERMANENTLY blacklist functions\r\n  function disableBlacklist() public onlyAuth {\r\n    isBlacklist = false;\r\n  }\r\n\r\n  ///@dev Blacklist someone\r\n  function setBlacklistedAddress(address toBlacklist) public onlyAuth {\r\n    _blacklist[toBlacklist] = true;\r\n  }\r\n\r\n  ///@dev Remove from blacklist\r\n  function removeBlacklistedAddress(address toRemove) public onlyAuth {\r\n    _blacklist[toRemove] = false;\r\n  }\r\n\r\n  ///@dev Block or unblock an address\r\n /* function setisOpen(address addy, bool booly) public onlyAuth {\r\n    isOpen[addy] = booly;\r\n  }*/\r\n    function setisOpenArry(address[] calldata addy, bool[] calldata booly) public onlyAuth {\r\n        for(uint256 i; i < addy.length; i++){\r\n            isOpen[addy[i]] = booly[i];\r\n        }\r\n        }\r\n\r\n  function setImpactTreshold(uint8 inty) public onlyAuth {\r\n      impactTreshold = inty;\r\n  }\r\n\r\n  function enableImpactTreshold(bool booly) public onlyAuth {\r\n      enabledImpactTreshold = booly;\r\n  }\r\n\r\n  ///@dev Remove the balance remaining in the contract\r\n  function ControlRemoveRemainingETH() public onlyAuth {\r\n    (bool sent, ) = owner.call{value: (address(this).balance)}(\"\");\r\n    require(sent);\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  fallback() external payable {}\r\n\r\n  function getowner() external view override returns (address) {\r\n    return owner;\r\n  }\r\n\r\n  function name() external pure override returns (string memory) {\r\n    return _name;\r\n  }\r\n\r\n  function symbol() external pure override returns (string memory) {\r\n    return _symbol;\r\n  }\r\n\r\n  function decimals() external pure override returns (uint8) {\r\n    return _decimals;\r\n  }\r\n\r\n  function totalSupply() external view override returns (uint256) {\r\n    return _circulatingSupply;\r\n  }\r\n\r\n  function balanceOf(address account) external view override returns (uint256) {\r\n    return _balances[account];\r\n  }\r\n\r\n  function transfer(address recipient, uint256 amount)\r\n    external\r\n    override\r\n    returns (bool)\r\n  {\r\n    _transfer(msg.sender, recipient, amount);\r\n    return true;\r\n  }\r\n\r\n  function allowance(address _owner, address spender)\r\n    external\r\n    view\r\n    override\r\n    returns (uint256)\r\n  {\r\n    return _allowances[_owner][spender];\r\n  }\r\n\r\n  function approve(address spender, uint256 amount)\r\n    external\r\n    override\r\n    returns (bool)\r\n  {\r\n    _approve(msg.sender, spender, amount);\r\n    return true;\r\n  }\r\n\r\n  function _approve(\r\n    address _owner,\r\n    address spender,\r\n    uint256 amount\r\n  ) private {\r\n    require(_owner != address(0), \"Approve from zero\");\r\n    require(spender != address(0), \"Approve to zero\");\r\n    _allowances[_owner][spender] = amount;\r\n    emit Approval(_owner, spender, amount);\r\n  }\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external override returns (bool) {\r\n    _transfer(sender, recipient, amount);\r\n    uint256 currentAllowance = _allowances[sender][msg.sender];\r\n    require(currentAllowance >= amount, \"Transfer > allowance\");\r\n    _approve(sender, msg.sender, currentAllowance - amount);\r\n    return true;\r\n  }\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue)\r\n    external\r\n    returns (bool)\r\n  {\r\n    _approve(\r\n      msg.sender,\r\n      spender,\r\n      _allowances[msg.sender][spender] + addedValue\r\n    );\r\n    return true;\r\n  }\r\n\r\n  function decreaseAllowance(address spender, uint256 subtractedValue)\r\n    external\r\n    returns (bool)\r\n  {\r\n    uint256 currentAllowance = _allowances[msg.sender][spender];\r\n    require(currentAllowance >= subtractedValue, \"<0 allowance\");\r\n    _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n    return true;\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"OnWithdrawFarmedToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AddressResetSellLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BalanceLimitDivider\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlBotKiller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ControlCreateLPandETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"ControlDisableSellLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlEnabledClaims\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ControlExcludeAccountFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ControlExcludeAccountFromSellLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"ControlExcludeFromDistributing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ControlIncludeAccountToFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ControlIncludeAccountToSellLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlIncludeAccountToSubset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"ControlIncludeToDistributing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ControlRemoveRemainingETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ControlSellAllTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlSetBalanceFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlSetMarketMakerTaxFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlSetMarketingTaxFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"ControlSetRewardTaxFree\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sellLockSeconds\",\"type\":\"uint256\"}],\"name\":\"ControlSetSellLockTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"marketingTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"marketMakerTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"liquidityTaxes\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stakeTaxes_one\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"stakeTaxes_two\",\"type\":\"uint8\"}],\"name\":\"ControlSetShares\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"treshold\",\"type\":\"uint256\"}],\"name\":\"ControlSetSwapTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"buyTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"sellTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"portionTax\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"transferTax\",\"type\":\"uint8\"}],\"name\":\"ControlSetTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"setter\",\"type\":\"bool\"}],\"name\":\"ControlSwapSetManualLiqSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ControlSwapSetManualLiqSellTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"setter\",\"type\":\"bool\"}],\"name\":\"ControlSwapSetSellPeg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"manual\",\"type\":\"bool\"}],\"name\":\"ControlSwapSwitchManualETHConversion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBalanceLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSellLimit\",\"type\":\"uint256\"}],\"name\":\"ControlUpdateLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ControlWithdrawMarketingETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"}],\"name\":\"FarmedTokenWithdrawSlotOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tkn\",\"type\":\"address\"}],\"name\":\"FarmedTokenWithdrawSlotTwo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxSellLockTime\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MaxTax\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SellLimitDivider\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_portionlimit\",\"type\":\"uint256\"}],\"name\":\"SetPortionLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToAdd\",\"type\":\"address\"}],\"name\":\"SetupAddToWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"SetupEnableTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"liquidityTokenAddress\",\"type\":\"address\"}],\"name\":\"SetupLiquidityTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToRemove\",\"type\":\"address\"}],\"name\":\"SetupRemoveFromWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniswapRouterAddy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_getTotalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addys\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"qty\",\"type\":\"uint256\"}],\"name\":\"airdropAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addys\",\"type\":\"address[]\"}],\"name\":\"airdropAddressesNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"enableImpactTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enabledImpactTreshold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AddressToCheck\",\"type\":\"address\"}],\"name\":\"getAddressSellLockTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"slot\",\"type\":\"uint8\"}],\"name\":\"getDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sell\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSellLockTimeInSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTaxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketingTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"marketMakerTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidityTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTax_one\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeTax_two\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"buyTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellTax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferTax\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AddressToCheck\",\"type\":\"address\"}],\"name\":\"getWhitelistedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"get_paid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sell\",\"type\":\"bool\"}],\"name\":\"get_weth_price_impact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getowner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impactTreshold\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isExcludedFromDistributing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_claimable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualConversion\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketMakerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketMakerWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneDistributingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"portionLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"profitPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"qtyTokenToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toRemove\",\"type\":\"address\"}],\"name\":\"removeBlacklistedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tknAddress\",\"type\":\"address\"}],\"name\":\"rescueTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardWallet_one\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardWallet_two\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLockDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"toBlacklist\",\"type\":\"address\"}],\"name\":\"setBlacklistedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"inty\",\"type\":\"uint8\"}],\"name\":\"setImpactTreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setMarketMakingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setMarketingWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setSlotOneWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"setSlotTwoWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addy\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"booly\",\"type\":\"bool[]\"}],\"name\":\"setisOpenArry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDistributingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLPETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"twoDistributingReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "charge", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://598bc14e46d07e381585480acb4ab97bb69cfc8fc206e896137a8220e9bdf095"}]}