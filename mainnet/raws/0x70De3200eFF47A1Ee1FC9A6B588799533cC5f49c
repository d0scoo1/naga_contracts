{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DEI/Pools/DEIPoolLibrary.sol\": {\r\n      \"content\": \"// Be name Khoda\\n// Bime Abolfazl\\n\\n// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.8.0;\\n\\ncontract DEIPoolLibrary {\\n    // Constants for various precisions\\n    uint256 private constant PRICE_PRECISION = 1e6;\\n\\n    constructor() {}\\n\\n    // ================ Structs ================\\n    // Needed to lower stack size\\n      struct MintFractionalDeiParams {\\n        uint256 deusPrice;\\n        uint256 collateralPrice;\\n        uint256 collateralAmount;\\n        uint256 collateralRatio;\\n    }\\n\\n   struct BuybackDeusParams {\\n        uint256 excessCollateralValueD18;\\n        uint256 deusPrice;\\n        uint256 collateralPrice;\\n        uint256 deusAmount;\\n    }\\n\\n    // ================ Functions ================\\n\\n    function calcMint1t1DEI(uint256 col_price, uint256 collateral_amount_d18)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (collateral_amount_d18 * col_price) / (1e6);\\n    }\\n\\n    function calcMintAlgorithmicDEI(\\n        uint256 deus_price_usd,\\n        uint256 deus_amount_d18\\n    ) public pure returns (uint256) {\\n        return (deus_amount_d18 * deus_price_usd) / (1e6);\\n    }\\n\\n    function calcMintFractionalDEI(MintFractionalDeiParams memory params)\\n        public\\n        pure\\n        returns (uint256, uint256)\\n    {\\n        // Since solidity truncates division, every division operation must be the last operation in the equation to ensure minimum error\\n        // The contract must check the proper ratio was sent to mint DEI. We do this by seeing the minimum mintable DEI based on each amount\\n        uint256 c_dollar_value_d18;\\n\\n        // Scoping for stack concerns\\n        {\\n            // USD amounts of the collateral and the DEUS\\n            c_dollar_value_d18 =\\n                (params.collateralAmount * params.collateralPrice) /\\n                (1e6);\\n        }\\n        uint256 calculated_deus_dollar_value_d18 = ((c_dollar_value_d18 *\\n            (1e6)) / params.collateralRatio) - c_dollar_value_d18;\\n\\n        uint256 calculated_deus_needed = (calculated_deus_dollar_value_d18 *\\n            (1e6)) / params.deusPrice;\\n\\n        return (\\n            c_dollar_value_d18 + calculated_deus_dollar_value_d18,\\n            calculated_deus_needed\\n        );\\n    }\\n\\n    function calcRedeem1t1DEI(uint256 col_price_usd, uint256 DEI_amount)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (DEI_amount * (1e6)) / col_price_usd;\\n    }\\n\\n    function calcBuyBackDEUS(BuybackDeusParams memory params)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        // If the total collateral value is higher than the amount required at the current collateral ratio then buy back up to the possible DEUS with the desired collateral\\n        require(\\n            params.excessCollateralValueD18 > 0,\\n            \\\"No excess collateral to buy back!\\\"\\n        );\\n\\n        // Make sure not to take more than is available\\n        uint256 deus_dollar_value_d18 = (params.deusAmount *\\n            (params.deusPrice)) / (1e6);\\n        require(\\n            deus_dollar_value_d18 <= params.excessCollateralValueD18,\\n            \\\"You are trying to buy back more than the excess!\\\"\\n        );\\n\\n        // Get the equivalent amount of collateral based on the market value of DEUS provided\\n        uint256 collateral_equivalent_d18 = (deus_dollar_value_d18 * (1e6)) /\\n            params.collateralPrice;\\n        //collateral_equivalent_d18 = collateral_equivalent_d18.sub((collateral_equivalent_d18.mul(params.buyback_fee)).div(1e6));\\n\\n        return collateral_equivalent_d18;\\n    }\\n\\n    // Returns value of collateral that must increase to reach recollateralization target (if 0 means no recollateralization)\\n    function recollateralizeAmount(\\n        uint256 total_supply,\\n        uint256 global_collateral_ratio,\\n        uint256 global_collat_value\\n    ) public pure returns (uint256) {\\n        uint256 target_collat_value = (total_supply * global_collateral_ratio) /\\n            (1e6); // We want 18 decimals of precision so divide by 1e6; total_supply is 1e18 and global_collateral_ratio is 1e6\\n        // Subtract the current value of collateral from the target value needed, if higher than 0 then system needs to recollateralize\\n        return target_collat_value - global_collat_value; // If recollateralization is not needed, throws a subtraction underflow\\n    }\\n\\n    function calcRecollateralizeDEIInner(\\n        uint256 collateral_amount,\\n        uint256 col_price,\\n        uint256 global_collat_value,\\n        uint256 dei_total_supply,\\n        uint256 global_collateral_ratio\\n    ) public pure returns (uint256, uint256) {\\n        uint256 collat_value_attempted = (collateral_amount * col_price) /\\n            (1e6);\\n        uint256 effective_collateral_ratio = (global_collat_value * (1e6)) /\\n            dei_total_supply; //returns it in 1e6\\n        uint256 recollat_possible = (global_collateral_ratio *\\n            dei_total_supply -\\n            (dei_total_supply * effective_collateral_ratio)) / (1e6);\\n\\n        uint256 amount_to_recollat;\\n        if (collat_value_attempted <= recollat_possible) {\\n            amount_to_recollat = collat_value_attempted;\\n        } else {\\n            amount_to_recollat = recollat_possible;\\n        }\\n\\n        return ((amount_to_recollat * (1e6)) / col_price, amount_to_recollat);\\n    }\\n}\\n\\n//Dar panah khoda\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"excessCollateralValueD18\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deusPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deusAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct DEIPoolLibrary.BuybackDeusParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calcBuyBackDEUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateral_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMint1t1DEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deus_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deus_amount_d18\",\"type\":\"uint256\"}],\"name\":\"calcMintAlgorithmicDEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deusPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralRatio\",\"type\":\"uint256\"}],\"internalType\":\"struct DEIPoolLibrary.MintFractionalDeiParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"calcMintFractionalDEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"col_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dei_total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"}],\"name\":\"calcRecollateralizeDEIInner\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"col_price_usd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DEI_amount\",\"type\":\"uint256\"}],\"name\":\"calcRedeem1t1DEI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"total_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collateral_ratio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"global_collat_value\",\"type\":\"uint256\"}],\"name\":\"recollateralizeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "DEIPoolLibrary", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}