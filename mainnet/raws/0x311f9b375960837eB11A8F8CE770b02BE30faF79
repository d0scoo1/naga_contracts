{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/habibiz/Oil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.7;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// Inspired by Solmate: https://github.com/Rari-Capital/solmate\\n/// Developed originally by 0xBasset\\n/// Upgraded by <redacted>\\n/// Additions by Tsuki Labs: https://tsukiyomigroup.com/ :)\\n\\ncontract Oil {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public impl_;\\n    address public ruler;\\n    address public treasury;\\n    address public uniPair;\\n    address public weth;\\n\\n    uint256 public totalSupply;\\n    uint256 public startingTime;\\n    uint256 public baseTax;\\n    uint256 public minSwap;\\n\\n    bool public paused;\\n    bool public swapping;\\n\\n    ERC721Like public habibi;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    mapping(address => bool) public isMinter;\\n\\n    mapping(uint256 => uint256) public claims;\\n\\n    mapping(address => Staker) internal stakers;\\n\\n    uint256 public sellFee;\\n\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    uint256 public doubleBaseTimestamp;\\n\\n    struct Habibi {\\n        uint256 stakedTimestamp;\\n        uint256 tokenId;\\n    }\\n\\n    struct Staker {\\n        Habibi[] habibiz;\\n        uint256 lastClaim;\\n    }\\n\\n    struct Rescueable {\\n        address revoker;\\n        bool adminAllowedAsRevoker;\\n    }\\n\\n    mapping(address => Rescueable) private rescueable;\\n\\n    address public sushiswapPair;\\n    IUniswapV2Router02 public uniswapV2Router;\\n    IUniswapV2Router02 public sushiswapV2Router;\\n\\n    mapping(address => bool) public excludedFromFees;\\n    mapping(address => bool) public blockList;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"OIL\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"OIL\\\";\\n    }\\n\\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function initialize(address habibi_, address treasury_) external {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n        ruler = msg.sender;\\n        treasury = treasury_;\\n        habibi = ERC721Like(habibi_);\\n        sellFee = 15000;\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external whenNotPaused returns (bool) {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        _transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external whenNotPaused returns (bool) {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        _transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              STAKING\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function habibizOfStaker(address _staker) public view returns (uint256[] memory) {\\n        uint256[] memory tokenIds = new uint256[](stakers[_staker].habibiz.length);\\n        for (uint256 i = 0; i < stakers[_staker].habibiz.length; i++) {\\n            tokenIds[i] = stakers[_staker].habibiz[i].tokenId;\\n        }\\n        return tokenIds;\\n    }\\n\\n    function stakeAll() external whenNotPaused {\\n        uint256[] memory habibiz = ERC721Like(habibi).walletOfOwner(msg.sender);\\n        require(habibiz.length > 0, \\\"Sender has no staked Habibiz\\\");\\n        stake(habibiz);\\n    }\\n\\n    function stake(uint256[] memory _habibiz) public nonReentrant whenNotPaused {\\n        for (uint256 i = 0; i < _habibiz.length; i++) {\\n            require(ERC721Like(habibi).ownerOf(_habibiz[i]) == msg.sender, \\\"At least one Habibi is not owned by you.\\\");\\n\\n            ERC721Like(habibi).transferFrom(msg.sender, address(this), _habibiz[i]);\\n\\n            stakers[msg.sender].habibiz.push(Habibi(block.timestamp, _habibiz[i]));\\n        }\\n    }\\n\\n    function unstakeAll() external nonReentrant whenNotPaused {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        uint256 oilRewards = calculateOilRewards(msg.sender);\\n        uint256[] memory tokenIds = habibizOfStaker(msg.sender);\\n\\n        require(tokenIds.length > 0, \\\"Sender has no staked Habibiz\\\");\\n        require(oilRewards > 0, \\\"No claimable Oil\\\");\\n\\n        for (uint256 i = 0; i < tokenIds.length; i++) {\\n            ERC721Like(habibi).transferFrom(address(this), msg.sender, tokenIds[i]);\\n            tokenIds[i] = stakers[msg.sender].habibiz[i].tokenId;\\n        }\\n        removeHabibiIdsFromStaker(msg.sender, tokenIds);\\n        stakers[msg.sender].lastClaim = block.timestamp;\\n        _mint(msg.sender, oilRewards);\\n    }\\n\\n    function removeHabibiIdsFromStaker(address _staker, uint256[] memory _tokenIds) internal {\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            for (uint256 j = 0; j < stakers[_staker].habibiz.length; j++) {\\n                if (_tokenIds[i] == stakers[_staker].habibiz[j].tokenId) {\\n                    stakers[_staker].habibiz[j] = stakers[_staker].habibiz[stakers[_staker].habibiz.length - 1];\\n                    stakers[_staker].habibiz.pop();\\n                }\\n            }\\n        }\\n    }\\n\\n    function unstakeByIds(uint256[] calldata _tokenIds) external nonReentrant whenNotPaused {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        uint256 oilRewards = calculateOilRewards(msg.sender);\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            bool owned = false;\\n            for (uint256 j = 0; j < stakers[msg.sender].habibiz.length; j++) {\\n                if (stakers[msg.sender].habibiz[j].tokenId == _tokenIds[i]) {\\n                    owned = true;\\n                }\\n            }\\n            require(owned, \\\"TOKEN NOT OWNED BY SENDER\\\");\\n            ERC721Like(habibi).transferFrom(address(this), msg.sender, _tokenIds[i]);\\n        }\\n        removeHabibiIdsFromStaker(msg.sender, _tokenIds);\\n        stakers[msg.sender].lastClaim = block.timestamp;\\n\\n        _mint(msg.sender, oilRewards);\\n    }\\n\\n    function approveRescue(\\n        address revoker_,\\n        bool confirm_,\\n        bool rescueableByAdmin_\\n    ) external {\\n        require(confirm_, \\\"Did not confirm\\\");\\n        require(revoker_ != address(0), \\\"Revoker cannot be null address\\\");\\n        rescueable[msg.sender] = Rescueable(revoker_, rescueableByAdmin_);\\n    }\\n\\n    function revokeRescue(address rescueable_, bool confirm_) external {\\n        if (msg.sender == ruler) {\\n            require(rescueable[rescueable_].adminAllowedAsRevoker, \\\"Admin is not allowed to revoke\\\");\\n        } else {\\n            require(rescueable[rescueable_].revoker == msg.sender, \\\"Sender is not revoker\\\");\\n        }\\n        require(confirm_, \\\"Did not confirm\\\");\\n\\n        delete rescueable[rescueable_];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CLAIMING\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function claim() external nonReentrant whenNotPaused {\\n        require(!blockList[msg.sender], \\\"Address Blocked\\\");\\n        uint256 oil = calculateOilRewards(msg.sender);\\n        if (oil > 0) {\\n            stakers[msg.sender].lastClaim = block.timestamp;\\n            _mint(msg.sender, oil);\\n        } else {\\n            revert(\\\"Not enough oil\\\");\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            OIL REWARDS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function calculateOilRewards(address _staker) public view returns (uint256 oilAmount) {\\n        uint256 balanceBonus = holderBonusPercentage(_staker);\\n        for (uint256 i = 0; i < stakers[_staker].habibiz.length; i++) {\\n            uint256 habibiId = stakers[_staker].habibiz[i].tokenId;\\n            oilAmount =\\n                oilAmount +\\n                calculateOilOfHabibi(\\n                    habibiId,\\n                    stakers[_staker].lastClaim,\\n                    stakers[_staker].habibiz[i].stakedTimestamp,\\n                    block.timestamp,\\n                    balanceBonus,\\n                    doubleBaseTimestamp\\n                );\\n        }\\n    }\\n\\n    function calculateOilOfHabibi(\\n        uint256 _habibiId,\\n        uint256 _lastClaimedTimestamp,\\n        uint256 _stakedTimestamp,\\n        uint256 _currentTimestamp,\\n        uint256 _balanceBonus,\\n        uint256 _doubleBaseTimestamp\\n    ) internal pure returns (uint256 oil) {\\n        uint256 bonusPercentage;\\n        uint256 baseOilMultiplier = 1;\\n        uint256 unclaimedTime;\\n        uint256 stakedTime = _currentTimestamp - _stakedTimestamp;\\n        if (_lastClaimedTimestamp < _stakedTimestamp) {\\n            _lastClaimedTimestamp = _stakedTimestamp;\\n        }\\n\\n        unclaimedTime = _currentTimestamp - _lastClaimedTimestamp;\\n\\n        if (stakedTime >= 15 days || _stakedTimestamp <= _doubleBaseTimestamp) {\\n            baseOilMultiplier = 2;\\n        }\\n\\n        if (stakedTime >= 90 days) {\\n            bonusPercentage = 100;\\n        } else {\\n            for (uint256 i = 2; i < 4; i++) {\\n                uint256 timeRequirement = 15 days * i;\\n                if (timeRequirement > 0 && timeRequirement <= stakedTime) {\\n                    bonusPercentage = bonusPercentage + 15;\\n                } else {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        if (_isAnimated(_habibiId)) {\\n            oil = (unclaimedTime * 2500 ether * baseOilMultiplier) / 1 days;\\n        } else {\\n            bonusPercentage = bonusPercentage + _balanceBonus;\\n            oil = (unclaimedTime * 500 ether * baseOilMultiplier) / 1 days;\\n        }\\n        oil = oil + ((oil * bonusPercentage) / 100);\\n    }\\n\\n    function staker(address staker_) public view returns (Staker memory) {\\n        return stakers[staker_];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            OIL PRIVILEGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mint(address to, uint256 value) external onlyMinter {\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) external onlyMinter {\\n        _burn(from, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Ruler Function\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setDoubleBaseTimestamp(uint256 _doubleBaseTimestamp) external onlyRuler {\\n        doubleBaseTimestamp = _doubleBaseTimestamp;\\n    }\\n\\n    function setMinter(address _minter, bool _canMint) external onlyRuler {\\n        isMinter[_minter] = _canMint;\\n    }\\n\\n    function setRuler(address _ruler) external onlyRuler {\\n        ruler = _ruler;\\n    }\\n\\n    function setPaused(bool _paused) external onlyRuler {\\n        paused = _paused;\\n    }\\n\\n    function setHabibiAddress(address _habibiAddress) external onlyRuler {\\n        habibi = ERC721Like(_habibiAddress);\\n    }\\n\\n    function setSellFee(uint256 _fee) external onlyRuler {\\n        sellFee = _fee;\\n    }\\n\\n    function setUniswapV2Router(address router_) external onlyRuler {\\n        uniswapV2Router = IUniswapV2Router02(router_);\\n    }\\n\\n    function setSushiswapV2Router(address router_) external onlyRuler {\\n        sushiswapV2Router = IUniswapV2Router02(router_);\\n    }\\n\\n    function setV2Routers(address uniswapRouter_, address sushiswapRouter_) external onlyRuler {\\n        uniswapV2Router = IUniswapV2Router02(uniswapRouter_);\\n        sushiswapV2Router = IUniswapV2Router02(sushiswapRouter_);\\n    }\\n\\n    function setUniPair(address uniPair_) external onlyRuler {\\n        uniPair = uniPair_;\\n    }\\n\\n    function setSushiswapPair(address sushiswapPair_) external onlyRuler {\\n        sushiswapPair = sushiswapPair_;\\n    }\\n\\n    function setPairs(address uniPair_, address sushiswapPair_) external onlyRuler {\\n        uniPair = uniPair_;\\n        sushiswapPair = sushiswapPair_;\\n    }\\n\\n    function excludeFromFees(address[] calldata addresses_, bool[] calldata excluded_) external onlyRuler {\\n        for (uint256 i = 0; i < addresses_.length; i++) {\\n            excludedFromFees[addresses_[i]] = excluded_[i];\\n        }\\n    }\\n\\n    function blockOrUnblockAddresses(address[] calldata addresses_, bool[] calldata blocked_) external onlyRuler {\\n        for (uint256 i = 0; i < addresses_.length; i++) {\\n            blockList[addresses_[i]] = blocked_[i];\\n        }\\n    }\\n\\n    /// emergency\\n    function rescue(\\n        address staker_,\\n        address to_,\\n        uint256[] calldata tokenIds_\\n    ) external onlyRuler {\\n        require(rescueable[staker_].revoker != address(0), \\\"User has not opted-in for rescue\\\");\\n        uint256[] memory fromHabibiz = habibizOfStaker(staker_);\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            bool found;\\n            for (uint256 j = 0; j < fromHabibiz.length; j++) {\\n                if (tokenIds_[i] == fromHabibiz[j]) {\\n                    found = true;\\n                    break;\\n                }\\n            }\\n            require(found, \\\"TokenID not found\\\");\\n        }\\n        removeHabibiIdsFromStaker(staker_, tokenIds_);\\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\\n            stakers[to_].habibiz.push(Habibi(block.timestamp, tokenIds_[i]));\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _getRouterFromPair(address pairAddress_) internal view returns (IUniswapV2Router02) {\\n        return pairAddress_ == address(uniPair) ? uniswapV2Router : sushiswapV2Router;\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        require(balanceOf[from] >= value, \\\"ERC20: transfer amount exceeds balance\\\");\\n        uint256 tax;\\n\\n        bool shouldTax = ((to == uniPair && balanceOf[to] != 0) || (to == sushiswapPair && balanceOf[to] != 0)) &&\\n            !swapping;\\n        if (shouldTax && !excludedFromFees[from]) {\\n            tax = (value * sellFee) / 100_000;\\n            if (tax > 0) {\\n                balanceOf[address(this)] += tax;\\n                swapTokensForEth(to, tax, treasury);\\n            }\\n        }\\n        uint256 taxedAmount = value - tax;\\n        balanceOf[from] -= value;\\n        balanceOf[to] += taxedAmount;\\n        emit Transfer(from, to, taxedAmount);\\n    }\\n\\n    function swapTokensForEth(\\n        address pairAddress_,\\n        uint256 _amountIn,\\n        address _to\\n    ) private lockTheSwap {\\n        IUniswapV2Router02 router = _getRouterFromPair(pairAddress_);\\n        IERC20(address(this)).approve(address(router), _amountIn);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = router.WETH(); // or router.WETH();\\n\\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(_amountIn, 1, path, _to, block.timestamp);\\n    }\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function holderBonusPercentage(address staker_) public view returns (uint256) {\\n        uint256 balance = stakers[staker_].habibiz.length;\\n\\n        if (balance < 5) return 0;\\n        if (balance < 10) return 15;\\n        if (balance < 20) return 25;\\n        return 35;\\n    }\\n\\n    function _isAnimated(uint256 _id) internal pure returns (bool animated) {\\n        return\\n            _id == 40 ||\\n            _id == 108 ||\\n            _id == 169 ||\\n            _id == 191 ||\\n            _id == 246 ||\\n            _id == 257 ||\\n            _id == 319 ||\\n            _id == 386 ||\\n            _id == 496 ||\\n            _id == 562 ||\\n            _id == 637 ||\\n            _id == 692 ||\\n            _id == 832 ||\\n            _id == 942 ||\\n            _id == 943 ||\\n            _id == 957 ||\\n            _id == 1100 ||\\n            _id == 1108 ||\\n            _id == 1169 ||\\n            _id == 1178 ||\\n            _id == 1627 ||\\n            _id == 1706 ||\\n            _id == 1843 ||\\n            _id == 1884 ||\\n            _id == 2137 ||\\n            _id == 2158 ||\\n            _id == 2165 ||\\n            _id == 2214 ||\\n            _id == 2232 ||\\n            _id == 2238 ||\\n            _id == 2508 ||\\n            _id == 2629 ||\\n            _id == 2863 ||\\n            _id == 3055 ||\\n            _id == 3073 ||\\n            _id == 3280 ||\\n            _id == 3297 ||\\n            _id == 3322 ||\\n            _id == 3327 ||\\n            _id == 3361 ||\\n            _id == 3411 ||\\n            _id == 3605 ||\\n            _id == 3639 ||\\n            _id == 3774 ||\\n            _id == 4250 ||\\n            _id == 4267 ||\\n            _id == 4302 ||\\n            _id == 4362 ||\\n            _id == 4382 ||\\n            _id == 4397 ||\\n            _id == 4675 ||\\n            _id == 4707 ||\\n            _id == 4863;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          MODIFIERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier onlyMinter() {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO MINT OR BURN\\\");\\n        _;\\n    }\\n\\n    modifier onlyRuler() {\\n        require(msg.sender == ruler, \\\"NOT ALLOWED TO RULE\\\");\\n        _;\\n    }\\n\\n    modifier whenNotPaused() {\\n        require(!paused, \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    modifier lockTheSwap() {\\n        swapping = true;\\n        _;\\n        swapping = false;\\n    }\\n\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ninterface ERC721Like {\\n    function balanceOf(address holder_) external view returns (uint256);\\n\\n    function ownerOf(uint256 id_) external view returns (address);\\n\\n    function walletOfOwner(address _owner) external view returns (uint256[] calldata);\\n\\n    function isApprovedForAll(address operator_, address address_) external view returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n}\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function WETH() external pure returns (address);\\n\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\\ninterface UniPairLike {\\n    function token0() external returns (address);\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function getReserves()\\n        external\\n        view\\n        returns (\\n            uint112 reserve0,\\n            uint112 reserve1,\\n            uint32 blockTimestampLast\\n        );\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"revoker_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"confirm_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"rescueableByAdmin_\",\"type\":\"bool\"}],\"name\":\"approveRescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"blocked_\",\"type\":\"bool[]\"}],\"name\":\"blockOrUnblockAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"calculateOilRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"oilAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doubleBaseTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"excluded_\",\"type\":\"bool[]\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"habibi\",\"outputs\":[{\"internalType\":\"contract ERC721Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"habibizOfStaker\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"holderBonusPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impl_\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"habibi_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"treasury_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rescueable_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"confirm_\",\"type\":\"bool\"}],\"name\":\"revokeRescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ruler\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_doubleBaseTimestamp\",\"type\":\"uint256\"}],\"name\":\"setDoubleBaseTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_habibiAddress\",\"type\":\"address\"}],\"name\":\"setHabibiAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_canMint\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniPair_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushiswapPair_\",\"type\":\"address\"}],\"name\":\"setPairs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ruler\",\"type\":\"address\"}],\"name\":\"setRuler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setSellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sushiswapPair_\",\"type\":\"address\"}],\"name\":\"setSushiswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"name\":\"setSushiswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniPair_\",\"type\":\"address\"}],\"name\":\"setUniPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"router_\",\"type\":\"address\"}],\"name\":\"setUniswapV2Router\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"uniswapRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sushiswapRouter_\",\"type\":\"address\"}],\"name\":\"setV2Routers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_habibiz\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker_\",\"type\":\"address\"}],\"name\":\"staker\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"stakedTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Oil.Habibi[]\",\"name\":\"habibiz\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"internalType\":\"struct Oil.Staker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2Router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Oil", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}