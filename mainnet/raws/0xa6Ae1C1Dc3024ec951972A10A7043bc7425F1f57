{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ArtblocksOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./ArtblocksOracleMessages.sol\\\";\\nimport \\\"./ITraitOracle.sol\\\";\\nimport \\\"./Popcnt.sol\\\";\\nimport \\\"./SignatureChecker.sol\\\";\\n\\nenum TraitType {\\n    /// A trait that represents an Art Blocks project, like \\\"Chromie Squiggle\\\"\\n    /// or \\\"Archetype\\\". Keyed by project ID, a small non-negative integer.\\n    PROJECT,\\n    /// A trait that represents a feature within a particular Art Blocks\\n    /// project, like a specific color palette of Archetype (\\\"Palette: Paddle\\\")\\n    /// or a specific body type of Algobot (\\\"Bodywork: Wedge\\\"). Keyed by\\n    /// project ID (a small non-negative integer) and human-readable trait name\\n    /// (a string).\\n    FEATURE\\n}\\n\\n/// Static information about a project trait (immutable once written).\\nstruct ProjectInfo {\\n    /// The ERC-721 contract for tokens belonging to this project.\\n    IERC721 tokenContract;\\n    /// The integer index of this project: e.g., `0` for \\\"Chromie Squiggle\\\" or\\n    /// `23` for \\\"Archetype\\\".\\n    uint32 projectId;\\n    /// The number of tokens in this project, like `600`.\\n    uint32 size;\\n    /// The human-readable name of this project, like \\\"Archetype\\\".\\n    string name;\\n}\\n\\n/// Static information about a feature trait (immutable once written).\\nstruct FeatureInfo {\\n    /// The ERC-721 contract for tokens belonging to this trait's project.\\n    IERC721 tokenContract;\\n    /// The integer index of the project that this feature is a part of: e.g.,\\n    /// for the \\\"Palette: Paddle\\\" trait on Archetypes, this value is `23`,\\n    /// which is the ID of the Archetype project.\\n    uint32 projectId;\\n    /// The string name of the feature, like \\\"Palette\\\".\\n    string featureName;\\n    /// The value of the trait within the feature, like \\\"Paddle\\\".\\n    string traitValue;\\n}\\n\\n/// The current state of a feature trait, updated as more memberships and\\n/// finalizations are recorded.\\nstruct FeatureMetadata {\\n    /// The number of distinct token IDs that currently have this trait: i.e.,\\n    /// the sum of the population counts of `featureMembers[_t][_i]` for each\\n    /// `_i`.\\n    uint32 currentSize;\\n    /// Token indices `0` (inclusive) through `numFinalized` (exclusive),\\n    /// relative to the start of the project, have their memberships in this\\n    /// trait finalized.\\n    uint32 numFinalized;\\n    /// A hash accumulator of updates to this trait. Initially `0`; updated for\\n    /// each new message `_msg` by ABI-encoding `(log, _msg.structHash())`,\\n    /// applying `keccak256`, and truncating the result back to `bytes24`.\\n    bytes24 log;\\n}\\n\\nenum MulticallMessageKind {\\n    SET_PROJECT_INFO,\\n    SET_FEATURE_INFO,\\n    UPDATE_TRAIT\\n}\\n\\nstruct MulticallMessage {\\n    MulticallMessageKind kind;\\n    bytes encodedMsg;\\n    bytes signature;\\n    SignatureKind signatureKind;\\n}\\n\\ncontract ArtblocksOracle is IERC165, ITraitOracle, Ownable {\\n    using ArtblocksOracleMessages for SetProjectInfoMessage;\\n    using ArtblocksOracleMessages for SetFeatureInfoMessage;\\n    using ArtblocksOracleMessages for UpdateTraitMessage;\\n    using Popcnt for uint256;\\n\\n    event OracleSignerChanged(address indexed oracleSigner);\\n    event ProjectInfoSet(\\n        bytes32 indexed traitId,\\n        uint32 indexed projectId,\\n        string name,\\n        uint32 version,\\n        uint32 size,\\n        IERC721 tokenContract\\n    );\\n    event FeatureInfoSet(\\n        bytes32 indexed traitId,\\n        uint32 indexed projectId,\\n        // `nameAndValue` is `featureName + \\\": \\\" + traitValue`, for indexing.\\n        string indexed nameAndValue,\\n        string featureName,\\n        string traitValue,\\n        uint32 version,\\n        IERC721 tokenContract\\n    );\\n    event TraitUpdated(\\n        bytes32 indexed traitId,\\n        uint32 newSize,\\n        uint32 newNumFinalized,\\n        bytes24 newLog\\n    );\\n\\n    string constant ERR_ALREADY_EXISTS = \\\"ArtblocksOracle: ALREADY_EXISTS\\\";\\n    string constant ERR_IMMUTABLE = \\\"ArtblocksOracle: IMMUTABLE\\\";\\n    string constant ERR_INVALID_ARGUMENT = \\\"ArtblocksOracle: INVALID_ARGUMENT\\\";\\n    string constant ERR_INVALID_STATE = \\\"ArtblocksOracle: INVALID_STATE\\\";\\n    string constant ERR_UNAUTHORIZED = \\\"ArtblocksOracle: UNAUTHORIZED\\\";\\n\\n    bytes32 constant TYPEHASH_DOMAIN_SEPARATOR =\\n        keccak256(\\n            \\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\"\\n        );\\n    bytes32 constant DOMAIN_SEPARATOR_NAME_HASH = keccak256(\\\"ArtblocksOracle\\\");\\n\\n    /// Art Blocks gives each project a token space of 1 million IDs. Most IDs\\n    /// in this space are not actually used, but a token's ID floor-divided by\\n    /// this stride gives the project ID, and the token ID modulo this stride\\n    /// gives the token index within the project.\\n    uint256 constant PROJECT_STRIDE = 10**6;\\n\\n    address public oracleSigner;\\n\\n    mapping(bytes32 => ProjectInfo) public projectTraitInfo;\\n    mapping(bytes32 => FeatureInfo) public featureTraitInfo;\\n\\n    /// Append-only relation on `TraitId * TokenId`, for feature traits only.\\n    /// (Project trait membership is determined from the token ID itself.)\\n    ///\\n    /// Encoded by packing 256 token indices into each word: if a token has\\n    /// index `_i` in its project (i.e., `_i == _tokenId % PROJECT_STRIDE`),\\n    /// then the token has trait `_t` iff the `_i % 256`th bit (counting from\\n    /// the LSB) of `featureMembers[_t][_i / 256]` is `1`.\\n    mapping(bytes32 => mapping(uint256 => uint256)) featureMembers;\\n    /// Metadata for each feature trait; see struct definition. Not defined for\\n    /// project traits.\\n    mapping(bytes32 => FeatureMetadata) public featureMetadata;\\n\\n    // EIP-165 interface discovery boilerplate.\\n    function supportsInterface(bytes4 _interfaceId)\\n        external\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        if (_interfaceId == type(ITraitOracle).interfaceId) return true;\\n        if (_interfaceId == type(IERC165).interfaceId) return true;\\n        return false;\\n    }\\n\\n    function setOracleSigner(address _oracleSigner) external onlyOwner {\\n        oracleSigner = _oracleSigner;\\n        emit OracleSignerChanged(_oracleSigner);\\n    }\\n\\n    function _requireOracleSignature(\\n        bytes32 _structHash,\\n        bytes memory _signature,\\n        SignatureKind _kind\\n    ) internal view {\\n        address _signer = SignatureChecker.recover(\\n            _computeDomainSeparator(),\\n            _structHash,\\n            _signature,\\n            _kind\\n        );\\n        require(_signer == oracleSigner, ERR_UNAUTHORIZED);\\n    }\\n\\n    function _computeDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_DOMAIN_SEPARATOR,\\n                    DOMAIN_SEPARATOR_NAME_HASH,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function setProjectInfo(\\n        SetProjectInfoMessage memory _msg,\\n        bytes memory _signature,\\n        SignatureKind _signatureKind\\n    ) public {\\n        _requireOracleSignature(_msg.structHash(), _signature, _signatureKind);\\n\\n        // Input fields must be non-empty (but project ID may be 0).\\n        require(_msg.size > 0, ERR_INVALID_ARGUMENT);\\n        require(\\n            _msg.tokenContract != IERC721(address(0)),\\n            ERR_INVALID_ARGUMENT\\n        );\\n        require(!_stringEmpty(_msg.projectName), ERR_INVALID_ARGUMENT);\\n\\n        // Project must not already exist.\\n        bytes32 _traitId = projectTraitId(_msg.projectId, _msg.version);\\n        require(projectTraitInfo[_traitId].size == 0, ERR_ALREADY_EXISTS);\\n\\n        projectTraitInfo[_traitId] = ProjectInfo({\\n            projectId: _msg.projectId,\\n            name: _msg.projectName,\\n            size: _msg.size,\\n            tokenContract: _msg.tokenContract\\n        });\\n        emit ProjectInfoSet({\\n            traitId: _traitId,\\n            projectId: _msg.projectId,\\n            name: _msg.projectName,\\n            version: _msg.version,\\n            size: _msg.size,\\n            tokenContract: _msg.tokenContract\\n        });\\n    }\\n\\n    function setFeatureInfo(\\n        SetFeatureInfoMessage memory _msg,\\n        bytes memory _signature,\\n        SignatureKind _signatureKind\\n    ) public {\\n        _requireOracleSignature(_msg.structHash(), _signature, _signatureKind);\\n\\n        // Input fields must be non-empty (but project ID may be 0).\\n        require(\\n            _msg.tokenContract != IERC721(address(0)),\\n            ERR_INVALID_ARGUMENT\\n        );\\n        require(!_stringEmpty(_msg.featureName), ERR_INVALID_ARGUMENT);\\n        require(!_stringEmpty(_msg.traitValue), ERR_INVALID_ARGUMENT);\\n\\n        // Feature must not already exist.\\n        bytes32 _traitId = featureTraitId(\\n            _msg.projectId,\\n            _msg.featureName,\\n            _msg.traitValue,\\n            _msg.version\\n        );\\n        require(\\n            featureTraitInfo[_traitId].tokenContract == IERC721(address(0)),\\n            ERR_ALREADY_EXISTS\\n        );\\n\\n        featureTraitInfo[_traitId] = FeatureInfo({\\n            projectId: _msg.projectId,\\n            featureName: _msg.featureName,\\n            traitValue: _msg.traitValue,\\n            tokenContract: _msg.tokenContract\\n        });\\n        emit FeatureInfoSet({\\n            traitId: _traitId,\\n            projectId: _msg.projectId,\\n            nameAndValue: string(\\n                abi.encodePacked(_msg.featureName, \\\": \\\", _msg.traitValue)\\n            ),\\n            featureName: _msg.featureName,\\n            traitValue: _msg.traitValue,\\n            version: _msg.version,\\n            tokenContract: _msg.tokenContract\\n        });\\n    }\\n\\n    function updateTrait(\\n        UpdateTraitMessage memory _msg,\\n        bytes memory _signature,\\n        SignatureKind _signatureKind\\n    ) public {\\n        bytes32 _structHash = _msg.structHash();\\n        _requireOracleSignature(_structHash, _signature, _signatureKind);\\n\\n        bytes32 _traitId = _msg.traitId;\\n        // Feature must exist.\\n        require(\\n            featureTraitInfo[_traitId].tokenContract != IERC721(address(0)),\\n            ERR_INVALID_ARGUMENT\\n        );\\n        FeatureMetadata memory _oldMetadata = featureMetadata[_traitId];\\n\\n        // Check whether we're increasing the number of finalized tokens.\\n        // If so, the current trait log must match the given one.\\n        uint32 _newNumFinalized = _oldMetadata.numFinalized;\\n        uint32 _msgNumFinalized = uint32(uint256(_msg.finalization));\\n        if (_msgNumFinalized > _newNumFinalized) {\\n            _newNumFinalized = _msgNumFinalized;\\n            bytes24 _expectedLastLog = bytes24(_msg.finalization);\\n            require(_oldMetadata.log == _expectedLastLog, ERR_INVALID_STATE);\\n        }\\n\\n        // Add any new token memberships.\\n        uint32 _newSize = _oldMetadata.currentSize;\\n        for (uint256 _i = 0; _i < _msg.words.length; _i++) {\\n            TraitMembershipWord memory _word = _msg.words[_i];\\n            uint256 _wordIndex = _word.wordIndex;\\n\\n            uint256 _oldWord = featureMembers[_traitId][_wordIndex];\\n            uint256 _newTokensMask = _word.mask & ~_oldWord;\\n\\n            // It's an error to update any tokens in this word that are already\\n            // finalized (i.e., were finalized prior to this message).\\n            uint256 _errantUpdatesMask = _newTokensMask &\\n                _finalizedTokensMask(_oldMetadata.numFinalized, _wordIndex);\\n            require(_errantUpdatesMask == 0, ERR_IMMUTABLE);\\n\\n            featureMembers[_traitId][_wordIndex] = _oldWord | _newTokensMask;\\n            _newSize += uint32(_newTokensMask.popcnt());\\n        }\\n\\n        // If this message didn't add or finalize any new memberships, we don't\\n        // want to update the hash log *or* emit an event.\\n        bool _wasNoop = (_newSize == _oldMetadata.currentSize) &&\\n            (_newNumFinalized == _oldMetadata.numFinalized);\\n        if (_wasNoop) return;\\n\\n        // If we either added or finalized memberships, update the hash log.\\n        bytes24 _oldLog = _oldMetadata.log;\\n        bytes24 _newLog = bytes24(keccak256(abi.encode(_oldLog, _structHash)));\\n\\n        FeatureMetadata memory _newMetadata = FeatureMetadata({\\n            currentSize: _newSize,\\n            numFinalized: _newNumFinalized,\\n            log: _newLog\\n        });\\n        featureMetadata[_traitId] = _newMetadata;\\n\\n        emit TraitUpdated({\\n            traitId: _traitId,\\n            newSize: _newSize,\\n            newNumFinalized: _newNumFinalized,\\n            newLog: _newLog\\n        });\\n    }\\n\\n    function hasTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes calldata _trait\\n    ) external view override returns (bool) {\\n        bytes32 _traitId = bytes32(_trait);\\n\\n        uint8 _discriminant = uint8(uint256(_traitId));\\n        if (_discriminant == uint8(TraitType.PROJECT)) {\\n            return _hasProjectTrait(_tokenContract, _tokenId, _traitId);\\n        } else if (_discriminant == uint8(TraitType.FEATURE)) {\\n            return _hasFeatureTrait(_tokenContract, _tokenId, _traitId);\\n        } else {\\n            revert(ERR_INVALID_ARGUMENT);\\n        }\\n    }\\n\\n    function _hasProjectTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes32 _traitId\\n    ) internal view returns (bool) {\\n        ProjectInfo storage _info = projectTraitInfo[_traitId];\\n        IERC721 _projectContract = _info.tokenContract;\\n        uint256 _projectId = _info.projectId;\\n        uint256 _projectSize = _info.size;\\n\\n        if (_tokenContract != _projectContract) return false;\\n        if (_tokenId / PROJECT_STRIDE != _projectId) return false;\\n        if (_tokenId % PROJECT_STRIDE >= _projectSize) return false;\\n        return true;\\n    }\\n\\n    function _hasFeatureTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes32 _traitId\\n    ) internal view returns (bool) {\\n        FeatureInfo storage _info = featureTraitInfo[_traitId];\\n        IERC721 _traitContract = _info.tokenContract;\\n        uint256 _projectId = _info.projectId;\\n\\n        if (_tokenContract != _traitContract) return false;\\n        if (_tokenId / PROJECT_STRIDE != _projectId) return false;\\n\\n        uint256 _tokenIndex = _tokenId - (uint256(_projectId) * PROJECT_STRIDE);\\n        uint256 _wordIndex = _tokenIndex >> 8;\\n        uint256 _mask = 1 << (_tokenIndex & 0xff);\\n        return (featureMembers[_traitId][_wordIndex] & _mask) != 0;\\n    }\\n\\n    function projectTraitId(uint32 _projectId, uint32 _version)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory _blob = abi.encode(\\n            TraitType.PROJECT,\\n            _projectId,\\n            _version\\n        );\\n        uint256 _hash = uint256(keccak256(_blob));\\n        return bytes32((_hash & ~uint256(0xff)) | uint256(TraitType.PROJECT));\\n    }\\n\\n    function featureTraitId(\\n        uint32 _projectId,\\n        string memory _featureName,\\n        string memory _traitValue,\\n        uint32 _version\\n    ) public pure returns (bytes32) {\\n        bytes memory _blob = abi.encode(\\n            TraitType.FEATURE,\\n            _projectId,\\n            _featureName,\\n            _traitValue,\\n            _version\\n        );\\n        uint256 _hash = uint256(keccak256(_blob));\\n        return bytes32((_hash & ~uint256(0xff)) | uint256(TraitType.FEATURE));\\n    }\\n\\n    /// Dumb helper to test whether a string is empty, because Solidity doesn't\\n    /// expose `_s.length` for a string `_s`.\\n    function _stringEmpty(string memory _s) internal pure returns (bool) {\\n        return bytes(_s).length == 0;\\n    }\\n\\n    /// Given that the first `_numFinalized` tokens for trait `_t` have been\\n    /// finalized, returns a mask into `featureMembers[_t][_wordIndex]` of\\n    /// memberships that are finalized and thus not permitted to be updated.\\n    ///\\n    /// For instance, if `_numFinalized == 259`, then token indices 0 through 258\\n    /// (inclusive) have been finalized, so:\\n    ///\\n    ///     `_finalizedTokensMask(259, 0) == ~0`\\n    ///         because all tokens in word 0 have been finalized\\n    ///         be updated\\n    ///     `_finalizedTokensMask(259, 1) == (1 << 3) - 1`\\n    ///         because the first three tokens (256, 257, 258) within this word\\n    ///         have been finalized, so the result has the low 3 bits set\\n    ///     `_finalizedTokensMask(259, 2) == 0`\\n    ///         because no tokens in word 2 (or higher) have been finalized\\n    function _finalizedTokensMask(uint32 _numFinalized, uint256 _wordIndex)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 _firstTokenInWord = _wordIndex << 8;\\n        if (_numFinalized < _firstTokenInWord) {\\n            // Nothing in this word is finalized.\\n            return 0;\\n        }\\n        uint256 _numFinalizedSinceStartOfWord = uint256(_numFinalized) -\\n            _firstTokenInWord;\\n        if (_numFinalizedSinceStartOfWord > 0xff) {\\n            // Everything in this word is finalized.\\n            return ~uint256(0);\\n        }\\n        // Otherwise, between 0 and 255 tokens in this word are finalized; form\\n        // a mask of their indices.\\n        //\\n        // (This subtraction doesn't underflow because the shift produces a\\n        // nonzero value, given the bounds on `_numFinalizedSinceStartOfWord`.)\\n        return (1 << _numFinalizedSinceStartOfWord) - 1;\\n    }\\n\\n    function multicall(MulticallMessage[] calldata _inputs) external {\\n        for (uint256 _i = 0; _i < _inputs.length; _i++) {\\n            MulticallMessage calldata _input = _inputs[_i];\\n            if (_input.kind == MulticallMessageKind.UPDATE_TRAIT) {\\n                UpdateTraitMessage memory _msg = abi.decode(\\n                    _input.encodedMsg,\\n                    (UpdateTraitMessage)\\n                );\\n                updateTrait(_msg, _input.signature, _input.signatureKind);\\n            } else if (_input.kind == MulticallMessageKind.SET_FEATURE_INFO) {\\n                SetFeatureInfoMessage memory _msg = abi.decode(\\n                    _input.encodedMsg,\\n                    (SetFeatureInfoMessage)\\n                );\\n                setFeatureInfo(_msg, _input.signature, _input.signatureKind);\\n            } else if (_input.kind == MulticallMessageKind.SET_PROJECT_INFO) {\\n                SetProjectInfoMessage memory _msg = abi.decode(\\n                    _input.encodedMsg,\\n                    (SetProjectInfoMessage)\\n                );\\n                setProjectInfo(_msg, _input.signature, _input.signatureKind);\\n            } else {\\n                revert(ERR_INVALID_ARGUMENT);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ArtblocksOracleMessages.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nstruct SetProjectInfoMessage {\\n    uint32 version;\\n    IERC721 tokenContract;\\n    uint32 projectId;\\n    uint32 size;\\n    string projectName;\\n}\\n\\nstruct SetFeatureInfoMessage {\\n    uint32 version;\\n    IERC721 tokenContract;\\n    uint32 projectId;\\n    string featureName;\\n    string traitValue;\\n}\\n\\nstruct UpdateTraitMessage {\\n    bytes32 traitId;\\n    TraitMembershipWord[] words;\\n    /// Define `numTokensFinalized` as `uint32(uint256(finalization))`\\n    /// (the low/last 4 bytes) and `expectedLastLog` as `bytes24(finalization)`\\n    /// (the high/first 24 bytes).\\n    ///\\n    /// If `numTokensFinalized` is greater than the current number of tokens\\n    /// finalized for this trait, then `expectedLastLog` must equal the\\n    /// previous value of the hash-update log for this trait (not including the\\n    /// update from this message), and the number of tokens finalized will be\\n    /// increased to `numTokensFinalized`. If the last log does not match, the\\n    /// transaction will be reverted.\\n    ///\\n    /// If `numTokensFinalized` is *not* greater than the current number of\\n    /// finalized tokens, then this field and `expectedLastLog` are ignored\\n    /// (even if the last log does not match). In particular, they are always\\n    /// ignored when `numTokensFinalized` is zero or if a message is replayed.\\n    bytes32 finalization;\\n}\\n\\n/// A set of token IDs within a multiple-of-256 block.\\nstruct TraitMembershipWord {\\n    /// This set describes membership for tokens between `wordIndex * 256`\\n    /// (inclusive) and `(wordIndex + 1) * 256` (exclusive), with IDs relative\\n    /// to the start of the project.\\n    uint256 wordIndex;\\n    /// A 256-bit mask of tokens such that `mask[_i]` is set if token\\n    /// `wordIndex * 256 + _i` (relative to the start of the project) is in the\\n    /// set.\\n    uint256 mask;\\n}\\n\\nlibrary ArtblocksOracleMessages {\\n    using ArtblocksOracleMessages for TraitMembershipWord;\\n    using ArtblocksOracleMessages for TraitMembershipWord[];\\n\\n    bytes32 internal constant TYPEHASH_SET_PROJECT_INFO =\\n        keccak256(\\n            \\\"SetProjectInfoMessage(uint32 version,address tokenContract,uint32 projectId,uint32 size,string projectName)\\\"\\n        );\\n    bytes32 internal constant TYPEHASH_SET_FEATURE_INFO =\\n        keccak256(\\n            \\\"SetFeatureInfoMessage(uint32 version,address tokenContract,uint32 projectId,string featureName,string traitValue)\\\"\\n        );\\n    bytes32 internal constant TYPEHASH_UPDATE_TRAIT =\\n        keccak256(\\n            \\\"UpdateTraitMessage(bytes32 traitId,TraitMembershipWord[] words,bytes32 finalization)TraitMembershipWord(uint256 wordIndex,uint256 mask)\\\"\\n        );\\n    bytes32 internal constant TYPEHASH_TRAIT_MEMBERSHIP_WORD =\\n        keccak256(\\\"TraitMembershipWord(uint256 wordIndex,uint256 mask)\\\");\\n\\n    function structHash(SetProjectInfoMessage memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_SET_PROJECT_INFO,\\n                    _self.version,\\n                    _self.tokenContract,\\n                    _self.projectId,\\n                    _self.size,\\n                    keccak256(abi.encodePacked(_self.projectName))\\n                )\\n            );\\n    }\\n\\n    function structHash(SetFeatureInfoMessage memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_SET_FEATURE_INFO,\\n                    _self.version,\\n                    _self.tokenContract,\\n                    _self.projectId,\\n                    keccak256(abi.encodePacked(_self.featureName)),\\n                    keccak256(abi.encodePacked(_self.traitValue))\\n                )\\n            );\\n    }\\n\\n    function structHash(UpdateTraitMessage memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_UPDATE_TRAIT,\\n                    _self.traitId,\\n                    _self.words.structHash(),\\n                    _self.finalization\\n                )\\n            );\\n    }\\n\\n    function structHash(TraitMembershipWord memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    TYPEHASH_TRAIT_MEMBERSHIP_WORD,\\n                    _self.wordIndex,\\n                    _self.mask\\n                )\\n            );\\n    }\\n\\n    function structHash(TraitMembershipWord[] memory _self)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32[] memory _structHashes = new bytes32[](_self.length);\\n        for (uint256 _i = 0; _i < _self.length; _i++) {\\n            _structHashes[_i] = _self[_i].structHash();\\n        }\\n        return keccak256(abi.encodePacked(_structHashes));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITraitOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ITraitOracle {\\n    /// Queries whether the given ERC-721 token has the given trait.\\n    ///\\n    /// The interpretation of the trait bytestring may be domain-specific and\\n    /// is at the discretion of the trait oracle. For example, an oracle might\\n    /// choose to encode traits called \\\"Normal\\\" and \\\"Rare\\\" as `\\\"\\\\x00\\\"` and\\n    /// `\\\"\\\\x01\\\"` respectively, or as `bytes(keccak256(\\\"Normal\\\"))` and\\n    /// `bytes(keccak256(\\\"Rare\\\"))`, or as something else. The trait oracle may\\n    /// expose other domain-specific methods to describe these traits.\\n    function hasTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes calldata _trait\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Popcnt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary Popcnt {\\n    /// Computes the population count of `_x`: i.e., the number of bits that\\n    /// are set. Also known as the Hamming weight.\\n    ///\\n    /// Implementation is the standard contraction algorithm.\\n    function popcnt(uint256 _x) internal pure returns (uint256) {\\n        _x = (_x & MASK_0) + ((_x >> 1) & MASK_0);\\n        _x = (_x & MASK_1) + ((_x >> 2) & MASK_1);\\n        _x = (_x & MASK_2) + ((_x >> 4) & MASK_2);\\n        _x = (_x & MASK_3) + ((_x >> 8) & MASK_3);\\n        _x = (_x & MASK_4) + ((_x >> 16) & MASK_4);\\n        _x = (_x & MASK_5) + ((_x >> 32) & MASK_5);\\n        _x = (_x & MASK_6) + ((_x >> 64) & MASK_6);\\n        _x = (_x & MASK_7) + ((_x >> 128) & MASK_7);\\n        return _x;\\n    }\\n\\n    /// To compute these constants:\\n    ///\\n    /// ```python3\\n    /// for i in range(8):\\n    ///     pow = 2 ** i\\n    ///     bits = (\\\"0\\\" * pow + \\\"1\\\" * pow) * (256 // (2 * pow))\\n    ///     num = int(bits, 2)\\n    ///     hexstr = \\\"0x\\\" + hex(num)[2:].zfill(64)\\n    ///     print(\\\"uint256 constant MASK_%s = %s;\\\" % (i, hexstr))\\n    /// ```\\n    uint256 constant MASK_0 =\\n        0x5555555555555555555555555555555555555555555555555555555555555555;\\n    uint256 constant MASK_1 =\\n        0x3333333333333333333333333333333333333333333333333333333333333333;\\n    uint256 constant MASK_2 =\\n        0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n    uint256 constant MASK_3 =\\n        0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n    uint256 constant MASK_4 =\\n        0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n    uint256 constant MASK_5 =\\n        0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n    uint256 constant MASK_6 =\\n        0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n    uint256 constant MASK_7 =\\n        0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n}\\n\"\r\n    },\r\n    \"contracts/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nenum SignatureKind {\\n    /// A message for which authorization is handled specially by the verifying\\n    /// contract. Signatures with this kind will always be rejected by\\n    /// `SignatureChecker.recover`; this enum variant exists to let callers\\n    /// handle other types of authorization, such as pre-authorization in\\n    /// contract storage or association with `msg.sender`.\\n    EXTERNAL,\\n    /// A message that starts with \\\"\\\\x19Ethereum Signed Message[...]\\\", as\\n    /// implemented by the `personal_sign` JSON-RPC method.\\n    ETHEREUM_SIGNED_MESSAGE,\\n    /// A message that starts with \\\"\\\\x19\\\\x01\\\" and follows the EIP-712 typed\\n    /// data specification.\\n    EIP_712\\n}\\n\\nlibrary SignatureChecker {\\n    function recover(\\n        bytes32 _domainSeparator,\\n        bytes32 _structHash,\\n        bytes memory _signature,\\n        SignatureKind _kind\\n    ) internal pure returns (address) {\\n        bytes32 _hash;\\n        if (_kind == SignatureKind.ETHEREUM_SIGNED_MESSAGE) {\\n            _hash = ECDSA.toEthSignedMessageHash(\\n                keccak256(abi.encode(_domainSeparator, _structHash))\\n            );\\n        } else if (_kind == SignatureKind.EIP_712) {\\n            _hash = ECDSA.toTypedDataHash(_domainSeparator, _structHash);\\n        } else {\\n            revert(\\\"SignatureChecker: no signature given\\\");\\n        }\\n        return ECDSA.recover(_hash, _signature);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"nameAndValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"featureName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"traitValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"FeatureInfoSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracleSigner\",\"type\":\"address\"}],\"name\":\"OracleSignerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"size\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"}],\"name\":\"ProjectInfoSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"traitId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newSize\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"newNumFinalized\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes24\",\"name\":\"newLog\",\"type\":\"bytes24\"}],\"name\":\"TraitUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"featureMetadata\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"currentSize\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"numFinalized\",\"type\":\"uint32\"},{\"internalType\":\"bytes24\",\"name\":\"log\",\"type\":\"bytes24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_projectId\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"_featureName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_traitValue\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"_version\",\"type\":\"uint32\"}],\"name\":\"featureTraitId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"featureTraitInfo\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"featureName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"traitValue\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_trait\",\"type\":\"bytes\"}],\"name\":\"hasTrait\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum MulticallMessageKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"encodedMsg\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"signatureKind\",\"type\":\"uint8\"}],\"internalType\":\"struct MulticallMessage[]\",\"name\":\"_inputs\",\"type\":\"tuple[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleSigner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_version\",\"type\":\"uint32\"}],\"name\":\"projectTraitId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"projectTraitInfo\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"size\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"featureName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"traitValue\",\"type\":\"string\"}],\"internalType\":\"struct SetFeatureInfoMessage\",\"name\":\"_msg\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"_signatureKind\",\"type\":\"uint8\"}],\"name\":\"setFeatureInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracleSigner\",\"type\":\"address\"}],\"name\":\"setOracleSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"version\",\"type\":\"uint32\"},{\"internalType\":\"contract IERC721\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"size\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"projectName\",\"type\":\"string\"}],\"internalType\":\"struct SetProjectInfoMessage\",\"name\":\"_msg\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"_signatureKind\",\"type\":\"uint8\"}],\"name\":\"setProjectInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"traitId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wordIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mask\",\"type\":\"uint256\"}],\"internalType\":\"struct TraitMembershipWord[]\",\"name\":\"words\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"finalization\",\"type\":\"bytes32\"}],\"internalType\":\"struct UpdateTraitMessage\",\"name\":\"_msg\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"enum SignatureKind\",\"name\":\"_signatureKind\",\"type\":\"uint8\"}],\"name\":\"updateTrait\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ArtblocksOracle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}