{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FETH.sol\": {\r\n      \"content\": \"/*\\n  \uff65\\n   *\u3000\u2605\\n      \uff65 \uff61\\n        \u3000\uff65\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n\u200b\\n                      `                     .-:::::-.`              `-::---...```\\n                     `-:`               .:+ssssoooo++//:.`       .-/+shhhhhhhhhhhhhyyyssooo:\\n                    .--::.            .+ossso+/////++/:://-`   .////+shhhhhhhhhhhhhhhhhhhhhy\\n                  `-----::.         `/+////+++///+++/:--:/+/-  -////+shhhhhhhhhhhhhhhhhhhhhy\\n                 `------:::-`      `//-.``.-/+ooosso+:-.-/oso- -////+shhhhhhhhhhhhhhhhhhhhhy\\n                .--------:::-`     :+:.`  .-/osyyyyyyso++syhyo.-////+shhhhhhhhhhhhhhhhhhhhhy\\n              `-----------:::-.    +o+:-.-:/oyhhhhhhdhhhhhdddy:-////+shhhhhhhhhhhhhhhhhhhhhy\\n             .------------::::--  `oys+/::/+shhhhhhhdddddddddy/-////+shhhhhhhhhhhhhhhhhhhhhy\\n            .--------------:::::-` +ys+////+yhhhhhhhddddddddhy:-////+yhhhhhhhhhhhhhhhhhhhhhy\\n          `----------------::::::-`.ss+/:::+oyhhhhhhhhhhhhhhho`-////+shhhhhhhhhhhhhhhhhhhhhy\\n         .------------------:::::::.-so//::/+osyyyhhhhhhhhhys` -////+shhhhhhhhhhhhhhhhhhhhhy\\n       `.-------------------::/:::::..+o+////+oosssyyyyyyys+`  .////+shhhhhhhhhhhhhhhhhhhhhy\\n       .--------------------::/:::.`   -+o++++++oooosssss/.     `-//+shhhhhhhhhhhhhhhhhhhhyo\\n     .-------   ``````.......--`        `-/+ooooosso+/-`          `./++++///:::--...``hhhhyo\\n                                              `````\\n   *\u3000\\n      \uff65 \uff61\\n\u3000\u3000\u3000\u3000\uff65\u3000\u3000\uff9f\u2606 \uff61\\n  \u3000\u3000\u3000 *\u3000\u2605 \uff9f\uff65\uff61 *  \uff61\\n          \u3000\u3000* \u2606 \uff61\uff65\uff9f*.\uff61\\n      \u3000\u3000\u3000\uff9f *.\uff61\u2606\uff61\u2605\u3000\uff65\\n    *\u3000\u3000\uff9f\uff61\u00b7*\uff65\uff61 \uff9f*\\n  \u3000\u3000\u3000\u2606\uff9f\uff65\uff61\u00b0*. \uff9f\\n\u3000 \uff65 \uff9f*\uff61\uff65\uff9f\u2605\uff61\\n\u3000\u3000\uff65 *\uff9f\uff61\u3000\u3000 *\\n\u3000\uff65\uff9f*\uff61\u2605\uff65\\n \u2606\u2234\uff61\u3000*\\n\uff65 \uff61\\n*/\\n\\n// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./libraries/LockedBalance.sol\\\";\\n\\nerror FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\\nerror FETH_Cannot_Deposit_To_Address_Zero();\\nerror FETH_Cannot_Deposit_To_FETH();\\nerror FETH_Cannot_Withdraw_To_Address_Zero();\\nerror FETH_Cannot_Withdraw_To_FETH();\\nerror FETH_Cannot_Withdraw_To_Market();\\nerror FETH_Escrow_Expired();\\nerror FETH_Escrow_Not_Found();\\nerror FETH_Expiration_Too_Far_In_Future();\\n/// @param amount The current allowed amount the spender is authorized to transact for this account.\\nerror FETH_Insufficient_Allowance(uint256 amount);\\n/// @param amount The current available (unlocked) token count of this account.\\nerror FETH_Insufficient_Available_Funds(uint256 amount);\\n/// @param amount The current number of tokens this account has for the given lockup expiry bucket.\\nerror FETH_Insufficient_Escrow(uint256 amount);\\nerror FETH_Invalid_Lockup_Duration();\\nerror FETH_Market_Must_Be_A_Contract();\\nerror FETH_Must_Deposit_Non_Zero_Amount();\\nerror FETH_Must_Lockup_Non_Zero_Amount();\\nerror FETH_No_Funds_To_Withdraw();\\nerror FETH_Only_FND_Market_Allowed();\\nerror FETH_Too_Much_ETH_Provided();\\nerror FETH_Transfer_To_Address_Zero_Not_Allowed();\\nerror FETH_Transfer_To_FETH_Not_Allowed();\\n\\n/**\\n * @title An ERC-20 token which wraps ETH, potentially with a 1 day lockup period.\\n * @notice FETH is an [ERC-20 token](https://eips.ethereum.org/EIPS/eip-20) modeled after\\n * [WETH9](https://etherscan.io/address/0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2#code).\\n * It has the added ability to lockup tokens for 24-25 hours - during this time they may not be\\n * transferred or withdrawn, except by our market contract which requested the lockup in the first place.\\n * @dev Locked balances are rounded up to the next hour.\\n * They are grouped by the expiration time of the lockup into what we refer to as a lockup \\\"bucket\\\".\\n * At any time there may be up to 25 buckets but never more than that which prevents loops from exhausting gas limits.\\n */\\ncontract FETH {\\n  using AddressUpgradeable for address payable;\\n  using LockedBalance for LockedBalance.Lockups;\\n  using Math for uint256;\\n\\n  /// @notice Tracks an account's info.\\n  struct AccountInfo {\\n    /// @notice The number of tokens which have been unlocked already.\\n    uint96 freedBalance;\\n    /// @notice The first applicable lockup bucket for this account.\\n    uint32 lockupStartIndex;\\n    /// @notice Stores up to 25 buckets of locked balance for a user, one per hour.\\n    LockedBalance.Lockups lockups;\\n    /// @notice Returns the amount which a spender is still allowed to withdraw from this account.\\n    mapping(address => uint256) allowance;\\n  }\\n\\n  /// @notice Stores per-account details.\\n  mapping(address => AccountInfo) private accountToInfo;\\n\\n  // Lockup configuration\\n  /// @notice The minimum lockup period in seconds.\\n  uint256 private immutable lockupDuration;\\n  /// @notice The interval to which lockup expiries are rounded, limiting the max number of outstanding lockup buckets.\\n  uint256 private immutable lockupInterval;\\n\\n  /// @notice The Foundation market contract with permissions to manage lockups.\\n  address payable private immutable foundationMarket;\\n\\n  // ERC-20 metadata fields\\n  /**\\n   * @notice The number of decimals the token uses.\\n   * @dev This method can be used to improve usability when displaying token amounts, but all interactions\\n   * with this contract use whole amounts not considering decimals.\\n   * @return 18\\n   */\\n  uint8 public constant decimals = 18;\\n  /**\\n   * @notice The name of the token.\\n   * @return Foundation ETH\\n   */\\n  string public constant name = \\\"Foundation ETH\\\";\\n  /**\\n   * @notice The symbol of the token.\\n   * @return FETH\\n   */\\n  string public constant symbol = \\\"FETH\\\";\\n\\n  // ERC-20 events\\n  /**\\n   * @notice Emitted when the allowance for a spender account is updated.\\n   * @param from The account the spender is authorized to transact for.\\n   * @param spender The account with permissions to manage FETH tokens for the `from` account.\\n   * @param amount The max amount of tokens which can be spent by the `spender` account.\\n   */\\n  event Approval(address indexed from, address indexed spender, uint256 amount);\\n  /**\\n   * @notice Emitted when a transfer of FETH tokens is made from one account to another.\\n   * @param from The account which is sending FETH tokens.\\n   * @param to The account which is receiving FETH tokens.\\n   * @param amount The number of FETH tokens which were sent.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n  // Custom events\\n  /**\\n   * @notice Emitted when FETH tokens are locked up by the Foundation market for 24-25 hours\\n   * and may include newly deposited ETH which is added to the account's total FETH balance.\\n   * @param account The account which has access to the FETH after the `expiration`.\\n   * @param expiration The time at which the `from` account will have access to the locked FETH.\\n   * @param amount The number of FETH tokens which where locked up.\\n   * @param valueDeposited The amount of ETH added to their account's total FETH balance,\\n   * this may be lower than `amount` if available FETH was leveraged.\\n   */\\n  event BalanceLocked(address indexed account, uint256 indexed expiration, uint256 amount, uint256 valueDeposited);\\n  /**\\n   * @notice Emitted when FETH tokens are unlocked by the Foundation market.\\n   * @dev This event will not be emitted when lockups expire,\\n   * it's only for tokens which are unlocked before their expiry.\\n   * @param account The account which had locked FETH freed before expiration.\\n   * @param expiration The time this balance was originally scheduled to be unlocked.\\n   * @param amount The number of FETH tokens which were unlocked.\\n   */\\n  event BalanceUnlocked(address indexed account, uint256 indexed expiration, uint256 amount);\\n  /**\\n   * @notice Emitted when ETH is withdrawn from a user's account.\\n   * @dev This may be triggered by the user, an approved operator, or the Foundation market.\\n   * @param from The account from which FETH was deducted in order to send the ETH.\\n   * @param to The address the ETH was sent to.\\n   * @param amount The number of tokens which were deducted from the user's FETH balance and transferred as ETH.\\n   */\\n  event ETHWithdrawn(address indexed from, address indexed to, uint256 amount);\\n\\n  /// @dev Allows the Foundation market permission to manage lockups for a user.\\n  modifier onlyFoundationMarket() {\\n    if (msg.sender != foundationMarket) {\\n      revert FETH_Only_FND_Market_Allowed();\\n    }\\n    _;\\n  }\\n\\n  /**\\n   * @notice Set immutable variables for the implementation contract.\\n   * @dev Using immutable instead of constants allows us to use different values on testnet.\\n   * @param _foundationMarket The address of the Foundation NFT marketplace.\\n   * @param _lockupDuration The minimum length of time to lockup tokens for when `BalanceLocked`, in seconds.\\n   */\\n  constructor(address payable _foundationMarket, uint256 _lockupDuration) {\\n    if (!_foundationMarket.isContract()) {\\n      revert FETH_Market_Must_Be_A_Contract();\\n    }\\n    foundationMarket = _foundationMarket;\\n    lockupDuration = _lockupDuration;\\n    lockupInterval = _lockupDuration / 24;\\n    if (lockupInterval * 24 != _lockupDuration || _lockupDuration == 0) {\\n      revert FETH_Invalid_Lockup_Duration();\\n    }\\n  }\\n\\n  /**\\n   * @notice Transferring ETH (via `msg.value`) to the contract performs a `deposit` into the user's account.\\n   */\\n  receive() external payable {\\n    depositFor(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Approves a `spender` as an operator with permissions to transfer from your account.\\n   * @param spender The address of the operator account that has approval to spend funds\\n   * from the `msg.sender`'s account.\\n   * @param amount The max number of FETH tokens from `msg.sender`'s account that this spender is\\n   * allowed to transact with.\\n   * @return success Always true.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool success) {\\n    accountToInfo[msg.sender].allowance[spender] = amount;\\n    emit Approval(msg.sender, spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Deposit ETH (via `msg.value`) and receive the equivalent amount in FETH tokens.\\n   * These tokens are not subject to any lockup period.\\n   */\\n  function deposit() external payable {\\n    depositFor(msg.sender);\\n  }\\n\\n  /**\\n   * @notice Deposit ETH (via `msg.value`) and credit the `account` provided with the equivalent amount in FETH tokens.\\n   * These tokens are not subject to any lockup period.\\n   * @dev This may be used by the Foundation market to credit a user's account with FETH tokens.\\n   * @param account The account to credit with FETH tokens.\\n   */\\n  function depositFor(address account) public payable {\\n    if (msg.value == 0) {\\n      revert FETH_Must_Deposit_Non_Zero_Amount();\\n    } else if (account == address(0)) {\\n      revert FETH_Cannot_Deposit_To_Address_Zero();\\n    } else if (account == address(this)) {\\n      revert FETH_Cannot_Deposit_To_FETH();\\n    }\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    // ETH value cannot realistically overflow 96 bits.\\n    unchecked {\\n      accountInfo.freedBalance += uint96(msg.value);\\n    }\\n    emit Transfer(address(0), account, msg.value);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Remove an account's lockup and then create a new lockup, potentially for a different account.\\n   * @dev Used by the market when an offer for an NFT is increased.\\n   * This may be for a single account (increasing their offer)\\n   * or two different accounts (outbidding someone elses offer).\\n   * @param unlockFrom The account whose lockup is to be removed.\\n   * @param unlockExpiration The original lockup expiration for the tokens to be unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param unlockAmount The number of tokens to be unlocked from `unlockFrom`'s account.\\n   * This will revert if the tokens were previously unlocked.\\n   * @param lockupFor The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\\n   * @param lockupAmount The number of tokens to be locked up for the `lockupFor`'s account.\\n   * `msg.value` must be <= `lockupAmount` and any delta will be taken from the account's available FETH balance.\\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\\n   */\\n  function marketChangeLockup(\\n    address unlockFrom,\\n    uint256 unlockExpiration,\\n    uint256 unlockAmount,\\n    address lockupFor,\\n    uint256 lockupAmount\\n  ) external payable onlyFoundationMarket returns (uint256 expiration) {\\n    _marketUnlockFor(unlockFrom, unlockExpiration, unlockAmount);\\n    return _marketLockupFor(lockupFor, lockupAmount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Lockup an account's FETH tokens for 24-25 hours.\\n   * @dev Used by the market when a new offer for an NFT is made.\\n   * @param account The account to which the funds are to be deposited for (via the `msg.value`) and tokens locked up.\\n   * @param amount The number of tokens to be locked up for the `lockupFor`'s account.\\n   * `msg.value` must be <= `amount` and any delta will be taken from the account's available FETH balance.\\n   * @return expiration The expiration timestamp for the FETH tokens that were locked.\\n   */\\n  function marketLockupFor(address account, uint256 amount)\\n    external\\n    payable\\n    onlyFoundationMarket\\n    returns (uint256 expiration)\\n  {\\n    return _marketLockupFor(account, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\\n   * @dev Used by the market when an offer is invalidated, which occurs when an auction for the same NFT\\n   * receives its first bid or the buyer purchased the NFT another way, such as with `buy`.\\n   * @param account The account whose lockup is to be unlocked.\\n   * @param expiration The original lockup expiration for the tokens to be unlocked unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param amount The number of tokens to be unlocked from `account`.\\n   * This will revert if the tokens were previously unlocked.\\n   */\\n  function marketUnlockFor(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external onlyFoundationMarket {\\n    _marketUnlockFor(account, expiration, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Removes tokens from the user's available balance and returns ETH to the caller.\\n   * @dev Used by the market when a user's available FETH balance is used to make a purchase\\n   * including accepting a buy price or a private sale, or placing a bid in an auction.\\n   * @param from The account whose available balance is to be withdrawn from.\\n   * @param amount The number of tokens to be deducted from `unlockFrom`'s available balance and transferred as ETH.\\n   * This will revert if the tokens were previously unlocked.\\n   */\\n  function marketWithdrawFrom(address from, uint256 amount) external onlyFoundationMarket {\\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\\n    _deductBalanceFrom(accountInfo, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(from, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Used by the market contract only:\\n   * Removes a lockup from the user's account and then returns ETH to the caller.\\n   * @dev Used by the market to extract unexpired funds as ETH to distribute for\\n   * a sale when the user's offer is accepted.\\n   * @param account The account whose lockup is to be removed.\\n   * @param expiration The original lockup expiration for the tokens to be unlocked.\\n   * This will revert if the lockup has already expired.\\n   * @param amount The number of tokens to be unlocked and withdrawn as ETH.\\n   */\\n  function marketWithdrawLocked(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) external onlyFoundationMarket {\\n    _removeFromLockedBalance(account, expiration, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(account, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers an amount from your account.\\n   * @param to The address of the account which the tokens are transferred from.\\n   * @param amount The number of FETH tokens to be transferred.\\n   * @return success Always true (reverts if insufficient funds).\\n   */\\n  function transfer(address to, uint256 amount) external returns (bool success) {\\n    return transferFrom(msg.sender, to, amount);\\n  }\\n\\n  /**\\n   * @notice Transfers an amount from the account specified if the `msg.sender` has approval.\\n   * @param from The address from which the available tokens are transferred from.\\n   * @param to The address to which the tokens are to be transferred.\\n   * @param amount The number of FETH tokens to be transferred.\\n   * @return success Always true (reverts if insufficient funds or not approved).\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 amount\\n  ) public returns (bool success) {\\n    if (to == address(0)) {\\n      revert FETH_Transfer_To_Address_Zero_Not_Allowed();\\n    } else if (to == address(this)) {\\n      revert FETH_Transfer_To_FETH_Not_Allowed();\\n    }\\n    AccountInfo storage fromAccountInfo = _freeFromEscrow(from);\\n    if (from != msg.sender) {\\n      _deductAllowanceFrom(fromAccountInfo, amount, from);\\n    }\\n    _deductBalanceFrom(fromAccountInfo, amount);\\n    AccountInfo storage toAccountInfo = accountToInfo[to];\\n\\n    // Total ETH cannot realistically overflow 96 bits.\\n    unchecked {\\n      toAccountInfo.freedBalance += uint96(amount);\\n    }\\n\\n    emit Transfer(from, to, amount);\\n\\n    return true;\\n  }\\n\\n  /**\\n   * @notice Withdraw all tokens available in your account and receive ETH.\\n   */\\n  function withdrawAvailableBalance() external {\\n    AccountInfo storage accountInfo = _freeFromEscrow(msg.sender);\\n    uint256 amount = accountInfo.freedBalance;\\n    if (amount == 0) {\\n      revert FETH_No_Funds_To_Withdraw();\\n    }\\n    delete accountInfo.freedBalance;\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    payable(msg.sender).sendValue(amount);\\n\\n    emit ETHWithdrawn(msg.sender, msg.sender, amount);\\n  }\\n\\n  /**\\n   * @notice Withdraw the specified number of tokens from the `from` accounts available balance\\n   * and send ETH to the destination address, if the `msg.sender` has approval.\\n   * @param from The address from which the available funds are to be withdrawn.\\n   * @param to The destination address for the ETH to be transferred to.\\n   * @param amount The number of tokens to be withdrawn and transferred as ETH.\\n   */\\n  function withdrawFrom(\\n    address from,\\n    address payable to,\\n    uint256 amount\\n  ) external {\\n    if (amount == 0) {\\n      revert FETH_No_Funds_To_Withdraw();\\n    } else if (to == address(0)) {\\n      revert FETH_Cannot_Withdraw_To_Address_Zero();\\n    } else if (to == address(this)) {\\n      revert FETH_Cannot_Withdraw_To_FETH();\\n    } else if (to == address(foundationMarket)) {\\n      revert FETH_Cannot_Withdraw_To_Market();\\n    }\\n\\n    AccountInfo storage accountInfo = _freeFromEscrow(from);\\n    if (from != msg.sender) {\\n      _deductAllowanceFrom(accountInfo, amount, from);\\n    }\\n    _deductBalanceFrom(accountInfo, amount);\\n\\n    // With the external call after state changes, we do not need a nonReentrant guard\\n    to.sendValue(amount);\\n\\n    emit ETHWithdrawn(from, to, amount);\\n  }\\n\\n  /**\\n   * @dev Require msg.sender has been approved and deducts the amount from the available allowance.\\n   */\\n  function _deductAllowanceFrom(\\n    AccountInfo storage accountInfo,\\n    uint256 amount,\\n    address from\\n  ) private {\\n    if (accountInfo.allowance[msg.sender] != type(uint256).max) {\\n      if (accountInfo.allowance[msg.sender] < amount) {\\n        revert FETH_Insufficient_Allowance(accountInfo.allowance[msg.sender]);\\n      }\\n      // The check above ensures allowance cannot underflow.\\n      unchecked {\\n        accountInfo.allowance[msg.sender] -= amount;\\n      }\\n      emit Approval(from, msg.sender, accountInfo.allowance[msg.sender]);\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes an amount from the account's available FETH balance.\\n   */\\n  function _deductBalanceFrom(AccountInfo storage accountInfo, uint256 amount) private {\\n    // Free from escrow in order to consider any expired escrow balance\\n    if (accountInfo.freedBalance < amount) {\\n      revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\\n    }\\n    // The check above ensures balance cannot underflow.\\n    unchecked {\\n      accountInfo.freedBalance -= uint96(amount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Moves expired escrow to the available balance.\\n   * Sets the next bucket that hasn't expired as the new start index.\\n   */\\n  function _freeFromEscrow(address account) private returns (AccountInfo storage) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n\\n    // If the first bucket (the oldest) is empty or not yet expired, no change to escrowStartIndex is required\\n    if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\\n      return accountInfo;\\n    }\\n\\n    while (true) {\\n      // Total ETH cannot realistically overflow 96 bits.\\n      unchecked {\\n        accountInfo.freedBalance += escrow.totalAmount;\\n        accountInfo.lockups.del(escrowIndex);\\n        // Escrow index cannot overflow 32 bits.\\n        escrow = accountInfo.lockups.get(escrowIndex + 1);\\n      }\\n\\n      // If the next bucket is empty, the start index is set to the previous bucket\\n      if (escrow.expiration == 0) {\\n        break;\\n      }\\n\\n      // Escrow index cannot overflow 32 bits.\\n      unchecked {\\n        // Increment the escrow start index if the next bucket is not empty\\n        ++escrowIndex;\\n      }\\n\\n      // If the next bucket is expired, that's the new start index\\n      if (escrow.expiration >= block.timestamp) {\\n        break;\\n      }\\n    }\\n\\n    // Escrow index cannot overflow 32 bits.\\n    unchecked {\\n      accountInfo.lockupStartIndex = uint32(escrowIndex);\\n    }\\n    return accountInfo;\\n  }\\n\\n  /**\\n   * @notice Lockup an account's FETH tokens for 24-25 hours.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function _marketLockupFor(address account, uint256 amount) private returns (uint256 expiration) {\\n    if (account == address(0)) {\\n      revert FETH_Cannot_Deposit_For_Lockup_With_Address_Zero();\\n    }\\n    if (amount == 0) {\\n      revert FETH_Must_Lockup_Non_Zero_Amount();\\n    }\\n\\n    // Block timestamp in seconds is small enough to never overflow\\n    unchecked {\\n      // Lockup expires after 24 hours, rounded up to the next hour for a total of [24-25) hours\\n      expiration = lockupDuration + block.timestamp.ceilDiv(lockupInterval) * lockupInterval;\\n    }\\n\\n    // Update available escrow\\n    // Always free from escrow to ensure the max bucket count is <= 25\\n    AccountInfo storage accountInfo = _freeFromEscrow(account);\\n    if (msg.value < amount) {\\n      // The check above prevents underflow with delta.\\n      unchecked {\\n        uint256 delta = amount - msg.value;\\n        if (accountInfo.freedBalance < delta) {\\n          revert FETH_Insufficient_Available_Funds(accountInfo.freedBalance);\\n        }\\n        // The check above prevents underflow of freed balance.\\n        accountInfo.freedBalance -= uint96(delta);\\n      }\\n    } else if (msg.value != amount) {\\n      // There's no reason to send msg.value more than the amount being locked up\\n      revert FETH_Too_Much_ETH_Provided();\\n    }\\n\\n    // Add to locked escrow\\n    unchecked {\\n      // The number of buckets is always < 256 bits.\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          if (expiration > type(uint32).max) {\\n            revert FETH_Expiration_Too_Far_In_Future();\\n          }\\n          // Amount (ETH) will always be < 96 bits.\\n          accountInfo.lockups.set(escrowIndex, expiration, amount);\\n          break;\\n        }\\n        if (escrow.expiration == expiration) {\\n          // Total ETH will always be < 96 bits.\\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount + amount);\\n          break;\\n        }\\n      }\\n    }\\n\\n    emit BalanceLocked(account, expiration, amount, msg.value);\\n  }\\n\\n  /**\\n   * @notice Remove an account's lockup, making the FETH tokens available for transfer or withdrawal.\\n   */\\n  function _marketUnlockFor(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) private {\\n    AccountInfo storage accountInfo = _removeFromLockedBalance(account, expiration, amount);\\n    // Total ETH cannot realistically overflow 96 bits.\\n    unchecked {\\n      accountInfo.freedBalance += uint96(amount);\\n    }\\n  }\\n\\n  /**\\n   * @dev Removes the specified amount from locked escrow, potentially before its expiration.\\n   */\\n  /* solhint-disable-next-line code-complexity */\\n  function _removeFromLockedBalance(\\n    address account,\\n    uint256 expiration,\\n    uint256 amount\\n  ) private returns (AccountInfo storage) {\\n    if (expiration < block.timestamp) {\\n      revert FETH_Escrow_Expired();\\n    }\\n\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    uint256 escrowIndex = accountInfo.lockupStartIndex;\\n    LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n\\n    if (escrow.expiration == expiration) {\\n      // If removing from the first bucket, we may be able to delete it\\n      if (escrow.totalAmount == amount) {\\n        accountInfo.lockups.del(escrowIndex);\\n\\n        // Bump the escrow start index unless it's the last one\\n        if (accountInfo.lockups.get(escrowIndex + 1).expiration != 0) {\\n          // The number of escrow buckets will never overflow 32 bits.\\n          unchecked {\\n            ++accountInfo.lockupStartIndex;\\n          }\\n        }\\n      } else {\\n        if (escrow.totalAmount < amount) {\\n          revert FETH_Insufficient_Escrow(escrow.totalAmount);\\n        }\\n        // The require above ensures balance will not underflow.\\n        unchecked {\\n          accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\\n        }\\n      }\\n    } else {\\n      // Removing from the 2nd+ bucket\\n      while (true) {\\n        // The number of escrow buckets will never overflow 32 bits.\\n        unchecked {\\n          ++escrowIndex;\\n        }\\n        escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == expiration) {\\n          if (amount > escrow.totalAmount) {\\n            revert FETH_Insufficient_Escrow(escrow.totalAmount);\\n          }\\n          // The require above ensures balance will not underflow.\\n          unchecked {\\n            accountInfo.lockups.setTotalAmount(escrowIndex, escrow.totalAmount - amount);\\n          }\\n          // We may have an entry with 0 totalAmount but expiration will be set\\n          break;\\n        }\\n        if (escrow.expiration == 0) {\\n          revert FETH_Escrow_Not_Found();\\n        }\\n      }\\n    }\\n\\n    emit BalanceUnlocked(account, expiration, amount);\\n    return accountInfo;\\n  }\\n\\n  /**\\n   * @notice Returns the amount which a spender is still allowed to transact from the `account`'s balance.\\n   * @param account The owner of the funds.\\n   * @param operator The address with approval to spend from the `account`'s balance.\\n   * @return amount The number of tokens the `operator` is still allowed to transact with.\\n   */\\n  function allowance(address account, address operator) external view returns (uint256 amount) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    amount = accountInfo.allowance[operator];\\n  }\\n\\n  /**\\n   * @notice Returns the balance of an account which is available to transfer or withdraw.\\n   * @dev This will automatically increase as soon as locked tokens reach their expiry date.\\n   * @param account The account to query the available balance of.\\n   * @return balance The available balance of the account.\\n   */\\n  function balanceOf(address account) external view returns (uint256 balance) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    balance = accountInfo.freedBalance;\\n\\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\\n    unchecked {\\n      // Add expired lockups\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0 || escrow.expiration >= block.timestamp) {\\n          break;\\n        }\\n        balance += escrow.totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Gets the Foundation market address which has permissions to manage lockups.\\n   * @return market The Foundation market contract address.\\n   */\\n  function getFoundationMarket() external view returns (address market) {\\n    market = foundationMarket;\\n  }\\n\\n  /**\\n   * @notice Returns the balance and each outstanding (unexpired) lockup bucket for an account, grouped by expiry.\\n   * @dev `expires.length` == `amounts.length`\\n   * and `amounts[i]` is the number of tokens which will expire at `expires[i]`.\\n   * The results returned are sorted by expiry, with the earliest expiry date first.\\n   * @param account The account to query the locked balance of.\\n   * @return expiries The time at which each outstanding lockup bucket expires.\\n   * @return amounts The number of FETH tokens which will expire for each outstanding lockup bucket.\\n   */\\n  function getLockups(address account) external view returns (uint256[] memory expiries, uint256[] memory amounts) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n\\n    // Count lockups\\n    uint256 lockedCount;\\n    // The number of buckets is always < 256 bits.\\n    unchecked {\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\\n          // Lockup count will never overflow 256 bits.\\n          ++lockedCount;\\n        }\\n      }\\n    }\\n\\n    // Allocate arrays\\n    expiries = new uint256[](lockedCount);\\n    amounts = new uint256[](lockedCount);\\n\\n    // Populate results\\n    uint256 i;\\n    // The number of buckets is always < 256 bits.\\n    unchecked {\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        if (escrow.expiration >= block.timestamp && escrow.totalAmount != 0) {\\n          expiries[i] = escrow.expiration;\\n          amounts[i] = escrow.totalAmount;\\n          ++i;\\n        }\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the total balance of an account, including locked FETH tokens.\\n   * @dev Use `balanceOf` to get the number of tokens available for transfer or withdrawal.\\n   * @param account The account to query the total balance of.\\n   * @return balance The total FETH balance tracked for this account.\\n   */\\n  function totalBalanceOf(address account) external view returns (uint256 balance) {\\n    AccountInfo storage accountInfo = accountToInfo[account];\\n    balance = accountInfo.freedBalance;\\n\\n    // Total ETH cannot realistically overflow 96 bits and escrowIndex will always be < 256 bits.\\n    unchecked {\\n      // Add all lockups\\n      for (uint256 escrowIndex = accountInfo.lockupStartIndex; ; ++escrowIndex) {\\n        LockedBalance.Lockup memory escrow = accountInfo.lockups.get(escrowIndex);\\n        if (escrow.expiration == 0) {\\n          break;\\n        }\\n        balance += escrow.totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of ETH locked in this contract.\\n   * @return supply The total amount of ETH locked in this contract.\\n   * @dev It is possible for this to diverge from the total token count by transferring ETH on self destruct\\n   * but this is on-par with the WETH implementation and done for gas savings.\\n   */\\n  function totalSupply() external view returns (uint256 supply) {\\n    return address(this).balance;\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/LockedBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT OR Apache-2.0\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library that handles locked balances efficiently using bit packing.\\n */\\nlibrary LockedBalance {\\n  /// @dev Tracks an account's total lockup per expiration time.\\n  struct Lockup {\\n    uint32 expiration;\\n    uint96 totalAmount;\\n  }\\n\\n  struct Lockups {\\n    /// @dev Mapping from key to lockups.\\n    /// i) A key represents 2 lockups. The key for a lockup is `index / 2`.\\n    ///     For instance, elements with index 25 and 24 would map to the same key.\\n    /// ii) The `value` for the `key` is split into two 128bits which are used to store the metadata for a lockup.\\n    mapping(uint256 => uint256) lockups;\\n  }\\n\\n  // Masks used to split a uint256 into two equal pieces which represent two individual Lockups.\\n  uint256 private constant last128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 private constant first128BitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000;\\n\\n  // Masks used to retrieve or set the totalAmount value of a single Lockup.\\n  uint256 private constant firstAmountBitsMask = 0xFFFFFFFF000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n  uint256 private constant secondAmountBitsMask = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000;\\n\\n  /**\\n   * @notice Clears the lockup at the index.\\n   */\\n  function del(Lockups storage lockups, uint256 index) internal {\\n    unchecked {\\n      if (index % 2 == 0) {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask);\\n      } else {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets the Lockup at the provided index.\\n   */\\n  function set(\\n    Lockups storage lockups,\\n    uint256 index,\\n    uint256 expiration,\\n    uint256 totalAmount\\n  ) internal {\\n    unchecked {\\n      uint256 lockedBalanceBits = totalAmount | (expiration << 96);\\n      if (index % 2 == 0) {\\n        // set first 128 bits.\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & last128BitsMask) | (lockedBalanceBits << 128);\\n      } else {\\n        // set last 128 bits.\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & first128BitsMask) | lockedBalanceBits;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Sets only the totalAmount for a lockup at the index.\\n   */\\n  function setTotalAmount(\\n    Lockups storage lockups,\\n    uint256 index,\\n    uint256 totalAmount\\n  ) internal {\\n    unchecked {\\n      if (index % 2 == 0) {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & firstAmountBitsMask) | (totalAmount << 128);\\n      } else {\\n        index /= 2;\\n        lockups.lockups[index] = (lockups.lockups[index] & secondAmountBitsMask) | totalAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Returns the Lockup at the provided index.\\n   * @dev To get the lockup stored in the *first* 128 bits (first slot/lockup):\\n   *       - we remove the last 128 bits (done by >> 128)\\n   *      To get the lockup stored in the *last* 128 bits (second slot/lockup):\\n   *       - we take the last 128 bits (done by % (2**128))\\n   *      Once the lockup is obtained:\\n   *       - get `expiration` by peaking at the first 32 bits (done by >> 96)\\n   *       - get `totalAmount` by peaking at the last 96 bits (done by % (2**96))\\n   */\\n  function get(Lockups storage lockups, uint256 index) internal view returns (Lockup memory balance) {\\n    unchecked {\\n      uint256 lockupMetadata = lockups.lockups[index / 2];\\n      if (lockupMetadata == 0) {\\n        return balance;\\n      }\\n      uint128 lockedBalanceBits;\\n      if (index % 2 == 0) {\\n        // use first 128 bits.\\n        lockedBalanceBits = uint128(lockupMetadata >> 128);\\n      } else {\\n        // use last 128 bits.\\n        lockedBalanceBits = uint128(lockupMetadata % (2**128));\\n      }\\n      // unpack the bits to retrieve the Lockup.\\n      balance.expiration = uint32(lockedBalanceBits >> 96);\\n      balance.totalAmount = uint96(lockedBalanceBits % (2**96));\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1337\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_foundationMarket\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockupDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Deposit_For_Lockup_With_Address_Zero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Deposit_To_Address_Zero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Deposit_To_FETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Withdraw_To_Address_Zero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Withdraw_To_FETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Cannot_Withdraw_To_Market\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Escrow_Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Escrow_Not_Found\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Expiration_Too_Far_In_Future\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FETH_Insufficient_Allowance\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FETH_Insufficient_Available_Funds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FETH_Insufficient_Escrow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Invalid_Lockup_Duration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Market_Must_Be_A_Contract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Must_Deposit_Non_Zero_Amount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Must_Lockup_Non_Zero_Amount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_No_Funds_To_Withdraw\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Only_FND_Market_Allowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Too_Much_ETH_Provided\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Transfer_To_Address_Zero_Not_Allowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FETH_Transfer_To_FETH_Not_Allowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"valueDeposited\",\"type\":\"uint256\"}],\"name\":\"BalanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ETHWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFoundationMarket\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"market\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getLockups\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"expiries\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unlockFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unlockExpiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unlockAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"lockupFor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockupAmount\",\"type\":\"uint256\"}],\"name\":\"marketChangeLockup\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"marketLockupFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"marketUnlockFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"marketWithdrawFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"marketWithdrawLocked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAvailableBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FETH", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1337", "ConstructorArguments": "000000000000000000000000cda72070e455bb31c7690a170224ce43623d0b6f0000000000000000000000000000000000000000000000000000000000015180", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}