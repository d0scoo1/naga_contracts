{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: None\r\n    // All rights reserved. @2022\r\n    \r\n    /*\r\n __          ___     _ _        _____      _          _               \r\n \\ \\        / / |   (_) |      / ____|    | |        | |              \r\n  \\ \\  /\\  / /| |__  _| |_ ___| |    _   _| |__   ___| | ___  ___ ___ \r\n   \\ \\/  \\/ / | '_ \\| | __/ _ \\ |   | | | | '_ \\ / _ \\ |/ _ \\/ __/ __|\r\n    \\  /\\  /  | | | | | ||  __/ |___| |_| | |_) |  __/ |  __/\\__ \\__ \\\r\n     \\/  \\/   |_| |_|_|\\__\\___|\\_____\\__,_|_.__/ \\___|_|\\___||___/___/\r\n                                                                      \r\n    */\r\n\r\n    // File: @openzeppelin/contracts/utils/cryptography/MerkleProof.sol\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev These functions deal with verification of Merkle Trees proofs.\r\n    *\r\n    * The proofs can be generated using the JavaScript library\r\n    * https://github.com/miguelmota/merkletreejs[merkletreejs].\r\n    * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\r\n    *\r\n    * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\r\n    */\r\n    library MerkleProof {\r\n        /**\r\n        * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n        * defined by `root`. For this, a `proof` must be provided, containing\r\n        * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n        * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n        */\r\n        function verify(\r\n            bytes32[] memory proof,\r\n            bytes32 root,\r\n            bytes32 leaf\r\n        ) internal pure returns (bool) {\r\n            return processProof(proof, leaf) == root;\r\n        }\r\n\r\n        /**\r\n        * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\r\n        * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n        * hash matches the root of the tree. When processing the proof, the pairs\r\n        * of leafs & pre-images are assumed to be sorted.\r\n        *\r\n        * _Available since v4.4._\r\n        */\r\n        function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n            bytes32 computedHash = leaf;\r\n            for (uint256 i = 0; i < proof.length; i++) {\r\n                bytes32 proofElement = proof[i];\r\n                if (computedHash <= proofElement) {\r\n                    // Hash(current computed hash + current element of the proof)\r\n                    computedHash = _efficientHash(computedHash, proofElement);\r\n                } else {\r\n                    // Hash(current element of the proof + current computed hash)\r\n                    computedHash = _efficientHash(proofElement, computedHash);\r\n                }\r\n            }\r\n            return computedHash;\r\n        }\r\n\r\n        function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n            assembly {\r\n                mstore(0x00, a)\r\n                mstore(0x20, b)\r\n                value := keccak256(0x00, 0x40)\r\n            }\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/utils/introspection/IERC165.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n    /**\r\n    * @dev Interface of the ERC165 standard, as defined in the\r\n    * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n    *\r\n    * Implementers can declare support of contract interfaces, which can then be\r\n    * queried by others ({ERC165Checker}).\r\n    *\r\n    * For an implementation, see {ERC165}.\r\n    */\r\n    interface IERC165 {\r\n        /**\r\n        * @dev Returns true if this contract implements the interface defined by\r\n        * `interfaceId`. See the corresponding\r\n        * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n        * to learn more about how these ids are created.\r\n        *\r\n        * This function call must use less than 30 000 gas.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/interfaces/IERC165.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    // File: @openzeppelin/contracts/interfaces/IERC2981.sol\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Interface for the NFT Royalty Standard.\r\n    *\r\n    * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\r\n    * support for royalty payments across all NFT marketplaces and ecosystem participants.\r\n    *\r\n    * _Available since v4.5._\r\n    */\r\n    interface IERC2981 is IERC165 {\r\n        /**\r\n        * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\r\n        * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\r\n        */\r\n        function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n            external\r\n            view\r\n            returns (address receiver, uint256 royaltyAmount);\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/IERC721.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Required interface of an ERC721 compliant contract.\r\n    */\r\n    interface IERC721 is IERC165 {\r\n        /**\r\n        * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n        */\r\n        event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n        /**\r\n        * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n        */\r\n        event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n        /**\r\n        * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n        */\r\n        event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n        /**\r\n        * @dev Returns the number of tokens in ``owner``'s account.\r\n        */\r\n        function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n        /**\r\n        * @dev Returns the owner of the `tokenId` token.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        */\r\n        function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n        /**\r\n        * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n        * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must exist and be owned by `from`.\r\n        * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) external;\r\n\r\n        /**\r\n        * @dev Transfers `tokenId` token from `from` to `to`.\r\n        *\r\n        * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must be owned by `from`.\r\n        * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) external;\r\n\r\n        /**\r\n        * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n        * The approval is cleared when the token is transferred.\r\n        *\r\n        * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The caller must own the token or be an approved operator.\r\n        * - `tokenId` must exist.\r\n        *\r\n        * Emits an {Approval} event.\r\n        */\r\n        function approve(address to, uint256 tokenId) external;\r\n\r\n        /**\r\n        * @dev Returns the account approved for `tokenId` token.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        */\r\n        function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n        /**\r\n        * @dev Approve or remove `operator` as an operator for the caller.\r\n        * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - The `operator` cannot be the caller.\r\n        *\r\n        * Emits an {ApprovalForAll} event.\r\n        */\r\n        function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n        /**\r\n        * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n        *\r\n        * See {setApprovalForAll}\r\n        */\r\n        function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n        /**\r\n        * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must exist and be owned by `from`.\r\n        * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes calldata data\r\n        ) external;\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n    * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n    */\r\n    interface IERC721Metadata is IERC721 {\r\n        /**\r\n        * @dev Returns the token collection name.\r\n        */\r\n        function name() external view returns (string memory);\r\n\r\n        /**\r\n        * @dev Returns the token collection symbol.\r\n        */\r\n        function symbol() external view returns (string memory);\r\n\r\n        /**\r\n        * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\r\n        */\r\n        function tokenURI(uint256 tokenId) external view returns (string memory);\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n    * @dev See https://eips.ethereum.org/EIPS/eip-721\r\n    */\r\n    interface IERC721Enumerable is IERC721 {\r\n        /**\r\n        * @dev Returns the total amount of tokens stored by the contract.\r\n        */\r\n        function totalSupply() external view returns (uint256);\r\n\r\n        /**\r\n        * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\r\n        * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\r\n        */\r\n        function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\r\n\r\n        /**\r\n        * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n        * Use along with {totalSupply} to enumerate all tokens.\r\n        */\r\n        function tokenByIndex(uint256 index) external view returns (uint256);\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/utils/introspection/ERC165.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n    /**\r\n    * @dev Implementation of the {IERC165} interface.\r\n    *\r\n    * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n    * for the additional interface id that will be supported. For example:\r\n    *\r\n    * ```solidity\r\n    * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n    *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n    * }\r\n    * ```\r\n    *\r\n    * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n    */\r\n    abstract contract ERC165 is IERC165 {\r\n        /**\r\n        * @dev See {IERC165-supportsInterface}.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n            return interfaceId == type(IERC165).interfaceId;\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n    /**\r\n    * @title ERC721 token receiver interface\r\n    * @dev Interface for any contract that wants to support safeTransfers\r\n    * from ERC721 asset contracts.\r\n    */\r\n    interface IERC721Receiver {\r\n        /**\r\n        * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n        * by `operator` from `from`, this function is called.\r\n        *\r\n        * It must return its Solidity selector to confirm the token transfer.\r\n        * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n        *\r\n        * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\r\n        */\r\n        function onERC721Received(\r\n            address operator,\r\n            address from,\r\n            uint256 tokenId,\r\n            bytes calldata data\r\n        ) external returns (bytes4);\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n    /**\r\n    * @dev Provides information about the current execution context, including the\r\n    * sender of the transaction and its data. While these are generally available\r\n    * via msg.sender and msg.data, they should not be accessed in such a direct\r\n    * manner, since when dealing with meta-transactions the account sending and\r\n    * paying for execution may not be the actual sender (as far as an application\r\n    * is concerned).\r\n    *\r\n    * This contract is only required for intermediate, library-like contracts.\r\n    */\r\n    abstract contract Context {\r\n        function _msgSender() internal view virtual returns (address) {\r\n            return msg.sender;\r\n        }\r\n\r\n        function _msgData() internal view virtual returns (bytes calldata) {\r\n            return msg.data;\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n    /**\r\n    * @dev String operations.\r\n    */\r\n    library Strings {\r\n        bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n        /**\r\n        * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n        */\r\n        function toString(uint256 value) internal pure returns (string memory) {\r\n            // Inspired by OraclizeAPI's implementation - MIT licence\r\n            // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n            if (value == 0) {\r\n                return \"0\";\r\n            }\r\n            uint256 temp = value;\r\n            uint256 digits;\r\n            while (temp != 0) {\r\n                digits++;\r\n                temp /= 10;\r\n            }\r\n            bytes memory buffer = new bytes(digits);\r\n            while (value != 0) {\r\n                digits -= 1;\r\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n                value /= 10;\r\n            }\r\n            return string(buffer);\r\n        }\r\n\r\n        /**\r\n        * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n        */\r\n        function toHexString(uint256 value) internal pure returns (string memory) {\r\n            if (value == 0) {\r\n                return \"0x00\";\r\n            }\r\n            uint256 temp = value;\r\n            uint256 length = 0;\r\n            while (temp != 0) {\r\n                length++;\r\n                temp >>= 8;\r\n            }\r\n            return toHexString(value, length);\r\n        }\r\n\r\n        /**\r\n        * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n        */\r\n        function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n            bytes memory buffer = new bytes(2 * length + 2);\r\n            buffer[0] = \"0\";\r\n            buffer[1] = \"x\";\r\n            for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n                buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n                value >>= 4;\r\n            }\r\n            require(value == 0, \"Strings: hex length insufficient\");\r\n            return string(buffer);\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\n    pragma solidity ^0.8.1;\r\n\r\n    /**\r\n    * @dev Collection of functions related to the address type\r\n    */\r\n    library Address {\r\n        /**\r\n        * @dev Returns true if `account` is a contract.\r\n        *\r\n        * [IMPORTANT]\r\n        * ====\r\n        * It is unsafe to assume that an address for which this function returns\r\n        * false is an externally-owned account (EOA) and not a contract.\r\n        *\r\n        * Among others, `isContract` will return false for the following\r\n        * types of addresses:\r\n        *\r\n        *  - an externally-owned account\r\n        *  - a contract in construction\r\n        *  - an address where a contract will be created\r\n        *  - an address where a contract lived, but was destroyed\r\n        * ====\r\n        *\r\n        * [IMPORTANT]\r\n        * ====\r\n        * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n        *\r\n        * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n        * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n        * constructor.\r\n        * ====\r\n        */\r\n        function isContract(address account) internal view returns (bool) {\r\n            // This method relies on extcodesize/address.code.length, which returns 0\r\n            // for contracts in construction, since the code is only stored at the end\r\n            // of the constructor execution.\r\n\r\n            return account.code.length > 0;\r\n        }\r\n\r\n        /**\r\n        * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n        * `recipient`, forwarding all available gas and reverting on errors.\r\n        *\r\n        * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n        * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n        * imposed by `transfer`, making them unable to receive funds via\r\n        * `transfer`. {sendValue} removes this limitation.\r\n        *\r\n        * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n        *\r\n        * IMPORTANT: because control is transferred to `recipient`, care must be\r\n        * taken to not create reentrancy vulnerabilities. Consider using\r\n        * {ReentrancyGuard} or the\r\n        * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n        */\r\n        function sendValue(address payable recipient, uint256 amount) internal {\r\n            require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n            (bool success, ) = recipient.call{value: amount}(\"\");\r\n            require(success, \"Address: unable to send value, recipient may have reverted\");\r\n        }\r\n\r\n        /**\r\n        * @dev Performs a Solidity function call using a low level `call`. A\r\n        * plain `call` is an unsafe replacement for a function call: use this\r\n        * function instead.\r\n        *\r\n        * If `target` reverts with a revert reason, it is bubbled up by this\r\n        * function (like regular Solidity function calls).\r\n        *\r\n        * Returns the raw returned data. To convert to the expected return value,\r\n        * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `target` must be a contract.\r\n        * - calling `target` with `data` must not revert.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n            return functionCall(target, data, \"Address: low-level call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n        * `errorMessage` as a fallback revert reason when `target` reverts.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCall(\r\n            address target,\r\n            bytes memory data,\r\n            string memory errorMessage\r\n        ) internal returns (bytes memory) {\r\n            return functionCallWithValue(target, data, 0, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but also transferring `value` wei to `target`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - the calling contract must have an ETH balance of at least `value`.\r\n        * - the called Solidity function must be `payable`.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCallWithValue(\r\n            address target,\r\n            bytes memory data,\r\n            uint256 value\r\n        ) internal returns (bytes memory) {\r\n            return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n        * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n        *\r\n        * _Available since v3.1._\r\n        */\r\n        function functionCallWithValue(\r\n            address target,\r\n            bytes memory data,\r\n            uint256 value,\r\n            string memory errorMessage\r\n        ) internal returns (bytes memory) {\r\n            require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n            require(isContract(target), \"Address: call to non-contract\");\r\n\r\n            (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n            return verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but performing a static call.\r\n        *\r\n        * _Available since v3.3._\r\n        */\r\n        function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n            return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n        * but performing a static call.\r\n        *\r\n        * _Available since v3.3._\r\n        */\r\n        function functionStaticCall(\r\n            address target,\r\n            bytes memory data,\r\n            string memory errorMessage\r\n        ) internal view returns (bytes memory) {\r\n            require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n            (bool success, bytes memory returndata) = target.staticcall(data);\r\n            return verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n        * but performing a delegate call.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n            return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n        * but performing a delegate call.\r\n        *\r\n        * _Available since v3.4._\r\n        */\r\n        function functionDelegateCall(\r\n            address target,\r\n            bytes memory data,\r\n            string memory errorMessage\r\n        ) internal returns (bytes memory) {\r\n            require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n            (bool success, bytes memory returndata) = target.delegatecall(data);\r\n            return verifyCallResult(success, returndata, errorMessage);\r\n        }\r\n\r\n        /**\r\n        * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n        * revert reason using the provided one.\r\n        *\r\n        * _Available since v4.3._\r\n        */\r\n        function verifyCallResult(\r\n            bool success,\r\n            bytes memory returndata,\r\n            string memory errorMessage\r\n        ) internal pure returns (bytes memory) {\r\n            if (success) {\r\n                return returndata;\r\n            } else {\r\n                // Look for revert reason and bubble it up if present\r\n                if (returndata.length > 0) {\r\n                    // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                    assembly {\r\n                        let returndata_size := mload(returndata)\r\n                        revert(add(32, returndata), returndata_size)\r\n                    }\r\n                } else {\r\n                    revert(errorMessage);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/ERC721.sol\r\n\r\n\r\n    // OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/ERC721.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /**\r\n    * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\r\n    * the Metadata extension, but not including the Enumerable extension, which is available separately as\r\n    * {ERC721Enumerable}.\r\n    */\r\n    contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\r\n        using Address for address;\r\n        using Strings for uint256;\r\n\r\n        // Token name\r\n        string private _name;\r\n\r\n        // Token symbol\r\n        string private _symbol;\r\n\r\n        // Mapping from token ID to owner address\r\n        mapping(uint256 => address) private _owners;\r\n\r\n        // Mapping owner address to token count\r\n        mapping(address => uint256) private _balances;\r\n\r\n        // Mapping from token ID to approved address\r\n        mapping(uint256 => address) private _tokenApprovals;\r\n\r\n        // Mapping from owner to operator approvals\r\n        mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n        /**\r\n        * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\r\n        */\r\n        constructor(string memory name_, string memory symbol_) {\r\n            _name = name_;\r\n            _symbol = symbol_;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC165-supportsInterface}.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n            return\r\n                interfaceId == type(IERC721).interfaceId ||\r\n                interfaceId == type(IERC721Metadata).interfaceId ||\r\n                super.supportsInterface(interfaceId);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-balanceOf}.\r\n        */\r\n        function balanceOf(address owner) public view virtual override returns (uint256) {\r\n            require(owner != address(0), \"ERC721: balance query for the zero address\");\r\n            return _balances[owner];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-ownerOf}.\r\n        */\r\n        function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n            address owner = _owners[tokenId];\r\n            require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n            return owner;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Metadata-name}.\r\n        */\r\n        function name() public view virtual override returns (string memory) {\r\n            return _name;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Metadata-symbol}.\r\n        */\r\n        function symbol() public view virtual override returns (string memory) {\r\n            return _symbol;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Metadata-tokenURI}.\r\n        */\r\n        function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n            require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n            string memory baseURI = _baseURI();\r\n            return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n        }\r\n\r\n        /**\r\n        * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\r\n        * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\r\n        * by default, can be overriden in child contracts.\r\n        */\r\n        function _baseURI() internal view virtual returns (string memory) {\r\n            return \"\";\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-approve}.\r\n        */\r\n        function approve(address to, uint256 tokenId) public virtual override {\r\n            address owner = ERC721.ownerOf(tokenId);\r\n            require(to != owner, \"ERC721: approval to current owner\");\r\n\r\n            require(\r\n                _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n                \"ERC721: approve caller is not owner nor approved for all\"\r\n            );\r\n\r\n            _approve(to, tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-getApproved}.\r\n        */\r\n        function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n            require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n\r\n            return _tokenApprovals[tokenId];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-setApprovalForAll}.\r\n        */\r\n        function setApprovalForAll(address operator, bool approved) public virtual override {\r\n            _setApprovalForAll(_msgSender(), operator, approved);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-isApprovedForAll}.\r\n        */\r\n        function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n            return _operatorApprovals[owner][operator];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-transferFrom}.\r\n        */\r\n        function transferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) public virtual override {\r\n            //solhint-disable-next-line max-line-length\r\n            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n\r\n            _transfer(from, to, tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-safeTransferFrom}.\r\n        */\r\n        function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) public virtual override {\r\n            safeTransferFrom(from, to, tokenId, \"\");\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721-safeTransferFrom}.\r\n        */\r\n        function safeTransferFrom(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes memory _data\r\n        ) public virtual override {\r\n            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\r\n            _safeTransfer(from, to, tokenId, _data);\r\n        }\r\n\r\n        /**\r\n        * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n        * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n        *\r\n        * `_data` is additional data, it has no specified format and it is sent in call to `to`.\r\n        *\r\n        * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\r\n        * implement alternative mechanisms to perform token transfer, such as signature-based.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must exist and be owned by `from`.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function _safeTransfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes memory _data\r\n        ) internal virtual {\r\n            _transfer(from, to, tokenId);\r\n            require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n        }\r\n\r\n        /**\r\n        * @dev Returns whether `tokenId` exists.\r\n        *\r\n        * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\r\n        *\r\n        * Tokens start existing when they are minted (`_mint`),\r\n        * and stop existing when they are burned (`_burn`).\r\n        */\r\n        function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n            return _owners[tokenId] != address(0);\r\n        }\r\n\r\n        /**\r\n        * @dev Returns whether `spender` is allowed to manage `tokenId`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        */\r\n        function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n            require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n            address owner = ERC721.ownerOf(tokenId);\r\n            return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\r\n        }\r\n\r\n        /**\r\n        * @dev Safely mints `tokenId` and transfers it to `to`.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must not exist.\r\n        * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function _safeMint(address to, uint256 tokenId) internal virtual {\r\n            _safeMint(to, tokenId, \"\");\r\n        }\r\n\r\n        /**\r\n        * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\r\n        * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\r\n        */\r\n        function _safeMint(\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes memory _data\r\n        ) internal virtual {\r\n            _mint(to, tokenId);\r\n            require(\r\n                _checkOnERC721Received(address(0), to, tokenId, _data),\r\n                \"ERC721: transfer to non ERC721Receiver implementer\"\r\n            );\r\n        }\r\n\r\n        /**\r\n        * @dev Mints `tokenId` and transfers it to `to`.\r\n        *\r\n        * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must not exist.\r\n        * - `to` cannot be the zero address.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function _mint(address to, uint256 tokenId) internal virtual {\r\n            require(to != address(0), \"ERC721: mint to the zero address\");\r\n            require(!_exists(tokenId), \"ERC721: token already minted\");\r\n\r\n            _beforeTokenTransfer(address(0), to, tokenId);\r\n\r\n            _balances[to] += 1;\r\n            _owners[tokenId] = to;\r\n\r\n            emit Transfer(address(0), to, tokenId);\r\n\r\n            _afterTokenTransfer(address(0), to, tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev Destroys `tokenId`.\r\n        * The approval is cleared when the token is burned.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `tokenId` must exist.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function _burn(uint256 tokenId) internal virtual {\r\n            address owner = ERC721.ownerOf(tokenId);\r\n\r\n            _beforeTokenTransfer(owner, address(0), tokenId);\r\n\r\n            // Clear approvals\r\n            _approve(address(0), tokenId);\r\n\r\n            _balances[owner] -= 1;\r\n            delete _owners[tokenId];\r\n\r\n            emit Transfer(owner, address(0), tokenId);\r\n\r\n            _afterTokenTransfer(owner, address(0), tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev Transfers `tokenId` from `from` to `to`.\r\n        *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `to` cannot be the zero address.\r\n        * - `tokenId` token must be owned by `from`.\r\n        *\r\n        * Emits a {Transfer} event.\r\n        */\r\n        function _transfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) internal virtual {\r\n            require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\r\n            require(to != address(0), \"ERC721: transfer to the zero address\");\r\n\r\n            _beforeTokenTransfer(from, to, tokenId);\r\n\r\n            // Clear approvals from the previous owner\r\n            _approve(address(0), tokenId);\r\n\r\n            _balances[from] -= 1;\r\n            _balances[to] += 1;\r\n            _owners[tokenId] = to;\r\n\r\n            emit Transfer(from, to, tokenId);\r\n\r\n            _afterTokenTransfer(from, to, tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev Approve `to` to operate on `tokenId`\r\n        *\r\n        * Emits a {Approval} event.\r\n        */\r\n        function _approve(address to, uint256 tokenId) internal virtual {\r\n            _tokenApprovals[tokenId] = to;\r\n            emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev Approve `operator` to operate on all of `owner` tokens\r\n        *\r\n        * Emits a {ApprovalForAll} event.\r\n        */\r\n        function _setApprovalForAll(\r\n            address owner,\r\n            address operator,\r\n            bool approved\r\n        ) internal virtual {\r\n            require(owner != operator, \"ERC721: approve to caller\");\r\n            _operatorApprovals[owner][operator] = approved;\r\n            emit ApprovalForAll(owner, operator, approved);\r\n        }\r\n\r\n        /**\r\n        * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\r\n        * The call is not executed if the target address is not a contract.\r\n        *\r\n        * @param from address representing the previous owner of the given token ID\r\n        * @param to target address that will receive the tokens\r\n        * @param tokenId uint256 ID of the token to be transferred\r\n        * @param _data bytes optional data to send along with the call\r\n        * @return bool whether the call correctly returned the expected magic value\r\n        */\r\n        function _checkOnERC721Received(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId,\r\n            bytes memory _data\r\n        ) private returns (bool) {\r\n            if (to.isContract()) {\r\n                try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\r\n                    return retval == IERC721Receiver.onERC721Received.selector;\r\n                } catch (bytes memory reason) {\r\n                    if (reason.length == 0) {\r\n                        revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                    } else {\r\n                        assembly {\r\n                            revert(add(32, reason), mload(reason))\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        /**\r\n        * @dev Hook that is called before any token transfer. This includes minting\r\n        * and burning.\r\n        *\r\n        * Calling conditions:\r\n        *\r\n        * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n        * transferred to `to`.\r\n        * - When `from` is zero, `tokenId` will be minted for `to`.\r\n        * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n        * - `from` and `to` are never both zero.\r\n        *\r\n        * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n        */\r\n        function _beforeTokenTransfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) internal virtual {}\r\n\r\n        /**\r\n        * @dev Hook that is called after any transfer of tokens. This includes\r\n        * minting and burning.\r\n        *\r\n        * Calling conditions:\r\n        *\r\n        * - when `from` and `to` are both non-zero.\r\n        * - `from` and `to` are never both zero.\r\n        *\r\n        * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n        */\r\n        function _afterTokenTransfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) internal virtual {}\r\n    }\r\n\r\n    // File: @openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\r\n\r\n\r\n    // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\r\n\r\n    pragma solidity ^0.8.0;\r\n\r\n\r\n\r\n    /**\r\n    * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\r\n    * enumerability of all the token ids in the contract as well as all token ids owned by each\r\n    * account.\r\n    */\r\n    abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\r\n        // Mapping from owner to list of owned token IDs\r\n        mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n        // Mapping from token ID to index of the owner tokens list\r\n        mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n        // Array with all token ids, used for enumeration\r\n        uint256[] private _allTokens;\r\n\r\n        // Mapping from token id to position in the allTokens array\r\n        mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n        /**\r\n        * @dev See {IERC165-supportsInterface}.\r\n        */\r\n        function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\r\n            return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n        */\r\n        function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\r\n            require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\r\n            return _ownedTokens[owner][index];\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Enumerable-totalSupply}.\r\n        */\r\n        function totalSupply() public view virtual override returns (uint256) {\r\n            return _allTokens.length;\r\n        }\r\n\r\n        /**\r\n        * @dev See {IERC721Enumerable-tokenByIndex}.\r\n        */\r\n        function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\r\n            require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\r\n            return _allTokens[index];\r\n        }\r\n\r\n        /**\r\n        * @dev Hook that is called before any token transfer. This includes minting\r\n        * and burning.\r\n        *\r\n        * Calling conditions:\r\n        *\r\n        * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n        * transferred to `to`.\r\n        * - When `from` is zero, `tokenId` will be minted for `to`.\r\n        * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n        * - `from` cannot be the zero address.\r\n        * - `to` cannot be the zero address.\r\n        *\r\n        * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n        */\r\n        function _beforeTokenTransfer(\r\n            address from,\r\n            address to,\r\n            uint256 tokenId\r\n        ) internal virtual override {\r\n            super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n            if (from == address(0)) {\r\n                _addTokenToAllTokensEnumeration(tokenId);\r\n            } else if (from != to) {\r\n                _removeTokenFromOwnerEnumeration(from, tokenId);\r\n            }\r\n            if (to == address(0)) {\r\n                _removeTokenFromAllTokensEnumeration(tokenId);\r\n            } else if (to != from) {\r\n                _addTokenToOwnerEnumeration(to, tokenId);\r\n            }\r\n        }\r\n\r\n        /**\r\n        * @dev Private function to add a token to this extension's ownership-tracking data structures.\r\n        * @param to address representing the new owner of the given token ID\r\n        * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n        */\r\n        function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\r\n            uint256 length = ERC721.balanceOf(to);\r\n            _ownedTokens[to][length] = tokenId;\r\n            _ownedTokensIndex[tokenId] = length;\r\n        }\r\n\r\n        /**\r\n        * @dev Private function to add a token to this extension's token tracking data structures.\r\n        * @param tokenId uint256 ID of the token to be added to the tokens list\r\n        */\r\n        function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\r\n            _allTokensIndex[tokenId] = _allTokens.length;\r\n            _allTokens.push(tokenId);\r\n        }\r\n\r\n        /**\r\n        * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n        * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n        * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n        * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n        * @param from address representing the previous owner of the given token ID\r\n        * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n        */\r\n        function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\r\n            // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\r\n            // then delete the last slot (swap and pop).\r\n\r\n            uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\r\n            uint256 tokenIndex = _ownedTokensIndex[tokenId];\r\n\r\n            // When the token to delete is the last token, the swap operation is unnecessary\r\n            if (tokenIndex != lastTokenIndex) {\r\n                uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\r\n\r\n                _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n                _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n            }\r\n\r\n            // This also deletes the contents at the last position of the array\r\n            delete _ownedTokensIndex[tokenId];\r\n            delete _ownedTokens[from][lastTokenIndex];\r\n        }\r\n\r\n        /**\r\n        * @dev Private function to remove a token from this extension's token tracking data structures.\r\n        * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n        * @param tokenId uint256 ID of the token to be removed from the tokens list\r\n        */\r\n        function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\r\n            // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\r\n            // then delete the last slot (swap and pop).\r\n\r\n            uint256 lastTokenIndex = _allTokens.length - 1;\r\n            uint256 tokenIndex = _allTokensIndex[tokenId];\r\n\r\n            // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\r\n            // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\r\n            // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\r\n            uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n            _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\r\n            _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\r\n\r\n            // This also deletes the contents at the last position of the array\r\n            delete _allTokensIndex[tokenId];\r\n            _allTokens.pop();\r\n        }\r\n    }\r\n    // File: contracts/Cubeless.sol\r\n\r\n\r\n    pragma solidity ^0.8.7;\r\n\r\n\r\n    abstract contract ERC2981Collection is IERC2981 {\r\n\r\n    // ERC165\r\n    // _setRoyalties(address,uint256) => 0x40a04a5a\r\n    // royaltyInfo(uint256,uint256) => 0x2a55205a\r\n    // ERC2981Collection => 0x6af56a00\r\n\r\n    address private royaltyAddress;\r\n    uint256 private royaltyPercent;\r\n\r\n    // Set to be internal function _setRoyalties\r\n    // _setRoyalties(address,uint256) => 0x40a04a5a\r\n    function _setRoyalties(address _receiver, uint256 _percentage) internal {\r\n        royaltyAddress = _receiver;\r\n        royaltyPercent = _percentage;\r\n    }\r\n\r\n    // Override for royaltyInfo(uint256, uint256)\r\n    // royaltyInfo(uint256,uint256) => 0x2a55205a\r\n    /*\r\n    function royaltyInfo(\r\n        uint256 _tokenId,\r\n        uint256 _salePrice\r\n    ) external view override(IERC2981) virtual returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    ) {\r\n        receiver = royaltyAddress;\r\n\r\n        // This sets percentages by price * percentage / 100\r\n        royaltyAmount = _salePrice * royaltyPercent / 100;\r\n    }\r\n    */\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    /// owner:    \ud835\uddea\ud835\udddb\ud835\udddc\ud835\udde7\ud835\uddd8\ud835\uddd6\ud835\udde8\ud835\uddd5\ud835\uddd8\ud835\udddf\ud835\uddd8\ud835\udde6\ud835\udde6 - \ud835\udde6\ud835\uddec\ud835\uddd7\ud835\udde1\ud835\uddd8\ud835\uddec - \ud835\uddd4\ud835\udde8\ud835\udde6\ud835\udde7\ud835\udde5\ud835\uddd4\ud835\udddf\ud835\udddc\ud835\uddd4\r\n    /// author:   pamuk.eth\r\n    /// White Cubeless Pty Ltd is a blockchain technology company registered in Australia. All rights reserved by White Cubeless Pty Ltd. @2022    \r\n    /// Live Version -\r\n    \r\n    \r\n    /**\r\n    * @dev Heavily customized ERC721 supporting,\r\n    *\r\n    * - Multiple drop management\r\n    * - Contingent transactions\r\n    * - Reservation\r\n    * - Owner mint \r\n    * - URI recycling\r\n    * - Merkletree Presale\r\n    * - Drop-Wise Royalties\r\n    * - PublicSale\r\n    * - 3 Way Balance of Powers\r\n    */\r\n\r\n    contract WhiteCubeless is ERC721Enumerable,ERC2981Collection  {\r\n        \r\n        //\ud835\udde9\ud835\uddd4\ud835\udde5\ud835\udddc\ud835\uddd4\ud835\uddd5\ud835\udddf\ud835\uddd8 \ud835\uddd7\ud835\uddd8\ud835\uddd6\ud835\udddf\ud835\uddd4\ud835\udde5\ud835\uddd4\ud835\udde7\ud835\udddc\ud835\udde2\ud835\udde1\ud835\udde6:\r\n        \r\n\r\n        //\ud835\uddd8\ud835\udde9\ud835\uddd8\ud835\udde1\ud835\udde7\ud835\udde6\r\n\r\n        /// @dev emitted after mint\r\n        event Mint(address indexed _to, uint256 indexed _tokenId, uint256 indexed _artworkId);\r\n\r\n        /// @dev emitted after burn\r\n        event Burn( uint256 indexed _tokenId, uint256 indexed _artworkId);\r\n\r\n        /// @dev freezes metadata for marketplaces\r\n        event PermanentURI( string _value, uint256 indexed _id);\r\n\r\n        /// @dev emitted after artwork adeed\r\n        event ArtworkAdded( string uri, uint256  _ArtworkId,uint256  _Limit);\r\n\r\n        //\ud835\uddda\ud835\udddf\ud835\udde2\ud835\uddd5\ud835\uddd4\ud835\udddf\r\n        \r\n        uint256 constant public ONE_MILLION = 1_000_000;\r\n        \r\n\r\n        //\ud835\udde9\ud835\uddd8\ud835\udde5\ud835\udde6\ud835\udddc\ud835\udde2\ud835\udde1\ud835\udddc\ud835\udde1\ud835\uddda\r\n        \r\n        /// @dev this is to make sure any tokenID generated by WhiteCubeless is unique even the contract is different.\r\n        uint256 constant public WhiteCubelessGalleryVersion  = 1;\r\n        \r\n        /// @dev assign first ID\r\n        uint256  public nextartworkId = WhiteCubelessGalleryVersion*ONE_MILLION;\r\n\r\n        \r\n        //\ud835\uddda\ud835\uddd4\ud835\udddf\ud835\udddf\ud835\uddd8\ud835\udde5\ud835\uddec \ud835\uddd8\ud835\uddd7\ud835\udddc\ud835\udde7\ud835\udddc\ud835\udde2\ud835\udde1\ud835\udde6\r\n        \r\n        /// @dev drop struct\r\n        struct Artwork {\r\n            string artworkBaseIpfsURI; // 'ipfs://CID/'\r\n            address royaltyReceiver;   // default assigned in init\r\n            uint256 minted;            // already minted + reserved\r\n            uint256 count;             // minted + reserved + burned\r\n            uint256 artworkLimit;      // max limit \r\n            uint256 royaltiesInBP;     // default assigned in init\r\n            uint256 artworkPrice;      // init assignment, can change later\r\n            uint256 reserved;          // count of reserved\r\n            bool locked;               // once locked nobody can change royalty, URI and other ctirical info, locking is irreversible\r\n            bool paused;               // pause for minting\r\n            bool presale;              // init assignment\r\n            uint256[] available_list;  // generated in init for URI recycling [1,2,3] - [0,2,3]\r\n        }\r\n\r\n        \r\n        mapping(uint256 => Artwork) internal artworks; \r\n        mapping(uint256 => bool) internal artworkCheck;\r\n        mapping(uint256 => uint256) internal tokenIdToArtworkId;\r\n        mapping(uint256 => uint256) internal tokenIdToIpfsHash;\r\n        mapping(uint256 => uint256[]) internal artworkIdToTokenIds;\r\n        \r\n        mapping (bytes32 => uint256) internal whiteListLimits;\r\n        \r\n        mapping (uint256 => bool) public paidWithCard;\r\n        mapping (uint256 => uint256) public paidDate;\r\n        mapping (uint256 => bool) public burnDisabled;\r\n        mapping (uint256 => bool) public isBurned;\r\n\r\n        //\ud835\udde3\ud835\udde5\ud835\udddc\ud835\udde9\ud835\udddc\ud835\udddf\ud835\uddd8\ud835\uddda\ud835\uddd8\ud835\udde6\r\n\r\n\r\n        mapping(address => bool) public isOperator;\r\n        mapping(address => bool) public isGalleryReserver;\r\n\r\n        address public admin;\r\n        address public gateKeeperOne;\r\n        address public gateKeeperTwo;\r\n        address public defaultRoyaltyReceiver;\r\n        bytes32 public root;\r\n\r\n        bool public gateKeeperOneAllowMinting=false;\r\n        bool public gateKeeperTwoAllowMinting=false;\r\n        bool public gateKeeperOneAppointed=false;\r\n        bool public gateKeeperTwoAppointed=false;\r\n        bool public gateKeeperOneChangeAdmin=false;\r\n        bool public gateKeeperTwoChangeAdmin=false;\r\n        \r\n        //\ud835\udde5\ud835\udde2\ud835\uddec\ud835\uddd4\ud835\udddf\ud835\udde7\ud835\udddc\ud835\uddd8\ud835\udde6\r\n\r\n        \r\n        uint256 public defaultRoyaltiesInBP = 800;      // 8%\r\n        uint256 public MINT_HARD_LIMIT=10;             // cannot mint more than 10\r\n        uint256 public WHITELIST_PER_ACCOUNT_LIMIT=5;  // each whitelisted account can get 5 pieces before the whitelist reset\r\n        uint256 public currentMappingVersion;          // resettable mapping\r\n        uint256 public DAY_LIMIT=90;                   // cannot burn a credit card sale after this limit\r\n        \r\n        //\ud835\udde0\ud835\udde2\ud835\uddd7\ud835\udddc\ud835\uddd9\ud835\udddc\ud835\uddd8\ud835\udde5\ud835\udde6\r\n\r\n        /// @dev checks if the tokenId exists \r\n        modifier onlyValidTokenId(uint256 _tokenId) \r\n        {\r\n            \r\n            require(_exists(_tokenId));\r\n            _;\r\n        }\r\n\r\n        /// @dev checks if transaction is direct or from a contract\r\n        modifier onlyAccounts () {\r\n            require(msg.sender == tx.origin);\r\n            _;\r\n        }\r\n        \r\n        /// @dev checks the lock status of the artwork\r\n        modifier onlyUnlocked(uint256 _artworkId) \r\n        {\r\n            \r\n\r\n            require(!artworks[_artworkId].locked);\r\n            _;\r\n        }\r\n\r\n        /// @dev checks if the minting is paused or not\r\n        modifier onlyUnPaused(uint256 _artworkId) \r\n        {\r\n\r\n            require(!artworks[_artworkId].paused);\r\n            _;\r\n        }\r\n\r\n        /// @dev only called by admin\r\n        modifier onlyAdmin() \r\n        {\r\n\r\n            require(msg.sender == admin);\r\n            _;\r\n        }\r\n\r\n        /// @dev only called by admin and operator\r\n        modifier onlyOperator() \r\n        {\r\n            \r\n            require(isOperator[msg.sender] || msg.sender==admin );\r\n            _;\r\n        }\r\n\r\n        /// @dev only called by admin and operator and reserver\r\n        modifier onlyGalleryReserver() \r\n        {\r\n            // checks if the msg sender is reserver or not\r\n            \r\n            require((isGalleryReserver[msg.sender]) || (isOperator[msg.sender]) || (msg.sender==admin));\r\n            _;\r\n        }\r\n        \r\n        /// @dev only called by GateKeeperOne\r\n        modifier onlyGateKeeperOne() \r\n        {\r\n            require(gateKeeperOneAppointed);\r\n\r\n            \r\n            require(msg.sender == gateKeeperOne);\r\n            _;\r\n        }\r\n\r\n        /// @dev only called by GateKeeperTwo\r\n        modifier onlyGateKeeperTwo() \r\n        {\r\n            \r\n            require(gateKeeperTwoAppointed);\r\n\r\n            require(msg.sender == gateKeeperTwo);\r\n            _;\r\n        }\r\n\r\n        /// @dev only called by GateKeeperTwo and GateKeeperOne, makes sure they are appointed as well. \r\n        modifier onlyGateKeeper() \r\n        {\r\n            // checks if the msg sender is gatekeeper or not\r\n            require((msg.sender == gateKeeperOne) || (msg.sender == gateKeeperTwo));\r\n            require(gateKeeperTwoAppointed);\r\n            require(gateKeeperOneAppointed);\r\n\r\n            _;\r\n        }\r\n\r\n        constructor(string memory _tokenName, string memory _tokenSymbol, bytes32 merkleroot) ERC721(_tokenName, _tokenSymbol)  \r\n        {\r\n            admin = msg.sender;\r\n            \r\n            \r\n            root = merkleroot;\r\n\r\n            //gatekeepers are  admin in the initial deployment\r\n            gateKeeperOne=msg.sender;\r\n            gateKeeperTwo=msg.sender;\r\n\r\n            //minting is toggled to true\r\n            gateKeeperOneAllowMinting=true;\r\n            gateKeeperTwoAllowMinting=true;\r\n\r\n            //gatekeepers can change admin if they have unanymous decision\r\n            gateKeeperOneChangeAdmin=false;\r\n            gateKeeperTwoChangeAdmin=false;\r\n            \r\n            defaultRoyaltyReceiver=msg.sender;\r\n            \r\n            //\ud835\uddd4\ud835\uddd9\ud835\udde7\ud835\uddd8\ud835\udde5 \ud835\uddd7\ud835\uddd8\ud835\udde3\ud835\udddf\ud835\udde2\ud835\uddec \ud835\udde7\ud835\udde2\ud835\uddd7\ud835\udde2:\r\n            // 1- Appoint GateKeeper - Keep in Mind Admin Can Only Appoint a GateKeeper Once\r\n\r\n        }\r\n\r\n\r\n        // \ud835\uddd4\ud835\uddd7\ud835\udde0\ud835\udddc\ud835\udde1 \ud835\udde3\ud835\udde5\ud835\udddc\ud835\udde9\ud835\udddc\ud835\udddf\ud835\uddd4\ud835\uddda\ud835\uddd8\ud835\udde6\r\n\r\n        /// @dev change admin to a new account\r\n        function changeAdmin(address _address)  onlyAdmin public\r\n        {\r\n\r\n            admin = _address;\r\n            \r\n\r\n        }\r\n        \r\n        /// @dev adds Operator which can carry daily hot wallet duties - admin only\r\n        function addOperator(address _address)  onlyAdmin public\r\n        {\r\n            isOperator[_address] = true;\r\n        }\r\n\r\n        /// @dev remove privilages - Admin only\r\n        function removeOperator(address _address)  onlyAdmin public\r\n        {\r\n            isOperator[_address] = false;\r\n        }\r\n\r\n        /// @dev add Gallery Reserver can only reserve artwork - Operator        \r\n        function addGalleryReserver(address _address)  onlyOperator public\r\n        {\r\n            isGalleryReserver[_address] = true;\r\n        }\r\n\r\n        /// @dev remove privilages - Operator \r\n        function removeGalleryReserver(address _address)  onlyOperator public\r\n        {\r\n            isGalleryReserver[_address] = false;\r\n        }\r\n\r\n        /// @dev GAtekeepers can stop minting, minting is on by default, has to be appointed before first minting\r\n        function appointGateKeeperOne(address _address)  onlyAdmin public\r\n        {\r\n            require (gateKeeperOneAppointed== false);\r\n            gateKeeperOne= _address;\r\n            gateKeeperOneAppointed=true;\r\n\r\n        }\r\n\r\n        /// @dev GAtekeepers can stop minting, minting is on by default, has to be appointed before first minting\r\n        function appointGateKeeperTwo(address _address)  onlyAdmin public\r\n        {\r\n\r\n            require (gateKeeperTwoAppointed== false);\r\n            gateKeeperTwo= _address;\r\n            gateKeeperTwoAppointed=true;\r\n        }\r\n\r\n        /// @dev Admin can withdraw ETH to admin account\r\n        function withdrawAll() public onlyAdmin \r\n        {\r\n            uint256 balance = address(this).balance;\r\n            require(balance > 0);\r\n\r\n            _withdraw(admin, balance);\r\n            \r\n        }\r\n\r\n        /// @dev withdraw function\r\n        function _withdraw(address _address, uint256 _amount) private \r\n        {\r\n            (bool success, ) = _address.call{value: _amount}(\"\");\r\n            require(success);\r\n        }\r\n\r\n        //\ud835\uddda\ud835\uddd4\ud835\udde7\ud835\uddd8\ud835\uddde\ud835\uddd8\ud835\uddd8\ud835\udde3\ud835\uddd8\ud835\udde5 \ud835\udde3\ud835\udde5\ud835\udddc\ud835\udde9\ud835\udddc\ud835\udddf\ud835\uddd8\ud835\uddda\ud835\uddd8\ud835\udde6\r\n\r\n        /// @dev Start/Stop Minting, On by default\r\n        function gateKeeperOneToggleMinting(bool toggle_bool)  onlyGateKeeperOne public\r\n        {\r\n            gateKeeperOneAllowMinting= toggle_bool;\r\n        \r\n        }\r\n\r\n        /// @dev Start/Stop Minting, On by default\r\n        function gateKeeperTwoToggleMinting(bool toggle_bool)  onlyGateKeeperTwo public\r\n        {\r\n            gateKeeperTwoAllowMinting= toggle_bool;\r\n        \r\n        }\r\n\r\n        /// @dev only Gatekeeper  can change itself \r\n        function gateKeeperOneChangeAddress(address _address)  onlyGateKeeperOne public\r\n        {\r\n            gateKeeperOne= _address;\r\n\r\n\r\n        }\r\n        \r\n        /// @dev only Gatekeeper  can change itself\r\n        function gateKeeperTwoChangeAddress(address _address)  onlyGateKeeperTwo public\r\n        {\r\n            gateKeeperTwo= _address;\r\n\r\n        }\r\n\r\n        /// @dev initiate admin recovery, true to vote to change admin\r\n        function gateKeeperOneToggleAdminChange(bool toggle_bool)  onlyGateKeeperOne public\r\n        {\r\n            gateKeeperOneChangeAdmin= toggle_bool;\r\n        \r\n        }\r\n\r\n        /// @dev initiate admin recovery, true to vote to change admin\r\n        function gateKeeperTwoToggleAdminChange(bool toggle_bool)  onlyGateKeeperTwo public\r\n        {\r\n            gateKeeperTwoChangeAdmin= toggle_bool;\r\n        \r\n        }\r\n\r\n        /// @dev if both admin change votes are true, this funtion assigns a new admin\r\n        function gateKeeperAdminOverride(address _address)  onlyGateKeeper public\r\n        {\r\n            //gatekeepers can change admin if they agree to do so\r\n            require(gateKeeperTwoChangeAdmin,\"1\");\r\n            require(gateKeeperOneChangeAdmin,\"2\");\r\n\r\n            gateKeeperTwoChangeAdmin=false;\r\n            gateKeeperOneChangeAdmin=false;\r\n\r\n            admin = _address;\r\n            \r\n        }\r\n\r\n        //\ud835\udde2\ud835\udde3\ud835\uddd8\ud835\udde5\ud835\uddd4\ud835\udde7\ud835\udddc\ud835\udde2\ud835\udde1\ud835\uddd4\ud835\udddf \ud835\uddea\ud835\udddb\ud835\udddc\ud835\udde7\ud835\uddd8\ud835\udddf\ud835\udddc\ud835\udde6\ud835\udde7\ud835\uddd8\ud835\uddd7 \ud835\uddd9\ud835\udde8\ud835\udde1\ud835\uddd6\ud835\udde7\ud835\udddc\ud835\udde2\ud835\udde1\ud835\udde6\r\n\r\n        /// @dev change multiple mint per artwork\r\n        function updateMintHardLimit(uint256 _hardlimit) onlyOperator public \r\n        {\r\n            MINT_HARD_LIMIT = _hardlimit;\r\n        }\r\n        \r\n        /// @dev freeze metadata of the multiple tokens if neccesary, contact info@whitecubeless.com if you need  Frozen badge in marketplaces \r\n        function freezeMetadataList(uint256[] memory _tokenIds)  onlyOperator  public\r\n        {\r\n\r\n            require (_tokenIds.length < 20, \"1\");\r\n            \r\n            for (uint i; i<_tokenIds.length;) \r\n            {\r\n                uint256 tokenId=_tokenIds[i];\r\n                require(_exists(tokenId), \"2\");\r\n                emit PermanentURI(tokenURI(tokenId),tokenId);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n\r\n        }\r\n        /// @dev changes the royalty receiver, only applicable for new artworks\r\n        function changeDefaultRoyaltyReceiver(address _address)  onlyOperator public\r\n        {\r\n            defaultRoyaltyReceiver = _address;\r\n        }\r\n        \r\n        /// @dev merkleroot for presales, only one root at a time\r\n        function setMerkleRoot(bytes32 merkleroot)  onlyOperator  public \r\n        {\r\n            root = merkleroot;\r\n        }\r\n\r\n        /// @dev max tokens a whitelisted account can mint\r\n        function setWhitelistPerAccount(uint256 maximum_per_account)  onlyOperator  public \r\n        {\r\n            WHITELIST_PER_ACCOUNT_LIMIT = maximum_per_account;\r\n        }\r\n\r\n        /// @dev after day_limit, contract can't burn transferred tokens\r\n        function setCCDayLimit(uint256 day_limit)  onlyOperator  public \r\n        {\r\n            require(day_limit<=90);\r\n            DAY_LIMIT = day_limit;\r\n        }\r\n\r\n        /// @dev multiple disables remote burning for tokens, immediately, triggered manually when payment is cleared\r\n        function disableMultipleCreditCardBurn(uint256[] memory _tokenIds, uint256 check_len) onlyOperator public\r\n        {\r\n            uint256 q1=_tokenIds.length;\r\n            \r\n            require(q1==check_len);\r\n\r\n            for (uint i; i < check_len;) \r\n            {\r\n                disableCreditCardBurn(_tokenIds[i]);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n\r\n        /// @dev  disables remote burning for tokens, immediately, triggered when payment is cleared, contact info@whitecubeless.com to secure your token if purchased via traditional methods\r\n        function disableCreditCardBurn(uint _tokenId)   onlyOperator public \r\n        {\r\n            burnDisabled[_tokenId]=true;\r\n        }\r\n        \r\n        /// @dev add multiple artworks\r\n        function addMultipleArtwork(uint256[] memory _artworkLimits,uint256[] memory _prices,string[] calldata _artworkBaseIpfsURIs,bool[] memory _presales,uint256 len_check) onlyOperator public\r\n        {\r\n\r\n            uint256 q2=_artworkLimits.length;\r\n            uint256 q3=_prices.length;\r\n            uint256 q4=_artworkBaseIpfsURIs.length;\r\n            uint256 q5=_presales.length;\r\n\r\n            require(q2==len_check,\"2\");\r\n            require(q3==len_check,\"3\");\r\n            require(q4==len_check,\"4\");\r\n            require(q5==len_check,\"5\");\r\n\r\n\r\n            for (uint i; i < len_check;) \r\n            {\r\n                addArtwork( _artworkLimits[i],_prices[i], _artworkBaseIpfsURIs[i],_presales[i]);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n\r\n        }\r\n\r\n        /// @dev add artwork , once added cannot be undone\r\n        function addArtwork(uint256 _artworkLimit,uint256 _price, string calldata _artworkBaseIpfsURI,bool presale)  onlyOperator public\r\n        {\r\n            uint256 artworkId = nextartworkId;\r\n            require(artworkCheck[artworkId]==false,\"1\");\r\n\r\n            artworks[artworkId].artworkLimit = _artworkLimit;\r\n            artworks[artworkId].artworkPrice=_price;\r\n            artworkCheck[artworkId]=true;\r\n            //\r\n            artworks[artworkId].royaltyReceiver=defaultRoyaltyReceiver;\r\n            artworks[artworkId].royaltiesInBP=defaultRoyaltiesInBP;\r\n            artworks[artworkId].presale=presale;\r\n\r\n            artworks[artworkId].minted=0;\r\n            artworks[artworkId].locked=false;\r\n            artworks[artworkId].artworkBaseIpfsURI = _artworkBaseIpfsURI;\r\n            artworks[artworkId].available_list=new uint[](_artworkLimit);\r\n            for (uint i; i < _artworkLimit;)\r\n            {\r\n                artworks[artworkId].available_list[i]=i+1;\r\n                unchecked { ++i ;}\r\n\r\n            } \r\n\r\n            emit ArtworkAdded( _artworkBaseIpfsURI, artworkId,_artworkLimit);\r\n            nextartworkId = nextartworkId+1; \r\n            \r\n        }\r\n\r\n        /// @dev locks an artwork for editing, manually triggered after edition is sold out\r\n        function updateArtworkLock(uint256 _artworkId,bool lock_bool)  onlyOperator   onlyUnlocked(_artworkId) public\r\n        {\r\n            //when locked, nobody can unlock therefore the whole structure is frozen\r\n            artworks[_artworkId].locked = lock_bool;\r\n        }\r\n\r\n\r\n        /// @dev pauses artwork for minting\r\n        function updateArtworkPause(uint256 _artworkId,bool pause_bool)  onlyOperator  public\r\n        {\r\n            //when locked, nobody can unlock therefore the whole structure is frozen\r\n            artworks[_artworkId].paused = pause_bool;\r\n        }\r\n\r\n        /// @dev multiple IPFS change in case there is a problem with the IPFS supplied in init, cannot be used after locking\r\n        function updateMultipleArtworkBaseIpfsURI(uint256[] calldata _artworkIds,string[] calldata _artworkBaseIpfsURIs, uint256 check_len) onlyOperator public\r\n        {\r\n            uint256 q1=_artworkBaseIpfsURIs.length;\r\n            uint256 q2=_artworkIds.length;\r\n            \r\n            require(q1==check_len,\"1\");\r\n            require(q2==check_len,\"2\");\r\n\r\n            for (uint i; i < check_len;) \r\n            {\r\n                updateArtworkBaseIpfsURI(_artworkIds[i], _artworkBaseIpfsURIs[i]);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n\r\n        /// @dev IPFS change in case there is a problem with the IPFS supplied in init, cannot be used after locking\r\n        function updateArtworkBaseIpfsURI(uint256 _artworkId, string calldata _artworkBaseIpfsURI) onlyOperator onlyUnlocked(_artworkId) public \r\n        {\r\n            artworks[_artworkId].artworkBaseIpfsURI = _artworkBaseIpfsURI;\r\n\r\n        }\r\n        \r\n        /// @dev multiple price change in case there is a problem with the price supplied in init, cannot be used after locking\r\n        function updateMultipleArtworkPrice(uint256[] calldata _artworkIds,uint256[] calldata _prices, uint256 check_len) onlyOperator public\r\n        {\r\n            uint256 q1=_prices.length;\r\n            uint256 q2=_artworkIds.length;\r\n            \r\n            require(q1==check_len,\"1\");\r\n            require(q2==check_len,\"2\");\r\n\r\n            for (uint i ; i < check_len; ) \r\n            {\r\n                updateArtworkPrice(_artworkIds[i], _prices[i]);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n        \r\n        /// @dev  price change in case there is a problem with the price supplied in init, cannot be used after locking\r\n        function updateArtworkPrice(uint256 _artworkId, uint256 _price) onlyOperator onlyUnlocked(_artworkId) public \r\n        {\r\n            artworks[_artworkId].artworkPrice = _price;\r\n\r\n        }\r\n\r\n        /// @dev enable presale for an artwork on the fly\r\n        function updateArtworkPresale(uint256 _artworkId, bool _presaleBool) onlyOperator onlyUnlocked(_artworkId) public \r\n        {\r\n            artworks[_artworkId].presale = _presaleBool;\r\n            \r\n        }\r\n        \r\n        /// @dev  multiple change URI extension that comes after ipfs://{CID}/, last resort if there is a sequencing problem after recycling, cannot be done after lock\r\n        function overrideMultipleTokenIPFSHash(uint256[] calldata _newHashs , uint256[] calldata _tokenIds, uint256 check_len) onlyOperator public\r\n        {\r\n            uint256 q1=_newHashs.length;\r\n            uint256 q2=_tokenIds.length;\r\n            \r\n            require(q1==check_len,\"1\");\r\n            require(q2==check_len,\"2\");\r\n\r\n            for (uint i ; i < check_len; ) \r\n            {\r\n                overrideTokenIPFSHash(_newHashs[i], _tokenIds[i]);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n        \r\n        /// @dev  change URI extension that comes after ipfs://{CID}/, last resort if there is a sequencing problem after recycling, cannot be done after lock\r\n        function overrideTokenIPFSHash(uint256 _newHash , uint256 _tokenId) onlyOperator public \r\n        {\r\n            //check if artwork is locked\r\n            require(_exists(_tokenId), \"1\");\r\n            require(!artworks[tokenIdToArtworkId[_tokenId]].locked,\"2\");\r\n            \r\n            tokenIdToIpfsHash[_tokenId]=_newHash;\r\n\r\n        }\r\n\r\n        /// @dev  change available to mint array if there is a problem in sequencing, this applies for future mints\r\n        function overrideAvailableArray(uint256 _artworkId,uint256[] calldata available_array  ) onlyOperator onlyUnlocked(_artworkId) public \r\n        {\r\n            // jus tin case if available array mixes up\r\n            require(available_array.length == artworks[_artworkId].available_list.length,\"1\");\r\n            require(artworkCheck[_artworkId],\"2\");\r\n\r\n            for (uint i; i < artworks[_artworkId].available_list.length;) \r\n            {\r\n                artworks[_artworkId].available_list[i]=available_array[i];\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n        \r\n        /// @dev  royalty percentage  change for existing artworks\r\n        function changeArtworkRoyaltiesInBP(uint256 _artworkId,uint256 _royaltiesInBP)  onlyOperator onlyUnlocked(_artworkId) public\r\n        {\r\n            artworks[_artworkId].royaltiesInBP = _royaltiesInBP;\r\n\r\n        }\r\n\r\n        /// @dev  royalty address  change for existing artworks\r\n        function changeArtworkRoyaltyReceiver(uint256 _artworkId,address _royaltyReceiver)  onlyOperator onlyUnlocked(_artworkId) public\r\n        {\r\n            artworks[_artworkId].royaltyReceiver = _royaltyReceiver;\r\n\r\n        }\r\n\r\n\r\n        //\ud835\udde0\ud835\udddc\ud835\udde1\ud835\udde7\ud835\udddc\ud835\udde1\ud835\uddda\r\n\r\n        /**\r\n        * @dev mints a token for the gallery.\r\n        *\r\n        * Requirements:\r\n        *\r\n        * - `artwork` should be Unpaused.\r\n        * - only operator can call\r\n        *\r\n        * Functionality:\r\n        * - can mint reserved tokens \r\n        * - can mint credit card tokens where gallery can burn in 90 days if the payment is fraudulent\r\n        * - can mint tokens for other OTC deals\r\n        */\r\n        function galleryMint(address _to, uint256 _artworkId, bool _freeze,uint256 quantity,bool credit_card_sale,bool reserved) onlyOperator onlyUnPaused(_artworkId) external returns (uint256[] memory) \r\n        {\r\n            // if the sale is done via credit card, we reserve right to burn for 90days\r\n\r\n            require(artworkCheck[_artworkId],\"1\");\r\n            \r\n            require(quantity<=MINT_HARD_LIMIT, \"3\");\r\n            require(!artworks[_artworkId].locked , \"4\");\r\n            require(gateKeeperOneAllowMinting , \"5\");\r\n            require(gateKeeperOneAppointed, \"6\");\r\n            require(gateKeeperTwoAllowMinting, \"7\");\r\n            require(gateKeeperTwoAppointed, \"8\");\r\n            \r\n            if (reserved==false)\r\n            {\r\n                require(artworks[_artworkId].minted + quantity <= artworks[_artworkId].artworkLimit, \"2\");\r\n            }\r\n            \r\n            if (reserved)\r\n            {\r\n                //in the mint we will increment minted \r\n                // we need to deduct from reserved and minted before hand so that minted will come to the correct quantuty\r\n                require(artworks[_artworkId].reserved - quantity >= 0, \"9\"); //make sure it as actually reserved\r\n                require(artworks[_artworkId].minted - quantity >= 0, \"10\"); //something wrong\r\n\r\n            }\r\n            \r\n            uint[]    memory tokenIds =  new uint[](quantity);\r\n\r\n            for (uint i ; i < quantity; ) \r\n            {\r\n                if (reserved)\r\n                {\r\n                    artworks[_artworkId].reserved=artworks[_artworkId].reserved-1; // unreserve the minted\r\n                    artworks[_artworkId].minted=artworks[_artworkId].minted-1; // unreserve the minted\r\n                }\r\n                \r\n                uint tokenId=_mintToken(_to, _artworkId,_freeze);\r\n                tokenIds[i]=tokenId;\r\n                paidWithCard[tokenId]=credit_card_sale;\r\n                paidDate[tokenId]=block.timestamp;\r\n                unchecked { ++i ;}\r\n\r\n\r\n            }\r\n            return tokenIds;\r\n        }\r\n        \r\n        /// @dev  reserves a token for future sale\r\n        function galleryReserve( uint256 _artworkId,uint256 quantity) onlyGalleryReserver  external \r\n        {\r\n            \r\n            // can reserve while paused\r\n            require(artworkCheck[_artworkId],\"1\");\r\n            require(artworks[_artworkId].minted+quantity <= artworks[_artworkId].artworkLimit, \"2\");\r\n            require(quantity<=MINT_HARD_LIMIT, \"3\");\r\n            require(!artworks[_artworkId].locked , \"4\");\r\n            require(gateKeeperOneAllowMinting , \"5\");\r\n            require(gateKeeperOneAppointed, \"6\");\r\n            require(gateKeeperTwoAllowMinting, \"7\");\r\n            require(gateKeeperTwoAppointed, \"8\");\r\n\r\n            //add the reserved and minted\r\n            artworks[_artworkId].minted=artworks[_artworkId].minted+quantity;\r\n            artworks[_artworkId].reserved=artworks[_artworkId].reserved+quantity;\r\n            \r\n\r\n        }\r\n\r\n        /// @dev  unreserves a token for future sale\r\n        function galleryUnReserve( uint256 _artworkId,uint256 quantity) onlyGalleryReserver external \r\n        {\r\n            // if the sale is done via credit card, we reserve right to burn for 90days\r\n            // can reserve while paused\r\n            require(artworkCheck[_artworkId],\"1\");\r\n            require(artworks[_artworkId].minted-quantity >= 0, \"2\");\r\n            require(artworks[_artworkId].reserved-quantity >= 0, \"3\");\r\n            require(quantity<=MINT_HARD_LIMIT, \"4\");\r\n            require(!artworks[_artworkId].locked , \"5\");\r\n            require(gateKeeperOneAllowMinting , \"6\");\r\n            require(gateKeeperOneAppointed, \"7\");\r\n            require(gateKeeperTwoAllowMinting, \"8\");\r\n            require(gateKeeperTwoAppointed, \"9\");\r\n\r\n            //sub the reserved and minted\r\n            artworks[_artworkId].minted=artworks[_artworkId].minted-quantity;\r\n            artworks[_artworkId].reserved=artworks[_artworkId].reserved-quantity;\r\n            \r\n\r\n        }\r\n\r\n        /// @dev  public mint function where ETH is expected for delivery\r\n        function publicSaleMint(uint256 _artworkId, bool _freeze,  uint256 quantity) public payable onlyAccounts onlyUnPaused(_artworkId)  returns (uint256[] memory) \r\n        {\r\n            require(artworkCheck[_artworkId],\"1\");\r\n            require(msg.value >=  artworks[_artworkId].artworkPrice*quantity, \"2\");\r\n            require(artworks[_artworkId].artworkPrice>0, \"3\");\r\n            require(quantity<=MINT_HARD_LIMIT, \"4\");\r\n            require(artworks[_artworkId].minted+quantity <= artworks[_artworkId].artworkLimit, \"5\");\r\n            require(!artworks[_artworkId].locked , \"6\");\r\n            require(gateKeeperOneAllowMinting, \"7\");\r\n            require(gateKeeperTwoAllowMinting, \"8\");\r\n            require(gateKeeperOneAppointed, \"9\");\r\n            require(gateKeeperTwoAppointed, \"10\");\r\n            require(artworks[_artworkId].presale==false, \"11\");\r\n\r\n            uint[]    memory tokenIds =  new uint[](quantity);\r\n            \r\n            for (uint i; i < quantity;) \r\n            {\r\n                tokenIds[i]=_mintToken(msg.sender, _artworkId,_freeze);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n            return tokenIds;\r\n            \r\n\r\n        }\r\n\r\n        /// @dev  public presale mint function where ETH and whitelisting is expected for delivery\r\n        function preSaleMint(uint256 _artworkId, bool _freeze, uint256 quantity, bytes32[] calldata proof) public payable onlyAccounts  onlyUnPaused(_artworkId) returns (uint256[] memory) \r\n        {\r\n            require(artworkCheck[_artworkId],\"1\");\r\n            require(msg.value >=  artworks[_artworkId].artworkPrice * quantity, \"2\");\r\n            require(artworks[_artworkId].artworkPrice>0, \"3\");\r\n            require(quantity<=MINT_HARD_LIMIT, \"4\");\r\n            require(artworks[_artworkId].minted+quantity <= artworks[_artworkId].artworkLimit, \"5\");\r\n            require(!artworks[_artworkId].locked , \"6\");\r\n            require(gateKeeperOneAllowMinting, \"7\");\r\n            require(gateKeeperTwoAllowMinting, \"8\");\r\n            require(gateKeeperOneAppointed, \"9\");\r\n            require(gateKeeperTwoAppointed, \"10\");\r\n            require(artworks[_artworkId].presale==true, \"11\");\r\n\r\n            bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\r\n            require(MerkleProof.verify(proof, root, leaf),\"12\");\r\n            uint256 limit=getWhiteListedLimit(msg.sender);\r\n            uint256 new_limit=limit + quantity;\r\n            require(new_limit<=WHITELIST_PER_ACCOUNT_LIMIT,\"13\");\r\n            \r\n            uint[]    memory tokenIds =  new uint[](quantity);\r\n            \r\n            _setLimit(msg.sender,new_limit);\r\n\r\n            for (uint i ; i < quantity;) \r\n            {\r\n                tokenIds[i]=_mintToken(msg.sender, _artworkId,_freeze);\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n            return tokenIds;\r\n            \r\n\r\n        }\r\n\r\n        /// @dev seach for a non 0, unassigned ID and add it as extension, used for recycling the IPFS link\r\n        function getNextAvailableExtId(uint256 _artworkId) internal  returns (bool found,uint256 ext_id) \r\n        {\r\n            //loop the avialble\r\n            //if it is not 0, break and return \r\n            // if 0\r\n            ext_id=0;\r\n            uint256[] storage avails=artworks[_artworkId].available_list;\r\n            found=false;\r\n            for (uint i ; i < avails.length;) \r\n            {\r\n                uint256 val=artworks[_artworkId].available_list[i];\r\n                if (val!=0)\r\n                {\r\n                    artworks[_artworkId].available_list[i]=0;\r\n                    ext_id=val;\r\n                    found=true;\r\n                    break;\r\n                }\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n            return (found,ext_id);\r\n\r\n        }\r\n\r\n        /// @dev all mint functions call this function\r\n        function _mintToken(address _to, uint256 _artworkId, bool _freeze) internal returns (uint256 _tokenId) \r\n        {\r\n\r\n            artworks[_artworkId].minted = artworks[_artworkId].minted + 1;\r\n            artworks[_artworkId].count = artworks[_artworkId].count + 1;\r\n\r\n            uint256 tokenIdToBe = (_artworkId * ONE_MILLION) + artworks[_artworkId].count;\r\n            require(artworks[_artworkId].count<ONE_MILLION,\"1\");\r\n            \r\n            (bool found_,uint256 ext_id_)=getNextAvailableExtId(_artworkId);\r\n            require(found_,\"2\");\r\n\r\n            _mint(_to, tokenIdToBe);\r\n\r\n            tokenIdToArtworkId[tokenIdToBe] = _artworkId;\r\n            artworkIdToTokenIds[_artworkId].push(tokenIdToBe);\r\n            tokenIdToIpfsHash[tokenIdToBe]=ext_id_;\r\n\r\n            emit Mint(_to, tokenIdToBe, _artworkId);\r\n\r\n            if (_freeze)\r\n            {\r\n                emit PermanentURI(tokenURI(tokenIdToBe),tokenIdToBe);\r\n                //freeze it, OpenSea convention\r\n        \r\n            }\r\n            \r\n            return tokenIdToBe;\r\n        }\r\n        \r\n        /// @dev string concetanation\r\n        function append(string memory a, string memory  b) internal pure returns (string memory) \r\n        {\r\n\r\n            return string(abi.encodePacked(a, b));\r\n\r\n        }\r\n\r\n\r\n        /// @dev overrided URI function where URI based on Artwork is returned\r\n        function tokenURI(uint256 _tokenId) public view onlyValidTokenId(_tokenId) override returns (string memory) \r\n        {\r\n            uint256 ipfsHash= tokenIdToIpfsHash[_tokenId];\r\n            return append(artworks[tokenIdToArtworkId[_tokenId]].artworkBaseIpfsURI, Strings.toString(ipfsHash));\r\n        }\r\n\r\n        //BURNING\r\n\r\n        /// @dev internal burn, deletes URI, reduces supply and sends the token to the 0x0. \r\n        /// If the token is sold via CC, can remote burn\r\n        // If token is sold via ETH, only burn if Operator holds the token\r\n        function burnTokens(uint256[] calldata _tokenIds, uint256 check_len) external  onlyOperator \r\n        {\r\n            require(gateKeeperOneAllowMinting, \"1\");\r\n            require(gateKeeperTwoAllowMinting, \"2\");\r\n            require(gateKeeperOneAppointed, \"3\");\r\n            require(gateKeeperTwoAppointed, \"4\");\r\n            uint256 q1=_tokenIds.length;\r\n            \r\n            require(q1==check_len,\"5\");\r\n            for (uint i ; i < q1;) \r\n            {\r\n                if (paidWithCard[_tokenIds[i]])\r\n                {\r\n                    _creditCardBurn(_tokenIds[i]);\r\n                }\r\n                else\r\n                {\r\n                    _burnToken(_tokenIds[i],msg.sender);\r\n                }\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n        }\r\n\r\n\r\n        /// @dev burn function  resets the states\r\n        function _burnToken(uint256 _tokenId,address msg_sender) internal \r\n        {\r\n            require(_exists(_tokenId), \"1\");\r\n            address token_owner = ERC721.ownerOf(_tokenId);\r\n            require(msg_sender==token_owner ,\"2\");\r\n            uint256 _artworkId=tokenIdToArtworkId[_tokenId];\r\n            require(_artworkId!=0,\"3\");\r\n\r\n            //get the hash of the token and equate it to a value other than 0\r\n            uint256 ipfsHash=tokenIdToIpfsHash[_tokenId];\r\n            artworks[_artworkId].minted = artworks[_artworkId].minted - 1;\r\n            tokenIdToArtworkId[_tokenId] = 0;\r\n            tokenIdToIpfsHash[_tokenId]=0;\r\n            artworks[_artworkId].available_list[ipfsHash-1]=ipfsHash; //burned ID is available for recycling\r\n            isBurned[_tokenId]=true;\r\n            _burn(_tokenId);\r\n\r\n            emit Burn(_tokenId,_artworkId);\r\n\r\n        } \r\n\r\n        /// @dev burn function  that doesn't check ownership\r\n        function _creditCardBurn(uint256 _tokenId) internal \r\n        {\r\n            //function to burn the token if it is bought via credit card\r\n            // this functionality is only valid for 90 days after mint and will be used a last resort against fraud\r\n            // Please contact us via info@whitecubeless.com if you to want to disable that earlier, you might be subject to KYC depending on the situation.\r\n\r\n            //Note that this function is only callable if paidWithCard is true.\r\n            // The only scenerio where this can happen is publicGalleryMint\r\n\r\n            require(_exists(_tokenId), \"1\");\r\n            require(paidWithCard[_tokenId], \"2\");\r\n            require(block.timestamp-paidDate[_tokenId]<=DAY_LIMIT * 86400,\"3\");\r\n            require(burnDisabled[_tokenId]==false,\"4\");\r\n            uint256 ipfsHash=tokenIdToIpfsHash[_tokenId];\r\n\r\n            uint256 _artworkId=tokenIdToArtworkId[_tokenId];\r\n            require(_artworkId!=0,\"5\");\r\n\r\n            artworks[_artworkId].minted = artworks[_artworkId].minted-1;\r\n            tokenIdToArtworkId[_tokenId] = 0;\r\n            tokenIdToIpfsHash[_tokenId]=0;\r\n            artworks[_artworkId].available_list[ipfsHash-1]=ipfsHash; //burned ID is available for recycling\r\n            isBurned[_tokenId]=true;\r\n\r\n            _burn(_tokenId);\r\n\r\n            emit Burn(_tokenId,_artworkId);\r\n\r\n        } \r\n\r\n\r\n\r\n\r\n\r\n        //\ud835\udde5\ud835\udde2\ud835\uddec\ud835\uddd4\ud835\udddf\ud835\udde7\ud835\udddc\ud835\uddd8\ud835\udde6\r\n\r\n        /// @dev EIP-2981 royalty override \r\n        function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view override returns (address receiver, uint256 royaltyAmount) \r\n        {\r\n            address _royaltiesReceiver = artworks[tokenIdToArtworkId[_tokenId]].royaltyReceiver;\r\n            uint256 _royaltiesinBPartwork = artworks[tokenIdToArtworkId[_tokenId]].royaltiesInBP;\r\n\r\n            uint256 _royalties = _salePrice*_royaltiesinBPartwork/10000;\r\n            return (_royaltiesReceiver, _royalties);\r\n        }\r\n\r\n\r\n        /// @notice Informs callers that this contract supports ERC2981\r\n        /// this is for future usage, hope marketplaces can see our royalty declarations\r\n        function supportsInterface(bytes4 interfaceId) public view override(ERC721Enumerable,IERC165) returns (bool) \r\n        {\r\n            return interfaceId == type(IERC2981).interfaceId || super.supportsInterface(interfaceId);\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        //\ud835\udde9\ud835\udddc\ud835\uddd8\ud835\uddea \ud835\uddd9\ud835\udde8\ud835\udde1\ud835\uddd6\ud835\udde7\ud835\udddc\ud835\udde2\ud835\udde1\ud835\udde6\r\n\r\n\r\n        /// @dev gives artwork information\r\n        function artworkTokenInfo(uint256 _artworkId) view public returns (uint256 minted, uint256 artworkLimit ,  bool locked,uint256 price,uint256 count,string memory artworkBaseIpfsURI,uint256 reserved) \r\n        {\r\n            minted = artworks[_artworkId].minted;\r\n            //minted includes both reserved and minted\r\n\r\n            reserved = artworks[_artworkId].reserved;\r\n            //to keep track of reserved, only deduct if reserve minted or unreserved\r\n            artworkLimit = artworks[_artworkId].artworkLimit;\r\n            locked=artworks[_artworkId].locked;\r\n            price=artworks[_artworkId].artworkPrice;\r\n            count=artworks[_artworkId].count;\r\n            artworkBaseIpfsURI = artworks[_artworkId].artworkBaseIpfsURI;\r\n        }\r\n\r\n        /// @dev all tokens, burned ones are shown as 0 in the result\r\n        function artworkShowAllTokens(uint256 _artworkId) public view returns (uint256[] memory)\r\n        {\r\n\r\n            uint256[] memory tokens=artworkIdToTokenIds[_artworkId];\r\n            uint len=tokens.length;\r\n\r\n            for (uint i ; i < len;) \r\n            {\r\n                uint256 val=tokens[i];\r\n                if (isBurned[val])\r\n                {\r\n                    tokens[i]=0;\r\n                }\r\n                unchecked { ++i ;}\r\n\r\n            }\r\n            return tokens;\r\n        }\r\n\r\n        /// @dev tokenId to ArtworkID\r\n        function showArtworkOfToken(uint256 _tokenId) public view returns (uint256)\r\n        {\r\n            return tokenIdToArtworkId[_tokenId];\r\n        }\r\n        \r\n        /// @dev artwork to IPFS CID\r\n        function showIpfsHash(uint256 _artworkId) public view returns (uint256)\r\n        {\r\n            return tokenIdToIpfsHash[_artworkId];\r\n        }\r\n        \r\n        /// @dev remaining time to remotely burn a credit card token\r\n        function showCCSecondsRemaining(uint256 _tokenId) public view returns (uint)\r\n        {\r\n            return (DAY_LIMIT * 86400)-(block.timestamp-paidDate[_tokenId]);\r\n        }\r\n\r\n        /// @dev returns if user cna reserve a quantity at the moment\r\n        function isReservable(uint quantity,uint _artworkId) public view returns (bool)\r\n        {\r\n            \r\n            if ((artworks[_artworkId].minted+quantity <= artworks[_artworkId].artworkLimit) && (artworkCheck[_artworkId])) \r\n            {\r\n                return true;\r\n            }\r\n            \r\n            return false;\r\n            \r\n            \r\n        }\r\n        \r\n\r\n        /// @dev available array display\r\n        function showAvailableArray(uint256 _artworkId) public view returns (uint256[] memory)\r\n        {\r\n            return artworks[_artworkId].available_list;\r\n        }\r\n\r\n        \r\n        //RESETTABLE MAPPING\r\n        /**\r\n        * @dev A resettable mapping implementation using clever hashing\r\n        *\r\n        * \r\n        *\r\n        * Functionality:\r\n        *\r\n        * - Resets the whitelisted addresses for the next drop.\r\n        * \r\n        */        \r\n        \r\n        /// @dev how much a whitelisted user minted\r\n        function getWhiteListedLimit(address  whitelistedAddress) public view returns(uint256) \r\n        {\r\n            bytes32 key = keccak256(abi.encodePacked(currentMappingVersion, whitelistedAddress));\r\n            return whiteListLimits[key];\r\n        }\r\n\r\n        /// @dev set the number of mints a whitelisted user called\r\n        function _setLimit(address whitelistedAddress, uint256 newLimit) internal \r\n        {\r\n            bytes32 key = keccak256(abi.encodePacked(currentMappingVersion, whitelistedAddress));\r\n            whiteListLimits[key] = newLimit;\r\n        }\r\n        \r\n        /// @dev reset the whitelisted limits\r\n        function resetWhiteListedMapping() external onlyOperator \r\n        {\r\n            currentMappingVersion++;\r\n        }\r\n\r\n        /// @dev a way to delete entries from the mapping,\r\n        function recoverGas(uint256 _version, address whitelistedAddress) external onlyOperator \r\n        {\r\n            require(_version < currentMappingVersion);\r\n            bytes32 key = keccak256(abi.encodePacked(_version, whitelistedAddress));\r\n            delete(whiteListLimits[key]);\r\n        }\r\n        \r\n    }", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_tokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"bytes32\",\"name\":\"merkleroot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_ArtworkId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_Limit\",\"type\":\"uint256\"}],\"name\":\"ArtworkAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"PermanentURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAY_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_HARD_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_MILLION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELIST_PER_ACCOUNT_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WhiteCubelessGalleryVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_artworkBaseIpfsURI\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"presale\",\"type\":\"bool\"}],\"name\":\"addArtwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addGalleryReserver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_artworkLimits\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_artworkBaseIpfsURIs\",\"type\":\"string[]\"},{\"internalType\":\"bool[]\",\"name\":\"_presales\",\"type\":\"bool[]\"},{\"internalType\":\"uint256\",\"name\":\"len_check\",\"type\":\"uint256\"}],\"name\":\"addMultipleArtwork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"appointGateKeeperOne\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"appointGateKeeperTwo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"artworkShowAllTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"artworkTokenInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artworkLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"locked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"artworkBaseIpfsURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"reserved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"check_len\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_royaltiesInBP\",\"type\":\"uint256\"}],\"name\":\"changeArtworkRoyaltiesInBP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_royaltyReceiver\",\"type\":\"address\"}],\"name\":\"changeArtworkRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"changeDefaultRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentMappingVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRoyaltiesInBP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRoyaltyReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"disableCreditCardBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"check_len\",\"type\":\"uint256\"}],\"name\":\"disableMultipleCreditCardBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"freezeMetadataList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"credit_card_sale\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"reserved\",\"type\":\"bool\"}],\"name\":\"galleryMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"galleryReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"galleryUnReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"gateKeeperAdminOverride\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperOne\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperOneAllowMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperOneAppointed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"gateKeeperOneChangeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperOneChangeAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle_bool\",\"type\":\"bool\"}],\"name\":\"gateKeeperOneToggleAdminChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle_bool\",\"type\":\"bool\"}],\"name\":\"gateKeeperOneToggleMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperTwo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperTwoAllowMinting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperTwoAppointed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"gateKeeperTwoChangeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateKeeperTwoChangeAdmin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle_bool\",\"type\":\"bool\"}],\"name\":\"gateKeeperTwoToggleAdminChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toggle_bool\",\"type\":\"bool\"}],\"name\":\"gateKeeperTwoToggleMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whitelistedAddress\",\"type\":\"address\"}],\"name\":\"getWhiteListedLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isBurned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGalleryReserver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"isReservable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextartworkId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"available_array\",\"type\":\"uint256[]\"}],\"name\":\"overrideAvailableArray\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_newHashs\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"check_len\",\"type\":\"uint256\"}],\"name\":\"overrideMultipleTokenIPFSHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newHash\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"overrideTokenIPFSHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paidDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"paidWithCard\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"preSaleMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_freeze\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"publicSaleMint\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_version\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"whitelistedAddress\",\"type\":\"address\"}],\"name\":\"recoverGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeGalleryReserver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetWhiteListedMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day_limit\",\"type\":\"uint256\"}],\"name\":\"setCCDayLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleroot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maximum_per_account\",\"type\":\"uint256\"}],\"name\":\"setWhitelistPerAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"showArtworkOfToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"showAvailableArray\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"showCCSecondsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"}],\"name\":\"showIpfsHash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_artworkBaseIpfsURI\",\"type\":\"string\"}],\"name\":\"updateArtworkBaseIpfsURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"lock_bool\",\"type\":\"bool\"}],\"name\":\"updateArtworkLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"pause_bool\",\"type\":\"bool\"}],\"name\":\"updateArtworkPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_presaleBool\",\"type\":\"bool\"}],\"name\":\"updateArtworkPresale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_artworkId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateArtworkPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_hardlimit\",\"type\":\"uint256\"}],\"name\":\"updateMintHardLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_artworkIds\",\"type\":\"uint256[]\"},{\"internalType\":\"string[]\",\"name\":\"_artworkBaseIpfsURIs\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"check_len\",\"type\":\"uint256\"}],\"name\":\"updateMultipleArtworkBaseIpfsURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_artworkIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"check_len\",\"type\":\"uint256\"}],\"name\":\"updateMultipleArtworkPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WhiteCubeless", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a0420514165f44c975c2f7fbe23cd56a6361500b625673323a8548e23052e7d9820000000000000000000000000000000000000000000000000000000000000016574849544520435542454c45535320505459204c54440000000000000000000000000000000000000000000000000000000000000000000000000000000000025743000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://abc7b1b04c6f21ce05247c7ea94f1d641b4d68b6e41cf7e989152233406c10d1"}]}