{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/ArtistDAO.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.3;\\n\\nimport \\\"./IApolloToken.sol\\\";\\nimport \\\"./third-party/UniswapV2Library.sol\\\";\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\\n/// @title The DAO contract for the Apollo Inu token\\ncontract ApolloDAO is Context {\\n\\n    /// @notice The address & interface of the apollo token contract\\n    IApolloToken public immutable apolloToken;\\n    /// @notice The address of the wETH contract. Used to determine minimum balances.\\n    address public immutable wethAddress;\\n    /// @notice The addres of the USDC contract. Used to determine minimum balances.\\n    address public immutable usdcAddress;\\n    /// @notice Address of the Uniswap v2 factory used to create the pairs\\n    address public immutable uniswapFactory;\\n\\n    /// @notice Event that is emitted when a new DAO is nominated\\n    event NewDAONomination(address indexed newDAO, address indexed nominator);\\n    /// @notice Event that is emitted when a new vote is submitted\\n    event VoteSubmitted(address indexed newDAO, address indexed voter, uint256 voteAmount, bool voteFor);\\n    /// @notice Event that is emitted when a vote is withdrawn\\n    event VoteWithdrawn(address indexed newDAO, address indexed voter);\\n    /// @notice Event that is emitted when voting is closed for a nominated DAO\\n    event VotingClosed(address indexed newDAO, bool approved);\\n    /// @notice Event that is emitted when a cycle has ended and a winner selected\\n    event CycleWinnerSelected(address winner, uint256 reward, string summary);\\n\\n    /// @notice A record of the current state of a DAO nomination\\n    struct DAONomination {\\n        /// The timestamp (i.e. `block.timestamp`) that the nomination was created\\n        uint256 timeOfNomination;\\n        /// The account that made the nomination\\n        address nominator;\\n        /// The total amount of votes in favor of the nomination\\n        uint256 votesFor;\\n        /// The total amount of votes against the nomination\\n        uint256 votesAgainst;\\n        /// Whether voting has closed for this nomination\\n        bool votingClosed;\\n    }\\n\\n    /// @notice A description of a single vote record by a particular account for a nomination\\n    struct DAOVotes {\\n        /// The count of tokens committed to this vote\\n        uint256 voteCount;\\n        /// Whether an account voted in favor of the nomination\\n        bool votedFor;\\n    }\\n\\n    struct LeadCandidate {\\n        address candidate;\\n        uint256 voteCount;\\n        uint256 voteCycle;\\n    }\\n\\n    /// @dev A mapping of the contract address of a nomination to the nomination state\\n    mapping (address => DAONomination) private _newDAONominations;\\n    /// @dev A mapping of the vote record by an account for a nominated DAO\\n    mapping (address => mapping (address => DAOVotes)) private _lockedVotes;\\n\\n    /// @notice The minimum voting duration for a particular nomination (three days).\\n    uint256 public constant daoVotingDuration = 300;\\n    /// @notice The minimum amount of Apollo an account must hold to submit a new nomination\\n    uint256 public constant minimumDAOBalance = 20000000000 * 10**9;\\n    /// @notice The total amount of votes\u2014and thus Apollo tokens\u2014that are currently held by this DAO\\n    uint256 public totalLockedVotes;\\n    /// @notice The total number of DAO nominations that are open for voting\\n    uint256 public activeDAONominations;\\n\\n    /// @notice The address of the new approved DAO that will be eligible to replace this DAO\\n    address public approvedNewDAO = address(0);\\n    /// @notice The address of the privileged admin that can decide contests\\n    address public immutable admin;\\n    /// @notice The minimum amount of time after a new DAO is approved before it can be activated as the\\n    /// next effective DAO (two days).\\n    uint256 public constant daoUpdateDelay = 300;\\n    /// @notice The timestamp when the new DAO was approved\\n    uint256 public daoApprovedTime;\\n    /// @notice Boolean to track when to stop contests\\n    bool public continueContests = true;\\n    /// @notice The IPFS summary of every cycle\\n    mapping(uint256 => string) public votingSummary;\\n\\n    /// @notice The total duration in seconds of one voting cycle\\n    uint256 public constant votingCyleLength = 604800;\\n    /// @notice The timestamp when the current voting cycle ends\\n    uint256 public currentVotingCycleEnd;\\n    \\n    LeadCandidate public leadVoteRecipient;\\n\\n    ///@notice The percent of the DAO balance that the winnings cannot exceed\\n    uint256 public maxBalancePercentage = 98;\\n    /// @notice The amount of Apollo each vote is worth (5M Apollo)\\n    uint256 public voteAwardMultiplier = 70000000 * 10**9;\\n    /// @notice The % of the winnings to be burned. (1%)\\n    uint256 public awardBurnPercentage = 1;\\n    /// @notice The % of the DAO pool to be given to the dev wallet. (.5%)\\n    uint256 public devWalletPerMille = 5;\\n    /// @notice The wallet used to fund the Apollo DAO development\\n    address public immutable devWallet;\\n    /// @notice The minimum value of Apollo in USDC required to vote\\n    uint256 public minimumUSDValueToVote = 50 * 10**6;\\n    /// @notice The minimum value of Apollo in USDC required to nominate\\n    uint256 public minimumUSDValueToNominate = 75 * 10**6;\\n    /// @notice The percentage of vote withdrawls to burn\\n    uint256 public constant daoVoteBurnPercentage = 1;\\n    /// @notice The wallet that will control contest parameters\\n    address public immutable deployingWallet;\\n\\n    constructor(address tokenAddress, address _wethAddress, address _usdcAddress, address _devWallet, address _admin, address _deployingWallet) {\\n        apolloToken = IApolloToken(tokenAddress);\\n        wethAddress = _wethAddress;\\n        usdcAddress = _usdcAddress;\\n        uniswapFactory = apolloToken.uniswapRouter().factory();\\n        devWallet = _devWallet;\\n        admin = _admin;\\n        deployingWallet = _deployingWallet;\\n    }\\n\\n    // Modifiers\\n\\n    modifier onlyAdmin(){\\n        require(_msgSender()==admin,\\\"Only admin can call this function\\\");\\n        _;\\n    }\\n\\n    modifier onlyDeployingWallet(){\\n        require(_msgSender()==deployingWallet,\\\"Only deploying wallet can call this function\\\");\\n        _;\\n    }\\n\\n    // Public functions\\n\\n    /// @notice The minimum amount of Apollo an account must hold to submit a vote\\n    function minimumVoteBalance() public view returns (uint256) {\\n        return _apolloAmountFromUSD(minimumUSDValueToVote);\\n    }\\n\\n    /// @notice The minimum amount of Apollo an account must hold to submit a nomination\\n    function minimumNominationBalance() public view returns (uint256) {\\n        return _apolloAmountFromUSD(minimumUSDValueToNominate);\\n    }\\n\\n    function completeCycle(address _candidate, uint256 _voteCount, string memory voteSummary) public  onlyAdmin{\\n        require(block.timestamp > currentVotingCycleEnd, \\\"Voting Cycle has not ended\\\");\\n        require(continueContests, \\\"Cannot complete new cycles after a new DAO is approved\\\");\\n        leadVoteRecipient.candidate = _candidate;\\n        leadVoteRecipient.voteCount = _voteCount;\\n        leadVoteRecipient.voteCycle = currentVotingCycleEnd;\\n\\n        uint256 minContractBalance = apolloToken.balanceOf(address(this)) * maxBalancePercentage / 100;\\n        uint256 votesToAward = leadVoteRecipient.voteCount * voteAwardMultiplier;\\n        votingSummary[currentVotingCycleEnd] = voteSummary;\\n\\n        uint256 winnings;\\n\\n        if (minContractBalance < votesToAward) {\\n            winnings = minContractBalance;\\n        } else {\\n            winnings = votesToAward;\\n        }\\n\\n        uint256 burnAmount = winnings * awardBurnPercentage / 100;\\n        uint256 devWalletTake = apolloToken.balanceOf(address(this)) * devWalletPerMille / 1000;\\n\\n        if (winnings > 0) {\\n            emit CycleWinnerSelected(leadVoteRecipient.candidate, winnings, voteSummary);\\n\\n            apolloToken.transfer(_candidate, winnings - burnAmount);\\n            apolloToken.transfer(devWallet, devWalletTake);\\n            apolloToken.burn(burnAmount);\\n        }\\n         \\n\\n        if (approvedNewDAO == address(0)) {\\n            currentVotingCycleEnd = block.timestamp + votingCyleLength;\\n        } else {\\n            continueContests = false;\\n        }\\n    }\\n\\n    /// @notice Cast a vote for an active nominated DAO\\n    /// @param voteAmount The amount of Apollo to commit to your vote\\n    /// @param newDAO The address of the nominated DAO to cast a vote for\\n    /// @param voteFor Whether you want to vote in favor of the nomination\\n    function voteForDAONomination(uint256 voteAmount, address newDAO, bool voteFor) external {\\n        require(_newDAONominations[newDAO].timeOfNomination > 0 , \\\"There is no DAO Nomination for this address\\\");\\n        require(_lockedVotes[_msgSender()][newDAO].voteCount == 0, \\\"User already voted on this nomination\\\");\\n        require(approvedNewDAO == address(0), \\\"There is already an approved new DAO\\\");\\n        apolloToken.transferFrom(_msgSender(), address(this), voteAmount);\\n        totalLockedVotes += voteAmount;\\n        _lockedVotes[_msgSender()][newDAO].voteCount += voteAmount;\\n        _lockedVotes[_msgSender()][newDAO].votedFor = voteFor;\\n        if(voteFor){\\n            _newDAONominations[newDAO].votesFor += voteAmount;\\n        } else {\\n            _newDAONominations[newDAO].votesAgainst += voteAmount;\\n        }\\n        emit VoteSubmitted(newDAO, _msgSender(), voteAmount, voteFor);\\n    }\\n\\n    /// @notice Withdraw votes you have previously cast for a nomination. This can be called regardless of\\n    /// whether a nomination is active. If still active, your votes will no longer count in the final tally.\\n    /// @param newDAO The address of the nomination to withdraw your votes from\\n    function withdrawNewDAOVotes(address newDAO) external {\\n        uint256 currentVoteCount = _lockedVotes[_msgSender()][newDAO].voteCount;\\n        require(currentVoteCount > 0 , \\\"You have not cast votes for this nomination\\\");\\n        require((totalLockedVotes - currentVoteCount) >= 0, \\\"Withdrawing would take DAO balance below expected rewards amount\\\");\\n\\n        uint256 apolloToBurn = currentVoteCount * daoVoteBurnPercentage / 100;\\n        uint256 apolloToTransfer = currentVoteCount - apolloToBurn;\\n\\n        apolloToken.transfer(_msgSender(), apolloToTransfer);\\n        apolloToken.burn(apolloToBurn);\\n\\n\\n        totalLockedVotes -= currentVoteCount;\\n        _lockedVotes[_msgSender()][newDAO].voteCount -= currentVoteCount;\\n\\n        if(_lockedVotes[_msgSender()][newDAO].votedFor){\\n            _newDAONominations[newDAO].votesFor -= currentVoteCount;\\n        } else {\\n            _newDAONominations[newDAO].votesAgainst -= currentVoteCount;\\n        }\\n        emit VoteWithdrawn(newDAO, _msgSender());\\n    }\\n\\n    /// @notice Submit a nomination for a new DAO contract\\n    /// @param newDAO The address of the new DAO contract you wish to nominate\\n    function nominateNewDAO(address newDAO) external {\\n        require(apolloToken.balanceOf(_msgSender()) >= minimumDAOBalance , \\\"Nominator does not own enough APOLLO\\\");\\n        require(_newDAONominations[newDAO].timeOfNomination == 0, \\\"This address has already been nominated\\\");\\n        _newDAONominations[newDAO] = DAONomination({\\n            timeOfNomination: block.timestamp,\\n            nominator: _msgSender(),\\n            votesFor: 0,\\n            votesAgainst: 0,\\n            votingClosed: false\\n        });\\n        activeDAONominations += 1;\\n        emit NewDAONomination(newDAO, _msgSender());\\n    }\\n\\n    /// @notice Close voting for the provided nomination, preventing any future votes\\n    /// @param newDAO The address of the nomination to close voting for\\n    function closeNewDAOVoting(address newDAO) external {\\n        require(block.timestamp > (_newDAONominations[newDAO].timeOfNomination + daoVotingDuration), \\\"We have not passed the minimum voting duration\\\");\\n        require(!_newDAONominations[newDAO].votingClosed, \\\"Voting has already closed for this nomination\\\");\\n        require(approvedNewDAO == address(0), \\\"There is already an approved new DAO\\\");\\n\\n        bool approved = (_newDAONominations[newDAO].votesFor > _newDAONominations[newDAO].votesAgainst);\\n        if (approved) {\\n            approvedNewDAO = newDAO;\\n            daoApprovedTime = block.timestamp;\\n        }\\n        activeDAONominations -= 1;\\n        _newDAONominations[newDAO].votingClosed = true;\\n        emit VotingClosed(newDAO, approved);\\n    }\\n\\n    /// @notice Update the address of the active DAO in the Apollo token contract\\n    /// @dev This function may only be called after a new DAO is approved and after the update delay has elapsed\\n    function updateDAOAddress() external {\\n        require(approvedNewDAO != address(0), \\\"There is not an approved new DAO\\\");\\n        require(block.timestamp > (daoApprovedTime + daoUpdateDelay), \\\"We have not finished the delay for an approved DAO\\\");\\n        apolloToken.changeArtistAddress(approvedNewDAO);\\n    }\\n\\n    /// @notice Reflects any contract balance left behinf\\n    ///@param amountToReflect is the amount to reflect. Set to 0 to reflect entire balance\\n    function reflectBalance(uint256 amountToReflect) external {\\n        require(apolloToken.artistDAO() != address(this), \\\"This function cannot be called while this contract is the DAO\\\");\\n        if(amountToReflect == 0){\\n            amountToReflect = apolloToken.balanceOf(address(this));\\n        }\\n        apolloToken.reflect(amountToReflect);\\n    }\\n\\n    /// @notice The time the provided DAO address was nominated\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationTime(address dao) external view returns (uint256){\\n        return _newDAONominations[dao].timeOfNomination;\\n    }\\n\\n    /// @notice The account that nominated the provided DAO address\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationNominator(address dao) external view returns (address){\\n        return _newDAONominations[dao].nominator;\\n    }\\n\\n    /// @notice The amount of votes in favor of a nomination\\n    /// @param dao The DAO address to check\\n    function daoNominationVotesFor(address dao) external view returns (uint256){\\n        return _newDAONominations[dao].votesFor;\\n    }\\n\\n    /// @notice The amount of votes against a nomination\\n    /// @param dao The DAO address to check\\n    function daoNominationVotesAgainst(address dao) external view returns (uint256){\\n        return _newDAONominations[dao].votesAgainst;\\n    }\\n\\n    /// @notice Whether voting is closed for the provided DAO address\\n    /// @param dao The DAO address that was previously nominated\\n    function daoNominationVotingClosed(address dao) external view returns (bool){\\n        return _newDAONominations[dao].votingClosed;\\n    }\\n\\n    /// @notice The amount of votes pledged by the provided voter for the provided DAO nomination\\n    /// @param voter The address who cast a vote for the DAO\\n    /// @param dao The address of the nominated DAO to check\\n    function checkAddressVoteAmount(address voter, address dao) external view returns (uint256){\\n        return _lockedVotes[voter][dao].voteCount;\\n    }\\n\\n    function checkDAOAddressVote(address voter, address dao) external view returns (bool){\\n        return _lockedVotes[voter][dao].votedFor;\\n    }\\n\\n    // Functions for changing contest parameters\\n\\n    function setVoteMultiplier(uint256 newMultiplier) external onlyDeployingWallet(){\\n        voteAwardMultiplier = newMultiplier;\\n    }\\n\\n    function setMaxBalancePercentage(uint256 newPercentage) external onlyDeployingWallet(){\\n        maxBalancePercentage = newPercentage;\\n    }\\n\\n    function setMinimumVoteDollarAmount(uint256 newDollarAmount) external onlyDeployingWallet(){\\n        minimumUSDValueToVote = newDollarAmount;\\n    }\\n\\n    function setMinimumNominationDollarAmount(uint256 newDollarAmount) external onlyDeployingWallet(){\\n        minimumUSDValueToNominate = newDollarAmount;\\n    }\\n\\n    function setBurnPercentage(uint256 newPercentage) external onlyDeployingWallet(){\\n        awardBurnPercentage = newPercentage;\\n    }\\n\\n    function setDevWalletPerMille(uint256 newPerMille) external onlyDeployingWallet(){\\n        devWalletPerMille = newPerMille;\\n    }\\n\\n    function pullApolloFunds(address recipient, uint256 amountToSend) external onlyDeployingWallet(){\\n        uint256 amount;\\n        if(amountToSend == 0) {\\n            amount = apolloToken.balanceOf(address(this));\\n        } else {\\n            amount = amountToSend;\\n        }\\n        apolloToken.transfer(recipient, amount);\\n    }\\n\\n    // Internal functions\\n\\n    /// @notice The minimum amount of Apollo an account must hold to submit a vote\\n    function _apolloAmountFromUSD(uint256 _usdAmount) internal view returns (uint256) {\\n        (uint usdcReserve, uint wethToUSDCReserve) = UniswapV2Library.getReserves(uniswapFactory, usdcAddress, wethAddress);\\n        (uint apolloReserve, uint wethToApolloReserve) = UniswapV2Library.getReserves(uniswapFactory, address(apolloToken), wethAddress);\\n        uint wethAmount = UniswapV2Library.quote(_usdAmount, usdcReserve, wethToUSDCReserve);\\n        uint apolloAmount = UniswapV2Library.quote(wethAmount, wethToApolloReserve, apolloReserve);\\n        return apolloAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/third-party/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\n\\nlibrary SafeMath {\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n}\\n\\nlibrary UniswapV2Library {\\n    using SafeMath for uint;\\n\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\\n    }\\n\\n    // calculates the CREATE2 address for a pair without making any external calls\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = address(uint160(uint(keccak256(abi.encodePacked(\\n                hex'ff',\\n                factory,\\n                keccak256(abi.encodePacked(token0, token1)),\\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\\n            )))));\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\\n        (address token0,) = sortTokens(tokenA, tokenB);\\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\\n        amountB = amountA.mul(reserveB) / reserveA;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/IApolloToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external view returns (address);\\n}\\n\\ninterface IApolloToken {\\n    function changeArtistAddress(address newAddress) external;\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n    function burn(uint256 burnAmount) external;\\n    function reflect(uint256 tAmount) external;\\n    function artistDAO() external view returns (address);\\n    function uniswapRouter() external view returns (IUniswapV2Router02);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_usdcAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_devWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_deployingWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"summary\",\"type\":\"string\"}],\"name\":\"CycleWinnerSelected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nominator\",\"type\":\"address\"}],\"name\":\"NewDAONomination\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"voteAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"voteFor\",\"type\":\"bool\"}],\"name\":\"VoteSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"VotingClosed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeDAONominations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apolloToken\",\"outputs\":[{\"internalType\":\"contract IApolloToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approvedNewDAO\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"awardBurnPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"checkAddressVoteAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"checkDAOAddressVote\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"closeNewDAOVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_voteCount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"voteSummary\",\"type\":\"string\"}],\"name\":\"completeCycle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"continueContests\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentVotingCycleEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoApprovedTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationNominator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotesAgainst\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotesFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"daoNominationVotingClosed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoUpdateDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoVoteBurnPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoVotingDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devWalletPerMille\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"leadVoteRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"candidate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"voteCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteCycle\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBalancePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumDAOBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumNominationBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumUSDValueToNominate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumUSDValueToVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumVoteBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"nominateNewDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSend\",\"type\":\"uint256\"}],\"name\":\"pullApolloFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToReflect\",\"type\":\"uint256\"}],\"name\":\"reflectBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"setBurnPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPerMille\",\"type\":\"uint256\"}],\"name\":\"setDevWalletPerMille\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"setMaxBalancePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDollarAmount\",\"type\":\"uint256\"}],\"name\":\"setMinimumNominationDollarAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDollarAmount\",\"type\":\"uint256\"}],\"name\":\"setMinimumVoteDollarAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMultiplier\",\"type\":\"uint256\"}],\"name\":\"setVoteMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDAOAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdcAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteAwardMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"voteFor\",\"type\":\"bool\"}],\"name\":\"voteForDAONomination\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votingCyleLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"votingSummary\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newDAO\",\"type\":\"address\"}],\"name\":\"withdrawNewDAOVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ApolloDAO", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000adf86e75d8f0f57e0288d0970e7407eaa49b3cab000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000051f42141e3ff5e02ecbfa614ab5fd6be60778fe90000000000000000000000008eefbb91c097341620b2a13425577aed24337f400000000000000000000000008120dc5a4de3060d6284e8cf541f872edc00c734", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}