{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// File: tokens/erc1155/ERC1155.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\nabstract contract ERC1155 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event TransferSingle(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 id,\r\n        uint256 amount\r\n    );\r\n\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] amounts\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC1155 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function uri(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             ERC1155 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) public virtual {\r\n        require(\r\n            msg.sender == from || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        balanceOf[from][id] -= amount;\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, from, to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) public virtual {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        require(\r\n            msg.sender == from || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            balanceOf[from][id] -= amount;\r\n            balanceOf[to][id] += amount;\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256[] memory balances)\r\n    {\r\n        uint256 ownersLength = owners.length; // Saves MLOADs.\r\n\r\n        require(ownersLength == ids.length, \"LENGTH_MISMATCH\");\r\n\r\n        balances = new uint256[](owners.length);\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the array index counter which cannot possibly overflow.\r\n        unchecked {\r\n            for (uint256 i = 0; i < ownersLength; i++) {\r\n                balances[i] = balanceOf[owners[i]][ids[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        pure\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\r\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) internal {\r\n        balanceOf[to][id] += amount;\r\n\r\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155Received(\r\n                    msg.sender,\r\n                    address(0),\r\n                    id,\r\n                    amount,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _batchMint(\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            balanceOf[to][ids[i]] += amounts[i];\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\r\n\r\n        require(\r\n            to.code.length == 0\r\n                ? to != address(0)\r\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(\r\n                    msg.sender,\r\n                    address(0),\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                ) == ERC1155TokenReceiver.onERC1155BatchReceived.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _batchBurn(\r\n        address from,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts\r\n    ) internal {\r\n        uint256 idsLength = ids.length; // Saves MLOADs.\r\n\r\n        require(idsLength == amounts.length, \"LENGTH_MISMATCH\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ) {\r\n            balanceOf[from][ids[i]] -= amounts[i];\r\n\r\n            // An array can't have a total length\r\n            // larger than the max uint256 value.\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\r\n    }\r\n\r\n    function _burn(\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) internal {\r\n        balanceOf[from][id] -= amount;\r\n\r\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\r\ninterface ERC1155TokenReceiver {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: Club.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract Club is ERC1155 {\r\n    using Counters for Counters.Counter;\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    string public docs;\r\n    address public safeAddress;\r\n    address public referralAddress;\r\n    address internal coterieAddress;\r\n    uint256 public maxMembers;\r\n\r\n    Counters.Counter public memberCounter;\r\n    Counters.Counter public tokenCounter;\r\n\r\n    mapping(address => bool) public members;\r\n    mapping(uint256 => Token) public tokens;\r\n\r\n    bool internal locked;\r\n\r\n    struct Token {\r\n        uint256 mintPrice;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        string ipfsCID;\r\n        uint256 maximum;\r\n        uint256 minted;\r\n        uint256 maxAmount;\r\n        bool exists;\r\n    }\r\n\r\n    event Minted(address who, uint256 tokenIndex, uint256 amount);\r\n    event Withdrew(uint256 amountSentToSafe, uint256 percentageFee);\r\n    event Kicked(address who);\r\n    event Joined(address who);\r\n\r\n    error UnknownToken();\r\n    error AlreadyInitialized();\r\n    error NotEnoughFunds();\r\n    error NotMember();\r\n\r\n    modifier onlySafe() {\r\n        require(\r\n            msg.sender == safeAddress,\r\n            \"Only the safe can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyCoterie() {\r\n        require(\r\n            msg.sender == coterieAddress,\r\n            \"Only coterie can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onTime(uint256 startTime, uint256 endTime) {\r\n        require(startTime < endTime, \"Start time must be before end time\");\r\n        require(startTime > 0 && endTime > 0, \"Time window cannot be 0\");\r\n        _;\r\n    }\r\n\r\n    modifier inMemberLimits(uint256 _maxMembers, string memory _docs) {\r\n        if (bytes(_docs).length == 0) {\r\n            require(_maxMembers > 0, \"Max members must be greater than 0\");\r\n            require(_maxMembers <= 100, \"Max members must be less than 100\");\r\n        } else {\r\n            require(_maxMembers > 0, \"Max members must be greater than 0\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _kick(address to) internal {\r\n        if (!members[to]) revert NotMember();\r\n\r\n        for (uint256 i = 0; i < tokenCounter.current(); i++) {\r\n            if (balanceOf[to][i] > 0) {\r\n                balanceOf[to][i] = 0;\r\n            }\r\n        }\r\n\r\n        memberCounter.decrement();\r\n        members[to] = false;\r\n\r\n        emit Kicked(to);\r\n    }\r\n\r\n    function _getTokenValues(address to) internal view returns (uint256) {\r\n        if (!members[to]) revert NotMember();\r\n\r\n        uint256 total = 0;\r\n\r\n        for (uint256 i = 0; i < tokenCounter.current(); i++) {\r\n            if (balanceOf[to][i] > 0) {\r\n                total = total.add(balanceOf[to][i].mul(tokens[i].mintPrice));\r\n            }\r\n        }\r\n\r\n        return total;\r\n    }\r\n\r\n    function _addMember(address to) internal {\r\n        require(!members[to], \"Member already exists\");\r\n\r\n        members[to] = true;\r\n        memberCounter.increment();\r\n\r\n        emit Joined(to);\r\n    }\r\n\r\n    function setCoterieAddress(address _coterieAddress) external onlyCoterie {\r\n        coterieAddress = _coterieAddress;\r\n    }\r\n\r\n    function init(\r\n        string memory _clubName,\r\n        string memory _tokenSymbol,\r\n        string memory _docs,\r\n        uint256 _maxMembers,\r\n        address _safeAddress,\r\n        address _referralAddress\r\n    ) external inMemberLimits(_maxMembers, _docs) {\r\n        if (safeAddress != address(0)) revert AlreadyInitialized();\r\n        require(\r\n            _safeAddress != _referralAddress,\r\n            \"Safe address cannot be the same as referral address\"\r\n        );\r\n\r\n        name = _clubName;\r\n        symbol = _tokenSymbol;\r\n        docs = _docs;\r\n        safeAddress = _safeAddress;\r\n        referralAddress = _referralAddress;\r\n        maxMembers = _maxMembers;\r\n        coterieAddress = 0x7c5252031d236d5A17db832Fc8367e6850a3b4FB;\r\n    }\r\n\r\n    function createFundingRound(\r\n        uint256 mintPrice,\r\n        uint256 startTime,\r\n        uint256 endTime,\r\n        uint256 maximum,\r\n        uint256 maxAmount,\r\n        string memory ipfsCID\r\n    ) external onlySafe onTime(startTime, endTime) {\r\n        Token storage token = tokens[tokenCounter.current()];\r\n        token.mintPrice = mintPrice;\r\n        token.startTime = startTime;\r\n        token.endTime = endTime;\r\n        token.ipfsCID = ipfsCID;\r\n        token.maximum = maximum;\r\n        token.minted = 0;\r\n        token.maxAmount = maxAmount;\r\n        token.exists = true;\r\n\r\n        tokenCounter.increment();\r\n    }\r\n\r\n    function editFundingRound(\r\n        uint256 id,\r\n        uint256 mintPrice,\r\n        uint256 startTime,\r\n        uint256 endTime\r\n    ) external onlySafe onTime(startTime, endTime) {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].mintPrice = mintPrice;\r\n        tokens[id].startTime = startTime;\r\n        tokens[id].endTime = endTime;\r\n    }\r\n\r\n    function editTokenMintMaximum(uint256 id, uint256 maximum)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].maximum = maximum;\r\n    }\r\n\r\n    function editTokenMaxAmount(uint256 id, uint256 maxAmount)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].maxAmount = maxAmount;\r\n    }\r\n\r\n    function editTokenIPFS(uint256 id, string memory ipfsCID)\r\n        external\r\n        onlySafe\r\n    {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        tokens[id].ipfsCID = ipfsCID;\r\n    }\r\n\r\n    function editMaximumMembers(uint256 _maxMembers)\r\n        external\r\n        onlySafe\r\n        inMemberLimits(_maxMembers, docs)\r\n    {\r\n        maxMembers = _maxMembers;\r\n    }\r\n\r\n    function mint(uint256 tokenIndex, uint256 amount) external payable {\r\n        if (!tokens[tokenIndex].exists) revert UnknownToken();\r\n        if (tokens[tokenIndex].maxAmount > 0) {\r\n            require(\r\n                amount <=\r\n                    tokens[tokenIndex].maxAmount.sub(\r\n                        balanceOf[msg.sender][tokenIndex]\r\n                    ),\r\n                \"Cannot mint over max amount\"\r\n            );\r\n        }\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n        require(\r\n            block.timestamp > tokens[tokenIndex].startTime &&\r\n                block.timestamp < tokens[tokenIndex].endTime,\r\n            \"time window closed\"\r\n        );\r\n        if (msg.value < amount.mul(tokens[tokenIndex].mintPrice))\r\n            revert NotEnoughFunds();\r\n        if (tokens[tokenIndex].maximum > 0) {\r\n            require(\r\n                tokens[tokenIndex].minted.add(amount) <=\r\n                    tokens[tokenIndex].maximum,\r\n                \"Maximum amount of tokens minted\"\r\n            );\r\n        }\r\n\r\n        if (!members[msg.sender]) {\r\n            if (memberCounter.current() >= maxMembers) revert(\"Club is full\");\r\n            members[msg.sender] = true;\r\n            memberCounter.increment();\r\n\r\n            emit Joined(msg.sender);\r\n        }\r\n\r\n        _mint(msg.sender, tokenIndex, amount, \"\");\r\n        tokens[tokenIndex].minted = tokens[tokenIndex].minted.add(amount);\r\n\r\n        emit Minted(msg.sender, tokenIndex, amount);\r\n    }\r\n\r\n    function withdraw() external onlySafe {\r\n        require(safeAddress != address(0), \"Club not initialized\");\r\n        require(address(this).balance > 0, \"No funds to withdraw\");\r\n\r\n        uint256 balance = address(this).balance;\r\n        uint256 rate = 500;\r\n\r\n        if (balance >= 50 ether && balance < 85 ether) {\r\n            rate = 425;\r\n        } else if (balance >= 85 ether && balance < 100 ether) {\r\n            rate = 385;\r\n        } else if (balance >= 100 ether && balance < 250 ether) {\r\n            rate = 325;\r\n        } else if (balance >= 250 ether && balance < 500 ether) {\r\n            rate = 250;\r\n        } else if (balance >= 500 ether) {\r\n            rate = 200;\r\n        }\r\n\r\n        uint256 coterieFee = address(this).balance.mul(rate).div(10000);\r\n        uint256 referralFee = 0;\r\n\r\n        if (referralAddress != address(0)) {\r\n            referralFee = coterieFee.div(10);\r\n            (bool referralSuccess, ) = referralAddress.call{value: referralFee}(\r\n                \"\"\r\n            );\r\n            if (!referralSuccess) {\r\n                revert(\"referral address failed to receive funds\");\r\n            }\r\n        }\r\n\r\n        (bool coterieSuccess, ) = coterieAddress.call{\r\n            value: coterieFee.sub(referralFee)\r\n        }(\"\");\r\n        if (!coterieSuccess) {\r\n            revert(\"Coterie address failed to receive funds\");\r\n        }\r\n\r\n        uint256 amountSentToSafe = address(this).balance;\r\n\r\n        (bool safeSuccess, ) = safeAddress.call{value: amountSentToSafe}(\"\");\r\n        if (!safeSuccess) {\r\n            revert(\"Safe address failed to receive funds\");\r\n        }\r\n\r\n        emit Withdrew(amountSentToSafe, rate);\r\n    }\r\n\r\n    function kick(address to) external payable onlySafe {\r\n        uint256 totalEtherToReturn = _getTokenValues(to);\r\n\r\n        if (msg.value < totalEtherToReturn) revert NotEnoughFunds();\r\n\r\n        _kick(to);\r\n\r\n        (bool success, ) = to.call{value: totalEtherToReturn}(\"\");\r\n        if (!success) {\r\n            revert(\"Failed to send funds to kicked member\");\r\n        }\r\n    }\r\n\r\n    function kickMultiple(address[] calldata to) external payable onlySafe {\r\n        require(to.length > 0, \"No members to kick\");\r\n        require(\r\n            to.length <= memberCounter.current(),\r\n            \"Too many addresses provided\"\r\n        );\r\n        require(msg.value > 0, \"No ether was sent\");\r\n\r\n        int256 balance = int256(msg.value);\r\n\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            uint256 etherToReturn = _getTokenValues(to[i]);\r\n            balance = balance - int256(etherToReturn);\r\n\r\n            if (balance < 0) revert NotEnoughFunds();\r\n\r\n            _kick(to[i]);\r\n\r\n            (bool success, ) = to[i].call{value: etherToReturn}(\"\");\r\n            if (!success) {\r\n                revert(\"Failed to send funds to kicked member\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function addMember(address to) public onlySafe {\r\n        require(memberCounter.current() < maxMembers, \"Club is full\");\r\n\r\n        _addMember(to);\r\n    }\r\n\r\n    function addMembers(address[] calldata to) external onlySafe {\r\n        require(to.length > 0, \"No members to add\");\r\n        require(\r\n            to.length.add(memberCounter.current()) <= maxMembers,\r\n            \"Too many addresses provided\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            _addMember(to[i]);\r\n        }\r\n    }\r\n\r\n    function uri(uint256 id) public view override returns (string memory) {\r\n        if (!tokens[id].exists) revert UnknownToken();\r\n\r\n        return string(abi.encodePacked(\"ipfs://\", tokens[id].ipfsCID));\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughFunds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotMember\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownToken\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Joined\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Kicked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountSentToSafe\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentageFee\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"addMember\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"addMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsCID\",\"type\":\"string\"}],\"name\":\"createFundingRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"docs\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"editFundingRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxMembers\",\"type\":\"uint256\"}],\"name\":\"editMaximumMembers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsCID\",\"type\":\"string\"}],\"name\":\"editTokenIPFS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"editTokenMaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximum\",\"type\":\"uint256\"}],\"name\":\"editTokenMintMaximum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_clubName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_docs\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_maxMembers\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_safeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"kick\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"name\":\"kickMultiple\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMembers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"memberCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coterieAddress\",\"type\":\"address\"}],\"name\":\"setCoterieAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsCID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maximum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Club", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8f5c379743fd26023b26d41066d961bb4f6255e2611abf45abe403f586262800"}]}