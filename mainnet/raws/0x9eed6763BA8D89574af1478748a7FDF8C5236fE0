{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/l1/L1GovernanceRelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"./L1DAIBridge.sol\\\";\\n\\ncontract L1GovernanceRelay {\\n  // --- Auth ---\\n  mapping(address => uint256) public wards;\\n  function rely(address usr) external auth {\\n    wards[usr] = 1;\\n    emit Rely(usr);\\n  }\\n  function deny(address usr) external auth {\\n    wards[usr] = 0;\\n    emit Deny(usr);\\n  }\\n  modifier auth() {\\n    require(wards[msg.sender] == 1, \\\"L1GovernanceRelay/not-authorized\\\");\\n    _;\\n  }\\n\\n  event Rely(address indexed usr);\\n  event Deny(address indexed usr);\\n\\n  uint256 constant RELAY_SELECTOR = 300224956480472355485152391090755024345070441743081995053718200325371913697;\\n\\n  address public immutable starkNet;\\n  uint256 public immutable l2GovernanceRelay;\\n\\n  constructor(address _starkNet, uint256 _l2GovernanceRelay) {\\n    wards[msg.sender] = 1;\\n    emit Rely(msg.sender);\\n\\n    starkNet = _starkNet;\\n    l2GovernanceRelay = _l2GovernanceRelay;\\n  }\\n\\n  // Forward a call to be repeated on L2\\n  function relay(uint256 spell) external auth {\\n    uint256[] memory payload = new uint256[](1);\\n    payload[0] = spell;\\n    StarkNetLike(starkNet).sendMessageToL2(l2GovernanceRelay, RELAY_SELECTOR, payload);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/l1/L1DAIBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.7.6;\\n\\ninterface TokenLike {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool success);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\\ninterface StarkNetLike {\\n    function sendMessageToL2(\\n        uint256 to,\\n        uint256 selector,\\n        uint256[] calldata payload\\n    ) external returns (bytes32);\\n\\n    function consumeMessageFromL2(\\n        uint256 from,\\n        uint256[] calldata payload\\n    ) external returns (bytes32);\\n\\n    function startL1ToL2MessageCancellation(\\n        uint256 toAddress,\\n        uint256 selector,\\n        uint256[] calldata payload,\\n        uint256 nonce\\n    ) external;\\n\\n    function cancelL1ToL2Message(\\n        uint256 toAddress,\\n        uint256 selector,\\n        uint256[] calldata payload,\\n        uint256 nonce\\n    ) external;\\n}\\n\\ncontract L1DAIBridge {\\n    // --- Auth ---\\n    mapping(address => uint256) public wards;\\n\\n    function rely(address usr) external auth {\\n        wards[usr] = 1;\\n        emit Rely(usr);\\n    }\\n\\n    function deny(address usr) external auth {\\n        wards[usr] = 0;\\n        emit Deny(usr);\\n    }\\n\\n    modifier auth() {\\n        require(wards[msg.sender] == 1, \\\"L1DAIBridge/not-authorized\\\");\\n        _;\\n    }\\n\\n    event Rely(address indexed usr);\\n    event Deny(address indexed usr);\\n\\n\\n    uint256 public isOpen = 1;\\n\\n    modifier whenOpen() {\\n        require(isOpen == 1, \\\"L1DAIBridge/closed\\\");\\n        _;\\n    }\\n\\n    function close() external auth {\\n        isOpen = 0;\\n        emit Closed();\\n    }\\n\\n    event Closed();\\n\\n    address public immutable starkNet;\\n    address public immutable dai;\\n    uint256 public immutable l2Dai;\\n    address public immutable escrow;\\n    uint256 public immutable l2DaiBridge;\\n\\n    uint256 public ceiling = 0;\\n    uint256 public maxDeposit = type(uint256).max;\\n\\n    uint256 constant HANDLE_WITHDRAW = 0;\\n\\n    // src/starkware/cairo/lang/cairo_constants.py\\n    //  2 ** 251 + 17 * 2 ** 192 + 1;\\n    uint256 constant SN_PRIME =\\n        3618502788666131213697322783095070105623107215331596699973092056135872020481;\\n\\n    //  from starkware.starknet.compiler.compile import get_selector_from_name\\n    //  print(get_selector_from_name('handle_deposit'))\\n    uint256 constant DEPOSIT =\\n        1285101517810983806491589552491143496277809242732141897358598292095611420389;\\n\\n    //  print(get_selector_from_name('handle_force_withdrawal'))\\n    uint256 constant FORCE_WITHDRAW =\\n        1137729855293860737061629600728503767337326808607526258057644140918272132445;\\n\\n    event LogCeiling(uint256 ceiling);\\n    event LogMaxDeposit(uint256 maxDeposit);\\n    event LogDeposit(address indexed l1Sender, uint256 amount, uint256 l2Recipient);\\n    event LogWithdrawal(address indexed l1Recipient, uint256 amount);\\n    event LogForceWithdrawal(address indexed l1Recipient, uint256 amount, uint256 indexed l2Sender);\\n    event LogStartDepositCancellation(uint256 indexed l2Receipient, uint256 amount, uint256 nonce);\\n    event LogCancelDeposit(\\n        uint256 indexed l2Recipient, address l1Recipient, uint256 amount, uint256 nonce\\n    );\\n\\n    constructor(\\n        address _starkNet,\\n        address _dai,\\n        uint256 _l2Dai,\\n        address _escrow,\\n        uint256 _l2DaiBridge\\n    ) {\\n        wards[msg.sender] = 1;\\n        emit Rely(msg.sender);\\n\\n        starkNet = _starkNet;\\n        dai = _dai;\\n        l2Dai = _l2Dai;\\n        escrow = _escrow;\\n        l2DaiBridge = _l2DaiBridge;\\n    }\\n\\n    function setCeiling(uint256 _ceiling) external auth whenOpen {\\n        ceiling = _ceiling;\\n        emit LogCeiling(_ceiling);\\n    }\\n\\n    function setMaxDeposit(uint256 _maxDeposit) external auth whenOpen {\\n        maxDeposit = _maxDeposit;\\n        emit LogMaxDeposit(_maxDeposit);\\n    }\\n\\n    // slither-disable-next-line similar-names\\n    function deposit(\\n        uint256 amount,\\n        uint256 l2Recipient\\n    ) external whenOpen {\\n        emit LogDeposit(msg.sender, amount, l2Recipient);\\n\\n        require(l2Recipient != 0 && l2Recipient != l2Dai && l2Recipient < SN_PRIME, \\\"L1DAIBridge/invalid-address\\\");\\n\\n        require(amount <= maxDeposit, \\\"L1DAIBridge/above-max-deposit\\\");\\n\\n        TokenLike(dai).transferFrom(msg.sender, escrow, amount);\\n\\n        require(\\n            TokenLike(dai).balanceOf(escrow) <= ceiling,\\n            \\\"L1DAIBridge/above-ceiling\\\"\\n        );\\n\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = l2Recipient;\\n        (payload[1], payload[2]) = toSplitUint(amount);\\n        payload[3] = uint256(uint160(msg.sender));\\n\\n        StarkNetLike(starkNet).sendMessageToL2(l2DaiBridge, DEPOSIT, payload);\\n    }\\n\\n    function toSplitUint(uint256 value) internal pure returns (uint256, uint256) {\\n      uint256 low = value & ((1 << 128) - 1);\\n      uint256 high = value >> 128;\\n      return (low, high);\\n    }\\n\\n    // slither-disable-next-line similar-names\\n    function withdraw(uint256 amount, address l1Recipient) external {\\n        emit LogWithdrawal(l1Recipient, amount);\\n\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = HANDLE_WITHDRAW;\\n        payload[1] = uint256(uint160(msg.sender));\\n        (payload[2], payload[3]) = toSplitUint(amount);\\n\\n        StarkNetLike(starkNet).consumeMessageFromL2(l2DaiBridge, payload);\\n        TokenLike(dai).transferFrom(escrow, l1Recipient, amount);\\n    }\\n\\n    function forceWithdrawal(uint256 amount, uint256 l2Sender) external whenOpen {\\n        emit LogForceWithdrawal(msg.sender, amount, l2Sender);\\n\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = l2Sender;\\n        payload[1] = uint256(uint160(msg.sender));\\n        (payload[2], payload[3]) = toSplitUint(amount);\\n\\n        StarkNetLike(starkNet).sendMessageToL2(l2DaiBridge, FORCE_WITHDRAW, payload);\\n    }\\n\\n    function startDepositCancellation(\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        uint256 nonce\\n    ) external {\\n        emit LogStartDepositCancellation(l2Recipient, amount, nonce);\\n\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = l2Recipient;\\n        (payload[1], payload[2]) = toSplitUint(amount);\\n        payload[3] = uint256(uint160(msg.sender));\\n\\n        StarkNetLike(starkNet).startL1ToL2MessageCancellation(l2DaiBridge, DEPOSIT, payload, nonce);\\n    }\\n\\n    function cancelDeposit(\\n        uint256 amount,\\n        uint256 l2Recipient,\\n        // slither-disable-next-line similar-names\\n        address l1Recipient,\\n        uint256 nonce\\n    ) external {\\n        emit LogCancelDeposit(l2Recipient, l1Recipient, amount, nonce);\\n\\n        uint256[] memory payload = new uint256[](4);\\n        payload[0] = l2Recipient;\\n        (payload[1], payload[2]) = toSplitUint(amount);\\n        payload[3] = uint256(uint160(msg.sender));\\n\\n        StarkNetLike(starkNet).cancelL1ToL2Message(l2DaiBridge, DEPOSIT, payload, nonce);\\n        TokenLike(dai).transferFrom(escrow, l1Recipient, amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_starkNet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_l2GovernanceRelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Deny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"Rely\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"deny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l2GovernanceRelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"spell\",\"type\":\"uint256\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"usr\",\"type\":\"address\"}],\"name\":\"rely\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"starkNet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"wards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "L1GovernanceRelay", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000c662c410c0ecf747543f5ba90660f6abebd9c8c401bd845968fc0866ecb43076fc8f122ce6f1793d5871129ee3bae056ca81b672", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}