{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FactoryV1.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\npragma solidity ^0.8.0;\\n\\nimport \\\"@beandao/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@beandao/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"@beandao/contracts/library/Address.sol\\\";\\nimport \\\"@beandao/contracts/library/BeaconDeployer.sol\\\";\\nimport {Ownership, IERC173} from \\\"@beandao/contracts/library/Ownership.sol\\\";\\nimport {BeaconProxyDeployer} from \\\"@beandao/contracts/library/BeaconProxyDeployer.sol\\\";\\nimport {MinimalProxyDeployer} from \\\"@beandao/contracts/library/MinimalProxyDeployer.sol\\\";\\nimport {Multicall, IMulticall} from \\\"@beandao/contracts/library/Multicall.sol\\\";\\nimport \\\"./IFactory.sol\\\";\\n\\n/**\\n * @title Factory V1\\n * @author yoonsung.eth\\n * @notice Abstract reusable contract into template and deploy them in small sizes `minimal proxy` and `beacon proxy`.\\n * This contract can receive a fee lower than the deploy cost, and registered addresses do not have to pay the fee.\\n * Beacon is managed in this contract, it can be useful if you need a scalable upgrade through the `beacon proxy`.\\n * @dev The template to be registered may or may not have an `initialize` function.\\n * However, at least a ERC173 and multicall for directed at self must be implemented.\\n */\\ncontract FactoryV1 is Ownership, Multicall, IFactory {\\n    using Address for address;\\n\\n    /**\\n     * @notice template key for template info.\\n     */\\n    mapping(bytes32 => TemplateInfo) public templates;\\n\\n    /**\\n     * @notice registered template for nonce.\\n     */\\n    mapping(address => uint256) private nonceForTemplate;\\n\\n    /**\\n     * @notice template count.\\n     */\\n    uint256 public nonce = 1;\\n\\n    /**\\n     * @notice base fee\\n     */\\n    uint256 public baseFee;\\n\\n    /**\\n     * @notice fee collector\\n     */\\n    address payable public feeTo;\\n\\n    /**\\n     * @notice requiring on deploy, allowlist contract.\\n     * @param feeAmount basic fee for ether amount\\n     * @param feeToAddr fee collector address\\n     */\\n    constructor(uint256 feeAmount, address payable feeToAddr) {\\n        baseFee = feeAmount;\\n        feeTo = feeToAddr;\\n        nonceForTemplate[address(0)] = type(uint256).max;\\n    }\\n\\n    /**\\n     * @notice template id\ub97c \ud1b5\ud574\uc11c minimal proxy\uc640 minimal beacon proxy\ub97c \ubc30\ud3ec\ud558\ub294 \ud568\uc218.\\n     * @dev \uc77c\ubc18\uc801\uc73c\ub85c \ubc30\ud3ec\ub418\ub294 \ucee8\ud2b8\ub799\ud2b8\uc640 \uac19\uc774 \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ucd08\uae30\ud654 \ud568\uc218\ub97c \uc2e4\ud589\ud574\uc57c \ud55c\ub2e4\uba74, initializationCallData\uc5d0 \ud638\ucd9c\ud560 \ud568\uc218\ub97c\\n     * serialize\ud558\uc5ec \uc8fc\uc785\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4. \ucee8\ud2b8\ub799\ud2b8 \uc18c\uc720\uad8c\uc744 \ubcc4\ub3c4\ub85c \uad00\ub9ac\ud574\uc57c\ud558\ub294 \uacbd\uc6b0 multicall\uc744 \ud1b5\ud574\uc11c \uba85\uc2dc\uc801\uc778 \uc18c\uc720\uad8c \uc774\uc804\uc774 \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\\n     * @param templateId \ubc30\ud3ec\ud560 \ucee8\ud2b8\ub799\ud2b8\uc758 template id\\n     * @param isBeacon \ube44\ucf58\uc73c\ub85c \ubc30\ud3ec\ud574\uc57c \ud560 \uac83\uc778\uc9c0 \uacb0\uc815\ud558\ub294 \uc778\uc790.\\n     * @param initializationCallData \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ud638\ucd9c\ud560 \uc9c1\ub82c\ud654\ub41c \ucd08\uae30\ud654 \ud568\uc218 \uc815\ubcf4\\n     * @param calls \ucee8\ud2b8\ub799\ud2b8\uac00 \ubc30\ud3ec\ub41c \uc774\ud6c4, \ud544\uc694\ud55c \uc77c\ub828\uc758 \ud568\uc218 \ud638\ucd9c \uc815\ubcf4\\n     */\\n    function deploy(\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed) {\\n        // \ud15c\ud50c\ub9bf\uc744 \ubc30\ud3ec\ud558\uae30 \uc704\ud55c \uc218\uc218\ub8cc\uac00 \uc801\uc815 \uc218\uc900\uc778\uc9c0 \ud655\uc778.\\n        require(baseFee <= msg.value || owner == msg.sender, \\\"Factory/Incorrect-amounts\\\");\\n        // \uc218\uc218\ub8cc \uc804\uc1a1\\n        feeTransfer(feeTo, msg.value);\\n        // \ubc30\ud3ec\ud560 \ud15c\ud50c\ub9bf\uc758 \uc815\ubcf4\\n        TemplateInfo memory tmp = templates[templateId];\\n\\n        deployed = isBeacon\\n            ? BeaconProxyDeployer.deploy(tmp.btemplate, initializationCallData)\\n            : MinimalProxyDeployer.deploy(tmp.template, initializationCallData);\\n\\n        // \ubd80\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ud560 \ub370\uc774\ud130\uac00 \uc788\ub2e4\uba74, \ubc30\ud3ec\ub41c \ucee8\ud2b8\ub799\ud2b8\uc5d0 \ucd94\uac00\uc801\uc778 call\uc744 \ud560 \uc218 \uc788\uc74c.\\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\\n        // \uc774\ubca4\ud2b8 \ud638\ucd9c\\n        emit Deployed(deployed, msg.sender);\\n    }\\n\\n    /**\\n     * @notice template id\uc640 \uc678\ubd80\uc5d0\uc11c \uad00\ub9ac\ub418\ub294 seed\ub97c \ud1b5\ud574\uc11c minimal proxy\uc640 minimal beacon proxy\ub97c \ubc30\ud3ec\ud558\ub294 \ud568\uc218.\\n     * @dev \uc77c\ubc18\uc801\uc73c\ub85c \ubc30\ud3ec\ub418\ub294 \ucee8\ud2b8\ub799\ud2b8\uc640 \uac19\uc774 \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ucd08\uae30\ud654 \ud568\uc218\ub97c \uc2e4\ud589\ud574\uc57c \ud55c\ub2e4\uba74, initializationCallData\uc5d0 \ud638\ucd9c\ud560 \ud568\uc218\ub97c\\n     * serialize\ud558\uc5ec \uc8fc\uc785\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4. \ucee8\ud2b8\ub799\ud2b8 \uc18c\uc720\uad8c\uc744 \ubcc4\ub3c4\ub85c \uad00\ub9ac\ud574\uc57c\ud558\ub294 \uacbd\uc6b0 multicall\uc744 \ud1b5\ud574\uc11c \uba85\uc2dc\uc801\uc778 \uc18c\uc720\uad8c \uc774\uc804\uc774 \ub418\uc5b4\uc57c \ud569\ub2c8\ub2e4.\\n     * @param seed \ucee8\ud2b8\ub799\ud2b8 \uc8fc\uc18c \ud655\uc815\uc5d0 \ud544\uc694\ud55c \uc678\ubd80 seed\\n     * @param isBeacon \ube44\ucf58\uc73c\ub85c \ubc30\ud3ec\ud574\uc57c \ud560 \uac83\uc778\uc9c0 \uacb0\uc815\ud558\ub294 \uc778\uc790.\\n     * @param templateId \ubc30\ud3ec\ud560 \ucee8\ud2b8\ub799\ud2b8\uc758 template id\\n     * @param initializationCallData \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ud638\ucd9c\ud560 \uc9c1\ub82c\ud654\ub41c \ucd08\uae30\ud654 \ud568\uc218 \uc815\ubcf4\\n     * @param calls \ucee8\ud2b8\ub799\ud2b8\uac00 \ubc30\ud3ec\ub41c \uc774\ud6c4, \ud544\uc694\ud55c \uc77c\ub828\uc758 \ud568\uc218 \ud638\ucd9c \uc815\ubcf4\\n     */\\n    function deployWithSeed(\\n        string memory seed,\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed) {\\n        // \ud15c\ud50c\ub9bf\uc744 \ubc30\ud3ec\ud558\uae30 \uc704\ud55c \uc218\uc218\ub8cc\uac00 \uc801\uc815 \uc218\uc900\uc778\uc9c0 \ud655\uc778.\\n        require(baseFee <= msg.value || owner == msg.sender, \\\"Factory/Incorrect-amounts\\\");\\n        // \uc218\uc218\ub8cc \uc804\uc1a1\\n        feeTransfer(feeTo, msg.value);\\n        // \ubc30\ud3ec\ud560 \ud15c\ud50c\ub9bf\uc758 \uc815\ubcf4\\n        TemplateInfo memory tmp = templates[templateId];\\n\\n        deployed = isBeacon\\n            ? BeaconProxyDeployer.deploy(seed, tmp.btemplate, initializationCallData)\\n            : MinimalProxyDeployer.deploy(seed, tmp.template, initializationCallData);\\n\\n        // \ubd80\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ud560 \ub370\uc774\ud130\uac00 \uc788\ub2e4\uba74, \ubc30\ud3ec\ub41c \ucee8\ud2b8\ub799\ud2b8\uc5d0 \ucd94\uac00\uc801\uc778 call\uc744 \ud560 \uc218 \uc788\uc74c.\\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\\n        // \uc774\ubca4\ud2b8 \ud638\ucd9c\\n        emit Deployed(deployed, msg.sender);\\n    }\\n\\n    /**\\n     * @notice template id\uc640 \ucd08\uae30\ud654 \ub370\uc774\ud130 \ud1b5\ud574\uc11c minimal proxy\uc640 minimal beacon proxy\ub85c \ubc30\ud3ec\ud560 \uc8fc\uc18c\ub97c \ubbf8\ub9ac \ud30c\uc545\ud558\ub294 \ud568\uc218\\n     * @dev \uc5f0\uacb0\ub41c \uc9c0\uac11 \uc8fc\uc18c\uc5d0 \ub530\ub77c \uc0dd\uc131\ub420 \uc9c0\uac11 \uc8fc\uc18c\uac00 \ubcc0\uacbd\ub418\ubbc0\ub85c, \uc5f0\uacb0\ub418\uc5b4 \uc788\ub294 \uc8fc\uc18c\ub97c \ud544\uc218\ub85c \ud655\uc778\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4.\\n     * @param isBeacon \ube44\ucf58\uc73c\ub85c \ubc30\ud3ec\ud574\uc57c \ud560 \uac83\uc778\uc9c0 \uacb0\uc815\ud558\ub294 \uc778\uc790.\\n     * @param templateId \ubc30\ud3ec\ud560 \ucee8\ud2b8\ub799\ud2b8\uc758 template id\\n     * @param initializationCallData \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ud638\ucd9c\ud560 \uc9c1\ub82c\ud654\ub41c \ucd08\uae30\ud654 \ud568\uc218 \uc815\ubcf4\\n     */\\n    function compute(\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData\\n    ) external view returns (address deployable) {\\n        TemplateInfo memory tmp = templates[templateId];\\n        deployable = isBeacon\\n            ? BeaconProxyDeployer.calculateAddress(tmp.btemplate, initializationCallData)\\n            : MinimalProxyDeployer.calculateAddress(tmp.template, initializationCallData);\\n    }\\n\\n    /**\\n     * @notice template id\uc640 Seed \ubb38\uc790\uc5f4, \ucd08\uae30\ud654 \ub370\uc774\ud130 \ud1b5\ud574\uc11c minimal proxy\uc640 minimal beacon proxy\ub85c \ubc30\ud3ec\ud560 \uc8fc\uc18c\ub97c \ubbf8\ub9ac \ud30c\uc545\ud558\ub294 \ud568\uc218\\n     * @dev \uc5f0\uacb0\ub41c \uc9c0\uac11 \uc8fc\uc18c\uc5d0 \ub530\ub77c \uc0dd\uc131\ub420 \uc9c0\uac11 \uc8fc\uc18c\uac00 \ubcc0\uacbd\ub418\ubbc0\ub85c, \uc5f0\uacb0\ub418\uc5b4 \uc788\ub294 \uc8fc\uc18c\ub97c \ud544\uc218\ub85c \ud655\uc778\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4.\\n     * @param seed \ucee8\ud2b8\ub799\ud2b8\uc5d0 \uc0ac\uc6a9\ud560 seed \ubb38\uc790\uc5f4\\n     * @param isBeacon \ube44\ucf58\uc73c\ub85c \ubc30\ud3ec\ud574\uc57c \ud560 \uac83\uc778\uc9c0 \uacb0\uc815\ud558\ub294 \uc778\uc790.\\n     * @param templateId \ubc30\ud3ec\ud560 \ucee8\ud2b8\ub799\ud2b8\uc758 template id\\n     * @param initializationCallData \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ud638\ucd9c\ud560 \uc9c1\ub82c\ud654\ub41c \ucd08\uae30\ud654 \ud568\uc218 \uc815\ubcf4\\n     */\\n    function computeWithSeed(\\n        string memory seed,\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData\\n    ) external view returns (address deployable) {\\n        TemplateInfo memory tmp = templates[templateId];\\n        deployable = isBeacon\\n            ? BeaconProxyDeployer.calculateAddress(seed, tmp.btemplate, initializationCallData)\\n            : MinimalProxyDeployer.calculateAddress(seed, tmp.template, initializationCallData);\\n    }\\n\\n    /**\\n     * @notice Factori.eth\uc5d0 \ub4f1\ub85d\ub418\uc9c0 \uc54a\uc740 \ucee8\ud2b8\ub799\ud2b8\ub97c Template\ub85c \ud558\uc5ec Minimal Proxy\ub85c \ubc30\ud3ec\ud569\ub2c8\ub2e4.\\n     * @param templateAddr \ud15c\ud50c\ub9bf\uc73c\ub85c \uc0ac\uc6a9\ud560 \uc774\ubbf8 \ubc30\ud3ec\ub41c \ucee8\ud2b8\ub799\ud2b8 \uc8fc\uc18c\\n     * @param initializationCallData \ubc30\ud3ec\ub418\uba74\uc11c \ud638\ucd9c\ub418\uc5b4\uc57c \ud558\ub294 \ucd08\uae30\ud654 \ud568\uc218\\n     * @param calls \ucd08\uae30\ud654 \ud568\uc218 \uc774\uc678\uc5d0, \ud638\ucd9c\ub418\uc5b4\uc57c \ud558\ub294 \ud568\uc218\ub4e4\uc758 \ubc30\uc5f4\\n     */\\n    function clone(\\n        address templateAddr,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed) {\\n        require(nonceForTemplate[templateAddr] == 0, \\\"Factory/Registered-Template\\\");\\n        // \ud15c\ud50c\ub9bf\uc744 \ubc30\ud3ec\ud558\uae30 \uc704\ud55c \uc218\uc218\ub8cc\uac00 \uc801\uc815 \uc218\uc900\uc778\uc9c0 \ud655\uc778.\\n        require(baseFee == msg.value || owner == msg.sender, \\\"Factory/Incorrect-amounts\\\");\\n        // \uc218\uc218\ub8cc \uc804\uc1a1\\n        feeTransfer(feeTo, msg.value);\\n        deployed = MinimalProxyDeployer.deploy(templateAddr, initializationCallData);\\n        if (calls.length > 0) IMulticall(deployed).multicall(calls);\\n    }\\n\\n    /**\\n     * @notice Factori.eth\uc5d0 \ub4f1\ub85d\ub418\uc9c0 \uc54a\uc740 \ucee8\ud2b8\ub799\ud2b8\ub97c Template\ub85c \ud558\uc5ec minimal proxy\ub85c \ubc30\ud3ec\ud560 \uc8fc\uc18c\ub97c \ubbf8\ub9ac \ud30c\uc545\ud558\ub294 \ud568\uc218\\n     * @dev \uc5f0\uacb0\ub41c \uc9c0\uac11 \uc8fc\uc18c\uc5d0 \ub530\ub77c \uc0dd\uc131\ub420 \uc9c0\uac11 \uc8fc\uc18c\uac00 \ubcc0\uacbd\ub418\ubbc0\ub85c, \uc5f0\uacb0\ub418\uc5b4 \uc788\ub294 \uc8fc\uc18c\ub97c \ud544\uc218\ub85c \ud655\uc778\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4.\\n     * @param templateAddr \ubc30\ud3ec\ud560 \ucee8\ud2b8\ub799\ud2b8\uc758 template id\\n     * @param initializationCallData \ucee8\ud2b8\ub799\ud2b8\uac00 \uc0dd\uc131\ub420 \ub54c \ud638\ucd9c\ud560 \uc9c1\ub82c\ud654\ub41c \ucd08\uae30\ud654 \ud568\uc218 \uc815\ubcf4\\n     */\\n    function computeClone(address templateAddr, bytes memory initializationCallData)\\n        external\\n        view\\n        returns (address deployable)\\n    {\\n        deployable = MinimalProxyDeployer.calculateAddress(templateAddr, initializationCallData);\\n    }\\n\\n    /**\\n     * @notice template id\uc5d0 \ub530\ub77c\uc11c \ucee8\ud2b8\ub799\ud2b8\ub97c \ubc30\ud3ec\ud558\uae30 \uc704\ud55c \ud544\uc694 \uac00\uaca9\uc744 \uac00\uc838\uc624\ub294 \ud568\\n     * @dev \uc5f0\uacb0\ub41c \uc9c0\uac11 \uc8fc\uc18c\uc5d0 \ub530\ub77c \uc0dd\uc131\ub420 \uc9c0\uac11 \uc8fc\uc18c\uac00 \ubcc0\uacbd\ub418\ubbc0\ub85c, \uc5f0\uacb0\ub418\uc5b4 \uc788\ub294 \uc8fc\uc18c\ub97c \ud544\uc218\ub85c \ud655\uc778\ud558\uc5ec\uc57c \ud569\ub2c8\ub2e4.\\n     * @return price \uc774\ub354\ub9ac\uc6c0\uc73c\ub85c \uad6c\uc131\ub41c \uac12\uc744 \uac00\uc9d0.\\n     */\\n    function getPrice() external view returns (uint256 price) {\\n        price = baseFee;\\n    }\\n\\n    /**\\n     * @notice \ud15c\ud50c\ub9bf\uc73c\ub85c \uc0ac\uc6a9\ub418\uae30 \uc801\ud569\ud55c \uc778\ud130\ud398\uc774\uc2a4\uac00 \uad6c\ud604\ub41c \ucee8\ud2b8\ub799\ud2b8\ub97c \ud15c\ud50c\ub9bf\uc73c\ub85c \uac00\uaca9\uacfc \ud568\uaed8 \ub4f1\ub85d\ud568.\\n     * @dev \uac19\uc740 \ud15c\ud50c\ub9bf\uc774 \ube44\ucf58\uacfc, \uc77c\ubc18\uc801\uc778 \ud15c\ud50c\ub9bf\uc73c\ub85c \ub4f1\ub85d\ub420 \uc218 \uc788\uc2b5\ub2c8\ub2e4. \ub530\ub77c\uc11c \uc120\ud0dd\uc801\uc73c\ub85c \uc0ac\uc6a9 \uac00\ub2a5\ud569\ub2c8\ub2e4.\\n     * @param templateAddr \ud15c\ud50c\ub9bf\uc73c\ub85c \uc0ac\uc6a9\ub420 \ucee8\ud2b8\ub799\ud2b8\uc758 \uc8fc\uc18c\\n     */\\n    function addTemplate(address templateAddr) external onlyOwner {\\n        require(nonceForTemplate[templateAddr] == 0, \\\"Factory/Non-Valid\\\");\\n        bytes32 key = keccak256(abi.encode(templateAddr, nonce));\\n        address beaconAddr = BeaconDeployer.deploy(templateAddr);\\n        templates[key] = TemplateInfo({template: templateAddr, btemplate: beaconAddr});\\n        nonceForTemplate[templateAddr] = nonce++;\\n        emit NewTemplate(key, templateAddr, beaconAddr);\\n    }\\n\\n    /**\\n     * @notice \ub4f1\ub85d\ub41c \ud15c\ud50c\ub9bf\uc758 \uc815\ubcf4\ub97c \ubcc0\uacbd\ud558\ub294 \ud568\uc218, \ube44\ucf58\uc778 \uacbd\uc6b0\uc5d0\ub294 \ud15c\ud50c\ub9bf\uc744 \uc5c5\ub370\uc774\ud2b8 \ud560 \uc218 \uc788\uc73c\ub098 \ube44\ucf58\uc774 \uc544\ub2c8\ub77c\uba74 \uc5c5\ub370\uc774\ud2b8 \ubd88\uac00\ub2a5.\\n     * @param key \uc5c5\ub370\uc774\ud2b8 \ub420 \ud15c\ud50c\ub9bf\uc758 \uc544\uc774\ub514\\n     * @param templateAddr \ube44\ucf58\uc77c \uacbd\uc6b0 \ud15c\ud50c\ub9bf \uc8fc\uc18c, \ud15c\ud50c\ub9bf \uc18c\uc720\uc8fc \uc8fc\uc18c\ub97c \uc21c\uc11c\ub300\ub85c \uc778\ucf54\ub529\\n     */\\n    function updateTemplate(bytes32 key, address templateAddr) external onlyOwner {\\n        require(templateAddr != address(0), \\\"Factory/Non-Valid\\\");\\n        require(nonceForTemplate[templateAddr] == 0, \\\"Factory/registered-before\\\");\\n        require(templateAddr.isContract(), \\\"Factory/is-not-Contract\\\");\\n        TemplateInfo memory tmp = templates[key];\\n        tmp.template = templateAddr;\\n        (bool success, ) = tmp.btemplate.call(abi.encode(templateAddr));\\n        assert(success);\\n        templates[key] = tmp;\\n        emit UpdatedTemplate(key, tmp.template);\\n    }\\n\\n    /**\\n     * @notice \ub4f1\ub85d\ub41c \ud15c\ud50c\ub9bf\uc744 \uc0ad\uc81c\ud558\ub294 \ud568\uc218\\n     * @param key \uc0ad\uc81c\ub420 \ud15c\ud50c\ub9bf\uc758 \uc544\uc774\ub514\\n     */\\n    function removeTemplate(bytes32 key) external onlyOwner {\\n        TemplateInfo memory tmp = templates[key];\\n        require(tmp.template != address(0), \\\"Factory/Non-Exist\\\");\\n        delete templates[key];\\n        emit DeletedTemplate(key);\\n    }\\n\\n    /**\\n     * @notice \uace0\uc815 \uc218\uc218\ub8cc\ub97c \ubcc0\uacbd\\n     * @param newFee \ubcc0\uacbd\ub41c \uc218\uc218\ub8cc\\n     */\\n    function changeFee(uint256 newFee) external onlyOwner {\\n        uint256 prevFee = baseFee;\\n        baseFee = newFee;\\n        emit FeeChanged(prevFee, newFee);\\n    }\\n\\n    /**\\n     * @notice \uc218\uc218\ub8cc\ub97c \uc218\ucde8\ud560 \ub300\uc0c1 \ubcc0\uacbd\\n     * @param newFeeTo \uc218\ucde8\ud560 \ub300\uc0c1 \uc8fc\uc18c\\n     */\\n    function changeFeeTo(address payable newFeeTo) external onlyOwner {\\n        address prevFeeTo = feeTo;\\n        feeTo = newFeeTo;\\n        emit FeeToChanged(prevFeeTo, newFeeTo);\\n    }\\n\\n    /**\\n     * @notice Factori.eth\uc5d0 \uc313\uc5ec\uc788\ub294 ETH\uc640 \ud1a0\ud070\uc744 \ud638\ucd9c\ud558\uc5ec, \uc218\uc218\ub8cc \uc218\ucde8 \uc8fc\uc18c\uc5d0 \uc804\uc1a1\ud568\\n     * @param tokenAddr \uc218\ucde8\ud560 \ud1a0\ud070 \uc8fc\uc18c\\n     */\\n    function collect(address tokenAddr) external onlyOwner {\\n        IERC20(tokenAddr).transfer(feeTo, IERC20(tokenAddr).balanceOf(address(this)));\\n    }\\n\\n    function recoverOwnership(address deployed, address to) external onlyOwner {\\n        IERC173(deployed).transferOwnership(to);\\n    }\\n\\n    function feeTransfer(address to, uint256 amount) internal returns (bool callStatus) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n            let returnDataSize := returndatasize()\\n            if iszero(callStatus) {\\n                returndatacopy(0, 0, returnDataSize)\\n                revert(0, returnDataSize)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function balanceOf(address target) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/Address.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Address {\\n    function isContract(address target) internal view returns (bool result) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := gt(extcodesize(target), 0)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/BeaconDeployer.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title BeaconDeployer\\n * @author yoonsung.eth\\n * @notice library that deploy Beacon contract.\\n */\\nlibrary BeaconDeployer {\\n    function deploy(address implementation) internal returns (address result) {\\n        bytes memory code = abi.encodePacked(\\n            hex\\\"606161002960003933600081816002015260310152602080380360803960805160005560616000f3fe337f00000000000000000000000000000000000000000000000000000000000000001415602e57600035600055005b337f00000000000000000000000000000000000000000000000000000000000000001460605760005460005260206000f35b\\\",\\n            abi.encode(implementation)\\n        );\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            result := create(0, add(code, 0x20), mload(code))\\n\\n            // pass along failure message from failed contract deployment and revert.\\n            if iszero(extcodesize(result)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/Ownership.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IERC173.sol\\\";\\n\\n/**\\n * @title Ownership\\n * @author yoonsung.eth\\n * @notice \ub2e8\uc77c Ownership\uc744 \uac00\uc9c8 \uc218 \uc788\ub3c4\ub85d \ub3c4\uc640\uc8fc\ub294 \ucd94\uc0c1 \ucee8\ud2b8\ub799\ud2b8\\n * @dev constructor \uae30\ubc18 \ucee8\ud2b8\ub799\ud2b8\uc5d0\uc11c\ub294 \uc0dd\uc131 \uc2dc\uc810\uc5d0 owner\uac00 msg.sender\ub85c \uc9c0\uc815\ub418\uba70,\\n *      Proxy\ub85c \uc791\ub3d9\ub418\ub294 \ucee8\ud2b8\ub799\ud2b8\uc758 \uacbd\uc6b0 `__transferOwnership(address)`\ub97c \uba85\uc2dc\uc801\uc73c\ub85c \ud638\ucd9c\ud558\uc5ec owner\ub97c \uc9c0\uc815\ud558\uc5ec\uc57c \ud55c\ub2e4.\\n */\\nabstract contract Ownership is IERC173 {\\n    address public override owner;\\n\\n    modifier onlyOwner() {\\n        require(owner == msg.sender, \\\"Ownership/Not-Authorized\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    function transferOwnership(address newOwner) external virtual override onlyOwner {\\n        require(newOwner != address(0), \\\"Ownership/Not-Allowed-Zero\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function resignOwnership() external virtual onlyOwner {\\n        delete owner;\\n        emit OwnershipTransferred(msg.sender, address(0));\\n    }\\n\\n    function _transferOwnership(address newOwner) internal {\\n        address prev = owner;\\n        owner = newOwner;\\n        emit OwnershipTransferred(prev, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/BeaconProxyDeployer.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BeaconMaker.sol\\\";\\nimport \\\"./BeaconMakerWithCall.sol\\\";\\n\\n/**\\n * @title BeaconProxyDeployer\\n * @author yoonsung.eth\\n * @notice Beacon Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 \ub77c\uc774\ube0c\ub7ec\ub9ac\\n */\\nlibrary BeaconProxyDeployer {\\n    function deploy(address beacon, bytes memory initializationCalldata) internal returns (address result) {\\n        bytes memory createCode = creation(beacon, initializationCalldata);\\n\\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded_data := add(0x20, createCode) // load initialization code.\\n            let encoded_size := mload(createCode) // load the init code's length.\\n            result := create2(\\n                // call `CREATE2` w/ 4 arguments.\\n                0, // forward any supplied endowment.\\n                encoded_data, // pass in initialization code.\\n                encoded_size, // pass in init code's length.\\n                salt // pass in the salt value.\\n            )\\n\\n            // pass along failure message from failed contract deployment and revert.\\n            if iszero(extcodesize(result)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function deploy(\\n        string memory seed,\\n        address beacon,\\n        bytes memory initializationCalldata\\n    ) internal returns (address result) {\\n        bytes memory createCode = creation(beacon, initializationCalldata);\\n\\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded_data := add(0x20, createCode) // load initialization code.\\n            let encoded_size := mload(createCode) // load the init code's length.\\n            result := create2(\\n                // call `CREATE2` w/ 4 arguments.\\n                0, // forward any supplied endowment.\\n                encoded_data, // pass in initialization code.\\n                encoded_size, // pass in init code's length.\\n                salt // pass in the salt value.\\n            )\\n\\n            // pass along failure message from failed contract deployment and revert.\\n            if iszero(extcodesize(result)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function calculateAddress(address template, bytes memory initializationCalldata)\\n        internal\\n        view\\n        returns (address addr)\\n    {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        (, addr) = getSaltAndTarget(createCode);\\n    }\\n\\n    function calculateAddress(\\n        string memory seed,\\n        address template,\\n        bytes memory initializationCalldata\\n    ) internal view returns (address addr) {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        addr = getTargetFromSeed(createCode, seed);\\n    }\\n\\n    function isBeacon(address beaconAddr, address target) internal view returns (bool result) {\\n        bytes20 beaconAddrBytes = bytes20(beaconAddr);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0x6), beaconAddrBytes)\\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\\n\\n            let other := add(clone, 0x40)\\n            extcodecopy(target, other, 0, 0x3c)\\n            result := eq(mload(clone), mload(other))\\n        }\\n    }\\n\\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\\n        // get the keccak256 hash of the init code for address derivation.\\n        bytes32 initCodeHash = keccak256(initCode);\\n\\n        // set the initial nonce to be provided when constructing the salt.\\n        uint256 nonce = 0;\\n\\n        // declare variable for code size of derived address.\\n        bool exist;\\n\\n        while (true) {\\n            // derive `CREATE2` salt using `msg.sender` and nonce.\\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\\n\\n            target = address( // derive the target deployment address.\\n                uint160( // downcast to match the address type.\\n                    uint256( // cast to uint to truncate upper digits.\\n                        keccak256( // compute CREATE2 hash using 4 inputs.\\n                            abi.encodePacked( // pack all inputs to the hash together.\\n                                bytes1(0xff), // pass in the control character.\\n                                address(this), // pass in the address of this contract.\\n                                salt, // pass in the salt from above.\\n                                initCodeHash // pass in hash of contract creation code.\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n\\n            // determine if a contract is already deployed to the target address.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                exist := gt(extcodesize(target), 0)\\n            }\\n\\n            // exit the loop if no contract is deployed to the target address.\\n            if (!exist) {\\n                break;\\n            }\\n\\n            // otherwise, increment the nonce and derive a new salt.\\n            nonce++;\\n        }\\n    }\\n\\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\\n        // get the keccak256 hash of the init code for address derivation.\\n        bytes32 initCodeHash = keccak256(initCode);\\n\\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\\n\\n        target = address( // derive the target deployment address.\\n            uint160( // downcast to match the address type.\\n                uint256( // cast to uint to truncate upper digits.\\n                    keccak256( // compute CREATE2 hash using 4 inputs.\\n                        abi.encodePacked( // pack all inputs to the hash together.\\n                            bytes1(0xff), // pass in the control character.\\n                            address(this), // pass in the address of this contract.\\n                            salt, // pass in the salt from above.\\n                            initCodeHash // pass in hash of contract creation code.\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function creation(address addr, bytes memory initializationCalldata)\\n        private\\n        pure\\n        returns (bytes memory createCode)\\n    {\\n        createCode = initializationCalldata.length > 0\\n            ? abi.encodePacked(\\n                type(BeaconMakerWithCall).creationCode,\\n                abi.encode(address(addr), initializationCalldata)\\n            )\\n            : abi.encodePacked(type(BeaconMaker).creationCode, abi.encode(address(addr)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/MinimalProxyDeployer.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MinimalMaker.sol\\\";\\nimport \\\"./MinimalMakerWithCall.sol\\\";\\n\\n/**\\n * @title MinimalProxyDeployer\\n * @author yoonsung.eth\\n * @notice Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 \ub77c\uc774\ube0c\ub7ec\ub9ac\\n */\\nlibrary MinimalProxyDeployer {\\n    function deploy(address template, bytes memory initializationCalldata) internal returns (address result) {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        (bytes32 salt, ) = getSaltAndTarget(createCode);\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded_data := add(0x20, createCode) // load initialization code.\\n            let encoded_size := mload(createCode) // load the init code's length.\\n            result := create2(\\n                // call `CREATE2` w/ 4 arguments.\\n                0, // forward any supplied endowment.\\n                encoded_data, // pass in initialization code.\\n                encoded_size, // pass in init code's length.\\n                salt // pass in the salt value.\\n            )\\n\\n            // pass along failure message from failed contract deployment and revert.\\n            if iszero(extcodesize(result)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function deploy(\\n        string memory seed,\\n        address template,\\n        bytes memory initializationCalldata\\n    ) internal returns (address result) {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let encoded_data := add(0x20, createCode) // load initialization code.\\n            let encoded_size := mload(createCode) // load the init code's length.\\n            result := create2(\\n                // call `CREATE2` w/ 4 arguments.\\n                0, // forward any supplied endowment.\\n                encoded_data, // pass in initialization code.\\n                encoded_size, // pass in init code's length.\\n                salt // pass in the salt value.\\n            )\\n\\n            // pass along failure message from failed contract deployment and revert.\\n            if iszero(extcodesize(result)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function calculateAddress(address template, bytes memory initializationCalldata)\\n        internal\\n        view\\n        returns (address addr)\\n    {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        (, addr) = getSaltAndTarget(createCode);\\n    }\\n\\n    function calculateAddress(\\n        string memory seed,\\n        address template,\\n        bytes memory initializationCalldata\\n    ) internal view returns (address addr) {\\n        bytes memory createCode = creation(template, initializationCalldata);\\n\\n        addr = getTargetFromSeed(createCode, seed);\\n    }\\n\\n    function isMinimal(address templateAddr, address target) internal view returns (bool result) {\\n        bytes20 templateAddrBytes = bytes20(templateAddr);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0xa), templateAddrBytes)\\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n\\n            let other := add(clone, 0x40)\\n            extcodecopy(target, other, 0, 0x2d)\\n            result := eq(mload(clone), mload(other))\\n        }\\n    }\\n\\n    function getSaltAndTarget(bytes memory initCode) internal view returns (bytes32 salt, address target) {\\n        // get the keccak256 hash of the init code for address derivation.\\n        bytes32 initCodeHash = keccak256(initCode);\\n\\n        // set the initial nonce to be provided when constructing the salt.\\n        uint256 nonce = 0;\\n\\n        // declare variable for code size of derived address.\\n        bool exist;\\n\\n        while (true) {\\n            // derive `CREATE2` salt using `msg.sender` and nonce.\\n            salt = keccak256(abi.encodePacked(msg.sender, nonce));\\n\\n            target = address( // derive the target deployment address.\\n                uint160( // downcast to match the address type.\\n                    uint256( // cast to uint to truncate upper digits.\\n                        keccak256( // compute CREATE2 hash using 4 inputs.\\n                            abi.encodePacked( // pack all inputs to the hash together.\\n                                bytes1(0xff), // pass in the control character.\\n                                address(this), // pass in the address of this contract.\\n                                salt, // pass in the salt from above.\\n                                initCodeHash // pass in hash of contract creation code.\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n\\n            // determine if a contract is already deployed to the target address.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                exist := gt(extcodesize(target), 0)\\n            }\\n\\n            // exit the loop if no contract is deployed to the target address.\\n            if (!exist) {\\n                break;\\n            }\\n\\n            // otherwise, increment the nonce and derive a new salt.\\n            nonce++;\\n        }\\n    }\\n\\n    function getTargetFromSeed(bytes memory initCode, string memory seed) internal view returns (address target) {\\n        // get the keccak256 hash of the init code for address derivation.\\n        bytes32 initCodeHash = keccak256(initCode);\\n\\n        bytes32 salt = keccak256(abi.encodePacked(msg.sender, seed));\\n\\n        target = address( // derive the target deployment address.\\n            uint160( // downcast to match the address type.\\n                uint256( // cast to uint to truncate upper digits.\\n                    keccak256( // compute CREATE2 hash using 4 inputs.\\n                        abi.encodePacked( // pack all inputs to the hash together.\\n                            bytes1(0xff), // pass in the control character.\\n                            address(this), // pass in the address of this contract.\\n                            salt, // pass in the salt from above.\\n                            initCodeHash // pass in hash of contract creation code.\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    function creation(address addr, bytes memory initializationCalldata)\\n        private\\n        pure\\n        returns (bytes memory createCode)\\n    {\\n        createCode = initializationCalldata.length > 0\\n            ? abi.encodePacked(\\n                type(MinimalMakerWithCall).creationCode,\\n                abi.encode(address(addr), initializationCalldata)\\n            )\\n            : abi.encodePacked(type(MinimalMaker).creationCode, abi.encode(address(addr)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/Multicall.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IMulticall.sol\\\";\\n\\n/**\\n * @title Multicall\\n * @author yoonsung.eth\\n * @notice \ucee8\ud2b8\ub799\ud2b8\uac00 \uac00\uc9c0\uace0 \uc788\ub294 \ud2b8\ub79c\uc7ad\uc158\uc744 \uc21c\uc11c\ub300\ub85c \uc2e4\ud589\uc2dc\ud0ac \uc218 \uc788\uc74c.\\n */\\nabstract contract Multicall is IMulticall {\\n    function multicall(bytes[] calldata callData) external override returns (bytes[] memory returnData) {\\n        returnData = new bytes[](callData.length);\\n        for (uint256 i = 0; i < callData.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(callData[i]);\\n            // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n            if (!success) {\\n                // revert called without a message\\n                if (result.length < 68) revert();\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            returnData[i] = result;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IFactory.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IFactory {\\n    struct TemplateInfo {\\n        address template;\\n        address btemplate;\\n    }\\n\\n    event Deployed(address deployed, address owner);\\n    event NewTemplate(bytes32 indexed key, address template, address beacon);\\n    event UpdatedTemplate(bytes32 indexed key, address template);\\n    event DeletedTemplate(bytes32 indexed key);\\n    event FeeChanged(uint256 prevFee, uint256 fee);\\n    event FeeToChanged(address prevFeeTo, address feeTo);\\n\\n    function deploy(\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed);\\n\\n    function deployWithSeed(\\n        string memory seed,\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed);\\n\\n    function compute(\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData\\n    ) external view returns (address deployable);\\n\\n    function computeWithSeed(\\n        string memory seed,\\n        bool isBeacon,\\n        bytes32 templateId,\\n        bytes memory initializationCallData\\n    ) external view returns (address deployable);\\n\\n    function clone(\\n        address templateAddr,\\n        bytes memory initializationCallData,\\n        bytes[] memory calls\\n    ) external payable returns (address deployed);\\n\\n    function computeClone(address templateAddr, bytes memory initializationCallData)\\n        external\\n        view\\n        returns (address deployable);\\n\\n    function getPrice() external view returns (uint256 price);\\n\\n    function addTemplate(address templateAddr) external;\\n\\n    function updateTemplate(bytes32 key, address templateAddr) external;\\n\\n    function removeTemplate(bytes32 key) external;\\n\\n    function changeFee(uint256 newFee) external;\\n\\n    function changeFeeTo(address payable newFeeTo) external;\\n\\n    function collect(address tokenAddr) external;\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/interfaces/IERC173.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC-173 Contract Ownership Standard\\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-173.md\\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n */\\ninterface IERC173 {\\n    /**\\n     * @dev This emits when ownership of a contract changes.\\n     */\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @notice Get the address of the owner\\n     * @return The address of the owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @notice Set the address of the new owner of the contract\\n     * @param newOwner The address of the new owner of the contract\\n     */\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/BeaconMaker.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title BeaconMaker\\n * @author yoonsung.eth\\n * @notice Beacon Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 Maker Dummy\\n * @dev template\uc5d0\ub294 \ub2e8 \ud55c\ubc88\ub9cc \ud638\ucd9c \uac00\ub2a5\ud55c initialize \ud568\uc218\uac00 \ud544\uc694\ud558\uba70, \uc774\ub294 \ud544\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ub418\uc5b4 \uacfc\uc815\uc774 \uc0dd\ub7b5\ub418\uc5b4\uc57c \ud568.\\n */\\ncontract BeaconMaker {\\n    /**\\n     * @param beacon call \ud588\uc744 \uacbd\uc6b0, \uc8fc\uc18c\uac00 \ubc18\ud658\ub418\uc5b4\uc57c \ud558\ub294 \ucee8\ud2b8\ub799\ud2b8\\n     */\\n    constructor(address beacon) payable {\\n        // Beacon Address\\n        bytes20 targetBytes = bytes20(beacon);\\n        // place Beacon Proxy code in memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0x6), targetBytes)\\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/BeaconMakerWithCall.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title BeaconMakerWithCall\\n * @author yoonsung.eth\\n * @notice Beacon Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 Maker Dummy\\n * @dev template\uc5d0\ub294 \ub2e8 \ud55c\ubc88\ub9cc \ud638\ucd9c \uac00\ub2a5\ud55c initialize \ud568\uc218\uac00 \ud544\uc694\ud558\uba70, \uc774\ub294 \ud544\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ub418\uc5b4 \uacfc\uc815\uc774 \uc0dd\ub7b5\ub418\uc5b4\uc57c \ud568.\\n */\\ncontract BeaconMakerWithCall {\\n    /**\\n     * @param beacon call \ud588\uc744 \uacbd\uc6b0, \uc8fc\uc18c\uac00 \ubc18\ud658\ub418\uc5b4\uc57c \ud568\\n     * @param initializationCalldata template\ub85c \ubc30\ud3ec\ud560 \ub54c \ucd08\uae30\ud654 \ud560 \ud568\uc218\\n     */\\n    constructor(address beacon, bytes memory initializationCalldata) payable {\\n        (, bytes memory returnData) = beacon.staticcall(\\\"\\\");\\n        address template = abi.decode(returnData, (address));\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = template.delegatecall(initializationCalldata);\\n        if (!success) {\\n            // pass along failure message from delegatecall and revert.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Beacon Address\\n        bytes20 targetBytes = bytes20(beacon);\\n        // place Beacon Proxy code in memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x3d3d3d3d3d730000000000000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0x6), targetBytes)\\n            mstore(add(clone, 0x1a), 0x5afa3d82803e368260203750808036602082515af43d82803e903d91603a57fd)\\n            mstore(add(clone, 0x3a), 0x5bf3000000000000000000000000000000000000000000000000000000000000)\\n            // return Beacon Minimal Proxy code to write it to spawned contract runtime.\\n            return(add(0x00, clone), 0x3c) // Beacon Minimal Proxy runtime code, length\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/MinimalMaker.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title MinimalMaker\\n * @author yoonsung.eth\\n * @notice Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 Maker Dummy\\n * @dev template\uc5d0\ub294 \ub2e8 \ud55c\ubc88\ub9cc \ud638\ucd9c \uac00\ub2a5\ud55c initialize \ud568\uc218\uac00 \ud544\uc694\ud558\uba70, \uc774\ub294 \ud544\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ub418\uc5b4 \uacfc\uc815\uc774 \uc0dd\ub7b5\ub418\uc5b4\uc57c \ud568.\\n */\\ncontract MinimalMaker {\\n    constructor(address template) payable {\\n        // Template Address\\n        bytes20 targetBytes = bytes20(template);\\n        // place Minimal Proxy eip-1167 code in memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0xa), targetBytes)\\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            // return eip-1167 code to write it to spawned contract runtime.\\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/library/MinimalMakerWithCall.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title MinimalMakerWithCall\\n * @author yoonsung.eth\\n * @notice Minimal Proxy\ub97c \ubc30\ud3ec\ud558\ub294 \uae30\ub2a5\uc744 \uac00\uc9c4 Maker Dummy\\n * @dev template\uc5d0\ub294 \ub2e8 \ud55c\ubc88\ub9cc \ud638\ucd9c \uac00\ub2a5\ud55c initialize \ud568\uc218\uac00 \ud544\uc694\ud558\uba70, \uc774\ub294 \ud544\uc218\uc801\uc73c\ub85c \ud638\ucd9c\ub418\uc5b4 \uacfc\uc815\uc774 \uc0dd\ub7b5\ub418\uc5b4\uc57c \ud568.\\n */\\ncontract MinimalMakerWithCall {\\n    constructor(address template, bytes memory initializationCalldata) payable {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = template.delegatecall(initializationCalldata);\\n        if (!success) {\\n            // pass along failure message from delegatecall and revert.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        // Template Address\\n        bytes20 targetBytes = bytes20(template);\\n        // place Minimal Proxy eip-1167 code in memory.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let clone := mload(0x40)\\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\\n            mstore(add(clone, 0xa), targetBytes)\\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            // return eip-1167 code to write it to spawned contract runtime.\\n            return(add(0x00, clone), 0x2d) // eip-1167 runtime code, length\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@beandao/contracts/interfaces/IMulticall.sol\": {\r\n      \"content\": \"/**\\n * SPDX-License-Identifier: LGPL-3.0-or-later\\n */\\n\\npragma solidity ^0.8.0;\\n\\ninterface IMulticall {\\n    function multicall(bytes[] calldata callData) external returns (bytes[] memory returnData);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 42069,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"feeToAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"DeletedTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevFeeTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeTo\",\"type\":\"address\"}],\"name\":\"FeeToChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"NewTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"}],\"name\":\"UpdatedTemplate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"templateAddr\",\"type\":\"address\"}],\"name\":\"addTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newFeeTo\",\"type\":\"address\"}],\"name\":\"changeFeeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"templateAddr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"}],\"name\":\"clone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBeacon\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"}],\"name\":\"compute\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployable\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"templateAddr\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"}],\"name\":\"computeClone\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployable\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isBeacon\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"}],\"name\":\"computeWithSeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployable\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isBeacon\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"}],\"name\":\"deploy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"seed\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isBeacon\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"templateId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"initializationCallData\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"calls\",\"type\":\"bytes[]\"}],\"name\":\"deployWithSeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeTo\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"callData\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployed\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"recoverOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"}],\"name\":\"removeTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resignOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"templates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"btemplate\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"key\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"templateAddr\",\"type\":\"address\"}],\"name\":\"updateTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FactoryV1", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "42069", "ConstructorArguments": "000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000054b5e06c82f0d3d91377e5827bfb2381ef1cc2b7", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cf700d741ec17b81a9cd412a255e60e875e0ce5611be2b853e00ddb9c5f15ecf"}]}