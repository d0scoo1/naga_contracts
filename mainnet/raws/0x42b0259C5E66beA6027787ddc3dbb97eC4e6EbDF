{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n......@@@@@#%*;,..............*@\r\n......@@@@@@@@@#*:...........+@@\r\n......@@@@@@@@@@@@*,........;@@@\r\n......@@@@@@@@@@@@@%,......:#@@@\r\n......@@@@@@@@@@@@@@?.....,#@@@@\r\n......@@@@@@@@@@@@@@@,...,S@@@@@\r\n......@@@@@@@@@@@@@@@:...%@@@@@@\r\n......@@@@@@@@@@@@@@@,..?@@@@@@@\r\n......@@@@@@@@@@@@@@?..*@@@@@@@@\r\n......@@@@@@@@@@@@@%,.+@@@@@@@@@\r\n......@@@@@@@@@@@@*..;@@@@@@@@@@\r\n......@@@@@@@@@#*:..:@@@@@@@@@@#\r\n......@@@@#S%*;,....S@@@@@@@@@@#  \r\n\r\n..........................................................................................................................................\r\n88888888ba,....88...............88.......................88............db..............................88.................................\r\n88......`\"8b...\"\"...............\"\"....,d.................88...........d88b......................,d.....\"\"...............,d................\r\n88........`8b.........................88.................88..........d8'`8b.....................88......................88................\r\n88.........88..88...,adPPYb,d8..88..MM88MMM..,adPPYYba,..88.........d8'..`8b......8b,dPPYba,..MM88MMM..88..,adPPYba,..MM88MMM..,adPPYba,..\r\n88.........88..88..a8\"....`Y88..88....88.....\"\".....`Y8..88........d8YaaaaY8b.....88P'...\"Y8....88.....88..I8[....\"\"....88.....I8[....\"\"..\r\n88.........8P..88..8b.......88..88....88.....,adPPPPP88..88.......d8\"\"\"\"\"\"\"\"8b....88............88.....88...`\"Y8ba,.....88......`\"Y8ba,...\r\n88.......a8P...88..\"8a,...,d88..88....88,....88,....,88..88......d8'........`8b...88............88,....88..aa....]8I....88,....aa....]8I..\r\n88888888Y\"'....88...`\"YbbdP\"Y8..88....\"Y888..`\"8bbdP\"Y8..88.....d8'..........`8b..88............\"Y888..88..`\"YbbdP\"'....\"Y888..`\"YbbdP\"'..\r\n....................aa,....,88............................................................................................................\r\n.....................\"Y8bbdP\".............................................................................................................\r\n\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.12;\r\n\r\n/*********************************************\r\n *********************************************\r\n *  H e l p e r   l i b r a r i e s\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     * See openzeppelin's Address.sol for details\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n        return account.code.length > 0;\r\n    }\r\n}\r\n\r\n/*********************************************\r\n *********************************************\r\n *  H e l p e r   c o n t r a c t s\r\n */\r\n\r\ncontract ReentrancyGuard {\r\n    uint8 private constant _NOT_ENTERED = 1;\r\n    uint8 private constant _ENTERED = 2;\r\n    uint8 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Caller not owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Invalid address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/*********************************************\r\n *********************************************\r\n *  I n t e r f a c e s\r\n */\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC2981 {\r\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\r\n        external\r\n        view\r\n        returns (address receiver, uint256 royaltyAmount);\r\n}\r\n\r\ninterface IERC721Metadata {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index)\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\ninterface IERC721 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ncontract DigitalArtists is\r\n    IERC165,\r\n    IERC721,\r\n    IERC721Metadata,\r\n    IERC721Enumerable,\r\n    IERC2981,\r\n    ReentrancyGuard,\r\n    Ownable\r\n{\r\n    event Mint(\r\n        uint256 indexed collectionId_,\r\n        address indexed to_,\r\n        uint256 tokenId_\r\n    );\r\n\r\n    event Withdraw(\r\n        address indexed initiator_,\r\n        address indexed to_,\r\n        uint256 amount_\r\n    );\r\n\r\n    event CollectionArtistAddressUpdated(\r\n        uint256 indexed collectionId_,\r\n        address newAddr_,\r\n        address oldAddr_\r\n    );\r\n\r\n    event CollectionStateUpdated(\r\n        uint256 indexed collectionId_,\r\n        uint8 newState_,\r\n        uint8 oldSate_\r\n    );\r\n\r\n    event CollectionAuthorizationUpdated(\r\n        uint256 indexed collectionId_,\r\n        address indexed addr_,\r\n        bool state_\r\n    );\r\n\r\n    modifier onlyAuthorized(uint256 collectionId_) {\r\n        require(\r\n            _isCollectionAuthorized(collectionId_, _msgSender()),\r\n            \"Unauthorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    struct Artist {\r\n        string name;\r\n        string info;\r\n        uint32 collectionsCount;\r\n    }\r\n\r\n    struct Collection {\r\n        // Collection name\r\n        bytes32 name;\r\n        // Collection base URI\r\n        string baseUri;\r\n        // Artists address\r\n        address artistAddr;\r\n        // Royalties address - artistAddr is used if this one is not set\r\n        address royaltyAddr;\r\n        // Current token id\r\n        uint256 tokenId;\r\n        // Starting token number\r\n        uint256 tokenIdFrom;\r\n        // Public mint(state 2) price\r\n        uint256 mintPrice;\r\n        // Premint (state 1) price\r\n        uint256 premintPrice;\r\n        // Balance from the minting process\r\n        uint256 balance;\r\n        // Withdrawn value [0] is artist and [1] is platform\r\n        uint256[2] withdrawn;\r\n        // Collection max supply\r\n        uint32 maxSupply;\r\n        // Maximum number of NFTs that could be minted on the premint\r\n        uint32 premintMaxSupply;\r\n        // Royalty basis\r\n        uint16 royaltyBasis;\r\n        // Maximum number of NFTs that address could mint on the public sale\r\n        uint16 mintCap;\r\n        // Maximum number of NFTs that address could mint on the premint\r\n        uint16 premintCap;\r\n        // Maximum number of addresses that premint list could hold\r\n        uint16 premintListCap;\r\n        // Current number of addresses on the premint list\r\n        uint16 premintListCount;\r\n        // Withdraw percentages [0] is artist and [1] is platform\r\n        uint16[2] percentage;\r\n        // Flag indicating whether collection base URI is locked\r\n        uint8 baseUriLocked;\r\n        // campaign state - 0 (not active), 1 (premint), 2 (public mint)\r\n        uint8 state;\r\n        // Mapping for authorizing addresses to manage this collection\r\n        mapping(address => bool) authorized;\r\n        // Mapping from address to boolean flag indicating if this address is on the premint list\r\n        mapping(address => bool) premintList;\r\n        // Mapping from address to number representing minted NFTs on the public sale\r\n        mapping(address => uint32) minted;\r\n        // Mapping from address to number representing minted NFTs on the premint\r\n        mapping(address => uint32) preminted;\r\n    }\r\n\r\n    /*********************************************\r\n     *********************************************\r\n     *  P r i v a t e\r\n     *      m e m b e r s\r\n     *\r\n     */\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] private _allTokens;\r\n\r\n    // Contract name\r\n    string private _name;\r\n\r\n    // Contract token symbol\r\n    string private _symbol;\r\n\r\n    // Default base uri. It will be used if collection base uri is not set\r\n    string private _baseUri;\r\n\r\n    // Default artist percentage when organizing mints\r\n    uint16 private _percentArtist;\r\n\r\n    // Default platform percentage when organizing mints\r\n    uint16 private _percentPlatform;\r\n\r\n    // Flag indicating whether anyone could use createCollection or only whitelisted addresses and owner\r\n    uint8 private _isCreateCollectionPublic;\r\n\r\n    // Reference to the last collection ID\r\n    uint256 private _lastCollectionId;\r\n\r\n    // Mapping from collection ID to Collection\r\n    mapping(uint256 => Collection) private _collections;\r\n\r\n    // Mapping from artist address to Artist\r\n    mapping(address => Artist) private _artists;\r\n\r\n    // Mapping from token id to collection ID\r\n    mapping(uint256 => uint256) private _tokenIdToCollectionId;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) private _allTokensIndex;\r\n\r\n    // Mapping from token id to index of the owner tokens list\r\n    mapping(uint256 => uint256) private _ownedTokensIndex;\r\n\r\n    // Mapping for explicit token URIs\r\n    mapping(uint256 => string) private _tokenUri;\r\n\r\n    // Mapping from token id to owner address\r\n    mapping(uint256 => address) private _owners;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping(address => uint256) private _balances;\r\n\r\n    // Mapping from artist address to boolean flag indicating whether this address is trusted\r\n    mapping(address => bool) private _knownArtists;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\r\n\r\n    constructor() ReentrancyGuard() Ownable() {\r\n        _symbol = \"DA\";\r\n        _name = \"Digital Artists\";\r\n    }\r\n\r\n    /*********************************************\r\n     *********************************************\r\n     *  P u b l i c\r\n     *      m e t h o d s\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Returns last collection ID\r\n     */\r\n    function lastCollectionId() public view returns (uint256) {\r\n        return _lastCollectionId;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection ID from given token ID\r\n     */\r\n    function tokenIdToCollectionId(uint256 tokenId_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _tokenIdToCollectionId[tokenId_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a token ID owned by `owner` at a given `index` of its token list.\r\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\r\n     * @param owner_ owner address\r\n     * @param idx_ index of token\r\n     */\r\n    function tokenOfOwnerByIndex(address owner_, uint256 idx_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(idx_ < balanceOf(owner_), \"Index out of bounds\");\r\n        return _ownedTokens[owner_][idx_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of tokens stored by the contract.\r\n     * @dev See {IERC721Enumerable-totalSupply}.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _allTokens.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of tokens in collection.\r\n     * @param collectionId_ checked collection ID.\r\n     */\r\n    function totalSupplyByCollectionId(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        unchecked {\r\n            return\r\n                _collections[collectionId_].tokenId -\r\n                _collections[collectionId_].tokenIdFrom;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a token ID at a given `index` of all the tokens stored by the contract.\r\n     * @dev See {IERC721Enumerable-tokenByIndex}.\r\n     * @param idx_ desired index\r\n     */\r\n    function tokenByIndex(uint256 idx_) public view returns (uint256) {\r\n        require(idx_ < totalSupply(), \"Index out of bounds\");\r\n        return _allTokens[idx_];\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns address and royatly amount from given token id and price.\r\n     * Different collections could have different royatlies.\r\n     * @param tokenId_ token id\r\n     * @param price_ price against royatly is calculated\r\n     */\r\n    function royaltyInfo(uint256 tokenId_, uint256 price_)\r\n        public\r\n        view\r\n        returns (address, uint256)\r\n    {\r\n        require(_exists(tokenId_), \"Nonexistent token\");\r\n        uint256 collectionId = _tokenIdToCollectionId[tokenId_];\r\n\r\n        unchecked {\r\n            return (\r\n                _collections[collectionId].royaltyAddr == address(0)\r\n                    ? _collections[collectionId].artistAddr\r\n                    : _collections[collectionId].royaltyAddr,\r\n                (price_ * _collections[collectionId].royaltyBasis) / 10000\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns token uri from given token id.\r\n     * @param tokenId_ token id\r\n     */\r\n    function tokenURI(uint256 tokenId_) public view returns (string memory) {\r\n        require(_exists(tokenId_), \"Nonexistent token\");\r\n\r\n        if (bytes(_tokenUri[tokenId_]).length > 0) {\r\n            // Explicit token uri\r\n            return _tokenUri[tokenId_];\r\n        }\r\n\r\n        string memory baseUri = bytes(\r\n            _collections[_tokenIdToCollectionId[tokenId_]].baseUri\r\n        ).length > 0\r\n            ? _collections[_tokenIdToCollectionId[tokenId_]].baseUri\r\n            : _baseUri;\r\n\r\n        return string(abi.encodePacked(baseUri, Strings.toString(tokenId_)));\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection's artist or contract owner to explicitly set URI for token.\r\n     * @param tokenId_ updated token id\r\n     * @param uri_ explicit token uri\r\n     */\r\n    function updateTokenUri(uint256 tokenId_, string memory uri_) public {\r\n        require(\r\n            _isCollectionAuthorized(\r\n                _tokenIdToCollectionId[tokenId_],\r\n                _msgSender()\r\n            ),\r\n            \"Unauthorized\"\r\n        );\r\n        _tokenUri[tokenId_] = uri_;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the count of the owned tokens by address.\r\n     * @param owner_ checked addess\r\n     */\r\n    function balanceOf(address owner_) public view returns (uint256) {\r\n        return _balances[owner_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of token id owner or zero address if non-existing token id is specified.\r\n     * @param tokenId_ checked token id\r\n     */\r\n    function ownerOf(uint256 tokenId_) public view returns (address) {\r\n        return _owners[tokenId_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean value indicating if the checked interface is supported.\r\n     * @param interfaceId_ checked interface id\r\n     */\r\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\r\n        return\r\n            interfaceId_ == type(IERC165).interfaceId ||\r\n            interfaceId_ == type(IERC2981).interfaceId ||\r\n            interfaceId_ == type(IERC721).interfaceId ||\r\n            interfaceId_ == type(IERC721Metadata).interfaceId ||\r\n            interfaceId_ == type(IERC721Enumerable).interfaceId;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to update default percentages in case of public mint is organized.\r\n     * @param percentArtist_ artist percentage\r\n     * @param percentPlatform_ platform percentage\r\n     */\r\n    function updateDefaultPercentages(\r\n        uint16 percentArtist_,\r\n        uint16 percentPlatform_\r\n    ) public onlyOwner {\r\n        unchecked {\r\n            require(\r\n                percentArtist_ + percentPlatform_ == 10000,\r\n                \"Invalid percentage\"\r\n            );\r\n        }\r\n\r\n        _percentArtist = percentArtist_;\r\n        _percentPlatform = percentPlatform_;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to specify explicit split percentage for collection if public mint is organized.\r\n     * @param collectionId_ collection ID\r\n     * @param percentArtist_ artist percentage\r\n     * @param percentPlatform_ platform percentage\r\n     */\r\n    function updateCollectionPercentages(\r\n        uint256 collectionId_,\r\n        uint16 percentArtist_,\r\n        uint16 percentPlatform_\r\n    ) public onlyOwner {\r\n        if (percentArtist_ == 1) {\r\n            // Artist percetage is explicitly set to 0, 1 means 0 percentage, see withdraw function\r\n            _collections[collectionId_].percentage[0] = 1;\r\n            _collections[collectionId_].percentage[1] = 10000;\r\n        } else if (percentPlatform_ == 1) {\r\n            // Platform percetage is explicitly set to 0, 1 means 0 percentage, see withdraw function\r\n            _collections[collectionId_].percentage[0] = 10000;\r\n            _collections[collectionId_].percentage[1] = 1;\r\n        } else {\r\n            unchecked {\r\n                require(\r\n                    percentArtist_ + percentPlatform_ == 10000,\r\n                    \"Invalid percentage\"\r\n                );\r\n            }\r\n            _collections[collectionId_].percentage[0] = percentArtist_;\r\n            _collections[collectionId_].percentage[1] = percentPlatform_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns default split percentages - artists and platform respectively.\r\n     */\r\n    function defaultPercentages() public view returns (uint16, uint16) {\r\n        return (_percentArtist, _percentPlatform);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to specify default base URI.\r\n     * @param uri_ new base URI\r\n     */\r\n    function setBaseUri(string memory uri_) public onlyOwner {\r\n        _baseUri = uri_;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the default base URI\r\n     */\r\n    function defaultBaseUri() public view returns (string memory) {\r\n        return _baseUri;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to change createCollection access level.\r\n     * @param level_ access level - public or known artists only\r\n     */\r\n    function updateCreateCollectionAccess(uint8 level_) public onlyOwner {\r\n        // Everything greater than 0 will allow public access to createCollection\r\n        // otherwise onlyOwner and _knownArtists have access\r\n        _isCreateCollectionPublic = level_;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a boolean flag indicating if createColletion function is publicly accessible.\r\n     */\r\n    function isCreateCollectionPublic() public view returns (bool) {\r\n        return _isCreateCollectionPublic > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to add addresses to the known artists white list.\r\n     * @param addresses_ array of addresses\r\n     */\r\n    function addKnownArtists(address[] memory addresses_) public onlyOwner {\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            _knownArtists[addresses_[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to remove addresses from the known artists white list.\r\n     * @param addresses_ array of addresses\r\n     */\r\n    function removeKnownArtists(address[] memory addresses_) public onlyOwner {\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            _knownArtists[addresses_[i]] = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating whether address is a known artist.\r\n     * @param addr_ checked address\r\n     */\r\n    function isKnownArtist(address addr_) public view returns (bool) {\r\n        return _knownArtists[addr_];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set base URI for specific collection.\r\n     * @param collectionId_ collection ID\r\n     * @param baseUri_ base URI\r\n     */\r\n    function setCollectionBaseUri(uint256 collectionId_, string memory baseUri_)\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(\r\n            _collections[collectionId_].baseUriLocked == 0,\r\n            \"baseURI locked\"\r\n        );\r\n        _collections[collectionId_].baseUri = baseUri_;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to lock base URI from being changed. Once locked it cannot be unlocked.\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function lockCollectionBaseUri(uint256 collectionId_) public onlyOwner {\r\n        _collections[collectionId_].baseUriLocked = 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection's base URI, if there is any.\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionBaseUri(uint256 collectionId_)\r\n        public\r\n        view\r\n        virtual\r\n        returns (string memory)\r\n    {\r\n        return _collections[collectionId_].baseUri;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating whether collection's base URI is locked\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function isCollectionBaseUriLocked(uint256 collectionId_)\r\n        public\r\n        view\r\n        virtual\r\n        returns (bool)\r\n    {\r\n        return _collections[collectionId_].baseUriLocked > 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to update max supply and premint max supply\r\n     * @param collectionId_ collection ID\r\n     * @param shouldUpdateMaxSupply_ flag indicating whether max supply value should be updated\r\n     * @param maxSupply_ new max supply\r\n     * @param shouldUpdatePremintMaxSupply_ flag indicating whether premint max supply value should be updated\r\n     * @param premintMaxSupply_ new premint max supply\r\n     */\r\n    function updateCollectionSupplies(\r\n        uint256 collectionId_,\r\n        uint8 shouldUpdateMaxSupply_,\r\n        uint32 maxSupply_,\r\n        uint8 shouldUpdatePremintMaxSupply_,\r\n        uint32 premintMaxSupply_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        if (shouldUpdateMaxSupply_ != 0) {\r\n            unchecked {\r\n                require(\r\n                    totalSupplyByCollectionId(collectionId_) <= maxSupply_ &&\r\n                    _collections[collectionId_].maxSupply + 10000 > maxSupply_,\r\n                    \"Invalid max supply\"\r\n                );\r\n            }\r\n\r\n            _collections[collectionId_].maxSupply = maxSupply_;\r\n        }\r\n\r\n        if (shouldUpdatePremintMaxSupply_ != 0) {\r\n            unchecked {\r\n                require(\r\n                    totalSupplyByCollectionId(collectionId_) <= premintMaxSupply_ &&\r\n                    _collections[collectionId_].maxSupply + 10000 > premintMaxSupply_,\r\n                    \"Invalid premint max supply\"\r\n                );\r\n            }\r\n            _collections[collectionId_].premintMaxSupply = premintMaxSupply_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection supplies - max supply, premint max supply and current total supply\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionSupplies(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (\r\n            uint32,\r\n            uint32,\r\n            uint256\r\n        )\r\n    {\r\n        return (\r\n            _collections[collectionId_].maxSupply,\r\n            _collections[collectionId_].premintMaxSupply,\r\n            totalSupplyByCollectionId(collectionId_)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to change state\r\n     * @param collectionId_ collection ID\r\n     * @param state_ state - 1(premint), 2(public mint), everything else is considered not active\r\n     */\r\n    function updateCollectionState(uint256 collectionId_, uint8 state_)\r\n        public\r\n        onlyAuthorized(collectionId_)\r\n    {\r\n        uint8 oldState = _collections[collectionId_].state;\r\n        _collections[collectionId_].state = state_;\r\n        emit CollectionStateUpdated(collectionId_, state_, oldState);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection state - 1(premint), 2(public mint), everything else is considered not active\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionState(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        return _collections[collectionId_].state;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns how many NFTs give address minted on premint and public mint for specific collection\r\n     * @param collectionId_ collection ID\r\n     * @param addr_ checked address\r\n     */\r\n    function collectionAddressMintedStats(uint256 collectionId_, address addr_)\r\n        public\r\n        view\r\n        returns (uint32, uint32)\r\n    {\r\n        return (\r\n            _collections[collectionId_].minted[addr_],\r\n            _collections[collectionId_].preminted[addr_]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns generated balance from mint campaign of collection\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionBalance(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _collections[collectionId_].balance;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating if address is collection authorized\r\n     * @param collectionId_ collection ID\r\n     * @param addr_ checked address\r\n     */\r\n    function isCollectionAuthorized(uint256 collectionId_, address addr_)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _collections[collectionId_].authorized[addr_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection bounds - starting token id, last token id, current token id\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionBounds(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        unchecked {\r\n            return (\r\n                _collections[collectionId_].tokenIdFrom + 1,\r\n                _collections[collectionId_].tokenIdFrom + _collections[collectionId_].maxSupply,\r\n                _collections[collectionId_].tokenId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns info about collection - collection name, artist name, base URI, artist address, max supply\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionInfo(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (\r\n            string memory,\r\n            string memory,\r\n            string memory,\r\n            address,\r\n            uint32\r\n        )\r\n    {\r\n        return (\r\n            string(abi.encodePacked(_collections[collectionId_].name)),\r\n            string(abi.encodePacked(_artists[_collections[collectionId_].artistAddr].name)),\r\n            string(abi.encodePacked(_collections[collectionId_].baseUri)),\r\n            _collections[collectionId_].artistAddr,\r\n            _collections[collectionId_].maxSupply\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to retrive split payments information\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionPaymentsInfo(uint256 collectionId_)\r\n        public\r\n        view\r\n        onlyAuthorized(collectionId_)\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint16,\r\n            uint16\r\n        )\r\n    {\r\n        return (\r\n            _collections[collectionId_].withdrawn[0],\r\n            _collections[collectionId_].withdrawn[1],\r\n            _collections[collectionId_].percentage[0],\r\n            _collections[collectionId_].percentage[1]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner or known artists to create new collectins on this contract\r\n     * @param artistAddr_ collection artists address (required)\r\n     * @param maxSupply_ collection max supply (required)\r\n     * @param premintMaxSupply_ collection premint max supply (optional)\r\n     */\r\n    function createCollection(\r\n        address artistAddr_,\r\n        uint32 maxSupply_,\r\n        uint32 premintMaxSupply_\r\n    ) public {\r\n        _nonZeroAddress(artistAddr_);\r\n        require(maxSupply_ > 0 && maxSupply_ <= 5000000, \"Invalid supply\");\r\n\r\n        if (_isCreateCollectionPublic == 0) {\r\n            // Leave an option to publicly allow this operation\r\n            require(\r\n                _msgSender() == owner() || _knownArtists[_msgSender()],\r\n                \"Unauthorized\"\r\n            );\r\n        }\r\n\r\n        Collection storage c = _collections[++_lastCollectionId];\r\n        c.artistAddr = artistAddr_;\r\n        c.maxSupply = maxSupply_;\r\n\r\n        if (premintMaxSupply_ > 0) {\r\n            _collections[_lastCollectionId].premintMaxSupply = premintMaxSupply_;\r\n        }\r\n\r\n        uint256 prevIdx;\r\n        unchecked {\r\n            prevIdx = _lastCollectionId - 1;\r\n            _artists[artistAddr_].collectionsCount++;\r\n        }\r\n\r\n        // Every new collection's tokenId will start from the previous end + 10000(gap)\r\n        c.tokenId = _collections[prevIdx].tokenIdFrom + _collections[prevIdx].maxSupply + 10000;\r\n        c.tokenIdFrom = c.tokenId;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating whether collection exists\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionExists(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _collections[collectionId_].artistAddr != address(0);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to toggle address collection authorization state\r\n     * @param collectionId_ collection ID\r\n     * @param addr_ address to toggle authorization state for\r\n     * @param state_ authorization state - true or false\r\n     */\r\n    function toggleCollectionAuthorization(\r\n        uint256 collectionId_,\r\n        address addr_,\r\n        bool state_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        _nonZeroAddress(addr_);\r\n        _collections[collectionId_].authorized[addr_] = state_;\r\n        emit CollectionAuthorizationUpdated(collectionId_, addr_, state_);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to set royalty for specific collection\r\n     * @param collectionId_ collection ID\r\n     * @param royaltyAddr_ new royalty address\r\n     * @param royaltyBasis_ new royalty basis\r\n     */\r\n    function updateCollectionRoyalty(\r\n        uint256 collectionId_,\r\n        address royaltyAddr_,\r\n        uint16 royaltyBasis_\r\n    ) public onlyOwner {\r\n        require(royaltyBasis_ <= 5000, \"Maximum 50% royalty\");\r\n        _collections[collectionId_].royaltyAddr = royaltyAddr_;\r\n        _collections[collectionId_].royaltyBasis = royaltyBasis_;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns royalty information about collection\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionRoyaltyInfo(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (address, uint16)\r\n    {\r\n        return (\r\n            _collections[collectionId_].royaltyAddr == address(0)\r\n                ? _collections[collectionId_].artistAddr\r\n                : _collections[collectionId_].royaltyAddr,\r\n            _collections[collectionId_].royaltyBasis\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows artist or contract owner to update on-chain info about artist by address\r\n     * @param addr_ artist address\r\n     * @param name_ new artist name\r\n     * @param info_ new artist info - free text\r\n     */\r\n    function updateArtist(\r\n        address addr_,\r\n        string memory name_,\r\n        string memory info_\r\n    ) public {\r\n        require(\r\n            _msgSender() == owner() || _msgSender() == addr_,\r\n            \"Unauthorized\"\r\n        );\r\n\r\n        if (bytes(name_).length > 0) {\r\n            _artists[addr_].name = name_;\r\n        }\r\n\r\n        if (bytes(info_).length > 0) {\r\n            _artists[addr_].info = info_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to update on-chain collection name\r\n     * @param collectionId_ collection ID\r\n     * @param collectionName_ collection name\r\n     */\r\n    function updateCollectionName(\r\n        uint256 collectionId_,\r\n        string memory collectionName_\r\n    ) public onlyOwner {\r\n        _collections[collectionId_].name = bytes32(bytes(collectionName_));\r\n    }\r\n\r\n    /**\r\n     * @notice Allows contract owner to update collection's artist address\r\n     * @param collectionId_ collection ID\r\n     * @param artistAddr_ new artist address\r\n     */\r\n    function updateCollectionArtistAddr(\r\n        uint256 collectionId_,\r\n        address artistAddr_\r\n    ) public onlyOwner {\r\n        _nonZeroAddress(artistAddr_);\r\n        address oldAddress = _collections[collectionId_].artistAddr;\r\n        _collections[collectionId_].artistAddr = artistAddr_;\r\n        emit CollectionArtistAddressUpdated(\r\n            collectionId_,\r\n            artistAddr_,\r\n            oldAddress\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns artist address for collection\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionArtistAddr(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (address)\r\n    {\r\n        return _collections[collectionId_].artistAddr;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to add addresses to premint list\r\n     * @param collectionId_ collection ID\r\n     * @param addresses_ array of addresses\r\n     */\r\n    function addToCollectionPremintList(\r\n        uint256 collectionId_,\r\n        address[] memory addresses_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        Collection storage c = _collections[collectionId_];\r\n\r\n        require(\r\n            c.premintListCount + addresses_.length <= c.premintListCap,\r\n            \"Presale list overflow\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            if (!c.premintList[addresses_[i]]) {\r\n                c.premintList[addresses_[i]] = true;\r\n                unchecked {\r\n                    c.premintListCount++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to remove addresses from premint list\r\n     * @param collectionId_ collection ID\r\n     * @param addresses_ array of addresses\r\n     */\r\n    function removeFromCollectionPremintList(\r\n        uint256 collectionId_,\r\n        address[] memory addresses_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        Collection storage c = _collections[collectionId_];\r\n\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            if (c.premintList[addresses_[i]]) {\r\n                c.premintList[addresses_[i]] = false;\r\n                unchecked {\r\n                    c.premintListCount--;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating if address is on the collection's premint list\r\n     * @param collectionId_ collection ID\r\n     * @param addr_ checked address\r\n     */\r\n    function isOnCollectionPremintList(uint256 collectionId_, address addr_)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _collections[collectionId_].premintList[addr_];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection's premint list capacity and current count\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionPremintListDetails(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint16, uint16)\r\n    {\r\n        return (\r\n            _collections[collectionId_].premintListCap,\r\n            _collections[collectionId_].premintListCount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to update premint and mint prices for collection\r\n     * @param collectionId_ collection ID\r\n     * @param shouldUpdateMintPrice_ flag indicating whether mint price should be updated\r\n     * @param mintPrice_ mint price to be set if shouldUpdateMintPrice_ > 0\r\n     * @param shouldUpdatepremintPrice_ flag indicating whether premint price should be updated\r\n     * @param premintPrice_ premint price to be set if shouldUpdatepremintPrice_ > 0\r\n     */\r\n    function updateCollectionMintPrices(\r\n        uint256 collectionId_,\r\n        uint8 shouldUpdateMintPrice_,\r\n        uint256 mintPrice_,\r\n        uint8 shouldUpdatepremintPrice_,\r\n        uint256 premintPrice_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        // using parameter which determines if value should be updated\r\n        // proceed with update if shouldUpdate..._ paramters != 0\r\n\r\n        if (shouldUpdateMintPrice_ != 0) {\r\n            _collections[collectionId_].mintPrice = mintPrice_;\r\n        }\r\n\r\n        if (shouldUpdatepremintPrice_ != 0) {\r\n            _collections[collectionId_].premintPrice = premintPrice_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection's mint and premint prices\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionMintPrices(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint256, uint256)\r\n    {\r\n        return (\r\n            _collections[collectionId_].mintPrice,\r\n            _collections[collectionId_].premintPrice\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to update collection capacities - mint, premint, premint list\r\n     * @param collectionId_ collection ID\r\n     * @param shouldUpdateMintCap_ flag if mint capacity is updated\r\n     * @param mintCap_ mint capacity to set\r\n     * @param shouldUpdatePremintCap_ flag if premint capacity is updated\r\n     * @param premintCap_ premint capacity to set\r\n     * @param shouldUpdatePremintListCap_ flag if premint list capacity is updated\r\n     * @param premintListCap_ premint list capacity to set\r\n     */\r\n    function updateCollectionCaps(\r\n        uint256 collectionId_,\r\n        uint8 shouldUpdateMintCap_,\r\n        uint16 mintCap_,\r\n        uint8 shouldUpdatePremintCap_,\r\n        uint16 premintCap_,\r\n        uint8 shouldUpdatePremintListCap_,\r\n        uint16 premintListCap_\r\n    ) public onlyAuthorized(collectionId_) {\r\n        // using parameter which determines if value should be updated\r\n        // proceed with update if shouldUpdate..._ paramters != 0\r\n\r\n        if (shouldUpdateMintCap_ != 0) {\r\n            _collections[collectionId_].mintCap = mintCap_;\r\n        }\r\n\r\n        if (shouldUpdatePremintCap_ != 0) {\r\n            _collections[collectionId_].premintCap = premintCap_;\r\n        }\r\n\r\n        if (shouldUpdatePremintListCap_ != 0) {\r\n            _collections[collectionId_].premintListCap = premintListCap_;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns collection's mint and premint capacities\r\n     * @param collectionId_ collection ID\r\n     */\r\n    function collectionMintCaps(uint256 collectionId_)\r\n        public\r\n        view\r\n        returns (uint16, uint16)\r\n    {\r\n        return (\r\n            _collections[collectionId_].mintCap,\r\n            _collections[collectionId_].premintCap\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Mint function - will mint to message sender\r\n     * @param collectionId_ collection ID\r\n     * @param amount_ minted NFTs count\r\n     */\r\n    function mint(uint256 collectionId_, uint16 amount_) public payable {\r\n        mintTo(collectionId_, amount_, _msgSender());\r\n    }\r\n\r\n    /**\r\n     * @notice Mint function - will mint to receiver_\r\n     * @param collectionId_ collection ID\r\n     * @param amount_ minted NFTs count\r\n     * @param receiver_ receiver of the minted NFTs\r\n     */\r\n    function mintTo(\r\n        uint256 collectionId_,\r\n        uint16 amount_,\r\n        address receiver_\r\n    ) public payable nonReentrant {\r\n        _nonZeroAddress(receiver_);\r\n        require(collectionExists(collectionId_), \"Nonexistent collection\");\r\n\r\n        Collection storage c = _collections[collectionId_];\r\n\r\n        require(\r\n            totalSupplyByCollectionId(collectionId_) < c.maxSupply,\r\n            \"Mint completed\"\r\n        );\r\n        require(amount_ > 0, \"Invalid mint amount\");\r\n\r\n        if (c.state == 1) {\r\n            require(c.premintList[receiver_], \"Not on whitelist\");\r\n\r\n            uint32 minted = c.preminted[receiver_];\r\n            unchecked {\r\n                c.preminted[receiver_] += amount_;\r\n            }\r\n\r\n            _mint(\r\n                collectionId_,\r\n                c.premintPrice,\r\n                receiver_,\r\n                amount_,\r\n                c.premintCap,\r\n                c.premintMaxSupply,\r\n                minted\r\n            );\r\n        } else if (c.state == 2) {\r\n            uint32 minted = c.minted[receiver_];\r\n            unchecked {\r\n                c.minted[receiver_] += amount_;\r\n            }\r\n            _mint(\r\n                collectionId_,\r\n                c.mintPrice,\r\n                receiver_,\r\n                amount_,\r\n                c.mintCap,\r\n                c.maxSupply,\r\n                minted\r\n            );\r\n        } else {\r\n            revert(\"Mint not active\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint function - allows collection authorized or contract owner to mint\r\n     * @param collectionId_ collection ID\r\n     * @param amount_ minted NFTs count\r\n     * @param receiver_ receiver of the minted NFTs\r\n     */\r\n    function mintInternal(\r\n        uint256 collectionId_,\r\n        uint16 amount_,\r\n        address receiver_\r\n    ) public onlyAuthorized(collectionId_) nonReentrant {\r\n        _nonZeroAddress(receiver_);\r\n\r\n        Collection storage c = _collections[collectionId_];\r\n\r\n        require(\r\n            amount_ + totalSupplyByCollectionId(collectionId_) <= c.maxSupply,\r\n            \"Supply overflow\"\r\n        );\r\n\r\n        for (uint16 i = 0; i < amount_; i++) {\r\n            unchecked {\r\n                c.tokenId += 1;\r\n            }\r\n\r\n            require(!_exists(c.tokenId), \"Token already minted\");\r\n\r\n            _beforeTokenTransfer(address(0), receiver_, c.tokenId);\r\n\r\n            _tokenIdToCollectionId[c.tokenId] = collectionId_;\r\n            unchecked {\r\n                _balances[receiver_] += 1;\r\n            }\r\n            _owners[c.tokenId] = receiver_;\r\n\r\n            emit Mint(collectionId_, receiver_, c.tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer token from address to another\r\n     * @param from_ current owner\r\n     * @param to_ new owner address\r\n     * @param tokenId_ desired token ID\r\n     */\r\n    function transferFrom(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_\r\n    ) public {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId_),\r\n            \"Not owner nor approved\"\r\n        );\r\n\r\n        _transfer(from_, to_, tokenId_);\r\n    }\r\n\r\n    /**\r\n     * @notice Safe transfer token from address to another. It is going to verify transfer using _checkOnERC721Received\r\n     * @param from_ current owner\r\n     * @param to_ new owner address\r\n     * @param tokenId_ desired token ID\r\n     */\r\n    function safeTransferFrom(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_\r\n    ) public {\r\n        safeTransferFrom(from_, to_, tokenId_, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Safe transfer token from address to another. It is going to verify transfer using _checkOnERC721Received\r\n     * @param from_ current owner\r\n     * @param to_ new owner address\r\n     * @param tokenId_ desired token ID\r\n     * @param data_ passed data in case receiver is contract\r\n     */\r\n    function safeTransferFrom(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_,\r\n        bytes memory data_\r\n    ) public {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId_),\r\n            \"Not owner nor approved\"\r\n        );\r\n        _transfer(from_, to_, tokenId_);\r\n        require(\r\n            _checkOnERC721Received(from_, to_, tokenId_, data_),\r\n            \"Non ERC721Receiver implementer\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Allows collection authorized or contract owner to withdraw funds generated from mint campaign\r\n     * @param collectionId_ collection ID\r\n     * @param addr_ withdraw address\r\n     */\r\n    function withdraw(uint256 collectionId_, address addr_)\r\n        public\r\n        onlyAuthorized(collectionId_)\r\n        nonReentrant\r\n    {\r\n        _nonZeroAddress(addr_);\r\n        require(\r\n            _collections[collectionId_].balance != 0,\r\n            \"Insufficient balance\"\r\n        );\r\n\r\n        Collection storage c = _collections[collectionId_];\r\n\r\n        // index 0 is artist and index 1 is platform\r\n        uint8 idx = _msgSender() == owner() ? 1 : 0;\r\n        uint256 allTimeBalance = c.balance + c.withdrawn[0] + c.withdrawn[1];\r\n        uint16 percentage;\r\n\r\n        if (_collections[collectionId_].percentage[idx] == 1) {\r\n            // In this case the given side doesn't have a cut - it might be the platform or artist as well\r\n            percentage = 0;\r\n        } else if (\r\n            _collections[collectionId_].percentage[idx] > 1 &&\r\n            _collections[collectionId_].percentage[idx] <= 10000\r\n        ) {\r\n            // This is a valid percentage from the collection struct\r\n            percentage = _collections[collectionId_].percentage[idx];\r\n        } else {\r\n            // Default percentage\r\n            percentage = idx == 0 ? _percentArtist : _percentPlatform;\r\n        }\r\n\r\n        uint256 payment = (allTimeBalance * percentage) /\r\n            10000 -\r\n            c.withdrawn[idx];\r\n\r\n        require(payment != 0, \"Nothing to withdraw\");\r\n\r\n        c.withdrawn[idx] += payment;\r\n        c.balance -= payment;\r\n\r\n        (bool success, ) = payable(addr_).call{value: payment}(\"\");\r\n        require(success, \"Withdraw failed\");\r\n\r\n        emit Withdraw(_msgSender(), addr_, payment);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows token owner or approved operator to approve address to token\r\n     * @param to_ approved address\r\n     * @param tokenId_ token ID\r\n     */\r\n    function approve(address to_, uint256 tokenId_) public {\r\n        address tokenOwner = ownerOf(tokenId_);\r\n        require(to_ != tokenOwner, \"Approval to current owner\");\r\n        require(\r\n            _msgSender() == tokenOwner ||\r\n                isApprovedForAll(tokenOwner, _msgSender()),\r\n            \"Not owner nor approved\"\r\n        );\r\n        _approve(to_, tokenId_);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns boolean flag indicating whether address is approved operator for owner tokens\r\n     * @param checkedOwner_ address of owner\r\n     * @param operator_ checked address\r\n     */\r\n    function isApprovedForAll(address checkedOwner_, address operator_)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _operatorApprovals[checkedOwner_][operator_];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows token owner to set/reset operator for his tokens\r\n     * @param operator_ address of owner\r\n     * @param approved_ checked address\r\n     */\r\n    function setApprovalForAll(address operator_, bool approved_) public {\r\n        require(operator_ != _msgSender(), \"Approve to caller\");\r\n        _operatorApprovals[_msgSender()][operator_] = approved_;\r\n        emit ApprovalForAll(_msgSender(), operator_, approved_);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns approved address of token\r\n     * @param tokenId_ token ID\r\n     */\r\n    function getApproved(uint256 tokenId_) public view returns (address) {\r\n        return _tokenApprovals[tokenId_];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows token owner or approved to burn token\r\n     * @param tokenId_ token ID\r\n     */\r\n    function burn(uint256 tokenId_) public virtual {\r\n        require(\r\n            _isApprovedOrOwner(_msgSender(), tokenId_),\r\n            \"Not owner nor approved\"\r\n        );\r\n\r\n        address owner = ownerOf(tokenId_);\r\n\r\n        _beforeTokenTransfer(owner, address(0), tokenId_);\r\n        _approve(address(0), tokenId_);\r\n\r\n        _balances[owner] -= 1;\r\n        delete _owners[tokenId_];\r\n\r\n        emit Transfer(owner, address(0), tokenId_);\r\n    }\r\n\r\n    /*********************************************\r\n     *********************************************\r\n     *  P r i v a t e\r\n     *      m e t h o d s\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes minting\r\n     * and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\r\n     * transferred to `to`.\r\n     * - When `from` is zero, `tokenId` will be minted for `to`.\r\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_\r\n    ) private {\r\n        if (from_ == address(0)) {\r\n            _allTokensIndex[tokenId_] = _allTokens.length;\r\n            _allTokens.push(tokenId_);\r\n        } else if (from_ != to_) {\r\n            _removeTokenFromOwnerEnumeration(from_, tokenId_);\r\n        }\r\n\r\n        if (to_ == address(0)) {\r\n            _removeTokenFromAllTokensEnumeration(tokenId_);\r\n        } else if (to_ != from_) {\r\n            uint256 length = balanceOf(to_);\r\n            _ownedTokens[to_][length] = tokenId_;\r\n            _ownedTokensIndex[tokenId_] = length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\r\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\r\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\r\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\r\n     * @param from_ address representing the previous owner of the given token ID\r\n     * @param tokenId_ uint256 ID of the token to be removed from the tokens list of the given address\r\n     */\r\n    function _removeTokenFromOwnerEnumeration(address from_, uint256 tokenId_)\r\n        private\r\n    {\r\n        uint256 lastTokenIndex = balanceOf(from_) - 1;\r\n        uint256 tokenIndex = _ownedTokensIndex[tokenId_];\r\n\r\n        if (tokenIndex != lastTokenIndex) {\r\n            uint256 lastTokenId = _ownedTokens[from_][lastTokenIndex];\r\n            _ownedTokens[from_][tokenIndex] = lastTokenId;\r\n            _ownedTokensIndex[lastTokenId] = tokenIndex;\r\n        }\r\n\r\n        // This also deletes the contents at the last position of the array\r\n        delete _ownedTokensIndex[tokenId_];\r\n        delete _ownedTokens[from_][lastTokenIndex];\r\n    }\r\n\r\n    /**\r\n     * @dev Private function to remove a token from this extension's token tracking data structures.\r\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\r\n     * @param tokenId_ uint256 ID of the token to be removed from the tokens list\r\n     */\r\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId_) private {\r\n        uint256 lastTokenIndex = _allTokens.length - 1;\r\n        uint256 tokenIndex = _allTokensIndex[tokenId_];\r\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\r\n\r\n        _allTokens[tokenIndex] = lastTokenId;\r\n        _allTokensIndex[lastTokenId] = tokenIndex;\r\n\r\n        delete _allTokensIndex[tokenId_];\r\n        _allTokens.pop();\r\n    }\r\n\r\n    function _exists(uint256 tokenId_) private view returns (bool) {\r\n        return _owners[tokenId_] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        require(_exists(tokenId_), \"Operator query for nonexistent token\");\r\n        address tokenOwner = ownerOf(tokenId_);\r\n        return (tokenOwner == spender_ ||\r\n            getApproved(tokenId_) == spender_ ||\r\n            isApprovedForAll(tokenOwner, spender_));\r\n    }\r\n\r\n    function _transfer(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_\r\n    ) private {\r\n        _nonZeroAddress(to_);\r\n        require(ownerOf(tokenId_) == from_, \"Not owner\");\r\n\r\n        _beforeTokenTransfer(from_, to_, tokenId_);\r\n        _approve(address(0), tokenId_);\r\n\r\n        _balances[from_] -= 1;\r\n        _balances[to_] += 1;\r\n        _owners[tokenId_] = to_;\r\n\r\n        emit Transfer(from_, to_, tokenId_);\r\n    }\r\n\r\n    function _approve(address to_, uint256 tokenId_) private {\r\n        _tokenApprovals[tokenId_] = to_;\r\n        emit Approval(ownerOf(tokenId_), to_, tokenId_);\r\n    }\r\n\r\n    function _mint(\r\n        uint256 collectionId_,\r\n        uint256 price_,\r\n        address receiver_,\r\n        uint16 amount_,\r\n        uint16 cap_,\r\n        uint32 maxSupply_,\r\n        uint32 minted_\r\n    ) private {\r\n        if (cap_ > 0) {\r\n            require(amount_ + minted_ <= cap_, \"Invalid mint amount\");\r\n        }\r\n\r\n        require(\r\n            amount_ + totalSupplyByCollectionId(collectionId_) <= maxSupply_,\r\n            \"Supply overflow\"\r\n        );\r\n\r\n        unchecked {\r\n            require(msg.value == amount_ * price_, \"Invalid ETH amount\");\r\n            _collections[collectionId_].balance += amount_ * price_;\r\n        }\r\n\r\n        for (uint256 i = 0; i < amount_; i++) {\r\n            unchecked {\r\n                _collections[collectionId_].tokenId += 1;\r\n            }\r\n\r\n            require(\r\n                !_exists(_collections[collectionId_].tokenId),\r\n                \"Token already minted\"\r\n            );\r\n\r\n            _beforeTokenTransfer(\r\n                address(0),\r\n                receiver_,\r\n                _collections[collectionId_].tokenId\r\n            );\r\n\r\n            _tokenIdToCollectionId[_collections[collectionId_].tokenId] = collectionId_;\r\n            unchecked {\r\n                _balances[receiver_] += 1;\r\n            }\r\n            _owners[_collections[collectionId_].tokenId] = receiver_;\r\n\r\n            emit Mint(\r\n                collectionId_,\r\n                receiver_,\r\n                _collections[collectionId_].tokenId\r\n            );\r\n        }\r\n    }\r\n\r\n    function _checkOnERC721Received(\r\n        address from_,\r\n        address to_,\r\n        uint256 tokenId_,\r\n        bytes memory data_\r\n    ) private returns (bool) {\r\n        if (Address.isContract(to_)) {\r\n            try\r\n                IERC721Receiver(to_).onERC721Received(\r\n                    _msgSender(),\r\n                    from_,\r\n                    tokenId_,\r\n                    data_\r\n                )\r\n            returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"Non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function _nonZeroAddress(address addr_) private pure {\r\n        require(addr_ != address(0), \"Invalid address\");\r\n    }\r\n\r\n    function _isCollectionAuthorized(uint256 collectionId_, address addr_)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return\r\n            owner() == addr_ ||\r\n            _collections[collectionId_].artistAddr == addr_ ||\r\n            _collections[collectionId_].authorized[addr_];\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddr_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAddr_\",\"type\":\"address\"}],\"name\":\"CollectionArtistAddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state_\",\"type\":\"bool\"}],\"name\":\"CollectionAuthorizationUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"newState_\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"oldSate_\",\"type\":\"uint8\"}],\"name\":\"CollectionStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"}],\"name\":\"addKnownArtists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"}],\"name\":\"addToCollectionPremintList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"collectionAddressMintedStats\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionArtistAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionBaseUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionBounds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionMintCaps\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionMintPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionPaymentsInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionPremintListDetails\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionRoyaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionState\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"collectionSupplies\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"artistAddr_\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"maxSupply_\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"premintMaxSupply_\",\"type\":\"uint32\"}],\"name\":\"createCollection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultBaseUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPercentages\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkedOwner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"isCollectionAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"isCollectionBaseUriLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCreateCollectionPublic\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"isKnownArtist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"isOnCollectionPremintList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastCollectionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"lockCollectionBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"amount_\",\"type\":\"uint16\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"amount_\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"mintInternal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"amount_\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"mintTo\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"}],\"name\":\"removeFromCollectionPremintList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"}],\"name\":\"removeKnownArtists\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price_\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"baseUri_\",\"type\":\"string\"}],\"name\":\"setCollectionBaseUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state_\",\"type\":\"bool\"}],\"name\":\"toggleCollectionAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx_\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenIdToCollectionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"idx_\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"}],\"name\":\"totalSupplyByCollectionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"info_\",\"type\":\"string\"}],\"name\":\"updateArtist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"artistAddr_\",\"type\":\"address\"}],\"name\":\"updateCollectionArtistAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdateMintCap_\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"mintCap_\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdatePremintCap_\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"premintCap_\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdatePremintListCap_\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"premintListCap_\",\"type\":\"uint16\"}],\"name\":\"updateCollectionCaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdateMintPrice_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdatepremintPrice_\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"premintPrice_\",\"type\":\"uint256\"}],\"name\":\"updateCollectionMintPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"collectionName_\",\"type\":\"string\"}],\"name\":\"updateCollectionName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"percentArtist_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentPlatform_\",\"type\":\"uint16\"}],\"name\":\"updateCollectionPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltyAddr_\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"royaltyBasis_\",\"type\":\"uint16\"}],\"name\":\"updateCollectionRoyalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"state_\",\"type\":\"uint8\"}],\"name\":\"updateCollectionState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdateMaxSupply_\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"maxSupply_\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"shouldUpdatePremintMaxSupply_\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"premintMaxSupply_\",\"type\":\"uint32\"}],\"name\":\"updateCollectionSupplies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level_\",\"type\":\"uint8\"}],\"name\":\"updateCreateCollectionAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"percentArtist_\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"percentPlatform_\",\"type\":\"uint16\"}],\"name\":\"updateDefaultPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"updateTokenUri\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"collectionId_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr_\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DigitalArtists", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ae817e51da98304989a81e69c26541218693020f1b6acef71cec7684bfbe5946"}]}