{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.18;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'dCHF' token contract\r\n//\r\n// Deployed to : 0x0000F70bC78af03f14132c68b59153E4788bAb20  on march 20th 2018 somewhere after Block 52911611\r\n// Symbol      : dCH\r\n// Name        : private digitale Schweizer Franken - private digital Swiss Franc \r\n// Total supply: 15000,00\r\n// Decimals    : 2\r\n//\r\n// based on code made by\r\n//\r\n//  Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n//\r\n// ----------------------------------------------------------------------------\r\n// ALLGEMEINE GESCHAEFTSBEDINGUNGEN f\u00fcr die Nutzung von privaten digitalen Schweizer Franken\r\n// ----------------------------------------------------------------------------\r\n//\r\n// -----------------------------\r\n// 1. Diese Allgemeinen Gesch\u00e4ftsbedingungen gelten ausschliesslich f\u00fcr Rechtsgesch\u00e4fte zwischen der Scenic Swisscoast GmbH, 3012 Bern (CH-ID:  CH03540319700) und dem Kunden im Rahmen des Verkaufs und der Annahme von privaten digitalen Schweizer Franken. Diese Dienstleitungen der Scenic Swisscoast GmbH ba-sieren ausschliesslich auf der Grundlage dieser Allgemeinen Gesch\u00e4ftsbedingungen.\r\n// -----------------------------\r\n// 2. Definition: \r\n// -----------------------------\r\n//     Bei der Scenic Swisscoast GmbH handelt es sich um ein privates Schweizer Unternehmen. Sie verkauft die privaten digitalen Schweizer Franken als Kryptow\u00e4hrung in eigenem Namen und auf eigene Rechnung. Sce-nic Swisscoast GmbH ist keine Beh\u00f6rde und handelt weder als Beh\u00f6rde noch in einem amtlichen Auftrag. Sce-nic Swisscoast GmbH ist auch keine Bank. Die privaten digitalen Schweizer Franken sind ein privates digitales Zahlungsmittel in Schweizer Franken, das von der Scenic Swisscoast GmbH auf einer Blockchain geschaffen und verkauft wird. Solche privaten Zah-lungsmittel werden auch als \u00abdigitales Geld\u00bb, \u00abvirtuelles Geld\u00bb oder \u00abKryptow\u00e4hrungen\u00bb bezeichnet. Bei den privaten digitalen Schweizer Franken handelt es sich weder um staatliches Geld noch um ein gesetz-liches Zahlungsmittel. Es ist ein privates digitales Zahlungsmittel. F\u00fcr die privaten digitalen Schweizer Fran-ken besteht in der Schweiz keine Pflicht zur Annahme als Zahlungsmittel. Sie k\u00f6nnen nur bei der Scenic Swisscoast GmbH f\u00fcr den Kauf von Tickets f\u00fcr das 1. International Innovation Film Festival in Bern, das vom 14.-18. Februar 2019 stattfinden wird, sowie f\u00fcr Dienstleistungen der Scenic Swisscoast GmbH zur Zahlung verwendet werden. Bei den privaten digitalen Schweizer Franken handelt es sich nicht um sog. \u00abelektronisches Geld\u00bb im engeren Sinne. Der K\u00e4ufer der privaten digitalen Schweizer Franken hat keine Forderung gegen die Scenic Swisscoast GmbH und kann diese bei der Scenic Swisscoast GmbH nicht gegen gesetzliche Zahlungsmittel umtauschen. Kryptow\u00e4hrungen wie Bitcoin oder Ether werden \u00fcblicherweise in einer eigenen W\u00e4hrung ausgegeben. Die privaten digitalen Schweizer Franken werden in Schweizer Franken als W\u00e4hrung ausgegeben. Damit entf\u00e4llt das bei Kryptow\u00e4hrungen bestehende Wechselkursrisiko. Der K\u00e4ufer der privaten digitalen Schweizer Fran-ken kann diese beim Kauf von Tickets f\u00fcr das 1. International Innovation Film Festival in Bern oder bei der Bezahlung von Dienstleistungen der Scenic Swisscoast GmbH 1:1 in Schweizer Franken verwenden. Die privaten digitalen Schweizer Franken sind ein eindeutiger, ERC-20 standardisierter Token auf der Ethereum-Blockchain mit der eindeutigen Ethereumcontract - nummer von diesem Smart Contract hier: Alle Vertragsdetails k\u00f6nnen mit einem Blockchainexplorer wie zum Beispiel etherscan.io eingesehen werden: \r\n// -----------------------------\r\n// 3. Verkauf des Digitalen Schweizer Frankens:\r\n// -----------------------------\r\n//     Verk\u00e4ufer:\r\n//      Verk\u00e4ufer der privaten digitalen Schweizer Franken ist die Scenic Swisscoast GmbH. Diese verkauft die priva-ten digitalen Schweizer Franken auf der Webseite www.innovationfilmfestival.ch.\r\n//\r\n//  Der K\u00e4ufer: \r\n// 1.\tmuss beim bei der Bestellung Name, Vorname, Adresse inklusive Wohnort sowie Email und Mobil-Telefonnummer angeben \r\n// 2.\tkann f\u00fcr 100, 500 oder 750 Franken private digitale Schweizer Franken kaufen \r\n// 3.\tkann f\u00fcr maximal 750 Franken private digitale Schweizer Franken kaufen \r\n// 4.\tmuss \u00fcber eine Ethereumadresse verf\u00fcgen oder eine erstellen, um die privaten digitalen Schweizer Fran-ken entgegenzunehmen \r\n// 5.\tverliert beim Verlust des private Keys zur Ethereumadresse oder bei Verlust des Wallets mit der Ethereumadresse seine privaten digitalen Schweizer Franken, sofern er kein Backup erstellt hat. Weder die Scenic Swisscoast GmbH noch sonst eine Institution ist technisch in der Lage, verlorengegangene pri-vate digitale Schweizer Franken oder private Keys widerherzustellen oder r\u00fcckzuverg\u00fcten. \r\n// 6.\tmuss sich der Risiken der Ethereumblockchaintechnologie bewusst sein: insbesondere muss sich der Kun-de bewusst sein, dass die Scenic Swisscoast GmbH nicht f\u00fcr die Ethereumblockchain und/oder das Eth-reumnetzwerk noch die Verf\u00fcgbarkeit verantwortlich ist. \r\n// 7.\tmuss sich bewusst sein, dass er nur mit den privaten digitalen Schweizer Franken bezahlen kann, wenn er auf das Internet zugreifen kann. \r\n// 8.\tmuss sich der Risiken bewusst sein, die ein allf\u00e4lliger Entwicklungsschub in der Quantenkryptografie zu bedeuten h\u00e4tte. \r\n// 9.\tmuss sich der grunds\u00e4tzlichen Risiken der Blockchaintechnologie bewusst sein. Sowohl die Technologie selbst als auch der Umgang mit der Technologie k\u00f6nnen die Sicherheit der privaten digitalen Schweizer Franken beeintr\u00e4chtigen. \r\n// 10.\tmuss sich der Risiken, die Software und Webseiten Dritter bergen, bewusst sein. Insbesondere sind da Walletgeneratoren, mobile Apps und Betriebssysteme von mobilen Ger\u00e4ten und sonstiger Hardware zu erw\u00e4hnen.\r\n// 11.\tmuss sich unerwarteter Risiken bewusst sein. Die Ethereumtechnologie ist noch verh\u00e4ltnism\u00e4ssig jung und es k\u00f6nnen unerwartete Risiken auftreten. \r\n// 12.\tkann w\u00e4hlen, wie er die privaten digitalen Schweizer Franken bezahlen will. M\u00f6glich ist eine Zahlung auf das Postkonto der Scenic Swisscoast GmbH oder eine Zahlung via PayPal oder eine Bezahlung mit Ether.\r\n// 13.\tmuss sich bewusst sein, dass es f\u00fcr den Transfer von privaten digitalen Schweizer Franken einen kleinen Betrag Ether braucht. Dieser Betrag h\u00e4ngt von verschiedenen Faktoren ab, auf welche Scenic Swisscoast GmbH keinen Einfluss hat (z.B. Gaspreis, Geschwindigkeit der Transaktion, Traffic auf der Ethereumblock-chain). Scenic Swisscoast GmbH wird bei jedem Verkauf von privaten digitalen Schweizer Franken dem K\u00e4ufer zus\u00e4tzlich und freiwillig 0.0001 Ether auf die vom Kunden genannte Ethereumadresse mit\u00fcberwei-sen. Dieser Betrag erm\u00f6glich dem Kunden (Stand: Ausgabe der AGB) mindestens eine \u00dcberweisung von privaten digitalen Schweizer Franken. Dar\u00fcber hinaus tr\u00e4gt der Kunde die Kosten f\u00fcr weitere \u00dcberwei-sungen von privaten digitalen Schweizer Franken auf der Ethereumblockchain selber.\r\n// 14.\tmuss sich bewusst sein, dass \u00dcberweisungen von privaten digitalen Schweizer Franken auf falsche Ethereumadressen nicht r\u00fcckg\u00e4ngig gemacht werden k\u00f6nnen und somit verloren sind. Der Kunde muss insbesondere bei der Bezahlung via Bankeinzahlung oder PayPal sicherstellen, dass er der Scenic Swisscoast GmbH die richtige Ethereumadresse angibt. \r\n\r\n// Bei der Bezahlung auf das Postkonto oder via PayPal\r\n// stellt die Scenic Swisscoast GmbH innert 24h eine Rechnung per Mail zu, die innert 7 Tagen bezahlt sein muss. Die privaten digitalen Schweizer Franken werden innert 7 Tagen nach Eingang der Zahlung (Post/Paypal) auf die angegebene Ethereumadresse \u00fcberwiesen. \r\n\r\n// Bei der Bezahlung mit Ether \r\n// -\tberechnet die Scenic Swisscoast GmbH den Etherwechselkurs gem\u00e4ss Angaben von Kraken (in ETH/EUR mit einem CHF/Euro-Wechselkurs gem\u00e4ss http://www.finanzen.ch/devisen/eurokurs).\r\n// -\terstellt die Scenic Swisscoast GmbH eine Rechnung und einen Smartcontract f\u00fcr den Umtausch von Ether in private digitale Schweizer Franken.\r\n// - \tauf dieser Rechnung ist die Ethereumadresse des Smartcontracts aufgef\u00fchrt.\r\n// -    Der Smartcontract tauscht automatisch Ether in private digitale Schweizer Franken zum berechneten Wechselkurs um. Der Kunde muss den in Rechnung gestellten Betrag in Ether an die Ethereumadresse des Smartcontracts senden und erh\u00e4lt automatisch vom Smartcontract die privaten digitalen Schweizer Fran-ken auf sein Ethereumwallet. Der Kunde muss den Betrag von einem Wallet aus senden, auf das er vollen Zugriff hat (zum Beispiel mittels private Key).\r\n// -    Auf Wunsch kann der Kunde bei der Bezahlung mit Ether die Alternative ohne Smartcontract w\u00e4hlen. Er \r\n// 1) bezahlt den verrechneten Betrag in Ether auf die Ethereumadresse von Scenic Swisscoast GmbH, \r\n// 2) gibt der Scenic Swisscoast GmbH seine eigene Ethereumadresse an, auf die er vollen Zugriff hat (zum Beispiel mittels private Key)\r\n// 3) erh\u00e4lt von der Scenic Swisscoast GmbH innert 7 Tagen die ihm zustehenden Digitalen Schweizer Franken auf das angegeben Wallet.\r\n// Bei einer Bezahlung mit Ether ist die Bezahlung mittels Smartcontract unmittelbar.\r\n// \r\n// Verkaufsbeschr\u00e4nkung\r\n// Der Verkauf ist auf 15\u2019000 private digitale Schweizer Franken mit je zwei Nachkommastellen beschr\u00e4nkt. Die Scenic Swisscoast GmbH beh\u00e4lt sich vor, zu einem sp\u00e4teren Zeitpunkt weitere private digitale Schweizer Fran-ken zu verkaufen.\r\n// \r\n// Die privaten digitalen Schweizer Franken werden ausschliesslich an Personen mit Wohnsitz in der Schweiz verkauft.\r\n//\r\n// -----------------------------\r\n//4.\tVerwendung der privaten digitalen Schweizer Franken / Akzeptanzstellen: \r\n// -----------------------------\r\n// Die Scenic Swisscoast GmbH ist Mitveranstalterin des 1. International Innovation Film Festival in Bern das vom 14.-18. Februar stattfindet. Sie hat das Vorkaufsrecht auf alle Tickets der 9 Kinovorf\u00fchrungen im Rahmen des Filmfestivals. Die privaten digitalen Schweizer Franken werden am Festival f\u00fcr den Kinoticketkauf als Zahlungsmittel zum Nennwert akzeptiert werden. Im Weiteren akzeptiert die Scenic Swisscoast GmbH die privaten digitalen Schweizer Franken als Zahlungsmittel f\u00fcr ihre eigenen Dienstleistungen. Die Scenic Swisscoast GmbH beh\u00e4lt sich vor, weitere Akzeptanzstellen f\u00fcr die privaten digitalen Schweizer Franken zu schaffen.\r\n//\r\n//4.1\t\tKeine R\u00fcckgabe der privaten digitalen Schweizer Franken: Die R\u00fcckgabe nicht gebrauchter privater digitaler Schweizer Franken an die Scenic Swisscoast GmbH ist aus-geschlossen.\r\n//\r\n// -----------------------------\r\n//5.\tPreise: \r\n// -----------------------------\r\n//Der Digitale Schweizer Franken wird zu folgenden Preisen verkauft: \r\n//vor dem 25. M\u00e4rz 2018:115 private digitale Schweizer Franken f\u00fcr 100 Schweizer Franken \r\n//vor dem 31.M\u00e4rz 2018:\t110 private digitale Schweizer Franken f\u00fcr 100 Schweizer Franken \r\n//vor dem 1. August 2018: 105 private digitale Schweizer Franken f\u00fcr 100 Schweizer Franken \r\n//nach dem 1. August 2018: 100 private digitale Schweizer Franken f\u00fcr 100 Schweizer Franken\r\n//\r\n//\r\n// -----------------------------\r\n//6.\tVerantwortung der Scenic Swisscoast GmbH: \r\n// -----------------------------\r\n//Die Scenic Swisscoast GmbH hat die privaten digitalen Schweizer Franken nach g\u00e4ngigem Standard entwi-ckelt und auf der Ethereum Blockchain ver\u00f6ffentlicht. \r\n//Die Scenic Swisscoast GmbH ist weder verantwortlich noch zust\u00e4ndig f\u00fcr die Verf\u00fcgbarkeit des Internetzu-griffs, des Zustandes des Ethereumnetzwerks oder die Sicherheit des ERC-20 Standards.\r\n//\r\n//\r\n// -----------------------------\r\n//7.\tSorgfaltspflichten des Kunden:\r\n// -----------------------------\r\n//Der Kunde verpflichtet sich, wahrheitsgem\u00e4sse, exakte, aktuelle und vollst\u00e4ndige Angaben zu seiner Person und seiner Ethereumadresse auf dem Bestellformular zu machen. Scenic Swisscoast GmbH schliesst f\u00fcr Verlus-te und Sch\u00e4den, die sich aus der Nichterf\u00fcllung dieser Verpflichtungen ergeben, jegliche Haftung aus. Scenic Swisscoast GmbH beh\u00e4lt sich vor, diese Angaben durch R\u00fcckruf oder \u00e4hnliche geeignete Massnahmen zu \u00fcberpr\u00fcfen und bei Missachtung unserer AGB einzelne Personen vom Verkauf auszuschliessen.\r\n//\r\n// -----------------------------\r\n//8.\tDatenschutz:\r\n// -----------------------------\r\n//Scenic Swisscoast GmbH ist berechtigt, die Anmeldedaten im Rahmen der Erf\u00fcllung der Vertragszwecke zu speichern, zu ver\u00e4ndern oder zu \u00fcbermitteln. Scenic Swisscoast GmbH weist den Kunden darauf hin, dass per-sonenbezogene Daten im Rahmen der Vertragsdurchf\u00fchrung gespeichert werden. Der Kunde willigt mit der Akzeptierung dieser AGB ein, dass die erhobenen Daten, insbesondere auch die Ethereumadresse, von Scenic Swisscoast GmbH verarbeitet und genutzt werden k\u00f6nnen. Der Kunde kann der Verwendung seiner Daten je-derzeit widersprechen.\r\n//\r\n// -----------------------------\r\n//9.\tGew\u00e4hrleistung, Haftung:\r\n// -----------------------------\r\n//Der Kunde erkl\u00e4rt sich ausdr\u00fccklich damit einverstanden, dass die Nutzung des von Scenic Swisscoast GmbH zur Verf\u00fcgung gestellten Dienstes auf eigene Gefahr erfolgt. Scenic Swisscoast GmbH haftet nicht im Falle h\u00f6herer Gewalt, insbesondere bei Ausfall von Telefonleitungen oder Internetleitungen, Arbeitskampfmass-nahmen, Hochwasser, beh\u00f6rdlichen Massnahmen, unvorhersehbarem Ausfall von Transportmitteln oder Energie oder sonstigen unabwendbaren Ereignissen. Dies gilt auch, wenn die vorstehenden Ereignisse bei ei-nem Erf\u00fcllungsgehilfen der Scenic Swisscoast GmbH eintreten.\r\n//\r\n//\r\n// -----------------------------\r\n//10.\t\u00c4nderung des Angebotes:\r\n// -----------------------------\r\n//Die Scenic Swisscoast GmbH beh\u00e4lt sich vor, die angebotenen Dienste mit oder ohne Mitteilung an den Kun-den zeitweilig oder auf Dauer zu \u00e4ndern, zu unterbrechen oder einzustellen. Die Scenic Swisscoast GmbH haf-tet dem Kunden gegen\u00fcber nicht f\u00fcr die \u00c4nderung, Unterbrechung oder Einstellung des Dienstes.\r\n//\r\n// -----------------------------\r\n//11.\tLinks:\r\n// -----------------------------\r\n//Auf den Internetseiten von innovationfilmfestival.ch kann die Scenic Swisscoast GmbH Links zu anderen, frem-den Internetseiten oder fremden Quellen erstellen. Die Scenic Swisscoast GmbH hat hinsichtlich dieser Inter-netseiten oder Quellen keine Kontrollm\u00f6glichkeiten in Bezug auf Verf\u00fcgbarkeit oder Inhalt. Aus diesem Grunde ist die Scenic Swisscoast GmbH f\u00fcr den Inhalt solcher Internetseiten oder Quellen nicht verantwortlich.\r\n//\r\n// -----------------------------\r\n//12.\tAnzuwendendes Recht, Gerichtsstand:\r\n// -----------------------------\r\n//Bei Streitf\u00e4llen findet das schweizerische Recht Anwendung. Als Gerichtsstand wird Thun vereinbart.\r\n//\r\n//\r\n//\r\n//\r\n//\r\n//\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract dCHF is ERC20Interface, Owned, SafeMath {\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    function dCHF() public {\r\n        symbol = \"dCHF\";\r\n        name = \"private digitale Schweizer Franken - private digital Swiss Franc\";\r\n        decimals = 2;\r\n        _totalSupply = 1500000;\r\n        balances[0x0000F70bC78af03f14132c68b59153E4788bAb20] = _totalSupply;\r\n        Transfer(address(0),0x0000F70bC78af03f14132c68b59153E4788bAb20 , _totalSupply);\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account tokenOwner\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to to account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces \r\n    // ------------------------------------------------------------------------\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer tokens from the from account to the to account\r\n    // \r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the from account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the spender's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for spender to transferFrom(...) tokens\r\n    // from the token owner's account. The spender contract function\r\n    // receiveApproval(...) is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Don't accept ETH\r\n    // ------------------------------------------------------------------------\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "dCHF", "CompilerVersion": "v0.4.22-nightly.2018.3.16+commit.2b2527f3", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e4aea352c3548d203766c669d17c05c08c91c1a7f82d4415a37e80e244e450fb"}]}