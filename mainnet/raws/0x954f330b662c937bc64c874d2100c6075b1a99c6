{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.5.2;\r\n\r\ncontract Admin {\r\n\r\n    address internal _admin;\r\n\r\n    event AdminChanged(address oldAdmin, address newAdmin);\r\n\r\n    /// @notice gives the current administrator of this contract.\r\n    /// @return the current administrator of this contract.\r\n    function getAdmin() external view returns (address) {\r\n        return _admin;\r\n    }\r\n\r\n    /// @notice change the administrator to be `newAdmin`.\r\n    /// @param newAdmin address of the new administrator.\r\n    function changeAdmin(address newAdmin) external {\r\n        require(msg.sender == _admin, \"only admin can change admin\");\r\n        emit AdminChanged(_admin, newAdmin);\r\n        _admin = newAdmin;\r\n    }\r\n}\r\n\r\n\r\ncontract SuperOperators is Admin {\r\n\r\n    mapping(address => bool) internal _superOperators;\r\n\r\n    event SuperOperator(address superOperator, bool enabled);\r\n\r\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\r\n    /// @param superOperator address that will be given/removed superOperator right.\r\n    /// @param enabled set whether the superOperator is enabled or disabled.\r\n    function setSuperOperator(address superOperator, bool enabled) external {\r\n        require(\r\n            msg.sender == _admin,\r\n            \"only admin is allowed to add super operators\"\r\n        );\r\n        _superOperators[superOperator] = enabled;\r\n        emit SuperOperator(superOperator, enabled);\r\n    }\r\n\r\n    /// @notice check whether address `who` is given superOperator rights.\r\n    /// @param who The address to query.\r\n    /// @return whether the address has superOperator rights.\r\n    function isSuperOperator(address who) public view returns (bool) {\r\n        return _superOperators[who];\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20Events {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\nlibrary BytesUtil {\r\n    function memcpy(uint256 dest, uint256 src, uint256 len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256**(32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function pointerToBytes(uint256 src, uint256 len)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory ret = new bytes(len);\r\n        uint256 retptr;\r\n        assembly {\r\n            retptr := add(ret, 32)\r\n        }\r\n\r\n        memcpy(retptr, src, len);\r\n        return ret;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes memory b) {\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(\r\n                add(m, 20),\r\n                xor(0x140000000000000000000000000000000000000000, a)\r\n            )\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function uint256ToBytes(uint256 a) internal pure returns (bytes memory b) {\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 32), a)\r\n            mstore(0x40, add(m, 64))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function doFirstParamEqualsAddress(bytes memory data, address _address)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (data.length < (36 + 32)) {\r\n            return false;\r\n        }\r\n        uint256 value;\r\n        assembly {\r\n            value := mload(add(data, 36))\r\n        }\r\n        return value == uint256(_address);\r\n    }\r\n\r\n    function doParamEqualsUInt256(bytes memory data, uint256 i, uint256 value)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (data.length < (36 + (i + 1) * 32)) {\r\n            return false;\r\n        }\r\n        uint256 offset = 36 + i * 32;\r\n        uint256 valuePresent;\r\n        assembly {\r\n            valuePresent := mload(add(data, offset))\r\n        }\r\n        return valuePresent == value;\r\n    }\r\n\r\n    function overrideFirst32BytesWithAddress(\r\n        bytes memory data,\r\n        address _address\r\n    ) internal pure returns (bytes memory) {\r\n        uint256 dest;\r\n        assembly {\r\n            dest := add(data, 48)\r\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\r\n\r\n        bytes memory addressBytes = addressToBytes(_address);\r\n        uint256 src;\r\n        assembly {\r\n            src := add(addressBytes, 32)\r\n        }\r\n\r\n        memcpy(dest, src, 20);\r\n        return data;\r\n    }\r\n\r\n    function overrideFirstTwo32BytesWithAddressAndInt(\r\n        bytes memory data,\r\n        address _address,\r\n        uint256 _value\r\n    ) internal pure returns (bytes memory) {\r\n        uint256 dest;\r\n        uint256 src;\r\n\r\n        assembly {\r\n            dest := add(data, 48)\r\n        } // 48 = 32 (offset) + 4 (func sig) + 12 (address is only 20 bytes)\r\n        bytes memory bbytes = addressToBytes(_address);\r\n        assembly {\r\n            src := add(bbytes, 32)\r\n        }\r\n        memcpy(dest, src, 20);\r\n\r\n        assembly {\r\n            dest := add(data, 68)\r\n        } // 48 = 32 (offset) + 4 (func sig) + 32 (next slot)\r\n        bbytes = uint256ToBytes(_value);\r\n        assembly {\r\n            src := add(bbytes, 32)\r\n        }\r\n        memcpy(dest, src, 32);\r\n\r\n        return data;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20BaseToken is SuperOperators, ERC20Events {\r\n\r\n    uint256 internal _totalSupply;\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n\r\n    /// @notice Gets the total number of tokens in existence.\r\n    /// @return the total number of tokens in existence.\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @notice Gets the balance of `owner`.\r\n    /// @param owner The address to query the balance of.\r\n    /// @return The amount owned by `owner`.\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        return _balances[owner];\r\n    }\r\n\r\n    /// @notice gets allowance of `spender` for `owner`'s tokens.\r\n    /// @param owner address whose token is allowed.\r\n    /// @param spender address allowed to transfer.\r\n    /// @return the amount of token `spender` is allowed to transfer on behalf of `owner`.\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        returns (uint256 remaining)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /// @notice returns the number of decimals for that token.\r\n    /// @return the number of decimals.\r\n    function decimals() public view returns (uint8) {\r\n        return uint8(18);\r\n    }\r\n\r\n    /// @notice Transfer `amount` tokens to `to`.\r\n    /// @param to the recipient address of the tokens transfered.\r\n    /// @param amount the number of tokens transfered.\r\n    /// @return true if success.\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _transfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Transfer `amount` tokens from `from` to `to`.\r\n    /// @param from whose token it is transferring from.\r\n    /// @param to the recipient address of the tokens transfered.\r\n    /// @param amount the number of tokens transfered.\r\n    /// @return true if success.\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        if (msg.sender != from && !_superOperators[msg.sender]) {\r\n            uint256 currentAllowance = _allowances[from][msg.sender];\r\n            if (currentAllowance != (2**256) - 1) {\r\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\r\n                require(currentAllowance >= amount, \"Not enough funds allowed\");\r\n                _allowances[from][msg.sender] = currentAllowance - amount;\r\n            }\r\n        }\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice burn `amount` tokens.\r\n    /// @param amount the number of tokens to burn.\r\n    /// @return true if success.\r\n    function burn(uint256 amount) external returns (bool) {\r\n        _burn(msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice burn `amount` tokens from `owner`.\r\n    /// @param owner address whose token is to burn.\r\n    /// @param amount the number of token to burn.\r\n    /// @return true if success.\r\n    function burnFor(address owner, uint256 amount) external returns (bool) {\r\n        _burn(owner, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice approve `spender` to transfer `amount` tokens.\r\n    /// @param spender address to be given rights to transfer.\r\n    /// @param amount the number of tokens allowed.\r\n    /// @return true if success.\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        _approveFor(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice approve `spender` to transfer `amount` tokens from `owner`.\r\n    /// @param owner address whose token is allowed.\r\n    /// @param spender  address to be given rights to transfer.\r\n    /// @param amount the number of tokens allowed.\r\n    /// @return true if success.\r\n    function approveFor(address owner, address spender, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            msg.sender == owner || _superOperators[msg.sender],\r\n            \"msg.sender != owner && !superOperator\"\r\n        );\r\n        _approveFor(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function addAllowanceIfNeeded(address owner, address spender, uint256 amountNeeded)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(\r\n            msg.sender == owner || _superOperators[msg.sender],\r\n            \"msg.sender != owner && !superOperator\"\r\n        );\r\n        _addAllowanceIfNeeded(owner, spender, amountNeeded);\r\n        return true;\r\n    }\r\n\r\n    function _addAllowanceIfNeeded(address owner, address spender, uint256 amountNeeded)\r\n        internal\r\n    {\r\n        if(amountNeeded > 0 && !isSuperOperator(spender)) {\r\n            uint256 currentAllowance = _allowances[owner][spender];\r\n            if(currentAllowance < amountNeeded) {\r\n                _approveFor(owner, spender, amountNeeded);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _approveFor(address owner, address spender, uint256 amount)\r\n        internal\r\n    {\r\n        require(\r\n            owner != address(0) && spender != address(0),\r\n            \"Cannot approve with 0x0\"\r\n        );\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal {\r\n        require(to != address(0), \"Cannot send to 0x0\");\r\n        uint256 currentBalance = _balances[from];\r\n        require(currentBalance >= amount, \"not enough fund\");\r\n        _balances[from] = currentBalance - amount;\r\n        _balances[to] += amount;\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address to, uint256 amount) internal {\r\n        require(to != address(0), \"Cannot mint to 0x0\");\r\n        require(amount > 0, \"cannot mint 0 tokens\");\r\n        uint256 currentTotalSupply = _totalSupply;\r\n        uint256 newTotalSupply = currentTotalSupply + amount;\r\n        require(newTotalSupply > currentTotalSupply, \"overflow\");\r\n        _totalSupply = newTotalSupply;\r\n        _balances[to] += amount;\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal {\r\n        require(amount > 0, \"cannot burn 0 tokens\");\r\n        if (msg.sender != from && !_superOperators[msg.sender]) {\r\n            uint256 currentAllowance = _allowances[from][msg.sender];\r\n            require(\r\n                currentAllowance >= amount,\r\n                \"Not enough funds allowed\"\r\n            );\r\n            if (currentAllowance != (2**256) - 1) {\r\n                // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\r\n                _allowances[from][msg.sender] = currentAllowance - amount;\r\n            }\r\n        }\r\n\r\n        uint256 currentBalance = _balances[from];\r\n        require(currentBalance >= amount, \"Not enough funds\");\r\n        _balances[from] = currentBalance - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract ERC20BasicApproveExtension {\r\n\r\n    /// @notice approve `target` to spend `amount` and call it with data.\r\n    /// @param target address to be given rights to transfer and destination of the call.\r\n    /// @param amount the number of tokens allowed.\r\n    /// @param data bytes for the call.\r\n    /// @return data of the call.\r\n    function approveAndCall(\r\n        address target,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external payable returns (bytes memory) {\r\n        require(\r\n            BytesUtil.doFirstParamEqualsAddress(data, msg.sender),\r\n            \"first param != sender\"\r\n        );\r\n\r\n        _approveFor(msg.sender, target, amount);\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call.value(msg.value)(data);\r\n        require(success, string(returnData));\r\n        return returnData;\r\n    }\r\n\r\n    /// @notice temporarly approve `target` to spend `amount` and call it with data. Previous approvals remains unchanged.\r\n    /// @param target destination of the call, allowed to spend the amount specified\r\n    /// @param amount the number of tokens allowed to spend.\r\n    /// @param data bytes for the call.\r\n    /// @return data of the call.\r\n    function paidCall(\r\n        address target,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external payable returns (bytes memory) {\r\n        require(\r\n            BytesUtil.doFirstParamEqualsAddress(data, msg.sender),\r\n            \"first param != sender\"\r\n        );\r\n\r\n        if (amount > 0) {\r\n            _addAllowanceIfNeeded(msg.sender, target, amount);\r\n        }\r\n\r\n        // solium-disable-next-line security/no-call-value\r\n        (bool success, bytes memory returnData) = target.call.value(msg.value)(data);\r\n        require(success, string(returnData));\r\n\r\n        return returnData;\r\n    }\r\n\r\n    function _approveFor(address owner, address target, uint256 amount) internal;\r\n    function _addAllowanceIfNeeded(address owner, address spender, uint256 amountNeeded) internal;\r\n}\r\n\r\n\r\n\r\ncontract ERC20ExecuteExtension {\r\n\r\n    /// @dev _executionAdmin != _admin so that this super power can be disabled independently\r\n    address internal _executionAdmin;\r\n\r\n    event ExecutionAdminAdminChanged(address oldAdmin, address newAdmin);\r\n\r\n    /// @notice give the address responsible for adding execution rights.\r\n    /// @return address of the execution administrator.\r\n    function getExecutionAdmin() external view returns (address) {\r\n        return _executionAdmin;\r\n    }\r\n\r\n    /// @notice change the execution adminstrator to be `newAdmin`.\r\n    /// @param newAdmin address of the new administrator.\r\n    function changeExecutionAdmin(address newAdmin) external {\r\n        require(msg.sender == _executionAdmin, \"only executionAdmin can change executionAdmin\");\r\n        emit ExecutionAdminAdminChanged(_executionAdmin, newAdmin);\r\n        _executionAdmin = newAdmin;\r\n    }\r\n\r\n    mapping(address => bool) internal _executionOperators;\r\n    event ExecutionOperator(address executionOperator, bool enabled);\r\n\r\n    /// @notice set `executionOperator` as executionOperator: `enabled`.\r\n    /// @param executionOperator address that will be given/removed executionOperator right.\r\n    /// @param enabled set whether the executionOperator is enabled or disabled.\r\n    function setExecutionOperator(address executionOperator, bool enabled) external {\r\n        require(\r\n            msg.sender == _executionAdmin,\r\n            \"only execution admin is allowed to add execution operators\"\r\n        );\r\n        _executionOperators[executionOperator] = enabled;\r\n        emit ExecutionOperator(executionOperator, enabled);\r\n    }\r\n\r\n    /// @notice check whether address `who` is given executionOperator rights.\r\n    /// @param who The address to query.\r\n    /// @return whether the address has executionOperator rights.\r\n    function isExecutionOperator(address who) public view returns (bool) {\r\n        return _executionOperators[who];\r\n    }\r\n\r\n    /// @notice execute on behalf of the contract.\r\n    /// @param to destination address fo the call.\r\n    /// @param gasLimit exact amount of gas to be passed to the call.\r\n    /// @param data the bytes sent to the destination address.\r\n    /// @return success whether the execution was successful.\r\n    /// @return returnData data resulting from the execution.\r\n    function executeWithSpecificGas(address to, uint256 gasLimit, bytes calldata data) external returns (bool success, bytes memory returnData) {\r\n        require(_executionOperators[msg.sender], \"only execution operators allowed to execute on Dotori behalf\");\r\n        (success, returnData) = to.call.gas(gasLimit)(data);\r\n        assert(gasleft() > gasLimit / 63); // not enough gas provided, assert to throw all gas // TODO use EIP-1930\r\n    }\r\n\r\n    /// @notice approve a specific amount of token for `from` and execute on behalf of the contract.\r\n    /// @param from address of which token will be transfered.\r\n    /// @param to destination address fo the call.\r\n    /// @param amount number of tokens allowed that can be transfer by the code at `to`.\r\n    /// @param gasLimit exact amount of gas to be passed to the call.\r\n    /// @param data the bytes sent to the destination address.\r\n    /// @return success whether the execution was successful.\r\n    /// @return returnData data resulting from the execution.\r\n    function approveAndExecuteWithSpecificGas(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 gasLimit,\r\n        bytes calldata data\r\n    ) external returns (bool success, bytes memory returnData) {\r\n        require(_executionOperators[msg.sender], \"only execution operators allowed to execute on Dotori behalf\");\r\n        return _approveAndExecuteWithSpecificGas(from, to, amount, gasLimit, data);\r\n    }\r\n\r\n    /// @dev the reason for this function is that charging for gas here is more gas-efficient than doing it in the caller.\r\n    /// @notice approve a specific amount of token for `from` and execute on behalf of the contract. Plus charge the gas required to perform it.\r\n    /// @param from address of which token will be transfered.\r\n    /// @param to destination address fo the call.\r\n    /// @param amount number of tokens allowed that can be transfer by the code at `to`.\r\n    /// @param gasLimit exact amount of gas to be passed to the call.\r\n    /// @param tokenGasPrice price in token for the gas to be charged.\r\n    /// @param baseGasCharge amount of gas charged on top of the gas used for the call.\r\n    /// @param tokenReceiver recipient address of the token charged for the gas used.\r\n    /// @param data the bytes sent to the destination address.\r\n    /// @return success whether the execution was successful.\r\n    /// @return returnData data resulting from the execution.\r\n    function approveAndExecuteWithSpecificGasAndChargeForIt(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 gasLimit,\r\n        uint256 tokenGasPrice,\r\n        uint256 baseGasCharge,\r\n        address tokenReceiver,\r\n        bytes calldata data\r\n    ) external returns (bool success, bytes memory returnData) {\r\n        uint256 initialGas = gasleft();\r\n        require(_executionOperators[msg.sender], \"only execution operators allowed to execute on Dotori behalf\");\r\n        (success, returnData) = _approveAndExecuteWithSpecificGas(from, to, amount, gasLimit, data);\r\n        if (tokenGasPrice > 0) {\r\n            _charge(from, gasLimit, tokenGasPrice, initialGas, baseGasCharge, tokenReceiver);\r\n        }\r\n    }\r\n\r\n    /// @notice transfer 1amount1 token from `from` to `to` and charge the gas required to perform that transfer.\r\n    /// @param from address of which token will be transfered.\r\n    /// @param to destination address fo the call.\r\n    /// @param amount number of tokens allowed that can be transfer by the code at `to`.\r\n    /// @param gasLimit exact amount of gas to be passed to the call.\r\n    /// @param tokenGasPrice price in token for the gas to be charged.\r\n    /// @param baseGasCharge amount of gas charged on top of the gas used for the call.\r\n    /// @param tokenReceiver recipient address of the token charged for the gas used.\r\n    /// @return whether the transfer was successful.\r\n    function transferAndChargeForGas(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 gasLimit,\r\n        uint256 tokenGasPrice,\r\n        uint256 baseGasCharge,\r\n        address tokenReceiver\r\n    ) external returns (bool) {\r\n        uint256 initialGas = gasleft();\r\n        require(_executionOperators[msg.sender], \"only execution operators allowed to perfrom transfer and charge\");\r\n        _transfer(from, to, amount);\r\n        if (tokenGasPrice > 0) {\r\n            _charge(from, gasLimit, tokenGasPrice, initialGas, baseGasCharge, tokenReceiver);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function _charge(\r\n        address from,\r\n        uint256 gasLimit,\r\n        uint256 tokenGasPrice,\r\n        uint256 initialGas,\r\n        uint256 baseGasCharge,\r\n        address tokenReceiver\r\n    ) internal {\r\n        uint256 gasCharge = initialGas - gasleft();\r\n        if(gasCharge > gasLimit) {\r\n            gasCharge = gasLimit;\r\n        }\r\n        gasCharge += baseGasCharge;\r\n        uint256 tokensToCharge = gasCharge * tokenGasPrice;\r\n        require(tokensToCharge / gasCharge == tokenGasPrice, \"overflow\");\r\n        _transfer(from, tokenReceiver, tokensToCharge);\r\n    }\r\n\r\n    function _approveAndExecuteWithSpecificGas(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 gasLimit,\r\n        bytes memory data\r\n    ) internal returns (bool success, bytes memory returnData) {\r\n\r\n        if (amount > 0) {\r\n            _addAllowanceIfNeeded(from, to, amount);\r\n        }\r\n        (success, returnData) = to.call.gas(gasLimit)(data);\r\n        assert(gasleft() > gasLimit / 63); // not enough gas provided, assert to throw all gas // TODO use EIP-1930\r\n    }\r\n\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal;\r\n    function _addAllowanceIfNeeded(address owner, address spender, uint256 amountNeeded) internal;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Dotori is ERC20ExecuteExtension, ERC20BasicApproveExtension, ERC20BaseToken {\r\n\r\n    constructor(address DotoriAdmin, address executionAdmin, address beneficiary) public {\r\n        _admin = DotoriAdmin;\r\n        _executionAdmin = executionAdmin;\r\n        _mint(beneficiary, 10000000000000000000000000000);\r\n    }\r\n\r\n    /// @notice A descriptive name for the tokens\r\n    /// @return name of the tokens\r\n    function name() public view returns (string memory) {\r\n        return \"Dotori\";\r\n    }\r\n\r\n    /// @notice An abbreviated name for the tokens\r\n    /// @return symbol of the tokens\r\n    function symbol() public view returns (string memory) {\r\n        return \"DTR\";\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeExecutionAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFor\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amountNeeded\",\"type\":\"uint256\"}],\"name\":\"addAllowanceIfNeeded\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isExecutionOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isSuperOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"executionOperator\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setExecutionOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndExecuteWithSpecificGas\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"superOperator\",\"type\":\"address\"},{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setSuperOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExecutionAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"paidCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"name\":\"baseGasCharge\",\"type\":\"uint256\"},{\"name\":\"tokenReceiver\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndExecuteWithSpecificGasAndChargeForIt\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeWithSpecificGas\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"},{\"name\":\"returnData\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"name\":\"baseGasCharge\",\"type\":\"uint256\"},{\"name\":\"tokenReceiver\",\"type\":\"address\"}],\"name\":\"transferAndChargeForGas\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"DotoriAdmin\",\"type\":\"address\"},{\"name\":\"executionAdmin\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"superOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SuperOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"ExecutionAdminAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"executionOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"ExecutionOperator\",\"type\":\"event\"}]", "ContractName": "Dotori", "CompilerVersion": "v0.5.2+commit.1df8f40c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008cd16787d2015af4fa95e82a9d047f0fa7797df00000000000000000000000008cd16787d2015af4fa95e82a9d047f0fa7797df00000000000000000000000008cd16787d2015af4fa95e82a9d047f0fa7797df0", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://9f0ad23270f4428a92d664bde045adc0e830faf0e310cc29798bf0e2f67a50f9"}]}