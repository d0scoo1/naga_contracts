{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/RewardMaster.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nimport \\\"./actions/RewardAdvisersList.sol\\\";\\nimport \\\"./interfaces/IActionMsgReceiver.sol\\\";\\nimport \\\"./interfaces/IErc20Min.sol\\\";\\nimport \\\"./interfaces/IRewardAdviser.sol\\\";\\nimport \\\"./interfaces/IRewardPool.sol\\\";\\nimport \\\"./utils/ImmutableOwnable.sol\\\";\\nimport \\\"./utils/Claimable.sol\\\";\\nimport \\\"./utils/NonReentrant.sol\\\";\\nimport \\\"./utils/Utils.sol\\\";\\n\\n/***\\n * @title RewardMaster\\n * @notice It accounts rewards and distributes reward tokens to users.\\n * @dev It withdraws the reward token from (or via) the \\\"REWARD_POOL\\\" contract,\\n * and keeps tokens, aka \\\"Treasury\\\", on its balance until distribution.\\n * It issues to users \\\"shares\\\" in the Treasury, or redeems shares, paying out\\n * tokens from the Treasury to users, or on behalf of users, as follows.\\n * It receives messages (calls) on \\\"actions\\\" to be rewarded from authorized\\n * \\\"ActionOracle\\\" contracts.\\n * On every \\\"action\\\" message received, it calls a \\\"RewardAdviser\\\" contract,\\n * assigned for that ActionOracle and action type, which advices on how many\\n * shares shall be created and to whom, or whose shares must be redeemed, and\\n * where reward tokens shall be sent to.\\n * The owner may add or remove addresses of ActionOracle`s and RewardAdviser`s.\\n */\\ncontract RewardMaster is\\n    ImmutableOwnable,\\n    Utils,\\n    Claimable,\\n    NonReentrant,\\n    RewardAdvisersList,\\n    IActionMsgReceiver\\n{\\n    // solhint-disable var-name-mixedcase\\n\\n    /// @notice Token rewards are given in\\n    address public immutable REWARD_TOKEN;\\n\\n    /// @notice RewardPool instance that vests the reward token\\n    address public immutable REWARD_POOL;\\n\\n    /// @dev Block the contract deployed in\\n    uint256 public immutable START_BLOCK;\\n\\n    // solhint-enable var-name-mixedcase\\n\\n    /**\\n     * At any time, the amount of the reward token a user is entitled to is:\\n     *   tokenAmountEntitled = accumRewardPerShare * user.shares - user.offset\\n     *\\n     * This formula works since we update parameters as follows ...\\n     *\\n     * - when a new reward token amount added to the Treasury:\\n     *   accumRewardPerShare += tokenAmountAdded / totalShares\\n     *\\n     * - when new shares granted to a user:\\n     *   user.offset += sharesToCreate * accumRewardPerShare\\n     *   user.shares += sharesToCreate\\n     *   totalShares += sharesToCreate\\n     *\\n     * - when shares redeemed to a user:\\n     *   redemptionRate = accumRewardPerShare - user.offset/user.shares\\n     *   user.offset -= user.offset/user.shares * sharesToRedeem\\n     *   user.shares -= sharesToRedeem\\n     *   totalShares -= sharesToRedeem\\n     *   tokenAmountPayable = redemptionRate * sharesToRedeem\\n     *\\n     * (Scaling omitted in formulas above for clarity.)\\n     */\\n\\n    /// @dev Block when reward tokens were last time were vested in\\n    uint32 public lastVestedBlock;\\n    /// @dev Reward token balance (aka Treasury) after last vesting\\n    /// (token total supply is supposed to not exceed 2**96)\\n    uint96 public lastBalance;\\n\\n    /// @notice Total number of unredeemed shares\\n    /// (it is supposed to not exceed 2**128)\\n    uint128 public totalShares;\\n    /// @dev Min number of unredeemed shares being rewarded\\n    uint256 private constant MIN_SHARES_REWARDED = 1000;\\n    /// @dev Min number of blocks between vesting in the Treasury\\n    uint256 private constant MIN_VESTING_BLOCKS = 300;\\n\\n    // see comments above for explanation\\n    uint256 public accumRewardPerShare;\\n    // `accumRewardPerShare` is scaled (up) with this factor\\n    uint256 private constant SCALE = 1e9;\\n\\n    // see comments above for explanation\\n    struct UserRecord {\\n        // (limited to 2**96)\\n        uint96 shares;\\n        uint160 offset;\\n    }\\n\\n    // Mapping from user address to UserRecord data\\n    mapping(address => UserRecord) public records;\\n\\n    /// @dev Emitted when new shares granted to a user\\n    event SharesGranted(address indexed user, uint256 amount);\\n    /// @dev Emitted when shares of a user redeemed\\n    event SharesRedeemed(address indexed user, uint256 amount);\\n    /// @dev Emitted when new reward token amount vested to this contract\\n    event RewardAdded(uint256 reward);\\n    /// @dev Emitted when reward token amount paid to/for a user\\n    event RewardPaid(address indexed user, uint256 reward);\\n    /// @dev Emitted when the Treasury counts for \\\"extra\\\" reward tokens.\\n    /// \\\"Extra\\\" tokens are ones sent to this contract directly (rather than\\n    /// vested via the REWARD_POOL).\\n    event BalanceAdjusted(uint256 adjustment);\\n\\n    constructor(\\n        address _rewardToken,\\n        address _rewardPool,\\n        address _owner\\n    ) ImmutableOwnable(_owner) {\\n        require(\\n            _rewardToken != address(0) && _rewardPool != address(0),\\n            \\\"RM:C1\\\"\\n        );\\n\\n        REWARD_TOKEN = _rewardToken;\\n        REWARD_POOL = _rewardPool;\\n        START_BLOCK = blockNow();\\n    }\\n\\n    /// @notice Returns reward token amount entitled to the given user/account\\n    // This amount the account would get if shares would be redeemed now\\n    function entitled(address account) public view returns (uint256 reward) {\\n        UserRecord memory rec = records[account];\\n        if (rec.shares == 0) return 0;\\n\\n        // no reentrancy guard needed for the known contract call\\n        uint256 releasable = IRewardPool(REWARD_POOL).releasableAmount();\\n        uint256 _accumRewardPerShare = accumRewardPerShare;\\n        uint256 _totalShares = uint256(totalShares);\\n        if (releasable != 0 && _totalShares >= MIN_SHARES_REWARDED) {\\n            _accumRewardPerShare += (releasable * SCALE) / _totalShares;\\n        }\\n\\n        (reward, , ) = _computeRedemption(\\n            uint256(rec.shares),\\n            rec,\\n            _accumRewardPerShare\\n        );\\n    }\\n\\n    function onAction(bytes4 action, bytes memory message) external override {\\n        IRewardAdviser adviser = _getRewardAdviserOrRevert(msg.sender, action);\\n        // no reentrancy guard needed for the known contract call\\n        IRewardAdviser.Advice memory advice = adviser.getRewardAdvice(\\n            action,\\n            message\\n        );\\n        if (advice.sharesToCreate > 0) {\\n            _grantShares(advice.createSharesFor, advice.sharesToCreate);\\n        }\\n        if (advice.sharesToRedeem > 0) {\\n            _redeemShares(\\n                advice.redeemSharesFrom,\\n                advice.sharesToRedeem,\\n                advice.sendRewardTo\\n            );\\n        }\\n    }\\n\\n    function triggerVesting() external {\\n        _triggerVesting(true, false);\\n    }\\n\\n    /* ========== ONLY FOR OWNER FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Adds the \\\"RewardAdviser\\\" for given ActionOracle and action type\\n     * @dev May be only called by the {OWNER}\\n     * !!!!! Before adding a new \\\"adviser\\\", ensure \\\"shares\\\" it \\\"advices\\\" can not\\n     * overflow `UserRecord.shares`, `UserRecord.offset` and `totalShares`.\\n     */\\n    function addRewardAdviser(\\n        address oracle,\\n        bytes4 action,\\n        address adviser\\n    ) external onlyOwner {\\n        _addRewardAdviser(oracle, action, adviser);\\n    }\\n\\n    /// @notice Remove \\\"RewardAdviser\\\" for given ActionOracle and action type\\n    /// @dev May be only called by the {OWNER}\\n    function removeRewardAdviser(address oracle, bytes4 action)\\n        external\\n        onlyOwner\\n    {\\n        _removeRewardAdviser(oracle, action);\\n    }\\n\\n    /// @notice Withdraws accidentally sent token from this contract\\n    /// @dev May be only called by the {OWNER}\\n    function claimErc20(\\n        address claimedToken,\\n        address to,\\n        uint256 amount\\n    ) external onlyOwner nonReentrant {\\n        if (claimedToken == address(REWARD_TOKEN)) {\\n            // Not allowed if unclaimed shares remain\\n            require(totalShares == 0, \\\"RM: Failed to claim\\\");\\n        }\\n        _claimErc20(claimedToken, to, amount);\\n    }\\n\\n    /* ========== INTERNAL & PRIVATE FUNCTIONS ========== */\\n\\n    function _computeRedemption(\\n        uint256 sharesToRedeem,\\n        UserRecord memory rec,\\n        uint256 _accumRewardPerShare\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 reward,\\n            uint256 newShares,\\n            uint256 newOffset\\n        )\\n    {\\n        // `rec.shares` and `sharesToRedeem` are assumed to be non-zero here,\\n        // and `sharesToRedeem` does not exceed `rec.shares`\\n        newShares = uint256(rec.shares) - sharesToRedeem;\\n\\n        uint256 offsetRedeemed = newShares == 0\\n            ? uint256(rec.offset)\\n            : (uint256(rec.offset) * sharesToRedeem) / uint256(rec.shares);\\n        newOffset = uint256(rec.offset) - offsetRedeemed;\\n\\n        reward = 0;\\n        if (_accumRewardPerShare != 0) {\\n            reward = (sharesToRedeem * _accumRewardPerShare) / SCALE;\\n            // avoid eventual overflow resulted from rounding\\n            reward -= reward >= offsetRedeemed ? offsetRedeemed : reward;\\n        }\\n    }\\n\\n    function _grantShares(address to, uint256 shares)\\n        internal\\n        nonZeroAmount(shares)\\n        nonZeroAddress(to)\\n    {\\n        (uint256 _accumRewardPerShare, , ) = _triggerVesting(true, true);\\n\\n        UserRecord memory rec = records[to];\\n        uint256 newOffset = uint256(rec.offset) +\\n            (shares * _accumRewardPerShare) /\\n            SCALE;\\n        uint256 newShares = uint256(rec.shares) + shares;\\n\\n        records[to] = UserRecord(safe96(newShares), safe160(newOffset));\\n        totalShares = safe128(uint256(totalShares) + shares);\\n\\n        emit SharesGranted(to, shares);\\n    }\\n\\n    function _redeemShares(\\n        address from,\\n        // `shares` assumed to be non-zero\\n        uint256 shares,\\n        address to\\n    ) internal nonZeroAmount(shares) nonZeroAddress(from) nonZeroAddress(to) {\\n        UserRecord memory rec = records[from];\\n        require(rec.shares >= shares, \\\"RM: Not enough shares to redeem\\\");\\n\\n        (\\n            uint256 _accumRewardPerShare,\\n            uint256 newBalance,\\n            uint256 oldBalance\\n        ) = _triggerVesting(false, true);\\n\\n        (\\n            uint256 reward,\\n            uint256 newShares,\\n            uint256 newOffset\\n        ) = _computeRedemption(shares, rec, _accumRewardPerShare);\\n\\n        records[from] = UserRecord(safe96(newShares), safe160(newOffset));\\n        totalShares = safe128(uint256(totalShares) - shares);\\n\\n        uint256 _lastBalance = newBalance - reward;\\n        if (oldBalance != _lastBalance) {\\n            lastBalance = safe96(_lastBalance);\\n        }\\n\\n        if (reward != 0) {\\n            // known contract - nether reentrancy guard nor safeTransfer required\\n            require(\\n                IErc20Min(REWARD_TOKEN).transfer(to, reward),\\n                \\\"RM: Internal transfer failed\\\"\\n            );\\n            emit RewardPaid(to, reward);\\n        }\\n\\n        emit SharesRedeemed(from, shares);\\n    }\\n\\n    function _triggerVesting(\\n        bool isLastBalanceToBeUpdated,\\n        bool isMinVestingBlocksApplied\\n    )\\n        internal\\n        returns (\\n            uint256 newAccumRewardPerShare,\\n            uint256 newBalance,\\n            uint256 oldBalance\\n        )\\n    {\\n        uint32 _blockNow = safe32BlockNow();\\n        newAccumRewardPerShare = accumRewardPerShare;\\n        oldBalance = uint256(lastBalance);\\n        uint256 _totalShares = totalShares;\\n\\n        uint32 blocksPast = _blockNow - lastVestedBlock;\\n        if (\\n            (blocksPast == 0) ||\\n            (isMinVestingBlocksApplied && blocksPast < MIN_VESTING_BLOCKS) ||\\n            _totalShares < MIN_SHARES_REWARDED\\n        ) {\\n            // Do not request vesting from the REWARD_POOL\\n            return (newAccumRewardPerShare, oldBalance, oldBalance);\\n        }\\n\\n        // known contracts, no reentrancy guard needed\\n        uint256 newlyVested = IRewardPool(REWARD_POOL).vestRewards();\\n        newBalance = IErc20Min(REWARD_TOKEN).balanceOf(address(this));\\n\\n        uint256 expectedBalance = oldBalance + newlyVested;\\n        if (newBalance > expectedBalance) {\\n            // somebody transferred tokens to this contract directly\\n            uint256 adjustment = newBalance - expectedBalance;\\n            newlyVested += adjustment;\\n            emit BalanceAdjusted(adjustment);\\n        }\\n        if (newlyVested != 0) {\\n            newAccumRewardPerShare += (newlyVested * SCALE) / _totalShares;\\n            accumRewardPerShare = newAccumRewardPerShare;\\n            emit RewardAdded(newlyVested);\\n        }\\n        lastVestedBlock = _blockNow;\\n        if (isLastBalanceToBeUpdated && (oldBalance != newBalance)) {\\n            lastBalance = safe96(newBalance);\\n        }\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier nonZeroAmount(uint256 amount) {\\n        require(amount > 0, \\\"RM: Zero amount provided\\\");\\n        _;\\n    }\\n\\n    modifier nonZeroAddress(address account) {\\n        require(account != address(0), \\\"RM: Zero address provided\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/RewardAdvisersList.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IRewardAdviser.sol\\\";\\n\\n/**\\n * @title ActionControllers\\n * @notice It maintains a list of \\\"ActionOracle\\\" and \\\"RewardAdviser\\\" instances.\\n * For a tuple of ActionOracle address and action type, an RewardAdviser\\n * instance of  may be mapped.\\n */\\nabstract contract RewardAdvisersList {\\n    /// @dev Emitted when RewardAdviser added, updated, or removed\\n    event AdviserUpdated(\\n        address indexed oracle,\\n        bytes4 indexed action,\\n        address adviser\\n    );\\n\\n    /// @dev mapping from ActionOracle and (type of) action to ActionController\\n    mapping(address => mapping(bytes4 => address)) public rewardAdvisers;\\n\\n    function _addRewardAdviser(\\n        address oracle,\\n        bytes4 action,\\n        address adviser\\n    ) internal {\\n        require(\\n            oracle != address(0) &&\\n                adviser != address(0) &&\\n                action != bytes4(0),\\n            \\\"ACM:E1\\\"\\n        );\\n        require(rewardAdvisers[oracle][action] == address(0), \\\"ACM:E2\\\");\\n        rewardAdvisers[oracle][action] = adviser;\\n        emit AdviserUpdated(oracle, action, adviser);\\n    }\\n\\n    function _removeRewardAdviser(address oracle, bytes4 action) internal {\\n        require(rewardAdvisers[oracle][action] != address(0), \\\"ACM:E3\\\");\\n        rewardAdvisers[oracle][action] = address(0);\\n        emit AdviserUpdated(oracle, action, address(0));\\n    }\\n\\n    function _getRewardAdviserOrRevert(address oracle, bytes4 action)\\n        internal\\n        view\\n        returns (IRewardAdviser)\\n    {\\n        address adviser = rewardAdvisers[oracle][action];\\n        require(adviser != address(0), \\\"ACM:E4\\\");\\n        return IRewardAdviser(adviser);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IActionMsgReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IActionMsgReceiver {\\n    function onAction(bytes4 action, bytes memory message) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IErc20Min.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IErc20Min {\\n    /// @dev ERC-20 `balanceOf`\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @dev ERC-20 `transfer`\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /// @dev ERC-20 `transferFrom`\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @dev EIP-2612 `permit`\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardAdviser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IRewardAdviser {\\n    struct Advice {\\n        // advice on new \\\"shares\\\" (in the reward pool) to create\\n        address createSharesFor;\\n        uint96 sharesToCreate;\\n        // advice on \\\"shares\\\" to redeem\\n        address redeemSharesFrom;\\n        uint96 sharesToRedeem;\\n        // advice on address the reward against redeemed shares to send to\\n        address sendRewardTo;\\n    }\\n\\n    function getRewardAdvice(bytes4 action, bytes memory message)\\n        external\\n        returns (Advice memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRewardPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n// SPDX-FileCopyrightText: Copyright 2021-22 Panther Ventures Limited Gibraltar\\npragma solidity ^0.8.0;\\n\\ninterface IRewardPool {\\n    /// @notice Returns token amount that may be released (vested) now\\n    function releasableAmount() external view returns (uint256);\\n\\n    /// @notice Vests releasable token amount to the {recipient}\\n    /// @dev {recipient} only may call\\n    function vestRewards() external returns (uint256 amount);\\n\\n    /// @notice Emitted on vesting to the {recipient}\\n    event Vested(uint256 amount);\\n\\n    /// @notice Emitted on parameters initialized.\\n    event Initialized(uint256 _poolId, address _recipient, uint256 _endTime);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ImmutableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\n/// @title Staking\\nabstract contract ImmutableOwnable {\\n    /// @notice The owner who has privileged rights\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable OWNER;\\n\\n    /// @dev Throws if called by any account other than the {OWNER}.\\n    modifier onlyOwner() {\\n        require(OWNER == msg.sender, \\\"ImmOwn: unauthorized\\\");\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        require(_owner != address(0), \\\"ImmOwn: zero owner address\\\");\\n        OWNER = _owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Claimable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Claimable\\n * @notice It withdraws accidentally sent tokens from this contract.\\n */\\ncontract Claimable {\\n    bytes4 private constant SELECTOR_TRANSFER =\\n        bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\n    /// @dev Withdraws ERC20 tokens from this contract\\n    /// (take care of reentrancy attack risk mitigation)\\n    function _claimErc20(\\n        address token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory data) = token.call(\\n            abi.encodeWithSelector(SELECTOR_TRANSFER, to, amount)\\n        );\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"claimErc20: TRANSFER_FAILED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/NonReentrant.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title NonReentrant\\n * @notice It provides reentrancy guard.\\n * The code borrowed from openzeppelin-contracts.\\n * Unlike original, this version requires neither `constructor` no `init` call.\\n */\\nabstract contract NonReentrant {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _reentrancyStatus;\\n\\n    modifier nonReentrant() {\\n        // Being called right after deployment, when _reentrancyStatus is 0 ,\\n        // it does not revert (which is expected behaviour)\\n        require(_reentrancyStatus != _ENTERED, \\\"claimErc20: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _reentrancyStatus = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _reentrancyStatus = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nabstract contract Utils {\\n    function safe32(uint256 n) internal pure returns (uint32) {\\n        require(n < 2**32, \\\"UNSAFE32\\\");\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint256 n) internal pure returns (uint96) {\\n        require(n < 2**96, \\\"UNSAFE96\\\");\\n        return uint96(n);\\n    }\\n\\n    function safe128(uint256 n) internal pure returns (uint128) {\\n        require(n < 2**128, \\\"UNSAFE128\\\");\\n        return uint128(n);\\n    }\\n\\n    function safe160(uint256 n) internal pure returns (uint160) {\\n        require(n < 2**160, \\\"UNSAFE160\\\");\\n        return uint160(n);\\n    }\\n\\n    function safe32TimeNow() internal view returns (uint32) {\\n        return safe32(timeNow());\\n    }\\n\\n    function safe32BlockNow() internal view returns (uint32) {\\n        return safe32(blockNow());\\n    }\\n\\n    /// @dev Returns the current block timestamp (added to ease testing)\\n    function timeNow() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @dev Returns the current block number (added to ease testing)\\n    function blockNow() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"action\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"adviser\",\"type\":\"address\"}],\"name\":\"AdviserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"adjustment\",\"type\":\"uint256\"}],\"name\":\"BalanceAdjusted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SharesGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SharesRedeemed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accumRewardPerShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"action\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"adviser\",\"type\":\"address\"}],\"name\":\"addRewardAdviser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimedToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"entitled\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastBalance\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastVestedBlock\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"action\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"onAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"shares\",\"type\":\"uint96\"},{\"internalType\":\"uint160\",\"name\":\"offset\",\"type\":\"uint160\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"action\",\"type\":\"bytes4\"}],\"name\":\"removeRewardAdviser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"rewardAdvisers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardMaster", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000909e34d3f6124c324ac83dcca84b74398a6fa173000000000000000000000000cf463713521af5ce31ad18f6914f3706493f10e5000000000000000000000000505796f5bc290269d2522cf19135ad7aa60dfd77", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}