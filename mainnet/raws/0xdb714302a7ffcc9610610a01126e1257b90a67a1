{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NestedRecords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"./abstracts/OwnableFactoryHandler.sol\\\";\\n\\n/// @title Tracks data for underlying assets of NestedNFTs\\ncontract NestedRecords is OwnableFactoryHandler {\\n    /* ------------------------------ EVENTS ------------------------------ */\\n\\n    /// @dev Emitted when maxHoldingsCount is updated\\n    /// @param maxHoldingsCount The new value\\n    event MaxHoldingsChanges(uint256 maxHoldingsCount);\\n\\n    /// @dev Emitted when the lock timestamp of an NFT is increased\\n    /// @param nftId The NFT ID\\n    /// @param timestamp The new lock timestamp of the portfolio\\n    event LockTimestampIncreased(uint256 nftId, uint256 timestamp);\\n\\n    /// @dev Emitted when the reserve is updated for a specific portfolio\\n    /// @param nftId The NFT ID\\n    /// @param newReserve The new reserve address\\n    event ReserveUpdated(uint256 nftId, address newReserve);\\n\\n    /* ------------------------------ STRUCTS ------------------------------ */\\n\\n    /// @dev Store user asset informations\\n    struct NftRecord {\\n        mapping(address => uint256) holdings;\\n        address[] tokens;\\n        address reserve;\\n        uint256 lockTimestamp;\\n    }\\n\\n    /* ----------------------------- VARIABLES ----------------------------- */\\n\\n    /// @dev stores for each NFT ID an asset record\\n    mapping(uint256 => NftRecord) public records;\\n\\n    /// @dev The maximum number of holdings for an NFT record\\n    uint256 public maxHoldingsCount;\\n\\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\\n\\n    constructor(uint256 _maxHoldingsCount) {\\n        maxHoldingsCount = _maxHoldingsCount;\\n    }\\n\\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\\n\\n    /// @notice Sets the maximum number of holdings for an NFT record\\n    /// @param _maxHoldingsCount The new maximum number of holdings\\n    function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {\\n        require(_maxHoldingsCount != 0, \\\"NRC: INVALID_MAX_HOLDINGS\\\");\\n        maxHoldingsCount = _maxHoldingsCount;\\n        emit MaxHoldingsChanges(maxHoldingsCount);\\n    }\\n\\n    /* ------------------------- FACTORY FUNCTIONS ------------------------- */\\n\\n    /// @notice Update the amount for a specific holding and delete\\n    /// the holding if the amount is zero.\\n    /// @param _nftId The id of the NFT\\n    /// @param _token The token/holding address\\n    /// @param _amount Updated amount for this asset\\n    function updateHoldingAmount(\\n        uint256 _nftId,\\n        address _token,\\n        uint256 _amount\\n    ) public onlyFactory {\\n        if (_amount == 0) {\\n            uint256 tokenIndex = 0;\\n            address[] memory tokens = getAssetTokens(_nftId);\\n            while (tokenIndex < tokens.length) {\\n                if (tokens[tokenIndex] == _token) {\\n                    deleteAsset(_nftId, tokenIndex);\\n                    break;\\n                }\\n                tokenIndex++;\\n            }\\n        } else {\\n            records[_nftId].holdings[_token] = _amount;\\n        }\\n    }\\n\\n    /// @notice Fully delete a holding record for an NFT\\n    /// @param _nftId The id of the NFT\\n    /// @param _tokenIndex The token index in holdings array\\n    function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {\\n        address[] storage tokens = records[_nftId].tokens;\\n        address token = tokens[_tokenIndex];\\n\\n        require(records[_nftId].holdings[token] != 0, \\\"NRC: HOLDING_INACTIVE\\\");\\n\\n        delete records[_nftId].holdings[token];\\n        tokens[_tokenIndex] = tokens[tokens.length - 1];\\n        tokens.pop();\\n    }\\n\\n    /// @notice Delete a holding item in holding mapping. Does not remove token in NftRecord.tokens array\\n    /// @param _nftId NFT's identifier\\n    /// @param _token Token address for holding to remove\\n    function freeHolding(uint256 _nftId, address _token) public onlyFactory {\\n        delete records[_nftId].holdings[_token];\\n    }\\n\\n    /// @notice Helper function that creates a record or add the holding if record already exists\\n    /// @param _nftId The NFT's identifier\\n    /// @param _token The token/holding address\\n    /// @param _amount Amount to add for this asset\\n    /// @param _reserve Reserve address\\n    function store(\\n        uint256 _nftId,\\n        address _token,\\n        uint256 _amount,\\n        address _reserve\\n    ) external onlyFactory {\\n        NftRecord storage _nftRecord = records[_nftId];\\n\\n        uint256 amount = records[_nftId].holdings[_token];\\n        require(_amount != 0, \\\"NRC: INVALID_AMOUNT\\\");\\n        if (amount != 0) {\\n            require(_nftRecord.reserve == _reserve, \\\"NRC: RESERVE_MISMATCH\\\");\\n            updateHoldingAmount(_nftId, _token, amount + _amount);\\n            return;\\n        }\\n        require(_nftRecord.tokens.length < maxHoldingsCount, \\\"NRC: TOO_MANY_TOKENS\\\");\\n        require(\\n            _reserve != address(0) && (_reserve == _nftRecord.reserve || _nftRecord.reserve == address(0)),\\n            \\\"NRC: INVALID_RESERVE\\\"\\n        );\\n\\n        _nftRecord.holdings[_token] = _amount;\\n        _nftRecord.tokens.push(_token);\\n        _nftRecord.reserve = _reserve;\\n    }\\n\\n    /// @notice The factory can update the lock timestamp of a NFT record\\n    /// The new timestamp must be greater than the records lockTimestamp\\n    //  if block.timestamp > actual lock timestamp\\n    /// @param _nftId The NFT id to get the record\\n    /// @param _timestamp The new timestamp\\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external onlyFactory {\\n        require(_timestamp > records[_nftId].lockTimestamp, \\\"NRC: LOCK_PERIOD_CANT_DECREASE\\\");\\n        records[_nftId].lockTimestamp = _timestamp;\\n        emit LockTimestampIncreased(_nftId, _timestamp);\\n    }\\n\\n    /// @notice Delete from mapping assetTokens\\n    /// @param _nftId The id of the NFT\\n    function removeNFT(uint256 _nftId) external onlyFactory {\\n        delete records[_nftId];\\n    }\\n\\n    /// @notice Set the reserve where assets are stored\\n    /// @param _nftId The NFT ID to update\\n    /// @param _nextReserve Address for the new reserve\\n    function setReserve(uint256 _nftId, address _nextReserve) external onlyFactory {\\n        records[_nftId].reserve = _nextReserve;\\n        emit ReserveUpdated(_nftId, _nextReserve);\\n    }\\n\\n    /* ------------------------------- VIEWS ------------------------------- */\\n\\n    /// @notice Get content of assetTokens mapping\\n    /// @param _nftId The id of the NFT\\n    /// @return Array of token addresses\\n    function getAssetTokens(uint256 _nftId) public view returns (address[] memory) {\\n        return records[_nftId].tokens;\\n    }\\n\\n    /// @notice Get reserve the assets are stored in\\n    /// @param _nftId The NFT ID\\n    /// @return The reserve address these assets are stored in\\n    function getAssetReserve(uint256 _nftId) external view returns (address) {\\n        return records[_nftId].reserve;\\n    }\\n\\n    /// @notice Get how many tokens are in a portfolio/NFT\\n    /// @param _nftId NFT ID to examine\\n    /// @return The array length\\n    function getAssetTokensLength(uint256 _nftId) external view returns (uint256) {\\n        return records[_nftId].tokens.length;\\n    }\\n\\n    /// @notice Get holding amount for a given nft id\\n    /// @param _nftId The id of the NFT\\n    /// @param _token The address of the token\\n    /// @return The holding amount\\n    function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) {\\n        return records[_nftId].holdings[_token];\\n    }\\n\\n    /// @notice Returns the holdings associated to a NestedAsset\\n    /// @param _nftId the id of the NestedAsset\\n    /// @return Two arrays with the same length :\\n    ///         - The token addresses in the portfolio\\n    ///         - The respective amounts\\n    function tokenHoldings(uint256 _nftId) external view returns (address[] memory, uint256[] memory) {\\n        address[] memory tokens = getAssetTokens(_nftId);\\n        uint256 tokensCount = tokens.length;\\n        uint256[] memory amounts = new uint256[](tokensCount);\\n\\n        for (uint256 i = 0; i < tokensCount; i++) {\\n            amounts[i] = getAssetHolding(_nftId, tokens[i]);\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /// @notice Get the lock timestamp of a portfolio/NFT\\n    /// @param _nftId The NFT ID\\n    /// @return The lock timestamp from the NftRecord\\n    function getLockTimestamp(uint256 _nftId) external view returns (uint256) {\\n        return records[_nftId].lockTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/OwnableFactoryHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Asbtract \\\"Ownable\\\" contract managing a whitelist of factories\\nabstract contract OwnableFactoryHandler is Ownable {\\n    /// @dev Emitted when a new factory is added\\n    /// @param newFactory Address of the new factory\\n    event FactoryAdded(address newFactory);\\n\\n    /// @dev Emitted when a factory is removed\\n    /// @param oldFactory Address of the removed factory\\n    event FactoryRemoved(address oldFactory);\\n\\n    /// @dev Supported factories to interact with\\n    mapping(address => bool) public supportedFactories;\\n\\n    /// @dev Reverts the transaction if the caller is a supported factory\\n    modifier onlyFactory() {\\n        require(supportedFactories[msg.sender], \\\"OFH: FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    /// @notice Add a supported factory\\n    /// @param _factory The address of the new factory\\n    function addFactory(address _factory) external onlyOwner {\\n        require(_factory != address(0), \\\"OFH: INVALID_ADDRESS\\\");\\n        supportedFactories[_factory] = true;\\n        emit FactoryAdded(_factory);\\n    }\\n\\n    /// @notice Remove a supported factory\\n    /// @param _factory The address of the factory to remove\\n    function removeFactory(address _factory) external onlyOwner {\\n        require(supportedFactories[_factory], \\\"OFH: NOT_SUPPORTED\\\");\\n        supportedFactories[_factory] = false;\\n        emit FactoryRemoved(_factory);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxHoldingsCount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFactory\",\"type\":\"address\"}],\"name\":\"FactoryAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFactory\",\"type\":\"address\"}],\"name\":\"FactoryRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"LockTimestampIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxHoldingsCount\",\"type\":\"uint256\"}],\"name\":\"MaxHoldingsChanges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newReserve\",\"type\":\"address\"}],\"name\":\"ReserveUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"addFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenIndex\",\"type\":\"uint256\"}],\"name\":\"deleteAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"freeHolding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getAssetHolding\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getAssetReserve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getAssetTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getAssetTokensLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"getLockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHoldingsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"records\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"removeFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"removeNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxHoldingsCount\",\"type\":\"uint256\"}],\"name\":\"setMaxHoldingsCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nextReserve\",\"type\":\"address\"}],\"name\":\"setReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"store\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedFactories\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"}],\"name\":\"tokenHoldings\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateHoldingAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"updateLockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NestedRecords", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}