{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/resolvers/mainnet/v1/main.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract InstaVaultResolver {\\n    address internal constant wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    VaultInterface public immutable vault;\\n\\n    struct VaultInfo {\\n        address vaultAddr;\\n        address vaultDsa;\\n        uint256 revenue;\\n        uint256 revenueFee;\\n        VaultInterface.Ratios ratios;\\n        uint256 lastRevenueExchangePrice;\\n        uint256 exchangePrice;\\n        uint256 totalSupply;\\n        uint netCollateral;\\n        uint netBorrow;\\n        VaultInterface.BalVariables balances;\\n        uint netSupply;\\n        uint netBal;\\n    }\\n    \\n    function getVaultInfo()\\n        public\\n        view\\n        returns (VaultInfo memory vaultInfo_)\\n    {\\n        vaultInfo_.vaultAddr = address(vault);\\n        vaultInfo_.vaultDsa = vault.vaultDsa();\\n        vaultInfo_.revenue = vault.revenue();\\n        vaultInfo_.revenueFee = vault.revenueFee();\\n        vaultInfo_.ratios = vault.ratios();\\n        vaultInfo_.lastRevenueExchangePrice = vault.lastRevenueExchangePrice();\\n        (vaultInfo_.exchangePrice,) = vault.getCurrentExchangePrice();\\n        vaultInfo_.totalSupply = vault.totalSupply();\\n        (vaultInfo_.netCollateral, vaultInfo_.netBorrow, vaultInfo_.balances, vaultInfo_.netSupply, vaultInfo_.netBal) = vault.netAssets();\\n    }\\n\\n    function getUserInfo(address user_)\\n        public\\n        view\\n        returns (\\n            VaultInfo memory vaultInfo_,\\n            uint256 vtokenBal_,\\n            uint256 amount_\\n        )\\n    {\\n        vaultInfo_ = getVaultInfo();\\n        vtokenBal_ = vault.balanceOf(user_);\\n        amount_ = (vtokenBal_ * vaultInfo_.exchangePrice) / 1e18;\\n    }\\n\\n    struct RefinanceOneVariables {\\n        uint netCollateral;\\n        uint netBorrow;\\n        VaultInterface.BalVariables balances;\\n        uint netBal;\\n        uint netStEth;\\n        int netWeth;\\n        uint ratio;\\n        uint targetRatioDif;\\n    }\\n\\n    // This function gives data around leverage position\\n    function refinanceOneData() public view returns (\\n        uint finalCol_,\\n        uint finalDebt_,\\n        address flashTkn_,\\n        uint flashAmt_,\\n        uint excessDebt_,\\n        uint paybackDebt_,\\n        uint totalAmountToSwap_,\\n        uint extraWithdraw_,\\n        bool isRisky_\\n    ) {\\n        RefinanceOneVariables memory v_;\\n        (v_.netCollateral, v_.netBorrow, v_.balances, , v_.netBal) = vault.netAssets();\\n        if (v_.balances.wethVaultBal <= 1e14) v_.balances.wethVaultBal = 0;\\n        if (v_.balances.stethVaultBal <= 1e14) v_.balances.stethVaultBal = 0;\\n        VaultInterface.Ratios memory ratios_ = vault.ratios();\\n        v_.netStEth = v_.netCollateral + v_.balances.stethVaultBal + v_.balances.stethDsaBal;\\n        v_.netWeth = int(v_.balances.wethVaultBal + v_.balances.wethDsaBal) - int(v_.netBorrow);\\n        v_.ratio = v_.netWeth < 0 ? (uint(-v_.netWeth) * 1e4) / v_.netStEth : 0;\\n        v_.targetRatioDif = 10000 - (ratios_.minLimit - 10); // taking 0.1% more dif for margin\\n        if (v_.ratio < ratios_.minLimitGap) {\\n            // leverage till minLimit <> minLimitGap\\n            // final difference between collateral & debt in percent\\n            finalCol_ = (v_.netBal * 1e4) / v_.targetRatioDif;\\n            finalDebt_ = finalCol_ - v_.netBal;\\n            excessDebt_ = finalDebt_ - v_.netBorrow;\\n            flashTkn_ = wethAddr;\\n            flashAmt_ = (v_.netCollateral / 10) + (excessDebt_ * 10 / 8); // 10% of current collateral + excessDebt / 0.8\\n            totalAmountToSwap_ = excessDebt_ + v_.balances.wethVaultBal + v_.balances.wethDsaBal;\\n            // keeping as non collateral for easier withdrawals\\n            extraWithdraw_ = finalCol_ - ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n        } else {\\n            finalCol_ = v_.netStEth;\\n            finalDebt_ = uint(-v_.netWeth);\\n            paybackDebt_ = v_.balances.wethVaultBal + v_.balances.wethDsaBal;\\n            if (v_.ratio < (ratios_.maxLimit - 10)) {\\n                extraWithdraw_ = finalCol_ - ((finalDebt_ * 1e4) / (ratios_.maxLimit - 10));\\n            }\\n        }\\n        if (v_.ratio > ratios_.maxLimit) {\\n            isRisky_ = true;\\n        }\\n        if (excessDebt_ < 1e14) excessDebt_ = 0;\\n        if (paybackDebt_ < 1e14) paybackDebt_ = 0;\\n        if (totalAmountToSwap_ < 1e14) totalAmountToSwap_ = 0;\\n        if (extraWithdraw_ < 1e14) extraWithdraw_ = 0;\\n    }\\n\\n    constructor(address vaultAddr_) {\\n        vault = VaultInterface(vaultAddr_);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v1/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface VaultInterface {\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (\\n            uint256 exchangePrice_,\\n            uint256 newRevenue_\\n        );\\n    \\n    struct BalVariables {\\n        uint wethVaultBal;\\n        uint wethDsaBal;\\n        uint stethVaultBal;\\n        uint stethDsaBal;\\n        uint totalBal;\\n    }\\n\\n    function netAssets() external view returns (\\n        uint netCollateral_,\\n        uint netBorrow_,\\n        BalVariables memory balances_,\\n        uint netSupply_,\\n        uint netBal_\\n    );\\n\\n    struct Ratios {\\n        uint16 maxLimit; // Above this withdrawals are not allowed\\n        uint16 minLimit; // After leverage the ratio should be below minLimit & above minLimitGap\\n        uint16 minLimitGap;\\n        // send borrow rate in 4 decimals from UI. In the smart contract it'll convert to 27 decimals which where is 100%\\n        uint128 maxBorrowRate; // maximum borrow rate above this leveraging should not happen\\n    }\\n\\n    // maximum borrow rate. If above this limit then leverage won't happen\\n    function ratios() external view returns (Ratios memory);\\n\\n    function vaultDsa() external view returns (address);\\n\\n    function lastRevenueExchangePrice() external view returns (uint256);\\n\\n    function revenueFee() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBorrow\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBal\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultInterface.BalVariables\",\"name\":\"balances\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"netSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBal\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo_\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"vtokenBal_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBorrow\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDsaBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBal\",\"type\":\"uint256\"}],\"internalType\":\"struct VaultInterface.BalVariables\",\"name\":\"balances\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"netSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netBal\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refinanceOneData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalCol_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalDebt_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"flashTkn_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"excessDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paybackDebt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmountToSwap_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extraWithdraw_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isRisky_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract VaultInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstaVaultResolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c383a3833a87009fd9597f8184979af5edfad019", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}