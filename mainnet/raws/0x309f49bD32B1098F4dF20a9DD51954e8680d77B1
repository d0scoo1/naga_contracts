{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/bridge/Bridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice Holds the inbox accumulator for sequenced and delayed messages.\\n * It is also the ETH escrow for value sent with these messages.\\n * Since the escrow is held here, this contract also contains a list of allowed\\n * outboxes that can make calls from here and withdraw this escrow.\\n */\\ncontract Bridge is Initializable, DelegateCallAware, IBridge {\\n    using AddressUpgradeable for address;\\n\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedDelayedInboxesMap;\\n    mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedDelayedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address private _activeOutbox;\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    bytes32[] public override delayedInboxAccs;\\n\\n    /// @dev Accumulator for sequencer inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    bytes32[] public override sequencerInboxAccs;\\n\\n    IOwnable public override rollup;\\n    address public sequencerInbox;\\n\\n    address private constant EMPTY_ACTIVEOUTBOX = address(type(uint160).max);\\n\\n    function initialize(IOwnable rollup_) external initializer onlyDelegated {\\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\\n        rollup = rollup_;\\n    }\\n\\n    modifier onlyRollupOrOwner() {\\n        if (msg.sender != address(rollup)) {\\n            address rollupOwner = rollup.owner();\\n            if (msg.sender != rollupOwner) {\\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @dev returns the address of current active Outbox, or zero if no outbox is active\\n    function activeOutbox() public view returns (address) {\\n        address outbox = _activeOutbox;\\n        // address zero is returned if no outbox is set, but the value used in storage\\n        // is non-zero to save users some gas (as storage refunds are usually maxed out)\\n        // EIP-1153 would help here.\\n        // we don't return `EMPTY_ACTIVEOUTBOX` to avoid a breaking change on the current api\\n        if (outbox == EMPTY_ACTIVEOUTBOX) return address(0);\\n        return outbox;\\n    }\\n\\n    function allowedDelayedInboxes(address inbox) external view override returns (bool) {\\n        return allowedDelayedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address outbox) external view override returns (bool) {\\n        return allowedOutboxesMap[outbox].allowed;\\n    }\\n\\n    modifier onlySequencerInbox() {\\n        if (msg.sender != sequencerInbox) revert NotSequencerInbox(msg.sender);\\n        _;\\n    }\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        override\\n        onlySequencerInbox\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        seqMessageIndex = sequencerInboxAccs.length;\\n        if (sequencerInboxAccs.length > 0) {\\n            beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\\n        }\\n        if (afterDelayedMessagesRead > 0) {\\n            delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\\n        }\\n        acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\\n        sequencerInboxAccs.push(acc);\\n    }\\n\\n    /**\\n     * @dev allows the sequencer inbox to submit a delayed message of the batchPostingReport type\\n     * This is done through a separate function entrypoint instead of allowing the sequencer inbox\\n     * to call `enqueueDelayedMessage` to avoid the gas overhead of an extra SLOAD in either\\n     * every delayed inbox or every sequencer inbox call.\\n     */\\n    function submitBatchSpendingReport(address sender, bytes32 messageDataHash)\\n        external\\n        override\\n        onlySequencerInbox\\n        returns (uint256)\\n    {\\n        return\\n            addMessageToDelayedAccumulator(\\n                L1MessageType_batchPostingReport,\\n                sender,\\n                uint64(block.number),\\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time,\\n                block.basefee,\\n                messageDataHash\\n            );\\n    }\\n\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     * These messages are later sequenced in the SequencerInbox, either by the sequencer as\\n     * part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable override returns (uint256) {\\n        if (!allowedDelayedInboxesMap[msg.sender].allowed) revert NotDelayedInbox(msg.sender);\\n        return\\n            addMessageToDelayedAccumulator(\\n                kind,\\n                sender,\\n                uint64(block.number),\\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time\\n                block.basefee,\\n                messageDataHash\\n            );\\n    }\\n\\n    function addMessageToDelayedAccumulator(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 blockTimestamp,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        uint256 count = delayedInboxAccs.length;\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            blockNumber,\\n            blockTimestamp,\\n            count,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = delayedInboxAccs[count - 1];\\n        }\\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\\n        emit MessageDelivered(\\n            count,\\n            prevAcc,\\n            msg.sender,\\n            kind,\\n            sender,\\n            messageDataHash,\\n            baseFeeL1,\\n            blockTimestamp\\n        );\\n        return count;\\n    }\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external override returns (bool success, bytes memory returnData) {\\n        if (!allowedOutboxesMap[msg.sender].allowed) revert NotOutbox(msg.sender);\\n        if (data.length > 0 && !to.isContract()) revert NotContract(to);\\n        address prevOutbox = _activeOutbox;\\n        _activeOutbox = msg.sender;\\n        // We set and reset active outbox around external call so activeOutbox remains valid during call\\n\\n        // We use a low level call here since we want to bubble up whether it succeeded or failed to the caller\\n        // rather than reverting on failure as well as allow contract and non-contract calls\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, returnData) = to.call{value: value}(data);\\n        _activeOutbox = prevOutbox;\\n        emit BridgeCallTriggered(msg.sender, to, value, data);\\n    }\\n\\n    function setSequencerInbox(address _sequencerInbox) external override onlyRollupOrOwner {\\n        sequencerInbox = _sequencerInbox;\\n        emit SequencerInboxUpdated(_sequencerInbox);\\n    }\\n\\n    function setDelayedInbox(address inbox, bool enabled) external override onlyRollupOrOwner {\\n        InOutInfo storage info = allowedDelayedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit InboxToggle(inbox, enabled);\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedDelayedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\\n            allowedDelayedInboxList.push(inbox);\\n        } else {\\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\\n                allowedDelayedInboxList.length - 1\\n            ];\\n            allowedDelayedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\\n            allowedDelayedInboxList.pop();\\n            delete allowedDelayedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(address outbox, bool enabled) external override onlyRollupOrOwner {\\n        if (outbox == EMPTY_ACTIVEOUTBOX) revert InvalidOutboxSet(outbox);\\n\\n        InOutInfo storage info = allowedOutboxesMap[outbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit OutboxToggle(outbox, enabled);\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\\n            allowedOutboxList.push(outbox);\\n        } else {\\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\\n            allowedOutboxList.pop();\\n            delete allowedOutboxesMap[outbox];\\n        }\\n    }\\n\\n    function delayedMessageCount() external view override returns (uint256) {\\n        return delayedInboxAccs.length;\\n    }\\n\\n    function sequencerMessageCount() external view override returns (uint256) {\\n        return sequencerInboxAccs.length;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {NotContract, NotRollupOrOwner} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    // View functions\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function delayedInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function sequencerInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    function rollup() external view returns (IOwnable);\\n}\\n\"\r\n    },\r\n    \"src/bridge/Messages.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    baseFeeL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function accumulateInboxMessage(bytes32 prevAcc, bytes32 message)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(prevAcc, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/MessageTypes.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nuint8 constant L2_MSG = 3;\\nuint8 constant L1MessageType_L2FundedByL1 = 7;\\nuint8 constant L1MessageType_submitRetryableTx = 9;\\nuint8 constant L1MessageType_ethDeposit = 12;\\nuint8 constant L1MessageType_batchPostingReport = 13;\\nuint8 constant L2MessageType_unsignedEOATx = 0;\\nuint8 constant L2MessageType_unsignedContractTx = 1;\\n\\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/rollup/BridgeCreator.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/Bridge.sol\\\";\\nimport \\\"../bridge/SequencerInbox.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/Inbox.sol\\\";\\nimport \\\"../bridge/Outbox.sol\\\";\\nimport \\\"./RollupEventInbox.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\\\";\\n\\ncontract BridgeCreator is Ownable {\\n    Bridge public bridgeTemplate;\\n    SequencerInbox public sequencerInboxTemplate;\\n    Inbox public inboxTemplate;\\n    RollupEventInbox public rollupEventInboxTemplate;\\n    Outbox public outboxTemplate;\\n\\n    event TemplatesUpdated();\\n\\n    constructor() Ownable() {\\n        bridgeTemplate = new Bridge();\\n        sequencerInboxTemplate = new SequencerInbox();\\n        inboxTemplate = new Inbox();\\n        rollupEventInboxTemplate = new RollupEventInbox();\\n        outboxTemplate = new Outbox();\\n    }\\n\\n    function updateTemplates(\\n        address _bridgeTemplate,\\n        address _sequencerInboxTemplate,\\n        address _inboxTemplate,\\n        address _rollupEventInboxTemplate,\\n        address _outboxTemplate\\n    ) external onlyOwner {\\n        bridgeTemplate = Bridge(_bridgeTemplate);\\n        sequencerInboxTemplate = SequencerInbox(_sequencerInboxTemplate);\\n        inboxTemplate = Inbox(_inboxTemplate);\\n        rollupEventInboxTemplate = RollupEventInbox(_rollupEventInboxTemplate);\\n        outboxTemplate = Outbox(_outboxTemplate);\\n\\n        emit TemplatesUpdated();\\n    }\\n\\n    struct CreateBridgeFrame {\\n        ProxyAdmin admin;\\n        Bridge bridge;\\n        SequencerInbox sequencerInbox;\\n        Inbox inbox;\\n        RollupEventInbox rollupEventInbox;\\n        Outbox outbox;\\n    }\\n\\n    function createBridge(\\n        address adminProxy,\\n        address rollup,\\n        ISequencerInbox.MaxTimeVariation memory maxTimeVariation\\n    )\\n        external\\n        returns (\\n            Bridge,\\n            SequencerInbox,\\n            Inbox,\\n            RollupEventInbox,\\n            Outbox\\n        )\\n    {\\n        CreateBridgeFrame memory frame;\\n        {\\n            frame.bridge = Bridge(\\n                address(new TransparentUpgradeableProxy(address(bridgeTemplate), adminProxy, \\\"\\\"))\\n            );\\n            frame.sequencerInbox = SequencerInbox(\\n                address(\\n                    new TransparentUpgradeableProxy(address(sequencerInboxTemplate), adminProxy, \\\"\\\")\\n                )\\n            );\\n            frame.inbox = Inbox(\\n                address(new TransparentUpgradeableProxy(address(inboxTemplate), adminProxy, \\\"\\\"))\\n            );\\n            frame.rollupEventInbox = RollupEventInbox(\\n                address(\\n                    new TransparentUpgradeableProxy(\\n                        address(rollupEventInboxTemplate),\\n                        adminProxy,\\n                        \\\"\\\"\\n                    )\\n                )\\n            );\\n            frame.outbox = Outbox(\\n                address(new TransparentUpgradeableProxy(address(outboxTemplate), adminProxy, \\\"\\\"))\\n            );\\n        }\\n\\n        frame.bridge.initialize(IOwnable(rollup));\\n        frame.sequencerInbox.initialize(IBridge(frame.bridge), maxTimeVariation);\\n        frame.inbox.initialize(IBridge(frame.bridge), ISequencerInbox(frame.sequencerInbox));\\n        frame.rollupEventInbox.initialize(IBridge(frame.bridge));\\n        frame.outbox.initialize(IBridge(frame.bridge));\\n\\n        return (\\n            frame.bridge,\\n            frame.sequencerInbox,\\n            frame.inbox,\\n            frame.rollupEventInbox,\\n            frame.outbox\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/SequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IInbox.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\nimport \\\"../rollup/IRollupLogic.sol\\\";\\nimport \\\"./Messages.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\nimport {GasRefundEnabled, IGasRefunder} from \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {MAX_DATA_SIZE} from \\\"../libraries/Constants.sol\\\";\\n\\n/**\\n * @title Accepts batches from the sequencer and adds them to the rollup inbox.\\n * @notice Contains the inbox accumulator which is the ordering of all data and transactions to be processed by the rollup.\\n * As part of submitting a batch the sequencer is also expected to include items enqueued\\n * in the delayed inbox (Bridge.sol). If items in the delayed inbox are not included by a\\n * sequencer within a time limit they can be force included into the rollup inbox by anyone.\\n */\\ncontract SequencerInbox is DelegateCallAware, GasRefundEnabled, ISequencerInbox {\\n    uint256 public totalDelayedMessagesRead;\\n\\n    IBridge public bridge;\\n\\n    /// @dev The size of the batch header\\n    uint256 public constant HEADER_LENGTH = 40;\\n    /// @dev If the first batch data byte after the header has this bit set,\\n    /// the sequencer inbox has authenticated the data. Currently not used.\\n    bytes1 public constant DATA_AUTHENTICATED_FLAG = 0x40;\\n\\n    IOwnable public rollup;\\n    mapping(address => bool) public isBatchPoster;\\n    ISequencerInbox.MaxTimeVariation public maxTimeVariation;\\n\\n    struct DasKeySetInfo {\\n        bool isValidKeyset;\\n        uint64 creationBlock;\\n    }\\n    mapping(bytes32 => DasKeySetInfo) public dasKeySetInfo;\\n\\n    modifier onlyRollupOwner() {\\n        if (msg.sender != rollup.owner()) revert NotOwner(msg.sender, address(rollup));\\n        _;\\n    }\\n\\n    function initialize(\\n        IBridge bridge_,\\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation_\\n    ) external onlyDelegated {\\n        if (bridge != IBridge(address(0))) revert AlreadyInit();\\n        if (bridge_ == IBridge(address(0))) revert HadZeroInit();\\n        bridge = bridge_;\\n        rollup = bridge_.rollup();\\n        maxTimeVariation = maxTimeVariation_;\\n    }\\n\\n    function getTimeBounds() internal view virtual returns (TimeBounds memory) {\\n        TimeBounds memory bounds;\\n        if (block.timestamp > maxTimeVariation.delaySeconds) {\\n            bounds.minTimestamp = uint64(block.timestamp - maxTimeVariation.delaySeconds);\\n        }\\n        bounds.maxTimestamp = uint64(block.timestamp + maxTimeVariation.futureSeconds);\\n        if (block.number > maxTimeVariation.delayBlocks) {\\n            bounds.minBlockNumber = uint64(block.number - maxTimeVariation.delayBlocks);\\n        }\\n        bounds.maxBlockNumber = uint64(block.number + maxTimeVariation.futureBlocks);\\n        return bounds;\\n    }\\n\\n    /// @notice Force messages from the delayed inbox to be included in the chain\\n    /// Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and maxTimeVariation.delaySeconds\\n    /// has elapsed. As part of normal behaviour the sequencer will include these messages\\n    /// so it's only necessary to call this if the sequencer is down, or not including\\n    /// any delayed messages.\\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\\n    /// @param kind The kind of the last message to be included\\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\\n    /// @param sender The sender of the last message to be included\\n    /// @param messageDataHash The messageDataHash of the last message to be included\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external {\\n        if (_totalDelayedMessagesRead <= totalDelayedMessagesRead) revert DelayedBackwards();\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            l1BlockAndTime[0],\\n            l1BlockAndTime[1],\\n            _totalDelayedMessagesRead - 1,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        // Can only force-include after the Sequencer-only window has expired.\\n        if (l1BlockAndTime[0] + maxTimeVariation.delayBlocks >= block.number)\\n            revert ForceIncludeBlockTooSoon();\\n        if (l1BlockAndTime[1] + maxTimeVariation.delaySeconds >= block.timestamp)\\n            revert ForceIncludeTimeTooSoon();\\n\\n        // Verify that message hash represents the last message sequence of delayed message to be included\\n        bytes32 prevDelayedAcc = 0;\\n        if (_totalDelayedMessagesRead > 1) {\\n            prevDelayedAcc = bridge.delayedInboxAccs(_totalDelayedMessagesRead - 2);\\n        }\\n        if (\\n            bridge.delayedInboxAccs(_totalDelayedMessagesRead - 1) !=\\n            Messages.accumulateInboxMessage(prevDelayedAcc, messageHash)\\n        ) revert IncorrectMessagePreimage();\\n\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formEmptyDataHash(\\n            _totalDelayedMessagesRead\\n        );\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, _totalDelayedMessagesRead, 0);\\n        emit SequencerBatchDelivered(\\n            seqMessageIndex,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.NoData\\n        );\\n    }\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external refundsGas(gasRefunder) {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, afterDelayedMessagesRead, data.length);\\n        if (seqMessageIndex != sequenceNumber)\\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\\n        emit SequencerBatchDelivered(\\n            sequenceNumber,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.TxInput\\n        );\\n    }\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external override refundsGas(gasRefunder) {\\n        if (!isBatchPoster[msg.sender] && msg.sender != address(rollup)) revert NotBatchPoster();\\n\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        // we set the calldata length posted to 0 here since the caller isn't the origin\\n        // of the tx, so they might have not paid tx input cost for the calldata\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, afterDelayedMessagesRead, 0);\\n        if (seqMessageIndex != sequenceNumber)\\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\\n        emit SequencerBatchDelivered(\\n            sequenceNumber,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            afterDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.SeparateBatchEvent\\n        );\\n        emit SequencerBatchData(sequenceNumber, data);\\n    }\\n\\n    modifier validateBatchData(bytes calldata data) {\\n        uint256 fullDataLen = HEADER_LENGTH + data.length;\\n        if (fullDataLen > MAX_DATA_SIZE) revert DataTooLarge(fullDataLen, MAX_DATA_SIZE);\\n        if (data.length > 0 && (data[0] & DATA_AUTHENTICATED_FLAG) == DATA_AUTHENTICATED_FLAG) {\\n            revert DataNotAuthenticated();\\n        }\\n        // the first byte is used to identify the type of batch data\\n        // das batches expect to have the type byte set, followed by the keyset (so they should have at least 33 bytes)\\n        if (data.length >= 33 && data[0] & 0x80 != 0) {\\n            // we skip the first byte, then read the next 32 bytes for the keyset\\n            bytes32 dasKeysetHash = bytes32(data[1:33]);\\n            if (!dasKeySetInfo[dasKeysetHash].isValidKeyset) revert NoSuchKeyset(dasKeysetHash);\\n        }\\n        _;\\n    }\\n\\n    function packHeader(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes memory, TimeBounds memory)\\n    {\\n        TimeBounds memory timeBounds = getTimeBounds();\\n        bytes memory header = abi.encodePacked(\\n            timeBounds.minTimestamp,\\n            timeBounds.maxTimestamp,\\n            timeBounds.minBlockNumber,\\n            timeBounds.maxBlockNumber,\\n            uint64(afterDelayedMessagesRead)\\n        );\\n        // This must always be true from the packed encoding\\n        assert(header.length == HEADER_LENGTH);\\n        return (header, timeBounds);\\n    }\\n\\n    function formDataHash(bytes calldata data, uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        validateBatchData(data)\\n        returns (bytes32, TimeBounds memory)\\n    {\\n        (bytes memory header, TimeBounds memory timeBounds) = packHeader(afterDelayedMessagesRead);\\n        bytes32 dataHash = keccak256(bytes.concat(header, data));\\n        return (dataHash, timeBounds);\\n    }\\n\\n    function formEmptyDataHash(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes32, TimeBounds memory)\\n    {\\n        (bytes memory header, TimeBounds memory timeBounds) = packHeader(afterDelayedMessagesRead);\\n        return (keccak256(header), timeBounds);\\n    }\\n\\n    function addSequencerL2BatchImpl(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 calldataLengthPosted\\n    )\\n        internal\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        if (afterDelayedMessagesRead < totalDelayedMessagesRead) revert DelayedBackwards();\\n        if (afterDelayedMessagesRead > bridge.delayedMessageCount()) revert DelayedTooFar();\\n\\n        (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge.enqueueSequencerMessage(\\n            dataHash,\\n            afterDelayedMessagesRead\\n        );\\n\\n        totalDelayedMessagesRead = afterDelayedMessagesRead;\\n\\n        if (calldataLengthPosted > 0) {\\n            // this msg isn't included in the current sequencer batch, but instead added to\\n            // the delayed messages queue that is yet to be included\\n            address batchPoster = msg.sender;\\n            bytes memory spendingReportMsg = abi.encodePacked(\\n                block.timestamp,\\n                batchPoster,\\n                dataHash,\\n                seqMessageIndex,\\n                block.basefee\\n            );\\n            uint256 msgNum = bridge.submitBatchSpendingReport(\\n                batchPoster,\\n                keccak256(spendingReportMsg)\\n            );\\n            // this is the same event used by Inbox.sol after including a message to the delayed message accumulator\\n            emit InboxMessageDelivered(msgNum, spendingReportMsg);\\n        }\\n    }\\n\\n    function inboxAccs(uint256 index) external view override returns (bytes32) {\\n        return bridge.sequencerInboxAccs(index);\\n    }\\n\\n    function batchCount() external view override returns (uint256) {\\n        return bridge.sequencerMessageCount();\\n    }\\n\\n    /**\\n     * @notice Set max delay for sequencer inbox\\n     * @param maxTimeVariation_ the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(ISequencerInbox.MaxTimeVariation memory maxTimeVariation_)\\n        external\\n        override\\n        onlyRollupOwner\\n    {\\n        maxTimeVariation = maxTimeVariation_;\\n        emit OwnerFunctionCalled(0);\\n    }\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external override onlyRollupOwner {\\n        isBatchPoster[addr] = isBatchPoster_;\\n        emit OwnerFunctionCalled(1);\\n    }\\n\\n    /**\\n     * @notice Makes Data Availability Service keyset valid\\n     * @param keysetBytes bytes of the serialized keyset\\n     */\\n    function setValidKeyset(bytes calldata keysetBytes) external override onlyRollupOwner {\\n        bytes32 ksHash = keccak256(keysetBytes);\\n        if (dasKeySetInfo[ksHash].isValidKeyset) revert AlreadyValidDASKeyset(ksHash);\\n        dasKeySetInfo[ksHash] = DasKeySetInfo({\\n            isValidKeyset: true,\\n            creationBlock: uint64(block.number)\\n        });\\n        emit SetValidKeyset(ksHash, keysetBytes);\\n        emit OwnerFunctionCalled(2);\\n    }\\n\\n    /**\\n     * @notice Invalidates a Data Availability Service keyset\\n     * @param ksHash hash of the keyset\\n     */\\n    function invalidateKeysetHash(bytes32 ksHash) external override onlyRollupOwner {\\n        if (!dasKeySetInfo[ksHash].isValidKeyset) revert NoSuchKeyset(ksHash);\\n        // we don't delete the block creation value since its used to fetch the SetValidKeyset\\n        // event efficiently. The event provides the hash preimage of the key.\\n        // this is still needed when syncing the chain after a keyset is invalidated.\\n        dasKeySetInfo[ksHash].isValidKeyset = false;\\n        emit InvalidateKeyset(ksHash);\\n        emit OwnerFunctionCalled(3);\\n    }\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool) {\\n        return dasKeySetInfo[ksHash].isValidKeyset;\\n    }\\n\\n    /// @notice the creation block is intended to still be available after a keyset is deleted\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256) {\\n        DasKeySetInfo memory ksInfo = dasKeySetInfo[ksHash];\\n        if (ksInfo.creationBlock == 0) revert NoSuchKeyset(ksHash);\\n        return uint256(ksInfo.creationBlock);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/ISequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport {AlreadyInit, HadZeroInit, NotOrigin, DataTooLarge, NotRollup} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\n\\ninterface ISequencerInbox is IDelayedMessageProvider {\\n    struct MaxTimeVariation {\\n        uint256 delayBlocks;\\n        uint256 futureBlocks;\\n        uint256 delaySeconds;\\n        uint256 futureSeconds;\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    enum BatchDataLocation {\\n        TxInput,\\n        SeparateBatchEvent,\\n        NoData\\n    }\\n\\n    event SequencerBatchDelivered(\\n        uint256 indexed batchSequenceNumber,\\n        bytes32 indexed beforeAcc,\\n        bytes32 indexed afterAcc,\\n        bytes32 delayedAcc,\\n        uint256 afterDelayedMessagesRead,\\n        TimeBounds timeBounds,\\n        BatchDataLocation dataLocation\\n    );\\n\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\\n\\n    /// @dev a valid keyset was added\\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\\n\\n    /// @dev a keyset was invalidated\\n    event InvalidateKeyset(bytes32 indexed keysetHash);\\n\\n    /// @dev Thrown when someone attempts to read fewer messages than have already been read\\n    error DelayedBackwards();\\n\\n    /// @dev Thrown when someone attempts to read more messages than exist\\n    error DelayedTooFar();\\n\\n    /// @dev Force include can only read messages more blocks old than the delay period\\n    error ForceIncludeBlockTooSoon();\\n\\n    /// @dev Force include can only read messages more seconds old than the delay period\\n    error ForceIncludeTimeTooSoon();\\n\\n    /// @dev The message provided did not match the hash in the delayed inbox\\n    error IncorrectMessagePreimage();\\n\\n    /// @dev This can only be called by the batch poster\\n    error NotBatchPoster();\\n\\n    /// @dev The sequence number provided to this message was inconsistent with the number of batches already included\\n    error BadSequencerNumber(uint256 stored, uint256 received);\\n\\n    /// @dev The batch data has the inbox authenticated bit set, but the batch data was not authenticated by the inbox\\n    error DataNotAuthenticated();\\n\\n    /// @dev Tried to create an already valid Data Availability Service keyset\\n    error AlreadyValidDASKeyset(bytes32);\\n\\n    /// @dev Tried to use or invalidate an already invalid Data Availability Service keyset\\n    error NoSuchKeyset(bytes32);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function batchCount() external view returns (uint256);\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external;\\n\\n    // Methods only callable by rollup owner\\n\\n    /**\\n     * @notice Set max time variation from actual time for sequencer inbox\\n     * @param timeVariation the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(MaxTimeVariation memory timeVariation) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster) external;\\n\\n    function setValidKeyset(bytes calldata keysetBytes) external;\\n\\n    function invalidateKeysetHash(bytes32 ksHash) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/Inbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IInbox.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\nimport \\\"./IBridge.sol\\\";\\n\\nimport \\\"./Messages.sol\\\";\\nimport \\\"../libraries/AddressAliasHelper.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {\\n    L2_MSG,\\n    L1MessageType_L2FundedByL1,\\n    L1MessageType_submitRetryableTx,\\n    L1MessageType_ethDeposit,\\n    L2MessageType_unsignedEOATx,\\n    L2MessageType_unsignedContractTx\\n} from \\\"../libraries/MessageTypes.sol\\\";\\nimport {MAX_DATA_SIZE} from \\\"../libraries/Constants.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\n/**\\n * @title Inbox for user and contract originated messages\\n * @notice Messages created via this inbox are enqueued in the delayed accumulator\\n * to await inclusion in the SequencerInbox\\n */\\ncontract Inbox is DelegateCallAware, PausableUpgradeable, IInbox {\\n    IBridge public override bridge;\\n    ISequencerInbox public sequencerInbox;\\n\\n    /// ------------------------------------ allow list start ------------------------------------ ///\\n\\n    bool public allowListEnabled;\\n    mapping(address => bool) public isAllowed;\\n\\n    event AllowListAddressSet(address indexed user, bool val);\\n    event AllowListEnabledUpdated(bool isEnabled);\\n\\n    function setAllowList(address[] memory user, bool[] memory val) external onlyRollupOrOwner {\\n        require(user.length == val.length, \\\"INVALID_INPUT\\\");\\n\\n        for (uint256 i = 0; i < user.length; i++) {\\n            isAllowed[user[i]] = val[i];\\n            emit AllowListAddressSet(user[i], val[i]);\\n        }\\n    }\\n\\n    function setAllowListEnabled(bool _allowListEnabled) external onlyRollupOrOwner {\\n        require(_allowListEnabled != allowListEnabled, \\\"ALREADY_SET\\\");\\n        allowListEnabled = _allowListEnabled;\\n        emit AllowListEnabledUpdated(_allowListEnabled);\\n    }\\n\\n    /// @dev this modifier checks the tx.origin instead of msg.sender for convenience (ie it allows\\n    /// allowed users to interact with the token bridge without needing the token bridge to be allowList aware).\\n    /// this modifier is not intended to use to be used for security (since this opens the allowList to\\n    /// a smart contract phishing risk).\\n    modifier onlyAllowed() {\\n        if (allowListEnabled && !isAllowed[tx.origin]) revert NotAllowedOrigin(tx.origin);\\n        _;\\n    }\\n\\n    /// ------------------------------------ allow list end ------------------------------------ ///\\n\\n    modifier onlyRollupOrOwner() {\\n        IOwnable rollup = bridge.rollup();\\n        if (msg.sender != address(rollup)) {\\n            address rollupOwner = rollup.owner();\\n            if (msg.sender != rollupOwner) {\\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\\n            }\\n        }\\n        _;\\n    }\\n\\n    /// @notice pauses all inbox functionality\\n    function pause() external onlyRollupOrOwner {\\n        _pause();\\n    }\\n\\n    /// @notice unpauses all inbox functionality\\n    function unpause() external onlyRollupOrOwner {\\n        _unpause();\\n    }\\n\\n    function initialize(IBridge _bridge, ISequencerInbox _sequencerInbox)\\n        external\\n        initializer\\n        onlyDelegated\\n    {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        bridge = _bridge;\\n        sequencerInbox = _sequencerInbox;\\n        allowListEnabled = false;\\n        __Pausable_init();\\n    }\\n\\n    /// @dev function to be called one time during the inbox upgrade process\\n    /// this is used to fix the storage slots\\n    function postUpgradeInit(IBridge _bridge) external onlyDelegated onlyProxyOwner {\\n        uint8 slotsToWipe = 3;\\n        for (uint8 i = 0; i < slotsToWipe; i++) {\\n            assembly {\\n                sstore(i, 0)\\n            }\\n        }\\n        allowListEnabled = false;\\n        bridge = _bridge;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData)\\n        external\\n        whenNotPaused\\n        onlyAllowed\\n        returns (uint256)\\n    {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        if (messageData.length > MAX_DATA_SIZE)\\n            revert DataTooLarge(messageData.length, MAX_DATA_SIZE);\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDeliveredFromOrigin(msgNum);\\n        return msgNum;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData)\\n        external\\n        override\\n        whenNotPaused\\n        onlyAllowed\\n        returns (uint256)\\n    {\\n        return _deliverMessage(L2_MSG, msg.sender, messageData);\\n    }\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable virtual override whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable virtual override whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L1MessageType_L2FundedByL1,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    uint256(uint160(to)),\\n                    msg.value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external virtual override whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedEOATx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    nonce,\\n                    uint256(uint160(to)),\\n                    value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external virtual override whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            _deliverMessage(\\n                L2_MSG,\\n                msg.sender,\\n                abi.encodePacked(\\n                    L2MessageType_unsignedContractTx,\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    uint256(uint160(to)),\\n                    value,\\n                    data\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @notice Get the L1 fee for submitting a retryable\\n     * @dev This fee can be paid by funds already in the L2 aliased address or by the current message value\\n     * @dev This formula may change in the future, to future proof your code query this method instead of inlining!!\\n     * @param dataLength The length of the retryable's calldata, in bytes\\n     * @param baseFee The block basefee when the retryable is included in the chain\\n     */\\n    function calculateRetryableSubmissionFee(uint256 dataLength, uint256 baseFee)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        return (1400 + 6 * dataLength) * baseFee;\\n    }\\n\\n    /// @notice deposit eth from L1 to L2\\n    /// @dev this does not trigger the fallback function when receiving in the L2 side.\\n    /// Look into retryable tickets if you are interested in this functionality.\\n    /// @dev this function should not be called inside contract constructors\\n    function depositEth() public payable override whenNotPaused onlyAllowed returns (uint256) {\\n        address dest = msg.sender;\\n\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (AddressUpgradeable.isContract(msg.sender) || tx.origin != msg.sender) {\\n            // isContract check fails if this function is called during a contract's constructor.\\n            // We don't adjust the address for calls coming from L1 contracts since their addresses get remapped\\n            // If the caller is an EOA, we adjust the address.\\n            // This is needed because unsigned messages to the L2 (such as retryables)\\n            // have the L1 sender address mapped.\\n            dest = AddressAliasHelper.applyL1ToL2Alias(msg.sender);\\n        }\\n\\n        return\\n            _deliverMessage(\\n                L1MessageType_ethDeposit,\\n                msg.sender,\\n                abi.encodePacked(dest, msg.value)\\n            );\\n    }\\n\\n    /// @notice deprecated in favour of depositEth with no parameters\\n    function depositEth(uint256)\\n        external\\n        payable\\n        virtual\\n        override\\n        whenNotPaused\\n        onlyAllowed\\n        returns (uint256)\\n    {\\n        return depositEth();\\n    }\\n\\n    /**\\n     * @notice deprecated in favour of unsafeCreateRetryableTicket\\n     * @dev deprecated in favour of unsafeCreateRetryableTicket\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\\n     */\\n    function createRetryableTicketNoRefundAliasRewrite(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable virtual whenNotPaused onlyAllowed returns (uint256) {\\n        return\\n            unsafeCreateRetryableTicket(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                data\\n            );\\n    }\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev all msg.value will deposited to callValueRefundAddress on L2\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\\n     */\\n    function createRetryableTicket(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable virtual override whenNotPaused onlyAllowed returns (uint256) {\\n        // ensure the user's deposit alone will make submission succeed\\n        if (msg.value < (maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas)) {\\n            revert InsufficientValue(\\n                maxSubmissionCost + l2CallValue + gasLimit * maxFeePerGas,\\n                msg.value\\n            );\\n        }\\n\\n        // if a refund address is a contract, we apply the alias to it\\n        // so that it can access its funds on the L2\\n        // since the beneficiary and other refund addresses don't get rewritten by arb-os\\n        if (AddressUpgradeable.isContract(excessFeeRefundAddress)) {\\n            excessFeeRefundAddress = AddressAliasHelper.applyL1ToL2Alias(excessFeeRefundAddress);\\n        }\\n        if (AddressUpgradeable.isContract(callValueRefundAddress)) {\\n            // this is the beneficiary. be careful since this is the address that can cancel the retryable in the L2\\n            callValueRefundAddress = AddressAliasHelper.applyL1ToL2Alias(callValueRefundAddress);\\n        }\\n\\n        return\\n            unsafeCreateRetryableTicketInternal(\\n                to,\\n                l2CallValue,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                data\\n            );\\n    }\\n\\n    /**\\n     * @notice Put a message in the L2 inbox that can be reexecuted for some fixed amount of time if it reverts\\n     * @dev Same as createRetryableTicket, but does not guarantee that submission will succeed by requiring the needed funds\\n     * come from the deposit alone, rather than falling back on the user's L2 balance\\n     * @dev Advanced usage only (does not rewrite aliases for excessFeeRefundAddress and callValueRefundAddress).\\n     * createRetryableTicket method is the recommended standard.\\n     * @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n     * @param to destination L2 contract address\\n     * @param l2CallValue call value for retryable L2 message\\n     * @param maxSubmissionCost Max gas deducted from user's L2 balance to cover base submission fee\\n     * @param excessFeeRefundAddress gasLimit x maxFeePerGas - execution cost gets credited here on L2 balance\\n     * @param callValueRefundAddress l2Callvalue gets credited here on L2 if retryable txn times out or gets cancelled\\n     * @param gasLimit Max gas deducted from user's L2 balance to cover L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param maxFeePerGas price bid for L2 execution. Should not be set to 1 (magic value used to trigger the RetryableData error)\\n     * @param data ABI encoded data of L2 message\\n     * @return unique id for retryable transaction (keccak256(requestID, uint(0) )\\n     */\\n    function unsafeCreateRetryableTicketInternal(\\n        address to,\\n        uint256 l2CallValue,\\n        uint256 maxSubmissionCost,\\n        address excessFeeRefundAddress,\\n        address callValueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) internal virtual whenNotPaused onlyAllowed returns (uint256) {\\n        // gas price and limit of 1 should never be a valid input, so instead they are used as\\n        // magic values to trigger a revert in eth calls that surface data without requiring a tx trace\\n        if (gasLimit == 1 || maxFeePerGas == 1)\\n            revert RetryableData(\\n                msg.sender,\\n                to,\\n                l2CallValue,\\n                msg.value,\\n                maxSubmissionCost,\\n                excessFeeRefundAddress,\\n                callValueRefundAddress,\\n                gasLimit,\\n                maxFeePerGas,\\n                data\\n            );\\n\\n        uint256 submissionFee = calculateRetryableSubmissionFee(data.length, block.basefee);\\n        if (maxSubmissionCost < submissionFee)\\n            revert InsufficientSubmissionCost(submissionFee, maxSubmissionCost);\\n\\n        return\\n            _deliverMessage(\\n                L1MessageType_submitRetryableTx,\\n                msg.sender,\\n                abi.encodePacked(\\n                    uint256(uint160(to)),\\n                    l2CallValue,\\n                    msg.value,\\n                    maxSubmissionCost,\\n                    uint256(uint160(excessFeeRefundAddress)),\\n                    uint256(uint160(callValueRefundAddress)),\\n                    gasLimit,\\n                    maxFeePerGas,\\n                    data.length,\\n                    data\\n                )\\n            );\\n    }\\n\\n    function unsafeCreateRetryableTicket(\\n        address,\\n        uint256,\\n        uint256,\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public payable override returns (uint256) {\\n        revert(\\\"UNSAFE_RETRYABLES_TEMPORARILY_DISABLED\\\");\\n    }\\n\\n    function _deliverMessage(\\n        uint8 _kind,\\n        address _sender,\\n        bytes memory _messageData\\n    ) internal returns (uint256) {\\n        if (_messageData.length > MAX_DATA_SIZE)\\n            revert DataTooLarge(_messageData.length, MAX_DATA_SIZE);\\n        uint256 msgNum = deliverToBridge(\\n            _kind,\\n            AddressAliasHelper.applyL1ToL2Alias(_sender),\\n            keccak256(_messageData)\\n        );\\n        emit InboxMessageDelivered(msgNum, _messageData);\\n        return msgNum;\\n    }\\n\\n    function deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        return bridge.enqueueDelayedMessage{value: msg.value}(kind, sender, messageDataHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/Outbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IOutbox.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\n/// @dev this error is thrown since certain functions are only expected to be used in simulations, not in actual txs\\nerror SimulationOnlyEntrypoint();\\n\\ncontract Outbox is DelegateCallAware, IOutbox {\\n    address public rollup; // the rollup contract\\n    IBridge public bridge; // the bridge contract\\n\\n    mapping(uint256 => bytes32) public spent; // packed spent bitmap\\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\\n\\n    struct L2ToL1Context {\\n        uint128 l2Block;\\n        uint128 l1Block;\\n        uint128 timestamp;\\n        bytes32 outputId;\\n        address sender;\\n    }\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // be empty outside of transactions\\n    L2ToL1Context internal context;\\n\\n    // default context values to be used in storage instead of zero, to save on storage refunds\\n    // it is assumed that arb-os never assigns these values to a valid leaf to be redeemed\\n    uint128 private constant L2BLOCK_DEFAULT_CONTEXT = type(uint128).max;\\n    uint128 private constant L1BLOCK_DEFAULT_CONTEXT = type(uint128).max;\\n    uint128 private constant TIMESTAMP_DEFAULT_CONTEXT = type(uint128).max;\\n    bytes32 private constant OUTPUTID_DEFAULT_CONTEXT = bytes32(type(uint256).max);\\n    address private constant SENDER_DEFAULT_CONTEXT = address(type(uint160).max);\\n\\n    uint128 public constant OUTBOX_VERSION = 2;\\n\\n    function initialize(IBridge _bridge) external onlyDelegated {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        // address zero is returned if no context is set, but the values used in storage\\n        // are non-zero to save users some gas (as storage refunds are usually maxed out)\\n        // EIP-1153 would help here\\n        context = L2ToL1Context({\\n            l2Block: L2BLOCK_DEFAULT_CONTEXT,\\n            l1Block: L1BLOCK_DEFAULT_CONTEXT,\\n            timestamp: TIMESTAMP_DEFAULT_CONTEXT,\\n            outputId: OUTPUTID_DEFAULT_CONTEXT,\\n            sender: SENDER_DEFAULT_CONTEXT\\n        });\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external override {\\n        if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);\\n        roots[root] = l2BlockHash;\\n        emit SendRootUpdated(root, l2BlockHash);\\n    }\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    /// When the return value is zero, that means this is a system message\\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\\n    function l2ToL1Sender() external view override returns (address) {\\n        address sender = context.sender;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (sender == SENDER_DEFAULT_CONTEXT) return address(0);\\n        return sender;\\n    }\\n\\n    /// @return l2Block return L2 block when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1Block() external view override returns (uint256) {\\n        uint128 l2Block = context.l2Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l2Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l2Block);\\n    }\\n\\n    /// @return l1Block return L1 block when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1EthBlock() external view override returns (uint256) {\\n        uint128 l1Block = context.l1Block;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (l1Block == L1BLOCK_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(l1Block);\\n    }\\n\\n    /// @return timestamp return L2 timestamp when the L2 tx was initiated or zero\\n    /// if no L2 to L1 transaction is active\\n    function l2ToL1Timestamp() external view override returns (uint256) {\\n        uint128 timestamp = context.timestamp;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (timestamp == TIMESTAMP_DEFAULT_CONTEXT) return uint256(0);\\n        return uint256(timestamp);\\n    }\\n\\n    /// @notice batch number is deprecated and now always returns 0\\n    function l2ToL1BatchNum() external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    /// @return outputId returns the unique output identifier of the L2 to L1 tx or\\n    /// zero if no L2 to L1 transaction is active\\n    function l2ToL1OutputId() external view override returns (bytes32) {\\n        bytes32 outputId = context.outputId;\\n        // we don't return the default context value to avoid a breaking change in the API\\n        if (outputId == OUTPUTID_DEFAULT_CONTEXT) return bytes32(0);\\n        return outputId;\\n    }\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry.\\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\\n     * is only created once the rollup confirms the respective assertion.\\n     * @param proof Merkle proof of message inclusion in send root\\n     * @param index Merkle path to message\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param to destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param value wei in L1 message\\n     * @param data abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        bytes32 userTx = calculateItemHash(\\n            l2Sender,\\n            to,\\n            l2Block,\\n            l1Block,\\n            l2Timestamp,\\n            value,\\n            data\\n        );\\n\\n        recordOutputAsSpent(proof, index, userTx);\\n\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    /// @dev function used to simulate the result of a particular function call from the outbox\\n    /// it is useful for things such as gas estimates. This function includes all costs except for\\n    /// proof validation (which can be considered offchain as a somewhat of a fixed cost - it's\\n    /// not really a fixed cost, but can be treated as so with a fixed overhead for gas estimation).\\n    /// We can't include the cost of proof validation since this is intended to be used to simulate txs\\n    /// that are included in yet-to-be confirmed merkle roots. The simulation entrypoint could instead pretend\\n    /// to confirm a pending merkle root, but that would be less pratical for integrating with tooling.\\n    /// It is only possible to trigger it when the msg sender is address zero, which should be impossible\\n    /// unless under simulation in an eth_call or eth_estimateGas\\n    function executeTransactionSimulation(\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external {\\n        if (msg.sender != address(0)) revert SimulationOnlyEntrypoint();\\n        executeTransactionImpl(index, l2Sender, to, l2Block, l1Block, l2Timestamp, value, data);\\n    }\\n\\n    function executeTransactionImpl(\\n        uint256 outputId,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) internal {\\n        emit OutBoxTransactionExecuted(to, l2Sender, 0, outputId);\\n\\n        // we temporarily store the previous values so the outbox can naturally\\n        // unwind itself when there are nested calls to `executeTransaction`\\n        L2ToL1Context memory prevContext = context;\\n\\n        context = L2ToL1Context({\\n            sender: l2Sender,\\n            l2Block: uint128(l2Block),\\n            l1Block: uint128(l1Block),\\n            timestamp: uint128(l2Timestamp),\\n            outputId: bytes32(outputId)\\n        });\\n\\n        // set and reset vars around execution so they remain valid during call\\n        executeBridgeCall(to, value, data);\\n\\n        context = prevContext;\\n    }\\n\\n    function recordOutputAsSpent(\\n        bytes32[] memory proof,\\n        uint256 index,\\n        bytes32 item\\n    ) internal {\\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\\n\\n        uint256 spentIndex = index / 255; // Note: Reserves the MSB.\\n        uint256 bitOffset = index % 255;\\n\\n        bytes32 replay = spent[spentIndex];\\n        if (((replay >> bitOffset) & bytes32(uint256(1))) != bytes32(0)) revert AlreadySpent(index);\\n        spent[spentIndex] = (replay | bytes32(1 << bitOffset));\\n    }\\n\\n    function executeBridgeCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert BridgeCallFailed();\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IDelayedMessageProvider.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {INITIALIZATION_MSG_TYPE} from \\\"../libraries/MessageTypes.sol\\\";\\n\\n/**\\n * @title The inbox for rollup protocol events\\n */\\ncontract RollupEventInbox is IRollupEventInbox, IDelayedMessageProvider, DelegateCallAware {\\n    uint8 internal constant CREATE_NODE_EVENT = 0;\\n    uint8 internal constant CONFIRM_NODE_EVENT = 1;\\n    uint8 internal constant REJECT_NODE_EVENT = 2;\\n    uint8 internal constant STAKE_CREATED_EVENT = 3;\\n\\n    IBridge public override bridge;\\n    address public override rollup;\\n\\n    modifier onlyRollup() {\\n        require(msg.sender == rollup, \\\"ONLY_ROLLUP\\\");\\n        _;\\n    }\\n\\n    function initialize(IBridge _bridge) external override onlyDelegated {\\n        require(address(bridge) == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function rollupInitialized(uint256 chainId) external override onlyRollup {\\n        bytes memory initMsg = abi.encodePacked(chainId);\\n        uint256 num = bridge.enqueueDelayedMessage(\\n            INITIALIZATION_MSG_TYPE,\\n            address(0),\\n            keccak256(initMsg)\\n        );\\n        emit InboxMessageDelivered(num, initMsg);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./TransparentUpgradeableProxy.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\n\\n/**\\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\\n */\\ncontract ProxyAdmin is Ownable {\\n    /**\\n     * @dev Returns the current implementation of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"implementation()\\\")) == 0x5c60da1b\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"5c60da1b\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Returns the current admin of `proxy`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\\n        // We need to manually run the static call since the getter cannot be flagged as view\\n        // bytes4(keccak256(\\\"admin()\\\")) == 0xf851a440\\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\\\"f851a440\\\");\\n        require(success);\\n        return abi.decode(returndata, (address));\\n    }\\n\\n    /**\\n     * @dev Changes the admin of `proxy` to `newAdmin`.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the current admin of `proxy`.\\n     */\\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\\n        proxy.changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\\n        proxy.upgradeTo(implementation);\\n    }\\n\\n    /**\\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\\n     *\\n     * Requirements:\\n     *\\n     * - This contract must be the admin of `proxy`.\\n     */\\n    function upgradeAndCall(\\n        TransparentUpgradeableProxy proxy,\\n        address implementation,\\n        bytes memory data\\n    ) public payable virtual onlyOwner {\\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport {AlreadyInit, NotOrigin, DataTooLarge} from \\\"../libraries/Error.sol\\\";\\n\\n/// @dev The contract is paused, so cannot be paused\\nerror AlreadyPaused();\\n\\n/// @dev The contract is unpaused, so cannot be unpaused\\nerror AlreadyUnpaused();\\n\\n/// @dev The contract is paused\\nerror Paused();\\n\\n/// @dev msg.value sent to the inbox isn't high enough\\nerror InsufficientValue(uint256 expected, uint256 actual);\\n\\n/// @dev submission cost provided isn't enough to create retryable ticket\\nerror InsufficientSubmissionCost(uint256 expected, uint256 actual);\\n\\n/// @dev address not allowed to interact with the given contract\\nerror NotAllowedOrigin(address origin);\\n\\n/// @dev used to convey retryable tx data in eth calls without requiring a tx trace\\n/// this follows a pattern similar to EIP-3668 where reverts surface call information\\nerror RetryableData(\\n    address from,\\n    address to,\\n    uint256 l2CallValue,\\n    uint256 deposit,\\n    uint256 maxSubmissionCost,\\n    address excessFeeRefundAddress,\\n    address callValueRefundAddress,\\n    uint256 gasLimit,\\n    uint256 maxFeePerGas,\\n    bytes data\\n);\\n\\ninterface IInbox is IDelayedMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /// @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n    function createRetryableTicket(\\n        address to,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /// @notice TEMPORARILY DISABLED as exact mechanics are being worked out\\n    /// @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth() external payable returns (uint256);\\n\\n    /// @notice deprecated in favour of depositEth with no parameters\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IOwnable.sol\\\";\\n\\ninterface IRollupUserAbs is IRollupCore, IOwnable {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address stakeToken) external view;\\n\\n    function isERC20Enabled() external view returns (bool);\\n\\n    function rejectNextNode(address stakerAddress) external;\\n\\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\\n\\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\\n\\n    function stakeOnNewNode(\\n        RollupLib.Assertion memory assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function returnOldDeposit(address stakerAddress) external;\\n\\n    function reduceDeposit(uint256 target) external;\\n\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\\n\\n    function removeOldZombies(uint256 startIndex) external;\\n\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint64 firstUnresolvedNodeNum,\\n        uint64 latestCreatedNode\\n    ) external view returns (uint256);\\n\\n    function currentRequiredStake() external view returns (uint256);\\n\\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\\n\\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\\n\\n    function requireUnresolvedExists() external view;\\n\\n    function requireUnresolved(uint256 nodeNum) external view;\\n\\n    function withdrawStakerFunds() external returns (uint256);\\n\\n    function createChallenge(\\n        address[2] calldata stakers,\\n        uint64[2] calldata nodeNums,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32 secondExecutionHash,\\n        uint256[2] calldata proposedTimes,\\n        bytes32[2] calldata wasmModuleRoots\\n    ) external;\\n}\\n\\ninterface IRollupUser is IRollupUserAbs {\\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\\n\\n    function newStakeOnNewNode(\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external payable;\\n\\n    function addToDeposit(address stakerAddress) external payable;\\n}\\n\\ninterface IRollupUserERC20 is IRollupUserAbs {\\n    function newStakeOnExistingNode(\\n        uint256 tokenAmount,\\n        uint64 nodeNum,\\n        bytes32 nodeHash\\n    ) external;\\n\\n    function newStakeOnNewNode(\\n        uint256 tokenAmount,\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\\n}\\n\\ninterface IRollupAdmin {\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\\n        external;\\n\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external;\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external;\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setDelayedInbox(address _inbox, bool _enabled) external;\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external;\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\\n\\n    /**\\n     * @notice Set a new owner address for the rollup proxy\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external;\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\\n     */\\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external;\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external;\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake maximum avmgas to be used per block\\n     */\\n    function setBaseStake(uint256 newBaseStake) external;\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User logic!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external;\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external;\\n\\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external;\\n\\n    function forceRefundStaker(address[] memory stacker) external;\\n\\n    function forceCreateNode(\\n        uint64 prevNode,\\n        uint256 prevNodeInboxMaxCount,\\n        RollupLib.Assertion memory assertion,\\n        bytes32 expectedNodeHash\\n    ) external;\\n\\n    function forceConfirmNode(\\n        uint64 nodeNum,\\n        bytes32 blockHash,\\n        bytes32 sendRoot\\n    ) external;\\n\\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external;\\n\\n    /**\\n     * @notice Set the proving WASM module root\\n     * @param newWasmModuleRoot new module root\\n     */\\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external;\\n\\n    /**\\n     * @notice set a new sequencer inbox contract\\n     * @param _sequencerInbox new address of sequencer inbox\\n     */\\n    function setSequencerInbox(address _sequencerInbox) external;\\n}\\n\"\r\n    },\r\n    \"src/libraries/IGasRefunder.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.6.11 <0.9.0;\\n\\ninterface IGasRefunder {\\n    function onGasSpent(\\n        address payable spender,\\n        uint256 gasUsed,\\n        uint256 calldataSize\\n    ) external returns (bool success);\\n}\\n\\nabstract contract GasRefundEnabled {\\n    /// @dev this refunds the sender for execution costs of the tx\\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\\n    modifier refundsGas(IGasRefunder gasRefunder) {\\n        uint256 startGasLeft = gasleft();\\n        _;\\n        if (address(gasRefunder) != address(0)) {\\n            uint256 calldataSize = 0;\\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\\n            if (msg.sender == tx.origin) {\\n                assembly {\\n                    calldataSize := calldatasize()\\n                }\\n            }\\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n// 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\\nuint256 constant MAX_DATA_SIZE = 117964;\\n\\nuint64 constant NO_CHAL_INDEX = 0;\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\nimport \\\"../challenge/ChallengeLib.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IInbox.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"./IRollupLogic.sol\\\";\\n\\nstruct Config {\\n    uint64 confirmPeriodBlocks;\\n    uint64 extraChallengeTimeBlocks;\\n    address stakeToken;\\n    uint256 baseStake;\\n    bytes32 wasmModuleRoot;\\n    address owner;\\n    address loserStakeEscrow;\\n    uint256 chainId;\\n    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;\\n}\\n\\nstruct ContractDependencies {\\n    IBridge bridge;\\n    ISequencerInbox sequencerInbox;\\n    IInbox inbox;\\n    IOutbox outbox;\\n    IRollupEventInbox rollupEventInbox;\\n    IChallengeManager challengeManager;\\n    IRollupAdmin rollupAdminLogic;\\n    IRollupUser rollupUserLogic;\\n    // misc contracts that are useful when interacting with the rollup\\n    address validatorUtils;\\n    address validatorWalletCreator;\\n}\\n\\nlibrary RollupLib {\\n    using GlobalStateLib for GlobalState;\\n\\n    struct ExecutionState {\\n        GlobalState globalState;\\n        MachineStatus machineStatus;\\n    }\\n\\n    function stateHash(ExecutionState calldata execState, uint256 inboxMaxCount)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    execState.globalState.hash(),\\n                    inboxMaxCount,\\n                    execState.machineStatus\\n                )\\n            );\\n    }\\n\\n    /// @dev same as stateHash but expects execState in memory instead of calldata\\n    function stateHashMem(ExecutionState memory execState, uint256 inboxMaxCount)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    execState.globalState.hash(),\\n                    inboxMaxCount,\\n                    execState.machineStatus\\n                )\\n            );\\n    }\\n\\n    struct Assertion {\\n        ExecutionState beforeState;\\n        ExecutionState afterState;\\n        uint64 numBlocks;\\n    }\\n\\n    function executionHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        MachineStatus[2] memory statuses;\\n        statuses[0] = assertion.beforeState.machineStatus;\\n        statuses[1] = assertion.afterState.machineStatus;\\n        GlobalState[2] memory globalStates;\\n        globalStates[0] = assertion.beforeState.globalState;\\n        globalStates[1] = assertion.afterState.globalState;\\n        // TODO: benchmark how much this abstraction adds of gas overhead\\n        return executionHash(statuses, globalStates, assertion.numBlocks);\\n    }\\n\\n    function executionHash(\\n        MachineStatus[2] memory statuses,\\n        GlobalState[2] memory globalStates,\\n        uint64 numBlocks\\n    ) internal pure returns (bytes32) {\\n        bytes32[] memory segments = new bytes32[](2);\\n        segments[0] = ChallengeLib.blockStateHash(statuses[0], globalStates[0].hash());\\n        segments[1] = ChallengeLib.blockStateHash(statuses[1], globalStates[1].hash());\\n        return ChallengeLib.hashChallengeState(0, numBlocks, segments);\\n    }\\n\\n    function challengeRootHash(\\n        bytes32 execution,\\n        uint256 proposedTime,\\n        bytes32 wasmModuleRoot\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(execution, proposedTime, wasmModuleRoot));\\n    }\\n\\n    function confirmHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        return\\n            confirmHash(\\n                assertion.afterState.globalState.getBlockHash(),\\n                assertion.afterState.globalState.getSendRoot()\\n            );\\n    }\\n\\n    function confirmHash(bytes32 blockHash, bytes32 sendRoot) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(blockHash, sendRoot));\\n    }\\n\\n    function nodeHash(\\n        bool hasSibling,\\n        bytes32 lastHash,\\n        bytes32 assertionExecHash,\\n        bytes32 inboxAcc,\\n        bytes32 wasmModuleRoot\\n    ) internal pure returns (bytes32) {\\n        uint8 hasSiblingInt = hasSibling ? 1 : 0;\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    hasSiblingInt,\\n                    lastHash,\\n                    assertionExecHash,\\n                    inboxAcc,\\n                    wasmModuleRoot\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupCore.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Node.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\n\\ninterface IRollupCore {\\n    struct Staker {\\n        uint256 amountStaked;\\n        uint64 index;\\n        uint64 latestStakedNode;\\n        // currentChallenge is 0 if staker is not in a challenge\\n        uint64 currentChallenge;\\n        bool isStaked;\\n    }\\n\\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\\n\\n    event NodeCreated(\\n        uint64 indexed nodeNum,\\n        bytes32 indexed parentNodeHash,\\n        bytes32 indexed nodeHash,\\n        bytes32 executionHash,\\n        RollupLib.Assertion assertion,\\n        bytes32 afterInboxBatchAcc,\\n        bytes32 wasmModuleRoot,\\n        uint256 inboxMaxCount\\n    );\\n\\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\\n\\n    event NodeRejected(uint64 indexed nodeNum);\\n\\n    event RollupChallengeStarted(\\n        uint64 indexed challengeIndex,\\n        address asserter,\\n        address challenger,\\n        uint64 challengedNode\\n    );\\n\\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\\n\\n    event UserWithdrawableFundsUpdated(\\n        address indexed user,\\n        uint256 initialBalance,\\n        uint256 finalBalance\\n    );\\n\\n    function confirmPeriodBlocks() external view returns (uint64);\\n\\n    function extraChallengeTimeBlocks() external view returns (uint64);\\n\\n    function chainId() external view returns (uint256);\\n\\n    function baseStake() external view returns (uint256);\\n\\n    function wasmModuleRoot() external view returns (bytes32);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function outbox() external view returns (IOutbox);\\n\\n    function rollupEventInbox() external view returns (IRollupEventInbox);\\n\\n    function challengeManager() external view returns (IChallengeManager);\\n\\n    function loserStakeEscrow() external view returns (address);\\n\\n    function stakeToken() external view returns (address);\\n\\n    function minimumAssertionPeriod() external view returns (uint256);\\n\\n    function isValidator(address) external view returns (bool);\\n\\n    /**\\n     * @notice Get the Node for the given index.\\n     */\\n    function getNode(uint64 nodeNum) external view returns (Node memory);\\n\\n    /**\\n     * @notice Check if the specified node has been staked on by the provided staker.\\n     * Only accurate at the latest confirmed node and afterwards.\\n     */\\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves stored information about a requested staker\\n     * @param staker Staker address to retrieve\\n     * @return A structure with information about the requested staker\\n     */\\n    function getStaker(address staker) external view returns (Staker memory);\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) external view returns (address);\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() external view returns (uint256);\\n\\n    function isZombie(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) external view returns (uint256);\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() external view returns (uint64);\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() external view returns (uint64);\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() external view returns (uint64);\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view returns (uint64);\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {AlreadyInit, NotRollup} from \\\"../libraries/Error.sol\\\";\\n\\n/// @dev The provided proof was too long\\n/// @param proofLength The length of the too-long proof\\nerror ProofTooLong(uint256 proofLength);\\n\\n/// @dev The output index was greater than the maximum\\n/// @param index The output index\\n/// @param maxIndex The max the index could be\\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\\n\\n/// @dev The calculated root does not exist\\n/// @param root The calculated root\\nerror UnknownRoot(bytes32 root);\\n\\n/// @dev The record has already been spent\\n/// @param index The index of the spent record\\nerror AlreadySpent(uint256 index);\\n\\n/// @dev A call to the bridge failed with no return data\\nerror BridgeCallFailed();\\n\\ninterface IOutbox {\\n    event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\\n    event OutBoxTransactionExecuted(\\n        address indexed to,\\n        address indexed l2Sender,\\n        uint256 indexed zero,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    // @deprecated batch number is now always 0\\n    function l2ToL1BatchNum() external view returns (uint256);\\n\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../osp/IOneStepProofEntry.sol\\\";\\n\\nimport \\\"./IChallengeResultReceiver.sol\\\";\\n\\nimport \\\"./ChallengeLib.sol\\\";\\n\\ninterface IChallengeManager {\\n    enum ChallengeTerminationType {\\n        TIMEOUT,\\n        BLOCK_PROOF,\\n        EXECUTION_PROOF,\\n        CLEARED\\n    }\\n\\n    event InitiatedChallenge(\\n        uint64 indexed challengeIndex,\\n        GlobalState startState,\\n        GlobalState endState\\n    );\\n\\n    event Bisected(\\n        uint64 indexed challengeIndex,\\n        bytes32 indexed challengeRoot,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        bytes32[] chainHashes\\n    );\\n\\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\\n\\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\\n\\n    function initialize(\\n        IChallengeResultReceiver resultReceiver_,\\n        ISequencerInbox sequencerInbox_,\\n        IBridge bridge_,\\n        IOneStepProofEntry osp_\\n    ) external;\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external returns (uint64);\\n\\n    function challengeInfo(uint64 challengeIndex_)\\n        external\\n        view\\n        returns (ChallengeLib.Challenge memory);\\n\\n    function currentResponder(uint64 challengeIndex) external view returns (address);\\n\\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\\n\\n    function currentResponderTimeLeft(uint64 challengeIndex_) external view returns (uint256);\\n\\n    function clearChallenge(uint64 challengeIndex_) external;\\n\\n    function timeout(uint64 challengeIndex_) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/ChallengeLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\n\\nlibrary ChallengeLib {\\n    using MachineLib for Machine;\\n    using ChallengeLib for Challenge;\\n\\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\\n    enum ChallengeMode {\\n        NONE,\\n        BLOCK,\\n        EXECUTION\\n    }\\n\\n    struct Participant {\\n        address addr;\\n        uint256 timeLeft;\\n    }\\n\\n    struct Challenge {\\n        Participant current;\\n        Participant next;\\n        uint256 lastMoveTimestamp;\\n        bytes32 wasmModuleRoot;\\n        bytes32 challengeStateHash;\\n        uint64 maxInboxMessages;\\n        ChallengeMode mode;\\n    }\\n\\n    struct SegmentSelection {\\n        uint256 oldSegmentsStart;\\n        uint256 oldSegmentsLength;\\n        bytes32[] oldSegments;\\n        uint256 challengePosition;\\n    }\\n\\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\\n        return block.timestamp - challenge.lastMoveTimestamp;\\n    }\\n\\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\\n    }\\n\\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // Start the value stack with the function call ABI for the entrypoint\\n        Value[] memory startingValues = new Value[](3);\\n        startingValues[0] = ValueLib.newRefNull();\\n        startingValues[1] = ValueLib.newI32(0);\\n        startingValues[2] = ValueLib.newI32(0);\\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\\n        ValueStack memory internalStack;\\n        StackFrameWindow memory frameStack;\\n\\n        Machine memory mach = Machine({\\n            status: MachineStatus.RUNNING,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: 0,\\n            functionIdx: 0,\\n            functionPc: 0,\\n            modulesRoot: wasmModuleRoot\\n        });\\n        return mach.hash();\\n    }\\n\\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n\\n    function extractChallengeSegment(SegmentSelection calldata selection)\\n        internal\\n        pure\\n        returns (uint256 segmentStart, uint256 segmentLength)\\n    {\\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\\n        // Intentionally done before challengeLength is potentially added to for the final segment\\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\\n        }\\n    }\\n\\n    function hashChallengeState(\\n        uint256 segmentsStart,\\n        uint256 segmentsLength,\\n        bytes32[] memory segments\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\\n    }\\n\\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Block state:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Block state, errored:\\\", globalStateHash));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Block state, too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/GlobalState.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct GlobalState {\\n    bytes32[2] bytes32Vals;\\n    uint64[2] u64Vals;\\n}\\n\\nlibrary GlobalStateLib {\\n    uint16 internal constant BYTES32_VALS_NUM = 2;\\n    uint16 internal constant U64_VALS_NUM = 2;\\n\\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Global state:\\\",\\n                    state.bytes32Vals[0],\\n                    state.bytes32Vals[1],\\n                    state.u64Vals[0],\\n                    state.u64Vals[1]\\n                )\\n            );\\n    }\\n\\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[0];\\n    }\\n\\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[1];\\n    }\\n\\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[0];\\n    }\\n\\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[1];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function rollupInitialized(uint256 chainId) external;\\n}\\n\"\r\n    },\r\n    \"src/state/Machine.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\n\\nenum MachineStatus {\\n    RUNNING,\\n    FINISHED,\\n    ERRORED,\\n    TOO_FAR\\n}\\n\\nstruct Machine {\\n    MachineStatus status;\\n    ValueStack valueStack;\\n    ValueStack internalStack;\\n    StackFrameWindow frameStack;\\n    bytes32 globalStateHash;\\n    uint32 moduleIdx;\\n    uint32 functionIdx;\\n    uint32 functionPc;\\n    bytes32 modulesRoot;\\n}\\n\\nlibrary MachineLib {\\n    using StackFrameLib for StackFrameWindow;\\n    using ValueStackLib for ValueStack;\\n\\n    function hash(Machine memory mach) internal pure returns (bytes32) {\\n        // Warning: the non-running hashes are replicated in Challenge\\n        if (mach.status == MachineStatus.RUNNING) {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"Machine running:\\\",\\n                        mach.valueStack.hash(),\\n                        mach.internalStack.hash(),\\n                        mach.frameStack.hash(),\\n                        mach.globalStateHash,\\n                        mach.moduleIdx,\\n                        mach.functionIdx,\\n                        mach.functionPc,\\n                        mach.modulesRoot\\n                    )\\n                );\\n        } else if (mach.status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", mach.globalStateHash));\\n        } else if (mach.status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (mach.status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_MACH_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProofEntry.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOneStepProver.sol\\\";\\n\\nlibrary OneStepProofEntryLib {\\n    uint256 internal constant MAX_STEPS = 1 << 43;\\n}\\n\\ninterface IOneStepProofEntry {\\n    function proveOneStep(\\n        ExecutionContext calldata execCtx,\\n        uint256 machineStep,\\n        bytes32 beforeHash,\\n        bytes calldata proof\\n    ) external view returns (bytes32 afterHash);\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeResultReceiver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChallengeResultReceiver {\\n    function completeChallenge(\\n        uint256 challengeIndex,\\n        address winner,\\n        address loser\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/state/ValueStack.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueArray.sol\\\";\\n\\nstruct ValueStack {\\n    ValueArray proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary ValueStackLib {\\n    using ValueLib for Value;\\n    using ValueArrayLib for ValueArray;\\n\\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\\n        h = stack.remainingHash;\\n        uint256 len = stack.proved.length();\\n        for (uint256 i = 0; i < len; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Value stack:\\\", stack.proved.get(i).hash(), h));\\n        }\\n    }\\n\\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\\n        uint256 len = stack.proved.length();\\n        return stack.proved.get(len - 1);\\n    }\\n\\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\\n        return stack.proved.pop();\\n    }\\n\\n    function push(ValueStack memory stack, Value memory val) internal pure {\\n        return stack.proved.push(val);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Instructions.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Instruction {\\n    uint16 opcode;\\n    uint256 argumentData;\\n}\\n\\nlibrary Instructions {\\n    uint16 internal constant UNREACHABLE = 0x00;\\n    uint16 internal constant NOP = 0x01;\\n    uint16 internal constant RETURN = 0x0F;\\n    uint16 internal constant CALL = 0x10;\\n    uint16 internal constant CALL_INDIRECT = 0x11;\\n    uint16 internal constant LOCAL_GET = 0x20;\\n    uint16 internal constant LOCAL_SET = 0x21;\\n    uint16 internal constant GLOBAL_GET = 0x23;\\n    uint16 internal constant GLOBAL_SET = 0x24;\\n\\n    uint16 internal constant I32_LOAD = 0x28;\\n    uint16 internal constant I64_LOAD = 0x29;\\n    uint16 internal constant F32_LOAD = 0x2A;\\n    uint16 internal constant F64_LOAD = 0x2B;\\n    uint16 internal constant I32_LOAD8_S = 0x2C;\\n    uint16 internal constant I32_LOAD8_U = 0x2D;\\n    uint16 internal constant I32_LOAD16_S = 0x2E;\\n    uint16 internal constant I32_LOAD16_U = 0x2F;\\n    uint16 internal constant I64_LOAD8_S = 0x30;\\n    uint16 internal constant I64_LOAD8_U = 0x31;\\n    uint16 internal constant I64_LOAD16_S = 0x32;\\n    uint16 internal constant I64_LOAD16_U = 0x33;\\n    uint16 internal constant I64_LOAD32_S = 0x34;\\n    uint16 internal constant I64_LOAD32_U = 0x35;\\n\\n    uint16 internal constant I32_STORE = 0x36;\\n    uint16 internal constant I64_STORE = 0x37;\\n    uint16 internal constant F32_STORE = 0x38;\\n    uint16 internal constant F64_STORE = 0x39;\\n    uint16 internal constant I32_STORE8 = 0x3A;\\n    uint16 internal constant I32_STORE16 = 0x3B;\\n    uint16 internal constant I64_STORE8 = 0x3C;\\n    uint16 internal constant I64_STORE16 = 0x3D;\\n    uint16 internal constant I64_STORE32 = 0x3E;\\n\\n    uint16 internal constant MEMORY_SIZE = 0x3F;\\n    uint16 internal constant MEMORY_GROW = 0x40;\\n\\n    uint16 internal constant DROP = 0x1A;\\n    uint16 internal constant SELECT = 0x1B;\\n    uint16 internal constant I32_CONST = 0x41;\\n    uint16 internal constant I64_CONST = 0x42;\\n    uint16 internal constant F32_CONST = 0x43;\\n    uint16 internal constant F64_CONST = 0x44;\\n    uint16 internal constant I32_EQZ = 0x45;\\n    uint16 internal constant I32_RELOP_BASE = 0x46;\\n    uint16 internal constant IRELOP_EQ = 0;\\n    uint16 internal constant IRELOP_NE = 1;\\n    uint16 internal constant IRELOP_LT_S = 2;\\n    uint16 internal constant IRELOP_LT_U = 3;\\n    uint16 internal constant IRELOP_GT_S = 4;\\n    uint16 internal constant IRELOP_GT_U = 5;\\n    uint16 internal constant IRELOP_LE_S = 6;\\n    uint16 internal constant IRELOP_LE_U = 7;\\n    uint16 internal constant IRELOP_GE_S = 8;\\n    uint16 internal constant IRELOP_GE_U = 9;\\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\\n\\n    uint16 internal constant I64_EQZ = 0x50;\\n    uint16 internal constant I64_RELOP_BASE = 0x51;\\n\\n    uint16 internal constant I32_UNOP_BASE = 0x67;\\n    uint16 internal constant IUNOP_CLZ = 0;\\n    uint16 internal constant IUNOP_CTZ = 1;\\n    uint16 internal constant IUNOP_POPCNT = 2;\\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\\n\\n    uint16 internal constant I32_ADD = 0x6A;\\n    uint16 internal constant I32_SUB = 0x6B;\\n    uint16 internal constant I32_MUL = 0x6C;\\n    uint16 internal constant I32_DIV_S = 0x6D;\\n    uint16 internal constant I32_DIV_U = 0x6E;\\n    uint16 internal constant I32_REM_S = 0x6F;\\n    uint16 internal constant I32_REM_U = 0x70;\\n    uint16 internal constant I32_AND = 0x71;\\n    uint16 internal constant I32_OR = 0x72;\\n    uint16 internal constant I32_XOR = 0x73;\\n    uint16 internal constant I32_SHL = 0x74;\\n    uint16 internal constant I32_SHR_S = 0x75;\\n    uint16 internal constant I32_SHR_U = 0x76;\\n    uint16 internal constant I32_ROTL = 0x77;\\n    uint16 internal constant I32_ROTR = 0x78;\\n\\n    uint16 internal constant I64_UNOP_BASE = 0x79;\\n\\n    uint16 internal constant I64_ADD = 0x7C;\\n    uint16 internal constant I64_SUB = 0x7D;\\n    uint16 internal constant I64_MUL = 0x7E;\\n    uint16 internal constant I64_DIV_S = 0x7F;\\n    uint16 internal constant I64_DIV_U = 0x80;\\n    uint16 internal constant I64_REM_S = 0x81;\\n    uint16 internal constant I64_REM_U = 0x82;\\n    uint16 internal constant I64_AND = 0x83;\\n    uint16 internal constant I64_OR = 0x84;\\n    uint16 internal constant I64_XOR = 0x85;\\n    uint16 internal constant I64_SHL = 0x86;\\n    uint16 internal constant I64_SHR_S = 0x87;\\n    uint16 internal constant I64_SHR_U = 0x88;\\n    uint16 internal constant I64_ROTL = 0x89;\\n    uint16 internal constant I64_ROTR = 0x8A;\\n\\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\\n\\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\\n\\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\\n\\n    uint16 internal constant INIT_FRAME = 0x8002;\\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\\n    uint16 internal constant DUP = 0x8008;\\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\\n\\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\\n\\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\\n\\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\\n\\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Instruction:\\\", inst.opcode, inst.argumentData));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/StackFrame.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct StackFrame {\\n    Value returnPc;\\n    bytes32 localsMerkleRoot;\\n    uint32 callerModule;\\n    uint32 callerModuleInternals;\\n}\\n\\nstruct StackFrameWindow {\\n    StackFrame[] proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary StackFrameLib {\\n    using ValueLib for Value;\\n\\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Stack frame:\\\",\\n                    frame.returnPc.hash(),\\n                    frame.localsMerkleRoot,\\n                    frame.callerModule,\\n                    frame.callerModuleInternals\\n                )\\n            );\\n    }\\n\\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\\n        h = window.remainingHash;\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Stack frame stack:\\\", hash(window.proved[i]), h));\\n        }\\n    }\\n\\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        return window.proved[0];\\n    }\\n\\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        frame = window.proved[0];\\n        window.proved = new StackFrame[](0);\\n    }\\n\\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            newProved[i] = window.proved[i];\\n        }\\n        newProved[window.proved.length] = frame;\\n        window.proved = newProved;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Value.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nenum ValueType {\\n    I32,\\n    I64,\\n    F32,\\n    F64,\\n    REF_NULL,\\n    FUNC_REF,\\n    INTERNAL_REF\\n}\\n\\nstruct Value {\\n    ValueType valueType;\\n    uint256 contents;\\n}\\n\\nlibrary ValueLib {\\n    function hash(Value memory val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Value:\\\", val.valueType, val.contents));\\n    }\\n\\n    function maxValueType() internal pure returns (ValueType) {\\n        return ValueType.INTERNAL_REF;\\n    }\\n\\n    function assumeI32(Value memory val) internal pure returns (uint32) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I32, \\\"NOT_I32\\\");\\n        require(uintval < (1 << 32), \\\"BAD_I32\\\");\\n        return uint32(uintval);\\n    }\\n\\n    function assumeI64(Value memory val) internal pure returns (uint64) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I64, \\\"NOT_I64\\\");\\n        require(uintval < (1 << 64), \\\"BAD_I64\\\");\\n        return uint64(uintval);\\n    }\\n\\n    function newRefNull() internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\\n    }\\n\\n    function newI32(uint32 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\\n    }\\n\\n    function newI64(uint64 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\\n    }\\n\\n    function newBoolean(bool x) internal pure returns (Value memory) {\\n        if (x) {\\n            return newI32(uint32(1));\\n        } else {\\n            return newI32(uint32(0));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueArray.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct ValueArray {\\n    Value[] inner;\\n}\\n\\nlibrary ValueArrayLib {\\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\\n        return arr.inner[index];\\n    }\\n\\n    function set(\\n        ValueArray memory arr,\\n        uint256 index,\\n        Value memory val\\n    ) internal pure {\\n        arr.inner[index] = val;\\n    }\\n\\n    function length(ValueArray memory arr) internal pure returns (uint256) {\\n        return arr.inner.length;\\n    }\\n\\n    function push(ValueArray memory arr, Value memory val) internal pure {\\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\\n        for (uint256 i = 0; i < arr.inner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        newInner[arr.inner.length] = val;\\n        arr.inner = newInner;\\n    }\\n\\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\\n        popped = arr.inner[arr.inner.length - 1];\\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\\n        for (uint256 i = 0; i < newInner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        arr.inner = newInner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Instructions.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\nstruct ExecutionContext {\\n    uint256 maxInboxMessagesRead;\\n    IBridge bridge;\\n}\\n\\nabstract contract IOneStepProver {\\n    function executeOneStep(\\n        ExecutionContext memory execCtx,\\n        Machine calldata mach,\\n        Module calldata mod,\\n        Instruction calldata instruction,\\n        bytes calldata proof\\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\\n}\\n\"\r\n    },\r\n    \"src/state/Module.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ModuleMemory.sol\\\";\\n\\nstruct Module {\\n    bytes32 globalsMerkleRoot;\\n    ModuleMemory moduleMemory;\\n    bytes32 tablesMerkleRoot;\\n    bytes32 functionsMerkleRoot;\\n    uint32 internalsOffset;\\n}\\n\\nlibrary ModuleLib {\\n    using ModuleMemoryLib for ModuleMemory;\\n\\n    function hash(Module memory mod) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Module:\\\",\\n                    mod.globalsMerkleRoot,\\n                    mod.moduleMemory.hash(),\\n                    mod.tablesMerkleRoot,\\n                    mod.functionsMerkleRoot,\\n                    mod.internalsOffset\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ModuleMemory.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./Deserialize.sol\\\";\\n\\nstruct ModuleMemory {\\n    uint64 size;\\n    uint64 maxSize;\\n    bytes32 merkleRoot;\\n}\\n\\nlibrary ModuleMemoryLib {\\n    using MerkleProofLib for MerkleProof;\\n\\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Memory:\\\", mem.size, mem.maxSize, mem.merkleRoot));\\n    }\\n\\n    function proveLeaf(\\n        ModuleMemory memory mem,\\n        uint256 leafIdx,\\n        bytes calldata proof,\\n        uint256 startOffset\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 contents,\\n            uint256 offset,\\n            MerkleProof memory merkle\\n        )\\n    {\\n        offset = startOffset;\\n        (contents, offset) = Deserialize.b32(proof, offset);\\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\\n        bytes32 recomputedRoot = merkle.computeRootFromMemory(leafIdx, contents);\\n        require(recomputedRoot == mem.merkleRoot, \\\"WRONG_MEM_ROOT\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/MerkleProof.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./Module.sol\\\";\\n\\nstruct MerkleProof {\\n    bytes32[] counterparts;\\n}\\n\\nlibrary MerkleProofLib {\\n    using ModuleLib for Module;\\n    using ValueLib for Value;\\n\\n    function computeRootFromValue(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Value memory leaf\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, leaf.hash(), \\\"Value merkle tree:\\\");\\n    }\\n\\n    function computeRootFromInstruction(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Instruction memory inst\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, Instructions.hash(inst), \\\"Instruction merkle tree:\\\");\\n    }\\n\\n    function computeRootFromFunction(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 codeRoot\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Function:\\\", codeRoot));\\n        return computeRootUnsafe(proof, index, h, \\\"Function merkle tree:\\\");\\n    }\\n\\n    function computeRootFromMemory(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 contents\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Memory leaf:\\\", contents));\\n        return computeRootUnsafe(proof, index, h, \\\"Memory merkle tree:\\\");\\n    }\\n\\n    function computeRootFromElement(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 funcTypeHash,\\n        Value memory val\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Table element:\\\", funcTypeHash, val.hash()));\\n        return computeRootUnsafe(proof, index, h, \\\"Table element merkle tree:\\\");\\n    }\\n\\n    function computeRootFromTable(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        uint8 tableType,\\n        uint64 tableSize,\\n        bytes32 elementsRoot\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Table:\\\", tableType, tableSize, elementsRoot));\\n        return computeRootUnsafe(proof, index, h, \\\"Table merkle tree:\\\");\\n    }\\n\\n    function computeRootFromModule(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Module memory mod\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, mod.hash(), \\\"Module merkle tree:\\\");\\n    }\\n\\n    // WARNING: leafHash must be computed in such a way that it cannot be a non-leaf hash.\\n    function computeRootUnsafe(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 leafHash,\\n        string memory prefix\\n    ) internal pure returns (bytes32 h) {\\n        h = leafHash;\\n        for (uint256 layer = 0; layer < proof.counterparts.length; layer++) {\\n            if (index & 1 == 0) {\\n                h = keccak256(abi.encodePacked(prefix, h, proof.counterparts[layer]));\\n            } else {\\n                h = keccak256(abi.encodePacked(prefix, proof.counterparts[layer], h));\\n            }\\n            index >>= 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Deserialize.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Machine.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./ModuleMemory.sol\\\";\\nimport \\\"./Module.sol\\\";\\nimport \\\"./GlobalState.sol\\\";\\n\\nlibrary Deserialize {\\n    function u8(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint8 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        ret = uint8(proof[offset]);\\n        offset++;\\n    }\\n\\n    function u16(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint16 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 16 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u32(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint32 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 32 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u64(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint64 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 64 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u256(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint256 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 256 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function b32(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (bytes32 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint256 retInt;\\n        (retInt, offset) = u256(proof, offset);\\n        ret = bytes32(retInt);\\n    }\\n\\n    function value(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Value memory val, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint8 typeInt = uint8(proof[offset]);\\n        offset++;\\n        require(typeInt <= uint8(ValueLib.maxValueType()), \\\"BAD_VALUE_TYPE\\\");\\n        uint256 contents;\\n        (contents, offset) = u256(proof, offset);\\n        val = Value({valueType: ValueType(typeInt), contents: contents});\\n    }\\n\\n    function valueStack(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (ValueStack memory stack, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 remainingHash;\\n        (remainingHash, offset) = b32(proof, offset);\\n        uint256 provedLength;\\n        (provedLength, offset) = u256(proof, offset);\\n        Value[] memory proved = new Value[](provedLength);\\n        for (uint256 i = 0; i < proved.length; i++) {\\n            (proved[i], offset) = value(proof, offset);\\n        }\\n        stack = ValueStack({proved: ValueArray(proved), remainingHash: remainingHash});\\n    }\\n\\n    function instruction(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Instruction memory inst, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint16 opcode;\\n        uint256 data;\\n        (opcode, offset) = u16(proof, offset);\\n        (data, offset) = u256(proof, offset);\\n        inst = Instruction({opcode: opcode, argumentData: data});\\n    }\\n\\n    function stackFrame(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (StackFrame memory window, uint256 offset)\\n    {\\n        offset = startOffset;\\n        Value memory returnPc;\\n        bytes32 localsMerkleRoot;\\n        uint32 callerModule;\\n        uint32 callerModuleInternals;\\n        (returnPc, offset) = value(proof, offset);\\n        (localsMerkleRoot, offset) = b32(proof, offset);\\n        (callerModule, offset) = u32(proof, offset);\\n        (callerModuleInternals, offset) = u32(proof, offset);\\n        window = StackFrame({\\n            returnPc: returnPc,\\n            localsMerkleRoot: localsMerkleRoot,\\n            callerModule: callerModule,\\n            callerModuleInternals: callerModuleInternals\\n        });\\n    }\\n\\n    function stackFrameWindow(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (StackFrameWindow memory window, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 remainingHash;\\n        (remainingHash, offset) = b32(proof, offset);\\n        StackFrame[] memory proved;\\n        if (proof[offset] != 0) {\\n            offset++;\\n            proved = new StackFrame[](1);\\n            (proved[0], offset) = stackFrame(proof, offset);\\n        } else {\\n            offset++;\\n            proved = new StackFrame[](0);\\n        }\\n        window = StackFrameWindow({proved: proved, remainingHash: remainingHash});\\n    }\\n\\n    function moduleMemory(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (ModuleMemory memory mem, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint64 size;\\n        uint64 maxSize;\\n        bytes32 root;\\n        (size, offset) = u64(proof, offset);\\n        (maxSize, offset) = u64(proof, offset);\\n        (root, offset) = b32(proof, offset);\\n        mem = ModuleMemory({size: size, maxSize: maxSize, merkleRoot: root});\\n    }\\n\\n    function module(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Module memory mod, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 globalsMerkleRoot;\\n        ModuleMemory memory mem;\\n        bytes32 tablesMerkleRoot;\\n        bytes32 functionsMerkleRoot;\\n        uint32 internalsOffset;\\n        (globalsMerkleRoot, offset) = b32(proof, offset);\\n        (mem, offset) = moduleMemory(proof, offset);\\n        (tablesMerkleRoot, offset) = b32(proof, offset);\\n        (functionsMerkleRoot, offset) = b32(proof, offset);\\n        (internalsOffset, offset) = u32(proof, offset);\\n        mod = Module({\\n            globalsMerkleRoot: globalsMerkleRoot,\\n            moduleMemory: mem,\\n            tablesMerkleRoot: tablesMerkleRoot,\\n            functionsMerkleRoot: functionsMerkleRoot,\\n            internalsOffset: internalsOffset\\n        });\\n    }\\n\\n    function globalState(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (GlobalState memory state, uint256 offset)\\n    {\\n        offset = startOffset;\\n\\n        // using constant ints for array size requires newer solidity\\n        bytes32[2] memory bytes32Vals;\\n        uint64[2] memory u64Vals;\\n\\n        for (uint8 i = 0; i < GlobalStateLib.BYTES32_VALS_NUM; i++) {\\n            (bytes32Vals[i], offset) = b32(proof, offset);\\n        }\\n        for (uint8 i = 0; i < GlobalStateLib.U64_VALS_NUM; i++) {\\n            (u64Vals[i], offset) = u64(proof, offset);\\n        }\\n        state = GlobalState({bytes32Vals: bytes32Vals, u64Vals: u64Vals});\\n    }\\n\\n    function machine(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Machine memory mach, uint256 offset)\\n    {\\n        offset = startOffset;\\n        MachineStatus status;\\n        {\\n            uint8 statusU8;\\n            (statusU8, offset) = u8(proof, offset);\\n            if (statusU8 == 0) {\\n                status = MachineStatus.RUNNING;\\n            } else if (statusU8 == 1) {\\n                status = MachineStatus.FINISHED;\\n            } else if (statusU8 == 2) {\\n                status = MachineStatus.ERRORED;\\n            } else if (statusU8 == 3) {\\n                status = MachineStatus.TOO_FAR;\\n            } else {\\n                revert(\\\"UNKNOWN_MACH_STATUS\\\");\\n            }\\n        }\\n        ValueStack memory values;\\n        ValueStack memory internalStack;\\n        bytes32 globalStateHash;\\n        uint32 moduleIdx;\\n        uint32 functionIdx;\\n        uint32 functionPc;\\n        StackFrameWindow memory frameStack;\\n        bytes32 modulesRoot;\\n        (values, offset) = valueStack(proof, offset);\\n        (internalStack, offset) = valueStack(proof, offset);\\n        (frameStack, offset) = stackFrameWindow(proof, offset);\\n        (globalStateHash, offset) = b32(proof, offset);\\n        (moduleIdx, offset) = u32(proof, offset);\\n        (functionIdx, offset) = u32(proof, offset);\\n        (functionPc, offset) = u32(proof, offset);\\n        (modulesRoot, offset) = b32(proof, offset);\\n        mach = Machine({\\n            status: status,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: moduleIdx,\\n            functionIdx: functionIdx,\\n            functionPc: functionPc,\\n            modulesRoot: modulesRoot\\n        });\\n    }\\n\\n    function merkleProof(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (MerkleProof memory merkle, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint8 length;\\n        (length, offset) = u8(proof, offset);\\n        bytes32[] memory counterparts = new bytes32[](length);\\n        for (uint8 i = 0; i < length; i++) {\\n            (counterparts[i], offset) = b32(proof, offset);\\n        }\\n        merkle = MerkleProof(counterparts);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/Node.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Node {\\n    // Hash of the state of the chain as of this node\\n    bytes32 stateHash;\\n    // Hash of the data that can be challenged\\n    bytes32 challengeHash;\\n    // Hash of the data that will be committed if this node is confirmed\\n    bytes32 confirmData;\\n    // Index of the node previous to this one\\n    uint64 prevNum;\\n    // Deadline at which this node can be confirmed\\n    uint64 deadlineBlock;\\n    // Deadline at which a child of this node can be confirmed\\n    uint64 noChildConfirmedBeforeBlock;\\n    // Number of stakers staked on this node. This includes real stakers and zombies\\n    uint64 stakerCount;\\n    // Number of stakers staked on a child node. This includes real stakers and zombies\\n    uint64 childStakerCount;\\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\\n    uint64 firstChildBlock;\\n    // The number of the latest child of this node to be created\\n    uint64 latestChildNumber;\\n    // The block number when this node was created\\n    uint64 createdAtBlock;\\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\\n    bytes32 nodeHash;\\n}\\n\\n/**\\n * @notice Utility functions for Node\\n */\\nlibrary NodeLib {\\n    /**\\n     * @notice Initialize a Node\\n     * @param _stateHash Initial value of stateHash\\n     * @param _challengeHash Initial value of challengeHash\\n     * @param _confirmData Initial value of confirmData\\n     * @param _prevNum Initial value of prevNum\\n     * @param _deadlineBlock Initial value of deadlineBlock\\n     * @param _nodeHash Initial value of nodeHash\\n     */\\n    function createNode(\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint64 _prevNum,\\n        uint64 _deadlineBlock,\\n        bytes32 _nodeHash\\n    ) internal view returns (Node memory) {\\n        Node memory node;\\n        node.stateHash = _stateHash;\\n        node.challengeHash = _challengeHash;\\n        node.confirmData = _confirmData;\\n        node.prevNum = _prevNum;\\n        node.deadlineBlock = _deadlineBlock;\\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\\n        node.createdAtBlock = uint64(block.number);\\n        node.nodeHash = _nodeHash;\\n        return node;\\n    }\\n\\n    /**\\n     * @notice Update child properties\\n     * @param number The child number to set\\n     */\\n    function childCreated(Node storage self, uint64 number) internal {\\n        if (self.firstChildBlock == 0) {\\n            self.firstChildBlock = uint64(block.number);\\n        }\\n        self.latestChildNumber = number;\\n    }\\n\\n    /**\\n     * @notice Update the child confirmed deadline\\n     * @param deadline The new deadline to set\\n     */\\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\\n        self.noChildConfirmedBeforeBlock = deadline;\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed the node's deadline\\n     */\\n    function requirePastDeadline(Node memory self) internal view {\\n        require(block.number >= self.deadlineBlock, \\\"BEFORE_DEADLINE\\\");\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\\n     */\\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\\n        require(block.number >= self.noChildConfirmedBeforeBlock, \\\"CHILD_TOO_RECENT\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/AddressAliasHelper.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressAliasHelper {\\n    uint160 internal constant OFFSET = uint160(0x1111000000000000000000000000000000001111);\\n\\n    /// @notice Utility function that converts the address in the L1 that submitted a tx to\\n    /// the inbox to the msg.sender viewed in the L2\\n    /// @param l1Address the address in the L1 that triggered the tx to L2\\n    /// @return l2Address L2 address as viewed in msg.sender\\n    function applyL1ToL2Alias(address l1Address) internal pure returns (address l2Address) {\\n        unchecked {\\n            l2Address = address(uint160(l1Address) + OFFSET);\\n        }\\n    }\\n\\n    /// @notice Utility function that converts the msg.sender viewed in the L2 to the\\n    /// address in the L1 that submitted a tx to the inbox\\n    /// @param l2Address L2 address as viewed in msg.sender\\n    /// @return l1Address the address in the L1 that triggered the tx to L2\\n    function undoL1ToL2Alias(address l2Address) internal pure returns (address l1Address) {\\n        unchecked {\\n            l1Address = address(uint160(l2Address) - OFFSET);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/libraries/MerkleLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {MerkleProofTooLong} from \\\"./Error.sol\\\";\\n\\nlibrary MerkleLib {\\n    function generateRoot(bytes32[] memory _hashes) internal pure returns (bytes32) {\\n        bytes32[] memory prevLayer = _hashes;\\n        while (prevLayer.length > 1) {\\n            bytes32[] memory nextLayer = new bytes32[]((prevLayer.length + 1) / 2);\\n            for (uint256 i = 0; i < nextLayer.length; i++) {\\n                if (2 * i + 1 < prevLayer.length) {\\n                    nextLayer[i] = keccak256(\\n                        abi.encodePacked(prevLayer[2 * i], prevLayer[2 * i + 1])\\n                    );\\n                } else {\\n                    nextLayer[i] = prevLayer[2 * i];\\n                }\\n            }\\n            prevLayer = nextLayer;\\n        }\\n        return prevLayer[0];\\n    }\\n\\n    function calculateRoot(\\n        bytes32[] memory nodes,\\n        uint256 route,\\n        bytes32 item\\n    ) internal pure returns (bytes32) {\\n        uint256 proofItems = nodes.length;\\n        if (proofItems > 256) revert MerkleProofTooLong(proofItems, 256);\\n        bytes32 h = item;\\n        for (uint256 i = 0; i < proofItems; i++) {\\n            bytes32 node = nodes[i];\\n            if (route % 2 == 0) {\\n                assembly {\\n                    mstore(0x00, h)\\n                    mstore(0x20, node)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            } else {\\n                assembly {\\n                    mstore(0x00, node)\\n                    mstore(0x20, h)\\n                    h := keccak256(0x00, 0x40)\\n                }\\n            }\\n            route /= 2;\\n        }\\n        return h;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967Proxy.sol\\\";\\n\\n/**\\n * @dev This contract implements a proxy that is upgradeable by an admin.\\n *\\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\\n * clashing], which can potentially be used in an attack, this contract uses the\\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\\n * things that go hand in hand:\\n *\\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\\n * that call matches one of the admin functions exposed by the proxy itself.\\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\\n * \\\"admin cannot fallback to proxy target\\\".\\n *\\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\\n * to sudden errors when trying to call a function from the proxy implementation.\\n *\\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\\n */\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\n    /**\\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\\n     */\\n    constructor(\\n        address _logic,\\n        address admin_,\\n        bytes memory _data\\n    ) payable ERC1967Proxy(_logic, _data) {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        _changeAdmin(admin_);\\n    }\\n\\n    /**\\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\\n     */\\n    modifier ifAdmin() {\\n        if (msg.sender == _getAdmin()) {\\n            _;\\n        } else {\\n            _fallback();\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\\n     */\\n    function admin() external ifAdmin returns (address admin_) {\\n        admin_ = _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\\n     *\\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\\n     */\\n    function implementation() external ifAdmin returns (address implementation_) {\\n        implementation_ = _implementation();\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\\n     */\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\n        _changeAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\\n     */\\n    function upgradeTo(address newImplementation) external ifAdmin {\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\\n     * proxied contract.\\n     *\\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\n        _upgradeToAndCall(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _admin() internal view virtual returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    /**\\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\\n     */\\n    function _beforeFallback() internal virtual override {\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Proxy.sol\\\";\\nimport \\\"./ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\\n * implementation address that can be changed. This address is stored in storage in the location specified by\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\\n * implementation behind the proxy.\\n */\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\\n     *\\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\\n     */\\n    constructor(address _logic, bytes memory _data) payable {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\n        _upgradeToAndCall(_logic, _data, false);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _implementation() internal view virtual override returns (address impl) {\\n        return ERC1967Upgrade._getImplementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeacon.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/StorageSlot.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            Address.isContract(IBeacon(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822Proxiable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupCreator.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BridgeCreator.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../libraries/ArbitrumProxy.sol\\\";\\n\\ncontract RollupCreator is Ownable {\\n    event RollupCreated(\\n        address indexed rollupAddress,\\n        address inboxAddress,\\n        address adminProxy,\\n        address sequencerInbox,\\n        address bridge\\n    );\\n    event TemplatesUpdated();\\n\\n    BridgeCreator public bridgeCreator;\\n    IOneStepProofEntry public osp;\\n    IChallengeManager public challengeManagerTemplate;\\n    IRollupAdmin public rollupAdminLogic;\\n    IRollupUser public rollupUserLogic;\\n\\n    address public validatorUtils;\\n    address public validatorWalletCreator;\\n\\n    constructor() Ownable() {}\\n\\n    function setTemplates(\\n        BridgeCreator _bridgeCreator,\\n        IOneStepProofEntry _osp,\\n        IChallengeManager _challengeManagerLogic,\\n        IRollupAdmin _rollupAdminLogic,\\n        IRollupUser _rollupUserLogic,\\n        address _validatorUtils,\\n        address _validatorWalletCreator\\n    ) external onlyOwner {\\n        bridgeCreator = _bridgeCreator;\\n        osp = _osp;\\n        challengeManagerTemplate = _challengeManagerLogic;\\n        rollupAdminLogic = _rollupAdminLogic;\\n        rollupUserLogic = _rollupUserLogic;\\n        validatorUtils = _validatorUtils;\\n        validatorWalletCreator = _validatorWalletCreator;\\n        emit TemplatesUpdated();\\n    }\\n\\n    struct CreateRollupFrame {\\n        ProxyAdmin admin;\\n        IBridge bridge;\\n        ISequencerInbox sequencerInbox;\\n        IInbox inbox;\\n        IRollupEventInbox rollupEventInbox;\\n        IOutbox outbox;\\n        ArbitrumProxy rollup;\\n    }\\n\\n    // After this setup:\\n    // Rollup should be the owner of bridge\\n    // RollupOwner should be the owner of Rollup's ProxyAdmin\\n    // RollupOwner should be the owner of Rollup\\n    // Bridge should have a single inbox and outbox\\n    function createRollup(Config memory config, address expectedRollupAddr)\\n        external\\n        returns (address)\\n    {\\n        CreateRollupFrame memory frame;\\n        frame.admin = new ProxyAdmin();\\n\\n        (\\n            frame.bridge,\\n            frame.sequencerInbox,\\n            frame.inbox,\\n            frame.rollupEventInbox,\\n            frame.outbox\\n        ) = bridgeCreator.createBridge(\\n            address(frame.admin),\\n            expectedRollupAddr,\\n            config.sequencerInboxMaxTimeVariation\\n        );\\n\\n        frame.admin.transferOwnership(config.owner);\\n\\n        IChallengeManager challengeManager = IChallengeManager(\\n            address(\\n                new TransparentUpgradeableProxy(\\n                    address(challengeManagerTemplate),\\n                    address(frame.admin),\\n                    \\\"\\\"\\n                )\\n            )\\n        );\\n        challengeManager.initialize(\\n            IChallengeResultReceiver(expectedRollupAddr),\\n            frame.sequencerInbox,\\n            frame.bridge,\\n            osp\\n        );\\n\\n        frame.rollup = new ArbitrumProxy(\\n            config,\\n            ContractDependencies({\\n                bridge: frame.bridge,\\n                sequencerInbox: frame.sequencerInbox,\\n                inbox: frame.inbox,\\n                outbox: frame.outbox,\\n                rollupEventInbox: frame.rollupEventInbox,\\n                challengeManager: challengeManager,\\n                rollupAdminLogic: rollupAdminLogic,\\n                rollupUserLogic: rollupUserLogic,\\n                validatorUtils: validatorUtils,\\n                validatorWalletCreator: validatorWalletCreator\\n            })\\n        );\\n        require(address(frame.rollup) == expectedRollupAddr, \\\"WRONG_ROLLUP_ADDR\\\");\\n\\n        emit RollupCreated(\\n            address(frame.rollup),\\n            address(frame.inbox),\\n            address(frame.admin),\\n            address(frame.sequencerInbox),\\n            address(frame.bridge)\\n        );\\n        return address(frame.rollup);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/ArbitrumProxy.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AdminFallbackProxy.sol\\\";\\nimport \\\"../rollup/IRollupLogic.sol\\\";\\n\\ncontract ArbitrumProxy is AdminFallbackProxy {\\n    constructor(Config memory config, ContractDependencies memory connectedContracts)\\n        AdminFallbackProxy(\\n            address(connectedContracts.rollupAdminLogic),\\n            abi.encodeWithSelector(IRollupAdmin.initialize.selector, config, connectedContracts),\\n            address(connectedContracts.rollupUserLogic),\\n            abi.encodeWithSelector(IRollupUserAbs.initialize.selector, config.stakeToken),\\n            config.owner\\n        )\\n    {}\\n}\\n\"\r\n    },\r\n    \"src/libraries/AdminFallbackProxy.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice An extension to OZ's ERC1967Upgrade implementation to support two logic contracts\\nabstract contract DoubleLogicERC1967Upgrade is ERC1967Upgrade {\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.implementation.secondary\\\" subtracted by 1\\n    bytes32 internal constant _IMPLEMENTATION_SECONDARY_SLOT =\\n        0x2b1dbce74324248c222f0ec2d5ed7bd323cfc425b336f0253c5ccfda7265546d;\\n\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback.secondary\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SECONDARY_SLOT =\\n        0x49bd798cd84788856140a4cd5030756b4d08a9e4d55db725ec195f232d262a89;\\n\\n    /**\\n     * @dev Emitted when the secondary implementation is upgraded.\\n     */\\n    event UpgradedSecondary(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current secondary implementation address.\\n     */\\n    function _getSecondaryImplementation() internal view returns (address) {\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setSecondaryImplementation(address newImplementation) private {\\n        require(\\n            Address.isContract(newImplementation),\\n            \\\"ERC1967: new secondary implementation is not a contract\\\"\\n        );\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SECONDARY_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryTo(address newImplementation) internal {\\n        _setSecondaryImplementation(newImplementation);\\n        emit UpgradedSecondary(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade with additional setup call.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeSecondaryTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            Address.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform secondary implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function _upgradeSecondaryToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SECONDARY_SLOT).value) {\\n            _setSecondaryImplementation(newImplementation);\\n        } else {\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(\\n                    slot == _IMPLEMENTATION_SECONDARY_SLOT,\\n                    \\\"ERC1967Upgrade: unsupported proxiableUUID\\\"\\n                );\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new secondary implementation is not UUPS\\\");\\n            }\\n            _upgradeSecondaryToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n}\\n\\n/// @notice similar to TransparentUpgradeableProxy but allows the admin to fallback to a separate logic contract using DoubleLogicERC1967Upgrade\\n/// @dev this follows the UUPS pattern for upgradeability - read more at https://github.com/OpenZeppelin/openzeppelin-contracts/tree/v4.5.0/contracts/proxy#transparent-vs-uups-proxies\\ncontract AdminFallbackProxy is Proxy, DoubleLogicERC1967Upgrade {\\n    /**\\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `adminLogic` and a secondary\\n     * logic implementation specified by `userLogic`\\n     *\\n     * Only the `adminAddr` is able to use the `adminLogic` functions\\n     * All other addresses can interact with the `userLogic` functions\\n     */\\n    constructor(\\n        address adminLogic,\\n        bytes memory adminData,\\n        address userLogic,\\n        bytes memory userData,\\n        address adminAddr\\n    ) payable {\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\n        assert(\\n            _IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1)\\n        );\\n        assert(\\n            _IMPLEMENTATION_SECONDARY_SLOT ==\\n                bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation.secondary\\\")) - 1)\\n        );\\n        _changeAdmin(adminAddr);\\n        _upgradeToAndCall(adminLogic, adminData, false);\\n        _upgradeSecondaryToAndCall(userLogic, userData, false);\\n    }\\n\\n    /// @inheritdoc Proxy\\n    function _implementation() internal view override returns (address) {\\n        require(msg.data.length >= 4, \\\"NO_FUNC_SIG\\\");\\n        // if the sender is the proxy's admin, delegate to admin logic\\n        // if the admin is disabled, all calls will be forwarded to user logic\\n        // admin affordances can be disabled by setting to address(1) since\\n        // `ERC1697._setAdmin()` doesn't allow address(0) to be set\\n        address target = _getAdmin() != msg.sender\\n            ? DoubleLogicERC1967Upgrade._getSecondaryImplementation()\\n            : ERC1967Upgrade._getImplementation();\\n        // implementation setters do an existence check, but we protect against selfdestructs this way\\n        require(Address.isContract(target), \\\"TARGET_NOT_CONTRACT\\\");\\n        return target;\\n    }\\n\\n    /**\\n     * @dev unlike transparent upgradeable proxies, this does allow the admin to fallback to a logic contract\\n     * the admin is expected to interact only with the secondary logic contract, which handles contract\\n     * upgrades using the UUPS approach\\n     */\\n    function _beforeFallback() internal override {\\n        super._beforeFallback();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupUserLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nimport {IRollupUser} from \\\"./IRollupLogic.sol\\\";\\nimport \\\"../libraries/UUPSNotUpgradeable.sol\\\";\\nimport \\\"./RollupCore.sol\\\";\\n\\nabstract contract AbsRollupUserLogic is\\n    RollupCore,\\n    UUPSNotUpgradeable,\\n    IRollupUserAbs,\\n    IChallengeResultReceiver\\n{\\n    using NodeLib for Node;\\n    using GlobalStateLib for GlobalState;\\n\\n    modifier onlyValidator() {\\n        require(isValidator[msg.sender], \\\"NOT_VALIDATOR\\\");\\n        _;\\n    }\\n\\n    function isERC20Enabled() public view override returns (bool) {\\n        return stakeToken != address(0);\\n    }\\n\\n    /**\\n     * @notice Reject the next unresolved node\\n     * @param stakerAddress Example staker staked on sibling, used to prove a node is on an unconfirmable branch and can be rejected\\n     */\\n    function rejectNextNode(address stakerAddress) external onlyValidator whenNotPaused {\\n        requireUnresolvedExists();\\n        uint64 latestConfirmedNodeNum = latestConfirmed();\\n        uint64 firstUnresolvedNodeNum = firstUnresolvedNode();\\n        Node storage firstUnresolvedNode_ = getNodeStorage(firstUnresolvedNodeNum);\\n\\n        if (firstUnresolvedNode_.prevNum == latestConfirmedNodeNum) {\\n            /**If the first unresolved node is a child of the latest confirmed node, to prove it can be rejected, we show:\\n             * a) Its deadline has expired\\n             * b) *Some* staker is staked on a sibling\\n\\n             * The following three checks are sufficient to prove b:\\n            */\\n\\n            // 1.  StakerAddress is indeed a staker\\n            require(isStakedOnLatestConfirmed(stakerAddress), \\\"NOT_STAKED\\\");\\n\\n            // 2. Staker's latest staked node hasn't been resolved; this proves that staker's latest staked node can't be a parent of firstUnresolvedNode\\n            requireUnresolved(latestStakedNode(stakerAddress));\\n\\n            // 3. staker isn't staked on first unresolved node; this proves staker's latest staked can't be a child of firstUnresolvedNode (recall staking on node requires staking on all of its parents)\\n            require(!nodeHasStaker(firstUnresolvedNodeNum, stakerAddress), \\\"STAKED_ON_TARGET\\\");\\n            // If a staker is staked on a node that is neither a child nor a parent of firstUnresolvedNode, it must be a sibling, QED\\n\\n            // Verify the block's deadline has passed\\n            firstUnresolvedNode_.requirePastDeadline();\\n\\n            getNodeStorage(latestConfirmedNodeNum).requirePastChildConfirmDeadline();\\n\\n            removeOldZombies(0);\\n\\n            // Verify that no staker is staked on this node\\n            require(\\n                firstUnresolvedNode_.stakerCount == countStakedZombies(firstUnresolvedNodeNum),\\n                \\\"HAS_STAKERS\\\"\\n            );\\n        }\\n        // Simpler case: if the first unreseolved node doesn't point to the last confirmed node, another branch was confirmed and can simply reject it outright\\n        _rejectNextNode();\\n\\n        emit NodeRejected(firstUnresolvedNodeNum);\\n    }\\n\\n    /**\\n     * @notice Confirm the next unresolved node\\n     * @param blockHash The block hash at the end of the assertion\\n     * @param sendRoot The send root at the end of the assertion\\n     */\\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        requireUnresolvedExists();\\n\\n        uint64 nodeNum = firstUnresolvedNode();\\n        Node storage node = getNodeStorage(nodeNum);\\n\\n        // Verify the block's deadline has passed\\n        node.requirePastDeadline();\\n\\n        // Check that prev is latest confirmed\\n        assert(node.prevNum == latestConfirmed());\\n\\n        Node storage prevNode = getNodeStorage(node.prevNum);\\n        prevNode.requirePastChildConfirmDeadline();\\n\\n        removeOldZombies(0);\\n\\n        // Require only zombies are staked on siblings to this node, and there's at least one non-zombie staked on this node\\n        uint256 stakedZombies = countStakedZombies(nodeNum);\\n        uint256 zombiesStakedOnOtherChildren = countZombiesStakedOnChildren(node.prevNum) -\\n            stakedZombies;\\n        require(node.stakerCount > stakedZombies, \\\"NO_STAKERS\\\");\\n        require(\\n            prevNode.childStakerCount == node.stakerCount + zombiesStakedOnOtherChildren,\\n            \\\"NOT_ALL_STAKED\\\"\\n        );\\n\\n        confirmNode(nodeNum, blockHash, sendRoot);\\n    }\\n\\n    /**\\n     * @notice Create a new stake\\n     * @param depositAmount The amount of either eth or tokens staked\\n     */\\n    function _newStake(uint256 depositAmount) internal onlyValidator whenNotPaused {\\n        // Verify that sender is not already a staker\\n        require(!isStaked(msg.sender), \\\"ALREADY_STAKED\\\");\\n        require(!isZombie(msg.sender), \\\"STAKER_IS_ZOMBIE\\\");\\n        require(depositAmount >= currentRequiredStake(), \\\"NOT_ENOUGH_STAKE\\\");\\n\\n        createNewStake(msg.sender, depositAmount);\\n    }\\n\\n    /**\\n     * @notice Move stake onto existing child node\\n     * @param nodeNum Index of the node to move stake to. This must by a child of the node the staker is currently staked on\\n     * @param nodeHash Node hash of nodeNum (protects against reorgs)\\n     */\\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash)\\n        public\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        require(isStakedOnLatestConfirmed(msg.sender), \\\"NOT_STAKED\\\");\\n\\n        require(\\n            nodeNum >= firstUnresolvedNode() && nodeNum <= latestNodeCreated(),\\n            \\\"NODE_NUM_OUT_OF_RANGE\\\"\\n        );\\n        Node storage node = getNodeStorage(nodeNum);\\n        require(node.nodeHash == nodeHash, \\\"NODE_REORG\\\");\\n        require(latestStakedNode(msg.sender) == node.prevNum, \\\"NOT_STAKED_PREV\\\");\\n        stakeOnNode(msg.sender, nodeNum);\\n    }\\n\\n    /**\\n     * @notice Create a new node and move stake onto it\\n     * @param assertion The assertion data\\n     * @param expectedNodeHash The hash of the node being created (protects against reorgs)\\n     */\\n    function stakeOnNewNode(\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) public onlyValidator whenNotPaused {\\n        require(isStakedOnLatestConfirmed(msg.sender), \\\"NOT_STAKED\\\");\\n        // Ensure staker is staked on the previous node\\n        uint64 prevNode = latestStakedNode(msg.sender);\\n\\n        {\\n            uint256 timeSinceLastNode = block.number - getNode(prevNode).createdAtBlock;\\n            // Verify that assertion meets the minimum Delta time requirement\\n            require(timeSinceLastNode >= minimumAssertionPeriod, \\\"TIME_DELTA\\\");\\n\\n            // Minimum size requirement: any assertion must consume at least all inbox messages\\n            // put into L1 inbox before the prev node\u2019s L1 blocknum.\\n            // We make an exception if the machine enters the errored state,\\n            // as it can't consume future batches.\\n            require(\\n                assertion.afterState.machineStatus == MachineStatus.ERRORED ||\\n                    assertion.afterState.globalState.getInboxPosition() >= prevNodeInboxMaxCount,\\n                \\\"TOO_SMALL\\\"\\n            );\\n            // Minimum size requirement: any assertion must contain at least one block\\n            require(assertion.numBlocks > 0, \\\"EMPTY_ASSERTION\\\");\\n\\n            // The rollup cannot advance normally from an errored state\\n            require(\\n                assertion.beforeState.machineStatus == MachineStatus.FINISHED,\\n                \\\"BAD_PREV_STATUS\\\"\\n            );\\n        }\\n        createNewNode(assertion, prevNode, prevNodeInboxMaxCount, expectedNodeHash);\\n\\n        stakeOnNode(msg.sender, latestNodeCreated());\\n    }\\n\\n    /**\\n     * @notice Refund a staker that is currently staked on or before the latest confirmed node\\n     * @dev Since a staker is initially placed in the latest confirmed node, if they don't move it\\n     * a griefer can remove their stake. It is recomended to batch together the txs to place a stake\\n     * and move it to the desired node.\\n     * @param stakerAddress Address of the staker whose stake is refunded\\n     */\\n    function returnOldDeposit(address stakerAddress) external override onlyValidator whenNotPaused {\\n        require(latestStakedNode(stakerAddress) <= latestConfirmed(), \\\"TOO_RECENT\\\");\\n        requireUnchallengedStaker(stakerAddress);\\n        withdrawStaker(stakerAddress);\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     * @param depositAmount The amount of either eth or tokens deposited\\n     */\\n    function _addToDeposit(address stakerAddress, uint256 depositAmount)\\n        internal\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        requireUnchallengedStaker(stakerAddress);\\n        increaseStakeBy(stakerAddress, depositAmount);\\n    }\\n\\n    /**\\n     * @notice Reduce the amount staked for the sender (difference between initial amount staked and target is creditted back to the sender).\\n     * @param target Target amount of stake for the staker. If this is below the current minimum, it will be set to minimum instead\\n     */\\n    function reduceDeposit(uint256 target) external onlyValidator whenNotPaused {\\n        requireUnchallengedStaker(msg.sender);\\n        uint256 currentRequired = currentRequiredStake();\\n        if (target < currentRequired) {\\n            target = currentRequired;\\n        }\\n        reduceStakeTo(msg.sender, target);\\n    }\\n\\n    /**\\n     * @notice Start a challenge between the given stakers over the node created by the first staker assuming that the two are staked on conflicting nodes. N.B.: challenge creator does not necessarily need to be one of the two asserters.\\n     * @param stakers Stakers engaged in the challenge. The first staker should be staked on the first node\\n     * @param nodeNums Nodes of the stakers engaged in the challenge. The first node should be the earliest and is the one challenged\\n     * @param machineStatuses The before and after machine status for the first assertion\\n     * @param globalStates The before and after global state for the first assertion\\n     * @param numBlocks The number of L2 blocks contained in the first assertion\\n     * @param secondExecutionHash The execution hash of the second assertion\\n     * @param proposedTimes Times that the two nodes were proposed\\n     * @param wasmModuleRoots The wasm module roots at the time of the creation of each assertion\\n     */\\n    function createChallenge(\\n        address[2] calldata stakers,\\n        uint64[2] calldata nodeNums,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32 secondExecutionHash,\\n        uint256[2] calldata proposedTimes,\\n        bytes32[2] calldata wasmModuleRoots\\n    ) external onlyValidator whenNotPaused {\\n        require(nodeNums[0] < nodeNums[1], \\\"WRONG_ORDER\\\");\\n        require(nodeNums[1] <= latestNodeCreated(), \\\"NOT_PROPOSED\\\");\\n        require(latestConfirmed() < nodeNums[0], \\\"ALREADY_CONFIRMED\\\");\\n\\n        Node storage node1 = getNodeStorage(nodeNums[0]);\\n        Node storage node2 = getNodeStorage(nodeNums[1]);\\n\\n        // ensure nodes staked on the same parent (and thus in conflict)\\n        require(node1.prevNum == node2.prevNum, \\\"DIFF_PREV\\\");\\n\\n        // ensure both stakers aren't currently in challenge\\n        requireUnchallengedStaker(stakers[0]);\\n        requireUnchallengedStaker(stakers[1]);\\n\\n        require(nodeHasStaker(nodeNums[0], stakers[0]), \\\"STAKER1_NOT_STAKED\\\");\\n        require(nodeHasStaker(nodeNums[1], stakers[1]), \\\"STAKER2_NOT_STAKED\\\");\\n\\n        // Check param data against challenge hash\\n        require(\\n            node1.challengeHash ==\\n                RollupLib.challengeRootHash(\\n                    RollupLib.executionHash(machineStatuses, globalStates, numBlocks),\\n                    proposedTimes[0],\\n                    wasmModuleRoots[0]\\n                ),\\n            \\\"CHAL_HASH1\\\"\\n        );\\n\\n        require(\\n            node2.challengeHash ==\\n                RollupLib.challengeRootHash(\\n                    secondExecutionHash,\\n                    proposedTimes[1],\\n                    wasmModuleRoots[1]\\n                ),\\n            \\\"CHAL_HASH2\\\"\\n        );\\n\\n        // Calculate upper limit for allowed node proposal time:\\n        uint256 commonEndTime = getNodeStorage(node1.prevNum).firstChildBlock +\\n            // Dispute start: dispute timer for a node starts when its first child is created\\n            (node1.deadlineBlock - proposedTimes[0]) +\\n            extraChallengeTimeBlocks; // add dispute window to dispute start time\\n        if (commonEndTime < proposedTimes[1]) {\\n            // The 2nd node was created too late; loses challenge automatically.\\n            completeChallengeImpl(stakers[0], stakers[1]);\\n            return;\\n        }\\n        // Start a challenge between staker1 and staker2. Staker1 will defend the correctness of node1, and staker2 will challenge it.\\n        uint64 challengeIndex = createChallengeHelper(\\n            stakers,\\n            machineStatuses,\\n            globalStates,\\n            numBlocks,\\n            wasmModuleRoots,\\n            commonEndTime - proposedTimes[0],\\n            commonEndTime - proposedTimes[1]\\n        ); // trusted external call\\n\\n        challengeStarted(stakers[0], stakers[1], challengeIndex);\\n\\n        emit RollupChallengeStarted(challengeIndex, stakers[0], stakers[1], nodeNums[0]);\\n    }\\n\\n    function createChallengeHelper(\\n        address[2] calldata stakers,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32[2] calldata wasmModuleRoots,\\n        uint256 asserterTimeLeft,\\n        uint256 challengerTimeLeft\\n    ) internal returns (uint64) {\\n        return\\n            challengeManager.createChallenge(\\n                wasmModuleRoots[0],\\n                machineStatuses,\\n                globalStates,\\n                numBlocks,\\n                stakers[0],\\n                stakers[1],\\n                asserterTimeLeft,\\n                challengerTimeLeft\\n            );\\n    }\\n\\n    /**\\n     * @notice Inform the rollup that the challenge between the given stakers is completed\\n     * @param winningStaker Address of the winning staker\\n     * @param losingStaker Address of the losing staker\\n     */\\n    function completeChallenge(\\n        uint256 challengeIndex,\\n        address winningStaker,\\n        address losingStaker\\n    ) external override whenNotPaused {\\n        // Only the challenge manager contract can call this to declare the winner and loser\\n        require(msg.sender == address(challengeManager), \\\"WRONG_SENDER\\\");\\n        require(challengeIndex == inChallenge(winningStaker, losingStaker), \\\"NOT_IN_CHAL\\\");\\n        completeChallengeImpl(winningStaker, losingStaker);\\n    }\\n\\n    function completeChallengeImpl(address winningStaker, address losingStaker) private {\\n        uint256 remainingLoserStake = amountStaked(losingStaker);\\n        uint256 winnerStake = amountStaked(winningStaker);\\n        if (remainingLoserStake > winnerStake) {\\n            // If loser has a higher stake than the winner, refund the difference\\n            remainingLoserStake -= reduceStakeTo(losingStaker, winnerStake);\\n        }\\n\\n        // Reward the winner with half the remaining stake\\n        uint256 amountWon = remainingLoserStake / 2;\\n        increaseStakeBy(winningStaker, amountWon);\\n        remainingLoserStake -= amountWon;\\n        clearChallenge(winningStaker);\\n        // Credit the other half to the loserStakeEscrow address\\n        increaseWithdrawableFunds(loserStakeEscrow, remainingLoserStake);\\n        // Turning loser into zombie renders the loser's remaining stake inaccessible\\n        turnIntoZombie(losingStaker);\\n    }\\n\\n    /**\\n     * @notice Remove the given zombie from nodes it is staked on, moving backwords from the latest node it is staked on\\n     * @param zombieNum Index of the zombie to remove\\n     * @param maxNodes Maximum number of nodes to remove the zombie from (to limit the cost of this transaction)\\n     */\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        require(zombieNum < zombieCount(), \\\"NO_SUCH_ZOMBIE\\\");\\n        address zombieStakerAddress = zombieAddress(zombieNum);\\n        uint64 latestNodeStaked = zombieLatestStakedNode(zombieNum);\\n        uint256 nodesRemoved = 0;\\n        uint256 latestConfirmedNum = latestConfirmed();\\n        while (latestNodeStaked >= latestConfirmedNum && nodesRemoved < maxNodes) {\\n            Node storage node = getNodeStorage(latestNodeStaked);\\n            removeStaker(latestNodeStaked, zombieStakerAddress);\\n            latestNodeStaked = node.prevNum;\\n            nodesRemoved++;\\n        }\\n        if (latestNodeStaked < latestConfirmedNum) {\\n            removeZombie(zombieNum);\\n        } else {\\n            zombieUpdateLatestStakedNode(zombieNum, latestNodeStaked);\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove any zombies whose latest stake is earlier than the latest confirmed node\\n     * @param startIndex Index in the zombie list to start removing zombies from (to limit the cost of this transaction)\\n     */\\n    function removeOldZombies(uint256 startIndex) public onlyValidator whenNotPaused {\\n        uint256 currentZombieCount = zombieCount();\\n        uint256 latestConfirmedNum = latestConfirmed();\\n        for (uint256 i = startIndex; i < currentZombieCount; i++) {\\n            while (zombieLatestStakedNode(i) < latestConfirmedNum) {\\n                removeZombie(i);\\n                currentZombieCount--;\\n                if (i >= currentZombieCount) {\\n                    return;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\\n     * that only blocks operations that should be blocked anyway\\n     * @return The current minimum stake requirement\\n     */\\n    function currentRequiredStake(\\n        uint256 _blockNumber,\\n        uint64 _firstUnresolvedNodeNum,\\n        uint256 _latestCreatedNode\\n    ) internal view returns (uint256) {\\n        // If there are no unresolved nodes, then you can use the base stake\\n        if (_firstUnresolvedNodeNum - 1 == _latestCreatedNode) {\\n            return baseStake;\\n        }\\n        uint256 firstUnresolvedDeadline = getNodeStorage(_firstUnresolvedNodeNum).deadlineBlock;\\n        if (_blockNumber < firstUnresolvedDeadline) {\\n            return baseStake;\\n        }\\n        uint24[10] memory numerators = [\\n            1,\\n            122971,\\n            128977,\\n            80017,\\n            207329,\\n            114243,\\n            314252,\\n            129988,\\n            224562,\\n            162163\\n        ];\\n        uint24[10] memory denominators = [\\n            1,\\n            114736,\\n            112281,\\n            64994,\\n            157126,\\n            80782,\\n            207329,\\n            80017,\\n            128977,\\n            86901\\n        ];\\n        uint256 firstUnresolvedAge = _blockNumber - firstUnresolvedDeadline;\\n        uint256 periodsPassed = (firstUnresolvedAge * 10) / confirmPeriodBlocks;\\n        uint256 baseMultiplier = 2**(periodsPassed / 10);\\n        uint256 withNumerator = baseMultiplier * numerators[periodsPassed % 10];\\n        uint256 multiplier = withNumerator / denominators[periodsPassed % 10];\\n        if (multiplier == 0) {\\n            multiplier = 1;\\n        }\\n        return baseStake * multiplier;\\n    }\\n\\n    /**\\n     * @notice Calculate the current amount of funds required to place a new stake in the rollup\\n     * @dev If the stake requirement get's too high, this function may start reverting due to overflow, but\\n     * that only blocks operations that should be blocked anyway\\n     * @return The current minimum stake requirement\\n     */\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint64 firstUnresolvedNodeNum,\\n        uint64 latestCreatedNode\\n    ) external view returns (uint256) {\\n        return currentRequiredStake(blockNumber, firstUnresolvedNodeNum, latestCreatedNode);\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _getAdmin();\\n    }\\n\\n    function currentRequiredStake() public view returns (uint256) {\\n        uint64 firstUnresolvedNodeNum = firstUnresolvedNode();\\n\\n        return currentRequiredStake(block.number, firstUnresolvedNodeNum, latestNodeCreated());\\n    }\\n\\n    /**\\n     * @notice Calculate the number of zombies staked on the given node\\n     *\\n     * @dev This function could be uncallable if there are too many zombies. However,\\n     * removeZombie and removeOldZombies can be used to remove any zombies that exist\\n     * so that this will then be callable\\n     *\\n     * @param nodeNum The node on which to count staked zombies\\n     * @return The number of zombies staked on the node\\n     */\\n    function countStakedZombies(uint64 nodeNum) public view override returns (uint256) {\\n        uint256 currentZombieCount = zombieCount();\\n        uint256 stakedZombieCount = 0;\\n        for (uint256 i = 0; i < currentZombieCount; i++) {\\n            if (nodeHasStaker(nodeNum, zombieAddress(i))) {\\n                stakedZombieCount++;\\n            }\\n        }\\n        return stakedZombieCount;\\n    }\\n\\n    /**\\n     * @notice Calculate the number of zombies staked on a child of the given node\\n     *\\n     * @dev This function could be uncallable if there are too many zombies. However,\\n     * removeZombie and removeOldZombies can be used to remove any zombies that exist\\n     * so that this will then be callable\\n     *\\n     * @param nodeNum The parent node on which to count zombies staked on children\\n     * @return The number of zombies staked on children of the node\\n     */\\n    function countZombiesStakedOnChildren(uint64 nodeNum) public view override returns (uint256) {\\n        uint256 currentZombieCount = zombieCount();\\n        uint256 stakedZombieCount = 0;\\n        for (uint256 i = 0; i < currentZombieCount; i++) {\\n            Zombie storage zombie = getZombieStorage(i);\\n            // If this zombie is staked on this node, but its _latest_ staked node isn't this node,\\n            // then it must be staked on a child of this node.\\n            if (\\n                zombie.latestStakedNode != nodeNum && nodeHasStaker(nodeNum, zombie.stakerAddress)\\n            ) {\\n                stakedZombieCount++;\\n            }\\n        }\\n        return stakedZombieCount;\\n    }\\n\\n    /**\\n     * @notice Verify that there are some number of nodes still unresolved\\n     */\\n    function requireUnresolvedExists() public view override {\\n        uint256 firstUnresolved = firstUnresolvedNode();\\n        require(\\n            firstUnresolved > latestConfirmed() && firstUnresolved <= latestNodeCreated(),\\n            \\\"NO_UNRESOLVED\\\"\\n        );\\n    }\\n\\n    function requireUnresolved(uint256 nodeNum) public view override {\\n        require(nodeNum >= firstUnresolvedNode(), \\\"ALREADY_DECIDED\\\");\\n        require(nodeNum <= latestNodeCreated(), \\\"DOESNT_EXIST\\\");\\n    }\\n\\n    /**\\n     * @notice Verify that the given address is staked and not actively in a challenge\\n     * @param stakerAddress Address to check\\n     */\\n    function requireUnchallengedStaker(address stakerAddress) private view {\\n        require(isStaked(stakerAddress), \\\"NOT_STAKED\\\");\\n        require(currentChallenge(stakerAddress) == NO_CHAL_INDEX, \\\"IN_CHAL\\\");\\n    }\\n}\\n\\ncontract RollupUserLogic is AbsRollupUserLogic, IRollupUser {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address _stakeToken) external view override onlyProxy {\\n        require(_stakeToken == address(0), \\\"NO_TOKEN_ALLOWED\\\");\\n        require(!isERC20Enabled(), \\\"FACET_NOT_ERC20\\\");\\n    }\\n\\n    /**\\n     * @notice Create a new stake on an existing node\\n     * @param nodeNum Number of the node your stake will be place one\\n     * @param nodeHash Node hash of the node with the given nodeNum\\n     */\\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable override {\\n        _newStake(msg.value);\\n        stakeOnExistingNode(nodeNum, nodeHash);\\n    }\\n\\n    /**\\n     * @notice Create a new stake on a new node\\n     * @param assertion Assertion describing the state change between the old node and the new one\\n     * @param expectedNodeHash Node hash of the node that will be created\\n     * @param prevNodeInboxMaxCount Total of messages in the inbox as of the previous node\\n     */\\n    function newStakeOnNewNode(\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external payable override {\\n        _newStake(msg.value);\\n        stakeOnNewNode(assertion, expectedNodeHash, prevNodeInboxMaxCount);\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked eth for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     */\\n    function addToDeposit(address stakerAddress)\\n        external\\n        payable\\n        override\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        _addToDeposit(stakerAddress, msg.value);\\n    }\\n\\n    /**\\n     * @notice Withdraw uncommitted funds owned by sender from the rollup chain\\n     */\\n    function withdrawStakerFunds() external override onlyValidator whenNotPaused returns (uint256) {\\n        uint256 amount = withdrawFunds(msg.sender);\\n        // This is safe because it occurs after all checks and effects\\n        (bool success, ) = msg.sender.call{value: amount}(\\\"\\\");\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n        return amount;\\n    }\\n}\\n\\ncontract ERC20RollupUserLogic is AbsRollupUserLogic, IRollupUserERC20 {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address _stakeToken) external view override onlyProxy {\\n        require(_stakeToken != address(0), \\\"NEED_STAKE_TOKEN\\\");\\n        require(isERC20Enabled(), \\\"FACET_NOT_ERC20\\\");\\n    }\\n\\n    /**\\n     * @notice Create a new stake on an existing node\\n     * @param tokenAmount Amount of the rollups staking token to stake\\n     * @param nodeNum Number of the node your stake will be place one\\n     * @param nodeHash Node hash of the node with the given nodeNum\\n     */\\n    function newStakeOnExistingNode(\\n        uint256 tokenAmount,\\n        uint64 nodeNum,\\n        bytes32 nodeHash\\n    ) external override {\\n        _newStake(tokenAmount);\\n        stakeOnExistingNode(nodeNum, nodeHash);\\n        /// @dev This is an external call, safe because it's at the end of the function\\n        receiveTokens(tokenAmount);\\n    }\\n\\n    /**\\n     * @notice Create a new stake on a new node\\n     * @param tokenAmount Amount of the rollups staking token to stake\\n     * @param assertion Assertion describing the state change between the old node and the new one\\n     * @param expectedNodeHash Node hash of the node that will be created\\n     * @param prevNodeInboxMaxCount Total of messages in the inbox as of the previous node\\n     */\\n    function newStakeOnNewNode(\\n        uint256 tokenAmount,\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external override {\\n        _newStake(tokenAmount);\\n        stakeOnNewNode(assertion, expectedNodeHash, prevNodeInboxMaxCount);\\n        /// @dev This is an external call, safe because it's at the end of the function\\n        receiveTokens(tokenAmount);\\n    }\\n\\n    /**\\n     * @notice Increase the amount staked tokens for the given staker\\n     * @param stakerAddress Address of the staker whose stake is increased\\n     * @param tokenAmount the amount of tokens staked\\n     */\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount)\\n        external\\n        onlyValidator\\n        whenNotPaused\\n    {\\n        _addToDeposit(stakerAddress, tokenAmount);\\n        /// @dev This is an external call, safe because it's at the end of the function\\n        receiveTokens(tokenAmount);\\n    }\\n\\n    /**\\n     * @notice Withdraw uncommitted funds owned by sender from the rollup chain\\n     */\\n    function withdrawStakerFunds() external override onlyValidator whenNotPaused returns (uint256) {\\n        uint256 amount = withdrawFunds(msg.sender);\\n        // This is safe because it occurs after all checks and effects\\n        require(IERC20Upgradeable(stakeToken).transfer(msg.sender, amount), \\\"TRANSFER_FAILED\\\");\\n        return amount;\\n    }\\n\\n    function receiveTokens(uint256 tokenAmount) private {\\n        require(\\n            IERC20Upgradeable(stakeToken).transferFrom(msg.sender, address(this), tokenAmount),\\n            \\\"TRANSFER_FAIL\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"src/libraries/UUPSNotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\\\";\\nimport {DoubleLogicERC1967Upgrade} from \\\"./AdminFallbackProxy.sol\\\";\\n\\n/**\\n * @dev UUPSUpgradeable by OpenZeppelin but not upgradeable. This is expected to be used on the secondary\\n * logic slot behind a DoubleLogicERC1967Upgrade proxy\\n */\\nabstract contract UUPSNotUpgradeable is IERC1822Proxiable, DoubleLogicERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(\\n            _getSecondaryImplementation() == __self,\\n            \\\"Function must be called through active proxy\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(\\n            address(this) == __self,\\n            \\\"UUPSNotUpgradeable: must not be called through delegatecall\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SECONDARY_SLOT;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupCore.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport \\\"./Node.sol\\\";\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"./IRollupCore.sol\\\";\\n\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\n\\nimport {NO_CHAL_INDEX} from \\\"../libraries/Constants.sol\\\";\\n\\nabstract contract RollupCore is IRollupCore, PausableUpgradeable {\\n    using NodeLib for Node;\\n    using GlobalStateLib for GlobalState;\\n\\n    // Rollup Config\\n    uint64 public confirmPeriodBlocks;\\n    uint64 public extraChallengeTimeBlocks;\\n    uint256 public chainId;\\n    uint256 public baseStake;\\n    bytes32 public wasmModuleRoot;\\n\\n    IInbox public inbox;\\n    IBridge public bridge;\\n    IOutbox public outbox;\\n    ISequencerInbox public sequencerInbox;\\n    IRollupEventInbox public rollupEventInbox;\\n    IChallengeManager public override challengeManager;\\n\\n    // misc useful contracts when interacting with the rollup\\n    address public validatorUtils;\\n    address public validatorWalletCreator;\\n\\n    // when a staker loses a challenge, half of their funds get escrowed in this address\\n    address public loserStakeEscrow;\\n    address public stakeToken;\\n    uint256 public minimumAssertionPeriod;\\n\\n    mapping(address => bool) public isValidator;\\n\\n    // Stakers become Zombies after losing a challenge\\n    struct Zombie {\\n        address stakerAddress;\\n        uint64 latestStakedNode;\\n    }\\n\\n    uint64 private _latestConfirmed;\\n    uint64 private _firstUnresolvedNode;\\n    uint64 private _latestNodeCreated;\\n    uint64 private _lastStakeBlock;\\n    mapping(uint64 => Node) private _nodes;\\n    mapping(uint64 => mapping(address => bool)) private _nodeStakers;\\n\\n    address[] private _stakerList;\\n    mapping(address => Staker) public _stakerMap;\\n\\n    Zombie[] private _zombies;\\n\\n    mapping(address => uint256) private _withdrawableFunds;\\n    uint256 public totalWithdrawableFunds;\\n    uint256 public rollupDeploymentBlock;\\n\\n    // The node number of the initial node\\n    uint64 internal constant GENESIS_NODE = 0;\\n\\n    /**\\n     * @notice Get a storage reference to the Node for the given node index\\n     * @param nodeNum Index of the node\\n     * @return Node struct\\n     */\\n    function getNodeStorage(uint64 nodeNum) internal view returns (Node storage) {\\n        return _nodes[nodeNum];\\n    }\\n\\n    /**\\n     * @notice Get the Node for the given index.\\n     */\\n    function getNode(uint64 nodeNum) public view override returns (Node memory) {\\n        return getNodeStorage(nodeNum);\\n    }\\n\\n    /**\\n     * @notice Check if the specified node has been staked on by the provided staker.\\n     * Only accurate at the latest confirmed node and afterwards.\\n     */\\n    function nodeHasStaker(uint64 nodeNum, address staker) public view override returns (bool) {\\n        return _nodeStakers[nodeNum][staker];\\n    }\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint64 stakerNum) external view override returns (address) {\\n        return _stakerList[stakerNum];\\n    }\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) public view override returns (bool) {\\n        return _stakerMap[staker].isStaked;\\n    }\\n\\n    /**\\n     * @notice Check whether the given staker is staked on the latest confirmed node,\\n     * which includes if the staker is staked on a descendent of the latest confirmed node.\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStakedOnLatestConfirmed(address staker) public view returns (bool) {\\n        return _stakerMap[staker].isStaked && nodeHasStaker(_latestConfirmed, staker);\\n    }\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) public view override returns (uint64) {\\n        return _stakerMap[staker].latestStakedNode;\\n    }\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) public view override returns (uint64) {\\n        return _stakerMap[staker].currentChallenge;\\n    }\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) public view override returns (uint256) {\\n        return _stakerMap[staker].amountStaked;\\n    }\\n\\n    /**\\n     * @notice Retrieves stored information about a requested staker\\n     * @param staker Staker address to retrieve\\n     * @return A structure with information about the requested staker\\n     */\\n    function getStaker(address staker) external view override returns (Staker memory) {\\n        return _stakerMap[staker];\\n    }\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) public view override returns (address) {\\n        return _zombies[zombieNum].stakerAddress;\\n    }\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) public view override returns (uint64) {\\n        return _zombies[zombieNum].latestStakedNode;\\n    }\\n\\n    /**\\n     * @notice Retrieves stored information about a requested zombie\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return A structure with information about the requested staker\\n     */\\n    function getZombieStorage(uint256 zombieNum) internal view returns (Zombie storage) {\\n        return _zombies[zombieNum];\\n    }\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() public view override returns (uint256) {\\n        return _zombies.length;\\n    }\\n\\n    function isZombie(address staker) public view override returns (bool) {\\n        for (uint256 i = 0; i < _zombies.length; i++) {\\n            if (staker == _zombies[i].stakerAddress) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param user Address to check the funds of\\n     * @return Amount of funds withdrawable by user\\n     */\\n    function withdrawableFunds(address user) external view override returns (uint256) {\\n        return _withdrawableFunds[user];\\n    }\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() public view override returns (uint64) {\\n        return _firstUnresolvedNode;\\n    }\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() public view override returns (uint64) {\\n        return _latestConfirmed;\\n    }\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() public view override returns (uint64) {\\n        return _latestNodeCreated;\\n    }\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view override returns (uint64) {\\n        return _lastStakeBlock;\\n    }\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() public view override returns (uint64) {\\n        return uint64(_stakerList.length);\\n    }\\n\\n    /**\\n     * @notice Initialize the core with an initial node\\n     * @param initialNode Initial node to start the chain with\\n     */\\n    function initializeCore(Node memory initialNode) internal {\\n        __Pausable_init();\\n        _nodes[GENESIS_NODE] = initialNode;\\n        _firstUnresolvedNode = GENESIS_NODE + 1;\\n    }\\n\\n    /**\\n     * @notice React to a new node being created by storing it an incrementing the latest node counter\\n     * @param node Node that was newly created\\n     */\\n    function nodeCreated(Node memory node) internal {\\n        _latestNodeCreated++;\\n        _nodes[_latestNodeCreated] = node;\\n    }\\n\\n    /// @notice Reject the next unresolved node\\n    function _rejectNextNode() internal {\\n        _firstUnresolvedNode++;\\n    }\\n\\n    function confirmNode(\\n        uint64 nodeNum,\\n        bytes32 blockHash,\\n        bytes32 sendRoot\\n    ) internal {\\n        Node storage node = getNodeStorage(nodeNum);\\n        // Authenticate data against node's confirm data pre-image\\n        require(node.confirmData == RollupLib.confirmHash(blockHash, sendRoot), \\\"CONFIRM_DATA\\\");\\n\\n        // trusted external call to outbox\\n        outbox.updateSendRoot(sendRoot, blockHash);\\n\\n        _latestConfirmed = nodeNum;\\n        _firstUnresolvedNode = nodeNum + 1;\\n\\n        emit NodeConfirmed(nodeNum, blockHash, sendRoot);\\n    }\\n\\n    /**\\n     * @notice Create a new stake at latest confirmed node\\n     * @param stakerAddress Address of the new staker\\n     * @param depositAmount Stake amount of the new staker\\n     */\\n    function createNewStake(address stakerAddress, uint256 depositAmount) internal {\\n        uint64 stakerIndex = uint64(_stakerList.length);\\n        _stakerList.push(stakerAddress);\\n        _stakerMap[stakerAddress] = Staker(\\n            depositAmount,\\n            stakerIndex,\\n            _latestConfirmed,\\n            NO_CHAL_INDEX, // new staker is not in challenge\\n            true\\n        );\\n        _nodeStakers[_latestConfirmed][stakerAddress] = true;\\n        _lastStakeBlock = uint64(block.number);\\n        emit UserStakeUpdated(stakerAddress, 0, depositAmount);\\n    }\\n\\n    /**\\n     * @notice Check to see whether the two stakers are in the same challenge\\n     * @param stakerAddress1 Address of the first staker\\n     * @param stakerAddress2 Address of the second staker\\n     * @return Address of the challenge that the two stakers are in\\n     */\\n    function inChallenge(address stakerAddress1, address stakerAddress2)\\n        internal\\n        view\\n        returns (uint64)\\n    {\\n        Staker storage staker1 = _stakerMap[stakerAddress1];\\n        Staker storage staker2 = _stakerMap[stakerAddress2];\\n        uint64 challenge = staker1.currentChallenge;\\n        require(challenge != NO_CHAL_INDEX, \\\"NO_CHAL\\\");\\n        require(challenge == staker2.currentChallenge, \\\"DIFF_IN_CHAL\\\");\\n        return challenge;\\n    }\\n\\n    /**\\n     * @notice Make the given staker as not being in a challenge\\n     * @param stakerAddress Address of the staker to remove from a challenge\\n     */\\n    function clearChallenge(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        staker.currentChallenge = NO_CHAL_INDEX;\\n    }\\n\\n    /**\\n     * @notice Mark both the given stakers as engaged in the challenge\\n     * @param staker1 Address of the first staker\\n     * @param staker2 Address of the second staker\\n     * @param challenge Address of the challenge both stakers are now in\\n     */\\n    function challengeStarted(\\n        address staker1,\\n        address staker2,\\n        uint64 challenge\\n    ) internal {\\n        _stakerMap[staker1].currentChallenge = challenge;\\n        _stakerMap[staker2].currentChallenge = challenge;\\n    }\\n\\n    /**\\n     * @notice Add to the stake of the given staker by the given amount\\n     * @param stakerAddress Address of the staker to increase the stake of\\n     * @param amountAdded Amount of stake to add to the staker\\n     */\\n    function increaseStakeBy(address stakerAddress, uint256 amountAdded) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint256 initialStaked = staker.amountStaked;\\n        uint256 finalStaked = initialStaked + amountAdded;\\n        staker.amountStaked = finalStaked;\\n        emit UserStakeUpdated(stakerAddress, initialStaked, finalStaked);\\n    }\\n\\n    /**\\n     * @notice Reduce the stake of the given staker to the given target\\n     * @param stakerAddress Address of the staker to reduce the stake of\\n     * @param target Amount of stake to leave with the staker\\n     * @return Amount of value released from the stake\\n     */\\n    function reduceStakeTo(address stakerAddress, uint256 target) internal returns (uint256) {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint256 current = staker.amountStaked;\\n        require(target <= current, \\\"TOO_LITTLE_STAKE\\\");\\n        uint256 amountWithdrawn = current - target;\\n        staker.amountStaked = target;\\n        increaseWithdrawableFunds(stakerAddress, amountWithdrawn);\\n        emit UserStakeUpdated(stakerAddress, current, target);\\n        return amountWithdrawn;\\n    }\\n\\n    /**\\n     * @notice Remove the given staker and turn them into a zombie\\n     * @param stakerAddress Address of the staker to remove\\n     */\\n    function turnIntoZombie(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        _zombies.push(Zombie(stakerAddress, staker.latestStakedNode));\\n        deleteStaker(stakerAddress);\\n    }\\n\\n    /**\\n     * @notice Update the latest staked node of the zombie at the given index\\n     * @param zombieNum Index of the zombie to move\\n     * @param latest New latest node the zombie is staked on\\n     */\\n    function zombieUpdateLatestStakedNode(uint256 zombieNum, uint64 latest) internal {\\n        _zombies[zombieNum].latestStakedNode = latest;\\n    }\\n\\n    /**\\n     * @notice Remove the zombie at the given index\\n     * @param zombieNum Index of the zombie to remove\\n     */\\n    function removeZombie(uint256 zombieNum) internal {\\n        _zombies[zombieNum] = _zombies[_zombies.length - 1];\\n        _zombies.pop();\\n    }\\n\\n    /**\\n     * @notice Mark the given staker as staked on this node\\n     * @param staker Address of the staker to mark\\n     */\\n    function addStaker(uint64 nodeNum, address staker) internal {\\n        require(!_nodeStakers[nodeNum][staker], \\\"ALREADY_STAKED\\\");\\n        _nodeStakers[nodeNum][staker] = true;\\n        Node storage node = getNodeStorage(nodeNum);\\n        require(node.deadlineBlock != 0, \\\"NO_NODE\\\");\\n\\n        uint64 prevCount = node.stakerCount;\\n        node.stakerCount = prevCount + 1;\\n\\n        if (nodeNum > GENESIS_NODE) {\\n            Node storage parent = getNodeStorage(node.prevNum);\\n            parent.childStakerCount++;\\n            if (prevCount == 0) {\\n                parent.newChildConfirmDeadline(uint64(block.number) + confirmPeriodBlocks);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove the given staker from this node\\n     * @param staker Address of the staker to remove\\n     */\\n    function removeStaker(uint64 nodeNum, address staker) internal {\\n        require(_nodeStakers[nodeNum][staker], \\\"NOT_STAKED\\\");\\n        _nodeStakers[nodeNum][staker] = false;\\n\\n        Node storage node = getNodeStorage(nodeNum);\\n        node.stakerCount--;\\n\\n        if (nodeNum > GENESIS_NODE) {\\n            getNodeStorage(node.prevNum).childStakerCount--;\\n        }\\n    }\\n\\n    /**\\n     * @notice Remove the given staker and return their stake\\n     * This should not be called if the staker is staked on a descendent of the latest confirmed node\\n     * @param stakerAddress Address of the staker withdrawing their stake\\n     */\\n    function withdrawStaker(address stakerAddress) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint64 latestConfirmedNum = latestConfirmed();\\n        if (nodeHasStaker(latestConfirmedNum, stakerAddress)) {\\n            // Withdrawing a staker whose latest staked node isn't resolved should be impossible\\n            assert(staker.latestStakedNode == latestConfirmedNum);\\n            removeStaker(latestConfirmedNum, stakerAddress);\\n        }\\n        uint256 initialStaked = staker.amountStaked;\\n        increaseWithdrawableFunds(stakerAddress, initialStaked);\\n        deleteStaker(stakerAddress);\\n        emit UserStakeUpdated(stakerAddress, initialStaked, 0);\\n    }\\n\\n    /**\\n     * @notice Advance the given staker to the given node\\n     * @param stakerAddress Address of the staker adding their stake\\n     * @param nodeNum Index of the node to stake on\\n     */\\n    function stakeOnNode(address stakerAddress, uint64 nodeNum) internal {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        addStaker(nodeNum, stakerAddress);\\n        staker.latestStakedNode = nodeNum;\\n    }\\n\\n    /**\\n     * @notice Clear the withdrawable funds for the given address\\n     * @param account Address of the account to remove funds from\\n     * @return Amount of funds removed from account\\n     */\\n    function withdrawFunds(address account) internal returns (uint256) {\\n        uint256 amount = _withdrawableFunds[account];\\n        _withdrawableFunds[account] = 0;\\n        totalWithdrawableFunds -= amount;\\n        emit UserWithdrawableFundsUpdated(account, amount, 0);\\n        return amount;\\n    }\\n\\n    /**\\n     * @notice Increase the withdrawable funds for the given address\\n     * @param account Address of the account to add withdrawable funds to\\n     */\\n    function increaseWithdrawableFunds(address account, uint256 amount) internal {\\n        uint256 initialWithdrawable = _withdrawableFunds[account];\\n        uint256 finalWithdrawable = initialWithdrawable + amount;\\n        _withdrawableFunds[account] = finalWithdrawable;\\n        totalWithdrawableFunds += amount;\\n        emit UserWithdrawableFundsUpdated(account, initialWithdrawable, finalWithdrawable);\\n    }\\n\\n    /**\\n     * @notice Remove the given staker\\n     * @param stakerAddress Address of the staker to remove\\n     */\\n    function deleteStaker(address stakerAddress) private {\\n        Staker storage staker = _stakerMap[stakerAddress];\\n        uint64 stakerIndex = staker.index;\\n        _stakerList[stakerIndex] = _stakerList[_stakerList.length - 1];\\n        _stakerMap[_stakerList[stakerIndex]].index = stakerIndex;\\n        _stakerList.pop();\\n        delete _stakerMap[stakerAddress];\\n    }\\n\\n    struct StakeOnNewNodeFrame {\\n        uint256 currentInboxSize;\\n        Node node;\\n        bytes32 executionHash;\\n        Node prevNode;\\n        bytes32 lastHash;\\n        bool hasSibling;\\n        uint64 deadlineBlock;\\n        bytes32 sequencerBatchAcc;\\n    }\\n\\n    function createNewNode(\\n        RollupLib.Assertion calldata assertion,\\n        uint64 prevNodeNum,\\n        uint256 prevNodeInboxMaxCount,\\n        bytes32 expectedNodeHash\\n    ) internal returns (bytes32 newNodeHash) {\\n        require(\\n            assertion.afterState.machineStatus == MachineStatus.FINISHED ||\\n                assertion.afterState.machineStatus == MachineStatus.ERRORED,\\n            \\\"BAD_AFTER_STATUS\\\"\\n        );\\n\\n        StakeOnNewNodeFrame memory memoryFrame;\\n        {\\n            // validate data\\n            memoryFrame.prevNode = getNode(prevNodeNum);\\n            memoryFrame.currentInboxSize = bridge.sequencerMessageCount();\\n\\n            // Make sure the previous state is correct against the node being built on\\n            require(\\n                RollupLib.stateHash(assertion.beforeState, prevNodeInboxMaxCount) ==\\n                    memoryFrame.prevNode.stateHash,\\n                \\\"PREV_STATE_HASH\\\"\\n            );\\n\\n            // Ensure that the assertion doesn't read past the end of the current inbox\\n            uint64 afterInboxCount = assertion.afterState.globalState.getInboxPosition();\\n            uint64 prevInboxPosition = assertion.beforeState.globalState.getInboxPosition();\\n            require(afterInboxCount >= prevInboxPosition, \\\"INBOX_BACKWARDS\\\");\\n            if (afterInboxCount == prevInboxPosition) {\\n                require(\\n                    assertion.afterState.globalState.getPositionInMessage() >=\\n                        assertion.afterState.globalState.getPositionInMessage(),\\n                    \\\"INBOX_POS_IN_MSG_BACKWARDS\\\"\\n                );\\n            }\\n            // See validator/assertion.go ExecutionState RequiredBatches() for reasoning\\n            if (\\n                assertion.afterState.machineStatus == MachineStatus.ERRORED ||\\n                assertion.afterState.globalState.getPositionInMessage() > 0\\n            ) {\\n                // The current inbox message was read\\n                afterInboxCount++;\\n            }\\n            require(afterInboxCount <= memoryFrame.currentInboxSize, \\\"INBOX_PAST_END\\\");\\n            // This gives replay protection against the state of the inbox\\n            if (afterInboxCount > 0) {\\n                memoryFrame.sequencerBatchAcc = bridge.sequencerInboxAccs(afterInboxCount - 1);\\n            }\\n        }\\n\\n        {\\n            memoryFrame.executionHash = RollupLib.executionHash(assertion);\\n\\n            memoryFrame.deadlineBlock = uint64(block.number) + confirmPeriodBlocks;\\n\\n            memoryFrame.hasSibling = memoryFrame.prevNode.latestChildNumber > 0;\\n            // here we don't use ternacy operator to remain compatible with slither\\n            if (memoryFrame.hasSibling) {\\n                memoryFrame.lastHash = getNodeStorage(memoryFrame.prevNode.latestChildNumber)\\n                    .nodeHash;\\n            } else {\\n                memoryFrame.lastHash = memoryFrame.prevNode.nodeHash;\\n            }\\n\\n            newNodeHash = RollupLib.nodeHash(\\n                memoryFrame.hasSibling,\\n                memoryFrame.lastHash,\\n                memoryFrame.executionHash,\\n                memoryFrame.sequencerBatchAcc,\\n                wasmModuleRoot\\n            );\\n            require(newNodeHash == expectedNodeHash, \\\"UNEXPECTED_NODE_HASH\\\");\\n\\n            memoryFrame.node = NodeLib.createNode(\\n                RollupLib.stateHash(assertion.afterState, memoryFrame.currentInboxSize),\\n                RollupLib.challengeRootHash(\\n                    memoryFrame.executionHash,\\n                    block.number,\\n                    wasmModuleRoot\\n                ),\\n                RollupLib.confirmHash(assertion),\\n                prevNodeNum,\\n                memoryFrame.deadlineBlock,\\n                newNodeHash\\n            );\\n        }\\n\\n        {\\n            uint64 nodeNum = latestNodeCreated() + 1;\\n\\n            // Fetch a storage reference to prevNode since we copied our other one into memory\\n            // and we don't have enough stack available to keep to keep the previous storage reference around\\n            Node storage prevNode = getNodeStorage(prevNodeNum);\\n            prevNode.childCreated(nodeNum);\\n\\n            nodeCreated(memoryFrame.node);\\n        }\\n\\n        emit NodeCreated(\\n            latestNodeCreated(),\\n            memoryFrame.prevNode.nodeHash,\\n            newNodeHash,\\n            memoryFrame.executionHash,\\n            assertion,\\n            memoryFrame.sequencerBatchAcc,\\n            wasmModuleRoot,\\n            memoryFrame.currentInboxSize\\n        );\\n\\n        return newNodeHash;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/ValidatorUtils.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../rollup/IRollupCore.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\nimport {NO_CHAL_INDEX} from \\\"../libraries/Constants.sol\\\";\\n\\ncontract ValidatorUtils {\\n    using NodeLib for Node;\\n\\n    enum ConfirmType {\\n        NONE,\\n        VALID,\\n        INVALID\\n    }\\n\\n    enum NodeConflictType {\\n        NONE,\\n        FOUND,\\n        INDETERMINATE,\\n        INCOMPLETE\\n    }\\n\\n    struct NodeConflict {\\n        NodeConflictType ty;\\n        uint64 node1;\\n        uint64 node2;\\n    }\\n\\n    function findStakerConflict(\\n        IRollupCore rollup,\\n        address staker1,\\n        address staker2,\\n        uint256 maxDepth\\n    ) external view returns (NodeConflict memory) {\\n        uint64 staker1NodeNum = rollup.latestStakedNode(staker1);\\n        uint64 staker2NodeNum = rollup.latestStakedNode(staker2);\\n        return findNodeConflict(rollup, staker1NodeNum, staker2NodeNum, maxDepth);\\n    }\\n\\n    function checkDecidableNextNode(IRollupUserAbs rollup) external view returns (ConfirmType) {\\n        try ValidatorUtils(address(this)).requireConfirmable(rollup) {\\n            return ConfirmType.VALID;\\n        } catch {}\\n\\n        try ValidatorUtils(address(this)).requireRejectable(rollup) {\\n            return ConfirmType.INVALID;\\n        } catch {\\n            return ConfirmType.NONE;\\n        }\\n    }\\n\\n    function requireRejectable(IRollupCore rollup) external view {\\n        IRollupUser(address(rollup)).requireUnresolvedExists();\\n        uint64 firstUnresolvedNode = rollup.firstUnresolvedNode();\\n        Node memory node = rollup.getNode(firstUnresolvedNode);\\n        if (node.prevNum == rollup.latestConfirmed()) {\\n            // Verify the block's deadline has passed\\n            require(block.number >= node.deadlineBlock, \\\"BEFORE_DEADLINE\\\");\\n            rollup.getNode(node.prevNum).requirePastChildConfirmDeadline();\\n\\n            // Verify that no staker is staked on this node\\n            require(\\n                node.stakerCount ==\\n                    IRollupUser(address(rollup)).countStakedZombies(firstUnresolvedNode),\\n                \\\"HAS_STAKERS\\\"\\n            );\\n        }\\n    }\\n\\n    function requireConfirmable(IRollupUserAbs rollup) external view {\\n        rollup.requireUnresolvedExists();\\n\\n        uint256 stakerCount = rollup.stakerCount();\\n        // There is at least one non-zombie staker\\n        require(stakerCount > 0, \\\"NO_STAKERS\\\");\\n\\n        uint64 firstUnresolved = rollup.firstUnresolvedNode();\\n        Node memory node = rollup.getNode(firstUnresolved);\\n\\n        // Verify the block's deadline has passed\\n        node.requirePastDeadline();\\n\\n        // Check that prev is latest confirmed\\n        assert(node.prevNum == rollup.latestConfirmed());\\n\\n        Node memory prevNode = rollup.getNode(node.prevNum);\\n        prevNode.requirePastChildConfirmDeadline();\\n\\n        uint256 zombiesStakedOnOtherChildren = rollup.countZombiesStakedOnChildren(node.prevNum) -\\n            rollup.countStakedZombies(firstUnresolved);\\n        require(\\n            prevNode.childStakerCount == node.stakerCount + zombiesStakedOnOtherChildren,\\n            \\\"NOT_ALL_STAKED\\\"\\n        );\\n    }\\n\\n    function refundableStakers(IRollupCore rollup) external view returns (address[] memory) {\\n        uint256 stakerCount = rollup.stakerCount();\\n        address[] memory stakers = new address[](stakerCount);\\n        uint256 latestConfirmed = rollup.latestConfirmed();\\n        uint256 index = 0;\\n        for (uint64 i = 0; i < stakerCount; i++) {\\n            address staker = rollup.getStakerAddress(i);\\n            uint256 latestStakedNode = rollup.latestStakedNode(staker);\\n            if (latestStakedNode <= latestConfirmed && rollup.currentChallenge(staker) == 0) {\\n                stakers[index] = staker;\\n                index++;\\n            }\\n        }\\n        assembly {\\n            mstore(stakers, index)\\n        }\\n        return stakers;\\n    }\\n\\n    function latestStaked(IRollupCore rollup, address staker)\\n        external\\n        view\\n        returns (uint64, Node memory)\\n    {\\n        uint64 num = rollup.latestStakedNode(staker);\\n        if (num == 0) {\\n            num = rollup.latestConfirmed();\\n        }\\n        Node memory node = rollup.getNode(num);\\n        return (num, node);\\n    }\\n\\n    function stakedNodes(IRollupCore rollup, address staker)\\n        external\\n        view\\n        returns (uint64[] memory)\\n    {\\n        uint64[] memory nodes = new uint64[](100000);\\n        uint256 index = 0;\\n        for (uint64 i = rollup.latestConfirmed(); i <= rollup.latestNodeCreated(); i++) {\\n            if (rollup.nodeHasStaker(i, staker)) {\\n                nodes[index] = i;\\n                index++;\\n            }\\n        }\\n        // Shrink array down to real size\\n        assembly {\\n            mstore(nodes, index)\\n        }\\n        return nodes;\\n    }\\n\\n    function findNodeConflict(\\n        IRollupCore rollup,\\n        uint64 node1,\\n        uint64 node2,\\n        uint256 maxDepth\\n    ) public view returns (NodeConflict memory) {\\n        uint64 firstUnresolvedNode = rollup.firstUnresolvedNode();\\n        uint64 node1Prev = rollup.getNode(node1).prevNum;\\n        uint64 node2Prev = rollup.getNode(node2).prevNum;\\n\\n        for (uint256 i = 0; i < maxDepth; i++) {\\n            if (node1 == node2) {\\n                return NodeConflict(NodeConflictType.NONE, node1, node2);\\n            }\\n            if (node1Prev == node2Prev) {\\n                return NodeConflict(NodeConflictType.FOUND, node1, node2);\\n            }\\n            if (node1Prev < firstUnresolvedNode && node2Prev < firstUnresolvedNode) {\\n                return NodeConflict(NodeConflictType.INDETERMINATE, 0, 0);\\n            }\\n            if (node1Prev < node2Prev) {\\n                node2 = node2Prev;\\n                node2Prev = rollup.getNode(node2).prevNum;\\n            } else {\\n                node1 = node1Prev;\\n                node1Prev = rollup.getNode(node1).prevNum;\\n            }\\n        }\\n        return NodeConflict(NodeConflictType.INCOMPLETE, 0, 0);\\n    }\\n\\n    function getStakers(\\n        IRollupCore rollup,\\n        uint64 startIndex,\\n        uint64 max\\n    ) public view returns (address[] memory, bool hasMore) {\\n        uint256 maxStakers = rollup.stakerCount();\\n        if (startIndex + max <= maxStakers) {\\n            maxStakers = startIndex + max;\\n            hasMore = true;\\n        }\\n\\n        address[] memory stakers = new address[](maxStakers);\\n        for (uint64 i = 0; i < maxStakers; i++) {\\n            stakers[i] = rollup.getStakerAddress(startIndex + i);\\n        }\\n        return (stakers, hasMore);\\n    }\\n\\n    function timedOutChallenges(\\n        IRollupCore rollup,\\n        uint64 startIndex,\\n        uint64 max\\n    ) external view returns (uint64[] memory, bool hasMore) {\\n        (address[] memory stakers, bool hasMoreStakers) = getStakers(rollup, startIndex, max);\\n        uint64[] memory challenges = new uint64[](stakers.length);\\n        uint256 index = 0;\\n        IChallengeManager challengeManager = rollup.challengeManager();\\n        for (uint256 i = 0; i < stakers.length; i++) {\\n            address staker = stakers[i];\\n            uint64 challengeIndex = rollup.currentChallenge(staker);\\n            if (\\n                challengeIndex != NO_CHAL_INDEX &&\\n                challengeManager.isTimedOut(challengeIndex) &&\\n                challengeManager.currentResponder(challengeIndex) == staker\\n            ) {\\n                challenges[index++] = challengeIndex;\\n            }\\n        }\\n        // Shrink array down to real size\\n        assembly {\\n            mstore(challenges, index)\\n        }\\n        return (challenges, hasMoreStakers);\\n    }\\n\\n    // Worst case runtime of O(depth), as it terminates if it switches paths.\\n    function areUnresolvedNodesLinear(IRollupCore rollup) external view returns (bool) {\\n        uint256 end = rollup.latestNodeCreated();\\n        for (uint64 i = rollup.firstUnresolvedNode(); i <= end; i++) {\\n            if (i > 0 && rollup.getNode(i).prevNum != i - 1) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/ValidatorWallet.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\n/// @dev thrown when arrays provided don't have the expected length\\nerror BadArrayLength(uint256 expected, uint256 actual);\\n\\n/// @dev thrown when a function is called by an address that isn't the owner nor a executor\\nerror NotExecutorOrOwner(address actual);\\n\\n/// @dev thrown when the particular address can't be called by an executor\\nerror OnlyOwnerDestination(address expected, address actual, address destination);\\n\\n/// @dev thrown when eth withdrawal tx fails\\nerror WithdrawEthFail(address destination);\\n\\ncontract ValidatorWallet is OwnableUpgradeable, DelegateCallAware, GasRefundEnabled {\\n    using Address for address;\\n\\n    /// @dev a executor is allowed to call only certain contracts\\n    mapping(address => bool) public executors;\\n\\n    /// @dev allowed addresses which can be called by an executor\\n    mapping(address => bool) public allowedExecutorDestinations;\\n\\n    modifier onlyExecutorOrOwner() {\\n        if (!executors[_msgSender()] && owner() != _msgSender())\\n            revert NotExecutorOrOwner(_msgSender());\\n        _;\\n    }\\n\\n    event ExecutorUpdated(address indexed executor, bool isExecutor);\\n\\n    /// @dev updates the executor addresses\\n    function setExecutor(address[] calldata newExecutors, bool[] calldata isExecutor)\\n        external\\n        onlyOwner\\n    {\\n        if (newExecutors.length != isExecutor.length)\\n            revert BadArrayLength(newExecutors.length, isExecutor.length);\\n        unchecked {\\n            for (uint64 i = 0; i < newExecutors.length; ++i) {\\n                executors[newExecutors[i]] = isExecutor[i];\\n                emit ExecutorUpdated(newExecutors[i], isExecutor[i]);\\n            }\\n        }\\n    }\\n\\n    function initialize(\\n        address _executor,\\n        address _owner,\\n        address[] calldata initialExecutorAllowedDests\\n    ) external initializer onlyDelegated {\\n        __Ownable_init();\\n        transferOwnership(_owner);\\n\\n        executors[_executor] = true;\\n        emit ExecutorUpdated(_executor, true);\\n\\n        unchecked {\\n            for (uint64 i = 0; i < initialExecutorAllowedDests.length; ++i) {\\n                allowedExecutorDestinations[initialExecutorAllowedDests[i]] = true;\\n                emit AllowedExecutorDestinationsUpdated(initialExecutorAllowedDests[i], true);\\n            }\\n        }\\n    }\\n\\n    event AllowedExecutorDestinationsUpdated(address indexed destination, bool isSet);\\n\\n    /// @notice updates the destination addresses which executors are allowed to call\\n    function setAllowedExecutorDestinations(address[] calldata destinations, bool[] calldata isSet)\\n        external\\n        onlyOwner\\n    {\\n        if (destinations.length != isSet.length)\\n            revert BadArrayLength(destinations.length, isSet.length);\\n        unchecked {\\n            for (uint256 i = 0; i < destinations.length; ++i) {\\n                allowedExecutorDestinations[destinations[i]] = isSet[i];\\n                emit AllowedExecutorDestinationsUpdated(destinations[i], isSet[i]);\\n            }\\n        }\\n    }\\n\\n    /// @dev reverts if the current function can't be called\\n    function validateExecuteTransaction(address destination) public view {\\n        if (!allowedExecutorDestinations[destination] && owner() != _msgSender())\\n            revert OnlyOwnerDestination(owner(), _msgSender(), destination);\\n    }\\n\\n    function executeTransactions(\\n        bytes[] calldata data,\\n        address[] calldata destination,\\n        uint256[] calldata amount\\n    ) external payable {\\n        executeTransactionsWithGasRefunder(IGasRefunder(address(0)), data, destination, amount);\\n    }\\n\\n    function executeTransactionsWithGasRefunder(\\n        IGasRefunder gasRefunder,\\n        bytes[] calldata data,\\n        address[] calldata destination,\\n        uint256[] calldata amount\\n    ) public payable onlyExecutorOrOwner refundsGas(gasRefunder) {\\n        uint256 numTxes = data.length;\\n        if (numTxes != destination.length) revert BadArrayLength(numTxes, destination.length);\\n        if (numTxes != amount.length) revert BadArrayLength(numTxes, amount.length);\\n\\n        for (uint256 i = 0; i < numTxes; i++) {\\n            if (data[i].length > 0) require(destination[i].isContract(), \\\"NO_CODE_AT_ADDR\\\");\\n            validateExecuteTransaction(destination[i]);\\n            // We use a low level call here to allow for contract and non-contract calls\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, ) = address(destination[i]).call{value: amount[i]}(data[i]);\\n            if (!success) {\\n                assembly {\\n                    let ptr := mload(0x40)\\n                    let size := returndatasize()\\n                    returndatacopy(ptr, 0, size)\\n                    revert(ptr, size)\\n                }\\n            }\\n        }\\n    }\\n\\n    function executeTransaction(\\n        bytes calldata data,\\n        address destination,\\n        uint256 amount\\n    ) external payable {\\n        executeTransactionWithGasRefunder(IGasRefunder(address(0)), data, destination, amount);\\n    }\\n\\n    function executeTransactionWithGasRefunder(\\n        IGasRefunder gasRefunder,\\n        bytes calldata data,\\n        address destination,\\n        uint256 amount\\n    ) public payable onlyExecutorOrOwner refundsGas(gasRefunder) {\\n        if (data.length > 0) require(destination.isContract(), \\\"NO_CODE_AT_ADDR\\\");\\n        validateExecuteTransaction(destination);\\n        // We use a low level call here to allow for contract and non-contract calls\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = destination.call{value: amount}(data);\\n        if (!success) {\\n            assembly {\\n                let ptr := mload(0x40)\\n                let size := returndatasize()\\n                returndatacopy(ptr, 0, size)\\n                revert(ptr, size)\\n            }\\n        }\\n    }\\n\\n    function timeoutChallenges(IChallengeManager manager, uint64[] calldata challenges) external {\\n        timeoutChallengesWithGasRefunder(IGasRefunder(address(0)), manager, challenges);\\n    }\\n\\n    function timeoutChallengesWithGasRefunder(\\n        IGasRefunder gasRefunder,\\n        IChallengeManager manager,\\n        uint64[] calldata challenges\\n    ) public onlyExecutorOrOwner refundsGas(gasRefunder) {\\n        uint256 challengesCount = challenges.length;\\n        for (uint256 i = 0; i < challengesCount; i++) {\\n            try manager.timeout(challenges[i]) {} catch (bytes memory error) {\\n                if (error.length == 0) {\\n                    // Assume out of gas\\n                    // We need to revert here so gas estimation works\\n                    require(false, \\\"GAS\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n\\n    /// @dev allows the owner to withdraw eth held by this contract\\n    function withdrawEth(uint256 amount, address destination) external onlyOwner {\\n        (bool success, ) = destination.call{value: amount}(\\\"\\\");\\n        if (!success) revert WithdrawEthFail(destination);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/rollup/ValidatorWalletCreator.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./ValidatorWallet.sol\\\";\\n\\ncontract ValidatorWalletCreator is Ownable {\\n    event WalletCreated(\\n        address indexed walletAddress,\\n        address indexed executorAddress,\\n        address indexed ownerAddress,\\n        address adminProxy\\n    );\\n    event TemplateUpdated();\\n\\n    address public template;\\n\\n    constructor() Ownable() {\\n        template = address(new ValidatorWallet());\\n    }\\n\\n    function setTemplate(address _template) external onlyOwner {\\n        template = _template;\\n        emit TemplateUpdated();\\n    }\\n\\n    function createWallet(address[] calldata initialExecutorAllowedDests)\\n        external\\n        returns (address)\\n    {\\n        address _executor = msg.sender;\\n        address _owner = msg.sender;\\n        ProxyAdmin admin = new ProxyAdmin();\\n        address proxy = address(\\n            new TransparentUpgradeableProxy(address(template), address(admin), \\\"\\\")\\n        );\\n        admin.transferOwnership(_owner);\\n        ValidatorWallet(payable(proxy)).initialize(_executor, _owner, initialExecutorAllowedDests);\\n        emit WalletCreated(proxy, _executor, _owner, address(admin));\\n        return proxy;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/UpgradeableBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBeacon.sol\\\";\\nimport \\\"../../access/Ownable.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This contract is used in conjunction with one or more instances of {BeaconProxy} to determine their\\n * implementation contract, which is where they will delegate all function calls.\\n *\\n * An owner is able to change the implementation the beacon points to, thus upgrading the proxies that use this beacon.\\n */\\ncontract UpgradeableBeacon is IBeacon, Ownable {\\n    address private _implementation;\\n\\n    /**\\n     * @dev Emitted when the implementation returned by the beacon is changed.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Sets the address of the initial implementation, and the deployer account as the owner who can upgrade the\\n     * beacon.\\n     */\\n    constructor(address implementation_) {\\n        _setImplementation(implementation_);\\n    }\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function implementation() public view virtual override returns (address) {\\n        return _implementation;\\n    }\\n\\n    /**\\n     * @dev Upgrades the beacon to a new implementation.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * Requirements:\\n     *\\n     * - msg.sender must be the owner of the contract.\\n     * - `newImplementation` must be a contract.\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyOwner {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the implementation contract address for this beacon\\n     *\\n     * Requirements:\\n     *\\n     * - `newImplementation` must be a contract.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(Address.isContract(newImplementation), \\\"UpgradeableBeacon: implementation is not a contract\\\");\\n        _implementation = newImplementation;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/SimpleProxy.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/proxy/Proxy.sol\\\";\\n\\ncontract SimpleProxy is Proxy {\\n    address private immutable impl;\\n\\n    constructor(address impl_) {\\n        impl = impl_;\\n    }\\n\\n    function _implementation() internal view override returns (address) {\\n        return impl;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822.sol\\\";\\nimport \\\"../ERC1967/ERC1967Upgrade.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n}\\n\"\r\n    },\r\n    \"src/libraries/SecondaryLogicUUPSUpgradeable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {DoubleLogicERC1967Upgrade} from \\\"./AdminFallbackProxy.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/// @notice An extension to OZ's UUPSUpgradeable contract to be used for handling UUPS upgrades with a DoubleLogicERC1967Upgrade proxy\\n/// @dev upgrades should be handles by the primary logic contract in order to pass the `onlyProxy` check\\nabstract contract SecondaryLogicUUPSUpgradeable is UUPSUpgradeable, DoubleLogicERC1967Upgrade {\\n    /// @inheritdoc UUPSUpgradeable\\n    function proxiableUUID() external view override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the secondary contract. Called by\\n     * {upgradeSecondaryTo} and {upgradeSecondaryToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeSecondaryUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeSecondaryUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev Upgrade the secondary implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeSecondaryUpgrade}.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function upgradeSecondaryTo(address newImplementation) external onlyProxy {\\n        _authorizeSecondaryUpgrade(newImplementation);\\n        _upgradeSecondaryToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the secondary implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeSecondaryUpgrade}.\\n     *\\n     * Emits an {UpgradedSecondary} event.\\n     */\\n    function upgradeSecondaryToAndCall(address newImplementation, bytes memory data)\\n        external\\n        payable\\n        onlyProxy\\n    {\\n        _authorizeSecondaryUpgrade(newImplementation);\\n        _upgradeSecondaryToAndCallUUPS(newImplementation, data, true);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupAdminLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {IRollupAdmin, IRollupUser} from \\\"./IRollupLogic.sol\\\";\\nimport \\\"./RollupCore.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\nimport \\\"../libraries/SecondaryLogicUUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/beacon/UpgradeableBeacon.sol\\\";\\n\\nimport {NO_CHAL_INDEX} from \\\"../libraries/Constants.sol\\\";\\n\\ncontract RollupAdminLogic is RollupCore, IRollupAdmin, SecondaryLogicUUPSUpgradeable {\\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\\n        external\\n        override\\n        onlyProxy\\n        initializer\\n    {\\n        rollupDeploymentBlock = block.number;\\n        bridge = connectedContracts.bridge;\\n        sequencerInbox = connectedContracts.sequencerInbox;\\n        connectedContracts.bridge.setDelayedInbox(address(connectedContracts.inbox), true);\\n        connectedContracts.bridge.setSequencerInbox(address(connectedContracts.sequencerInbox));\\n\\n        inbox = connectedContracts.inbox;\\n        outbox = connectedContracts.outbox;\\n        connectedContracts.bridge.setOutbox(address(connectedContracts.outbox), true);\\n        rollupEventInbox = connectedContracts.rollupEventInbox;\\n        connectedContracts.bridge.setDelayedInbox(\\n            address(connectedContracts.rollupEventInbox),\\n            true\\n        );\\n\\n        connectedContracts.rollupEventInbox.rollupInitialized(config.chainId);\\n        connectedContracts.sequencerInbox.addSequencerL2Batch(0, \\\"\\\", 1, IGasRefunder(address(0)));\\n\\n        validatorUtils = connectedContracts.validatorUtils;\\n        validatorWalletCreator = connectedContracts.validatorWalletCreator;\\n        challengeManager = connectedContracts.challengeManager;\\n\\n        Node memory node = createInitialNode();\\n        initializeCore(node);\\n\\n        confirmPeriodBlocks = config.confirmPeriodBlocks;\\n        extraChallengeTimeBlocks = config.extraChallengeTimeBlocks;\\n        chainId = config.chainId;\\n        baseStake = config.baseStake;\\n        wasmModuleRoot = config.wasmModuleRoot;\\n        // A little over 15 minutes\\n        minimumAssertionPeriod = 75;\\n\\n        // the owner can't access the rollup user facet where escrow is redeemable\\n        require(config.loserStakeEscrow != _getAdmin(), \\\"INVALID_ESCROW_ADMIN\\\");\\n        // this next check shouldn't be an issue if the owner controls an AdminProxy\\n        // that accesses the admin facet, but still seems like a good extra precaution\\n        require(config.loserStakeEscrow != config.owner, \\\"INVALID_ESCROW_OWNER\\\");\\n        loserStakeEscrow = config.loserStakeEscrow;\\n\\n        stakeToken = config.stakeToken;\\n\\n        emit RollupInitialized(config.wasmModuleRoot, config.chainId);\\n    }\\n\\n    function createInitialNode() private view returns (Node memory) {\\n        GlobalState memory emptyGlobalState;\\n        bytes32 state = RollupLib.stateHashMem(\\n            RollupLib.ExecutionState(emptyGlobalState, MachineStatus.FINISHED),\\n            1 // inboxMaxCount - force the first assertion to read a message\\n        );\\n        return\\n            NodeLib.createNode(\\n                state,\\n                0, // challenge hash (not challengeable)\\n                0, // confirm data\\n                0, // prev node\\n                uint64(block.number), // deadline block (not challengeable)\\n                0 // initial node has a node hash of 0\\n            );\\n    }\\n\\n    /**\\n     * Functions are only to reach this logic contract if the caller is the owner\\n     * so there is no need for a redundant onlyOwner check\\n     */\\n\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external override {\\n        outbox = _outbox;\\n        bridge.setOutbox(address(_outbox), true);\\n        emit OwnerFunctionCalled(0);\\n    }\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external override {\\n        require(_outbox != address(outbox), \\\"CUR_OUTBOX\\\");\\n        bridge.setOutbox(_outbox, false);\\n        emit OwnerFunctionCalled(1);\\n    }\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setDelayedInbox(address _inbox, bool _enabled) external override {\\n        bridge.setDelayedInbox(address(_inbox), _enabled);\\n        emit OwnerFunctionCalled(2);\\n    }\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract.\\n     * The time spent paused is not incremented in the rollup's timing for node validation.\\n     */\\n    function pause() external override {\\n        _pause();\\n        emit OwnerFunctionCalled(3);\\n    }\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external override {\\n        _unpause();\\n        emit OwnerFunctionCalled(4);\\n    }\\n\\n    /// @notice allows the admin to upgrade the primary logic contract (ie rollup admin logic, aka this)\\n    /// @dev this function doesn't revert as this primary logic contract is only\\n    /// reachable by the proxy's admin\\n    function _authorizeUpgrade(address newImplementation) internal override {}\\n\\n    /// @notice allows the admin to upgrade the secondary logic contract (ie rollup user logic)\\n    /// @dev this function doesn't revert as this primary logic contract is only\\n    /// reachable by the proxy's admin\\n    function _authorizeSecondaryUpgrade(address newImplementation) internal override {}\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] calldata _validator, bool[] calldata _val) external override {\\n        require(_validator.length == _val.length, \\\"WRONG_LENGTH\\\");\\n\\n        for (uint256 i = 0; i < _validator.length; i++) {\\n            isValidator[_validator[i]] = _val[i];\\n        }\\n        emit OwnerFunctionCalled(6);\\n    }\\n\\n    /**\\n     * @notice Set a new owner address for the rollup\\n     * @dev it is expected that only the rollup admin can use this facet to set a new owner\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external override {\\n        _changeAdmin(newOwner);\\n        emit OwnerFunctionCalled(7);\\n    }\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external override {\\n        minimumAssertionPeriod = newPeriod;\\n        emit OwnerFunctionCalled(8);\\n    }\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks\\n     */\\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external override {\\n        confirmPeriodBlocks = newConfirmPeriod;\\n        emit OwnerFunctionCalled(9);\\n    }\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external override {\\n        extraChallengeTimeBlocks = newExtraTimeBlocks;\\n        emit OwnerFunctionCalled(10);\\n    }\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake minimum amount of stake required\\n     */\\n    function setBaseStake(uint256 newBaseStake) external override {\\n        baseStake = newBaseStake;\\n        emit OwnerFunctionCalled(12);\\n    }\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User facet!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external override whenPaused {\\n        /*\\n         * To change the stake token without breaking consistency one would need to:\\n         * Pause the system, have all stakers remove their funds,\\n         * update the user logic to handle ERC20s, change the stake token, then resume.\\n         *\\n         * Note: To avoid loss of funds stakers must remove their funds and claim all the\\n         * available withdrawable funds before the system is paused.\\n         */\\n        bool expectERC20Support = newStakeToken != address(0);\\n        // this assumes the rollup isn't its own admin. if needed, instead use a ProxyAdmin by OZ!\\n        bool actualERC20Support = IRollupUser(address(this)).isERC20Enabled();\\n        require(actualERC20Support == expectERC20Support, \\\"NO_USER_LOGIC_SUPPORT\\\");\\n        require(stakerCount() == 0, \\\"NO_ACTIVE_STAKERS\\\");\\n        require(totalWithdrawableFunds == 0, \\\"NO_PENDING_WITHDRAW\\\");\\n        stakeToken = newStakeToken;\\n        emit OwnerFunctionCalled(13);\\n    }\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external override {\\n        UpgradeableBeacon(beacon).upgradeTo(newImplementation);\\n        emit OwnerFunctionCalled(20);\\n    }\\n\\n    function forceResolveChallenge(address[] calldata stakerA, address[] calldata stakerB)\\n        external\\n        override\\n        whenPaused\\n    {\\n        require(stakerA.length == stakerB.length, \\\"WRONG_LENGTH\\\");\\n        for (uint256 i = 0; i < stakerA.length; i++) {\\n            uint64 chall = inChallenge(stakerA[i], stakerB[i]);\\n\\n            require(chall != NO_CHAL_INDEX, \\\"NOT_IN_CHALL\\\");\\n            clearChallenge(stakerA[i]);\\n            clearChallenge(stakerB[i]);\\n            challengeManager.clearChallenge(chall);\\n        }\\n        emit OwnerFunctionCalled(21);\\n    }\\n\\n    function forceRefundStaker(address[] calldata staker) external override whenPaused {\\n        for (uint256 i = 0; i < staker.length; i++) {\\n            reduceStakeTo(staker[i], 0);\\n            turnIntoZombie(staker[i]);\\n        }\\n        emit OwnerFunctionCalled(22);\\n    }\\n\\n    function forceCreateNode(\\n        uint64 prevNode,\\n        uint256 prevNodeInboxMaxCount,\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash\\n    ) external override whenPaused {\\n        require(prevNode == latestConfirmed(), \\\"ONLY_LATEST_CONFIRMED\\\");\\n\\n        createNewNode(assertion, prevNode, prevNodeInboxMaxCount, expectedNodeHash);\\n\\n        emit OwnerFunctionCalled(23);\\n    }\\n\\n    function forceConfirmNode(\\n        uint64 nodeNum,\\n        bytes32 blockHash,\\n        bytes32 sendRoot\\n    ) external override whenPaused {\\n        // this skips deadline, staker and zombie validation\\n        confirmNode(nodeNum, blockHash, sendRoot);\\n        emit OwnerFunctionCalled(24);\\n    }\\n\\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external override {\\n        // escrow holder can't be proxy admin, since escrow is only redeemable through\\n        // the primary user logic contract\\n        require(newLoserStakerEscrow != _getAdmin(), \\\"INVALID_ESCROW\\\");\\n        loserStakeEscrow = newLoserStakerEscrow;\\n        emit OwnerFunctionCalled(25);\\n    }\\n\\n    /**\\n     * @notice Set the proving WASM module root\\n     * @param newWasmModuleRoot new module root\\n     */\\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external override {\\n        wasmModuleRoot = newWasmModuleRoot;\\n        emit OwnerFunctionCalled(26);\\n    }\\n\\n    /**\\n     * @notice set a new sequencer inbox contract\\n     * @param _sequencerInbox new address of sequencer inbox\\n     */\\n    function setSequencerInbox(address _sequencerInbox) external override {\\n        bridge.setSequencerInbox(_sequencerInbox);\\n        emit OwnerFunctionCalled(27);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/OneStepProverMemory.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Value.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Deserialize.sol\\\";\\nimport \\\"./IOneStepProver.sol\\\";\\n\\ncontract OneStepProverMemory is IOneStepProver {\\n    using MerkleProofLib for MerkleProof;\\n    using ModuleMemoryLib for ModuleMemory;\\n    using ValueLib for Value;\\n    using ValueStackLib for ValueStack;\\n\\n    uint256 private constant LEAF_SIZE = 32;\\n    uint64 private constant PAGE_SIZE = 65536;\\n\\n    function pullLeafByte(bytes32 leaf, uint256 idx) internal pure returns (uint8) {\\n        require(idx < LEAF_SIZE, \\\"BAD_PULL_LEAF_BYTE_IDX\\\");\\n        // Take into account that we are casting the leaf to a big-endian integer\\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\\n        return uint8(uint256(leaf) >> leafShift);\\n    }\\n\\n    function setLeafByte(\\n        bytes32 oldLeaf,\\n        uint256 idx,\\n        uint8 val\\n    ) internal pure returns (bytes32) {\\n        require(idx < LEAF_SIZE, \\\"BAD_SET_LEAF_BYTE_IDX\\\");\\n        // Take into account that we are casting the leaf to a big-endian integer\\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\\n        uint256 newLeaf = uint256(oldLeaf);\\n        newLeaf &= ~(0xFF << leafShift);\\n        newLeaf |= uint256(val) << leafShift;\\n        return bytes32(newLeaf);\\n    }\\n\\n    function executeMemoryLoad(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        ValueType ty;\\n        uint256 readBytes;\\n        bool signed;\\n        if (inst.opcode == Instructions.I32_LOAD) {\\n            ty = ValueType.I32;\\n            readBytes = 4;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I64_LOAD) {\\n            ty = ValueType.I64;\\n            readBytes = 8;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.F32_LOAD) {\\n            ty = ValueType.F32;\\n            readBytes = 4;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.F64_LOAD) {\\n            ty = ValueType.F64;\\n            readBytes = 8;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I32_LOAD8_S) {\\n            ty = ValueType.I32;\\n            readBytes = 1;\\n            signed = true;\\n        } else if (inst.opcode == Instructions.I32_LOAD8_U) {\\n            ty = ValueType.I32;\\n            readBytes = 1;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I32_LOAD16_S) {\\n            ty = ValueType.I32;\\n            readBytes = 2;\\n            signed = true;\\n        } else if (inst.opcode == Instructions.I32_LOAD16_U) {\\n            ty = ValueType.I32;\\n            readBytes = 2;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I64_LOAD8_S) {\\n            ty = ValueType.I64;\\n            readBytes = 1;\\n            signed = true;\\n        } else if (inst.opcode == Instructions.I64_LOAD8_U) {\\n            ty = ValueType.I64;\\n            readBytes = 1;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I64_LOAD16_S) {\\n            ty = ValueType.I64;\\n            readBytes = 2;\\n            signed = true;\\n        } else if (inst.opcode == Instructions.I64_LOAD16_U) {\\n            ty = ValueType.I64;\\n            readBytes = 2;\\n            signed = false;\\n        } else if (inst.opcode == Instructions.I64_LOAD32_S) {\\n            ty = ValueType.I64;\\n            readBytes = 4;\\n            signed = true;\\n        } else if (inst.opcode == Instructions.I64_LOAD32_U) {\\n            ty = ValueType.I64;\\n            readBytes = 4;\\n            signed = false;\\n        } else {\\n            revert(\\\"INVALID_MEMORY_LOAD_OPCODE\\\");\\n        }\\n\\n        // Neither of these can overflow as they're computed with much less than 256 bit integers.\\n        uint256 startIdx = inst.argumentData + mach.valueStack.pop().assumeI32();\\n        if (startIdx + readBytes > mod.moduleMemory.size) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        uint256 proofOffset = 0;\\n        uint256 lastProvedLeafIdx = ~uint256(0);\\n        bytes32 lastProvedLeafContents;\\n        uint64 readValue;\\n        for (uint256 i = 0; i < readBytes; i++) {\\n            uint256 idx = startIdx + i;\\n            uint256 leafIdx = idx / LEAF_SIZE;\\n            if (leafIdx != lastProvedLeafIdx) {\\n                // This hits the stack size if we phrase it as mod.moduleMemory.proveLeaf(...)\\n                (lastProvedLeafContents, proofOffset, ) = ModuleMemoryLib.proveLeaf(\\n                    mod.moduleMemory,\\n                    leafIdx,\\n                    proof,\\n                    proofOffset\\n                );\\n                lastProvedLeafIdx = leafIdx;\\n            }\\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\\n            readValue |=\\n                uint64(pullLeafByte(lastProvedLeafContents, indexWithinLeaf)) <<\\n                uint64(i * 8);\\n        }\\n\\n        if (signed) {\\n            // Go down to the original uint size, change to signed, go up to correct size, convert back to unsigned\\n            if (readBytes == 1 && ty == ValueType.I32) {\\n                readValue = uint32(int32(int8(uint8(readValue))));\\n            } else if (readBytes == 1 && ty == ValueType.I64) {\\n                readValue = uint64(int64(int8(uint8(readValue))));\\n            } else if (readBytes == 2 && ty == ValueType.I32) {\\n                readValue = uint32(int32(int16(uint16(readValue))));\\n            } else if (readBytes == 2 && ty == ValueType.I64) {\\n                readValue = uint64(int64(int16(uint16(readValue))));\\n            } else if (readBytes == 4 && ty == ValueType.I64) {\\n                readValue = uint64(int64(int32(uint32(readValue))));\\n            } else {\\n                revert(\\\"BAD_READ_BYTES_SIGNED\\\");\\n            }\\n        }\\n\\n        mach.valueStack.push(Value({valueType: ty, contents: readValue}));\\n    }\\n\\n    function executeMemoryStore(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        uint64 writeBytes;\\n        uint64 toWrite;\\n        {\\n            ValueType ty;\\n            if (inst.opcode == Instructions.I32_STORE) {\\n                ty = ValueType.I32;\\n                writeBytes = 4;\\n            } else if (inst.opcode == Instructions.I64_STORE) {\\n                ty = ValueType.I64;\\n                writeBytes = 8;\\n            } else if (inst.opcode == Instructions.F32_STORE) {\\n                ty = ValueType.F32;\\n                writeBytes = 4;\\n            } else if (inst.opcode == Instructions.F64_STORE) {\\n                ty = ValueType.F64;\\n                writeBytes = 8;\\n            } else if (inst.opcode == Instructions.I32_STORE8) {\\n                ty = ValueType.I32;\\n                writeBytes = 1;\\n            } else if (inst.opcode == Instructions.I32_STORE16) {\\n                ty = ValueType.I32;\\n                writeBytes = 2;\\n            } else if (inst.opcode == Instructions.I64_STORE8) {\\n                ty = ValueType.I64;\\n                writeBytes = 1;\\n            } else if (inst.opcode == Instructions.I64_STORE16) {\\n                ty = ValueType.I64;\\n                writeBytes = 2;\\n            } else if (inst.opcode == Instructions.I64_STORE32) {\\n                ty = ValueType.I64;\\n                writeBytes = 4;\\n            } else {\\n                revert(\\\"INVALID_MEMORY_STORE_OPCODE\\\");\\n            }\\n\\n            Value memory writingVal = mach.valueStack.pop();\\n            require(writingVal.valueType == ty, \\\"BAD_STORE_TYPE\\\");\\n            toWrite = uint64(writingVal.contents);\\n            if (writeBytes < 8) {\\n                toWrite &= (uint64(1) << (writeBytes * 8)) - 1;\\n            }\\n        }\\n\\n        // Neither of these can overflow as they're computed with much less than 256 bit integers.\\n        uint256 startIdx = inst.argumentData + mach.valueStack.pop().assumeI32();\\n        if (startIdx + writeBytes > mod.moduleMemory.size) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        uint256 proofOffset = 0;\\n        uint256 lastProvedLeafIdx = ~uint256(0);\\n        MerkleProof memory lastProvedMerkle;\\n        bytes32 lastProvedLeafContents;\\n        for (uint256 i = 0; i < writeBytes; i++) {\\n            uint256 idx = startIdx + i;\\n            uint256 leafIdx = idx / LEAF_SIZE;\\n            if (leafIdx != lastProvedLeafIdx) {\\n                if (lastProvedLeafIdx != ~uint256(0)) {\\n                    // Apply the last leaf update\\n                    mod.moduleMemory.merkleRoot = lastProvedMerkle.computeRootFromMemory(\\n                        lastProvedLeafIdx,\\n                        lastProvedLeafContents\\n                    );\\n                }\\n                // This hits the stack size if we phrase it as mod.moduleMemory.proveLeaf(...)\\n                (lastProvedLeafContents, proofOffset, lastProvedMerkle) = ModuleMemoryLib.proveLeaf(\\n                    mod.moduleMemory,\\n                    leafIdx,\\n                    proof,\\n                    proofOffset\\n                );\\n                lastProvedLeafIdx = leafIdx;\\n            }\\n            uint256 indexWithinLeaf = idx % LEAF_SIZE;\\n            lastProvedLeafContents = setLeafByte(\\n                lastProvedLeafContents,\\n                indexWithinLeaf,\\n                uint8(toWrite)\\n            );\\n            toWrite >>= 8;\\n        }\\n        mod.moduleMemory.merkleRoot = lastProvedMerkle.computeRootFromMemory(\\n            lastProvedLeafIdx,\\n            lastProvedLeafContents\\n        );\\n    }\\n\\n    function executeMemorySize(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 pages = uint32(mod.moduleMemory.size / PAGE_SIZE);\\n        mach.valueStack.push(ValueLib.newI32(pages));\\n    }\\n\\n    function executeMemoryGrow(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 oldPages = uint32(mod.moduleMemory.size / PAGE_SIZE);\\n        uint32 growingPages = mach.valueStack.pop().assumeI32();\\n        // Safe as the input integers are too small to overflow a uint256\\n        uint256 newSize = uint256(oldPages) + uint256(growingPages);\\n        if (newSize <= mod.moduleMemory.maxSize) {\\n            mod.moduleMemory.size = uint64(newSize * PAGE_SIZE);\\n            mach.valueStack.push(ValueLib.newI32(oldPages));\\n        } else {\\n            mach.valueStack.push(ValueLib.newI32(~uint32(0)));\\n        }\\n    }\\n\\n    function executeOneStep(\\n        ExecutionContext calldata,\\n        Machine calldata startMach,\\n        Module calldata startMod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) external pure override returns (Machine memory mach, Module memory mod) {\\n        mach = startMach;\\n        mod = startMod;\\n\\n        uint16 opcode = inst.opcode;\\n\\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\\n            internal\\n            pure impl;\\n        if (opcode >= Instructions.I32_LOAD && opcode <= Instructions.I64_LOAD32_U) {\\n            impl = executeMemoryLoad;\\n        } else if (opcode >= Instructions.I32_STORE && opcode <= Instructions.I64_STORE32) {\\n            impl = executeMemoryStore;\\n        } else if (opcode == Instructions.MEMORY_SIZE) {\\n            impl = executeMemorySize;\\n        } else if (opcode == Instructions.MEMORY_GROW) {\\n            impl = executeMemoryGrow;\\n        } else {\\n            revert(\\\"INVALID_MEMORY_OPCODE\\\");\\n        }\\n\\n        impl(mach, mod, inst, proof);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/OneStepProverMath.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Value.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Deserialize.sol\\\";\\nimport \\\"./IOneStepProver.sol\\\";\\n\\ncontract OneStepProverMath is IOneStepProver {\\n    using ValueLib for Value;\\n    using ValueStackLib for ValueStack;\\n\\n    function executeEqz(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        Value memory v = mach.valueStack.pop();\\n        if (inst.opcode == Instructions.I32_EQZ) {\\n            require(v.valueType == ValueType.I32, \\\"NOT_I32\\\");\\n        } else if (inst.opcode == Instructions.I64_EQZ) {\\n            require(v.valueType == ValueType.I64, \\\"NOT_I64\\\");\\n        } else {\\n            revert(\\\"BAD_EQZ\\\");\\n        }\\n\\n        uint32 output;\\n        if (v.contents == 0) {\\n            output = 1;\\n        } else {\\n            output = 0;\\n        }\\n\\n        mach.valueStack.push(ValueLib.newI32(output));\\n    }\\n\\n    function signExtend(uint32 a) internal pure returns (uint64) {\\n        if (a & (1 << 31) != 0) {\\n            return uint64(a) | uint64(0xffffffff00000000);\\n        }\\n        return uint64(a);\\n    }\\n\\n    function i64RelOp(\\n        uint64 a,\\n        uint64 b,\\n        uint16 relop\\n    ) internal pure returns (bool) {\\n        if (relop == Instructions.IRELOP_EQ) {\\n            return (a == b);\\n        } else if (relop == Instructions.IRELOP_NE) {\\n            return (a != b);\\n        } else if (relop == Instructions.IRELOP_LT_S) {\\n            return (int64(a) < int64(b));\\n        } else if (relop == Instructions.IRELOP_LT_U) {\\n            return (a < b);\\n        } else if (relop == Instructions.IRELOP_GT_S) {\\n            return (int64(a) > int64(b));\\n        } else if (relop == Instructions.IRELOP_GT_U) {\\n            return (a > b);\\n        } else if (relop == Instructions.IRELOP_LE_S) {\\n            return (int64(a) <= int64(b));\\n        } else if (relop == Instructions.IRELOP_LE_U) {\\n            return (a <= b);\\n        } else if (relop == Instructions.IRELOP_GE_S) {\\n            return (int64(a) >= int64(b));\\n        } else if (relop == Instructions.IRELOP_GE_U) {\\n            return (a >= b);\\n        } else {\\n            revert(\\\"BAD IRELOP\\\");\\n        }\\n    }\\n\\n    function executeI32RelOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 b = mach.valueStack.pop().assumeI32();\\n        uint32 a = mach.valueStack.pop().assumeI32();\\n\\n        uint16 relop = inst.opcode - Instructions.I32_RELOP_BASE;\\n        uint64 a64;\\n        uint64 b64;\\n\\n        if (\\n            relop == Instructions.IRELOP_LT_S ||\\n            relop == Instructions.IRELOP_GT_S ||\\n            relop == Instructions.IRELOP_LE_S ||\\n            relop == Instructions.IRELOP_GE_S\\n        ) {\\n            a64 = signExtend(a);\\n            b64 = signExtend(b);\\n        } else {\\n            a64 = uint64(a);\\n            b64 = uint64(b);\\n        }\\n\\n        bool res = i64RelOp(a64, b64, relop);\\n\\n        mach.valueStack.push(ValueLib.newBoolean(res));\\n    }\\n\\n    function executeI64RelOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint64 b = mach.valueStack.pop().assumeI64();\\n        uint64 a = mach.valueStack.pop().assumeI64();\\n\\n        uint16 relop = inst.opcode - Instructions.I64_RELOP_BASE;\\n\\n        bool res = i64RelOp(a, b, relop);\\n\\n        mach.valueStack.push(ValueLib.newBoolean(res));\\n    }\\n\\n    function genericIUnOp(\\n        uint64 a,\\n        uint16 unop,\\n        uint16 bits\\n    ) internal pure returns (uint32) {\\n        require(bits == 32 || bits == 64, \\\"WRONG USE OF genericUnOp\\\");\\n        if (unop == Instructions.IUNOP_CLZ) {\\n            /* curbits is one-based to keep with unsigned mathematics */\\n            uint32 curbit = bits;\\n            while (curbit > 0 && (a & (1 << (curbit - 1)) == 0)) {\\n                curbit -= 1;\\n            }\\n            return (bits - curbit);\\n        } else if (unop == Instructions.IUNOP_CTZ) {\\n            uint32 curbit = 0;\\n            while (curbit < bits && ((a & (1 << curbit)) == 0)) {\\n                curbit += 1;\\n            }\\n            return curbit;\\n        } else if (unop == Instructions.IUNOP_POPCNT) {\\n            uint32 curbit = 0;\\n            uint32 res = 0;\\n            while (curbit < bits) {\\n                if ((a & (1 << curbit)) != 0) {\\n                    res += 1;\\n                }\\n                curbit++;\\n            }\\n            return res;\\n        }\\n        revert(\\\"BAD IUnOp\\\");\\n    }\\n\\n    function executeI32UnOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 a = mach.valueStack.pop().assumeI32();\\n\\n        uint16 unop = inst.opcode - Instructions.I32_UNOP_BASE;\\n\\n        uint32 res = genericIUnOp(a, unop, 32);\\n\\n        mach.valueStack.push(ValueLib.newI32(res));\\n    }\\n\\n    function executeI64UnOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint64 a = mach.valueStack.pop().assumeI64();\\n\\n        uint16 unop = inst.opcode - Instructions.I64_UNOP_BASE;\\n\\n        uint64 res = uint64(genericIUnOp(a, unop, 64));\\n\\n        mach.valueStack.push(ValueLib.newI64(res));\\n    }\\n\\n    function rotl32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        b %= 32;\\n        return (a << b) | (a >> (32 - b));\\n    }\\n\\n    function rotl64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        b %= 64;\\n        return (a << b) | (a >> (64 - b));\\n    }\\n\\n    function rotr32(uint32 a, uint32 b) internal pure returns (uint32) {\\n        b %= 32;\\n        return (a >> b) | (a << (32 - b));\\n    }\\n\\n    function rotr64(uint64 a, uint64 b) internal pure returns (uint64) {\\n        b %= 64;\\n        return (a >> b) | (a << (64 - b));\\n    }\\n\\n    function genericBinOp(\\n        uint64 a,\\n        uint64 b,\\n        uint16 opcodeOffset\\n    ) internal pure returns (uint64, bool) {\\n        unchecked {\\n            if (opcodeOffset == 0) {\\n                // add\\n                return (a + b, false);\\n            } else if (opcodeOffset == 1) {\\n                // sub\\n                return (a - b, false);\\n            } else if (opcodeOffset == 2) {\\n                // mul\\n                return (a * b, false);\\n            } else if (opcodeOffset == 4) {\\n                // div_u\\n                if (b == 0) {\\n                    return (0, true);\\n                }\\n                return (a / b, false);\\n            } else if (opcodeOffset == 6) {\\n                // rem_u\\n                if (b == 0) {\\n                    return (0, true);\\n                }\\n                return (a % b, false);\\n            } else if (opcodeOffset == 7) {\\n                // and\\n                return (a & b, false);\\n            } else if (opcodeOffset == 8) {\\n                // or\\n                return (a | b, false);\\n            } else if (opcodeOffset == 9) {\\n                // xor\\n                return (a ^ b, false);\\n            } else {\\n                revert(\\\"INVALID_GENERIC_BIN_OP\\\");\\n            }\\n        }\\n    }\\n\\n    function executeI32BinOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 b = mach.valueStack.pop().assumeI32();\\n        uint32 a = mach.valueStack.pop().assumeI32();\\n        uint32 res;\\n\\n        uint16 opcodeOffset = inst.opcode - Instructions.I32_ADD;\\n\\n        unchecked {\\n            if (opcodeOffset == 3) {\\n                // div_s\\n                if (b == 0 || (int32(a) == -2147483648 && int32(b) == -1)) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n                res = uint32(int32(a) / int32(b));\\n            } else if (opcodeOffset == 5) {\\n                // rem_s\\n                if (b == 0) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n                res = uint32(int32(a) % int32(b));\\n            } else if (opcodeOffset == 10) {\\n                // shl\\n                res = a << (b % 32);\\n            } else if (opcodeOffset == 12) {\\n                // shr_u\\n                res = a >> (b % 32);\\n            } else if (opcodeOffset == 11) {\\n                // shr_s\\n                res = uint32(int32(a) >> (b % 32));\\n            } else if (opcodeOffset == 13) {\\n                // rotl\\n                res = rotl32(a, b);\\n            } else if (opcodeOffset == 14) {\\n                // rotr\\n                res = rotr32(a, b);\\n            } else {\\n                (uint64 computed, bool err) = genericBinOp(a, b, opcodeOffset);\\n                if (err) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n                res = uint32(computed);\\n            }\\n        }\\n\\n        mach.valueStack.push(ValueLib.newI32(res));\\n    }\\n\\n    function executeI64BinOp(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint64 b = mach.valueStack.pop().assumeI64();\\n        uint64 a = mach.valueStack.pop().assumeI64();\\n        uint64 res;\\n\\n        uint16 opcodeOffset = inst.opcode - Instructions.I64_ADD;\\n\\n        unchecked {\\n            if (opcodeOffset == 3) {\\n                // div_s\\n                if (b == 0 || (int64(a) == -9223372036854775808 && int64(b) == -1)) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n                res = uint64(int64(a) / int64(b));\\n            } else if (opcodeOffset == 5) {\\n                // rem_s\\n                if (b == 0) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n                res = uint64(int64(a) % int64(b));\\n            } else if (opcodeOffset == 10) {\\n                // shl\\n                res = a << (b % 64);\\n            } else if (opcodeOffset == 12) {\\n                // shr_u\\n                res = a >> (b % 64);\\n            } else if (opcodeOffset == 11) {\\n                // shr_s\\n                res = uint64(int64(a) >> (b % 64));\\n            } else if (opcodeOffset == 13) {\\n                // rotl\\n                res = rotl64(a, b);\\n            } else if (opcodeOffset == 14) {\\n                // rotr\\n                res = rotr64(a, b);\\n            } else {\\n                bool err;\\n                (res, err) = genericBinOp(a, b, opcodeOffset);\\n                if (err) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n            }\\n        }\\n\\n        mach.valueStack.push(ValueLib.newI64(res));\\n    }\\n\\n    function executeI32WrapI64(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        uint64 a = mach.valueStack.pop().assumeI64();\\n\\n        uint32 a32 = uint32(a);\\n\\n        mach.valueStack.push(ValueLib.newI32(a32));\\n    }\\n\\n    function executeI64ExtendI32(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 a = mach.valueStack.pop().assumeI32();\\n\\n        uint64 a64;\\n\\n        if (inst.opcode == Instructions.I64_EXTEND_I32_S) {\\n            a64 = signExtend(a);\\n        } else {\\n            a64 = uint64(a);\\n        }\\n\\n        mach.valueStack.push(ValueLib.newI64(a64));\\n    }\\n\\n    function executeExtendSameType(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        ValueType ty;\\n        uint8 sourceBits;\\n        if (inst.opcode == Instructions.I32_EXTEND_8S) {\\n            ty = ValueType.I32;\\n            sourceBits = 8;\\n        } else if (inst.opcode == Instructions.I32_EXTEND_16S) {\\n            ty = ValueType.I32;\\n            sourceBits = 16;\\n        } else if (inst.opcode == Instructions.I64_EXTEND_8S) {\\n            ty = ValueType.I64;\\n            sourceBits = 8;\\n        } else if (inst.opcode == Instructions.I64_EXTEND_16S) {\\n            ty = ValueType.I64;\\n            sourceBits = 16;\\n        } else if (inst.opcode == Instructions.I64_EXTEND_32S) {\\n            ty = ValueType.I64;\\n            sourceBits = 32;\\n        } else {\\n            revert(\\\"INVALID_EXTEND_SAME_TYPE\\\");\\n        }\\n        uint256 resultMask;\\n        if (ty == ValueType.I32) {\\n            resultMask = (1 << 32) - 1;\\n        } else {\\n            resultMask = (1 << 64) - 1;\\n        }\\n        Value memory val = mach.valueStack.pop();\\n        require(val.valueType == ty, \\\"BAD_EXTEND_SAME_TYPE_TYPE\\\");\\n        uint256 sourceMask = (1 << sourceBits) - 1;\\n        val.contents &= sourceMask;\\n        if (val.contents & (1 << (sourceBits - 1)) != 0) {\\n            // Extend sign flag\\n            val.contents |= resultMask & ~sourceMask;\\n        }\\n        mach.valueStack.push(val);\\n    }\\n\\n    function executeReinterpret(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        ValueType destTy;\\n        ValueType sourceTy;\\n        if (inst.opcode == Instructions.I32_REINTERPRET_F32) {\\n            destTy = ValueType.I32;\\n            sourceTy = ValueType.F32;\\n        } else if (inst.opcode == Instructions.I64_REINTERPRET_F64) {\\n            destTy = ValueType.I64;\\n            sourceTy = ValueType.F64;\\n        } else if (inst.opcode == Instructions.F32_REINTERPRET_I32) {\\n            destTy = ValueType.F32;\\n            sourceTy = ValueType.I32;\\n        } else if (inst.opcode == Instructions.F64_REINTERPRET_I64) {\\n            destTy = ValueType.F64;\\n            sourceTy = ValueType.I64;\\n        } else {\\n            revert(\\\"INVALID_REINTERPRET\\\");\\n        }\\n        Value memory val = mach.valueStack.pop();\\n        require(val.valueType == sourceTy, \\\"INVALID_REINTERPRET_TYPE\\\");\\n        val.valueType = destTy;\\n        mach.valueStack.push(val);\\n    }\\n\\n    function executeOneStep(\\n        ExecutionContext calldata,\\n        Machine calldata startMach,\\n        Module calldata startMod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) external pure override returns (Machine memory mach, Module memory mod) {\\n        mach = startMach;\\n        mod = startMod;\\n\\n        uint16 opcode = inst.opcode;\\n\\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\\n            internal\\n            pure impl;\\n        if (opcode == Instructions.I32_EQZ || opcode == Instructions.I64_EQZ) {\\n            impl = executeEqz;\\n        } else if (\\n            opcode >= Instructions.I32_RELOP_BASE &&\\n            opcode <= Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST\\n        ) {\\n            impl = executeI32RelOp;\\n        } else if (\\n            opcode >= Instructions.I32_UNOP_BASE &&\\n            opcode <= Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST\\n        ) {\\n            impl = executeI32UnOp;\\n        } else if (opcode >= Instructions.I32_ADD && opcode <= Instructions.I32_ROTR) {\\n            impl = executeI32BinOp;\\n        } else if (\\n            opcode >= Instructions.I64_RELOP_BASE &&\\n            opcode <= Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST\\n        ) {\\n            impl = executeI64RelOp;\\n        } else if (\\n            opcode >= Instructions.I64_UNOP_BASE &&\\n            opcode <= Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST\\n        ) {\\n            impl = executeI64UnOp;\\n        } else if (opcode >= Instructions.I64_ADD && opcode <= Instructions.I64_ROTR) {\\n            impl = executeI64BinOp;\\n        } else if (opcode == Instructions.I32_WRAP_I64) {\\n            impl = executeI32WrapI64;\\n        } else if (\\n            opcode == Instructions.I64_EXTEND_I32_S || opcode == Instructions.I64_EXTEND_I32_U\\n        ) {\\n            impl = executeI64ExtendI32;\\n        } else if (opcode >= Instructions.I32_EXTEND_8S && opcode <= Instructions.I64_EXTEND_32S) {\\n            impl = executeExtendSameType;\\n        } else if (\\n            opcode >= Instructions.I32_REINTERPRET_F32 && opcode <= Instructions.F64_REINTERPRET_I64\\n        ) {\\n            impl = executeReinterpret;\\n        } else {\\n            revert(\\\"INVALID_OPCODE\\\");\\n        }\\n\\n        impl(mach, mod, inst, proof);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/OneStepProver0.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Value.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Deserialize.sol\\\";\\nimport \\\"./IOneStepProver.sol\\\";\\n\\ncontract OneStepProver0 is IOneStepProver {\\n    using MerkleProofLib for MerkleProof;\\n    using StackFrameLib for StackFrameWindow;\\n    using ValueLib for Value;\\n    using ValueStackLib for ValueStack;\\n\\n    function executeUnreachable(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        mach.status = MachineStatus.ERRORED;\\n    }\\n\\n    function executeNop(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        // :)\\n    }\\n\\n    function executeConstPush(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint16 opcode = inst.opcode;\\n        ValueType ty;\\n        if (opcode == Instructions.I32_CONST) {\\n            ty = ValueType.I32;\\n        } else if (opcode == Instructions.I64_CONST) {\\n            ty = ValueType.I64;\\n        } else if (opcode == Instructions.F32_CONST) {\\n            ty = ValueType.F32;\\n        } else if (opcode == Instructions.F64_CONST) {\\n            ty = ValueType.F64;\\n        } else {\\n            revert(\\\"CONST_PUSH_INVALID_OPCODE\\\");\\n        }\\n\\n        mach.valueStack.push(Value({valueType: ty, contents: uint64(inst.argumentData)}));\\n    }\\n\\n    function executeDrop(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        mach.valueStack.pop();\\n    }\\n\\n    function executeSelect(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 selector = mach.valueStack.pop().assumeI32();\\n        Value memory b = mach.valueStack.pop();\\n        Value memory a = mach.valueStack.pop();\\n\\n        if (selector != 0) {\\n            mach.valueStack.push(a);\\n        } else {\\n            mach.valueStack.push(b);\\n        }\\n    }\\n\\n    function executeReturn(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        StackFrame memory frame = mach.frameStack.pop();\\n        if (frame.returnPc.valueType == ValueType.REF_NULL) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        } else if (frame.returnPc.valueType != ValueType.INTERNAL_REF) {\\n            revert(\\\"INVALID_RETURN_PC_TYPE\\\");\\n        }\\n        uint256 data = frame.returnPc.contents;\\n        uint32 pc = uint32(data);\\n        uint32 func = uint32(data >> 32);\\n        uint32 mod = uint32(data >> 64);\\n        require(data >> 96 == 0, \\\"INVALID_RETURN_PC_DATA\\\");\\n        mach.functionPc = pc;\\n        mach.functionIdx = func;\\n        mach.moduleIdx = mod;\\n    }\\n\\n    function createReturnValue(Machine memory mach) internal pure returns (Value memory) {\\n        uint256 returnData = 0;\\n        returnData |= mach.functionPc;\\n        returnData |= uint256(mach.functionIdx) << 32;\\n        returnData |= uint256(mach.moduleIdx) << 64;\\n        return Value({valueType: ValueType.INTERNAL_REF, contents: returnData});\\n    }\\n\\n    function executeCall(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        // Push the return pc to the stack\\n        mach.valueStack.push(createReturnValue(mach));\\n\\n        // Push caller module info to the stack\\n        StackFrame memory frame = mach.frameStack.peek();\\n        mach.valueStack.push(ValueLib.newI32(frame.callerModule));\\n        mach.valueStack.push(ValueLib.newI32(frame.callerModuleInternals));\\n\\n        // Jump to the target\\n        uint32 idx = uint32(inst.argumentData);\\n        require(idx == inst.argumentData, \\\"BAD_CALL_DATA\\\");\\n        mach.functionIdx = idx;\\n        mach.functionPc = 0;\\n    }\\n\\n    function executeCrossModuleCall(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        // Push the return pc to the stack\\n        mach.valueStack.push(createReturnValue(mach));\\n\\n        // Push caller module info to the stack\\n        mach.valueStack.push(ValueLib.newI32(mach.moduleIdx));\\n        mach.valueStack.push(ValueLib.newI32(mod.internalsOffset));\\n\\n        // Jump to the target\\n        uint32 func = uint32(inst.argumentData);\\n        uint32 module = uint32(inst.argumentData >> 32);\\n        require(inst.argumentData >> 64 == 0, \\\"BAD_CROSS_MODULE_CALL_DATA\\\");\\n        mach.moduleIdx = module;\\n        mach.functionIdx = func;\\n        mach.functionPc = 0;\\n    }\\n\\n    function executeCallerModuleInternalCall(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        // Push the return pc to the stack\\n        mach.valueStack.push(createReturnValue(mach));\\n\\n        // Push caller module info to the stack\\n        mach.valueStack.push(ValueLib.newI32(mach.moduleIdx));\\n        mach.valueStack.push(ValueLib.newI32(mod.internalsOffset));\\n\\n        StackFrame memory frame = mach.frameStack.peek();\\n        if (frame.callerModuleInternals == 0) {\\n            // The caller module has no internals\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        // Jump to the target\\n        uint32 offset = uint32(inst.argumentData);\\n        require(offset == inst.argumentData, \\\"BAD_CALLER_INTERNAL_CALL_DATA\\\");\\n        mach.moduleIdx = frame.callerModule;\\n        mach.functionIdx = frame.callerModuleInternals + offset;\\n        mach.functionPc = 0;\\n    }\\n\\n    function executeCallIndirect(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        uint32 funcIdx;\\n        {\\n            uint32 elementIdx = mach.valueStack.pop().assumeI32();\\n\\n            // Prove metadata about the instruction and tables\\n            bytes32 elemsRoot;\\n            bytes32 wantedFuncTypeHash;\\n            uint256 offset = 0;\\n            {\\n                uint64 tableIdx;\\n                uint8 tableType;\\n                uint64 tableSize;\\n                MerkleProof memory tableMerkleProof;\\n                (tableIdx, offset) = Deserialize.u64(proof, offset);\\n                (wantedFuncTypeHash, offset) = Deserialize.b32(proof, offset);\\n                (tableType, offset) = Deserialize.u8(proof, offset);\\n                (tableSize, offset) = Deserialize.u64(proof, offset);\\n                (elemsRoot, offset) = Deserialize.b32(proof, offset);\\n                (tableMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\\n\\n                // Validate the information by recomputing known hashes\\n                bytes32 recomputed = keccak256(\\n                    abi.encodePacked(\\\"Call indirect:\\\", tableIdx, wantedFuncTypeHash)\\n                );\\n                require(recomputed == bytes32(inst.argumentData), \\\"BAD_CALL_INDIRECT_DATA\\\");\\n                recomputed = tableMerkleProof.computeRootFromTable(\\n                    tableIdx,\\n                    tableType,\\n                    tableSize,\\n                    elemsRoot\\n                );\\n                require(recomputed == mod.tablesMerkleRoot, \\\"BAD_TABLES_ROOT\\\");\\n\\n                // Check if the table access is out of bounds\\n                if (elementIdx >= tableSize) {\\n                    mach.status = MachineStatus.ERRORED;\\n                    return;\\n                }\\n            }\\n\\n            bytes32 elemFuncTypeHash;\\n            Value memory functionPointer;\\n            MerkleProof memory elementMerkleProof;\\n            (elemFuncTypeHash, offset) = Deserialize.b32(proof, offset);\\n            (functionPointer, offset) = Deserialize.value(proof, offset);\\n            (elementMerkleProof, offset) = Deserialize.merkleProof(proof, offset);\\n            bytes32 recomputedElemRoot = elementMerkleProof.computeRootFromElement(\\n                elementIdx,\\n                elemFuncTypeHash,\\n                functionPointer\\n            );\\n            require(recomputedElemRoot == elemsRoot, \\\"BAD_ELEMENTS_ROOT\\\");\\n\\n            if (elemFuncTypeHash != wantedFuncTypeHash) {\\n                mach.status = MachineStatus.ERRORED;\\n                return;\\n            }\\n\\n            if (functionPointer.valueType == ValueType.REF_NULL) {\\n                mach.status = MachineStatus.ERRORED;\\n                return;\\n            } else if (functionPointer.valueType == ValueType.FUNC_REF) {\\n                funcIdx = uint32(functionPointer.contents);\\n                require(funcIdx == functionPointer.contents, \\\"BAD_FUNC_REF_CONTENTS\\\");\\n            } else {\\n                revert(\\\"BAD_ELEM_TYPE\\\");\\n            }\\n        }\\n\\n        // Push the return pc to the stack\\n        mach.valueStack.push(createReturnValue(mach));\\n\\n        // Push caller module info to the stack\\n        StackFrame memory frame = mach.frameStack.peek();\\n        mach.valueStack.push(ValueLib.newI32(frame.callerModule));\\n        mach.valueStack.push(ValueLib.newI32(frame.callerModuleInternals));\\n\\n        // Jump to the target\\n        mach.functionIdx = funcIdx;\\n        mach.functionPc = 0;\\n    }\\n\\n    function executeArbitraryJump(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        // Jump to target\\n        uint32 pc = uint32(inst.argumentData);\\n        require(pc == inst.argumentData, \\\"BAD_CALL_DATA\\\");\\n        mach.functionPc = pc;\\n    }\\n\\n    function executeArbitraryJumpIf(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        uint32 cond = mach.valueStack.pop().assumeI32();\\n        if (cond != 0) {\\n            // Jump to target\\n            uint32 pc = uint32(inst.argumentData);\\n            require(pc == inst.argumentData, \\\"BAD_CALL_DATA\\\");\\n            mach.functionPc = pc;\\n        }\\n    }\\n\\n    function merkleProveGetValue(\\n        bytes32 merkleRoot,\\n        uint256 index,\\n        bytes calldata proof\\n    ) internal pure returns (Value memory) {\\n        uint256 offset = 0;\\n        Value memory proposedVal;\\n        MerkleProof memory merkle;\\n        (proposedVal, offset) = Deserialize.value(proof, offset);\\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\\n        bytes32 recomputedRoot = merkle.computeRootFromValue(index, proposedVal);\\n        require(recomputedRoot == merkleRoot, \\\"WRONG_MERKLE_ROOT\\\");\\n        return proposedVal;\\n    }\\n\\n    function merkleProveSetValue(\\n        bytes32 merkleRoot,\\n        uint256 index,\\n        Value memory newVal,\\n        bytes calldata proof\\n    ) internal pure returns (bytes32) {\\n        Value memory oldVal;\\n        uint256 offset = 0;\\n        MerkleProof memory merkle;\\n        (oldVal, offset) = Deserialize.value(proof, offset);\\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\\n        bytes32 recomputedRoot = merkle.computeRootFromValue(index, oldVal);\\n        require(recomputedRoot == merkleRoot, \\\"WRONG_MERKLE_ROOT\\\");\\n        return merkle.computeRootFromValue(index, newVal);\\n    }\\n\\n    function executeLocalGet(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        StackFrame memory frame = mach.frameStack.peek();\\n        Value memory val = merkleProveGetValue(frame.localsMerkleRoot, inst.argumentData, proof);\\n        mach.valueStack.push(val);\\n    }\\n\\n    function executeLocalSet(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        Value memory newVal = mach.valueStack.pop();\\n        StackFrame memory frame = mach.frameStack.peek();\\n        frame.localsMerkleRoot = merkleProveSetValue(\\n            frame.localsMerkleRoot,\\n            inst.argumentData,\\n            newVal,\\n            proof\\n        );\\n    }\\n\\n    function executeGlobalGet(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        Value memory val = merkleProveGetValue(mod.globalsMerkleRoot, inst.argumentData, proof);\\n        mach.valueStack.push(val);\\n    }\\n\\n    function executeGlobalSet(\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        Value memory newVal = mach.valueStack.pop();\\n        mod.globalsMerkleRoot = merkleProveSetValue(\\n            mod.globalsMerkleRoot,\\n            inst.argumentData,\\n            newVal,\\n            proof\\n        );\\n    }\\n\\n    function executeInitFrame(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        Value memory callerModuleInternals = mach.valueStack.pop();\\n        Value memory callerModule = mach.valueStack.pop();\\n        Value memory returnPc = mach.valueStack.pop();\\n        StackFrame memory newFrame = StackFrame({\\n            returnPc: returnPc,\\n            localsMerkleRoot: bytes32(inst.argumentData),\\n            callerModule: callerModule.assumeI32(),\\n            callerModuleInternals: callerModuleInternals.assumeI32()\\n        });\\n        mach.frameStack.push(newFrame);\\n    }\\n\\n    function executeMoveInternal(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata inst,\\n        bytes calldata\\n    ) internal pure {\\n        Value memory val;\\n        if (inst.opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL) {\\n            val = mach.valueStack.pop();\\n            mach.internalStack.push(val);\\n        } else if (inst.opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK) {\\n            val = mach.internalStack.pop();\\n            mach.valueStack.push(val);\\n        } else {\\n            revert(\\\"MOVE_INTERNAL_INVALID_OPCODE\\\");\\n        }\\n    }\\n\\n    function executeDup(\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        Value memory val = mach.valueStack.peek();\\n        mach.valueStack.push(val);\\n    }\\n\\n    function executeOneStep(\\n        ExecutionContext calldata,\\n        Machine calldata startMach,\\n        Module calldata startMod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) external pure override returns (Machine memory mach, Module memory mod) {\\n        mach = startMach;\\n        mod = startMod;\\n\\n        uint16 opcode = inst.opcode;\\n\\n        function(Machine memory, Module memory, Instruction calldata, bytes calldata)\\n            internal\\n            pure impl;\\n        if (opcode == Instructions.UNREACHABLE) {\\n            impl = executeUnreachable;\\n        } else if (opcode == Instructions.NOP) {\\n            impl = executeNop;\\n        } else if (opcode == Instructions.RETURN) {\\n            impl = executeReturn;\\n        } else if (opcode == Instructions.CALL) {\\n            impl = executeCall;\\n        } else if (opcode == Instructions.CROSS_MODULE_CALL) {\\n            impl = executeCrossModuleCall;\\n        } else if (opcode == Instructions.CALLER_MODULE_INTERNAL_CALL) {\\n            impl = executeCallerModuleInternalCall;\\n        } else if (opcode == Instructions.CALL_INDIRECT) {\\n            impl = executeCallIndirect;\\n        } else if (opcode == Instructions.ARBITRARY_JUMP) {\\n            impl = executeArbitraryJump;\\n        } else if (opcode == Instructions.ARBITRARY_JUMP_IF) {\\n            impl = executeArbitraryJumpIf;\\n        } else if (opcode == Instructions.LOCAL_GET) {\\n            impl = executeLocalGet;\\n        } else if (opcode == Instructions.LOCAL_SET) {\\n            impl = executeLocalSet;\\n        } else if (opcode == Instructions.GLOBAL_GET) {\\n            impl = executeGlobalGet;\\n        } else if (opcode == Instructions.GLOBAL_SET) {\\n            impl = executeGlobalSet;\\n        } else if (opcode == Instructions.INIT_FRAME) {\\n            impl = executeInitFrame;\\n        } else if (opcode == Instructions.DROP) {\\n            impl = executeDrop;\\n        } else if (opcode == Instructions.SELECT) {\\n            impl = executeSelect;\\n        } else if (opcode >= Instructions.I32_CONST && opcode <= Instructions.F64_CONST) {\\n            impl = executeConstPush;\\n        } else if (\\n            opcode == Instructions.MOVE_FROM_STACK_TO_INTERNAL ||\\n            opcode == Instructions.MOVE_FROM_INTERNAL_TO_STACK\\n        ) {\\n            impl = executeMoveInternal;\\n        } else if (opcode == Instructions.DUP) {\\n            impl = executeDup;\\n        } else {\\n            revert(\\\"INVALID_OPCODE\\\");\\n        }\\n\\n        impl(mach, mod, inst, proof);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/OneStepProverHostIo.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Value.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Deserialize.sol\\\";\\nimport \\\"./IOneStepProver.sol\\\";\\nimport \\\"../bridge/Messages.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ncontract OneStepProverHostIo is IOneStepProver {\\n    using GlobalStateLib for GlobalState;\\n    using MerkleProofLib for MerkleProof;\\n    using ModuleMemoryLib for ModuleMemory;\\n    using ValueLib for Value;\\n    using ValueStackLib for ValueStack;\\n\\n    uint256 private constant LEAF_SIZE = 32;\\n    uint256 private constant INBOX_NUM = 2;\\n    uint64 private constant INBOX_HEADER_LEN = 40;\\n    uint64 private constant DELAYED_HEADER_LEN = 112 + 1;\\n\\n    function setLeafByte(\\n        bytes32 oldLeaf,\\n        uint256 idx,\\n        uint8 val\\n    ) internal pure returns (bytes32) {\\n        require(idx < LEAF_SIZE, \\\"BAD_SET_LEAF_BYTE_IDX\\\");\\n        // Take into account that we are casting the leaf to a big-endian integer\\n        uint256 leafShift = (LEAF_SIZE - 1 - idx) * 8;\\n        uint256 newLeaf = uint256(oldLeaf);\\n        newLeaf &= ~(0xFF << leafShift);\\n        newLeaf |= uint256(val) << leafShift;\\n        return bytes32(newLeaf);\\n    }\\n\\n    function executeGetOrSetBytes32(\\n        Machine memory mach,\\n        Module memory mod,\\n        GlobalState memory state,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        uint256 ptr = mach.valueStack.pop().assumeI32();\\n        uint32 idx = mach.valueStack.pop().assumeI32();\\n\\n        if (idx >= GlobalStateLib.BYTES32_VALS_NUM) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        uint256 leafIdx = ptr / LEAF_SIZE;\\n        uint256 proofOffset = 0;\\n        bytes32 startLeafContents;\\n        MerkleProof memory merkleProof;\\n        (startLeafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\\n            leafIdx,\\n            proof,\\n            proofOffset\\n        );\\n\\n        if (inst.opcode == Instructions.GET_GLOBAL_STATE_BYTES32) {\\n            mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(\\n                leafIdx,\\n                state.bytes32Vals[idx]\\n            );\\n        } else if (inst.opcode == Instructions.SET_GLOBAL_STATE_BYTES32) {\\n            state.bytes32Vals[idx] = startLeafContents;\\n        } else {\\n            revert(\\\"BAD_GLOBAL_STATE_OPCODE\\\");\\n        }\\n    }\\n\\n    function executeGetU64(Machine memory mach, GlobalState memory state) internal pure {\\n        uint32 idx = mach.valueStack.pop().assumeI32();\\n\\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        mach.valueStack.push(ValueLib.newI64(state.u64Vals[idx]));\\n    }\\n\\n    function executeSetU64(Machine memory mach, GlobalState memory state) internal pure {\\n        uint64 val = mach.valueStack.pop().assumeI64();\\n        uint32 idx = mach.valueStack.pop().assumeI32();\\n\\n        if (idx >= GlobalStateLib.U64_VALS_NUM) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n        state.u64Vals[idx] = val;\\n    }\\n\\n    function executeReadPreImage(\\n        ExecutionContext calldata,\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata,\\n        bytes calldata proof\\n    ) internal pure {\\n        uint256 preimageOffset = mach.valueStack.pop().assumeI32();\\n        uint256 ptr = mach.valueStack.pop().assumeI32();\\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        uint256 leafIdx = ptr / LEAF_SIZE;\\n        uint256 proofOffset = 0;\\n        bytes32 leafContents;\\n        MerkleProof memory merkleProof;\\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\\n            leafIdx,\\n            proof,\\n            proofOffset\\n        );\\n\\n        bytes memory extracted;\\n        uint8 proofType = uint8(proof[proofOffset]);\\n        proofOffset++;\\n        if (proofType == 0) {\\n            bytes calldata preimage = proof[proofOffset:];\\n            require(keccak256(preimage) == leafContents, \\\"BAD_PREIMAGE\\\");\\n\\n            uint256 preimageEnd = preimageOffset + 32;\\n            if (preimageEnd > preimage.length) {\\n                preimageEnd = preimage.length;\\n            }\\n            extracted = preimage[preimageOffset:preimageEnd];\\n        } else {\\n            // TODO: support proving via an authenticated contract\\n            revert(\\\"UNKNOWN_PREIMAGE_PROOF\\\");\\n        }\\n\\n        for (uint256 i = 0; i < extracted.length; i++) {\\n            leafContents = setLeafByte(leafContents, i, uint8(extracted[i]));\\n        }\\n\\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\\n\\n        mach.valueStack.push(ValueLib.newI32(uint32(extracted.length)));\\n    }\\n\\n    function validateSequencerInbox(\\n        ExecutionContext calldata execCtx,\\n        uint64 msgIndex,\\n        bytes calldata message\\n    ) internal view returns (bool) {\\n        require(message.length >= INBOX_HEADER_LEN, \\\"BAD_SEQINBOX_PROOF\\\");\\n\\n        uint64 afterDelayedMsg;\\n        (afterDelayedMsg, ) = Deserialize.u64(message, 32);\\n        bytes32 messageHash = keccak256(message);\\n        bytes32 beforeAcc;\\n        bytes32 delayedAcc;\\n\\n        if (msgIndex > 0) {\\n            beforeAcc = execCtx.bridge.sequencerInboxAccs(msgIndex - 1);\\n        }\\n        if (afterDelayedMsg > 0) {\\n            delayedAcc = execCtx.bridge.delayedInboxAccs(afterDelayedMsg - 1);\\n        }\\n        bytes32 acc = keccak256(abi.encodePacked(beforeAcc, messageHash, delayedAcc));\\n        require(acc == execCtx.bridge.sequencerInboxAccs(msgIndex), \\\"BAD_SEQINBOX_MESSAGE\\\");\\n        return true;\\n    }\\n\\n    function validateDelayedInbox(\\n        ExecutionContext calldata execCtx,\\n        uint64 msgIndex,\\n        bytes calldata message\\n    ) internal view returns (bool) {\\n        require(message.length >= DELAYED_HEADER_LEN, \\\"BAD_DELAYED_PROOF\\\");\\n\\n        bytes32 beforeAcc;\\n\\n        if (msgIndex > 0) {\\n            beforeAcc = execCtx.bridge.delayedInboxAccs(msgIndex - 1);\\n        }\\n\\n        bytes32 messageDataHash = keccak256(message[DELAYED_HEADER_LEN:]);\\n        bytes1 kind = message[0];\\n        uint256 sender;\\n        (sender, ) = Deserialize.u256(message, 1);\\n\\n        bytes32 messageHash = keccak256(\\n            abi.encodePacked(kind, uint160(sender), message[33:DELAYED_HEADER_LEN], messageDataHash)\\n        );\\n        bytes32 acc = Messages.accumulateInboxMessage(beforeAcc, messageHash);\\n\\n        require(acc == execCtx.bridge.delayedInboxAccs(msgIndex), \\\"BAD_DELAYED_MESSAGE\\\");\\n        return true;\\n    }\\n\\n    function executeReadInboxMessage(\\n        ExecutionContext calldata execCtx,\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal view {\\n        uint256 messageOffset = mach.valueStack.pop().assumeI32();\\n        uint256 ptr = mach.valueStack.pop().assumeI32();\\n        uint256 msgIndex = mach.valueStack.pop().assumeI64();\\n        if (\\n            inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER &&\\n            msgIndex >= execCtx.maxInboxMessagesRead\\n        ) {\\n            mach.status = MachineStatus.TOO_FAR;\\n            return;\\n        }\\n\\n        if (ptr + 32 > mod.moduleMemory.size || ptr % LEAF_SIZE != 0) {\\n            mach.status = MachineStatus.ERRORED;\\n            return;\\n        }\\n\\n        uint256 leafIdx = ptr / LEAF_SIZE;\\n        uint256 proofOffset = 0;\\n        bytes32 leafContents;\\n        MerkleProof memory merkleProof;\\n        (leafContents, proofOffset, merkleProof) = mod.moduleMemory.proveLeaf(\\n            leafIdx,\\n            proof,\\n            proofOffset\\n        );\\n\\n        {\\n            // TODO: support proving via an authenticated contract\\n            require(proof[proofOffset] == 0, \\\"UNKNOWN_INBOX_PROOF\\\");\\n            proofOffset++;\\n\\n            function(ExecutionContext calldata, uint64, bytes calldata)\\n                internal\\n                view\\n                returns (bool) inboxValidate;\\n\\n            bool success;\\n            if (inst.argumentData == Instructions.INBOX_INDEX_SEQUENCER) {\\n                inboxValidate = validateSequencerInbox;\\n            } else if (inst.argumentData == Instructions.INBOX_INDEX_DELAYED) {\\n                inboxValidate = validateDelayedInbox;\\n            } else {\\n                mach.status = MachineStatus.ERRORED;\\n                return;\\n            }\\n            success = inboxValidate(execCtx, uint64(msgIndex), proof[proofOffset:]);\\n            if (!success) {\\n                mach.status = MachineStatus.ERRORED;\\n                return;\\n            }\\n        }\\n\\n        require(proof.length >= proofOffset, \\\"BAD_MESSAGE_PROOF\\\");\\n        uint256 messageLength = proof.length - proofOffset;\\n\\n        uint32 i = 0;\\n        for (; i < 32 && messageOffset + i < messageLength; i++) {\\n            leafContents = setLeafByte(\\n                leafContents,\\n                i,\\n                uint8(proof[proofOffset + messageOffset + i])\\n            );\\n        }\\n\\n        mod.moduleMemory.merkleRoot = merkleProof.computeRootFromMemory(leafIdx, leafContents);\\n        mach.valueStack.push(ValueLib.newI32(i));\\n    }\\n\\n    function executeHaltAndSetFinished(\\n        ExecutionContext calldata,\\n        Machine memory mach,\\n        Module memory,\\n        Instruction calldata,\\n        bytes calldata\\n    ) internal pure {\\n        mach.status = MachineStatus.FINISHED;\\n    }\\n\\n    function executeGlobalStateAccess(\\n        ExecutionContext calldata,\\n        Machine memory mach,\\n        Module memory mod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) internal pure {\\n        uint16 opcode = inst.opcode;\\n\\n        GlobalState memory state;\\n        uint256 proofOffset = 0;\\n        (state, proofOffset) = Deserialize.globalState(proof, proofOffset);\\n        require(state.hash() == mach.globalStateHash, \\\"BAD_GLOBAL_STATE\\\");\\n\\n        if (\\n            opcode == Instructions.GET_GLOBAL_STATE_BYTES32 ||\\n            opcode == Instructions.SET_GLOBAL_STATE_BYTES32\\n        ) {\\n            executeGetOrSetBytes32(mach, mod, state, inst, proof[proofOffset:]);\\n        } else if (opcode == Instructions.GET_GLOBAL_STATE_U64) {\\n            executeGetU64(mach, state);\\n        } else if (opcode == Instructions.SET_GLOBAL_STATE_U64) {\\n            executeSetU64(mach, state);\\n        } else {\\n            revert(\\\"INVALID_GLOBALSTATE_OPCODE\\\");\\n        }\\n\\n        mach.globalStateHash = state.hash();\\n    }\\n\\n    function executeOneStep(\\n        ExecutionContext calldata execCtx,\\n        Machine calldata startMach,\\n        Module calldata startMod,\\n        Instruction calldata inst,\\n        bytes calldata proof\\n    ) external view override returns (Machine memory mach, Module memory mod) {\\n        mach = startMach;\\n        mod = startMod;\\n\\n        uint16 opcode = inst.opcode;\\n\\n        function(\\n            ExecutionContext calldata,\\n            Machine memory,\\n            Module memory,\\n            Instruction calldata,\\n            bytes calldata\\n        ) internal view impl;\\n\\n        if (\\n            opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\\n            opcode <= Instructions.SET_GLOBAL_STATE_U64\\n        ) {\\n            impl = executeGlobalStateAccess;\\n        } else if (opcode == Instructions.READ_PRE_IMAGE) {\\n            impl = executeReadPreImage;\\n        } else if (opcode == Instructions.READ_INBOX_MESSAGE) {\\n            impl = executeReadInboxMessage;\\n        } else if (opcode == Instructions.HALT_AND_SET_FINISHED) {\\n            impl = executeHaltAndSetFinished;\\n        } else {\\n            revert(\\\"INVALID_MEMORY_OPCODE\\\");\\n        }\\n\\n        impl(execCtx, mach, mod, inst, proof);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/test-helpers/OutboxWithoutOptTester.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../libraries/MerkleLib.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\ncontract OutboxWithoutOptTester is DelegateCallAware, IOutbox {\\n    address public rollup; // the rollup contract\\n    IBridge public bridge; // the bridge contract\\n\\n    mapping(uint256 => bool) public spent; // maps leaf number => if spent\\n    mapping(bytes32 => bytes32) public roots; // maps root hashes => L2 block hash\\n\\n    struct L2ToL1Context {\\n        uint128 l2Block;\\n        uint128 l1Block;\\n        uint128 timestamp;\\n        bytes32 outputId;\\n        address sender;\\n    }\\n    // Note, these variables are set and then wiped during a single transaction.\\n    // Therefore their values don't need to be maintained, and their slots will\\n    // be empty outside of transactions\\n    L2ToL1Context internal context;\\n    uint128 public constant OUTBOX_VERSION = 2;\\n\\n    function initialize(IBridge _bridge) external {\\n        if (address(bridge) != address(0)) revert AlreadyInit();\\n        bridge = _bridge;\\n        rollup = address(_bridge.rollup());\\n    }\\n\\n    function updateSendRoot(bytes32 root, bytes32 l2BlockHash) external override {\\n        //if (msg.sender != rollup) revert NotRollup(msg.sender, rollup);  //test only!!!\\n        roots[root] = l2BlockHash;\\n        emit SendRootUpdated(root, l2BlockHash);\\n    }\\n\\n    /// @notice When l2ToL1Sender returns a nonzero address, the message was originated by an L2 account\\n    /// When the return value is zero, that means this is a system message\\n    /// @dev the l2ToL1Sender behaves as the tx.origin, the msg.sender should be validated to protect against reentrancies\\n    function l2ToL1Sender() external view override returns (address) {\\n        return context.sender;\\n    }\\n\\n    function l2ToL1Block() external view override returns (uint256) {\\n        return uint256(context.l2Block);\\n    }\\n\\n    function l2ToL1EthBlock() external view override returns (uint256) {\\n        return uint256(context.l1Block);\\n    }\\n\\n    function l2ToL1Timestamp() external view override returns (uint256) {\\n        return uint256(context.timestamp);\\n    }\\n\\n    // @deprecated batch number is now always 0\\n    function l2ToL1BatchNum() external pure override returns (uint256) {\\n        return 0;\\n    }\\n\\n    function l2ToL1OutputId() external view override returns (bytes32) {\\n        return context.outputId;\\n    }\\n\\n    /**\\n     * @notice Executes a messages in an Outbox entry.\\n     * @dev Reverts if dispute period hasn't expired, since the outbox entry\\n     * is only created once the rollup confirms the respective assertion.\\n     * @param proof Merkle proof of message inclusion in send root\\n     * @param index Merkle path to message\\n     * @param l2Sender sender if original message (i.e., caller of ArbSys.sendTxToL1)\\n     * @param to destination address for L1 contract call\\n     * @param l2Block l2 block number at which sendTxToL1 call was made\\n     * @param l1Block l1 block number at which sendTxToL1 call was made\\n     * @param l2Timestamp l2 Timestamp at which sendTxToL1 call was made\\n     * @param value wei in L1 message\\n     * @param data abi-encoded L1 message data\\n     */\\n    function executeTransaction(\\n        bytes32[] calldata proof,\\n        uint256 index,\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) external virtual {\\n        bytes32 outputId;\\n        {\\n            bytes32 userTx = calculateItemHash(\\n                l2Sender,\\n                to,\\n                l2Block,\\n                l1Block,\\n                l2Timestamp,\\n                value,\\n                data\\n            );\\n\\n            outputId = recordOutputAsSpent(proof, index, userTx);\\n            emit OutBoxTransactionExecuted(to, l2Sender, 0, index);\\n        }\\n\\n        // we temporarily store the previous values so the outbox can naturally\\n        // unwind itself when there are nested calls to `executeTransaction`\\n        L2ToL1Context memory prevContext = context;\\n\\n        context = L2ToL1Context({\\n            sender: l2Sender,\\n            l2Block: uint128(l2Block),\\n            l1Block: uint128(l1Block),\\n            timestamp: uint128(l2Timestamp),\\n            outputId: outputId\\n        });\\n\\n        // set and reset vars around execution so they remain valid during call\\n        executeBridgeCall(to, value, data);\\n\\n        context = prevContext;\\n    }\\n\\n    function recordOutputAsSpent(\\n        bytes32[] memory proof,\\n        uint256 index,\\n        bytes32 item\\n    ) internal returns (bytes32) {\\n        if (proof.length >= 256) revert ProofTooLong(proof.length);\\n        if (index >= 2**proof.length) revert PathNotMinimal(index, 2**proof.length);\\n\\n        // Hash the leaf an extra time to prove it's a leaf\\n        bytes32 calcRoot = calculateMerkleRoot(proof, index, item);\\n        if (roots[calcRoot] == bytes32(0)) revert UnknownRoot(calcRoot);\\n\\n        if (spent[index]) revert AlreadySpent(index);\\n        spent[index] = true;\\n\\n        return bytes32(index);\\n    }\\n\\n    function executeBridgeCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        (bool success, bytes memory returndata) = bridge.executeCall(to, value, data);\\n        if (!success) {\\n            if (returndata.length > 0) {\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert BridgeCallFailed();\\n            }\\n        }\\n    }\\n\\n    function calculateItemHash(\\n        address l2Sender,\\n        address to,\\n        uint256 l2Block,\\n        uint256 l1Block,\\n        uint256 l2Timestamp,\\n        uint256 value,\\n        bytes calldata data\\n    ) public pure returns (bytes32) {\\n        return\\n            keccak256(abi.encodePacked(l2Sender, to, l2Block, l1Block, l2Timestamp, value, data));\\n    }\\n\\n    function calculateMerkleRoot(\\n        bytes32[] memory proof,\\n        uint256 path,\\n        bytes32 item\\n    ) public pure returns (bytes32) {\\n        return MerkleLib.calculateRoot(proof, path, keccak256(abi.encodePacked(item)));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/test-helpers/BridgeTester.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/Messages.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\n\\n/**\\n * @title Staging ground for incoming and outgoing messages\\n * @notice Holds the inbox accumulator for delayed messages, and is the ETH escrow\\n * for value sent with these messages.\\n * Since the escrow is held here, this contract also contains a list of allowed\\n * outboxes that can make calls from here and withdraw this escrow.\\n */\\ncontract BridgeTester is Initializable, DelegateCallAware, IBridge {\\n    using AddressUpgradeable for address;\\n\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedInboxesMap;\\n    mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedDelayedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address private _activeOutbox;\\n\\n    IOwnable public rollup;\\n    address public sequencerInbox;\\n\\n    modifier onlyRollupOrOwner() {\\n        if (msg.sender != address(rollup)) {\\n            address rollupOwner = rollup.owner();\\n            if (msg.sender != rollupOwner) {\\n                revert NotRollupOrOwner(msg.sender, address(rollup), rollupOwner);\\n            }\\n        }\\n        _;\\n    }\\n\\n    function setSequencerInbox(address _sequencerInbox) external override onlyRollupOrOwner {\\n        sequencerInbox = _sequencerInbox;\\n        emit SequencerInboxUpdated(_sequencerInbox);\\n    }\\n\\n    /// @dev Accumulator for delayed inbox messages; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    bytes32[] public override delayedInboxAccs;\\n\\n    bytes32[] public override sequencerInboxAccs;\\n\\n    address private constant EMPTY_ACTIVEOUTBOX = address(type(uint160).max);\\n\\n    function initialize(IOwnable rollup_) external initializer {\\n        _activeOutbox = EMPTY_ACTIVEOUTBOX;\\n        rollup = rollup_;\\n    }\\n\\n    function activeOutbox() public view returns (address) {\\n        if (_activeOutbox == EMPTY_ACTIVEOUTBOX) return address(uint160(0));\\n        return _activeOutbox;\\n    }\\n\\n    function allowedDelayedInboxes(address inbox) external view override returns (bool) {\\n        return allowedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address outbox) external view override returns (bool) {\\n        return allowedOutboxesMap[outbox].allowed;\\n    }\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        // TODO: implement stub logic\\n    }\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256)\\n    {\\n        // TODO: implement stub\\n    }\\n\\n    /**\\n     * @dev Enqueue a message in the delayed inbox accumulator.\\n     * These messages are later sequenced in the SequencerInbox, either by the sequencer as\\n     * part of a normal batch, or by force inclusion.\\n     */\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable override returns (uint256) {\\n        if (!allowedInboxesMap[msg.sender].allowed) revert NotDelayedInbox(msg.sender);\\n        return\\n            addMessageToDelayedAccumulator(\\n                kind,\\n                sender,\\n                uint64(block.number),\\n                uint64(block.timestamp), // solhint-disable-line not-rely-on-time\\n                block.basefee,\\n                messageDataHash\\n            );\\n    }\\n\\n    function addMessageToDelayedAccumulator(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 blockTimestamp,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        uint256 count = delayedInboxAccs.length;\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            blockNumber,\\n            blockTimestamp,\\n            count,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = delayedInboxAccs[count - 1];\\n        }\\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\\n        emit MessageDelivered(\\n            count,\\n            prevAcc,\\n            msg.sender,\\n            kind,\\n            sender,\\n            messageDataHash,\\n            baseFeeL1,\\n            blockTimestamp\\n        );\\n        return count;\\n    }\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external override returns (bool success, bytes memory returnData) {\\n        if (!allowedOutboxesMap[msg.sender].allowed) revert NotOutbox(msg.sender);\\n        if (data.length > 0 && !to.isContract()) revert NotContract(to);\\n        address prevOutbox = _activeOutbox;\\n        _activeOutbox = msg.sender;\\n        // We set and reset active outbox around external call so activeOutbox remains valid during call\\n\\n        // We use a low level call here since we want to bubble up whether it succeeded or failed to the caller\\n        // rather than reverting on failure as well as allow contract and non-contract calls\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (success, returnData) = to.call{value: value}(data);\\n        _activeOutbox = prevOutbox;\\n        emit BridgeCallTriggered(msg.sender, to, value, data);\\n    }\\n\\n    function setDelayedInbox(address inbox, bool enabled) external override onlyRollupOrOwner {\\n        InOutInfo storage info = allowedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit InboxToggle(inbox, enabled);\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\\n            allowedDelayedInboxList.push(inbox);\\n        } else {\\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\\n                allowedDelayedInboxList.length - 1\\n            ];\\n            allowedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\\n            allowedDelayedInboxList.pop();\\n            delete allowedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(address outbox, bool enabled) external override onlyRollupOrOwner {\\n        InOutInfo storage info = allowedOutboxesMap[outbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit OutboxToggle(outbox, enabled);\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedOutboxesMap[outbox] = InOutInfo(allowedOutboxList.length, true);\\n            allowedOutboxList.push(outbox);\\n        } else {\\n            allowedOutboxList[info.index] = allowedOutboxList[allowedOutboxList.length - 1];\\n            allowedOutboxesMap[allowedOutboxList[info.index]].index = info.index;\\n            allowedOutboxList.pop();\\n            delete allowedOutboxesMap[outbox];\\n        }\\n    }\\n\\n    function delayedMessageCount() external view override returns (uint256) {\\n        return delayedInboxAccs.length;\\n    }\\n\\n    function sequencerMessageCount() external view override returns (uint256) {\\n        return sequencerInboxAccs.length;\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"src/test-helpers/MessageTester.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/Messages.sol\\\";\\n\\ncontract MessageTester {\\n    function messageHash(\\n        uint8 messageType,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 gasPriceL1,\\n        bytes32 messageDataHash\\n    ) public pure returns (bytes32) {\\n        return\\n            Messages.messageHash(\\n                messageType,\\n                sender,\\n                blockNumber,\\n                timestamp,\\n                inboxSeqNum,\\n                gasPriceL1,\\n                messageDataHash\\n            );\\n    }\\n\\n    function accumulateInboxMessage(bytes32 inbox, bytes32 message) public pure returns (bytes32) {\\n        return Messages.accumulateInboxMessage(inbox, message);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/InboxStub.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\nimport \\\"../bridge/Messages.sol\\\";\\nimport \\\"./BridgeStub.sol\\\";\\nimport {\\n    L2_MSG,\\n    L1MessageType_L2FundedByL1,\\n    L1MessageType_submitRetryableTx,\\n    L2MessageType_unsignedEOATx,\\n    L2MessageType_unsignedContractTx\\n} from \\\"../libraries/MessageTypes.sol\\\";\\n\\ncontract InboxStub is IInbox {\\n    IBridge public override bridge;\\n\\n    bool public paused;\\n\\n    function initialize(IBridge _bridge) external {\\n        require(address(bridge) == address(0), \\\"ALREADY_INIT\\\");\\n        bridge = _bridge;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method is an optimization to avoid having to emit the entirety of the messageData in a log. Instead validators are expected to be able to parse the data from the transaction's input\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2MessageFromOrigin(bytes calldata messageData) external returns (uint256) {\\n        // solhint-disable-next-line avoid-tx-origin\\n        require(msg.sender == tx.origin, \\\"origin only\\\");\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDeliveredFromOrigin(msgNum);\\n        return msgNum;\\n    }\\n\\n    /**\\n     * @notice Send a generic L2 message to the chain\\n     * @dev This method can be used to send any type of message that doesn't require L1 validation\\n     * @param messageData Data of the message being sent\\n     */\\n    function sendL2Message(bytes calldata messageData) external override returns (uint256) {\\n        uint256 msgNum = deliverToBridge(L2_MSG, msg.sender, keccak256(messageData));\\n        emit InboxMessageDelivered(msgNum, messageData);\\n        return msgNum;\\n    }\\n\\n    function deliverToBridge(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        return bridge.enqueueDelayedMessage{value: msg.value}(kind, sender, messageDataHash);\\n    }\\n\\n    function sendUnsignedTransaction(\\n        uint256,\\n        uint256,\\n        uint256,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function sendContractTransaction(\\n        uint256,\\n        uint256,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256,\\n        uint256,\\n        uint256,\\n        address,\\n        bytes calldata\\n    ) external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function sendL1FundedContractTransaction(\\n        uint256,\\n        uint256,\\n        address,\\n        bytes calldata\\n    ) external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function createRetryableTicket(\\n        address,\\n        uint256,\\n        uint256,\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function unsafeCreateRetryableTicket(\\n        address,\\n        uint256,\\n        uint256,\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function depositEth() external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function depositEth(uint256) external payable override returns (uint256) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/BridgeStub.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./InboxStub.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ncontract BridgeStub is IBridge {\\n    struct InOutInfo {\\n        uint256 index;\\n        bool allowed;\\n    }\\n\\n    mapping(address => InOutInfo) private allowedDelayedInboxesMap;\\n    //mapping(address => InOutInfo) private allowedOutboxesMap;\\n\\n    address[] public allowedDelayedInboxList;\\n    address[] public allowedOutboxList;\\n\\n    address public override activeOutbox;\\n\\n    // Accumulator for delayed inbox; tail represents hash of the current state; each element represents the inclusion of a new message.\\n    bytes32[] public override delayedInboxAccs;\\n\\n    bytes32[] public override sequencerInboxAccs;\\n\\n    address public sequencerInbox;\\n\\n    function setSequencerInbox(address _sequencerInbox) external override {\\n        sequencerInbox = _sequencerInbox;\\n        emit SequencerInboxUpdated(_sequencerInbox);\\n    }\\n\\n    function allowedDelayedInboxes(address inbox) external view override returns (bool) {\\n        return allowedDelayedInboxesMap[inbox].allowed;\\n    }\\n\\n    function allowedOutboxes(address) external pure override returns (bool) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable override returns (uint256) {\\n        require(allowedDelayedInboxesMap[msg.sender].allowed, \\\"NOT_FROM_INBOX\\\");\\n        return\\n            addMessageToDelayedAccumulator(\\n                kind,\\n                sender,\\n                block.number,\\n                block.timestamp, // solhint-disable-line not-rely-on-time\\n                block.basefee,\\n                messageDataHash\\n            );\\n    }\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        seqMessageIndex = sequencerInboxAccs.length;\\n        if (sequencerInboxAccs.length > 0) {\\n            beforeAcc = sequencerInboxAccs[sequencerInboxAccs.length - 1];\\n        }\\n        if (afterDelayedMessagesRead > 0) {\\n            delayedAcc = delayedInboxAccs[afterDelayedMessagesRead - 1];\\n        }\\n        acc = keccak256(abi.encodePacked(beforeAcc, dataHash, delayedAcc));\\n        sequencerInboxAccs.push(acc);\\n    }\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256)\\n    {\\n        // TODO: implement stub\\n    }\\n\\n    function addMessageToDelayedAccumulator(\\n        uint8,\\n        address,\\n        uint256,\\n        uint256,\\n        uint256,\\n        bytes32 messageDataHash\\n    ) internal returns (uint256) {\\n        uint256 count = delayedInboxAccs.length;\\n        bytes32 messageHash = Messages.messageHash(\\n            0,\\n            address(uint160(0)),\\n            0,\\n            0,\\n            0,\\n            0,\\n            messageDataHash\\n        );\\n        bytes32 prevAcc = 0;\\n        if (count > 0) {\\n            prevAcc = delayedInboxAccs[count - 1];\\n        }\\n        delayedInboxAccs.push(Messages.accumulateInboxMessage(prevAcc, messageHash));\\n        return count;\\n    }\\n\\n    function executeCall(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external pure override returns (bool, bytes memory) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function setDelayedInbox(address inbox, bool enabled) external override {\\n        InOutInfo storage info = allowedDelayedInboxesMap[inbox];\\n        bool alreadyEnabled = info.allowed;\\n        emit InboxToggle(inbox, enabled);\\n        if ((alreadyEnabled && enabled) || (!alreadyEnabled && !enabled)) {\\n            return;\\n        }\\n        if (enabled) {\\n            allowedDelayedInboxesMap[inbox] = InOutInfo(allowedDelayedInboxList.length, true);\\n            allowedDelayedInboxList.push(inbox);\\n        } else {\\n            allowedDelayedInboxList[info.index] = allowedDelayedInboxList[\\n                allowedDelayedInboxList.length - 1\\n            ];\\n            allowedDelayedInboxesMap[allowedDelayedInboxList[info.index]].index = info.index;\\n            allowedDelayedInboxList.pop();\\n            delete allowedDelayedInboxesMap[inbox];\\n        }\\n    }\\n\\n    function setOutbox(\\n        address, /* outbox */\\n        bool /* enabled*/\\n    ) external pure override {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n\\n    function delayedMessageCount() external view override returns (uint256) {\\n        return delayedInboxAccs.length;\\n    }\\n\\n    function sequencerMessageCount() external view override returns (uint256) {\\n        return sequencerInboxAccs.length;\\n    }\\n\\n    function rollup() external pure override returns (IOwnable) {\\n        revert(\\\"NOT_IMPLEMENTED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/challenge/ChallengeManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport \\\"../osp/IOneStepProofEntry.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"./IChallengeResultReceiver.sol\\\";\\nimport \\\"./ChallengeLib.sol\\\";\\nimport \\\"./IChallengeManager.sol\\\";\\n\\nimport {NO_CHAL_INDEX} from \\\"../libraries/Constants.sol\\\";\\n\\ncontract ChallengeManager is DelegateCallAware, IChallengeManager {\\n    using GlobalStateLib for GlobalState;\\n    using MachineLib for Machine;\\n    using ChallengeLib for ChallengeLib.Challenge;\\n\\n    enum ChallengeModeRequirement {\\n        ANY,\\n        BLOCK,\\n        EXECUTION\\n    }\\n\\n    string private constant NO_CHAL = \\\"NO_CHAL\\\";\\n    uint256 private constant MAX_CHALLENGE_DEGREE = 40;\\n\\n    uint64 public totalChallengesCreated;\\n    mapping(uint256 => ChallengeLib.Challenge) public challenges;\\n\\n    IChallengeResultReceiver public resultReceiver;\\n\\n    ISequencerInbox public sequencerInbox;\\n    IBridge public bridge;\\n    IOneStepProofEntry public osp;\\n\\n    function challengeInfo(uint64 challengeIndex)\\n        external\\n        view\\n        override\\n        returns (ChallengeLib.Challenge memory)\\n    {\\n        return challenges[challengeIndex];\\n    }\\n\\n    modifier takeTurn(\\n        uint64 challengeIndex,\\n        ChallengeLib.SegmentSelection calldata selection,\\n        ChallengeModeRequirement expectedMode\\n    ) {\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        require(msg.sender == currentResponder(challengeIndex), \\\"CHAL_SENDER\\\");\\n        require(!isTimedOut(challengeIndex), \\\"CHAL_DEADLINE\\\");\\n\\n        if (expectedMode == ChallengeModeRequirement.ANY) {\\n            require(challenge.mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\\n        } else if (expectedMode == ChallengeModeRequirement.BLOCK) {\\n            require(challenge.mode == ChallengeLib.ChallengeMode.BLOCK, \\\"CHAL_NOT_BLOCK\\\");\\n        } else if (expectedMode == ChallengeModeRequirement.EXECUTION) {\\n            require(challenge.mode == ChallengeLib.ChallengeMode.EXECUTION, \\\"CHAL_NOT_EXECUTION\\\");\\n        } else {\\n            assert(false);\\n        }\\n\\n        require(\\n            challenge.challengeStateHash ==\\n                ChallengeLib.hashChallengeState(\\n                    selection.oldSegmentsStart,\\n                    selection.oldSegmentsLength,\\n                    selection.oldSegments\\n                ),\\n            \\\"BIS_STATE\\\"\\n        );\\n        if (\\n            selection.oldSegments.length < 2 ||\\n            selection.challengePosition >= selection.oldSegments.length - 1\\n        ) {\\n            revert(\\\"BAD_CHALLENGE_POS\\\");\\n        }\\n\\n        _;\\n\\n        if (challenge.mode == ChallengeLib.ChallengeMode.NONE) {\\n            // Early return since challenge must have terminated\\n            return;\\n        }\\n\\n        ChallengeLib.Participant memory current = challenge.current;\\n        current.timeLeft -= block.timestamp - challenge.lastMoveTimestamp;\\n\\n        challenge.current = challenge.next;\\n        challenge.next = current;\\n\\n        challenge.lastMoveTimestamp = block.timestamp;\\n    }\\n\\n    function initialize(\\n        IChallengeResultReceiver resultReceiver_,\\n        ISequencerInbox sequencerInbox_,\\n        IBridge bridge_,\\n        IOneStepProofEntry osp_\\n    ) external override onlyDelegated {\\n        require(address(resultReceiver) == address(0), \\\"ALREADY_INIT\\\");\\n        require(address(resultReceiver_) != address(0), \\\"NO_RESULT_RECEIVER\\\");\\n        resultReceiver = resultReceiver_;\\n        sequencerInbox = sequencerInbox_;\\n        bridge = bridge_;\\n        osp = osp_;\\n    }\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external override returns (uint64) {\\n        require(msg.sender == address(resultReceiver), \\\"ONLY_ROLLUP_CHAL\\\");\\n        bytes32[] memory segments = new bytes32[](2);\\n        segments[0] = ChallengeLib.blockStateHash(\\n            startAndEndMachineStatuses_[0],\\n            startAndEndGlobalStates_[0].hash()\\n        );\\n        segments[1] = ChallengeLib.blockStateHash(\\n            startAndEndMachineStatuses_[1],\\n            startAndEndGlobalStates_[1].hash()\\n        );\\n\\n        uint64 challengeIndex = ++totalChallengesCreated;\\n        // The following is an assertion since it should never be possible, but it's an important invariant\\n        assert(challengeIndex != NO_CHAL_INDEX);\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        challenge.wasmModuleRoot = wasmModuleRoot_;\\n\\n        // See validator/assertion.go ExecutionState RequiredBatches() for reasoning\\n        uint64 maxInboxMessagesRead = startAndEndGlobalStates_[1].getInboxPosition();\\n        if (\\n            startAndEndMachineStatuses_[1] == MachineStatus.ERRORED ||\\n            startAndEndGlobalStates_[1].getPositionInMessage() > 0\\n        ) {\\n            maxInboxMessagesRead++;\\n        }\\n        challenge.maxInboxMessages = maxInboxMessagesRead;\\n        challenge.next = ChallengeLib.Participant({addr: asserter_, timeLeft: asserterTimeLeft_});\\n        challenge.current = ChallengeLib.Participant({\\n            addr: challenger_,\\n            timeLeft: challengerTimeLeft_\\n        });\\n        challenge.lastMoveTimestamp = block.timestamp;\\n        challenge.mode = ChallengeLib.ChallengeMode.BLOCK;\\n\\n        emit InitiatedChallenge(\\n            challengeIndex,\\n            startAndEndGlobalStates_[0],\\n            startAndEndGlobalStates_[1]\\n        );\\n        completeBisection(challengeIndex, 0, numBlocks, segments);\\n        return challengeIndex;\\n    }\\n\\n    /**\\n     * @notice Initiate the next round in the bisection by objecting to execution correctness with a bisection\\n     * of an execution segment with the same length but a different endpoint. This is either the initial move\\n     * or follows another execution objection\\n     */\\n    function bisectExecution(\\n        uint64 challengeIndex,\\n        ChallengeLib.SegmentSelection calldata selection,\\n        bytes32[] calldata newSegments\\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.ANY) {\\n        (uint256 challengeStart, uint256 challengeLength) = ChallengeLib.extractChallengeSegment(\\n            selection\\n        );\\n        require(challengeLength > 1, \\\"TOO_SHORT\\\");\\n        {\\n            uint256 expectedDegree = challengeLength;\\n            if (expectedDegree > MAX_CHALLENGE_DEGREE) {\\n                expectedDegree = MAX_CHALLENGE_DEGREE;\\n            }\\n            require(newSegments.length == expectedDegree + 1, \\\"WRONG_DEGREE\\\");\\n        }\\n\\n        requireValidBisection(selection, newSegments[0], newSegments[newSegments.length - 1]);\\n\\n        completeBisection(challengeIndex, challengeStart, challengeLength, newSegments);\\n    }\\n\\n    function challengeExecution(\\n        uint64 challengeIndex,\\n        ChallengeLib.SegmentSelection calldata selection,\\n        MachineStatus[2] calldata machineStatuses,\\n        bytes32[2] calldata globalStateHashes,\\n        uint256 numSteps\\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.BLOCK) {\\n        require(numSteps >= 1, \\\"CHALLENGE_TOO_SHORT\\\");\\n        require(numSteps <= OneStepProofEntryLib.MAX_STEPS, \\\"CHALLENGE_TOO_LONG\\\");\\n        requireValidBisection(\\n            selection,\\n            ChallengeLib.blockStateHash(machineStatuses[0], globalStateHashes[0]),\\n            ChallengeLib.blockStateHash(machineStatuses[1], globalStateHashes[1])\\n        );\\n\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        (uint256 executionChallengeAtSteps, uint256 challengeLength) = ChallengeLib\\n            .extractChallengeSegment(selection);\\n        require(challengeLength == 1, \\\"TOO_LONG\\\");\\n\\n        if (machineStatuses[0] != MachineStatus.FINISHED) {\\n            // If the machine is in a halted state, it can't change\\n            require(\\n                machineStatuses[0] == machineStatuses[1] &&\\n                    globalStateHashes[0] == globalStateHashes[1],\\n                \\\"HALTED_CHANGE\\\"\\n            );\\n            _currentWin(challengeIndex, ChallengeTerminationType.BLOCK_PROOF);\\n            return;\\n        }\\n\\n        if (machineStatuses[1] == MachineStatus.ERRORED) {\\n            // If the machine errors, it must return to the previous global state\\n            require(globalStateHashes[0] == globalStateHashes[1], \\\"ERROR_CHANGE\\\");\\n        }\\n\\n        bytes32[] memory segments = new bytes32[](2);\\n        segments[0] = ChallengeLib.getStartMachineHash(\\n            globalStateHashes[0],\\n            challenge.wasmModuleRoot\\n        );\\n        segments[1] = ChallengeLib.getEndMachineHash(machineStatuses[1], globalStateHashes[1]);\\n\\n        challenge.mode = ChallengeLib.ChallengeMode.EXECUTION;\\n\\n        completeBisection(challengeIndex, 0, numSteps, segments);\\n\\n        emit ExecutionChallengeBegun(challengeIndex, executionChallengeAtSteps);\\n    }\\n\\n    function oneStepProveExecution(\\n        uint64 challengeIndex,\\n        ChallengeLib.SegmentSelection calldata selection,\\n        bytes calldata proof\\n    ) external takeTurn(challengeIndex, selection, ChallengeModeRequirement.EXECUTION) {\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        uint256 challengeStart;\\n        {\\n            uint256 challengeLength;\\n            (challengeStart, challengeLength) = ChallengeLib.extractChallengeSegment(selection);\\n            require(challengeLength == 1, \\\"TOO_LONG\\\");\\n        }\\n\\n        bytes32 afterHash = osp.proveOneStep(\\n            ExecutionContext({maxInboxMessagesRead: challenge.maxInboxMessages, bridge: bridge}),\\n            challengeStart,\\n            selection.oldSegments[selection.challengePosition],\\n            proof\\n        );\\n        require(\\n            afterHash != selection.oldSegments[selection.challengePosition + 1],\\n            \\\"SAME_OSP_END\\\"\\n        );\\n\\n        emit OneStepProofCompleted(challengeIndex);\\n        _currentWin(challengeIndex, ChallengeTerminationType.EXECUTION_PROOF);\\n    }\\n\\n    function timeout(uint64 challengeIndex) external override {\\n        require(challenges[challengeIndex].mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\\n        require(isTimedOut(challengeIndex), \\\"TIMEOUT_DEADLINE\\\");\\n        _nextWin(challengeIndex, ChallengeTerminationType.TIMEOUT);\\n    }\\n\\n    function clearChallenge(uint64 challengeIndex) external override {\\n        require(msg.sender == address(resultReceiver), \\\"NOT_RES_RECEIVER\\\");\\n        require(challenges[challengeIndex].mode != ChallengeLib.ChallengeMode.NONE, NO_CHAL);\\n        delete challenges[challengeIndex];\\n        emit ChallengeEnded(challengeIndex, ChallengeTerminationType.CLEARED);\\n    }\\n\\n    function currentResponder(uint64 challengeIndex) public view override returns (address) {\\n        return challenges[challengeIndex].current.addr;\\n    }\\n\\n    function currentResponderTimeLeft(uint64 challengeIndex)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return challenges[challengeIndex].current.timeLeft;\\n    }\\n\\n    function isTimedOut(uint64 challengeIndex) public view override returns (bool) {\\n        return challenges[challengeIndex].isTimedOut();\\n    }\\n\\n    function requireValidBisection(\\n        ChallengeLib.SegmentSelection calldata selection,\\n        bytes32 startHash,\\n        bytes32 endHash\\n    ) private pure {\\n        require(selection.oldSegments[selection.challengePosition] == startHash, \\\"WRONG_START\\\");\\n        require(selection.oldSegments[selection.challengePosition + 1] != endHash, \\\"SAME_END\\\");\\n    }\\n\\n    function completeBisection(\\n        uint64 challengeIndex,\\n        uint256 challengeStart,\\n        uint256 challengeLength,\\n        bytes32[] memory newSegments\\n    ) private {\\n        assert(challengeLength >= 1);\\n        assert(newSegments.length >= 2);\\n\\n        bytes32 challengeStateHash = ChallengeLib.hashChallengeState(\\n            challengeStart,\\n            challengeLength,\\n            newSegments\\n        );\\n        challenges[challengeIndex].challengeStateHash = challengeStateHash;\\n\\n        emit Bisected(\\n            challengeIndex,\\n            challengeStateHash,\\n            challengeStart,\\n            challengeLength,\\n            newSegments\\n        );\\n    }\\n\\n    /// @dev This function causes the mode of the challenge to be set to NONE by deleting the challenge\\n    function _nextWin(uint64 challengeIndex, ChallengeTerminationType reason) private {\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        address next = challenge.next.addr;\\n        address current = challenge.current.addr;\\n        delete challenges[challengeIndex];\\n        resultReceiver.completeChallenge(challengeIndex, next, current);\\n        emit ChallengeEnded(challengeIndex, reason);\\n    }\\n\\n    /**\\n     * @dev this currently sets a challenge hash of 0 - no move is possible for the next participant to progress the\\n     * state. It is assumed that wherever this function is consumed, the turn is then adjusted for the opposite party\\n     * to timeout. This is done as a safety measure so challenges can only be resolved by timeouts during mainnet beta.\\n     */\\n    function _currentWin(\\n        uint64 challengeIndex,\\n        ChallengeTerminationType /* reason */\\n    ) private {\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        challenge.challengeStateHash = bytes32(0);\\n\\n        //        address next = challenge.next.addr;\\n        //        address current = challenge.current.addr;\\n        //        delete challenges[challengeIndex];\\n        //        resultReceiver.completeChallenge(challengeIndex, current, next);\\n        //        emit ChallengeEnded(challengeIndex, reason);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/ExecutionManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../challenge/ChallengeManager.sol\\\";\\n\\ncontract SingleExecutionChallenge is ChallengeManager {\\n    constructor(\\n        IOneStepProofEntry osp_,\\n        IChallengeResultReceiver resultReceiver_,\\n        uint64 maxInboxMessagesRead_,\\n        bytes32[2] memory startAndEndHashes,\\n        uint256 numSteps_,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) {\\n        osp = osp_;\\n        resultReceiver = resultReceiver_;\\n        uint64 challengeIndex = ++totalChallengesCreated;\\n        ChallengeLib.Challenge storage challenge = challenges[challengeIndex];\\n        challenge.maxInboxMessages = maxInboxMessagesRead_;\\n        bytes32[] memory segments = new bytes32[](2);\\n        segments[0] = startAndEndHashes[0];\\n        segments[1] = startAndEndHashes[1];\\n        bytes32 challengeStateHash = ChallengeLib.hashChallengeState(0, numSteps_, segments);\\n        challenge.challengeStateHash = challengeStateHash;\\n        challenge.next = ChallengeLib.Participant({addr: asserter_, timeLeft: asserterTimeLeft_});\\n        challenge.current = ChallengeLib.Participant({\\n            addr: challenger_,\\n            timeLeft: challengerTimeLeft_\\n        });\\n        challenge.lastMoveTimestamp = block.timestamp;\\n        challenge.mode = ChallengeLib.ChallengeMode.EXECUTION;\\n\\n        emit Bisected(challengeIndex, challengeStateHash, 0, numSteps_, segments);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/MockResultReceiver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../challenge/IChallengeResultReceiver.sol\\\";\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\n\\ncontract MockResultReceiver is IChallengeResultReceiver {\\n    IChallengeManager public manager;\\n    address public winner;\\n    address public loser;\\n    uint256 public challengeIndex;\\n\\n    event ChallengeCompleted(\\n        uint256 indexed challengeIndex,\\n        address indexed winner,\\n        address indexed loser\\n    );\\n\\n    constructor(IChallengeManager manager_) {\\n        manager = manager_;\\n    }\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external returns (uint64) {\\n        return\\n            manager.createChallenge(\\n                wasmModuleRoot_,\\n                startAndEndMachineStatuses_,\\n                startAndEndGlobalStates_,\\n                numBlocks,\\n                asserter_,\\n                challenger_,\\n                asserterTimeLeft_,\\n                challengerTimeLeft_\\n            );\\n    }\\n\\n    function completeChallenge(\\n        uint256 challengeIndex_,\\n        address winner_,\\n        address loser_\\n    ) external override {\\n        winner = winner_;\\n        loser = loser_;\\n        challengeIndex = challengeIndex_;\\n        emit ChallengeCompleted(challengeIndex, winner_, loser_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/OneStepProofEntry.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Deserialize.sol\\\";\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/MerkleProof.sol\\\";\\nimport \\\"./IOneStepProver.sol\\\";\\nimport \\\"./IOneStepProofEntry.sol\\\";\\n\\ncontract OneStepProofEntry is IOneStepProofEntry {\\n    using MerkleProofLib for MerkleProof;\\n    using MachineLib for Machine;\\n\\n    IOneStepProver public prover0;\\n    IOneStepProver public proverMem;\\n    IOneStepProver public proverMath;\\n    IOneStepProver public proverHostIo;\\n\\n    constructor(\\n        IOneStepProver prover0_,\\n        IOneStepProver proverMem_,\\n        IOneStepProver proverMath_,\\n        IOneStepProver proverHostIo_\\n    ) {\\n        prover0 = prover0_;\\n        proverMem = proverMem_;\\n        proverMath = proverMath_;\\n        proverHostIo = proverHostIo_;\\n    }\\n\\n    function proveOneStep(\\n        ExecutionContext calldata execCtx,\\n        uint256 machineStep,\\n        bytes32 beforeHash,\\n        bytes calldata proof\\n    ) external view override returns (bytes32 afterHash) {\\n        Machine memory mach;\\n        Module memory mod;\\n        MerkleProof memory modProof;\\n        Instruction memory inst;\\n\\n        {\\n            uint256 offset = 0;\\n            (mach, offset) = Deserialize.machine(proof, offset);\\n            require(mach.hash() == beforeHash, \\\"MACHINE_BEFORE_HASH\\\");\\n            if (mach.status != MachineStatus.RUNNING) {\\n                // Machine is halted.\\n                // WARNING: at this point, most machine fields are unconstrained.\\n                return mach.hash();\\n            }\\n\\n            if (machineStep + 1 == OneStepProofEntryLib.MAX_STEPS) {\\n                mach.status = MachineStatus.ERRORED;\\n                return mach.hash();\\n            }\\n\\n            (mod, offset) = Deserialize.module(proof, offset);\\n            (modProof, offset) = Deserialize.merkleProof(proof, offset);\\n            require(\\n                modProof.computeRootFromModule(mach.moduleIdx, mod) == mach.modulesRoot,\\n                \\\"MODULES_ROOT\\\"\\n            );\\n\\n            {\\n                MerkleProof memory instProof;\\n                MerkleProof memory funcProof;\\n                (inst, offset) = Deserialize.instruction(proof, offset);\\n                (instProof, offset) = Deserialize.merkleProof(proof, offset);\\n                (funcProof, offset) = Deserialize.merkleProof(proof, offset);\\n                bytes32 codeHash = instProof.computeRootFromInstruction(mach.functionPc, inst);\\n                bytes32 recomputedRoot = funcProof.computeRootFromFunction(\\n                    mach.functionIdx,\\n                    codeHash\\n                );\\n                require(recomputedRoot == mod.functionsMerkleRoot, \\\"BAD_FUNCTIONS_ROOT\\\");\\n            }\\n            proof = proof[offset:];\\n        }\\n\\n        uint256 oldModIdx = mach.moduleIdx;\\n        mach.functionPc += 1;\\n        uint16 opcode = inst.opcode;\\n        IOneStepProver prover;\\n        if (\\n            (opcode >= Instructions.I32_LOAD && opcode <= Instructions.I64_LOAD32_U) ||\\n            (opcode >= Instructions.I32_STORE && opcode <= Instructions.I64_STORE32) ||\\n            opcode == Instructions.MEMORY_SIZE ||\\n            opcode == Instructions.MEMORY_GROW\\n        ) {\\n            prover = proverMem;\\n        } else if (\\n            (opcode == Instructions.I32_EQZ || opcode == Instructions.I64_EQZ) ||\\n            (opcode >= Instructions.I32_RELOP_BASE &&\\n                opcode <= Instructions.I32_RELOP_BASE + Instructions.IRELOP_LAST) ||\\n            (opcode >= Instructions.I32_UNOP_BASE &&\\n                opcode <= Instructions.I32_UNOP_BASE + Instructions.IUNOP_LAST) ||\\n            (opcode >= Instructions.I32_ADD && opcode <= Instructions.I32_ROTR) ||\\n            (opcode >= Instructions.I64_RELOP_BASE &&\\n                opcode <= Instructions.I64_RELOP_BASE + Instructions.IRELOP_LAST) ||\\n            (opcode >= Instructions.I64_UNOP_BASE &&\\n                opcode <= Instructions.I64_UNOP_BASE + Instructions.IUNOP_LAST) ||\\n            (opcode >= Instructions.I64_ADD && opcode <= Instructions.I64_ROTR) ||\\n            (opcode == Instructions.I32_WRAP_I64) ||\\n            (opcode == Instructions.I64_EXTEND_I32_S || opcode == Instructions.I64_EXTEND_I32_U) ||\\n            (opcode >= Instructions.I32_EXTEND_8S && opcode <= Instructions.I64_EXTEND_32S) ||\\n            (opcode >= Instructions.I32_REINTERPRET_F32 &&\\n                opcode <= Instructions.F64_REINTERPRET_I64)\\n        ) {\\n            prover = proverMath;\\n        } else if (\\n            (opcode >= Instructions.GET_GLOBAL_STATE_BYTES32 &&\\n                opcode <= Instructions.SET_GLOBAL_STATE_U64) ||\\n            (opcode >= Instructions.READ_PRE_IMAGE && opcode <= Instructions.HALT_AND_SET_FINISHED)\\n        ) {\\n            prover = proverHostIo;\\n        } else {\\n            prover = prover0;\\n        }\\n\\n        (mach, mod) = prover.executeOneStep(execCtx, mach, mod, inst, proof);\\n\\n        mach.modulesRoot = modProof.computeRootFromModule(oldModIdx, mod);\\n\\n        return mach.hash();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/test-helpers/ValueArrayTester.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/ValueArray.sol\\\";\\n\\ncontract ValueArrayTester {\\n    using ValueArrayLib for ValueArray;\\n\\n    function test() external pure {\\n        ValueArray memory arr = ValueArray(new Value[](2));\\n        require(arr.length() == 2, \\\"START_LEN\\\");\\n        arr.set(0, ValueLib.newI32(1));\\n        arr.set(1, ValueLib.newI32(2));\\n        arr.push(ValueLib.newI32(3));\\n        require(arr.length() == 3, \\\"PUSH_LEN\\\");\\n        for (uint256 i = 0; i < arr.length(); i++) {\\n            Value memory val = arr.get(i);\\n            require(val.valueType == ValueType.I32, \\\"PUSH_VAL_TYPE\\\");\\n            require(val.contents == i + 1, \\\"PUSH_VAL_CONTENTS\\\");\\n        }\\n        Value memory popped = arr.pop();\\n        require(popped.valueType == ValueType.I32, \\\"POP_RET_TYPE\\\");\\n        require(popped.contents == 3, \\\"POP_RET_CONTENTS\\\");\\n        require(arr.length() == 2, \\\"POP_LEN\\\");\\n        for (uint256 i = 0; i < arr.length(); i++) {\\n            Value memory val = arr.get(i);\\n            require(val.valueType == ValueType.I32, \\\"POP_VAL_TYPE\\\");\\n            require(val.contents == i + 1, \\\"POP_VAL_CONTENTS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/mocks/SequencerInboxStub.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/SequencerInbox.sol\\\";\\n\\ncontract SequencerInboxStub is SequencerInbox {\\n    constructor(\\n        IBridge bridge_,\\n        address sequencer_,\\n        ISequencerInbox.MaxTimeVariation memory maxTimeVariation_\\n    ) {\\n        bridge = bridge_;\\n        rollup = IOwnable(msg.sender);\\n        maxTimeVariation = maxTimeVariation_;\\n        isBatchPoster[sequencer_] = true;\\n    }\\n\\n    function addInitMessage() external {\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formEmptyDataHash(0);\\n        (\\n            uint256 sequencerMessageCount,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, 0, 0);\\n        emit SequencerBatchDelivered(\\n            sequencerMessageCount,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.NoData\\n        );\\n    }\\n\\n    function getTimeBounds() internal view override returns (TimeBounds memory bounds) {\\n        this; // silence warning about function not being view\\n        return bounds;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sendRoot\",\"type\":\"bytes32\"}],\"name\":\"NodeConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"parentNodeHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"executionHash\",\"type\":\"bytes32\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes32[2]\",\"name\":\"bytes32Vals\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint64[2]\",\"name\":\"u64Vals\",\"type\":\"uint64[2]\"}],\"internalType\":\"struct GlobalState\",\"name\":\"globalState\",\"type\":\"tuple\"},{\"internalType\":\"enum MachineStatus\",\"name\":\"machineStatus\",\"type\":\"uint8\"}],\"internalType\":\"struct RollupLib.ExecutionState\",\"name\":\"beforeState\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32[2]\",\"name\":\"bytes32Vals\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint64[2]\",\"name\":\"u64Vals\",\"type\":\"uint64[2]\"}],\"internalType\":\"struct GlobalState\",\"name\":\"globalState\",\"type\":\"tuple\"},{\"internalType\":\"enum MachineStatus\",\"name\":\"machineStatus\",\"type\":\"uint8\"}],\"internalType\":\"struct RollupLib.ExecutionState\",\"name\":\"afterState\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"numBlocks\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct RollupLib.Assertion\",\"name\":\"assertion\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"afterInboxBatchAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"wasmModuleRoot\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"inboxMaxCount\",\"type\":\"uint256\"}],\"name\":\"NodeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"}],\"name\":\"NodeRejected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OwnerFunctionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"challengeIndex\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asserter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"challenger\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"challengedNode\",\"type\":\"uint64\"}],\"name\":\"RollupChallengeStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"machineHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"RollupInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"UpgradedSecondary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalBalance\",\"type\":\"uint256\"}],\"name\":\"UserStakeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finalBalance\",\"type\":\"uint256\"}],\"name\":\"UserWithdrawableFundsUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_stakerMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"latestStakedNode\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"currentChallenge\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"amountStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeManager\",\"outputs\":[{\"internalType\":\"contract IChallengeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"confirmPeriodBlocks\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"currentChallenge\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraChallengeTimeBlocks\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstUnresolvedNode\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"blockHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sendRoot\",\"type\":\"bytes32\"}],\"name\":\"forceConfirmNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"prevNode\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"prevNodeInboxMaxCount\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes32[2]\",\"name\":\"bytes32Vals\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint64[2]\",\"name\":\"u64Vals\",\"type\":\"uint64[2]\"}],\"internalType\":\"struct GlobalState\",\"name\":\"globalState\",\"type\":\"tuple\"},{\"internalType\":\"enum MachineStatus\",\"name\":\"machineStatus\",\"type\":\"uint8\"}],\"internalType\":\"struct RollupLib.ExecutionState\",\"name\":\"beforeState\",\"type\":\"tuple\"},{\"components\":[{\"components\":[{\"internalType\":\"bytes32[2]\",\"name\":\"bytes32Vals\",\"type\":\"bytes32[2]\"},{\"internalType\":\"uint64[2]\",\"name\":\"u64Vals\",\"type\":\"uint64[2]\"}],\"internalType\":\"struct GlobalState\",\"name\":\"globalState\",\"type\":\"tuple\"},{\"internalType\":\"enum MachineStatus\",\"name\":\"machineStatus\",\"type\":\"uint8\"}],\"internalType\":\"struct RollupLib.ExecutionState\",\"name\":\"afterState\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"numBlocks\",\"type\":\"uint64\"}],\"internalType\":\"struct RollupLib.Assertion\",\"name\":\"assertion\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"expectedNodeHash\",\"type\":\"bytes32\"}],\"name\":\"forceCreateNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"staker\",\"type\":\"address[]\"}],\"name\":\"forceRefundStaker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"stakerA\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"stakerB\",\"type\":\"address[]\"}],\"name\":\"forceResolveChallenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"}],\"name\":\"getNode\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"stateHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challengeHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"confirmData\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"prevNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"deadlineBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"noChildConfirmedBeforeBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"stakerCount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"childStakerCount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"firstChildBlock\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"latestChildNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"createdAtBlock\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"nodeHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct Node\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getStaker\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"index\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"latestStakedNode\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"currentChallenge\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"}],\"internalType\":\"struct IRollupCore.Staker\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"stakerNum\",\"type\":\"uint64\"}],\"name\":\"getStakerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inbox\",\"outputs\":[{\"internalType\":\"contract IInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"confirmPeriodBlocks\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"extraChallengeTimeBlocks\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"stakeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"baseStake\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"wasmModuleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"loserStakeEscrow\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequencerInbox.MaxTimeVariation\",\"name\":\"sequencerInboxMaxTimeVariation\",\"type\":\"tuple\"}],\"internalType\":\"struct Config\",\"name\":\"config\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge\",\"type\":\"address\"},{\"internalType\":\"contract ISequencerInbox\",\"name\":\"sequencerInbox\",\"type\":\"address\"},{\"internalType\":\"contract IInbox\",\"name\":\"inbox\",\"type\":\"address\"},{\"internalType\":\"contract IOutbox\",\"name\":\"outbox\",\"type\":\"address\"},{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"rollupEventInbox\",\"type\":\"address\"},{\"internalType\":\"contract IChallengeManager\",\"name\":\"challengeManager\",\"type\":\"address\"},{\"internalType\":\"contract IRollupAdmin\",\"name\":\"rollupAdminLogic\",\"type\":\"address\"},{\"internalType\":\"contract IRollupUser\",\"name\":\"rollupUserLogic\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorUtils\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"validatorWalletCreator\",\"type\":\"address\"}],\"internalType\":\"struct ContractDependencies\",\"name\":\"connectedContracts\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isStakedOnLatestConfirmed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"isZombie\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastStakeBlock\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestConfirmed\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestNodeCreated\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"latestStakedNode\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"loserStakeEscrow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumAssertionPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"nodeNum\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"nodeHasStaker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"outbox\",\"outputs\":[{\"internalType\":\"contract IOutbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_outbox\",\"type\":\"address\"}],\"name\":\"removeOldOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupDeploymentBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollupEventInbox\",\"outputs\":[{\"internalType\":\"contract IRollupEventInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sequencerInbox\",\"outputs\":[{\"internalType\":\"contract ISequencerInbox\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newBaseStake\",\"type\":\"uint256\"}],\"name\":\"setBaseStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newConfirmPeriod\",\"type\":\"uint64\"}],\"name\":\"setConfirmPeriodBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_inbox\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setDelayedInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"newExtraTimeBlocks\",\"type\":\"uint64\"}],\"name\":\"setExtraChallengeTimeBlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLoserStakerEscrow\",\"type\":\"address\"}],\"name\":\"setLoserStakeEscrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPeriod\",\"type\":\"uint256\"}],\"name\":\"setMinimumAssertionPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOutbox\",\"name\":\"_outbox\",\"type\":\"address\"}],\"name\":\"setOutbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencerInbox\",\"type\":\"address\"}],\"name\":\"setSequencerInbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStakeToken\",\"type\":\"address\"}],\"name\":\"setStakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_validator\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_val\",\"type\":\"bool[]\"}],\"name\":\"setValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newWasmModuleRoot\",\"type\":\"bytes32\"}],\"name\":\"setWasmModuleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakerCount\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeBeacon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeSecondaryTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeSecondaryToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorUtils\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorWalletCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wasmModuleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdrawableFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zombieNum\",\"type\":\"uint256\"}],\"name\":\"zombieAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zombieCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"zombieNum\",\"type\":\"uint256\"}],\"name\":\"zombieLatestStakedNode\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RollupAdminLogic", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}