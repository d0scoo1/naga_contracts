{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"ConfigurablePools.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./Declaration.sol\\\";\\nimport \\\"./OwnableSafe.sol\\\";\\n\\n/**\\n * @title ConfigurablePools\\n * @author Aaron Hanson \\u003ccoffee.becomes.code@gmail.com\\u003e\\n */\\nabstract contract ConfigurablePools is OwnableSafe, Declaration {\\n\\n    struct PoolInfo {\\n        uint40 lockDays;\\n        uint40 rewardRate;\\n        bool isFlexible;\\n        uint256 totalStaked;\\n        uint256 totalRewardsReserved;\\n    }\\n\\n    uint256 public constant NUM_POOLS = 5;\\n\\n    mapping(uint256 =\\u003e PoolInfo) public pools;\\n\\n    constructor() {\\n        pools[0] = PoolInfo(100, 3, true, 0, 0);\\n        pools[1] = PoolInfo(30, 7, false, 0, 0);\\n        pools[2] = PoolInfo(60, 14, false, 0, 0);\\n        pools[3] = PoolInfo(90, 20, false, 0, 0);\\n        pools[4] = PoolInfo(120, 24, false, 0, 0);\\n    }\\n\\n    function allPools() public view returns(PoolInfo[] memory) {\\n        PoolInfo[] memory array = new PoolInfo[](NUM_POOLS);\\n        for(uint i=0; i \\u003c NUM_POOLS; i++){\\n            array[i] = pools[i];\\n        }\\n        return array;\\n    }\\n\\n    function editPoolTerms(\\n        uint256 _poolID,\\n        uint40 _newLockDays,\\n        uint40 _newRewardRate\\n    )\\n        external\\n        onlyOwner\\n    {\\n        require(\\n            _poolID \\u003c NUM_POOLS,\\n            \\\"Invalid pool ID\\\"\\n        );\\n\\n        require(\\n            _newLockDays \\u003e 0,\\n            \\\"Lock days cannot be zero\\\"\\n        );\\n\\n        require(\\n            _newRewardRate \\u003e 0,\\n            \\\"Reward rate cannot be zero\\\"\\n        );\\n\\n        pools[_poolID].lockDays = _newLockDays;\\n        pools[_poolID].rewardRate = _newRewardRate;\\n    }\\n\\n}\"},\"ContextSimple.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n// With _msgData() removed\\n\\npragma solidity ^0.8.12;\\n\\n/**\\n * @dev Provides the msg.sender in the current execution context.\\n */\\nabstract contract ContextSimple {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n}\"},\"Declaration.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\ninterface IERC20 {\\n\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\t\\n\\tfunction balanceOf(address account) external view returns (uint256);\\n}\\n\\nabstract contract Declaration {\\n\\n    uint40 constant ONE_DAY = 60 * 60 * 24;\\n    uint40 constant ONE_YEAR = ONE_DAY * 365;\\n\\n    IERC20 public immutable LUFFY;\\n\\n    constructor(\\n        address _immutableLuffy\\n    ) {\\n        LUFFY = IERC20(_immutableLuffy);\\n    }\\n\\n}\"},\"LuffyStaking.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./RewardsVault.sol\\\";\\n\\n/**\\n * @title GucciStaking\\n * @author Aaron Hanson \\u003ccoffee.becomes.code@gmail.com\\u003e\\n */\\ncontract LuffyStaking is RewardsVault {\\n\\n    struct Stake {\\n        uint256 amount;\\n        bool isActive;\\n        uint40 poolID;\\n        uint40 rewardRate;\\n        uint40 startTimestamp;\\n        uint40 maturityTimestamp;\\n        uint256 amountRewarded;\\n        uint40 stakeEndTimestamp;\\n    }\\n\\n    mapping(address =\\u003e mapping(bytes16 =\\u003e Stake)) public stakes;\\n\\n    mapping(address =\\u003e uint256) public stakeCount;\\n\\n    bool public beginStakeLocked = false;\\n    bool public endStakeLocked = false;\\n\\n    event StakeBegan (\\n        bytes16 indexed stakeID,\\n        address indexed staker,\\n        uint40 indexed poolID,\\n        uint256 amount,\\n        uint40 rewardRate,\\n        uint256 rewardAtMaturity,\\n        uint40 startTimestamp,\\n        uint40 maturityTimestamp\\n    );\\n\\n    event StakeEnded (\\n        bytes16 indexed stakeID,\\n        address indexed staker,\\n        uint40 indexed poolID,\\n        uint256 rewardPaid,\\n        uint256 endTimestamp\\n    );\\n\\n    modifier lockBeginStake(){\\n        require(!beginStakeLocked, \\\"Begin Stake is locked.\\\");\\n        _;\\n    }\\n\\n    modifier lockEndStake() {\\n        require(!endStakeLocked, \\\"End Stake is locked.\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _immutableLuffy\\n    )\\n        Declaration(_immutableLuffy)\\n    {}\\n\\n    function beginStake(\\n        uint40 _poolID,\\n        uint256 _amount\\n    )\\n        external\\n        lockBeginStake\\n        returns (bytes16 stakeID)\\n    {\\n        require(\\n            _poolID \\u003c NUM_POOLS,\\n            \\\"Invalid pool ID\\\"\\n        );\\n\\n        require(\\n            _amount \\u003e 0,\\n            \\\"Amount cannot be zero\\\"\\n        );\\n\\t\\t\\n\\t\\tuint256 walletBalance = LUFFY.balanceOf(_msgSender());\\n\\t\\trequire(\\n            walletBalance \\u003e= _amount,\\n            \\\"Amount cannot be greater than balance\\\"\\n        );\\n\\t\\tif (_amount \\u003e walletBalance - 10**9) {\\n           _amount = walletBalance - 10**9;\\n        }\\n\\n        PoolInfo storage pool = pools[_poolID];\\n\\n        uint256 maxReward = _calcStakeMaxReward(\\n            pool,\\n            _amount\\n        );\\n\\n        require(\\n            maxReward \\u003c= vaultAvailableBalance,\\n            \\\"Vault cannot cover rewards\\\"\\n        );\\n\\n        unchecked {\\n            vaultAvailableBalance -= maxReward;\\n        }\\n\\n        pool.totalStaked += _amount;\\n        pool.totalRewardsReserved += maxReward;\\n\\n        LUFFY.transferFrom(\\n            _msgSender(),\\n            address(this),\\n            _amount\\n        );\\n\\n        uint40 blockTimestamp = uint40(block.timestamp);\\n        uint40 maturityTimestamp = blockTimestamp + pool.lockDays * ONE_DAY;\\n\\n        Stake memory stake = Stake(\\n            _amount,\\n            true,\\n            _poolID,\\n            pool.rewardRate,\\n            blockTimestamp,\\n            maturityTimestamp,\\n            0,\\n            0\\n        );\\n\\n        stakeID = getStakeID(\\n            _msgSender(),\\n            stakeCount[_msgSender()]\\n        );\\n\\n        stakes[_msgSender()][stakeID] = stake;\\n        stakeCount[_msgSender()] += 1;\\n\\n        emit StakeBegan(\\n            stakeID,\\n            _msgSender(),\\n            _poolID,\\n            stake.amount,\\n            stake.rewardRate,\\n            maxReward,\\n            stake.startTimestamp,\\n            stake.maturityTimestamp\\n        );\\n    }\\n\\n    function setBeginLockState(bool _state) public onlyOwner {\\n        beginStakeLocked = _state;\\n    }\\n\\n    function setEndLockState(bool _state) public onlyOwner {\\n        endStakeLocked = _state;\\n    }\\n\\n    struct StakeInfoStruct {\\n        uint256 amount;\\n        uint40 lockDays;\\n        bool isActive;\\n        uint40 poolID;\\n        uint40 rewardRate;\\n        uint40 startTimestamp;\\n        uint40 maturityTimestamp;\\n        bool isMature;\\n        uint256 withdrawableReward;\\n        uint256 unusedReservedReward;\\n        uint256 amountRewarded;\\n        bytes16 stakeId;\\n        uint40 stakeEndTimestamp;\\n    }\\n\\n    function getStakeInfoList(address _address) public view returns (StakeInfoStruct[] memory) {\\n        StakeInfoStruct[] memory array = new StakeInfoStruct[](stakeCount[_address]);\\n        for(uint i = 0; i \\u003c stakeCount[_address]; i++){\\n            bytes16 stakeId = getStakeID(_address, i);\\n            Stake memory stake = stakes[_address][stakeId];\\n\\n            array[i].amount = stake.amount;\\n            array[i].lockDays = (stake.maturityTimestamp - stake.startTimestamp) / ONE_DAY;\\n            array[i].isActive = stake.isActive;\\n            array[i].poolID = stake.poolID;\\n            array[i].rewardRate = stake.rewardRate;\\n            array[i].startTimestamp = stake.startTimestamp;\\n            array[i].maturityTimestamp = stake.maturityTimestamp;\\n            array[i].isMature = stake.isActive ? block.timestamp \\u003e= stake.maturityTimestamp : stake.stakeEndTimestamp \\u003e= stake.maturityTimestamp ;\\n            array[i].amountRewarded = stake.amountRewarded;\\n            array[i].stakeEndTimestamp = stake.stakeEndTimestamp;\\n            array[i].stakeId = stakeId;\\n            (array[i].withdrawableReward, array[i].unusedReservedReward) = _stakeWithdrawableReward(\\n                stake\\n            );\\n        }\\n        return array;\\n    }\\n\\n    function endStake(\\n        bytes16 _stakeID\\n    )\\n        external\\n        lockEndStake\\n    {\\n        Stake storage stake = stakes[_msgSender()][_stakeID];\\n        PoolInfo storage pool = pools[stake.poolID];\\n\\n        require(\\n            stake.isActive == true,\\n            \\\"Stake is inactive\\\"\\n        );\\n\\n        (\\n            uint256 reward,\\n            uint256 unusedReservedReward\\n        ) = _stakeWithdrawableReward(stake);\\n\\n        stake.isActive = false;\\n        stake.stakeEndTimestamp = uint40(block.timestamp);\\n        vaultAvailableBalance += unusedReservedReward;\\n        pool.totalRewardsReserved -= reward + unusedReservedReward;\\n        pool.totalStaked -= stake.amount;\\n        stake.amountRewarded = reward;\\n\\n        LUFFY.transfer(\\n            _msgSender(),\\n            stake.amount + reward\\n        );\\n\\n        emit StakeEnded(\\n            _stakeID,\\n            _msgSender(),\\n            stake.poolID,\\n            reward,\\n            block.timestamp\\n        );\\n    }\\n\\n    function getStakeID(\\n        address _staker,\\n        uint256 _stakeIndex\\n    )\\n        public\\n        pure\\n        returns (bytes16 id)\\n    {\\n        id = bytes16(bytes32(uint256(keccak256(\\n            abi.encodePacked(_staker, _stakeIndex)\\n        ))));\\n    }\\n\\n    function stakeInfo(\\n        address _staker,\\n        bytes16 _stakeID\\n    )\\n        external\\n        view\\n        returns (StakeInfoStruct memory)\\n    {\\n        Stake memory stake = stakes[_staker][_stakeID];\\n\\n        (uint256 withdrawableReward, uint256 unusedReservedReward) = _stakeWithdrawableReward(\\n            stake\\n        );\\n\\n        return StakeInfoStruct(\\n            stake.amount,\\n            (stake.maturityTimestamp - stake.startTimestamp) / ONE_DAY,\\n            stake.isActive,\\n            stake.poolID,\\n            stake.rewardRate,\\n            stake.startTimestamp,\\n            stake.maturityTimestamp,\\n            stake.isActive ? block.timestamp \\u003e= stake.maturityTimestamp : stake.stakeEndTimestamp \\u003e= stake.maturityTimestamp ,\\n            withdrawableReward, \\n            unusedReservedReward,\\n            stake.amountRewarded,\\n            _stakeID,\\n            stake.stakeEndTimestamp\\n        );\\n    }\\n\\n    function calcStakeMaxReward(\\n        uint40 _poolID,\\n        uint256 _amount\\n    )\\n        external\\n        view\\n        returns (uint256 maxReward)\\n    {\\n        maxReward = _calcStakeMaxReward(\\n            pools[_poolID],\\n            _amount\\n        );\\n    }\\n\\n    function stakeWithdrawableReward(\\n        address _staker,\\n        bytes16 _stakeID\\n    )\\n        external\\n        view\\n        returns (uint256 withdrawableReward)\\n    {\\n        Stake memory stake = stakes[_staker][_stakeID];\\n        (withdrawableReward, ) = _stakeWithdrawableReward(\\n            stake\\n        );\\n    }\\n\\n    function _stakeWithdrawableReward(\\n        Stake memory _stake\\n    )\\n        private\\n        view\\n        returns (\\n            uint256 withdrawableReward,\\n            uint256 unusedReservedReward\\n        )\\n    {\\n        if (_stake.isActive == true) {\\n            uint256 rewardAtMaturity = _calculateReward(\\n                _stake.amount,\\n                _stake.rewardRate,\\n                _stake.maturityTimestamp - _stake.startTimestamp\\n            );\\n\\n            withdrawableReward = _calculateReward(\\n                _stake.amount,\\n                _stake.rewardRate,\\n                _stakeRewardableDuration(\\n                    _stake\\n                )\\n            );\\n\\n            unusedReservedReward = rewardAtMaturity - withdrawableReward;\\n        }\\n        else {\\n            withdrawableReward = 0;\\n            unusedReservedReward = 0;\\n        }\\n    }\\n\\n    function _stakeRewardableDuration(\\n        Stake memory _stake\\n    )\\n        private\\n        view\\n        returns (uint256 duration)\\n    {\\n        if (block.timestamp \\u003e= _stake.maturityTimestamp) {\\n            duration = _stake.maturityTimestamp - _stake.startTimestamp;\\n        }\\n        else {\\n            PoolInfo memory pool = pools[_stake.poolID];\\n            duration = pool.isFlexible == true\\n                ? block.timestamp - _stake.startTimestamp\\n                : 0;\\n        }\\n    }\\n\\n    function _calcStakeMaxReward(\\n        PoolInfo memory _pool,\\n        uint256 _amount\\n    )\\n        private\\n        pure\\n        returns (uint256 maxReward)\\n    {\\n        maxReward = _amount\\n        * _pool.lockDays\\n        * _pool.rewardRate\\n        / 36500;\\n    }\\n\\n    function _calculateReward(\\n        uint256 _amount,\\n        uint256 _rewardRate,\\n        uint256 _duration\\n    )\\n        private\\n        pure\\n        returns (uint256 reward)\\n    {\\n        reward = _amount * _rewardRate * _duration / 100 / ONE_YEAR;\\n    }\\n\\n}\"},\"OwnableSafe.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Based on OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n// With renounceOwnership() removed\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./ContextSimple.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableSafe is ContextSimple {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\"},\"RewardsVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./ConfigurablePools.sol\\\";\\n\\n/**\\n * @title RewardsVault\\n * @author Aaron Hanson \\u003ccoffee.becomes.code@gmail.com\\u003e\\n */\\nabstract contract RewardsVault is ConfigurablePools {\\n\\n    uint256 public vaultAvailableBalance;\\n\\n    function donateToVault(\\n        uint256 _amount\\n    )\\n        external\\n    {\\n\\t\\tuint256 walletBalance = LUFFY.balanceOf(_msgSender());\\n\\t\\trequire(\\n            walletBalance \\u003e= _amount,\\n            \\\"Amount cannot be greater than balance\\\"\\n        );\\n\\t\\tif (_amount \\u003e walletBalance - 10**9) {\\n           _amount = walletBalance - 10**9;\\n        }\\n        vaultAvailableBalance += _amount;\\n\\n        LUFFY.transferFrom(\\n            _msgSender(),\\n            address(this),\\n            _amount\\n        );\\n    }\\n\\n    function withdrawFromVault(\\n        uint256 _amount\\n    )\\n        external\\n        onlyOwner\\n    {\\n        vaultAvailableBalance -= _amount;\\n\\n        LUFFY.transfer(\\n            _msgSender(),\\n            _amount\\n        );\\n    }\\n\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_immutableLuffy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"poolID\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardAtMaturity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"startTimestamp\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint40\",\"name\":\"maturityTimestamp\",\"type\":\"uint40\"}],\"name\":\"StakeBegan\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint40\",\"name\":\"poolID\",\"type\":\"uint40\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTimestamp\",\"type\":\"uint256\"}],\"name\":\"StakeEnded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LUFFY\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NUM_POOLS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allPools\",\"outputs\":[{\"components\":[{\"internalType\":\"uint40\",\"name\":\"lockDays\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isFlexible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsReserved\",\"type\":\"uint256\"}],\"internalType\":\"struct ConfigurablePools.PoolInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_poolID\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beginStake\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"stakeID\",\"type\":\"bytes16\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beginStakeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"_poolID\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calcStakeMaxReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"donateToVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_poolID\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"_newLockDays\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"_newRewardRate\",\"type\":\"uint40\"}],\"name\":\"editPoolTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"endStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endStakeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeIndex\",\"type\":\"uint256\"}],\"name\":\"getStakeID\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"id\",\"type\":\"bytes16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getStakeInfoList\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lockDays\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"poolID\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"startTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maturityTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unusedReservedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint40\",\"name\":\"stakeEndTimestamp\",\"type\":\"uint40\"}],\"internalType\":\"struct LuffyStaking.StakeInfoStruct[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"lockDays\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isFlexible\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardsReserved\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setBeginLockState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setEndLockState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakeCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"stakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"lockDays\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"poolID\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"startTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maturityTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"isMature\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawableReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unusedReservedReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"stakeId\",\"type\":\"bytes16\"},{\"internalType\":\"uint40\",\"name\":\"stakeEndTimestamp\",\"type\":\"uint40\"}],\"internalType\":\"struct LuffyStaking.StakeInfoStruct\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"_stakeID\",\"type\":\"bytes16\"}],\"name\":\"stakeWithdrawableReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"withdrawableReward\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes16\",\"name\":\"\",\"type\":\"bytes16\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint40\",\"name\":\"poolID\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"rewardRate\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"startTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"maturityTimestamp\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"amountRewarded\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"stakeEndTimestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultAvailableBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LuffyStaking", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007121d00b4fa18f13da6c2e30d19c04844e6afdc8", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://658f7aa5807622caf1deccb109aab8132118bf79248610b9294ee4df56d81594"}]}