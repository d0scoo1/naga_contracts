{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@rari-capital/solmate/src/auth/Auth.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\nabstract contract Auth {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(address indexed user, Authority indexed newAuthority);\\n\\n    address public owner;\\n\\n    Authority public authority;\\n\\n    constructor(address _owner, Authority _authority) {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig) internal view virtual returns (bool) {\\n        Authority auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return (address(auth) != address(0) && auth.canCall(user, address(this), functionSig)) || user == owner;\\n    }\\n\\n    function setAuthority(Authority newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(msg.sender == owner || authority.canCall(msg.sender, address(this), msg.sig));\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface Authority {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"srcBuild/Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport {Auth, Authority} from \\\"@rari-capital/solmate/src/auth/Auth.sol\\\";\\nlibrary Math {\\n    function max(uint a, uint b) internal pure returns (uint) {\\n        return a >= b ? a : b;\\n    }\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\\ninterface ve {\\n    function token() external view returns (address);\\n    function isUnlocked() external view returns (bool);\\n    function totalSupply() external view returns (uint);\\n    function create_lock_for(uint, uint, address) external returns (uint);\\n    function transferFrom(address, address, uint) external;\\n}\\n\\ninterface underlying {\\n    function approve(address spender, uint value) external returns (bool);\\n    function mint(address, uint) external;\\n    function setMinter(address) external;\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n    function transfer(address, uint) external returns (bool);\\n}\\n\\ninterface voter {\\n    function notifyRewardAmount(uint amount) external;\\n}\\n\\ninterface ve_dist {\\n    function checkpoint_token() external;\\n    function checkpoint_total_supply() external;\\n}\\n\\n// codifies the minting rules as per ve(3,3), abstracted from the token to support any token that allows minting\\n\\n//add safetransferlib\\ncontract Minter is Auth {\\n\\n    uint internal constant week = 86400 * 7; // allows minting once per week (reset every Thursday 00:00 UTC)\\n    uint internal emission = 98;\\n    uint internal tail_emission = 2;\\n    uint internal constant target_base = 100; // 2% per week target emission\\n    uint internal constant tail_base = 1000; // 0.2% per week target emission\\n    underlying public immutable _token;\\n    voter public immutable _voter;\\n    ve public immutable _ve;\\n    ve_dist public immutable _ve_dist;\\n    uint public weekly = 625_000e18;\\n    uint public active_period;\\n    uint internal constant lock = 86400 * 7 * 52 * 2; //2 year lock\\n\\n    address internal initializer;\\n    address internal airdrop;\\n\\n    event Mint(address indexed sender, uint weekly, uint circulating_supply, uint circulating_emission);\\n\\n    constructor(\\n        address GOVERNANCE_,\\n        address AUTHORITY_,\\n        address __voter, // the voting & distribution system\\n        address  __ve, // the veAPHRA system that will be locked into\\n        address __ve_dist // the distribution system that ensures users aren't diluted after unlock\\n    ) Auth(GOVERNANCE_, Authority(AUTHORITY_)) {\\n        initializer = msg.sender;\\n        _token = underlying(ve(__ve).token());\\n        _voter = voter(__voter);\\n        _ve = ve(__ve);\\n        _ve_dist = ve_dist(__ve_dist);\\n        active_period = (block.timestamp + (1 * week)) / week * week;\\n    }\\n\\n    //for guarded launch\\n    function migrateMinter(address newMinter_) external requiresAuth {\\n        _token.setMinter(newMinter_);\\n    }\\n\\n    function initialize(\\n        address[] memory initVeLocks,\\n        uint[] memory initVeAmounts,\\n        address[] memory initToken,\\n        uint[] memory initTokenAmounts,\\n        uint max // sum amounts / max = % ownership of top protocols, so if initial 20m is distributed, and target is 25% protocol ownership, then max - 4 x 20m = 80m\\n    ) external {\\n        //setup initial mint params here, lock team as ve nft's\\n        //setup fund team vesting locks\\n        require(initializer == msg.sender);\\n        _token.mint(address(this), max);\\n        _token.approve(address(_ve), type(uint).max);\\n\\n        for (uint i = 0; i < initVeLocks.length; i++) {\\n            _ve.create_lock_for(initVeAmounts[i], lock, initVeLocks[i]);\\n        }\\n\\n        for (uint i = 0; i < initToken.length; i++) {\\n            _token.transfer(initToken[i], initTokenAmounts[i]);\\n        }\\n\\n        //set to the last item in the initToken array as it is the airdrop and we want to exclude the airdrops balance\\n        // for supply emission calculations as it can only enter into ve when claimed\\n        airdrop = address(initToken[initToken.length - 1]);\\n        initializer = address(0);\\n        active_period = (block.timestamp + week) / week * week;\\n    }\\n\\n    function setEmission(uint newEmission_) external requiresAuth {\\n        emission = newEmission_;\\n    }\\n\\n    function setTailEmission(uint newTailEmission_) external requiresAuth {\\n        tail_emission = newTailEmission_;\\n    }\\n\\n    function setWeeklyRate(uint newWeeklyRate_) external requiresAuth {\\n        weekly = newWeeklyRate_;\\n    }\\n\\n    // calculate circulating supply as total token supply - locked supply\\n    function circulating_supply() public view returns (uint) {\\n        return _token.totalSupply() - _ve.totalSupply() - _token.balanceOf(airdrop) - _token.balanceOf(owner);\\n    }\\n\\n    // emission calculation is 2% of available supply to mint adjusted by circulating / total supply\\n    function calculate_emission() public view returns (uint) {\\n        return weekly * emission * circulating_supply() / target_base / _token.totalSupply();\\n    }\\n\\n    // weekly emission takes the max of calculated (aka target) emission versus circulating tail end emission\\n    function weekly_emission() public view returns (uint) {\\n        if(!ve(_ve).isUnlocked()) {\\n            return weekly;\\n        }\\n        return Math.max(calculate_emission(), circulating_emission());\\n    }\\n\\n    // calculates tail end (infinity) emissions as 0.2% of total supply\\n    function circulating_emission() public view returns (uint) {\\n        return circulating_supply() * tail_emission / tail_base;\\n    }\\n\\n    // calculate inflation and adjust ve balances accordingly\\n    function calculate_growth(uint _minted) public view returns (uint) {\\n        if(!ve(_ve).isUnlocked()) {\\n            return 0;\\n        }\\n        return _ve.totalSupply() * _minted / _token.totalSupply();\\n    }\\n\\n    // update period can only be called once per cycle (1 week)\\n    function update_period() external returns (uint) {\\n        uint _period = active_period;\\n        if (block.timestamp >= _period + week && initializer == address(0)) { // only trigger if new week\\n            _period = block.timestamp / week * week;\\n            active_period = _period;\\n            weekly = weekly_emission();\\n\\n            uint _growth = calculate_growth(weekly);\\n            uint _required = _growth + weekly;\\n            uint _balanceOf = _token.balanceOf(address(this));\\n            if (_balanceOf < _required) {\\n                _token.mint(address(this), _required-_balanceOf);\\n            }\\n\\n            require(_token.transfer(address(_ve_dist), _growth));\\n            _ve_dist.checkpoint_token(); // checkpoint token balance that was just minted in ve_dist\\n            _ve_dist.checkpoint_total_supply(); // checkpoint supply\\n\\n            _token.approve(address(_voter), weekly);\\n            _voter.notifyRewardAmount(weekly);\\n\\n            emit Mint(msg.sender, weekly, circulating_supply(), circulating_emission());\\n        }\\n        return _period;\\n    }\\n\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"GOVERNANCE_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"AUTHORITY_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__voter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"__ve_dist\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weekly\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"circulating_supply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"circulating_emission\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_token\",\"outputs\":[{\"internalType\":\"contract underlying\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"contract ve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ve_dist\",\"outputs\":[{\"internalType\":\"contract ve_dist\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_voter\",\"outputs\":[{\"internalType\":\"contract voter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"active_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract Authority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculate_emission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minted\",\"type\":\"uint256\"}],\"name\":\"calculate_growth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulating_emission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"circulating_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"initVeLocks\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"initVeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"initToken\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"initTokenAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter_\",\"type\":\"address\"}],\"name\":\"migrateMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract Authority\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newEmission_\",\"type\":\"uint256\"}],\"name\":\"setEmission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTailEmission_\",\"type\":\"uint256\"}],\"name\":\"setTailEmission\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWeeklyRate_\",\"type\":\"uint256\"}],\"name\":\"setWeeklyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weekly\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weekly_emission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Minter", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000002101a22a8a6f2b60ef36013effcef56893cea983000000000000000000000000cbb46b017e8d785c107e97c56135894b3ead599c000000000000000000000000c226820477d8aae987d235c4b425a13061a2aa0d000000000000000000000000f8fbff4918a9d96925ef8695978fba347df57276000000000000000000000000cd320c689352f8a8e6848bed59199eaa24b7ebbb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}