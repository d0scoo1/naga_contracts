{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.6.12;\r\n\r\n\r\nlibrary SafeMath {\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() public {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n    \r\n    function safeMultiTransfer(IERC20 token, address[] memory to, uint256[] memory values) internal {\r\n        require(to.length == values.length, \"Different number of recipients than values\");\r\n        for (uint i = 0; i < to.length; i++) {\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to[i], values[i]));\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n    \r\n    function safeMultiTransferFrom(IERC20 token, address from, address[] memory to, uint256[] memory values) internal {\r\n        require(to.length == values.length, \"Different number of recipients than values\");\r\n        for (uint i = 0; i < to.length; i++) {\r\n            callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to[i], values[i]));\r\n        }\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves.\r\n\r\n        // A Solidity high level call has three parts:\r\n        //  1. The target address is checked to verify it contains contract code\r\n        //  2. The call itself is made, and success asserted\r\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\r\n        // solhint-disable-next-line max-line-length\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\n\r\nlibrary UniswapV2Library {\r\n    using SafeMath for uint;\r\n\r\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\r\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\r\n        require(tokenA != tokenB, 'UniswapV2Library: IDENTICAL_ADDRESSES');\r\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n        require(token0 != address(0), 'UniswapV2Library: ZERO_ADDRESS');\r\n    }\r\n\r\n    // calculates the CREATE2 address for a pair without making any external calls\r\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\r\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\r\n        pair = address(uint(keccak256(abi.encodePacked(\r\n                hex'ff',\r\n                factory,\r\n                keccak256(abi.encodePacked(token0, token1)),\r\n                hex'96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f' // init code hash\r\n            ))));\r\n    }\r\n\r\n    // fetches and sorts the reserves for a pair\r\n    function getReserves(address factory, address tokenA, address tokenB) internal view returns (uint reserveA, uint reserveB) {\r\n        (address token0,) = sortTokens(tokenA, tokenB);\r\n        (uint reserve0, uint reserve1,) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\r\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\r\n    }\r\n\r\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n    function quote(uint amountA, uint reserveA, uint reserveB) internal pure returns (uint amountB) {\r\n        require(amountA > 0, 'UniswapV2Library: INSUFFICIENT_AMOUNT');\r\n        require(reserveA > 0 && reserveB > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        amountB = amountA.mul(reserveB) / reserveA;\r\n    }\r\n\r\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) internal pure returns (uint amountOut) {\r\n        require(amountIn > 0, 'UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint amountInWithFee = amountIn.mul(997);\r\n        uint numerator = amountInWithFee.mul(reserveOut);\r\n        uint denominator = reserveIn.mul(1000).add(amountInWithFee);\r\n        amountOut = numerator / denominator;\r\n    }\r\n\r\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) internal pure returns (uint amountIn) {\r\n        require(amountOut > 0, 'UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT');\r\n        require(reserveIn > 0 && reserveOut > 0, 'UniswapV2Library: INSUFFICIENT_LIQUIDITY');\r\n        uint numerator = reserveIn.mul(amountOut).mul(1000);\r\n        uint denominator = reserveOut.sub(amountOut).mul(997);\r\n        amountIn = (numerator / denominator).add(1);\r\n    }\r\n\r\n    // performs chained getAmountOut calculations on any number of pairs\r\n    function getAmountsOut(address factory, uint amountIn, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[0] = amountIn;\r\n        for (uint i; i < path.length - 1; i++) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i], path[i + 1]);\r\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n\r\n    // performs chained getAmountIn calculations on any number of pairs\r\n    function getAmountsIn(address factory, uint amountOut, address[] memory path) internal view returns (uint[] memory amounts) {\r\n        require(path.length >= 2, 'UniswapV2Library: INVALID_PATH');\r\n        amounts = new uint[](path.length);\r\n        amounts[amounts.length - 1] = amountOut;\r\n        for (uint i = path.length - 1; i > 0; i--) {\r\n            (uint reserveIn, uint reserveOut) = getReserves(factory, path[i - 1], path[i]);\r\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\n\r\npragma solidity 0.6.12;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}\r\n\r\n\r\ninterface IHedgeySwap {\r\n    function hedgeyCallSwap(address originalOwner, uint _c, uint _totalPurchase, address[] memory path, bool cashBack) external;\r\n}\r\n\r\n\r\ninterface IHedgeyFactory {\r\n    function isSwapper(address swapper) external view returns (bool);\r\n}\r\n\r\n\r\ncontract HedgeyCalls is ReentrancyGuard {\r\n    using SafeMath for uint;\r\n    using SafeERC20 for IERC20;\r\n\r\n    address public hedgeyFactory;\r\n    address public asset;\r\n    address public pymtCurrency;\r\n    uint public assetDecimals;\r\n    address public uniPair; \r\n    address payable public constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2; //weth address    \r\n    uint public fee;\r\n    address payable public feeCollector;\r\n    uint public c = 0;\r\n    address public constant uniFactory = 0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f; //AMM factory address\r\n    bool private assetWeth;\r\n    bool private pymtWeth;\r\n    bool public cashCloseOn;\r\n    \r\n\r\n    constructor(address _asset, address _pymtCurrency, address payable _feeCollector, uint _fee) public {\r\n        hedgeyFactory = msg.sender;\r\n        require(_asset != _pymtCurrency);\r\n        asset = _asset;\r\n        pymtCurrency = _pymtCurrency;\r\n        feeCollector = _feeCollector;\r\n        fee = _fee;\r\n        assetDecimals = IERC20(_asset).decimals();\r\n        uniPair = IUniswapV2Factory(uniFactory).getPair(asset, pymtCurrency);\r\n        if (uniPair != address(0x0)) {\r\n            cashCloseOn = true;\r\n        }\r\n        \r\n        if (_asset == weth) {\r\n            assetWeth = true;\r\n            pymtWeth = false;\r\n        } else if (_pymtCurrency == weth) {\r\n            assetWeth = false;\r\n            pymtWeth = true;\r\n        } else {\r\n            assetWeth = false;\r\n            pymtWeth = false;\r\n        }\r\n    }\r\n    \r\n    struct Call {\r\n        address payable short;\r\n        uint assetAmt;\r\n        uint minimumPurchase;\r\n        uint strike;\r\n        uint totalPurch;\r\n        uint price;\r\n        uint expiry;\r\n        bool open;\r\n        bool tradeable;\r\n        address payable long;\r\n        bool exercised;\r\n    }\r\n\r\n    \r\n    mapping (uint => Call) public calls;\r\n\r\n    \r\n    //internal and setup functions\r\n\r\n    receive() external payable {    \r\n    }\r\n\r\n    function depositPymt(bool _isWeth, address _token, address _sender, uint _amt) internal {\r\n        if (_isWeth) {\r\n            require(msg.value == _amt, \"deposit issue: sending in wrong amount of eth\");\r\n            IWETH(weth).deposit{value: _amt}();\r\n            assert(IWETH(weth).transfer(address(this), _amt));\r\n        } else {\r\n            SafeERC20.safeTransferFrom(IERC20(_token), _sender, address(this), _amt);\r\n        }\r\n    }\r\n\r\n    function withdrawPymt(bool _isWeth, address _token, address payable to, uint _amt) internal {\r\n        if (_isWeth && (!Address.isContract(to))) {\r\n            //if the address is a contract - then we should actually just send WETH out to the contract, else send the wallet eth\r\n            IWETH(weth).withdraw(_amt);\r\n            to.transfer(_amt);\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(_token), to, _amt);\r\n        }\r\n    }\r\n\r\n    function transferPymt(bool _isWETH, address _token, address from, address payable to, uint _amt) internal {\r\n        if (_isWETH) {\r\n            if (!Address.isContract(to)) {\r\n                to.transfer(_amt);\r\n            } else {\r\n                // we want to deliver WETH from ETH here for better handling at contract\r\n                IWETH(weth).deposit{value: _amt}();\r\n                assert(IWETH(weth).transfer(to, _amt));\r\n            }\r\n        } else {\r\n            SafeERC20.safeTransferFrom(IERC20(_token), from, to, _amt);         \r\n        }\r\n    }\r\n\r\n    function transferPymtWithFee(bool _isWETH, address _token, address from, address payable to, uint _total) internal {\r\n        uint _fee = (_total * fee).div(1e4);\r\n        uint _amt = _total.sub(_fee);\r\n        if (_isWETH) {\r\n            require(msg.value == _total, \"transfer issue: wrong amount of eth sent\");\r\n        }\r\n        transferPymt(_isWETH, _token, from, to, _amt); //transfer the stub to recipient\r\n        if (_fee > 0) transferPymt(_isWETH, _token, from, feeCollector, _fee); //transfer fee to fee collector\r\n    }\r\n\r\n    \r\n    //admin function to update the fee amount\r\n    function changeFee(uint _fee, address payable _collector) external {\r\n        require(msg.sender == feeCollector);\r\n        fee = _fee;\r\n        feeCollector = _collector;\r\n    }\r\n\r\n    \r\n    //function anyone can call after the contract is set to update if there was no AMM before but now there is\r\n    function updateAMM() external {\r\n        uniPair = IUniswapV2Factory(uniFactory).getPair(asset, pymtCurrency);\r\n        if (uniPair == address(0x0)) {\r\n            cashCloseOn = false;\r\n        } else {\r\n            cashCloseOn = true;\r\n        }\r\n        emit AMMUpdate(cashCloseOn);\r\n        \r\n    }\r\n\r\n\r\n    //CALL FUNCTIONS GOING HERE**********************************************************\r\n\r\n    //function for someone wanting to buy a new call\r\n    function newBid(uint _assetAmt, uint _strike, uint _price, uint _expiry) payable external {\r\n        uint _totalPurch = _assetAmt.mul(_strike).div(10 ** assetDecimals);\r\n        require(_totalPurch > 0, \"c: totalPurchase error: too small amount\");\r\n        uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n        require(balCheck >= _price, \"c: not enough cash to bid\");\r\n        depositPymt(pymtWeth, pymtCurrency, msg.sender, _price); \r\n        calls[c++] = Call(address(0x0), _assetAmt, _assetAmt, _strike, _totalPurch, _price, _expiry, false, true, msg.sender, false);\r\n        emit NewBid(c.sub(1), msg.sender, _assetAmt, _assetAmt, _strike, _price, _expiry);\r\n    }\r\n    \r\n    //function to cancel a new bid\r\n    function cancelNewBid(uint _c) external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(msg.sender == call.long, \"c: only long can cancel a bid\");\r\n        require(!call.open, \"c: call already open\");\r\n        require(!call.exercised, \"c: call already exercised\");\r\n        require(call.short == address(0x0), \"c: this is not a new bid\");\r\n        call.tradeable = false;\r\n        call.exercised = true;\r\n        withdrawPymt(pymtWeth, pymtCurrency, call.long, call.price);\r\n        emit OptionCancelled(_c);\r\n    }\r\n\r\n    \r\n    function sellOpenOptionToNewBid(uint _c, uint _d, uint _price) payable external nonReentrant {\r\n        Call storage openCall = calls[_c];\r\n        Call storage newBid = calls[_d];\r\n        require(_c != _d, \"c: wrong sale function\");\r\n        require(_price == newBid.price, \"c: price changed before you could execute\");\r\n        require(msg.sender == openCall.long, \"c: you dont own this\");\r\n        require(openCall.strike == newBid.strike, \"c: not the right strike\");\r\n        require(openCall.assetAmt == newBid.assetAmt, \"c: not the right assetAmt\");\r\n        require(openCall.expiry == newBid.expiry, \"c: not the right expiry\");\r\n        require(newBid.short == address(0x0), \"c: this is not a new bid\"); //newBid always sets the short address to 0x0\r\n        require(openCall.open && !newBid.open && newBid.tradeable && !openCall.exercised && !newBid.exercised && openCall.expiry > now && newBid.expiry > now, \"something is wrong\");\r\n        newBid.exercised = true;\r\n        newBid.tradeable = false;\r\n        uint feePymt = (newBid.price * fee).div(1e4);\r\n        uint shortPymt = newBid.price.sub(feePymt);\r\n        withdrawPymt(pymtWeth, pymtCurrency, openCall.long, shortPymt);\r\n        if (feePymt > 0) SafeERC20.safeTransfer(IERC20(pymtCurrency), feeCollector, feePymt);\r\n        openCall.long = newBid.long;\r\n        openCall.price = newBid.price;\r\n        openCall.tradeable = false;\r\n        emit OpenOptionSold( _c, _d, openCall.long, _price);\r\n    }\r\n\r\n    //function for someone to write the call for the open bid\r\n    //, uint _strike, uint _assetAmt, uint _price, uint _expiry\r\n    function sellNewOption(uint _c, uint _assetAmt, uint _strike, uint _price, uint _expiry) payable external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(call.strike == _strike && call.assetAmt == _assetAmt && call.price == _price && call.expiry == _expiry, \"c details issue\");\r\n        require(call.short == address(0x0));\r\n        require(msg.sender != call.long, \"c: you are the long\");\r\n        require(call.expiry > now, \"c: This is already expired\");\r\n        require(call.tradeable, \"c: not tradeable\");\r\n        require(!call.open, \"c: call already open\");\r\n        require(!call.exercised, \"c: this has been exercised\");\r\n        uint feePymt = (call.price * fee).div(1e4);\r\n        uint shortPymt = (call.price).sub(feePymt);\r\n        uint balCheck = assetWeth ? msg.value : IERC20(asset).balanceOf(msg.sender);\r\n        require(balCheck >= call.assetAmt, \"c: not enough cash to bid\");\r\n        depositPymt(assetWeth, asset, msg.sender, call.assetAmt);\r\n        if (feePymt > 0) SafeERC20.safeTransfer(IERC20(pymtCurrency), feeCollector, feePymt);\r\n        withdrawPymt(pymtWeth, pymtCurrency, msg.sender, shortPymt);\r\n        call.short = msg.sender;\r\n        call.tradeable = false;\r\n        call.open = true;\r\n        emit NewOptionSold(_c, msg.sender);\r\n    }\r\n\r\n    \r\n    function changeNewOption(uint _c, uint _assetAmt, uint _minimumPurchase, uint _strike, uint _price, uint _expiry) payable external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(call.long == msg.sender, \"c: dont own\");\r\n        require(!call.exercised, \"c: exercised\");\r\n        require(!call.open, \"c: open\");\r\n        require(call.tradeable, \"c: !tradeable\");\r\n        uint _totalPurch = _assetAmt.mul(_strike).div(10 ** assetDecimals);\r\n        require(_totalPurch > 0, \"c: totalPurchase err\");\r\n        //lets check if this is a new ask or new bid\r\n        //if its a newAsk\r\n        if (msg.sender == call.short) {\r\n            require(_minimumPurchase.mul(_strike).div(10 ** assetDecimals) > 0, \"c: min error\");\r\n            require(_assetAmt % _minimumPurchase == 0, \"c: mod error\");\r\n            uint refund = (call.assetAmt > _assetAmt) ? call.assetAmt.sub(_assetAmt) : _assetAmt.sub(call.assetAmt);\r\n            call.strike = _strike;\r\n            call.price = _price;\r\n            call.expiry = _expiry;\r\n            call.minimumPurchase = _minimumPurchase;\r\n            call.totalPurch = _totalPurch;\r\n            call.tradeable = true;\r\n            if (call.assetAmt > _assetAmt) {\r\n                call.assetAmt = _assetAmt;\r\n                withdrawPymt(assetWeth, asset, call.short, refund);\r\n            } else if (call.assetAmt < _assetAmt) {\r\n                call.assetAmt = _assetAmt;\r\n                uint balCheck = assetWeth ? msg.value : IERC20(asset).balanceOf(msg.sender);\r\n                require(balCheck >= refund, \"c: short change\");\r\n                depositPymt(assetWeth, asset, msg.sender, refund);\r\n            }\r\n            \r\n            emit OptionChanged(_c, _assetAmt, _minimumPurchase, _strike, _price, _expiry);\r\n\r\n        } else if (call.short == address(0x0)) {\r\n            //its a newBid\r\n            uint refund = (_price > call.price) ? _price.sub(call.price) : call.price.sub(_price);\r\n            call.assetAmt = _assetAmt;\r\n            call.minimumPurchase = _assetAmt;\r\n            call.strike = _strike;\r\n            call.expiry = _expiry;\r\n            call.totalPurch = _totalPurch;\r\n            call.tradeable = true;\r\n            if (_price > call.price) {\r\n                call.price = _price;\r\n                uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n                require(balCheck >= refund, \"c: not enough cash to bid\");\r\n                depositPymt(pymtWeth, pymtCurrency, msg.sender, refund);\r\n            } else if (_price < call.price) {\r\n                call.price = _price;\r\n                withdrawPymt(pymtWeth, pymtCurrency, call.long, refund);\r\n            }\r\n            \r\n            emit OptionChanged(_c, _assetAmt, _minimumPurchase, _strike, _price, _expiry);    \r\n        }\r\n           \r\n    } \r\n    \r\n\r\n    //function to write a new call\r\n    function newAsk(uint _assetAmt, uint _minimumPurchase, uint _strike, uint _price, uint _expiry) payable external {\r\n        uint _totalPurch = _assetAmt.mul(_strike).div(10 ** assetDecimals);\r\n        require(_totalPurch > 0, \"c: totalPurchase error: too small amount\");\r\n        require(_minimumPurchase.mul(_strike).div(10 ** assetDecimals) > 0, \"c: minimum purchase error, too small of a min\");\r\n        require(_assetAmt % _minimumPurchase == 0, \"c: asset amount needs to be a multiple of the minimum\");\r\n        uint balCheck = assetWeth ? msg.value : IERC20(asset).balanceOf(msg.sender);\r\n        require(balCheck >= _assetAmt, \"c: not enough to sell this call option\");\r\n        depositPymt(assetWeth, asset, msg.sender, _assetAmt);\r\n        calls[c++] = Call(msg.sender, _assetAmt, _minimumPurchase, _strike, _totalPurch, _price, _expiry, false, true, msg.sender, false);\r\n        emit NewAsk(c.sub(1), msg.sender, _assetAmt, _minimumPurchase, _strike, _price, _expiry);\r\n    }\r\n\r\n\r\n    //function to cancel a new ask from writter side\r\n    function cancelNewAsk(uint _c) external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(msg.sender == call.short && msg.sender == call.long, \"c: only short can change an ask\");\r\n        require(!call.open, \"c: call already open\");\r\n        require(!call.exercised, \"c: call already exercised\");\r\n        call.tradeable = false;\r\n        call.exercised = true;\r\n        withdrawPymt(assetWeth, asset, call.short, call.assetAmt);\r\n        emit OptionCancelled(_c);\r\n    }\r\n    \r\n    //function to purchase a new call that hasn't changed hands yet\r\n    //, uint _strike, uint _assetAmt, uint _price, uint _expiry\r\n    function buyNewOption(uint _c, uint _assetAmt, uint _strike, uint _price, uint _expiry) payable external {\r\n        Call storage call = calls[_c];\r\n        require(call.strike == _strike && call.expiry == _expiry, \"c details issue: something changed\");\r\n        require(msg.sender != call.short, \"c: you cannot buy this\");\r\n        require(call.short != address(0x0) && call.short == call.long, \"c: this option is not a new ask\");\r\n        require(call.expiry > now, \"c: This call is already expired\");\r\n        require(!call.exercised, \"c: This has already been exercised\");\r\n        require(call.tradeable, \"c: This isnt tradeable yet\");\r\n        require(!call.open, \"c: This call is already open\");\r\n        require(_assetAmt >= call.minimumPurchase, \"purchase size does not meet minimum\");\r\n        if (_assetAmt == call.assetAmt) {\r\n            require(_price == call.price, \"c: price does not match\");\r\n            uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n            require(balCheck >= call.price, \"c: not enough to sell this call option\");\r\n            transferPymtWithFee(pymtWeth, pymtCurrency, msg.sender, call.short, _price);\r\n            call.open = true;\r\n            call.long = msg.sender;\r\n            call.tradeable = false;\r\n            emit NewOptionBought(_c, msg.sender);\r\n        } else {\r\n            uint pricePerToken = call.price.mul(10 ** 32).div(call.assetAmt);\r\n            uint proRataPrice = _assetAmt.mul(pricePerToken).div(10 ** 32);\r\n            require(_price == proRataPrice, \"c: price doesnt match pro rata price\");\r\n            require(call.assetAmt.sub(_assetAmt) >= call.minimumPurchase, \"c: remainder too small\");\r\n            uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n            require(balCheck >= proRataPrice, \"c: not enough to sell this call option\");\r\n            uint proRataTotalPurchase = _assetAmt.mul(_strike).div(10 ** assetDecimals);\r\n            transferPymtWithFee(pymtWeth, pymtCurrency, msg.sender, call.short, proRataPrice);\r\n            calls[c++] = Call(call.short, _assetAmt, call.minimumPurchase, call.strike, proRataTotalPurchase, _price, _expiry, true, false, msg.sender, false);\r\n            emit PoolOptionBought(_c, c.sub(1), msg.sender, _assetAmt, _strike, _price, _expiry);\r\n            //update the current call to become the remainder\r\n            call.assetAmt -= _assetAmt;\r\n            call.price -= _price;\r\n            call.totalPurch = call.assetAmt.mul(_strike).div(10 ** assetDecimals);\r\n            \r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n\r\n    \r\n    /**function to buy an openAsk or newAsk and then replace the long from one position with the long of the other position and remove openShort from obligation */\r\n    function buyOptionFromAsk(uint _c, uint _d, uint _price) payable external nonReentrant {\r\n        Call storage openShort = calls[_c];\r\n        Call storage ask = calls[_d];\r\n        require(msg.sender == openShort.short, \"c: your not the short\");\r\n        require(ask.short != address(0x0), \"c: this is a newBid\");\r\n        require(_price == ask.price, \"c: price changed before executed\");\r\n        require(ask.tradeable && !ask.exercised && ask.expiry > now,\"c: ask issue\");\r\n        require(openShort.open && !openShort.exercised && openShort.expiry > now, \"c: short issue\");\r\n        require(openShort.strike == ask.strike, \"c: strikes do not match\");\r\n        require(openShort.assetAmt == ask.assetAmt, \"c: asset amount does not match\");\r\n        require(openShort.expiry == ask.expiry, \"c: expiry does not match\");\r\n        require(_c != _d, \"c: wrong function to buyback\");\r\n        //openShort pays the ask\r\n        uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n        require(balCheck >= ask.price, \"c: not enough to buy this put\");\r\n        transferPymtWithFee(pymtWeth, pymtCurrency, openShort.short, ask.long, _price); //if newAsk then ask.long == ask.short, if openAsk then ask.long is the one receiving the payment\r\n        //all the checks having been matched - now we assign the openAsk short to the openShort short position\r\n        //then we close out the openAsk position\r\n        ask.exercised = true;\r\n        ask.tradeable = false;\r\n        ask.open = false;\r\n        //now withdraw the openShort's asset back to them\r\n        withdrawPymt(assetWeth, asset, openShort.short, openShort.assetAmt);\r\n        openShort.short = ask.short;\r\n        emit OpenShortRePurchased( _c, _d, openShort.short, _price);\r\n    }\r\n    \r\n\r\n\r\n    //this function lets the long set a new price on the call - typically used for existing open positions\r\n    function setPrice(uint _c, uint _price, bool _tradeable) external {\r\n        Call storage call = calls[_c];\r\n        require((msg.sender == call.long && msg.sender == call.short && _tradeable) || (msg.sender == call.long && call.open), \"c: you cant change the price\");\r\n        require(call.expiry > now, \"c: already expired\");\r\n        require(!call.exercised, \"c: already expired\");\r\n        call.price = _price; \r\n        call.tradeable = _tradeable;\r\n        emit PriceSet(_c, _price, _tradeable);\r\n    }\r\n\r\n\r\n\r\n    //use this function to sell existing calls\r\n    //uint _strike, uint _assetAmt, uint _price, uint _expiry\r\n    function buyOpenOption(uint _c, uint _assetAmt, uint _strike, uint _price, uint _expiry) payable external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(call.strike == _strike && call.assetAmt == _assetAmt && call.price == _price && call.expiry == _expiry);\r\n        require(msg.sender != call.long);\r\n        require(call.open);\r\n        require(call.expiry >= now);\r\n        require(!call.exercised);\r\n        require(call.tradeable);\r\n        uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n        require(balCheck >= call.price);\r\n        transferPymtWithFee(pymtWeth, pymtCurrency, msg.sender, call.long, call.price);\r\n        if (msg.sender == call.short) {\r\n            call.exercised = true;\r\n            call.open = false;\r\n            withdrawPymt(assetWeth, asset, call.short, call.assetAmt);\r\n        }\r\n        call.tradeable = false;\r\n        call.long = msg.sender;\r\n        emit OpenOptionPurchased(_c, msg.sender);\r\n    }\r\n\r\n\r\n    //this is the basic exercise execution function that needs to be invoked prior to maturity to receive the physical asset\r\n    function exercise(uint _c) payable external nonReentrant {\r\n        Call storage call = calls[_c];\r\n        require(call.open);\r\n        require(call.expiry >= now);\r\n        require(!call.exercised);\r\n        require(msg.sender == call.long);\r\n        uint balCheck = pymtWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n        require(balCheck >= call.totalPurch);\r\n        call.exercised = true;\r\n        call.open = false;\r\n        call.tradeable = false;\r\n        if(pymtWeth) {\r\n            require(msg.value == call.totalPurch);\r\n        }\r\n        transferPymt(pymtWeth, pymtCurrency, msg.sender, call.short, call.totalPurch);   \r\n        withdrawPymt(assetWeth, asset, call.long, call.assetAmt);\r\n        emit OptionExercised(_c, false);\r\n    }\r\n\r\n\r\n    //this is the exercise alternative for ppl who want to receive payment currency instead of the underlying asset\r\n    function cashClose(uint _c, bool cashBack) payable external nonReentrant {\r\n        require(cashCloseOn);\r\n        Call storage call = calls[_c];\r\n        require(call.open);\r\n        require(call.expiry >= now);\r\n        require(!call.exercised);\r\n        require(msg.sender == call.long);\r\n   \r\n        uint assetIn = estIn(call.totalPurch);\r\n        require(assetIn < (call.assetAmt), \"c: Underlying is not in the money\");\r\n        \r\n        address to = pymtWeth ? address(this) : call.short;\r\n        call.exercised = true;\r\n        call.open = false;\r\n        call.tradeable = false;\r\n        swap(asset, call.totalPurch, assetIn, to);\r\n        if (pymtWeth) {\r\n            withdrawPymt(pymtWeth, pymtCurrency, call.short, call.totalPurch);\r\n        }\r\n        \r\n        call.assetAmt -= assetIn;\r\n        \r\n        if (cashBack) {\r\n            \r\n            uint cashEst = estCashOut(call.assetAmt);\r\n            address _to = pymtWeth ? address(this) : call.long;\r\n            swap(asset, cashEst, call.assetAmt, _to);\r\n            if (pymtWeth) {\r\n                withdrawPymt(pymtWeth, pymtCurrency, call.long, cashEst); \r\n            }\r\n        } else {\r\n            withdrawPymt(assetWeth, asset, call.long, call.assetAmt);\r\n        }\r\n        \r\n        emit OptionExercised(_c, true);\r\n    }\r\n\r\n\r\n    \r\n\r\n    //returns an expired call back to the short\r\n    function returnExpired(uint[] memory _calls) external nonReentrant {\r\n        uint _totalAssetAmount;\r\n        for (uint i; i < _calls.length; i++) {\r\n            Call storage call = calls[_calls[i]];\r\n            require(!call.exercised && call.expiry < now && msg.sender == call.short);\r\n            call.exercised = true;\r\n            call.open = false;\r\n            call.tradeable = false;\r\n            _totalAssetAmount += call.assetAmt;\r\n            emit OptionReturned(_calls[i]);\r\n        }\r\n        withdrawPymt(assetWeth, asset, msg.sender, _totalAssetAmount);\r\n        \r\n    }\r\n    \r\n    \r\n    \r\n    function rollExpired(uint[] memory _calls, uint _assetAmount, uint _minimumPurchase, uint _newStrike, uint _newPrice, uint _newExpiry) payable external {\r\n        uint _totalAssetAmount;\r\n        for (uint i; i < _calls.length; i++) {\r\n            Call storage call = calls[_calls[i]];\r\n            require(!call.exercised && call.expiry < now && msg.sender == call.short);\r\n            call.exercised = true;\r\n            call.open = false;\r\n            call.tradeable = false;\r\n            _totalAssetAmount += call.assetAmt;\r\n            emit OptionReturned(_calls[i]);\r\n        }\r\n        require(_assetAmount % _minimumPurchase == 0 && _assetAmount >= _totalAssetAmount);\r\n        uint _totalPurch = (_assetAmount).mul(_newStrike).div(10 ** assetDecimals);\r\n        require(_totalPurch > 0 && _minimumPurchase.mul(_newStrike).div(10 ** assetDecimals) > 0);\r\n        require(_newExpiry > block.timestamp);\r\n        //only allow the writer to upsize, and pull in the additional funds required to collateralize\r\n        if (_assetAmount > _totalAssetAmount) {\r\n            uint balCheck = assetWeth ? msg.value : IERC20(pymtCurrency).balanceOf(msg.sender);\r\n            require(balCheck >= _assetAmount.sub(_totalAssetAmount));\r\n            depositPymt(assetWeth, asset, msg.sender, _assetAmount.sub(_totalAssetAmount));\r\n        }\r\n        calls[c++] = Call(msg.sender, _assetAmount, _minimumPurchase, _newStrike, _totalPurch, _newPrice, _newExpiry, false, true, msg.sender, false);\r\n        emit NewAsk(c.sub(1), msg.sender, _assetAmount, _minimumPurchase, _newStrike, _newPrice, _newExpiry);\r\n    }\r\n    \r\n    \r\n   \r\n    \r\n    \r\n\r\n    //************SWAP SPECIFIC FUNCTIONS USED FOR THE CASH CLOSE METHODS***********************/\r\n    \r\n    \r\n     //function to transfer an owned call (only long) for the primary purpose of leveraging external swap functions to physically exercise in the case of no cash closing\r\n    function transferAndSwap(uint _c, address payable newOwner, address[] memory path, bool cashBack) external {\r\n        Call storage call = calls[_c];\r\n        require(call.expiry >= block.timestamp);\r\n        require(!call.exercised);\r\n        require(call.open);\r\n        require(msg.sender == call.long);\r\n        require(newOwner != call.short);\r\n        require(!Address.isContract(newOwner) || path.length > 1);\r\n        call.long = newOwner; //set long to new owner\r\n        if (path.length > 1) {\r\n            require(IHedgeyFactory(hedgeyFactory).isSwapper(newOwner)); //only whitelisted swapper addresses allowed\r\n            //swapping from asset to payment currency - need asset first and payment currency last in the path\r\n            require(path[0] == asset && path[path.length - 1] == pymtCurrency);\r\n            IHedgeySwap(newOwner).hedgeyCallSwap(msg.sender, _c, call.totalPurch, path, cashBack);\r\n        }\r\n        \r\n        emit OptionTransferred(_c, newOwner);\r\n    }\r\n\r\n    //function to swap from this contract to uniswap pool\r\n    function swap(address token, uint out, uint _in, address to) internal {\r\n        SafeERC20.safeTransfer(IERC20(token), uniPair, _in); //sends the asset amount in to the swap\r\n        address token0 = IUniswapV2Pair(uniPair).token0();\r\n        if (token == token0) {\r\n            IUniswapV2Pair(uniPair).swap(0, out, to, new bytes(0));\r\n        } else {\r\n            IUniswapV2Pair(uniPair).swap(out, 0, to, new bytes(0));\r\n        }\r\n        \r\n    }\r\n    \r\n    function estCashOut(uint amountIn) public view returns (uint amountOut) {\r\n        (uint resA, uint resB,) = IUniswapV2Pair(uniPair).getReserves();\r\n        address token1 = IUniswapV2Pair(uniPair).token1();\r\n        amountOut = (token1 == pymtCurrency) ? UniswapV2Library.getAmountOut(amountIn, resA, resB) : UniswapV2Library.getAmountOut(amountIn, resB, resA);\r\n    }\r\n\r\n    function estIn(uint amountOut) public view returns (uint amountIn) {\r\n        (uint resA, uint resB,) = IUniswapV2Pair(uniPair).getReserves();\r\n        address token1 = IUniswapV2Pair(uniPair).token1();\r\n        amountIn = (token1 == pymtCurrency) ? UniswapV2Library.getAmountIn(amountOut, resA, resB) : UniswapV2Library.getAmountIn(amountOut, resB, resA);\r\n    }\r\n    \r\n\r\n   /***events*****/\r\n    event NewBid(uint _i, address _long, uint _assetAmt, uint _minimumPurchase, uint _strike, uint _price, uint _expiry);\r\n    event NewAsk(uint _i, address _long, uint _assetAmt, uint _minimumPurchase, uint _strike, uint _price, uint _expiry);\r\n    event NewOptionSold(uint _i, address _short);\r\n    event NewOptionBought(uint _i, address _long);\r\n    event OpenOptionSold(uint _i, uint _j, address _long, uint _price);\r\n    event OpenShortRePurchased(uint _i, uint _j, address _short, uint _price);\r\n    event OpenOptionPurchased(uint _i, address _long);\r\n    event OptionChanged(uint _i, uint _assetAmt, uint _minimumPurchase, uint _strike, uint _price, uint _expiry);\r\n    event PriceSet(uint _i, uint _price, bool _tradeable);\r\n    event OptionExercised(uint _i, bool _cashClosed);\r\n    event OptionReturned(uint _i);\r\n    event OptionCancelled(uint _i);\r\n    event OptionTransferred(uint _i, address _newOwner);\r\n    event PoolOptionBought(uint _i, uint _j, address _long, uint _assetAmt, uint _strike, uint _price, uint _expiry);\r\n    event AMMUpdate(bool _cashCloseOn);\r\n}\r\n\r\n\r\ncontract HedgeyCallsFactory {\r\n    \r\n    mapping(address => mapping(address => address)) public pairs;\r\n    address payable public collector;\r\n    uint public fee;\r\n    mapping(address => bool) private swappers;\r\n    \r\n    \r\n\r\n    constructor (address payable _collector, uint _fee) public {\r\n        collector = _collector;\r\n        fee = _fee;\r\n       \r\n    }\r\n    \r\n    function addSwapper(address swapper) external {\r\n        require(msg.sender == collector, \"youre not the collector\");\r\n        swappers[swapper] = true;\r\n    }\r\n\r\n    function isSwapper(address swapper) external view returns (bool check) {\r\n        check = swappers[swapper];\r\n    }\r\n    \r\n    \r\n    function changeFee(uint _newFee, address payable _collector) external {\r\n        require(msg.sender == collector, \"youre not the collector\");\r\n        fee = _newFee;\r\n        collector = _collector;\r\n    }\r\n    \r\n    \r\n    function getPair(address asset, address pymtCurrency) external view returns (address pair) {\r\n        pair = pairs[asset][pymtCurrency];\r\n    }\r\n   \r\n    \r\n    function createContract(address asset, address pymtCurrency) external {\r\n        require(asset != pymtCurrency, \"same currencies\");\r\n        require(pairs[asset][pymtCurrency] == address(0), \"contract exists\");\r\n        HedgeyCalls callContract = new HedgeyCalls(asset, pymtCurrency, collector, fee);\r\n        pairs[asset][pymtCurrency] = address(callContract);\r\n        emit NewPairCreated(asset, pymtCurrency, address(callContract));\r\n    }\r\n\r\n    event NewPairCreated(address _asset, address _pymtCurrency, address _pair);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_collector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pymtCurrency\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"NewPairCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"addSwapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_collector\",\"type\":\"address\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pymtCurrency\",\"type\":\"address\"}],\"name\":\"createContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pymtCurrency\",\"type\":\"address\"}],\"name\":\"getPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"swapper\",\"type\":\"address\"}],\"name\":\"isSwapper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"check\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pairs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HedgeyCallsFactory", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001c55f857f80d7af9169628a134f34c5fb16fa5820000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://01d22ffac7edf2e692358bc5965a40a30f8bdeca3774d8b8d77579d9975042d0"}]}