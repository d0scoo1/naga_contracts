{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/USDI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./IUSDI.sol\\\";\\n\\nimport \\\"./token/UFragments.sol\\\";\\nimport \\\"./lending/Vault.sol\\\";\\n\\nimport \\\"./_external/IERC20.sol\\\";\\nimport \\\"./_external/compound/ExponentialNoError.sol\\\";\\nimport \\\"./_external/openzeppelin/PausableUpgradeable.sol\\\";\\n\\n/// @title USDI token contract\\n/// @notice handles all minting/burning of usdi\\n/// @dev extends UFragments\\ncontract USDI is Initializable, PausableUpgradeable, UFragments, IUSDI, ExponentialNoError {\\n  IERC20 public _reserve;\\n  IVaultController public _VaultController;\\n\\n  address public _pauser;\\n\\n  /// @notice checks if _msgSender() is VaultController\\n  modifier onlyVaultController() {\\n    require(_msgSender() == address(_VaultController), \\\"only VaultController\\\");\\n    _;\\n  }\\n\\n  /// @notice checks if _msgSender() is pauser\\n  modifier onlyPauser() {\\n    require(_msgSender() == address(_pauser), \\\"only pauser\\\");\\n    _;\\n  }\\n\\n  /// @notice any function with this modifier will call the pay_interest() function before any function logic is called\\n  modifier paysInterest() {\\n    _VaultController.calculateInterest();\\n    _;\\n  }\\n\\n  /// @notice initializer for contract\\n  /// @param reserveAddr the address of USDC\\n  /// @dev consider adding decimals?\\n  function initialize(address reserveAddr) public override initializer {\\n    __UFragments_init(\\\"USDI Token\\\", \\\"USDI\\\");\\n    __Pausable_init();\\n    _reserve = IERC20(reserveAddr);\\n  }\\n\\n  ///@notice sets the pauser for both USDI and VaultController\\n  ///@notice the pauser is a separate role from the owner\\n  function setPauser(address pauser_) external override onlyOwner {\\n    _pauser = pauser_;\\n  }\\n\\n  /// @notice pause contract, pauser only\\n  function pause() external override onlyPauser {\\n    _pause();\\n  }\\n\\n  /// @notice unpause contract, pauser only\\n  function unpause() external override onlyPauser {\\n    _unpause();\\n  }\\n\\n  ///@notice gets the pauser for both USDI and VaultController\\n  function pauser() public view returns (address) {\\n    return _pauser;\\n  }\\n\\n  ///@notice gets the owner of the USDI contract\\n  function owner() public view override(IUSDI, OwnableUpgradeable) returns (address) {\\n    return super.owner();\\n  }\\n\\n  /// @notice getter for name\\n  /// @return name of token\\n  function name() public view override(IERC20Metadata, ERC20Detailed) returns (string memory) {\\n    return super.name();\\n  }\\n\\n  /// @notice getter for symbol\\n  /// @return symbol for token\\n  function symbol() public view override(IERC20Metadata, ERC20Detailed) returns (string memory) {\\n    return super.symbol();\\n  }\\n\\n  /// @notice getter for decimals\\n  /// @return decimals for token\\n  function decimals() public view override(IERC20Metadata, ERC20Detailed) returns (uint8) {\\n    return super.decimals();\\n  }\\n\\n  /// @notice getter for address of the reserve currency, or usdc\\n  /// @return decimals for of reserve currency\\n  function reserveAddress() public view override returns (address) {\\n    return address(_reserve);\\n  }\\n\\n  /// @notice get the VaultController addr\\n  /// @return vaultcontroller addr\\n  function getVaultController() public view override returns (address) {\\n    return address(_VaultController);\\n  }\\n\\n  /// @notice set the VaultController addr so that vault_master may mint/burn USDi without restriction\\n  /// @param vault_master_address address of vault master\\n  function setVaultController(address vault_master_address) external override onlyOwner {\\n    _VaultController = IVaultController(vault_master_address);\\n  }\\n\\n  /// @notice deposit USDC to mint USDi\\n  /// @dev caller should obtain 1e12 USDi for each USDC\\n  /// the calculations for deposit mimic the calculations done by mint in the ampleforth contract, simply with the usdc transfer\\n  /// \\\"fragments\\\" are the units that we see, so 1000 fragments == 1000 USDi\\n  /// \\\"gons\\\" are the internal accounting unit, used to keep scale.\\n  /// we use the variable _gonsPerFragment in order to convert between the two\\n  /// try dimensional analysis when doing the math in order to verify units are correct\\n  /// @param usdc_amount amount of USDC to deposit\\n  function deposit(uint256 usdc_amount) external override paysInterest whenNotPaused {\\n    // scale the usdc_amount to the usdi decimal amount, aka 1e18. since usdc is 6 decimals, we multiply by 1e12\\n    uint256 amount = usdc_amount * 1e12;\\n    require(amount > 0, \\\"Cannot deposit 0\\\");\\n    // check allowance and ensure transfer success\\n    uint256 allowance = _reserve.allowance(_msgSender(), address(this));\\n    require(allowance >= usdc_amount, \\\"Insufficient Allowance\\\");\\n    require(_reserve.transferFrom(_msgSender(), address(this), usdc_amount), \\\"transfer failed\\\");\\n    // the gonbalances of the sender is in gons, therefore we must multiply the deposit amount, which is in fragments, by gonsperfragment\\n    _gonBalances[_msgSender()] = _gonBalances[_msgSender()] + amount * _gonsPerFragment;\\n    // total supply is in fragments, and so we add amount\\n    _totalSupply = _totalSupply + amount;\\n    // and totalgons of course is in gons, and so we multiply amount by gonsperfragment to get the amount of gons we must add to totalGons\\n    _totalGons = _totalGons + amount * _gonsPerFragment;\\n\\n    emit Transfer(address(0), _msgSender(), amount);\\n    emit Deposit(_msgSender(), amount);\\n  }\\n\\n  /// @notice withdraw USDC by burning USDi\\n  /// caller should obtain 1 USDC for every 1e12 USDi\\n  /// @param usdc_amount amount of USDC to withdraw\\n  function withdraw(uint256 usdc_amount) external override paysInterest whenNotPaused {\\n    // scale the usdc_amount to the USDi decimal amount, aka 1e18\\n    uint256 amount = usdc_amount * 1e12;\\n    // check balances all around\\n    require(amount <= this.balanceOf(_msgSender()), \\\"insufficient funds\\\");\\n    require(amount > 0, \\\"Cannot withdraw 0\\\");\\n    uint256 balance = _reserve.balanceOf(address(this));\\n    require(balance >= usdc_amount, \\\"Insufficient Reserve in Bank\\\");\\n    // ensure transfer success\\n    require(_reserve.transfer(_msgSender(), usdc_amount), \\\"transfer failed\\\");\\n    // modify the gonbalances of the sender, subtracting the amount of gons, therefore amount*gonsperfragment\\n    _gonBalances[_msgSender()] = _gonBalances[_msgSender()] - amount * _gonsPerFragment;\\n    // modify totalSupply and totalGons\\n    _totalSupply = _totalSupply - amount;\\n    _totalGons = _totalGons - amount * _gonsPerFragment;\\n    // emit both a Withdraw and transfer event\\n    emit Transfer(_msgSender(), address(0), amount);\\n    emit Withdraw(_msgSender(), amount);\\n  }\\n\\n  /// @notice withdraw USDC by burning USDi\\n  /// caller should obtain 1 USDC for every 1e12 USDi\\n  /// this function is effectively just withdraw, but we calculate the amount for the sender\\n  function withdrawAll() external override paysInterest whenNotPaused {\\n    uint256 reserve = _reserve.balanceOf(address(this));\\n    require(reserve != 0, \\\"Reserve is empty\\\");\\n    uint256 usdc_amount = (this.balanceOf(_msgSender())) / 1e12;\\n    //user's USDI value is more than reserve\\n    if (usdc_amount > reserve) {\\n      usdc_amount = reserve;\\n    }\\n    uint256 amount = usdc_amount * 1e12;\\n    require(_reserve.transfer(_msgSender(), usdc_amount), \\\"transfer failed\\\");\\n    // see comments in the withdraw function for an explaination of this math\\n    _gonBalances[_msgSender()] = _gonBalances[_msgSender()] - (amount * _gonsPerFragment);\\n    _totalSupply = _totalSupply - amount;\\n    _totalGons = _totalGons - (amount * _gonsPerFragment);\\n    // emit both a Withdraw and transfer event\\n    emit Transfer(_msgSender(), address(0), amount);\\n    emit Withdraw(_msgSender(), amount);\\n  }\\n\\n  /// @notice admin function to mint USDi\\n  /// @param usdc_amount the amount of USDi to mint, denominated in USDC\\n  function mint(uint256 usdc_amount) external override paysInterest onlyOwner {\\n    require(usdc_amount != 0, \\\"Cannot mint 0\\\");\\n    uint256 amount = usdc_amount * 1e12;\\n    // see comments in the deposit function for an explaination of this math\\n    _gonBalances[_msgSender()] = _gonBalances[_msgSender()] + amount * _gonsPerFragment;\\n    _totalSupply = _totalSupply + amount;\\n    _totalGons = _totalGons + amount * _gonsPerFragment;\\n    // emit both a mint and transfer event\\n    emit Transfer(address(0), _msgSender(), amount);\\n    emit Mint(_msgSender(), amount);\\n  }\\n\\n  /// @notice admin function to burn USDi\\n  /// @param usdc_amount the amount of USDi to burn, denominated in USDC\\n  function burn(uint256 usdc_amount) external override paysInterest onlyOwner {\\n    require(usdc_amount != 0, \\\"Cannot burn 0\\\");\\n    uint256 amount = usdc_amount * 1e12;\\n    // see comments in the deposit function for an explaination of this math\\n    _gonBalances[_msgSender()] = _gonBalances[_msgSender()] - amount * _gonsPerFragment;\\n    _totalSupply = _totalSupply - amount;\\n    _totalGons = _totalGons - amount * _gonsPerFragment;\\n    // emit both a mint and transfer event\\n    emit Transfer(_msgSender(), address(0), amount);\\n    emit Burn(_msgSender(), amount);\\n  }\\n\\n  /// @notice donates usdc to the protocol reserve\\n  /// @param usdc_amount the amount of USDC to donate\\n  function donate(uint256 usdc_amount) external override paysInterest whenNotPaused {\\n    uint256 amount = usdc_amount * 1e12;\\n    require(amount > 0, \\\"Cannot deposit 0\\\");\\n    uint256 allowance = _reserve.allowance(_msgSender(), address(this));\\n    require(allowance >= usdc_amount, \\\"Insufficient Allowance\\\");\\n    require(_reserve.transferFrom(_msgSender(), address(this), usdc_amount), \\\"transfer failed\\\");\\n    _donation(amount);\\n  }\\n\\n  /// @notice donates any USDC held by this contract to the USDi holders\\n  /// @notice accounts for any USDC that may have been sent here accidently\\n  /// @notice without this, any USDC sent to the contract could mess up the reserve ratio\\n  function donateReserve() external override onlyOwner whenNotPaused {\\n    uint256 totalUSDC = (_reserve.balanceOf(address(this))) * 1e12;\\n    uint256 totalLiability = truncate(_VaultController.totalBaseLiability() * _VaultController.interestFactor());\\n    require((totalUSDC + totalLiability) > _totalSupply, \\\"No extra reserve\\\");\\n\\n    _donation((totalUSDC + totalLiability) - _totalSupply);\\n  }\\n\\n  /// @notice function for the vaultController to mint\\n  /// @param target whom to mint the USDi to\\n  /// @param amount the amount of USDi to mint\\n  function vaultControllerMint(address target, uint256 amount) external override onlyVaultController {\\n    // see comments in the deposit function for an explaination of this math\\n    _gonBalances[target] = _gonBalances[target] + amount * _gonsPerFragment;\\n    _totalSupply = _totalSupply + amount;\\n    _totalGons = _totalGons + amount * _gonsPerFragment;\\n    emit Transfer(address(0), target, amount);\\n    emit Mint(target, amount);\\n  }\\n\\n  /// @notice function for the vaultController to burn\\n  /// @param target whom to burn the USDi from\\n  /// @param amount the amount of USDi to burn\\n  function vaultControllerBurn(address target, uint256 amount) external override onlyVaultController {\\n    require(_gonBalances[target] > (amount * _gonsPerFragment), \\\"USDI: not enough balance\\\");\\n    // see comments in the withdraw function for an explaination of this math\\n    _gonBalances[target] = _gonBalances[target] - amount * _gonsPerFragment;\\n    _totalSupply = _totalSupply - amount;\\n    _totalGons = _totalGons - amount * _gonsPerFragment;\\n    emit Transfer(target, address(0), amount);\\n    emit Burn(target, amount);\\n  }\\n\\n  /// @notice function for the vaultController to scale all USDi balances\\n  /// @param amount amount of USDi (e18) to donate\\n  function vaultControllerDonate(uint256 amount) external override onlyVaultController {\\n    _donation(amount);\\n  }\\n\\n  /// @notice function for distributing the donation to all USDi holders\\n  /// @param amount amount of USDi to donate\\n  function _donation(uint256 amount) internal {\\n    _totalSupply = _totalSupply + amount;\\n    if (_totalSupply > MAX_SUPPLY) {\\n      _totalSupply = MAX_SUPPLY;\\n    }\\n    _gonsPerFragment = _totalGons / _totalSupply;\\n    emit Donation(_msgSender(), amount, _totalSupply);\\n  }\\n\\n  /// @notice get reserve ratio\\n  /// @return e18_reserve_ratio USDi reserve ratio\\n  function reserveRatio() external view override returns (uint192 e18_reserve_ratio) {\\n    e18_reserve_ratio = safeu192(((_reserve.balanceOf(address(this)) * expScale) / _totalSupply) * 1e12);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IUSDI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./_external/IERC20Metadata.sol\\\";\\n\\n/// @title USDI Events\\n/// @notice interface which contains any events which the USDI contract emits\\ninterface USDIEvents {\\n  event Deposit(address indexed _from, uint256 _value);\\n  event Withdraw(address indexed _from, uint256 _value);\\n  event Mint(address to, uint256 _value);\\n  event Burn(address from, uint256 _value);\\n  event Donation(address indexed _from, uint256 _value, uint256 _totalSupply);\\n}\\n\\n/// @title USDI Interface\\n/// @notice extends USDIEvents and IERC20Metadata\\ninterface IUSDI is IERC20Metadata, USDIEvents {\\n  /// @notice initializer specifies the reserveAddress\\n  function initialize(address reserveAddress) external;\\n\\n  // getters\\n  function reserveRatio() external view returns (uint192);\\n\\n  function reserveAddress() external view returns (address);\\n\\n  // owner\\n  function owner() external view returns (address);\\n\\n  // business\\n  function deposit(uint256 usdc_amount) external;\\n\\n  function withdraw(uint256 usdc_amount) external;\\n\\n  function withdrawAll() external;\\n\\n  function donate(uint256 usdc_amount) external;\\n\\n  function donateReserve() external;\\n\\n  // admin functions\\n\\n  function setPauser(address pauser_) external;\\n\\n  function pauser() external view returns (address);\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function mint(uint256 usdc_amount) external;\\n\\n  function burn(uint256 usdc_amount) external;\\n\\n  function setVaultController(address vault_master_address) external;\\n\\n  function getVaultController() external view returns (address);\\n\\n  // functions for the vault controller to call\\n  function vaultControllerBurn(address target, uint256 amount) external;\\n\\n  function vaultControllerMint(address target, uint256 amount) external;\\n\\n  function vaultControllerDonate(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/token/UFragments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/* solhint-disable */\\npragma solidity 0.8.9;\\n\\nimport \\\"../_external/ERC20Detailed.sol\\\";\\n\\nimport \\\"../_external/openzeppelin/OwnableUpgradeable.sol\\\";\\nimport \\\"../_external/openzeppelin/Initializable.sol\\\";\\n\\n/**\\n * @title uFragments ERC20 token\\n * @dev USDI uses the uFragments concept from the Ideal Money project to play interest\\n *      Implementation is shamelessly borrowed from Ampleforth project\\n *      uFragments is a normal ERC20 token, but its supply can be adjusted by splitting and\\n *      combining tokens proportionally across all wallets.\\n *\\n *\\n *      uFragment balances are internally represented with a hidden denomination, 'gons'.\\n *      We support splitting the currency in expansion and combining the currency on contraction by\\n *      changing the exchange rate between the hidden 'gons' and the public 'fragments'.\\n */\\ncontract UFragments is Initializable, OwnableUpgradeable, ERC20Detailed {\\n  // PLEASE READ BEFORE CHANGING ANY ACCOUNTING OR MATH\\n  // Anytime there is division, there is a risk of numerical instability from rounding errors. In\\n  // order to minimize this risk, we adhere to the following guidelines:\\n  // 1) The conversion rate adopted is the number of gons that equals 1 fragment.\\n  //    The inverse rate must not be used--_totalGons is always the numerator and _totalSupply is\\n  //    always the denominator. (i.e. If you want to convert gons to fragments instead of\\n  //    multiplying by the inverse rate, you should divide by the normal rate)\\n  // 2) Gon balances converted into Fragments are always rounded down (truncated).\\n  //\\n  // We make the following guarantees:\\n  // - If address 'A' transfers x Fragments to address 'B'. A's resulting external balance will\\n  //   be decreased by precisely x Fragments, and B's external balance will be precisely\\n  //   increased by x Fragments.\\n  //\\n  // We do not guarantee that the sum of all balances equals the result of calling totalSupply().\\n  // This is because, for any conversion function 'f()' that has non-zero rounding error,\\n  // f(x0) + f(x1) + ... + f(xn) is not always equal to f(x0 + x1 + ... xn).\\n\\n  event LogRebase(uint256 indexed epoch, uint256 totalSupply);\\n  event LogMonetaryPolicyUpdated(address monetaryPolicy);\\n\\n  // Used for authentication\\n  address public monetaryPolicy;\\n\\n  modifier onlyMonetaryPolicy() {\\n    require(msg.sender == monetaryPolicy);\\n    _;\\n  }\\n\\n  modifier validRecipient(address to) {\\n    require(to != address(0x0));\\n    require(to != address(this));\\n    _;\\n  }\\n\\n  uint256 private constant DECIMALS = 18;\\n  uint256 private constant MAX_UINT256 = 2**256 - 1;\\n  uint256 private constant INITIAL_FRAGMENTS_SUPPLY = 1 * 10**DECIMALS;\\n\\n  // _totalGons is a multiple of INITIAL_FRAGMENTS_SUPPLY so that _gonsPerFragment is an integer.\\n  // Use the highest value that fits in a uint256 for max granularity.\\n  uint256 public _totalGons; // = INITIAL_FRAGMENTS_SUPPLY * 10**48;\\n\\n  // MAX_SUPPLY = maximum integer < (sqrt(4*_totalGons + 1) - 1) / 2\\n  uint256 public MAX_SUPPLY; // = type(uint128).max; // (2^128) - 1\\n\\n  uint256 public _totalSupply;\\n  uint256 public _gonsPerFragment;\\n  mapping(address => uint256) public _gonBalances;\\n\\n  // This is denominated in Fragments, because the gons-fragments conversion might change before\\n  // it's fully paid.\\n  mapping(address => mapping(address => uint256)) private _allowedFragments;\\n\\n  // EIP-2612: permit \u2013 712-signed approvals\\n  // https://eips.ethereum.org/EIPS/eip-2612\\n  string public constant EIP712_REVISION = \\\"1\\\";\\n  bytes32 public constant EIP712_DOMAIN =\\n    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\");\\n  bytes32 public constant PERMIT_TYPEHASH =\\n    keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n  // EIP-2612: keeps track of number of permits per address\\n  mapping(address => uint256) private _nonces;\\n\\n  function __UFragments_init(string memory name, string memory symbol) public initializer {\\n    __Ownable_init();\\n    __ERC20Detailed_init(name, symbol, uint8(DECIMALS));\\n\\n    //set og initial values\\n    _totalGons = INITIAL_FRAGMENTS_SUPPLY * 10**48;\\n    MAX_SUPPLY = 2**128 - 1;\\n\\n    _totalSupply = INITIAL_FRAGMENTS_SUPPLY;\\n    _gonBalances[address(0x0)] = _totalGons; //send starting supply to a burner address so _totalSupply is never 0\\n    _gonsPerFragment = _totalGons / _totalSupply;\\n\\n    emit Transfer(address(this), address(0x0), _totalSupply);\\n  }\\n\\n  /**\\n   * @param monetaryPolicy_ The address of the monetary policy contract to use for authentication.\\n   */\\n  function setMonetaryPolicy(address monetaryPolicy_) external onlyOwner {\\n    monetaryPolicy = monetaryPolicy_;\\n    emit LogMonetaryPolicyUpdated(monetaryPolicy_);\\n  }\\n\\n  /**\\n   * @dev Notifies Fragments contract about a new rebase cycle.\\n   * @param supplyAdd The number of new fragment tokens to add into circulation via expansion.\\n   * @param supplyRemove The number of new fragment tokens to remove into circulation via expansion.\\n   * @return The total number of fragments after the supply adjustment.\\n   */\\n  function rebase(\\n    uint256 epoch,\\n    uint256 supplyAdd,\\n    uint256 supplyRemove\\n  ) external onlyMonetaryPolicy returns (uint256) {\\n    if (supplyAdd == 0 && supplyRemove == 0) {\\n      emit LogRebase(epoch, _totalSupply);\\n      return _totalSupply;\\n    }\\n\\n    if (supplyAdd > 0) {\\n      _totalSupply = _totalSupply + supplyAdd;\\n    } else {\\n      _totalSupply = _totalSupply - supplyRemove;\\n    }\\n\\n    if (_totalSupply > MAX_SUPPLY) {\\n      _totalSupply = MAX_SUPPLY;\\n    }\\n\\n    _gonsPerFragment = _totalGons / _totalSupply;\\n\\n    // From this point forward, _gonsPerFragment is taken as the source of truth.\\n    // We recalculate a new _totalSupply to be in agreement with the _gonsPerFragment\\n    // conversion rate.\\n    // This means our applied Deltas can deviate from the requested Deltas,\\n    // but this deviation is guaranteed to be < (_totalSupply^2)/(_totalGons - _totalSupply).\\n    //\\n    // In the case of _totalSupply <= MAX_UINT128 (our current supply cap), this\\n    // deviation is guaranteed to be < 1, so we can omit this step. If the supply cap is\\n    // ever increased, it must be re-included.\\n    // _totalSupply = _totalGons - _gonsPerFragment\\n\\n    emit LogRebase(epoch, _totalSupply);\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @return The total number of fragments.\\n   */\\n  function totalSupply() external view override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @param who The address to query.\\n   * @return The balance of the specified address.\\n   */\\n  function balanceOf(address who) external view override returns (uint256) {\\n    return _gonBalances[who] / _gonsPerFragment;\\n  }\\n\\n  /**\\n   * @param who The address to query.\\n   * @return The gon balance of the specified address.\\n   */\\n  function scaledBalanceOf(address who) external view returns (uint256) {\\n    return _gonBalances[who];\\n  }\\n\\n  /**\\n   * @return the total number of gons.\\n   */\\n  function scaledTotalSupply() external view returns (uint256) {\\n    return _totalGons;\\n  }\\n\\n  /**\\n   * @return The number of successful permits by the specified address.\\n   */\\n  function nonces(address who) public view returns (uint256) {\\n    return _nonces[who];\\n  }\\n\\n  /**\\n   * @return The computed DOMAIN_SEPARATOR to be used off-chain services\\n   *         which implement EIP-712.\\n   *         https://eips.ethereum.org/EIPS/eip-2612\\n   */\\n  function DOMAIN_SEPARATOR() public view returns (bytes32) {\\n    uint256 chainId;\\n    assembly {\\n      chainId := chainid()\\n    }\\n    return\\n      keccak256(\\n        abi.encode(EIP712_DOMAIN, keccak256(bytes(name())), keccak256(bytes(EIP712_REVISION)), chainId, address(this))\\n      );\\n  }\\n\\n  /**\\n   * @dev Transfer tokens to a specified address.\\n   * @param to The address to transfer to.\\n   * @param value The amount to be transferred.\\n   * @return True on success, false otherwise.\\n   */\\n  function transfer(address to, uint256 value) external override validRecipient(to) returns (bool) {\\n    uint256 gonValue = value * _gonsPerFragment;\\n\\n    _gonBalances[msg.sender] = _gonBalances[msg.sender] - gonValue;\\n    _gonBalances[to] = _gonBalances[to] + gonValue;\\n\\n    emit Transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfer all of the sender's wallet balance to a specified address.\\n   * @param to The address to transfer to.\\n   * @return True on success, false otherwise.\\n   */\\n  function transferAll(address to) external validRecipient(to) returns (bool) {\\n    uint256 gonValue = _gonBalances[msg.sender];\\n    uint256 value = gonValue / _gonsPerFragment;\\n\\n    delete _gonBalances[msg.sender];\\n    _gonBalances[to] = _gonBalances[to] + gonValue;\\n\\n    emit Transfer(msg.sender, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Function to check the amount of tokens that an owner has allowed to a spender.\\n   * @param owner_ The address which owns the funds.\\n   * @param spender The address which will spend the funds.\\n   * @return The number of tokens still available for the spender.\\n   */\\n  function allowance(address owner_, address spender) external view override returns (uint256) {\\n    return _allowedFragments[owner_][spender];\\n  }\\n\\n  /**\\n   * @dev Transfer tokens from one address to another.\\n   * @param from The address you want to send tokens from.\\n   * @param to The address you want to transfer to.\\n   * @param value The amount of tokens to be transferred.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external override validRecipient(to) returns (bool) {\\n    _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender] - value;\\n\\n    uint256 gonValue = value * _gonsPerFragment;\\n    _gonBalances[from] = _gonBalances[from] - gonValue;\\n    _gonBalances[to] = _gonBalances[to] + gonValue;\\n\\n    emit Transfer(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Transfer all balance tokens from one address to another.\\n   * @param from The address you want to send tokens from.\\n   * @param to The address you want to transfer to.\\n   */\\n  function transferAllFrom(address from, address to) external validRecipient(to) returns (bool) {\\n    uint256 gonValue = _gonBalances[from];\\n    uint256 value = gonValue / _gonsPerFragment;\\n\\n    _allowedFragments[from][msg.sender] = _allowedFragments[from][msg.sender] - value;\\n\\n    delete _gonBalances[from];\\n    _gonBalances[to] = _gonBalances[to] + gonValue;\\n\\n    emit Transfer(from, to, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of\\n   * msg.sender. This method is included for ERC20 compatibility.\\n   * increaseAllowance and decreaseAllowance should be used instead.\\n   * Changing an allowance with this method brings the risk that someone may transfer both\\n   * the old and the new allowance - if they are both greater than zero - if a transfer\\n   * transaction is mined before the later approve() call is mined.\\n   *\\n   * @param spender The address which will spend the funds.\\n   * @param value The amount of tokens to be spent.\\n   */\\n  function approve(address spender, uint256 value) external override returns (bool) {\\n    _allowedFragments[msg.sender][spender] = value;\\n\\n    emit Approval(msg.sender, spender, value);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Increase the amount of tokens that an owner has allowed to a spender.\\n   * This method should be used instead of approve() to avoid the double approval vulnerability\\n   * described above.\\n   * @param spender The address which will spend the funds.\\n   * @param addedValue The amount of tokens to increase the allowance by.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n    _allowedFragments[msg.sender][spender] = _allowedFragments[msg.sender][spender] + addedValue;\\n\\n    emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Decrease the amount of tokens that an owner has allowed to a spender.\\n   *\\n   * @param spender The address which will spend the funds.\\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\\n    uint256 oldValue = _allowedFragments[msg.sender][spender];\\n    _allowedFragments[msg.sender][spender] = (subtractedValue >= oldValue) ? 0 : oldValue - subtractedValue;\\n\\n    emit Approval(msg.sender, spender, _allowedFragments[msg.sender][spender]);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Allows for approvals to be made via secp256k1 signatures.\\n   * @param owner The owner of the funds\\n   * @param spender The spender\\n   * @param value The amount\\n   * @param deadline The deadline timestamp, type(uint256).max for max deadline\\n   * @param v Signature param\\n   * @param s Signature param\\n   * @param r Signature param\\n   */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) public {\\n    require(block.timestamp <= deadline);\\n\\n    uint256 ownerNonce = _nonces[owner];\\n    bytes32 permitDataDigest = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, ownerNonce, deadline));\\n    bytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR(), permitDataDigest));\\n\\n    require(owner == ecrecover(digest, v, r, s));\\n    require(owner != address(0x0));\\n\\n    _nonces[owner] = ownerNonce + 1;\\n\\n    _allowedFragments[owner][spender] = value;\\n    emit Approval(owner, spender, value);\\n  }\\n}\\n/* solhint-enable */\\n\"\r\n    },\r\n    \"contracts/lending/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n//import \\\"../_external/IWETH.sol\\\";\\n\\nimport \\\"../IUSDI.sol\\\";\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IVaultController.sol\\\";\\n\\nimport \\\"../_external/CompLike.sol\\\";\\nimport \\\"../_external/IERC20.sol\\\";\\nimport \\\"../_external/Context.sol\\\";\\nimport \\\"../_external/openzeppelin/SafeERC20Upgradeable.sol\\\";\\n\\n/// @title Vault\\n/// @notice our implentation of maker-vault like vault\\n/// major differences:\\n/// 1. multi-collateral\\n/// 2. generate interest in USDi\\n/// 3. can delegate voting power of contained tokens\\ncontract Vault is IVault, Context {\\n  using SafeERC20Upgradeable for IERC20;\\n\\n  /// @title VaultInfo struct\\n  /// @notice this struct is used to store the vault metadata\\n  /// this should reduce the cost of minting by ~15,000\\n  /// by limiting us to max 2**96-1 vaults\\n  struct VaultInfo {\\n    uint96 id;\\n    address minter;\\n  }\\n  /// @notice Metadata of vault, aka the id & the minter's address\\n  VaultInfo public _vaultInfo;\\n  IVaultController public immutable _controller;\\n\\n  /// @notice this is the unscaled liability of the vault.\\n  /// the number is meaningless on its own, and must be combined with the factor taken from\\n  /// the vaultController in order to find the true liabilitiy\\n  uint256 public _baseLiability;\\n\\n  /// @notice checks if _msgSender is the controller of the vault\\n  modifier onlyVaultController() {\\n    require(_msgSender() == address(_controller), \\\"sender not VaultController\\\");\\n    _;\\n  }\\n\\n  /// @notice checks if _msgSender is the minter of the vault\\n  modifier onlyMinter() {\\n    require(_msgSender() == _vaultInfo.minter, \\\"sender not minter\\\");\\n    _;\\n  }\\n\\n  /// @notice must be called by VaultController, else it will not be registered as a vault in system\\n  /// @param id_ unique id of the vault, ever increasing and tracked by VaultController\\n  /// @param minter_ address of the person who created this vault\\n  /// @param controller_address address of the VaultController\\n  constructor(\\n    uint96 id_,\\n    address minter_,\\n    address controller_address\\n  ) {\\n    _vaultInfo = VaultInfo(id_, minter_);\\n    _controller = IVaultController(controller_address);\\n  }\\n\\n  /// @notice minter of the vault\\n  /// @return address of minter\\n  function minter() external view override returns (address) {\\n    return _vaultInfo.minter;\\n  }\\n\\n  /// @notice id of the vault\\n  /// @return address of minter\\n  function id() external view override returns (uint96) {\\n    return _vaultInfo.id;\\n  }\\n\\n  /// @notice current vault base liability\\n  /// @return base liability of vault\\n  function baseLiability() external view override returns (uint256) {\\n    return _baseLiability;\\n  }\\n\\n  /// @notice get vaults balance of an erc20 token\\n  /// @param addr address of the erc20 token\\n  /// @dev scales wBTC up to normal erc20 size\\n  function tokenBalance(address addr) external view override returns (uint256) {\\n    return IERC20(addr).balanceOf(address(this));\\n  }\\n\\n  /// @notice withdraw an erc20 token from the vault\\n  /// this can only be called by the minter\\n  /// the withdraw will be denied if ones vault would become insolvent\\n  /// @param token_address address of erc20 token\\n  /// @param amount amount of erc20 token to withdraw\\n  function withdrawErc20(address token_address, uint256 amount) external override onlyMinter {\\n    // transfer the token to the owner\\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token_address), _msgSender(), amount);\\n    //  check if the account is solvent\\n    require(_controller.checkVault(_vaultInfo.id), \\\"over-withdrawal\\\");\\n    emit Withdraw(token_address, amount);\\n  }\\n\\n  /// @notice delegate the voting power of a comp-like erc20 token to another address\\n  /// @param delegatee address that will receive the votes\\n  /// @param token_address address of comp-like erc20 token\\n  function delegateCompLikeTo(address delegatee, address token_address) external override onlyMinter {\\n    CompLike(token_address).delegate(delegatee);\\n  }\\n\\n  /// @notice function used by the VaultController to transfer tokens\\n  /// callable by the VaultController only\\n  /// @param _token token to transfer\\n  /// @param _to person to send the coins to\\n  /// @param _amount amount of coins to move\\n  function controllerTransfer(\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external override onlyVaultController {\\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\\n  }\\n\\n  /// @notice function used by the VaultController to reduce a vaults liability\\n  /// callable by the VaultController only\\n  /// @param increase true to increase, false to decerase\\n  /// @param base_amount amount to reduce base liability by\\n  function modifyLiability(bool increase, uint256 base_amount) external override onlyVaultController returns (uint256) {\\n    if (increase) {\\n      _baseLiability = _baseLiability + base_amount;\\n    } else {\\n      // require statement only valid for repayment\\n      require(_baseLiability >= base_amount, \\\"repay too much\\\");\\n      _baseLiability = _baseLiability - base_amount;\\n    }\\n    return _baseLiability;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/_external/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/compound/ExponentialNoError.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/**\\n * @title Exponential module for storing fixed-precision decimals\\n * @author Compound\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\n *         `Exp({mantissa: 5100000000000000000})`.\\n */\\ncontract ExponentialNoError {\\n  uint256 constant expScale = 1e18;\\n  uint256 constant doubleScale = 1e36;\\n  uint256 constant halfExpScale = expScale / 2;\\n  uint256 constant mantissaOne = expScale;\\n  uint256 constant uint192Max = 2**192 - 1;\\n  uint256 constant uint128Max = 2**128 - 1;\\n\\n  struct Exp {\\n    uint256 mantissa;\\n  }\\n\\n  struct Double {\\n    uint256 mantissa;\\n  }\\n\\n  /**\\n   * @dev Truncates the given exp to a whole number value.\\n   *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\\n   */\\n  function truncate(Exp memory exp) internal pure returns (uint256) {\\n    return exp.mantissa / expScale;\\n  }\\n\\n  function truncate(uint256 u) internal pure returns (uint256) {\\n    return u / expScale;\\n  }\\n\\n  function safeu192(uint256 u) internal pure returns (uint192) {\\n    require(u < uint192Max, \\\"overflow\\\");\\n    return uint192(u);\\n  }\\n\\n  function safeu128(uint256 u) internal pure returns (uint128) {\\n    require(u < uint128Max, \\\"overflow\\\");\\n    return uint128(u);\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\n   */\\n  function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\n    Exp memory product = mul_(a, scalar);\\n    return truncate(product);\\n  }\\n\\n  /**\\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\n   */\\n  function mul_ScalarTruncateAddUInt(\\n    Exp memory a,\\n    uint256 scalar,\\n    uint256 addend\\n  ) internal pure returns (uint256) {\\n    Exp memory product = mul_(a, scalar);\\n    return add_(truncate(product), addend);\\n  }\\n\\n  /**\\n   * @dev Checks if first Exp is less than second Exp.\\n   */\\n  function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa < right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp <= right Exp.\\n   */\\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa <= right.mantissa;\\n  }\\n\\n  /**\\n   * @dev Checks if left Exp > right Exp.\\n   */\\n  function greaterThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\n    return left.mantissa > right.mantissa;\\n  }\\n\\n  /**\\n   * @dev returns true if Exp is exactly zero\\n   */\\n  function isZeroExp(Exp memory value) internal pure returns (bool) {\\n    return value.mantissa == 0;\\n  }\\n\\n  function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\n    require(n < 2**224, errorMessage);\\n    return uint224(n);\\n  }\\n\\n  function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\n    require(n < 2**32, errorMessage);\\n    return uint32(n);\\n  }\\n\\n  function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: add_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return add_(a, b, \\\"addition overflow\\\");\\n  }\\n\\n  function add_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, errorMessage);\\n    return c;\\n  }\\n\\n  function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: sub_(a.mantissa, b.mantissa)});\\n  }\\n\\n  function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub_(a, b, \\\"subtraction underflow\\\");\\n  }\\n\\n  function sub_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    return a - b;\\n  }\\n\\n  function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b.mantissa) / expScale});\\n  }\\n\\n  function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n    return mul_(a, b.mantissa) / expScale;\\n  }\\n\\n  function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: mul_(a.mantissa, b.mantissa) / doubleScale});\\n  }\\n\\n  function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n    return Double({mantissa: mul_(a.mantissa, b)});\\n  }\\n\\n  function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\n    return mul_(a, b.mantissa) / doubleScale;\\n  }\\n\\n  function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mul_(a, b, \\\"multiplication overflow\\\");\\n  }\\n\\n  function mul_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    uint256 c = a * b;\\n    require(c / a == b, errorMessage);\\n    return c;\\n  }\\n\\n  function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(mul_(a.mantissa, expScale), b.mantissa)});\\n  }\\n\\n  function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\n    return Exp({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\n    return div_(mul_(a, expScale), b.mantissa);\\n  }\\n\\n  function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(mul_(a.mantissa, doubleScale), b.mantissa)});\\n  }\\n\\n  function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(a.mantissa, b)});\\n  }\\n\\n  function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\n    return div_(mul_(a, doubleScale), b.mantissa);\\n  }\\n\\n  function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div_(a, b, \\\"divide by zero\\\");\\n  }\\n\\n  function div_(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b > 0, errorMessage);\\n    return a / b;\\n  }\\n\\n  function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\n    return Double({mantissa: div_(mul_(a, doubleScale), b)});\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n  /**\\n   * @dev Emitted when the pause is triggered by `account`.\\n   */\\n  event Paused(address account);\\n\\n  /**\\n   * @dev Emitted when the pause is lifted by `account`.\\n   */\\n  event Unpaused(address account);\\n\\n  bool private _paused;\\n\\n  /**\\n   * @dev Initializes the contract in unpaused state.\\n   */\\n  function __Pausable_init() internal onlyInitializing {\\n    __Pausable_init_unchained();\\n  }\\n\\n  function __Pausable_init_unchained() internal onlyInitializing {\\n    _paused = false;\\n  }\\n\\n  /**\\n   * @dev Returns true if the contract is paused, and false otherwise.\\n   */\\n  function paused() public view virtual returns (bool) {\\n    return _paused;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is not paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  modifier whenNotPaused() {\\n    require(!paused(), \\\"Pausable: paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Modifier to make a function callable only when the contract is paused.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  modifier whenPaused() {\\n    require(paused(), \\\"Pausable: not paused\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Triggers stopped state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must not be paused.\\n   */\\n  function _pause() internal virtual whenNotPaused {\\n    _paused = true;\\n    emit Paused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns to normal state.\\n   *\\n   * Requirements:\\n   *\\n   * - The contract must be paused.\\n   */\\n  function _unpause() internal virtual whenPaused {\\n    _paused = false;\\n    emit Unpaused(_msgSender());\\n  }\\n\\n  /**\\n   * @dev This empty reserved space is put in place to allow future versions to add new\\n   * variables without shifting down storage in the inheritance chain.\\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n   */\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/ERC20Detailed.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./openzeppelin/Initializable.sol\\\";\\n\\n/**\\n * @title ERC20Detailed token\\n * @dev The decimals are only for visualization purposes.\\n * All the operations are done using the smallest and indivisible token unit,\\n * just as on Ethereum all the operations are done in wei.\\n */\\nabstract contract ERC20Detailed is Initializable, IERC20 {\\n  string private _name;\\n  string private _symbol;\\n  uint8 private _decimals;\\n\\n  /**\\n    constructor(string memory name_, string memory symbol_, uint8 decimals_){\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n     */\\n\\n  function __ERC20Detailed_init(\\n    string memory name_,\\n    string memory symbol_,\\n    uint8 decimals_\\n  ) public initializer {\\n    _name = name_;\\n    _symbol = symbol_;\\n    _decimals = decimals_;\\n  }\\n\\n  /**\\n   * @return the name of the token.\\n   */\\n  function name() public view virtual returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @return the symbol of the token.\\n   */\\n  function symbol() public view virtual returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @return the number of decimals of the token.\\n   */\\n  function decimals() public view virtual returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  uint256[50] private ______gap;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./ContextUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n  address private _owner;\\n\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  function __Ownable_init() internal initializer {\\n    __Context_init_unchained();\\n    __Ownable_init_unchained();\\n  }\\n\\n  function __Ownable_init_unchained() internal initializer {\\n    _transferOwnership(_msgSender());\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view virtual returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public virtual onlyOwner {\\n    _transferOwnership(address(0));\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public virtual onlyOwner {\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Internal function without access restriction.\\n   */\\n  function _transferOwnership(address newOwner) internal virtual {\\n    address oldOwner = _owner;\\n    _owner = newOwner;\\n    emit OwnershipTransferred(oldOwner, newOwner);\\n  }\\n\\n  uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n   */\\n  bool private _initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n   */\\n  bool private _initializing;\\n\\n  /**\\n   * @dev Modifier to protect an initializer function from being invoked twice.\\n   */\\n  modifier initializer() {\\n    require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n    bool isTopLevelCall = !_initializing;\\n    if (isTopLevelCall) {\\n      _initializing = true;\\n      _initialized = true;\\n    }\\n\\n    _;\\n\\n    if (isTopLevelCall) {\\n      _initializing = false;\\n    }\\n  }\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n   * {initializer} modifier, directly or indirectly.\\n   */\\n  modifier onlyInitializing() {\\n    require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity 0.8.9;\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n  function __Context_init() internal initializer {\\n    __Context_init_unchained();\\n  }\\n\\n  function __Context_init_unchained() internal initializer {}\\n\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    return msg.data;\\n  }\\n\\n  uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/lending/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n// @title Vault Events\\n/// @notice interface which contains any events which the Vault contract emits\\ninterface VaultEvents {\\n  event Deposit(address token_address, uint256 amount);\\n  event Withdraw(address token_address, uint256 amount);\\n}\\n\\n/// @title Vault Interface\\n/// @notice extends VaultEvents\\ninterface IVault is VaultEvents {\\n  /// @notice value of _baseLiability\\n  function baseLiability() external view returns (uint256);\\n  /// @notice value of _vaultInfo.minter\\n  function minter() external view returns (address);\\n  /// @notice value of _vaultInfo.id\\n  function id() external view returns (uint96);\\n  /// @notice value of _tokenBalance\\n  function tokenBalance(address) external view returns (uint256);\\n\\n  // business logic\\n\\n  function withdrawErc20(address token_address, uint256 amount) external;\\n  function delegateCompLikeTo(address compLikeDelegatee, address compLikeToken) external;\\n\\n  // administrative functions\\n  function controllerTransfer(\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external;\\n\\n  function modifyLiability(bool increase, uint256 base_amount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/IVaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n// @title VaultController Events\\n/// @notice interface which contains any events which the VaultController contract emits\\ninterface VaultControllerEvents {\\n  event InterestEvent(uint64 epoch, uint192 amount, uint256 curve_val);\\n  event NewProtocolFee(uint256 protocol_fee);\\n  event RegisteredErc20(address token_address, uint256 LTVe4, address oracle_address, uint256 liquidationIncentivee4);\\n  event UpdateRegisteredErc20(\\n    address token_address,\\n    uint256 LTVe4,\\n    address oracle_address,\\n    uint256 liquidationIncentivee4\\n  );\\n  event NewVault(address vault_address, uint256 vaultId, address vaultOwner);\\n  event RegisterOracleMaster(address oracleMasterAddress);\\n  event RegisterCurveMaster(address curveMasterAddress);\\n  event BorrowUSDi(uint256 vaultId, address vaultAddress, uint256 borrowAmount);\\n  event RepayUSDi(uint256 vaultId, address vaultAddress, uint256 repayAmount);\\n  event Liquidate(uint256 vaultId, address asset_address, uint256 usdi_to_repurchase, uint256 tokens_to_liquidate);\\n}\\n\\n/// @title VaultController Interface\\n/// @notice extends VaultControllerEvents\\ninterface IVaultController is VaultControllerEvents {\\n  // initializer\\n  function initialize() external;\\n\\n  // view functions\\n\\n  function tokensRegistered() external view returns (uint256);\\n\\n  function vaultsMinted() external view returns (uint96);\\n\\n  function lastInterestTime() external view returns (uint64);\\n\\n  function totalBaseLiability() external view returns (uint192);\\n\\n  function interestFactor() external view returns (uint192);\\n\\n  function protocolFee() external view returns (uint192);\\n\\n  function vaultAddress(uint96 id) external view returns (address);\\n\\n  function vaultIDs(address wallet) external view returns (uint96[] memory);\\n\\n  function amountToSolvency(uint96 id) external view returns (uint256);\\n\\n  function vaultLiability(uint96 id) external view returns (uint192);\\n\\n  function vaultBorrowingPower(uint96 id) external view returns (uint192);\\n\\n  function tokensToLiquidate(uint96 id, address token) external view returns (uint256);\\n\\n  function checkVault(uint96 id) external view returns (bool);\\n\\n  struct VaultSummary {\\n    uint96 id;\\n    uint192 borrowingPower;\\n    uint192 vaultLiability;\\n    address[] tokenAddresses;\\n    uint256[] tokenBalances;\\n  }\\n  function vaultSummaries(uint96 start, uint96 stop) external view returns (VaultSummary[] memory);\\n\\n  // interest calculations\\n  function calculateInterest() external returns (uint256);\\n\\n  // vault management business\\n  function mintVault() external returns (address);\\n\\n  function liquidateVault(\\n    uint96 id,\\n    address asset_address,\\n    uint256 tokenAmount\\n  ) external returns (uint256);\\n\\n  function borrowUsdi(uint96 id, uint192 amount) external;\\n\\n  function repayUSDi(uint96 id, uint192 amount) external;\\n\\n  function repayAllUSDi(uint96 id) external;\\n\\n  // admin\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function getOracleMaster() external view returns (address);\\n\\n  function registerOracleMaster(address master_oracle_address) external;\\n\\n  function getCurveMaster() external view returns (address);\\n\\n  function registerCurveMaster(address master_curve_address) external;\\n\\n  function changeProtocolFee(uint192 new_protocol_fee) external;\\n\\n  function registerErc20(\\n    address token_address,\\n    uint256 LTV,\\n    address oracle_address,\\n    uint256 liquidationIncentive\\n  ) external;\\n\\n  function registerUSDi(address usdi_address) external;\\n\\n  function updateRegisteredErc20(\\n    address token_address,\\n    uint256 LTV,\\n    address oracle_address,\\n    uint256 liquidationIncentive\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/CompLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface CompLike {\\n  function delegate(address delegatee) external;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/_external/openzeppelin/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"name\":\"Donation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"monetaryPolicy\",\"type\":\"address\"}],\"name\":\"LogMonetaryPolicyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"name\":\"LogRebase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_REVISION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_VaultController\",\"outputs\":[{\"internalType\":\"contract IVaultController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol_\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"decimals_\",\"type\":\"uint8\"}],\"name\":\"__ERC20Detailed_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"__UFragments_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_gonBalances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_gonsPerFragment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_reserve\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalGons\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"donate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"donateReserve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVaultController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reserveAddr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"monetaryPolicy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauser\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyAdd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRemove\",\"type\":\"uint256\"}],\"name\":\"rebase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserveRatio\",\"outputs\":[{\"internalType\":\"uint192\",\"name\":\"e18_reserve_ratio\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"scaledBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"scaledTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"monetaryPolicy_\",\"type\":\"address\"}],\"name\":\"setMonetaryPolicy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pauser_\",\"type\":\"address\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault_master_address\",\"type\":\"address\"}],\"name\":\"setVaultController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferAllFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultControllerBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultControllerDonate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"vaultControllerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"usdc_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "USDI", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}