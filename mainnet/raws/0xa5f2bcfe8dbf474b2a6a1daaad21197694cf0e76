{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: contracts/Interfaces/IStake.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.4;\r\ninterface IStake {\r\n\r\n    struct Deposit {\r\n    uint256 amount;\r\n    uint40 time;\r\n    }\r\n\r\n    struct Staker {\r\n    uint256 dividend_amount;\r\n    uint40 last_payout;\r\n    uint256 total_invested_amount;\r\n    uint256 total_withdrawn_amount;\r\n    Deposit[] deposits;\r\n    }\r\n    \r\n    event NewDeposit(address indexed addr, uint256 amount);\r\n    event Withdraw(address indexed addr, uint256 amount);\r\n\r\n    function withdraw(uint256 amountToWithdraw, uint40 timestamp)  external;\r\n\r\n    function withdrawAmount(address _addr) external returns(uint256) ;\r\n}\r\n\r\ninterface IMStake {\r\n\r\n    // struct Deposit {\r\n    // uint256 amount;\r\n    // uint40 time;\r\n    // }\r\n\r\n    struct Staker {\r\n    uint256 dividend_amount;\r\n    uint40 last_payout;\r\n    uint256 total_invested_amount;\r\n    uint256 total_withdrawn_amount;\r\n    uint256 amount;\r\n    uint40 time;\r\n    }\r\n    \r\n    event NewDeposit(address indexed addr, uint256 amount);\r\n    event Withdraw(address indexed addr, uint256 amount);\r\n\r\n    function withdraw(uint256 amountToWithdraw)  external;\r\n\r\n    function withdrawAmount(address _addr) external returns(uint256) ;\r\n}\r\n// File: contracts/Interfaces/ITokenERC20.sol\r\n\r\n\r\n\r\npragma solidity >=0.8.4;\r\n\r\ninterface ITokenERC20 {\r\n\r\nevent Transfer(address indexed from, address indexed to, uint256 value);\r\n    \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData) external returns (bool success);\r\n\r\n    function burn(uint256 _value) external returns (bool success);\r\n\r\n    function burnFrom(address _from, uint256 _value) external returns (bool success);\r\n\r\n    \r\n}\r\n// File: contracts/Owned.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Caller should be Owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenERC20.sol\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes calldata _extraData) external; }\r\n\r\ncontract TokenERC20 is ITokenERC20, owned{\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals = 18;\r\n    uint256 public totalSupply;\r\n\r\n    mapping (address => uint256) public balanceOf;\r\n    mapping (address => mapping (address => uint256)) public allowance;\r\n\r\n\r\n    constructor(\r\n        uint256 initialSupply,\r\n        string memory tokenName,\r\n        string memory tokenSymbol\r\n    ) {\r\n        totalSupply = initialSupply * 10 ** uint256(decimals);  \r\n        balanceOf[msg.sender] = totalSupply;            \r\n        name = tokenName;                        \r\n        symbol = tokenSymbol;           \r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n\r\n        require(_to != address(0x0), \"should Transfer to correct address\");\r\n\r\n        require(balanceOf[_from] >= _value, \"Not enough balance from the sender\");\r\n\r\n        require(balanceOf[_to] + _value > balanceOf[_to], \"overflows\");\r\n\r\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\r\n\r\n        balanceOf[_from] -= _value;\r\n\r\n        balanceOf[_to] += _value;\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\r\n    }\r\n\r\n\r\n    function transfer(address _to, uint256 _value) public override returns (bool success) {\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\r\n        require(_value <= allowance[_from][msg.sender], \"You are not allowed to transfer passed amount\");    \r\n        allowance[_from][msg.sender] -= _value;\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public override\r\n        returns (bool success) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(address _spender, uint256 _value, bytes memory _extraData)\r\n        public override\r\n        returns (bool success) {\r\n        tokenRecipient spender = tokenRecipient(_spender);\r\n        if (approve(_spender, _value)) {\r\n            spender.receiveApproval(msg.sender, _value, address(this), _extraData);\r\n            return true;\r\n        }\r\n    }\r\n\r\n\r\n    function burn(uint256 _value) public override returns (bool success) {\r\n        require(balanceOf[msg.sender] >= _value, \"Not enough balance of tokens to burn\");  \r\n        balanceOf[msg.sender] -= _value;            \r\n        totalSupply -= _value;               \r\n        emit Burn(msg.sender, _value);\r\n        return true;\r\n    }\r\n\r\n   \r\n    function burnFrom(address _from, uint256 _value) public override returns (bool success) {\r\n        require(balanceOf[_from] >= _value, \"Not enough balance of tokens to burn\");               \r\n        require(_value <= allowance[_from][msg.sender], \"Not allowed to burn such amount of tokens\");\r\n        balanceOf[_from] -= _value;                     \r\n        allowance[_from][msg.sender] -= _value;             \r\n        totalSupply -= _value;         \r\n        emit Burn(_from, _value);\r\n        return true;\r\n    }\r\n}\r\n// File: @openzeppelin/contracts/utils/math/SafeMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/MSPaceStakeContract.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract MSpaceStake is owned, IMStake {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeMath for uint40;\r\n    // using SafeERC20 for IERC20;\r\n\r\n    uint256 public invested_amount;\r\n    uint256 public withdrawn_amount;\r\n    bool public stakeLive;\r\n    bool public withdrawLive;\r\n    \r\n    TokenERC20 public MSPACE;\r\n\r\n    mapping(address => Staker) public stakers;\r\n    \r\n\taddress public gameDevWallet;\r\n    address public coinAddress;\r\n\r\n    uint256 public minumTime;\r\n    uint256 public mediumTime;\r\n    uint256 public maximumTime;\r\n    uint256 public endTime;\r\n    uint256 public timestampSeconds;\r\n\r\n    struct Percentage {\r\n        bool valid;\r\n        uint256 dividend;\r\n        uint256 divisor;\r\n    }\r\n\r\n    mapping(uint256 => Percentage) public percentage;\r\n\r\n    constructor(address _gameDevWallet, address _coinAddress) {\r\n        require(!isContract(gameDevWallet));\r\n\t\tgameDevWallet = _gameDevWallet;\r\n        coinAddress = _coinAddress;\r\n        MSPACE = TokenERC20(_coinAddress);\r\n        minumTime = 30;\r\n        mediumTime = 90;\r\n        maximumTime = 180;\r\n        endTime = 365;\r\n        timestampSeconds = 86400;\r\n        percentage[1].valid = true;\r\n        percentage[1].dividend = 111;\r\n        percentage[1].divisor = 200;\r\n        percentage[2].valid = true;\r\n        percentage[2].dividend = 833;\r\n        percentage[2].divisor = 1000;\r\n        percentage[3].valid = true;\r\n        percentage[3].dividend = 1667;\r\n        percentage[3].divisor = 1000;\r\n    }\r\n\r\n    function updateMinumTime(uint256 _new) public onlyOwner{\r\n        minumTime = _new;\r\n    }\r\n\r\n    function updateEndTime(uint256 _new) public onlyOwner{\r\n        endTime = _new;\r\n    }\r\n\r\n    function updateMediumTime(uint256 _new) public onlyOwner{\r\n        mediumTime = _new;\r\n    }\r\n\r\n    function updateTimeStampSeconds(uint256 _new) public onlyOwner{\r\n        timestampSeconds = _new;\r\n    }\r\n\r\n    function toggleStakeStatus() public onlyOwner{\r\n        stakeLive = !stakeLive;\r\n    }\r\n\r\n    function toggleWithdrawStatus() public onlyOwner{\r\n        withdrawLive = !withdrawLive;\r\n    }\r\n\r\n    function updatemMaximumTime(uint256 _new) public onlyOwner{\r\n        maximumTime = _new;\r\n    }\r\n\r\n    function updatePercentage(uint256 percentageLevel, uint256 dividend, uint256 divisor) public onlyOwner{\r\n        require(percentage[percentageLevel].valid, \"percentage not active\");\r\n        percentage[percentageLevel].dividend = dividend;\r\n        percentage[percentageLevel].divisor = divisor;\r\n    }\r\n\r\n\r\n    function updateGameDevWallet(address _newGameDevWallet) public onlyOwner {\r\n        gameDevWallet = _newGameDevWallet;\r\n    }\r\n\r\n    function updateCoinAddress(address _coinAddress) public onlyOwner {\r\n        coinAddress = _coinAddress;\r\n    }\r\n\r\n    function _withdrawAmount(address _addr) private {\r\n        uint256 amount = this.withdrawAmount(_addr);\r\n\r\n        if(amount > 0) {\r\n            stakers[_addr].last_payout = uint40(block.timestamp);\r\n            stakers[_addr].dividend_amount += amount;\r\n        }\r\n    }\r\n\r\n    function deposit(uint256 amount) external {\r\n        require(amount > 0, \"deposit is invalid\");\r\n        require(stakeLive, \"Not yet allowed to stake\");\r\n\r\n        uint256 newAmount = this.withdrawAmount(msg.sender) + amount;\r\n\r\n        MSPACE.transferFrom(msg.sender, gameDevWallet, amount);\r\n        Staker storage staker = stakers[msg.sender];\r\n\r\n        staker.total_invested_amount+= amount;\r\n        staker.amount = newAmount;\r\n        staker.time = uint40(block.timestamp);\r\n        invested_amount+= amount;\r\n        \r\n        emit NewDeposit(msg.sender, amount);\r\n    }\r\n    \r\n    function withdraw(uint256 amountToWithdraw) external override{\r\n        require(withdrawLive, \"Not yet allowed to withdraw\");\r\n        Staker storage staker = stakers[msg.sender];\r\n\r\n        _withdrawAmount(msg.sender);\r\n\r\n        require(staker.amount >= amountToWithdraw, \"Not enough balance to withdraw\");\r\n\r\n        require(staker.dividend_amount > 0, \"Zero amount\");\r\n\r\n        uint256 amount = staker.dividend_amount;\r\n\r\n        uint256 newAmount = staker.dividend_amount - amountToWithdraw;\r\n\r\n        uint40 newTime = (staker.time - ((uint40(block.timestamp) - staker.time) / 2));\r\n\r\n        staker.amount = newAmount;\r\n        staker.dividend_amount = 0;\r\n        staker.total_withdrawn_amount += amountToWithdraw;\r\n        staker.time = newTime;\r\n        withdrawn_amount += amountToWithdraw;\r\n\r\n        MSPACE.transferFrom(gameDevWallet, msg.sender, amountToWithdraw);\r\n        \r\n        emit Withdraw(msg.sender, amount);\r\n    }\r\n\r\n    function withdrawAmount(address _addr) view external override returns(uint256) {\r\n        Staker storage staker = stakers[_addr];\r\n        uint256 value = 0;\r\n        \r\n        uint daysDeposited = (uint40(block.timestamp) - staker.time) / timestampSeconds;\r\n\r\n        if(daysDeposited >= minumTime && daysDeposited < mediumTime && daysDeposited <= endTime){\r\n            value += (((staker.amount) * daysDeposited * percentage[1].dividend / percentage[1].divisor) / 100) + staker.amount; // 1/3\r\n        }\r\n        else if(daysDeposited >= mediumTime && daysDeposited < maximumTime && daysDeposited <= endTime){\r\n            value += (((staker.amount) * daysDeposited * percentage[2].dividend / percentage[2].divisor) / 100)+ staker.amount; // 1/2\r\n        }\r\n        else if(daysDeposited >= maximumTime && daysDeposited <= endTime) {\r\n            value += (((staker.amount) * daysDeposited * percentage[3].dividend / percentage[3].divisor) / 100)+ staker.amount; // 1\r\n        }\r\n        else if(daysDeposited < minumTime) {\r\n            value += 0;\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    \r\n    function addressDetails(address _addr) view external returns(uint256 for_withdraw, uint256 total_invested_amount, uint256 total_withdrawn_amount) {\r\n        Staker storage staker = stakers[_addr];\r\n\r\n        uint256 amount = this.withdrawAmount(_addr);\r\n\r\n        return (\r\n            amount + staker.dividend_amount,\r\n            staker.total_invested_amount,\r\n            staker.total_withdrawn_amount\r\n        );\r\n    }\r\n\r\n    function contractDetails() view external returns(uint256 _invested_amount, uint256 _withdrawn_amount) {\r\n        return (invested_amount, withdrawn_amount);\r\n    }\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gameDevWallet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_coinAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MSPACE\",\"outputs\":[{\"internalType\":\"contract TokenERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"addressDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"for_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameDevWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"invested_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maximumTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mediumTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minumTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"percentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"dividend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividend_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"last_payout\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"total_invested_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"total_withdrawn_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timestampSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleStakeStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toggleWithdrawStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_coinAddress\",\"type\":\"address\"}],\"name\":\"updateCoinAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"updateEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGameDevWallet\",\"type\":\"address\"}],\"name\":\"updateGameDevWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"updateMediumTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"updateMinumTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentageLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dividend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"updatePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"updateTimeStampSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"updatemMaximumTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"withdrawAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawLive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawn_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MSpaceStake", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000cf5cd60f628b8d9249acb3a165cfe5a9a5b6ed000000000000000000000000003f5919205a01fa0c44e8f4c4ba897629b26b076a", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d478a187c5e7fb00b760df1d710d462329829200e29326e7f7a938d959f39c75"}]}