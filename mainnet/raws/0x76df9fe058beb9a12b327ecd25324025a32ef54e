{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: node_modules\\openzeppelin-solidity\\contracts\\utils\\Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\access\\Ownable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\security\\Pausable.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\security\\ReentrancyGuard.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\utils\\math\\SafeMath.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// CAUTION\r\n// This version of SafeMath should only be used with Solidity 0.8 or later,\r\n// because it relies on the compiler's built in overflow checks.\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations.\r\n *\r\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\r\n * now has built in overflow checking.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n            // benefit is lost if 'b' is also tested.\r\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\utils\\math\\Math.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\utils\\Address.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: node_modules\\openzeppelin-solidity\\contracts\\utils\\introspection\\IERC165.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC721\\IERC721.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: openzeppelin-solidity\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\VirgoInstantLiquidity.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract VirgoInstantLiquidity is Ownable, Pausable, ReentrancyGuard {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n    using Address for address payable;\r\n\r\n    string public constant name = 'VirgoInstantLiquidity';\r\n    string public constant version = 'V1';\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n\r\n    //trade signer\r\n    address public operator;\r\n    //virgo nfts owner \r\n    address public nftOwner; \r\n    //multiple manager for signing eth withdraw;\r\n    mapping(address => bool) public managers;  \r\n    //index number for manager address(start from 1)  \r\n    mapping(address => uint256) public managerIndexes;  \r\n    //manager signature counts \r\n    uint256 private constant signCount = 3;   \r\n    //passed manager signature counts \r\n    uint256 private constant signedCount = 2;    \r\n\r\n    //only manager role can sign a request for contract's eth withdraw\r\n    modifier isManager{        \r\n        require(managers[_msgSender()], \"caller is not manager\"); \r\n        _;\r\n    }\r\n\r\n    event SellERC721Fail(address indexed seller, address indexed tokenAddress, uint256 indexed tokenId);\r\n    event SellERC1155Fail(address indexed seller, address indexed tokenAddress, uint256 indexed tokenId, uint256 amounts);\r\n    event BuyERC721Fail(address indexed buyer, address indexed tokenAddress, uint256 indexed tokenId);\r\n    event BuyERC1155Fail(address indexed buyer, address indexed tokenAddress, uint256 indexed tokenId, uint256 amounts);  \r\n    event EthRecordCreated(address from, address to, uint amount, uint ethRecordId);\r\n    event WithdrawETH(address indexed recipient, uint256 amount); \r\n    event UpdateOperator(address indexed operatorAddress);\r\n    event UpdateNFTOwner(address nftOwnerAddress);\r\n    event Delegate(address from, address to);\r\n    event CloseTransactions(uint256 ethRecordId);\r\n    //tradeType (Sell:0   Buy:1)\r\n    event OrderInfo(uint256 indexed orderId, uint256 indexed tradeType);\r\n\r\n    // keccak256(\"ERC721Details(address tokenAddr,uint256[] ids,uint256[] price)\")\r\n    bytes32 private constant ERC721DETAILS_TYPEHASH = 0xa22e8bf7e119b195a6f04ed0c21241bcc24983bba105b07664defc2dc7e92612;\r\n    // keccak256(\"ERC1155Details(address tokenAddr,uint256[] ids,uint256[] amounts,uint256[] unitPrice)\")\r\n    bytes32 private constant ERC1155DETAILS_TYPEHASH = 0x74f52a5cd1c2e6f4a7c9e679c7e7f1461ce7b3ef57b04c3546269aa80338d6f9;\r\n    // keccak256(\"sellNFTsForETH(ERC721Details[] _erc721Details,ERC1155Details[] _erc1155Details,uint256 _totalPrice,uint256 _deadline,uint256 _orderId)ERC1155Details(address tokenAddr,uint256[] ids,uint256[] amounts,uint256[] unitPrice)ERC721Details(address tokenAddr,uint256[] ids,uint256[] price)\")\r\n    bytes32 private constant SELLNFTSFORETH_TYPEHASH = 0xb73baae7c9bec1201806782a92848dc25312dc35645cbdc8088ac1c5c9ab35c7;\r\n     // keccak256(\"buyNFTsForETH(ERC721Details[] _erc721Details,ERC1155Details[] _erc1155Details,uint256 _totalPrice,uint256 _deadline,uint256 _orderId)ERC1155Details(address tokenAddr,uint256[] ids,uint256[] amounts,uint256[] unitPrice)ERC721Details(address tokenAddr,uint256[] ids,uint256[] price)\")\r\n    bytes32 private constant BUYNFTSFORETH_TYPEHASH = 0x89138277441e31c4f31b04b4d83b8b8048482d6fff3b13a35eb1baa840a245f4;\r\n    \r\n\r\n    struct ERC721Details {\r\n        address tokenAddr;        \r\n        uint256[] ids;\r\n        uint256[] price;\r\n    }\r\n\r\n    struct ERC1155Details {\r\n        address tokenAddr;\r\n        uint256[] ids;\r\n        uint256[] amounts;\r\n        uint256[] unitPrice;\r\n    }\r\n\r\n    struct EthRecord {        \r\n        address from;\r\n        address to;\r\n        uint256 amount;\r\n        uint256 signatureCount;\r\n        bool isEnd;\r\n        mapping (uint256 => bool) signatures;   //get sign status according to manager index number \r\n    }\r\n\r\n    struct RoleUpdateRecord {\r\n        address to;\r\n        uint256 signatureCount;\r\n        bool isUpdating;\r\n        mapping (uint256 => bool) signatures;   //get sign status according to manager index number \r\n    }    \r\n\r\n    mapping (uint256 => EthRecord) private ethRecords;\r\n    uint256[] private pendingEthRecords;     \r\n    uint256 private ethRecordNum;    \r\n    RoleUpdateRecord private operatorRecord;\r\n    RoleUpdateRecord private nftOwnerRecord;\r\n\r\n    constructor(address[] memory _managers, address _operator, address _nftOwner) {        \r\n        require(_managers.length == signCount, \"Invalid manager address count\");  \r\n        require(_operator!= address(0) && !_operator.isContract(), \"Invalid  operator address\");    \r\n        require(_nftOwner!= address(0) && !_nftOwner.isContract(), \"Invalid nftowner address\");         \r\n        for (uint256 i = 0; i < _managers.length; i++) {\r\n            require(!_managers[i].isContract(), \"Invalid manager address\");\r\n            require(!managers[_managers[i]], \"Repeated manager address\");\r\n            managers[_managers[i]] = true;\r\n            managerIndexes[_managers[i]] = i + 1;\r\n        }  \r\n        operator = _operator;\r\n        nftOwner = _nftOwner;              \r\n        _setDomainSeperator();\r\n    }\r\n\r\n    function _setDomainSeperator() internal {\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\r\n                keccak256(bytes(name)),\r\n                keccak256(bytes(version)),                \r\n                bytes32(getChainId()),                             \r\n                address(this) \r\n            )\r\n        );        \r\n    }\r\n\r\n    function getDomainSeperator() public view returns (bytes32) {\r\n        return DOMAIN_SEPARATOR;\r\n    }\r\n\r\n    function getChainId() public view returns (uint256) {\r\n        uint256 id;\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n        return id;\r\n    }   \r\n   \r\n\r\n    //Update operator address using multi-sign\r\n    function updateOperator(address _operatorAddress) external isManager {\r\n        require(_operatorAddress!= address(0) && !_operatorAddress.isContract() && _operatorAddress != operator, \"You can not change operator to zero address or contract based address or same  operator address\");\r\n\r\n        if (!operatorRecord.isUpdating) {\r\n            operatorRecord.to = _operatorAddress;\r\n            operatorRecord.signatureCount = 1;            \r\n            operatorRecord.isUpdating = true;\r\n            operatorRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n        } \r\n        else {\r\n            require(_operatorAddress == operatorRecord.to,\"The new operator address you signed is not requested!\");\r\n            require(!operatorRecord.signatures[managerIndexes[_msgSender()]],\"You have signed!\");\r\n            operatorRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n            operatorRecord.signatureCount+=1;    \r\n            if(operatorRecord.signatureCount >= signedCount){       \r\n                operator = _operatorAddress;\r\n                emit UpdateOperator(_operatorAddress);\r\n                _clearOperatorRecord();\r\n            }\r\n        }        \r\n    }\r\n\r\n    //Cancel to update operator address\r\n    function cancelUpdateOperator() external isManager {\r\n         _clearOperatorRecord();\r\n    }\r\n\r\n     //Update nft owner address using multi-sign\r\n    function updateNFTOwner(address _nftOwnerAddress) external isManager {\r\n        require(_nftOwnerAddress!= address(0) && !_nftOwnerAddress.isContract() && _nftOwnerAddress != nftOwner, \"You can not change nft ownerAddress to zero address or contract based address or same nftowner address\");\r\n\r\n        if (!nftOwnerRecord.isUpdating) {\r\n            nftOwnerRecord.to = _nftOwnerAddress;\r\n            nftOwnerRecord.signatureCount = 1;            \r\n            nftOwnerRecord.isUpdating = true;\r\n            nftOwnerRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n        } \r\n        else {\r\n            require(_nftOwnerAddress == nftOwnerRecord.to,\"The new nftowner address you signed is not requested!\");\r\n            require(!nftOwnerRecord.signatures[managerIndexes[_msgSender()]],\"You have signed!\");\r\n            nftOwnerRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n            nftOwnerRecord.signatureCount+=1;    \r\n            if(nftOwnerRecord.signatureCount >= signedCount){       \r\n                nftOwner = _nftOwnerAddress;\r\n                emit UpdateNFTOwner(_nftOwnerAddress);\r\n                _clearNFTOwnerRecord();\r\n            }\r\n        }  \r\n    }\r\n\r\n    //Cancel to update nft owner address\r\n    function cancelUpdateNFTOwner() external isManager {\r\n         _clearNFTOwnerRecord();\r\n    }\r\n\r\n    //Clear the operatorRecord \r\n    function _clearOperatorRecord() internal {\r\n        operatorRecord.to = address(0);\r\n        operatorRecord.signatureCount = 0;\r\n        operatorRecord.isUpdating = false;\r\n        for (uint256 i = 0; i < signCount; i++) {\r\n            operatorRecord.signatures[i+1] = false;\r\n        }\r\n    }\r\n\r\n    //Clear the nftOwnerRecord \r\n    function _clearNFTOwnerRecord() internal {\r\n        nftOwnerRecord.to = address(0);\r\n        nftOwnerRecord.signatureCount = 0;\r\n        nftOwnerRecord.isUpdating = false;\r\n        for (uint256 i = 0; i < signCount; i++) {\r\n            nftOwnerRecord.signatures[i+1] = false;\r\n        }\r\n    }\r\n\r\n    //get operator updating record\r\n    function getOperatorRecord() external view isManager returns(        \r\n        address _to,\r\n        uint256 _signatureCount,\r\n        bool _isUpdating\r\n        )\r\n    {            \r\n        _to = operatorRecord.to;\r\n        _signatureCount = operatorRecord.signatureCount;\r\n        _isUpdating = operatorRecord.isUpdating;\r\n    }    \r\n\r\n    //get nftowner updating record\r\n    function getNFTOwnerRecord() external view isManager returns(        \r\n        address _to,\r\n        uint256 _signatureCount,\r\n        bool _isUpdating\r\n        )\r\n    {            \r\n        _to = nftOwnerRecord.to;\r\n        _signatureCount = nftOwnerRecord.signatureCount;\r\n        _isUpdating = nftOwnerRecord.isUpdating;\r\n    }    \r\n    \r\n\r\n   //Get the balance of contract\r\n    function getBalance() public view returns(uint){\r\n        return address(this).balance;\r\n    }\r\n\r\n    //Get the current timestamp of block\r\n    function getBlockTimestamp() public view returns(uint){\r\n        return block.timestamp;\r\n    }\r\n\r\n    //Deposit to contract\r\n    function deposit() public payable{}\r\n\r\n    //calculate hash for ERC721Details record\r\n    function _hash(\r\n        ERC721Details memory _erc721Detail\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n                ERC721DETAILS_TYPEHASH,\r\n                _erc721Detail.tokenAddr,\r\n                keccak256(abi.encodePacked(_erc721Detail.ids)),\r\n                keccak256(abi.encodePacked(_erc721Detail.price))\r\n            )\r\n        );\r\n    }\r\n\r\n    //calculate hash for ERC1155Details record\r\n    function _hash(\r\n        ERC1155Details memory _erc1155Detail\r\n    ) internal pure returns (bytes32) {\r\n        return keccak256(abi.encode(\r\n                ERC1155DETAILS_TYPEHASH,\r\n                _erc1155Detail.tokenAddr,\r\n                keccak256(abi.encodePacked(_erc1155Detail.ids)),\r\n                keccak256(abi.encodePacked(_erc1155Detail.amounts)),\r\n                keccak256(abi.encodePacked(_erc1155Detail.unitPrice))\r\n            )\r\n        );\r\n    }\r\n\r\n    //Get message hash to sign for NFTs trade\r\n    function _getMessageHash(\r\n        bytes32 _typeHash,  \r\n        ERC721Details[] memory _erc721Details,\r\n        ERC1155Details[] memory _erc1155Details, \r\n        uint256 _totalPrice,\r\n        uint256 _deadline,\r\n        uint256 _orderId\r\n    ) internal pure returns (bytes32) {   \r\n\r\n        bytes32[] memory erc721Data = new bytes32[](_erc721Details.length);\r\n        bytes32[] memory erc1155Data = new bytes32[](_erc1155Details.length);\r\n\r\n        for (uint256 i = 0; i < _erc721Details.length; i++) {\r\n            erc721Data[i] = _hash(_erc721Details[i]);\r\n        }\r\n\r\n        for (uint256 i = 0; i < _erc1155Details.length; i++) {\r\n            erc1155Data[i] = _hash(_erc1155Details[i]);\r\n        }\r\n\r\n        return keccak256(abi.encode(_typeHash,  \r\n                                    keccak256(abi.encodePacked(erc721Data)), \r\n                                    keccak256(abi.encodePacked(erc1155Data)),  \r\n                                    _totalPrice,\r\n                                    _deadline,\r\n                                    _orderId));\r\n               \r\n    }\r\n\r\n    //Get signed Message \r\n    function _getSignedMessageHash(bytes32 _messageHash)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {       \r\n        return\r\n            keccak256(\r\n                abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, _messageHash)\r\n            );               \r\n    }\r\n    \r\n\r\n    //Verify the trade \r\n    function _verify(        \r\n        bytes32 _typeHash,\r\n        ERC721Details[] memory _erc721Details,\r\n        ERC1155Details[] memory _erc1155Details,  \r\n        uint256 _totalPrice,\r\n        uint256 _deadline,\r\n        uint256 _orderId,\r\n        bytes memory signature\r\n    ) internal view returns (bool) {\r\n        bytes32 messageHash = _getMessageHash(_typeHash, _erc721Details, _erc1155Details, _totalPrice, _deadline, _orderId);\r\n        bytes32 ethSignedMessageHash = _getSignedMessageHash(messageHash);\r\n\r\n        return _recoverSigner(ethSignedMessageHash, signature) == operator;\r\n    }\r\n\r\n    //Recover Signer\r\n    function _recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = _splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    //Calculate r,s,v\r\n    function _splitSignature(bytes memory sig)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(sig.length == 65, \"invalid signature length\");\r\n\r\n        assembly {\r\n            /*\r\n            First 32 bytes stores the length of the signature\r\n\r\n            add(sig, 32) = pointer of sig + 32\r\n            effectively, skips first 32 bytes of signature\r\n\r\n            mload(p) loads next 32 bytes starting at the memory address p into memory\r\n            */\r\n\r\n            // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n            // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n            // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // implicitly return (r, s, v)\r\n    }\r\n   \r\n\r\n    //User sell NFTs\r\n    function sellNFTsForETH( \r\n            ERC721Details[] calldata _erc721Details, \r\n            ERC1155Details[] calldata _erc1155Details,             \r\n            uint256 _totalPrice,          \r\n            uint256 _deadline,\r\n            uint256 _orderId,\r\n            bytes calldata _signature\r\n    ) external nonReentrant whenNotPaused{\r\n        require(_deadline >= block.timestamp, 'Trade expired');        \r\n        require(_totalPrice > 0, 'Price must be granter than zero');\r\n        require(getBalance() >= _totalPrice, 'The liquidity pool is full');   \r\n        require(_msgSender() != nftOwner, \"Seller can not be nftOwner\");        \r\n        require(_verify(            \r\n            SELLNFTSFORETH_TYPEHASH,             \r\n            _erc721Details, \r\n            _erc1155Details, \r\n            _totalPrice,             \r\n            _deadline, \r\n            _orderId,\r\n            _signature), 'INVALID_SIGNATURE');\r\n\r\n        uint256 _ethAmount = 0;\r\n            \r\n        //transfer ERC721 to contract\r\n        for (uint256 i = 0; i < _erc721Details.length; i++) {\r\n            for (uint256 j = 0; j < _erc721Details[i].ids.length; j++) {\r\n                  uint256 _tokenId = _erc721Details[i].ids[j];\r\n                  if (IERC721(_erc721Details[i].tokenAddr).ownerOf(_tokenId) == _msgSender()) {                        \r\n                        IERC721(_erc721Details[i].tokenAddr).safeTransferFrom(\r\n                              _msgSender(),\r\n                              nftOwner,                              \r\n                              _tokenId\r\n                        );\r\n                        _ethAmount = _ethAmount.add(_erc721Details[i].price[j]);\r\n                  }\r\n                  else\r\n                    emit SellERC721Fail(_msgSender(), _erc721Details[i].tokenAddr, _erc721Details[i].ids[j]);                  \r\n            }\r\n        }\r\n\r\n        //transfer ERC1155 to contract\r\n        for (uint256 i = 0; i < _erc1155Details.length; i++) {\r\n            for (uint256 j = 0; j < _erc1155Details[i].ids.length; j++) {  \r\n                uint256 _tokenId = _erc1155Details[i].ids[j]; \r\n                uint256 _amounts =  _erc1155Details[i].amounts[j]; \r\n                uint256 _price = _erc1155Details[i].unitPrice[j];                   \r\n                uint256 _balanceOf = IERC1155(_erc1155Details[i].tokenAddr).balanceOf(_msgSender(), _tokenId); \r\n                if (_balanceOf >= _amounts) {\r\n\r\n                    IERC1155(_erc1155Details[i].tokenAddr).safeTransferFrom(\r\n                        _msgSender(),\r\n                        nftOwner,\r\n                        _tokenId,\r\n                        _amounts,\r\n                        \"\"\r\n                    );\r\n                    _ethAmount = _ethAmount.add(_price.mul(_amounts));\r\n                }    \r\n                else if (_balanceOf > 0) {\r\n                    IERC1155(_erc1155Details[i].tokenAddr).safeTransferFrom(\r\n                        _msgSender(),\r\n                        nftOwner,\r\n                        _tokenId,\r\n                        _balanceOf,\r\n                        \"\"\r\n                    );\r\n                    _ethAmount = _ethAmount.add(_price.mul(_balanceOf));\r\n                    emit SellERC1155Fail(_msgSender(), _erc1155Details[i].tokenAddr, _tokenId, _amounts.sub(_balanceOf));\r\n                }\r\n                else \r\n                    emit SellERC1155Fail(_msgSender(), _erc1155Details[i].tokenAddr, _tokenId, _amounts);\r\n            }\r\n        }        \r\n\r\n        //transfer ETH to user\r\n        payable(_msgSender()).sendValue(_ethAmount);\r\n        emit OrderInfo(_orderId, 0);\r\n    } \r\n    \r\n\r\n    //User buy NFTs \r\n    function buyNFTsForETH(              \r\n        ERC721Details[] calldata _erc721Details, \r\n        ERC1155Details[] calldata _erc1155Details, \r\n        uint256 _totalPrice, \r\n        uint256 _deadline, \r\n        uint256 _orderId,\r\n        bytes calldata _signature\r\n    ) external payable nonReentrant whenNotPaused {\r\n        require(_deadline >= block.timestamp, 'Trade expired');    \r\n        require(_totalPrice > 0, 'Price must be granter than zero');\r\n        require(msg.value >= _totalPrice, \"Less than listing price\");   \r\n        require(_msgSender() != nftOwner, \"Buyer can not be nftOwner\");     \r\n        require(_verify(             \r\n            BUYNFTSFORETH_TYPEHASH,\r\n            _erc721Details, \r\n            _erc1155Details, \r\n            _totalPrice, \r\n            _deadline, \r\n            _orderId,\r\n            _signature), 'INVALID_SIGNATURE');\r\n\r\n        uint256 _ethAmount = msg.value;\r\n\r\n        //transfer ERC721 to user\r\n        for (uint256 i = 0; i < _erc721Details.length; i++) {\r\n            bool _isApproved = IERC721(_erc721Details[i].tokenAddr).isApprovedForAll(nftOwner, address(this));            \r\n            for (uint256 j = 0; j < _erc721Details[i].ids.length; j++) {\r\n                  uint256 _tokenId = _erc721Details[i].ids[j];\r\n                  if (IERC721(_erc721Details[i].tokenAddr).ownerOf(_tokenId) == nftOwner && _isApproved &&                         \r\n                        _ethAmount >= _erc721Details[i].price[j]) {\r\n                        IERC721(_erc721Details[i].tokenAddr).safeTransferFrom(                              \r\n                              nftOwner,\r\n                              _msgSender(),                              \r\n                              _tokenId\r\n                        );\r\n                        _ethAmount = _ethAmount.sub(_erc721Details[i].price[j]);\r\n                  }\r\n                  else\r\n                    emit BuyERC721Fail(_msgSender(), _erc721Details[i].tokenAddr, _tokenId);                  \r\n            }\r\n        }\r\n        \r\n\r\n        //transfer ERC1155 to user\r\n        for (uint256 i = 0; i < _erc1155Details.length; i++) {\r\n            bool _isApproved =  IERC1155(_erc1155Details[i].tokenAddr).isApprovedForAll(nftOwner, address(this));  \r\n            for (uint256 j = 0; j < _erc1155Details[i].ids.length; j++) { \r\n                uint256 _tokenId = _erc1155Details[i].ids[j]; \r\n                uint256 _amounts =  _erc1155Details[i].amounts[j]; \r\n                uint256 _price = _erc1155Details[i].unitPrice[j];                   \r\n                uint256 _balanceOf = IERC1155(_erc1155Details[i].tokenAddr).balanceOf(nftOwner, _tokenId); \r\n                                \r\n                if (_balanceOf >= _amounts && _isApproved && _ethAmount >= _price.mul(_amounts)) {\r\n                    IERC1155(_erc1155Details[i].tokenAddr).safeTransferFrom(                        \r\n                        nftOwner,\r\n                        _msgSender(),\r\n                        _tokenId,\r\n                        _amounts,\r\n                        \"\"\r\n                    );\r\n                    _ethAmount = _ethAmount.sub(_price.mul(_amounts));\r\n                }    \r\n                else if (_balanceOf > 0 && _isApproved && _ethAmount >= _price.mul(_balanceOf)) {\r\n                    IERC1155(_erc1155Details[i].tokenAddr).safeTransferFrom(                        \r\n                        nftOwner,\r\n                        _msgSender(),\r\n                        _tokenId,\r\n                        _balanceOf,\r\n                        \"\"\r\n                    );\r\n                    _ethAmount = _ethAmount.sub(_price.mul(_balanceOf));\r\n                    emit BuyERC1155Fail(_msgSender(), _erc1155Details[i].tokenAddr, _tokenId, \r\n                    _amounts.sub(_balanceOf));\r\n                }\r\n                else \r\n                    emit BuyERC1155Fail(_msgSender(), _erc1155Details[i].tokenAddr, _tokenId, \r\n                    _amounts);\r\n            }        \r\n        }\r\n        \r\n        //transfer remaining ETH to user\r\n        if (_ethAmount > 0)\r\n            payable(_msgSender()).sendValue(_ethAmount);\r\n        emit OrderInfo(_orderId, 1);    \r\n    }   \r\n\r\n    //batch query NFT approved status\r\n    function isApprovedForAll(address[] calldata _nftAddress, bool[] calldata _isERC721) external view returns (bool[] memory) {\r\n        require(_nftAddress.length == _isERC721.length, \"_nftAddress and _isERC721 length mismatch\");\r\n        bool[] memory batchStatuses = new bool[](_nftAddress.length);\r\n\r\n        for (uint256 i = 0; i < _nftAddress.length; i++) {\r\n            if (_isERC721[i]) \r\n                batchStatuses[i] = IERC721(_nftAddress[i]).isApprovedForAll(_msgSender(), address(this));           \r\n            else \r\n                batchStatuses[i] = IERC1155(_nftAddress[i]).isApprovedForAll(_msgSender(), address(this)); \r\n       }\r\n       return batchStatuses;\r\n    }\r\n\r\n\r\n    function supportsInterface(bytes4 _interfaceId)\r\n        external\r\n        virtual\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _interfaceId == this.supportsInterface.selector;\r\n    }\r\n\r\n    receive() external payable {}\r\n    \r\n\r\n    //start a eth withdraw request using multiple signatures\r\n    function requestWithdrawETH(address _recipient, uint256 _amount) external{\r\n        require(managers[_msgSender()], \"Only manager can withdraw eth!\");\r\n        require(_recipient != address(0), \"Transfer to the zero address\");\r\n        require(address(this).balance >= _amount,\"Insufficient Balance\");\r\n\r\n        uint256 ethRecordId = ethRecordNum++;  \r\n        EthRecord storage ethRecord =ethRecords[ethRecordId];\r\n        ethRecord.from = _msgSender();      \r\n        ethRecord.to = _recipient;\r\n        ethRecord.amount = _amount;\r\n        ethRecord.signatureCount = 1;\r\n        ethRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n        ethRecord.isEnd = false;\r\n        pendingEthRecords.push(ethRecordId);\r\n        emit EthRecordCreated(_msgSender(), _recipient, _amount, ethRecordId);\r\n    }   \r\n\r\n    //get pending withdraw transactions list\r\n    function getPendingWithdraws() public isManager view returns(uint256[] memory){    \r\n        return pendingEthRecords;\r\n    }\r\n\r\n    //get withdraw transaction's information\r\n    function getWithdrawInfo(uint256 _ethRecordId) external isManager view returns(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount,\r\n        uint256 _signatureCount,\r\n        bool _isEnd\r\n        )\r\n    {    \r\n        _from = ethRecords[_ethRecordId].from;\r\n        _to = ethRecords[_ethRecordId].to;\r\n        _amount = ethRecords[_ethRecordId].amount;\r\n        _signatureCount = ethRecords[_ethRecordId].signatureCount;\r\n        _isEnd = ethRecords[_ethRecordId].isEnd;\r\n    }    \r\n\r\n    //change manager address\r\n    function delegate(address _delegateTo) external isManager{  \r\n        require(_delegateTo != address(0), \"You can not delegate to the zero address\");\r\n        require(_delegateTo !=_msgSender(),\"You can not delegate to yourself\");\r\n        require(!managers[_delegateTo],\"You can not delegate to other manager\");\r\n        managers[_delegateTo] = true;  \r\n        managerIndexes[_delegateTo] = managerIndexes[_msgSender()];\r\n        managers[_msgSender()] = false;\r\n        managerIndexes[_msgSender()] = 0;\r\n        emit Delegate(_msgSender(), _delegateTo);\r\n    }\r\n\r\n    //sign for eth withdraw using multi-sign\r\n    function signEthRecord(uint256 _ethRecordId) external isManager{\r\n        EthRecord storage ethRecord = ethRecords[_ethRecordId];\r\n        require(!ethRecord.isEnd, \"This transaction is closed\");\r\n        require(ethRecord.from != _msgSender(), \"You can not sign the transaction you request\");\r\n        require(!ethRecord.signatures[managerIndexes[_msgSender()]],\"You have signed the transaction!\");\r\n        ethRecord.signatures[managerIndexes[_msgSender()]] = true;\r\n        ethRecord.signatureCount+=1;       \r\n        if(ethRecord.signatureCount >= signedCount ){       \r\n            require(address(this).balance >= ethRecord.amount, \"Insufficient Balance\"); \r\n            payable(ethRecord.to).sendValue(ethRecord.amount); \r\n            emit WithdrawETH(ethRecord.to, ethRecord.amount);\r\n            closeTransactions(_ethRecordId);\r\n        }\r\n    }\r\n\r\n    //delete withdraw transaction in case the array is over\r\n    function closeTransactions(uint256 _ethRecordId) public isManager{        \r\n        require(!ethRecords[_ethRecordId].isEnd, \"This transaction is closed\");\r\n        uint256 temp = 0;\r\n        for(uint256 i = 0; i< pendingEthRecords.length; i++){\r\n            if(1 == temp){\r\n                pendingEthRecords[i-1] = pendingEthRecords[i];\r\n            }else if(_ethRecordId == pendingEthRecords[i]){\r\n                temp = 1;\r\n            }\r\n        }\r\n        require(temp == 1, \"The _ethRecordId does not exist.\");\r\n        delete pendingEthRecords[pendingEthRecords.length - 1];\r\n        pendingEthRecords.pop();\r\n        ethRecords[_ethRecordId].isEnd = true;   \r\n        emit CloseTransactions(_ethRecordId);\r\n    }\r\n\r\n    //Pause trade\r\n    function pause() external isManager whenNotPaused {\r\n        _pause();\r\n    }\r\n\r\n    //Unpause trade\r\n    function unpause() external isManager whenPaused {\r\n        _unpause();\r\n    }    \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_managers\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_nftOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amounts\",\"type\":\"uint256\"}],\"name\":\"BuyERC1155Fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"BuyERC721Fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRecordId\",\"type\":\"uint256\"}],\"name\":\"CloseTransactions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Delegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRecordId\",\"type\":\"uint256\"}],\"name\":\"EthRecordCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tradeType\",\"type\":\"uint256\"}],\"name\":\"OrderInfo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amounts\",\"type\":\"uint256\"}],\"name\":\"SellERC1155Fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"SellERC721Fail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftOwnerAddress\",\"type\":\"address\"}],\"name\":\"UpdateNFTOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorAddress\",\"type\":\"address\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawETH\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"price\",\"type\":\"uint256[]\"}],\"internalType\":\"struct VirgoInstantLiquidity.ERC721Details[]\",\"name\":\"_erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"unitPrice\",\"type\":\"uint256[]\"}],\"internalType\":\"struct VirgoInstantLiquidity.ERC1155Details[]\",\"name\":\"_erc1155Details\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"buyNFTsForETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUpdateNFTOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelUpdateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethRecordId\",\"type\":\"uint256\"}],\"name\":\"closeTransactions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_delegateTo\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeperator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNFTOwnerRecord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_signatureCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isUpdating\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOperatorRecord\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_signatureCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isUpdating\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingWithdraws\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethRecordId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_signatureCount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isEnd\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nftAddress\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isERC721\",\"type\":\"bool[]\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managerIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"requestWithdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"price\",\"type\":\"uint256[]\"}],\"internalType\":\"struct VirgoInstantLiquidity.ERC721Details[]\",\"name\":\"_erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"unitPrice\",\"type\":\"uint256[]\"}],\"internalType\":\"struct VirgoInstantLiquidity.ERC1155Details[]\",\"name\":\"_erc1155Details\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_orderId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"sellNFTsForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethRecordId\",\"type\":\"uint256\"}],\"name\":\"signEthRecord\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftOwnerAddress\",\"type\":\"address\"}],\"name\":\"updateNFTOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operatorAddress\",\"type\":\"address\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VirgoInstantLiquidity", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000ad0d0ac8d984919a13d92e26c39331f7c0d7b17e000000000000000000000000e01d4c746ea3ce5ade7b4f6c9e5506fef72099c00000000000000000000000000000000000000000000000000000000000000003000000000000000000000000e01d4c746ea3ce5ade7b4f6c9e5506fef72099c0000000000000000000000000ad0d0ac8d984919a13d92e26c39331f7c0d7b17e000000000000000000000000b626d0146861411ad472ff2e4d92422d07430c57", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7ce2d805db2ec2a2ebe172b15850e6b4bf88db476ccdfa53075c047286ac6d38"}]}