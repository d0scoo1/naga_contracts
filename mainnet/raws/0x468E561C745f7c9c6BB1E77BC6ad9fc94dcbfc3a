{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.9.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC777/IERC777.sol@v4.3.3\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777Token standard as defined in the EIP.\r\n *\r\n * This contract uses the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 registry standard] to let\r\n * token holders and recipients react to token movements by using setting implementers\r\n * for the associated interfaces in said registry. See {IERC1820Registry} and\r\n * {ERC1820Implementer}.\r\n */\r\ninterface IERC777 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the smallest part of the token that is not divisible. This\r\n     * means all token operations (creation, movement and destruction) must have\r\n     * amounts that are a multiple of this number.\r\n     *\r\n     * For most token contracts, this value will equal 1.\r\n     */\r\n    function granularity() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`owner`).\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * If send or receive hooks are registered for the caller and `recipient`,\r\n     * the corresponding functions will be called with `data` and empty\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function send(\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from the caller's account, reducing the\r\n     * total supply.\r\n     *\r\n     * If a send hook is registered for the caller, the corresponding function\r\n     * will be called with `data` and empty `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - the caller must have at least `amount` tokens.\r\n     */\r\n    function burn(uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev Returns true if an account is an operator of `tokenHolder`.\r\n     * Operators can send and burn tokens on behalf of their owners. All\r\n     * accounts are their own operator.\r\n     *\r\n     * See {operatorSend} and {operatorBurn}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Make an account an operator of the caller.\r\n     *\r\n     * See {isOperatorFor}.\r\n     *\r\n     * Emits an {AuthorizedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function authorizeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Revoke an account's operator status for the caller.\r\n     *\r\n     * See {isOperatorFor} and {defaultOperators}.\r\n     *\r\n     * Emits a {RevokedOperator} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `operator` cannot be calling address.\r\n     */\r\n    function revokeOperator(address operator) external;\r\n\r\n    /**\r\n     * @dev Returns the list of default operators. These accounts are operators\r\n     * for all token holders, even if {authorizeOperator} was never called on\r\n     * them.\r\n     *\r\n     * This list is immutable, but individual holders may revoke these via\r\n     * {revokeOperator}, in which case {isOperatorFor} will return false.\r\n     */\r\n    function defaultOperators() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient`. The caller must\r\n     * be an operator of `sender`.\r\n     *\r\n     * If send or receive hooks are registered for `sender` and `recipient`,\r\n     * the corresponding functions will be called with `data` and\r\n     * `operatorData`. See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits a {Sent} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `sender` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `sender`.\r\n     * - `recipient` cannot be the zero address.\r\n     * - if `recipient` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the total supply.\r\n     * The caller must be an operator of `account`.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `data` and `operatorData`. See {IERC777Sender}.\r\n     *\r\n     * Emits a {Burned} event.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     * - the caller must be an operator for `account`.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes calldata data,\r\n        bytes calldata operatorData\r\n    ) external;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes data,\r\n        bytes operatorData\r\n    );\r\n\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes data, bytes operatorData);\r\n\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC777/IERC777Sender.sol@v4.3.3\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensSender standard as defined in the EIP.\r\n *\r\n * {IERC777} Token holders can be notified of operations performed on their\r\n * tokens by having a contract implement this interface (contract holders can be\r\n * their own implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Sender {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever a registered holder's\r\n     * (`from`) tokens are about to be moved or destroyed. The type of operation\r\n     * is conveyed by `to` being the zero address or not.\r\n     *\r\n     * This call occurs _before_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the pre-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC777/IERC777Recipient.sol@v4.3.3\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\r\n *\r\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\r\n * contract implement this interface (contract holders can be their own\r\n * implementer) and registering it on the\r\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\r\n *\r\n * See {IERC1820Registry} and {ERC1820Implementer}.\r\n */\r\ninterface IERC777Recipient {\r\n    /**\r\n     * @dev Called by an {IERC777} token contract whenever tokens are being\r\n     * moved or created into a registered account (`to`). The type of operation\r\n     * is conveyed by `from` being the zero address or not.\r\n     *\r\n     * This call occurs _after_ the token contract's state is updated, so\r\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\r\n     *\r\n     * This function may revert to prevent the operation from being executed.\r\n     */\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata userData,\r\n        bytes calldata operatorData\r\n    ) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.3\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC1820Registry.sol@v4.3.3\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the global ERC1820 Registry, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1820[EIP]. Accounts may register\r\n * implementers for interfaces in this registry, as well as query support.\r\n *\r\n * Implementers may be shared by multiple accounts, and can also implement more\r\n * than a single interface for each account. Contracts can implement interfaces\r\n * for themselves, but externally-owned accounts (EOA) must delegate this to a\r\n * contract.\r\n *\r\n * {IERC165} interfaces can also be queried via the registry.\r\n *\r\n * For an in-depth explanation and source code analysis, see the EIP text.\r\n */\r\ninterface IERC1820Registry {\r\n    /**\r\n     * @dev Sets `newManager` as the manager for `account`. A manager of an\r\n     * account is able to set interface implementers for it.\r\n     *\r\n     * By default, each account is its own manager. Passing a value of `0x0` in\r\n     * `newManager` will reset the manager to this initial state.\r\n     *\r\n     * Emits a {ManagerChanged} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     */\r\n    function setManager(address account, address newManager) external;\r\n\r\n    /**\r\n     * @dev Returns the manager for `account`.\r\n     *\r\n     * See {setManager}.\r\n     */\r\n    function getManager(address account) external view returns (address);\r\n\r\n    /**\r\n     * @dev Sets the `implementer` contract as ``account``'s implementer for\r\n     * `interfaceHash`.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     * The zero address can also be used in `implementer` to remove an old one.\r\n     *\r\n     * See {interfaceHash} to learn how these are created.\r\n     *\r\n     * Emits an {InterfaceImplementerSet} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be the current manager for `account`.\r\n     * - `interfaceHash` must not be an {IERC165} interface id (i.e. it must not\r\n     * end in 28 zeroes).\r\n     * - `implementer` must implement {IERC1820Implementer} and return true when\r\n     * queried for support, unless `implementer` is the caller. See\r\n     * {IERC1820Implementer-canImplementInterfaceForAddress}.\r\n     */\r\n    function setInterfaceImplementer(\r\n        address account,\r\n        bytes32 _interfaceHash,\r\n        address implementer\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the implementer of `interfaceHash` for `account`. If no such\r\n     * implementer is registered, returns the zero address.\r\n     *\r\n     * If `interfaceHash` is an {IERC165} interface id (i.e. it ends with 28\r\n     * zeroes), `account` will be queried for support of it.\r\n     *\r\n     * `account` being the zero address is an alias for the caller's address.\r\n     */\r\n    function getInterfaceImplementer(address account, bytes32 _interfaceHash) external view returns (address);\r\n\r\n    /**\r\n     * @dev Returns the interface hash for an `interfaceName`, as defined in the\r\n     * corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-1820#interface-name[section of the EIP].\r\n     */\r\n    function interfaceHash(string calldata interfaceName) external pure returns (bytes32);\r\n\r\n    /**\r\n     * @notice Updates the cache with whether the contract implements an ERC165 interface or not.\r\n     * @param account Address of the contract for which to update the cache.\r\n     * @param interfaceId ERC165 interface for which to update the cache.\r\n     */\r\n    function updateERC165Cache(address account, bytes4 interfaceId) external;\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not.\r\n     * If the result is not cached a direct lookup on the contract address is performed.\r\n     * If the result is not cached or the cached value is out-of-date, the cache MUST be updated manually by calling\r\n     * {updateERC165Cache} with the contract address.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165Interface(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Checks whether a contract implements an ERC165 interface or not without using nor updating the cache.\r\n     * @param account Address of the contract to check.\r\n     * @param interfaceId ERC165 interface to check.\r\n     * @return True if `account` implements `interfaceId`, false otherwise.\r\n     */\r\n    function implementsERC165InterfaceNoCache(address account, bytes4 interfaceId) external view returns (bool);\r\n\r\n    event InterfaceImplementerSet(address indexed account, bytes32 indexed interfaceHash, address indexed implementer);\r\n\r\n    event ManagerChanged(address indexed account, address indexed newManager);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IDiamondCut.sol\r\n\r\npragma solidity 0.8.12;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n\r\n// File contracts/libraries/LibDiamond.sol\r\n\r\npragma solidity 0.8.12;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        // maps function selectors to the facets that execute the functions.\r\n        // and maps the selectors to their position in the selectorSlots array.\r\n        // func selector => address facet, selector position\r\n        mapping(bytes4 => bytes32) facets;\r\n        // array of slots of function selectors.\r\n        // each slot holds 8 function selectors.\r\n        mapping(uint256 => bytes32) selectorSlots; \r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        //\r\n        // The number of function selectors in selectorSlots\r\n        uint16 selectorCount;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(msg.sender == diamondStorage().contractOwner, \"Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\" \r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(address(bytes20(oldFacet)) == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n                // add facet for selector\r\n                ds.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot = (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) | (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(oldFacetAddress != _newFacetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                ds.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\" \r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; selectorIndex++) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(address(bytes20(oldFacet)) != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n                    // only useful if immutable functions exist\r\n                    require(address(bytes20(oldFacet)) != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n                    // replace selector with last selector in ds.facets\r\n                    // gets the last selector\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        ds.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\" \r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address _contract) internal view returns (bool) {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        return contractSize > 0;\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        require(isContract(_contract), _errorMessage);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/facets/MNFTERC777Facet.sol\r\n\r\npragma solidity 0.8.12;\r\n\r\n\r\n\r\n\r\n\r\nstruct ERC777Storage {\r\n    mapping(address => uint256) _balances;\r\n\r\n    uint256 _totalSupply;\r\n\r\n    string _name;\r\n    string _symbol;\r\n\r\n    // This isn't ever read from - it's only used to respond to the defaultOperators query.\r\n    address[] _defaultOperatorsArray;\r\n\r\n    // Immutable, but accounts may revoke them (tracked in __revokedDefaultOperators).\r\n    mapping(address => bool) _defaultOperators;\r\n\r\n    // For each account, a mapping of its operators and revoked default operators.\r\n    mapping(address => mapping(address => bool)) _operators;\r\n    mapping(address => mapping(address => bool)) _revokedDefaultOperators;\r\n\r\n    // ERC20-allowances\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n\r\n    // Disable reentrancy\r\n    uint256 _entered;\r\n\r\n    // Mapping of partners with associated cashback rate multiplied by 100\r\n    // mapping(address => uint16) _partners;\r\n\r\n}\r\n\r\ncontract MNFTERC777Facet is IERC777, IERC20 {\r\n\r\n    event PartnerAdded(address indexed partner, uint16 cashbackRate);\r\n    event PartnerUpdated(address indexed partner, uint16 cashbackRate);\r\n    event PartnerRemoved(address indexed partner);\r\n\r\n    function getERC777Storage() internal pure returns(ERC777Storage storage es) {\r\n        // es.slot = keccak256(\"mnft.erc777.storage\")\r\n        assembly {\r\n            es.slot := 0x8fb040e626dc81be524f960fd04848fa1f8d9000e8b837b9a8ed86951edba988\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-name}.\r\n     */\r\n    function name() external view override returns (string memory) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n        return es._name;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-symbol}.\r\n     */\r\n    function symbol() external view override returns (string memory) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n        return es._symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-decimals}.\r\n     *\r\n     * Always returns 18, as per the\r\n     * [ERC777 EIP](https://eips.ethereum.org/EIPS/eip-777#backward-compatibility).\r\n     */\r\n    function decimals() external pure returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-granularity}.\r\n     *\r\n     * This implementation always returns `1`.\r\n     */\r\n    function granularity() external pure override returns (uint256) {\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-totalSupply}.\r\n     */\r\n    function totalSupply() external view override(IERC20, IERC777) returns (uint256) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n        return es._totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by an account (`tokenHolder`).\r\n     */\r\n    function balanceOf(address tokenHolder) external view override(IERC20, IERC777) returns (uint256) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n        return es._balances[tokenHolder];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-send}.\r\n     *\r\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\r\n     */\r\n    function send(\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data\r\n    ) external override {\r\n        _send(msg.sender, recipient, amount, data, \"\", true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\r\n     * interface if it is a contract.\r\n     *\r\n     * Also emits a {Sent} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n        require(getERC777Storage()._entered == 0, 'Undergoing transaction');\r\n\r\n        address from = msg.sender;\r\n\r\n        _callTokensToSend(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _move(from, from, recipient, amount, \"\", \"\");\r\n\r\n        _callTokensReceived(from, from, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-burn}.\r\n     *\r\n     * Also emits a {IERC20-Transfer} event for ERC20 compatibility.\r\n     */\r\n    function burn(uint256 amount, bytes memory data) external override {\r\n        _burn(msg.sender, amount, data, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-isOperatorFor}.\r\n     */\r\n    function isOperatorFor(address operator, address tokenHolder) external view override returns (bool) {\r\n        return _isOperatorFor(operator, tokenHolder);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-isOperatorFor}.\r\n     */\r\n    function _isOperatorFor(address operator, address tokenHolder) internal view returns (bool) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        return\r\n            operator == tokenHolder ||\r\n            (es._defaultOperators[operator] && !es._revokedDefaultOperators[tokenHolder][operator]) ||\r\n            es._operators[tokenHolder][operator];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-authorizeOperator}.\r\n     */\r\n    function authorizeOperator(address operator) external override {\r\n        require(msg.sender != operator, \"ERC777: authorizing self as operator\");\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        if (es._defaultOperators[operator]) {\r\n            delete es._revokedDefaultOperators[msg.sender][operator];\r\n        } else {\r\n            es._operators[msg.sender][operator] = true;\r\n        }\r\n\r\n        emit AuthorizedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-revokeOperator}.\r\n     */\r\n    function revokeOperator(address operator) external override {\r\n        require(operator != msg.sender, \"ERC777: revoking self as operator\");\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        if (es._defaultOperators[operator]) {\r\n            es._revokedDefaultOperators[msg.sender][operator] = true;\r\n        } else {\r\n            delete es._operators[msg.sender][operator];\r\n        }\r\n\r\n        emit RevokedOperator(operator, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-defaultOperators}.\r\n     */\r\n    function defaultOperators() external view override returns (address[] memory) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        return es._defaultOperatorsArray;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorSend}.\r\n     *\r\n     * Emits {Sent} and {IERC20-Transfer} events.\r\n     */\r\n    function operatorSend(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) external override {\r\n        require(_isOperatorFor(msg.sender, sender), \"ERC777: caller is not an operator for holder\");\r\n        _send(sender, recipient, amount, data, operatorData, true);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC777-operatorBurn}.\r\n     *\r\n     * Emits {Burned} and {IERC20-Transfer} events.\r\n     */\r\n    function operatorBurn(\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) external override {\r\n        require(_isOperatorFor(msg.sender, account), \"ERC777: caller is not an operator for holder\");\r\n        _burn(account, amount, data, operatorData);\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators may\r\n     * not have allowance, and accounts with allowance may not be operators\r\n     * themselves.\r\n     */\r\n    function allowance(address holder, address spender) external view override returns (uint256) {\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        return es._allowances[holder][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * Note that accounts cannot have allowance issued by their operators.\r\n     */\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        address holder = msg.sender;\r\n        _approve(holder, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators cannot\r\n     * call `transferFrom` (unless they have allowance), and accounts with\r\n     * allowance cannot call `operatorSend` (unless they are operators).\r\n     *\r\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\r\n     */\r\n    function transferFrom(\r\n        address holder,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\r\n        \r\n        ERC777Storage storage es = getERC777Storage();\r\n        require(es._entered == 0, 'Undergoing transaction');\r\n\r\n        address spender = msg.sender;\r\n\r\n        _callTokensToSend(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n        _move(spender, holder, recipient, amount, \"\", \"\");\r\n\r\n       \r\n        uint256 currentAllowance = es._allowances[holder][spender];\r\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\r\n        _approve(holder, spender, currentAllowance - amount);\r\n\r\n        _callTokensReceived(spender, holder, recipient, amount, \"\", \"\", false);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * If a send hook is registered for `account`, the corresponding function\r\n     * will be called with `operator`, `data` and `operatorData`.\r\n     *\r\n     * See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits {Minted} and {IERC20-Transfer} events.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function mint(\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    ) external {\r\n        LibDiamond.enforceIsContractOwner();\r\n        _mint(account, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * If `requireReceptionAck` is set to true, and if a send hook is\r\n     * registered for `account`, the corresponding function will be called with\r\n     * `operator`, `data` and `operatorData`.\r\n     *\r\n     * See {IERC777Sender} and {IERC777Recipient}.\r\n     *\r\n     * Emits {Minted} and {IERC20-Transfer} events.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - if `account` is a contract, it must implement the {IERC777Recipient}\r\n     * interface.\r\n     */\r\n    function _mint(\r\n        address account,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    ) internal {\r\n        require(account != address(0), \"ERC777: mint to the zero address\");\r\n        ERC777Storage storage es = getERC777Storage();\r\n\r\n        require((es._totalSupply + amount) <= 4200000000000000000000000000 , 'Mint amount exceed total supply');\r\n\r\n        address operator = msg.sender;\r\n\r\n        _beforeTokenTransfer(operator, address(0), account, amount);\r\n\r\n        unchecked {\r\n            es._totalSupply += amount;\r\n            es._balances[account] += amount;\r\n        }\r\n\r\n        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);\r\n\r\n        emit Minted(operator, account, amount, userData, operatorData);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _send(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    ) internal {\r\n        require(from != address(0), \"ERC777: send from the zero address\");\r\n        require(to != address(0), \"ERC777: send to the zero address\");\r\n        require(getERC777Storage()._entered == 0, 'Undergoing transaction');\r\n\r\n        address operator = msg.sender;\r\n\r\n        _callTokensToSend(operator, from, to, amount, userData, operatorData);\r\n\r\n        _move(operator, from, to, amount, userData, operatorData);\r\n\r\n        _callTokensReceived(operator, from, to, amount, userData, operatorData, requireReceptionAck);\r\n    }\r\n\r\n    /**\r\n     * @dev Burn tokens\r\n     * @param from address token holder address\r\n     * @param amount uint256 amount of tokens to burn\r\n     * @param data bytes extra information provided by the token holder\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _burn(\r\n        address from,\r\n        uint256 amount,\r\n        bytes memory data,\r\n        bytes memory operatorData\r\n    ) internal {\r\n        LibDiamond.enforceIsContractOwner();\r\n        require(from != address(0), \"ERC777: burn from the zero address\");\r\n\r\n        ERC777Storage storage es = getERC777Storage();\r\n        require(es._entered == 0, \"Undergoing account transaction\");\r\n\r\n        address operator = msg.sender;\r\n\r\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\r\n\r\n        _beforeTokenTransfer(operator, from, address(0), amount);\r\n\r\n        // Update state variables\r\n        uint256 fromBalance = es._balances[from];\r\n        require(fromBalance >= amount, \"ERC777: burn amount exceeds balance\");\r\n        unchecked {\r\n            es._balances[from] = fromBalance - amount;\r\n            es._totalSupply -= amount;\r\n        }\r\n\r\n        emit Burned(operator, from, amount, data, operatorData);\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n\r\n    function _move(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    ) private {\r\n        _beforeTokenTransfer(operator, from, to, amount);\r\n        ERC777Storage storage es = getERC777Storage();\r\n        // unchecked {\r\n        //     amount = amount * 1000 * (10000 - es._partners[to]) / 10000 / 1000;\r\n        // }\r\n        uint256 fromBalance = es._balances[from];\r\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\r\n        unchecked {\r\n            es._balances[from] = fromBalance - amount;\r\n            es._balances[to] += amount;\r\n        }\r\n\r\n        emit Sent(operator, from, to, amount, userData, operatorData);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev See {ERC20-_approve}.\r\n     *\r\n     * Note that accounts cannot have allowance issued by their operators.\r\n     */\r\n    function _approve(\r\n        address holder,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(holder != address(0), \"ERC777: approve from the zero address\");\r\n        require(spender != address(0), \"ERC777: approve to the zero address\");\r\n        \r\n        ERC777Storage storage es = getERC777Storage();\r\n        es._allowances[holder][spender] = value;\r\n        emit Approval(holder, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Call from.tokensToSend() if the interface is registered\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     */\r\n    function _callTokensToSend(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData\r\n    ) private {\r\n        address implementer = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\r\n                                .getInterfaceImplementer(from, 0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895);\r\n        if (implementer != address(0)) {\r\n            ERC777Storage storage es = getERC777Storage();\r\n            es._entered = 1;\r\n            IERC777Sender(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\r\n            es._entered = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Call to.tokensReceived() if the interface is registered. Reverts if the recipient is a contract but\r\n     * tokensReceived() was not registered for the recipient\r\n     * @param operator address operator requesting the transfer\r\n     * @param from address token holder address\r\n     * @param to address recipient address\r\n     * @param amount uint256 amount of tokens to transfer\r\n     * @param userData bytes extra information provided by the token holder (if any)\r\n     * @param operatorData bytes extra information provided by the operator (if any)\r\n     * @param requireReceptionAck if true, contract recipients are required to implement ERC777TokensRecipient\r\n     */\r\n    function _callTokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes memory userData,\r\n        bytes memory operatorData,\r\n        bool requireReceptionAck\r\n    ) private {\r\n        address implementer = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\r\n                                .getInterfaceImplementer(to, 0xb281fc8c12954d22544db45de3159a39272895b169a852b314f9cc762e44c53b);\r\n        if (implementer != address(0)) {\r\n            IERC777Recipient(implementer).tokensReceived(operator, from, to, amount, userData, operatorData);\r\n        } else if (requireReceptionAck) {\r\n            require(!LibDiamond.isContract(to), \"ERC777: token recipient contract has no implementer for ERC777TokensRecipient\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. This includes\r\n     * calls to {send}, {transfer}, {operatorSend}, minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {}\r\n\r\n    // /** \r\n    // @notice Add a new partner with a specific cashback rate\r\n    // @param partner The partner's account address.\r\n    // @param cashbackRate The cashback rate on transaction with this partner\r\n    //  */\r\n    // function addPartner(address partner, uint16 cashbackRate) external {\r\n    //     LibDiamond.enforceIsContractOwner();\r\n    //     require(cashbackRate > 0 && cashbackRate < 10000, \"Cashback rate must >0 and <10000\");\r\n    //     ERC777Storage storage es = getERC777Storage();\r\n    //     require(es._partners[partner] == 0, \"Partner already exists.\");\r\n    //     es._partners[partner] = cashbackRate;\r\n    //     emit PartnerAdded(partner, cashbackRate);\r\n    // }\r\n\r\n    // /** \r\n    // @notice Update a partner with a new cashback rate\r\n    // @param partner The partner's account address.\r\n    // @param cashbackRate The cashback rate on transaction with this partner\r\n    //  */\r\n    // function updatePartner(address partner, uint16 cashbackRate) external {\r\n    //     LibDiamond.enforceIsContractOwner();\r\n    //     require(cashbackRate > 0 && cashbackRate < 10000, \"Cashback rate must >0 and <10000\");\r\n    //     ERC777Storage storage es = getERC777Storage();\r\n    //     require(cashbackRate != es._partners[partner], \"Cashback rate not modified.\");\r\n    //     es._partners[partner] = cashbackRate;\r\n    //     emit PartnerUpdated(partner, cashbackRate);\r\n    // }\r\n\r\n    // /** \r\n    // @notice Remove partner\r\n    // @param partner The partner's account address.\r\n    //  */\r\n    // function removePartner(address partner) external {\r\n    //     LibDiamond.enforceIsContractOwner();\r\n    //     ERC777Storage storage es = getERC777Storage();\r\n    //     delete es._partners[partner];\r\n    //     emit PartnerRemoved(partner);\r\n    // }\r\n\r\n    function withdrawEth() external {\r\n        LibDiamond.enforceIsContractOwner();\r\n        (bool os, ) = payable(LibDiamond.diamondStorage().contractOwner).call{value: address(this).balance}(\"\");\r\n        require(os);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/facets/TransferUpdateFacet.sol\r\n\r\npragma solidity 0.8.12;\r\n\r\ncontract TransferUpdateFacet {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Unlike `send`, `recipient` is _not_ required to implement the {IERC777Recipient}\r\n     * interface if it is a contract.\r\n     *\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n\r\n        ERC777Storage storage es;\r\n        assembly {\r\n            es.slot := 0x8fb040e626dc81be524f960fd04848fa1f8d9000e8b837b9a8ed86951edba988\r\n        }\r\n        uint256 fromBalance = es._balances[msg.sender];\r\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\r\n\r\n        unchecked {\r\n            es._balances[msg.sender] = fromBalance - amount;\r\n            es._balances[recipient] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Note that operator and allowance concepts are orthogonal: operators cannot\r\n     * call `transferFrom` (unless they have allowance), and accounts with\r\n     * allowance cannot call `operatorSend` (unless they are operators).\r\n     *\r\n     * Emits {Sent}, {IERC20-Transfer} and {IERC20-Approval} events.\r\n     */\r\n    function transferFrom(\r\n        address holder,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool) {\r\n        require(recipient != address(0), \"ERC777: transfer to the zero address\");\r\n        require(holder != address(0), \"ERC777: transfer from the zero address\");\r\n        require(msg.sender != address(0), \"ERC777: ERC777: approve to the zero address\");\r\n        \r\n        ERC777Storage storage es;\r\n        assembly {\r\n            es.slot := 0x8fb040e626dc81be524f960fd04848fa1f8d9000e8b837b9a8ed86951edba988\r\n        }\r\n        uint256 fromBalance = es._balances[holder];\r\n        require(fromBalance >= amount, \"ERC777: transfer amount exceeds balance\");\r\n\r\n        uint256 currentAllowance = es._allowances[holder][msg.sender];\r\n        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");\r\n\r\n        uint256 newAllowance;\r\n        unchecked {\r\n            es._balances[holder] = fromBalance - amount;\r\n            es._balances[recipient] += amount;\r\n            newAllowance = currentAllowance - amount;\r\n        }\r\n        es._allowances[holder][msg.sender] = newAllowance;\r\n\r\n        emit Approval(holder, msg.sender, newAllowance);\r\n        emit Transfer(holder, recipient, amount);\r\n\r\n        return true;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TransferUpdateFacet", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cd91fc80af32fd699f1d050e05149d69a3e4c6b989e6fe3537e609628b2f235b"}]}