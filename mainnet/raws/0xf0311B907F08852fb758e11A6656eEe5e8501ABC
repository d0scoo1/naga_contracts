{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// Part: IDiamondLoupe\r\n\r\ninterface IDiamondLoupe {\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n  \r\n  function facets() external view returns (Facet[] memory facets_);\r\n\r\n    function facetFunctionSelectors(address _facet)\r\n        external\r\n        view\r\n        returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    function facetAddresses()\r\n        external\r\n        view\r\n        returns (address[] memory facetAddresses_);\r\n\r\n    function facetAddress(bytes4 _functionSelector)\r\n        external\r\n        view\r\n        returns (address facetAddress_);\r\n}\r\n\r\n// Part: IERC165\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// Part: IERC173\r\n\r\ninterface IERC173 {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function owner() external view returns (address owner_);\r\n\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\n\r\n// Part: IERC20\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n\r\npragma solidity 0.8.11;\r\n// Part: IDiamondCut\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {\r\n        Add,\r\n        Replace,\r\n        Remove\r\n    }\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n\r\n// Part: LibDiamond\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION =\r\n        keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        mapping(bytes4 => bytes32) facets;\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        uint16 selectorCount;\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        address contractOwner;\r\n        mapping(address => bool) isOwner;\r\n    }\r\n\r\n    function diamondStorage()\r\n        internal\r\n        pure\r\n        returns (DiamondStorage storage ds)\r\n    {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n    \r\n    DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(\r\n            msg.sender == diamondStorage().contractOwner,\r\n            \"Must be contract owner\"\r\n        );\r\n    }\r\n\r\n    event DiamondCut(\r\n        IDiamondCut.FacetCut[] _diamondCut,\r\n        address _init,\r\n        bytes _calldata\r\n    );\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        if (selectorCount & 7 > 0) {\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (\r\n            uint256 facetIndex;\r\n            facetIndex < _diamondCut.length;\r\n            facetIndex++\r\n        ) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n  \r\n          enforceHasContractCode(_newFacetAddress, \"Add facet has no code\");\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(\r\n                    address(bytes20(oldFacet)) == address(0),\r\n                    \"Can't add function that already exists\"\r\n                );\r\n                ds.facets[selector] =\r\n                    bytes20(_newFacetAddress) |\r\n                    bytes32(_selectorCount);\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                _selectorSlot =\r\n                    (_selectorSlot &\r\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n                if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n            }\r\n \r\n       } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(\r\n                _newFacetAddress,\r\n                \"Replace facet has no code\"\r\n            );\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                require(\r\n                    oldFacetAddress != address(this),\r\n                    \"Can't replace immutable function\"\r\n                );\r\n       \r\n         require(\r\n                    oldFacetAddress != _newFacetAddress,\r\n                    \"Can't replace function with same function\"\r\n                );\r\n                require(\r\n                    oldFacetAddress != address(0),\r\n                    \"Can't replace function that doesn't exist\"\r\n                );\r\n                ds.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                    bytes20(_newFacetAddress);\r\n\r\n   }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(\r\n                _newFacetAddress == address(0),\r\n                \"Remove facet address must be address(0)\"\r\n            );\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                if (_selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n       \r\n         } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                {\r\n \r\n                   bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(0),\r\n\r\n       \"Can't remove function that doesn't exist\"\r\n                    );\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(this),\r\n                        \"Can't remove immutable function\"\r\n  \r\n                  );\r\n                    lastSelector = bytes4(\r\n                        _selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n                    if (lastSelector != selector) {\r\n                        ds.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(ds.facets[lastSelector]);\r\n                    }\r\n                    delete ds.facets[selector];\r\n\r\n uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if \r\n(oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n                    oldSelectorSlot =\r\n\r\n       (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n\r\n   ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    _selectorSlot =\r\n                        (_selectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n\r\n              oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"Incorrect FacetCutAction\");\r\n     \r\n   }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata)\r\n        internal\r\n    {\r\n        if (_init == address(0)) {\r\n            require(\r\n                _calldata.length == 0,\r\n                \"_init is address(0) but_calldata is not empty\"\r\n            );\r\n        } else {\r\n            require(\r\n                _calldata.length > 0,\r\n                \"_calldata is empty but _init is not address(0)\"\r\n            );\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"_init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"_init function reverted\");\r\n                }\r\n            }\r\n   \r\n     }\r\n    }\r\n\r\n    function enforceHasContractCode(\r\n        address _contract,\r\n        string memory _errorMessage\r\n    ) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\n// File: DiamondInit.sol\r\n\r\ncontract DiamondInit {\r\n    function init() external {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n\r\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n        ds.supportedInterfaces[type(IERC20).interfaceId] = true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondInit", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5cd5991f62bd95ce4ab387d749de75c1c3b4b5c0df142769a144266d9096445c"}]}