{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/airdrop/ERC1155Airdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @notice Airdrop contract for Refinable NFT Marketplace\\n */\\ncontract ERC1155Airdrop is Context, ReentrancyGuard {\\n\\n    /// @notice ERC1155 NFT\\n    IERC1155 public token;\\n    IERC1155 public tokenV2;\\n\\n    event AirdropContractDeployed();\\n    event AirdropFinished(\\n        uint256 tokenId,\\n        address[] recipients\\n    );\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor(\\n        IERC1155 _token,\\n        IERC1155 _tokenV2\\n    ) public {\\n        require(address(_token) != address(0), \\\"Invalid NFT\\\");\\n        require(address(_tokenV2) != address(0), \\\"Invalid NFT\\\");\\n\\n        token = _token;\\n        tokenV2 = _tokenV2;\\n\\n        emit AirdropContractDeployed();\\n    }\\n\\n    /**\\n     * @dev Owner of token can airdrop tokens to recipients\\n     * @param _tokenId id of the token\\n     * @param _recipients addresses of recipients\\n     */\\n    function airdrop(IERC1155 _token, uint256 _tokenId, address[] memory _recipients) external nonReentrant {\\n        require(\\n            _token == token || _token == tokenV2,\\n            \\\"ERC1155Airdrop: Token is not allowed\\\"\\n        );\\n        require(\\n            _token.balanceOf(_msgSender(), _tokenId) >= _recipients.length,\\n            \\\"ERC1155Airdrop: Caller does not have amount of tokens\\\"\\n        );\\n        require(\\n            _token.isApprovedForAll(_msgSender(), address(this)),\\n            \\\"ERC1155Airdrop: Owner has not approved\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _recipients.length; i++) {\\n            _token.safeTransferFrom(_msgSender(), _recipients[i], _tokenId, 1, \\\"\\\");\\n        }\\n\\n        emit AirdropFinished(_tokenId, _recipients);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/GSN/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sale/ERC721Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../proxy/TransferProxy.sol\\\";\\nimport \\\"../proxy/ServiceFeeProxy.sol\\\";\\nimport \\\"./ERC721SaleNonceHolder.sol\\\";\\nimport \\\"../tokens/v1/HasSecondarySaleFees.sol\\\";\\nimport \\\"../tokens/HasSecondarySale.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\nimport \\\"../managers/TradeTokenManager.sol\\\";\\nimport \\\"../managers/NftTokenManager.sol\\\";\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../service_fee/RoyaltiesStrategy.sol\\\";\\nimport \\\"./VipPrivatePublicSaleInfo.sol\\\";\\n\\ncontract ERC721Sale is ReentrancyGuard, RoyaltiesStrategy, VipPrivatePublicSaleInfo {\\n    using ECDSA for bytes32;\\n    using RoyaltyLibrary for RoyaltyLibrary.Strategy;\\n\\n    event CloseOrder(\\n        address indexed token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        uint256 nonce\\n    );\\n    event Buy(\\n        address indexed token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        address payToken,\\n        uint256 price,\\n        address buyer\\n    );\\n\\n    bytes constant EMPTY = \\\"\\\";\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_HAS_SECONDARY_SALE = 0x5595380a;\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    address public transferProxy;\\n    address public serviceFeeProxy;\\n    address public nonceHolder;\\n    address public tradeTokenManager;\\n\\n    constructor(\\n        address _transferProxy,\\n        address _nonceHolder,\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) public {\\n        transferProxy = _transferProxy;\\n        nonceHolder = _nonceHolder;\\n        serviceFeeProxy = _serviceFeeProxy;\\n        tradeTokenManager = _tradeTokenManager;\\n    }\\n\\n    function buy(\\n        address _token,\\n        address _royaltyToken,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        bytes memory _signature\\n    ) public payable nonReentrant {\\n        \\n        bytes32 saleId = getID(_owner, _token, _tokenId);\\n\\n        // clean up saleInfo\\n        if(!whitelistNeeded(saleId) && saleInfo[saleId].vipSaleDate >= 0) {\\n            delete saleInfo[saleId];\\n        }\\n\\n        require(\\n            IERC721(_token).supportsInterface(_INTERFACE_ID_ERC721),\\n            \\\"ERC721Sale: Invalid NFT\\\"\\n        );\\n\\n        if (_royaltyToken != address(0)) {\\n            require(\\n                IERC721(_royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2),\\n                \\\"ERC721Sale: Invalid royalty contract\\\"\\n            );\\n            require(\\n                IRoyalty(_royaltyToken).getTokenContract() == _token,\\n                \\\"ERC721Sale: Royalty Token address does not match buy token\\\"\\n            );\\n        }\\n\\n        require(whitelisted(saleId, msg.sender), \\\"You should be whitelisted and sale should have started\\\");\\n\\n        require(\\n            IERC721(_token).ownerOf(_tokenId) == _owner,\\n            \\\"ERC721Sale: Seller is not the owner of the token\\\"\\n        );\\n\\n        uint256 receiveAmount;\\n        if (_payToken == address(0)) {\\n            receiveAmount = msg.value;\\n        } else {\\n            require(TradeTokenManager(tradeTokenManager).supportToken(_payToken) == true, \\\"ERC721Sale: Pay Token is not allowed\\\");\\n            receiveAmount = IBEP20(_payToken).allowance(_msgSender(), address(this));\\n        }\\n\\n        uint256 price = receiveAmount.mul(10 ** 4).div(ServiceFeeProxy(serviceFeeProxy).getBuyServiceFeeBps(_msgSender()).add(10000));\\n\\n        uint256 nonce = verifySignature(\\n            _token,\\n            _tokenId,\\n            _payToken,\\n            _owner,\\n            price,\\n            _signature\\n        );\\n        verifyOpenAndModifyState(_token, _tokenId, _owner, nonce);\\n        if (_royaltyToken != address(0)) {\\n            _distributeProfit(_royaltyToken, _tokenId, _payToken, _owner, price, receiveAmount);\\n        } else {\\n            _distributeProfit(_token, _tokenId, _payToken, _owner, price, receiveAmount);\\n        }\\n\\n        TransferProxy(transferProxy).erc721safeTransferFrom(_token, _owner, _msgSender(), _tokenId);\\n\\n        emit Buy(_token, _tokenId, _owner, _payToken, price, _msgSender());\\n    }\\n\\n    function _distributeProfit(\\n        address _token,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        uint256 _totalPrice,\\n        uint256 _receiveAmount\\n    ) internal {\\n        bool supportSecondarySale = IERC165(_token).supportsInterface(_INTERFACE_ID_HAS_SECONDARY_SALE);\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        uint256 sellerServiceFee;\\n        uint256 sellerReceiveAmount;\\n        uint256 royalties;\\n        if (supportSecondarySale) {\\n            bool isSecondarySale = HasSecondarySale(_token).checkSecondarySale(_tokenId);\\n            uint256 sellerServiceFeeBps = ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(_owner, isSecondarySale);\\n            sellerServiceFee = _totalPrice.mul(sellerServiceFeeBps).div(10 ** 4);\\n            sellerReceiveAmount = _totalPrice.sub(sellerServiceFee);\\n            /*\\n               * The sellerReceiveAmount is on sale price minus seller service fee minus buyer service fee\\n               * This make sures we have enough balance even the royalties is 100%\\n            */\\n            if (\\n                IERC165(_token).supportsInterface(_INTERFACE_ID_FEES)\\n                || IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY)\\n                || IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY_V2)\\n            )\\n                royalties = _payOutRoyaltiesByStrategy(_token, _tokenId, _payToken, _msgSender(), sellerReceiveAmount, isSecondarySale);\\n            sellerReceiveAmount = sellerReceiveAmount.sub(royalties);\\n            HasSecondarySale(_token).setSecondarySale(_tokenId);\\n        } else {\\n            // default to second sale if it's random 721 token\\n            uint256 sellerServiceFeeBps = ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(_owner, true);\\n            sellerServiceFee = _totalPrice.mul(sellerServiceFeeBps).div(10 ** 4);\\n            sellerReceiveAmount = _totalPrice.sub(sellerServiceFee);\\n        }\\n        if (_payToken == address(0)) {\\n            _owner.transfer(sellerReceiveAmount);\\n            serviceFeeRecipient.transfer(sellerServiceFee.add(_receiveAmount.sub(_totalPrice)));\\n        } else {\\n            IBEP20(_payToken).transferFrom(_msgSender(), _owner, sellerReceiveAmount);\\n            IBEP20(_payToken).transferFrom(_msgSender(), serviceFeeRecipient, sellerServiceFee.add(_receiveAmount.sub(_totalPrice)));\\n        }\\n    }\\n\\n    function cancel(address token, uint256 tokenId) public {\\n        uint256 nonce = ERC721SaleNonceHolder(nonceHolder).getNonce(token, tokenId, _msgSender());\\n        ERC721SaleNonceHolder(nonceHolder).setNonce(token, tokenId, _msgSender(), nonce.add(1));\\n\\n        emit CloseOrder(token, tokenId, _msgSender(), nonce.add(1));\\n    }\\n\\n    function verifySignature(\\n        address _token,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        uint256 _price,\\n        bytes memory _signature\\n    ) internal view returns (uint256 nonce) {\\n        nonce = ERC721SaleNonceHolder(nonceHolder).getNonce(_token, _tokenId, _owner);\\n        address owner;\\n        if (_payToken == address(0)) {\\n            owner = keccak256(abi.encodePacked(_token, _tokenId, _price, nonce)).toEthSignedMessageHash().recover(_signature);\\n        } else {\\n            owner = keccak256(abi.encodePacked(_token, _tokenId, _payToken, _price, nonce)).toEthSignedMessageHash().recover(_signature);\\n        }\\n        require(\\n            owner == _owner,\\n            \\\"ERC721Sale: Incorrect signature\\\"\\n        );\\n    }\\n\\n    function verifyOpenAndModifyState(\\n        address _token,\\n        uint256 _tokenId,\\n        address _owner,\\n        uint256 _nonce\\n    ) internal {\\n        ERC721SaleNonceHolder(nonceHolder).setNonce(_token, _tokenId, _owner, _nonce.add(1));\\n        emit CloseOrder(_token, _tokenId, _owner, _nonce.add(1));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        // Check the signature length\\n        if (signature.length != 65) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        }\\n\\n        // Divide the signature in r, s and v variables\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        // ecrecover takes the signature parameters, and the only way to get them\\n        // currently is to use assembly.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            r := mload(add(signature, 0x20))\\n            s := mload(add(signature, 0x40))\\n            v := byte(0, mload(add(signature, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover-bytes32-bytes-} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \\\"ECDSA: invalid signature 's' value\\\");\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid signature 'v' value\\\");\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * replicates the behavior of the\\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\\n     * JSON-RPC method.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/TransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport \\\"../roles/OperatorRole.sol\\\";\\n\\ncontract TransferProxy is OperatorRole {\\n    function erc721safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external onlyOperator {\\n        IERC721(token).safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function erc1155safeTransferFrom(\\n        address token,\\n        address _from,\\n        address _to,\\n        uint256 _id,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external onlyOperator {\\n        IERC1155(token).safeTransferFrom(_from, _to, _id, _value, _data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/ServiceFeeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../interfaces/IServiceFee.sol\\\";\\nimport \\\"../roles/AdminRole.sol\\\";\\n\\n/**\\n * @notice Service Fee Proxy to communicate service fee contract\\n */\\ncontract ServiceFeeProxy is AdminRole {\\n    /// @notice service fee contract\\n    IServiceFee public serviceFeeContract;\\n\\n    event ServiceFeeContractUpdated(address serviceFeeContract);\\n\\n    /**\\n     * @notice Lets admin set the service fee contract\\n     * @param _serviceFeeContract address of serviceFeeContract\\n     */\\n    function setServiceFeeContract(address _serviceFeeContract) onlyAdmin external {\\n        require(\\n            _serviceFeeContract != address(0),\\n            \\\"ServiceFeeProxy.setServiceFeeContract: Zero address\\\"\\n        );\\n        serviceFeeContract = IServiceFee(_serviceFeeContract);\\n        emit ServiceFeeContractUpdated(_serviceFeeContract);\\n    }\\n\\n    /**\\n     * @notice Fetch sell service fee bps from service fee contract\\n     * @param _seller address of seller\\n     */\\n    function getSellServiceFeeBps(address _seller, bool isSecondarySale) external view returns (uint256) {\\n        require(\\n            _seller != address(0),\\n            \\\"ServiceFeeProxy.getSellServiceFeeBps: Zero address\\\"\\n        );\\n        return serviceFeeContract.getSellServiceFeeBps(_seller, isSecondarySale);\\n    }\\n\\n    /**\\n     * @notice Fetch buy service fee bps from service fee contract\\n     * @param _buyer address of seller\\n     */\\n    function getBuyServiceFeeBps(address _buyer) external view returns (uint256) {\\n        require(\\n            _buyer != address(0),\\n            \\\"ServiceFeeProxy.getBuyServiceFeeBps: Zero address\\\"\\n        );\\n        return serviceFeeContract.getBuyServiceFeeBps(_buyer);\\n    }\\n\\n    /**\\n     * @notice Get service fee recipient address\\n     */\\n    function getServiceFeeRecipient() external view returns (address payable) {\\n        return serviceFeeContract.getServiceFeeRecipient();\\n    }\\n\\n    /**\\n     * @notice Set service fee recipient address\\n     * @param _serviceFeeRecipient address of recipient\\n     */\\n    function setServiceFeeRecipient(address payable _serviceFeeRecipient) external onlyAdmin {\\n        require(\\n            _serviceFeeRecipient != address(0),\\n            \\\"ServiceFeeProxy.setServiceFeeRecipient: Zero address\\\"\\n        );\\n\\n        serviceFeeContract.setServiceFeeRecipient(_serviceFeeRecipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sale/ERC721SaleNonceHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../roles/OperatorRole.sol\\\";\\n\\ncontract ERC721SaleNonceHolder is OperatorRole {\\n    // keccak256(token, owner, tokenId) => nonce\\n    mapping(bytes32 => uint256) public nonces;\\n\\n    // keccak256(token, owner, tokenId, nonce) => completed amount\\n    mapping(bytes32 => uint256) public completed;\\n\\n    function getNonce(\\n        address token,\\n        uint256 tokenId,\\n        address owner\\n    ) public view returns (uint256) {\\n        return nonces[getNonceKey(token, tokenId, owner)];\\n    }\\n\\n    function setNonce(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public onlyOperator {\\n        nonces[getNonceKey(token, tokenId, owner)] = nonce;\\n    }\\n\\n    function getNonceKey(\\n        address token,\\n        uint256 tokenId,\\n        address owner\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(token, tokenId, owner));\\n    }\\n\\n    function getCompleted(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public view returns (uint256) {\\n        return completed[getCompletedKey(token, tokenId, owner, nonce)];\\n    }\\n\\n    function setCompleted(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce,\\n        uint256 _completed\\n    ) public onlyOperator {\\n        completed[getCompletedKey(token, tokenId, owner, nonce)] = _completed;\\n    }\\n\\n    function getCompletedKey(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(token, tokenId, owner, nonce));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v1/HasSecondarySaleFees.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\n\\nabstract contract HasSecondarySaleFees is ERC165 {\\n\\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\\n\\n    /*\\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *\\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n\\n    constructor() public {\\n        _registerInterface(_INTERFACE_ID_FEES);\\n    }\\n\\n    function getFeeRecipients(uint256 id) public virtual view returns (address payable[] memory);\\n    function getFeeBps(uint256 id) public virtual view returns (uint[] memory);\\n}\"\r\n    },\r\n    \"contracts/tokens/HasSecondarySale.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"../interfaces/IHasSecondarySale.sol\\\";\\n\\nabstract contract HasSecondarySale is ERC165, IHasSecondarySale {\\n\\n    // From IHasSecondarySale\\n    bytes4 private constant _INTERFACE_ID_HAS_SECONDARY_SALE = 0x5595380a;\\n\\n    constructor() public {\\n        _registerInterface(_INTERFACE_ID_HAS_SECONDARY_SALE);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tge/interfaces/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\ninterface IBEP20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the token name.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address _owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/managers/TradeTokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../interfaces/ITokenManager.sol\\\";\\nimport \\\"../roles/AdminRole.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\n\\ncontract TradeTokenManager is ITokenManager, AdminRole {\\n\\n    struct TradeToken {\\n        string symbol;\\n        bool created;\\n        bool active;\\n    }\\n\\n    /// @notice ERC20 Token address -> active boolean\\n    mapping(address => TradeToken) public tokens;\\n\\n    modifier exist(address _token) {\\n        require(tokens[_token].created != false, \\\"TradeTokenManager: Token is not added\\\");\\n        _;\\n    }\\n\\n    function addToken(address _erc20Token,string calldata _symbol, bool _active) onlyAdmin external {\\n        require(_erc20Token != address(0), \\\"TradeTokenManager: Cannot be zero address\\\");\\n        require(tokens[_erc20Token].created == false, \\\"TradeTokenManager: Token already exist\\\");\\n        require(IBEP20(_erc20Token).totalSupply() != 0, \\\"TradeTokenManager: Token is not ERC20 standard\\\");\\n        tokens[_erc20Token] = TradeToken({\\n            symbol: _symbol,\\n            created: true,\\n            active: _active\\n        });\\n    }\\n\\n    function setToken(address _erc20Token, bool _active) onlyAdmin exist(_erc20Token) external override {\\n        tokens[_erc20Token].active = _active;\\n    }\\n\\n    function removeToken(address _erc20Token) onlyAdmin exist(_erc20Token) external override {\\n        delete tokens[_erc20Token];\\n    }\\n\\n    function supportToken(address _erc20Token) exist(_erc20Token) external view override returns (bool) {\\n        return tokens[_erc20Token].active;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/managers/NftTokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../roles/AdminRole.sol\\\";\\nimport \\\"../interfaces/ITokenManager.sol\\\";\\nimport \\\"../interfaces/IRoyalty.sol\\\";\\nimport \\\"../libs/NftTokenLibrary.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ncontract NftTokenManager is ITokenManager, AdminRole {\\n    struct NftToken {\\n        string name;\\n        bool created;\\n        bool active;\\n        NftTokenLibrary.TokenType tokenType;\\n    }\\n\\n    /// @notice ERC1155 or ERC721 Token address -> active boolean\\n    mapping(address => NftToken) public tokens;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    modifier exist(address _token) {\\n        require(tokens[_token].created != false, \\\"NftTokenManager: Token is not added\\\");\\n        _;\\n    }\\n    // TODO: Add Token By Batch\\n    function addToken(address _token, string calldata _name, bool _active, NftTokenLibrary.TokenType _tokenType) onlyAdmin external {\\n        require(_token != address(0), \\\"NftTokenManager: Cannot be zero address\\\");\\n        require(tokens[_token].created == false, \\\"NftTokenManager: Token already exist\\\");\\n        // TODO: Add Royalty type and link royalty to erc token\\n        if (_tokenType != NftTokenLibrary.TokenType.REFINABLE_ROYALTY_ERC721_CONTRACT && _tokenType != NftTokenLibrary.TokenType.REFINABLE_ROYALTY_ERC1155_CONTRACT) {\\n            require(\\n                IERC721(_token).supportsInterface(_INTERFACE_ID_ERC721) || IERC1155(_token).supportsInterface(_INTERFACE_ID_ERC1155),\\n                \\\"NftTokenManager: Token is not ERC1155 or ERC721 standard\\\"\\n            );\\n        } else {\\n            require(\\n                IERC165(_token).supportsInterface(type(IRoyalty).interfaceId),\\n                \\\"NftTokenManager: Token is not IRoyalty standard\\\"\\n            );\\n        }\\n        tokens[_token] = NftToken({\\n        name : _name,\\n        created : true,\\n        active : _active,\\n        tokenType : _tokenType\\n        });\\n    }\\n\\n    function setToken(address _token, bool _active) onlyAdmin exist(_token) external override {\\n        tokens[_token].active = _active;\\n    }\\n\\n    function removeToken(address _token) onlyAdmin exist(_token) external override {\\n        delete tokens[_token];\\n    }\\n\\n    function supportToken(address _token) exist(_token) external view override returns (bool) {\\n        return tokens[_token].active;\\n    }\\n\\n    function getTokenType(address _token) exist(_token) external view returns (NftTokenLibrary.TokenType) {\\n        return tokens[_token].tokenType;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/RoyaltyLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nlibrary RoyaltyLibrary {\\n    enum Strategy {\\n        ROYALTY_STRATEGY, // get royalty from the sales price (default)\\n        PROFIT_DISTRIBUTION_STRATEGY, // profit sharing from a fixed royalties of the sales price\\n        PRIMARY_SALE_STRATEGY // 1 party get royalty from primary sale, secondary sale will follow ROYALTY_STRATEGY\\n    }\\n\\n    struct RoyaltyInfo {\\n        uint256 value; //bps\\n        Strategy strategy;\\n    }\\n\\n    struct RoyaltyShareDetails {\\n        address payable recipient;\\n        uint256 value; // bps\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/service_fee/RoyaltiesStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/IERC165.sol\\\";\\n\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../tokens/v2/ERC721BaseV2.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\nimport \\\"../tokens/Royalty.sol\\\";\\nimport \\\"../tokens/v1/HasSecondarySaleFees.sol\\\";\\nimport \\\"../interfaces/IPrimaryRoyalty.sol\\\";\\n\\nabstract contract RoyaltiesStrategy is Context {\\n    using SafeMath for uint256;\\n    using RoyaltyLibrary for RoyaltyLibrary.RoyaltyShareDetails;\\n    using RoyaltyLibrary for RoyaltyLibrary.RoyaltyInfo;\\n\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    function _payOutRoyaltiesByStrategy(\\n        address _token,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address _payer,\\n        uint256 _actualPrice, // the total paid price - seller service fee - buyer service fee\\n        bool _isSecondarySale\\n    ) internal returns (uint256){\\n        /*\\n           * The _totalPrice is on sale price minus seller service fee minus buyer service fee\\n           * This make sures we have enough balance even the royalties is 100%\\n        */\\n        uint256 royalties;\\n        if (\\n            IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY)\\n            || IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY_V2)\\n        ) {\\n            royalties = _payOutRoyalties(_token, _tokenId, _payToken, _payer, _actualPrice, _isSecondarySale);\\n        } else {\\n            // support the old contract with no strategy\\n            address payable[] memory recipients = HasSecondarySaleFees(_token).getFeeRecipients(_tokenId);\\n            uint256[] memory royaltyShares = HasSecondarySaleFees(_token).getFeeBps(_tokenId);\\n            require(royaltyShares.length == recipients.length, \\\"RoyaltyStrategy: Royalty share array length not match recipients array length\\\");\\n            uint256 sumRoyaltyShareBps;\\n            for (uint256 i = 0; i < royaltyShares.length; i++) {\\n                sumRoyaltyShareBps = sumRoyaltyShareBps.add(royaltyShares[i]);\\n            }\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"RoyaltyStrategy: Total Royalty Shares bps should not exceed 10000\\\"\\n            );\\n            for (uint256 i = 0; i < royaltyShares.length; i++) {\\n                uint256 recipientRoyalty = _actualPrice.mul(royaltyShares[i]).div(10 ** 4);\\n                _transferToken(_payToken, _payer, recipients[i], recipientRoyalty);\\n                royalties = royalties.add(recipientRoyalty);\\n            }\\n        }\\n        return royalties;\\n    }\\n\\n    function _payOutRoyalties(address _token, uint256 _tokenId, address _payToken, address _payer, uint256 _payPrice, bool _isSecondarySale) internal returns (uint256) {\\n        uint256 royalties;\\n        RoyaltyLibrary.RoyaltyInfo memory royalty = Royalty(_token).getRoyalty(_tokenId);\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory royaltyShares;\\n        if (royalty.strategy == RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY && _isSecondarySale == false) {\\n            if (IERC165(_token).supportsInterface(type(IPrimaryRoyalty).interfaceId)) {\\n                royaltyShares = IPrimaryRoyalty(_token).getPrimaryRoyaltyShares(_tokenId);\\n            } else {\\n                royaltyShares = Royalty(_token).getRoyaltyShares(_tokenId);\\n            }\\n        } else {\\n            royaltyShares = Royalty(_token).getRoyaltyShares(_tokenId);\\n        }\\n        _checkRoyaltiesBps(royalty, royaltyShares);\\n        for (uint256 i = 0; i < royaltyShares.length; i++) {\\n            uint256 recipientRoyalty;\\n            if (royalty.strategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY && _isSecondarySale) {\\n                recipientRoyalty = _payPrice.mul(royalty.value).mul(royaltyShares[i].value).div(10 ** 8);\\n            } else {\\n                recipientRoyalty = _payPrice.mul(royaltyShares[i].value).div(10 ** 4);\\n            }\\n            _transferToken(_payToken, _payer, royaltyShares[i].recipient, recipientRoyalty);\\n            royalties = royalties.add(recipientRoyalty);\\n        }\\n        return royalties;\\n    }\\n\\n    function _checkRoyaltiesBps(RoyaltyLibrary.RoyaltyInfo memory _royalty, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal pure {\\n        require(\\n            _royalty.value <= 10 ** 4,\\n            \\\"RoyaltyStrategy: Royalty bps should be less than 10000\\\"\\n        );\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps.add(_royaltyShares[i].value);\\n        }\\n        if (_royalty.strategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10 ** 4,\\n                \\\"RoyaltyStrategy: Total Royalty Shares bps should be 10000\\\"\\n            );\\n        } else {\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"RoyaltyStrategy: Total Royalty Shares bps should not exceed 10000\\\"\\n            );\\n        }\\n    }\\n\\n    function _transferToken(address _payToken, address _payer, address payable _recipient, uint256 _amount) internal {\\n        if (_payToken == address(0)) {\\n            _recipient.transfer(_amount);\\n        } else {\\n            if (_payer == address(this)) {\\n                IBEP20(_payToken).transfer(_recipient, _amount);\\n            } else {\\n                IBEP20(_payToken).transferFrom(_payer, _recipient, _amount);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sale/VipPrivatePublicSaleInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {ERC165Checker} from \\\"@openzeppelin/contracts/introspection/ERC165Checker.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\nabstract contract VipPrivatePublicSaleInfo is Ownable {\\n\\n    using ERC165Checker for address;\\n\\n    enum WhitelistType{ VIP, PRIVATE }\\n\\n    struct SaleInfo {\\n        uint256 vipSaleDate;\\n        mapping(address => bool) vipWhitelist;\\n        uint256 privateSaleDate;\\n        mapping(address => bool) privateWhitelist;\\n        uint256 publicSaleDate;\\n        address creator;\\n    }\\n\\n    /// @dev address -> token id -> sale info\\n    mapping(bytes32 => SaleInfo) public saleInfo;\\n\\n    event Whitelisted(WhitelistType whitelistType, address indexed account, bool isWhitelisted);\\n\\n    modifier onlyCreator(bytes32 _saleId) {\\n        require(saleInfo[_saleId].creator == msg.sender, \\\"Whitelist: Not Sale creator\\\");\\n        _;\\n    }\\n\\n    function setSaleInfo(        \\n        address _token,\\n        uint256 _tokenId,\\n        uint256 _vipSaleDate,\\n        uint256 _privateSaleDate,\\n        uint256 _publicSaleDate\\n    ) external {\\n\\n        if(_token.supportsInterface(type(IERC1155).interfaceId)) {\\n            require(\\n                IERC1155(_token).balanceOf(msg.sender, _tokenId) > 0,\\n                \\\"ERC1155Sale: Caller doesn't have any tokens\\\"\\n            );\\n        } else if(_token.supportsInterface(type(IERC721).interfaceId)) {\\n            require(\\n                IERC721(_token).ownerOf(_tokenId) == msg.sender,\\n                \\\"ERC721Sale: Caller doesn't this tokenId\\\"\\n            );\\n        } else {\\n            require(false, \\\"not ERC1155 or ERC721 token\\\");\\n        }\\n\\n        bytes32 saleId = getID(msg.sender, _token, _tokenId);\\n\\n        saleInfo[saleId] = SaleInfo({\\n            vipSaleDate: _vipSaleDate,\\n            privateSaleDate: _privateSaleDate,\\n            publicSaleDate: _publicSaleDate,\\n            creator: msg.sender\\n        });\\n    }\\n\\n    function batchSetSaleInfo(\\n        address[] memory _tokens,\\n        uint256[] memory _tokenIds,\\n        uint256 _vipSaleDate,\\n        uint256 _privateSaleDate,\\n        uint256 _publicSaleDate\\n    ) external {         \\n\\n        require(_tokens.length == _tokenIds.length, \\\"tokens and token ids length doesnt match\\\");\\n\\n        for(uint i = 0; i < _tokenIds.length; i++) {\\n\\n            if(_tokens[i].supportsInterface(type(IERC1155).interfaceId)) {\\n                require(\\n                    IERC1155(_tokens[i]).balanceOf(msg.sender, _tokenIds[i]) > 0,\\n                    \\\"ERC1155Sale: Caller doesn't have any tokens\\\"\\n                );\\n            } else if(_tokens[i].supportsInterface(type(IERC721).interfaceId)) {\\n                require(\\n                    IERC721(_tokens[i]).ownerOf(_tokenIds[i]) == msg.sender,\\n                    \\\"ERC721Sale: Caller doesn't this tokenId\\\"\\n                );\\n            } else {\\n                require(false, \\\"not ERC1155 or ERC721 token\\\");\\n            }\\n\\n\\n            bytes32 saleId = getID(msg.sender, _tokens[i], _tokenIds[i]);\\n            saleInfo[saleId] = SaleInfo({\\n                vipSaleDate: _vipSaleDate,\\n                privateSaleDate: _privateSaleDate,\\n                publicSaleDate: _publicSaleDate,\\n                creator: msg.sender\\n            });\\n        }\\n    }\\n\\n    function whitelisted(bytes32 saleId, address _address)\\n    public\\n    view\\n    returns (bool)\\n    {\\n\\n        // if it doesn't exist, we just allow sale to go through\\n        if(saleInfo[saleId].creator == address(0)) {\\n            return true;\\n        }\\n\\n        // should be whitelisted if we're in the VIP sale\\n        if(\\n            saleInfo[saleId].vipSaleDate <= _getNow() &&\\n            saleInfo[saleId].privateSaleDate > _getNow() \\n        ) {\\n            return saleInfo[saleId].vipWhitelist[_address];\\n        }\\n        \\n\\n        // should be whitelisted if we're in the Private sale\\n        if(\\n            saleInfo[saleId].privateSaleDate <= _getNow() && \\n            saleInfo[saleId].publicSaleDate > _getNow() \\n        ) {\\n            return \\n                saleInfo[saleId].vipWhitelist[_address] || \\n                saleInfo[saleId].privateWhitelist[_address];\\n        }\\n\\n        return false;\\n    }\\n\\n    function whitelistNeeded(bytes32 saleId)\\n    public\\n    view\\n    returns (bool)\\n    {\\n        // whitelist has passed when now is > vip and private sale date\\n        if(\\n            saleInfo[saleId].vipSaleDate < _getNow() &&\\n            saleInfo[saleId].privateSaleDate < _getNow() &&\\n            saleInfo[saleId].publicSaleDate < _getNow()\\n\\n        ) {\\n            return false;\\n        }\\n\\n\\n        return true;\\n    }\\n\\n    function toggleAddressByBatch(bytes32[] memory _saleIds, WhitelistType[][] memory _whitelistTypes, address[][][] memory _addresses, bool enable)\\n    public\\n    {\\n        // for many sale ids\\n        for(uint i = 0; i < _saleIds.length; i++) {       \\n\\n            require(saleInfo[_saleIds[i]].creator == msg.sender, \\\"Whitelist: Not Sale creator\\\");\\n\\n            // 1 sale can have many whitelist types\\n            for (uint256 j = 0; j < _whitelistTypes[i].length; j++) {\\n\\n                // 1 whitelist type can have many addresses\\n                for(uint k = 0; k < _addresses[i][j].length; k++) {\\n                    if(_whitelistTypes[i][j] == WhitelistType.VIP) {\\n                        require(saleInfo[_saleIds[i]].vipWhitelist[_addresses[i][j][k]] == !enable);\\n                        saleInfo[_saleIds[i]].vipWhitelist[_addresses[i][j][k]] = enable;\\n                        emit Whitelisted(WhitelistType.VIP, _addresses[i][j][k], enable);\\n                    }\\n                    if(_whitelistTypes[i][j] == WhitelistType.PRIVATE) {\\n                        require(saleInfo[_saleIds[i]].privateWhitelist[_addresses[i][j][k]] == !enable);\\n                        saleInfo[_saleIds[i]].privateWhitelist[_addresses[i][j][k]] = enable;\\n                        emit Whitelisted(WhitelistType.PRIVATE, _addresses[i][j][k], enable);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _getNow() internal virtual view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /*\\n     * @notice Get Sale info with owner address and token id\\n     * @param _owner address of token Owner\\n     * @param _tokenId Id of token\\n     */\\n    function getSaleInfo(\\n        address _owner,\\n        address _token,\\n        uint256 _tokenId\\n    ) public view returns (bytes32 saleId, uint256 vipSaleDate, uint256 privateSaleDate, uint256 publicSaleDate, address creator) {\\n\\n        bytes32 _saleId = getID(_owner, _token, _tokenId);\\n\\n        require(saleInfo[_saleId].vipSaleDate >= 0, \\\"VipPrivatePublicSale: Sale has no dates set\\\");\\n\\n        return (_saleId, saleInfo[_saleId].vipSaleDate, saleInfo[_saleId].privateSaleDate, saleInfo[_saleId].publicSaleDate, saleInfo[_saleId].creator);\\n    }\\n\\n\\n\\n    \\n    function getID(address _owner, address _token, uint256 _tokenId) public pure returns (bytes32) {\\n        return sha256(abi.encodePacked(_owner, \\\":\\\", _token, \\\":\\\",Strings.toString(_tokenId)));\\n    }\\n\\n    function getIDBatch(address[] memory _owners, address[] memory _tokens, uint256[] memory _tokenIds) public pure returns (bytes32[] memory) {\\n        \\n        require(_tokenIds.length <= 100, \\\"You are requesting too many ids, max 100\\\");\\n        require(_tokenIds.length == _owners.length, \\\"tokenIds length != owners length\\\");\\n        require(_tokenIds.length == _tokens.length, \\\"tokenIds length != tokens length\\\");\\n        \\n        bytes32[] memory ids = new bytes32[](_tokenIds.length);\\n        \\n        for(uint i = 0; i < _tokenIds.length; i++) {\\n            ids[i] = getID(_owners[i], _tokens[i], _tokenIds[i]);\\n        }\\n\\n        return ids;\\n    }\\n}\"\r\n    },\r\n    \"contracts/roles/OperatorRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract OperatorRole is AccessControl {\\n    \\n    bytes32 public constant OPERATOR_ROLE = keccak256(\\\"OPERATOR_ROLE\\\");\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(_msgSender()), \\\"Ownable: caller is not the admin\\\");\\n        _;\\n    }\\n\\n    modifier onlyOperator() {\\n        require(isOperator(_msgSender()), \\\"Ownable: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    function addOperator(address _account) public onlyAdmin {\\n        _setupRole(OPERATOR_ROLE , _account);\\n    }\\n\\n    function removeOperator(address _account) public onlyAdmin {\\n        revokeRole(OPERATOR_ROLE , _account);\\n    }\\n\\n    function isAdmin(address _account) internal virtual view returns(bool) {\\n        return hasRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n\\n    function isOperator(address _account) internal virtual view returns(bool) {\\n        return hasRole(OPERATOR_ROLE , _account);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/EnumerableSet.sol\\\";\\nimport \\\"../utils/Address.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    using Address for address;\\n\\n    struct RoleData {\\n        EnumerableSet.AddressSet members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping (bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view returns (bool) {\\n        return _roles[role].members.contains(account);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view returns (uint256) {\\n        return _roles[role].members.length();\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {\\n        return _roles[role].members.at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to grant\\\");\\n\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual {\\n        require(hasRole(_roles[role].adminRole, _msgSender()), \\\"AccessControl: sender must be an admin to revoke\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        emit RoleAdminChanged(role, _roles[role].adminRole, adminRole);\\n        _roles[role].adminRole = adminRole;\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (_roles[role].members.add(account)) {\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (_roles[role].members.remove(account)) {\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IServiceFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @notice Service Fee interface for Refinable NFT Marketplace\\n */\\ninterface IServiceFee {\\n\\n    /**\\n     * @notice Lets admin set the refinable token contract\\n     * @param _refinableTokenContract address of refinable token contract\\n     */\\n    function setRefinableTokenContract(address _refinableTokenContract) external;\\n\\n    /**\\n     * @notice Admin can add proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function addProxy(address _proxyAddr) external;\\n\\n    /**\\n     * @notice Admin can remove proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function removeProxy(address _proxyAddr) external;\\n\\n    /**\\n     * @notice Calculate the seller service fee in according to the business logic and returns it\\n     * @param _seller address of seller\\n     * @param _isPrimarySale sale is primary or secondary\\n     */\\n    function getSellServiceFeeBps(address _seller, bool _isPrimarySale) external view returns (uint256);\\n\\n    /**\\n     * @notice Calculate the buyer service fee in according to the business logic and returns it\\n     * @param _buyer address of buyer\\n     */\\n    function getBuyServiceFeeBps(address _buyer) external view returns (uint256);\\n\\n    /**\\n     * @notice Get service fee recipient address\\n     */\\n    function getServiceFeeRecipient() external view returns (address payable);\\n\\n    /**\\n     * @notice Set service fee recipient address\\n     * @param _serviceFeeRecipient address of recipient\\n     */\\n    function setServiceFeeRecipient(address payable _serviceFeeRecipient) external;\\n}\\n\"\r\n    },\r\n    \"contracts/roles/AdminRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract AdminRole is AccessControl {\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(_msgSender()), \\\"Ownable: caller is not the admin\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    function isAdmin(address _account) internal virtual view returns(bool) {\\n        return hasRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IHasSecondarySale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\ninterface IHasSecondarySale {\\n\\n    /*\\n     * bytes4(keccak256('checkSecondarySale(uint256)')) == 0x0e883747\\n     * bytes4(keccak256('setSecondarySale(uint256)')) == 0x5b1d0f4d\\n     *\\n     * => 0x0e883747 ^ 0x5b1d0f4d == 0x5595380a\\n     */\\n//    bytes4 private constant _INTERFACE_ID_HAS_SECONDARY_SALE = 0x5595380a;\\n//\\n//    constructor() public {\\n//        _registerInterface(_INTERFACE_ID_HAS_SECONDARY_SALE);\\n//    }\\n\\n    function checkSecondarySale(uint256 tokenId) external view returns (bool);\\n    function setSecondarySale(uint256 tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\ninterface ITokenManager {\\n    function setToken(address _token, bool _active) external;\\n\\n    function removeToken(address _token) external;\\n\\n    function supportToken(address _token) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoyalty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\n\\ninterface IRoyalty {\\n    using RoyaltyLibrary for RoyaltyLibrary.Strategy;\\n    using RoyaltyLibrary for RoyaltyLibrary.RoyaltyInfo;\\n    using RoyaltyLibrary for RoyaltyLibrary.RoyaltyShareDetails;\\n\\n    /*\\n     * bytes4(keccak256('getRoyalty(uint256)')) == 0x1af9cf49\\n     * bytes4(keccak256('getRoyaltyShares(uint256)')) == 0xac04f243\\n     * bytes4(keccak256('getTokenContract()') == 0x28b7bede\\n     *\\n     * => 0x1af9cf49 ^ 0xac04f243 ^ 0x28b7bede  == 0x9e4a83d4\\n     */\\n\\n    //    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x9e4a83d4;\\n    //\\n    //    constructor() public {\\n    //        _registerInterface(_INTERFACE_ID_ROYALTY);\\n    //    }\\n\\n    function getRoyalty(uint256 _tokenId) external view returns (RoyaltyLibrary.RoyaltyInfo memory);\\n\\n    function getRoyaltyShares(uint256 _tokenId) external view returns (RoyaltyLibrary.RoyaltyShareDetails[] memory);\\n\\n    function getTokenContract() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/NftTokenLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nlibrary NftTokenLibrary {\\n    // DO NOT change the ordering\\n    enum TokenType {\\n        ERC721_CONTRACT, // 0\\n        ERC1155_CONTRACT, // 1\\n        REFINABLE_ERC721_CONTRACT, // 2\\n        REFINABLE_ERC1155_CONTRACT, // 3\\n        REFINABLE_ERC721_V2_CONTRACT, // 4\\n        REFINABLE_ERC1155_V2_CONTRACT, // 5\\n        REFINABLE_WHITELISTED_ERC721_CONTRACT, // 6\\n        REFINABLE_WHITELISTED_ERC1155_CONTRACT, // 7\\n        REFINABLE_WHITELISTED_ERC721_V2_CONTRACT, // 8\\n        REFINABLE_WHITELISTED_ERC1155_V2_CONTRACT, // 9\\n        REFINABLE_WHITELISTED_ERC721_V3_CONTRACT, // 10\\n        REFINABLE_WHITELISTED_ERC1155_V3_CONTRACT, // 11\\n        REFINABLE_ROYALTY_ERC721_CONTRACT, // 12\\n        REFINABLE_ROYALTY_ERC1155_CONTRACT // 13\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/ERC721BaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"../HasSecondarySale.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../Royalty.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token with support for baseURI\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\nabstract contract ERC721BaseV2 is\\nHasSecondarySale,\\nHasContractURI,\\nERC721Burnable,\\nMinterRole,\\nRoyalty\\n{\\n    /// @dev sale is primary or secondary\\n    mapping(uint256 => bool) public isSecondarySale;\\n\\n    /*\\n     * bytes4(keccak256('MINT_WITH_ADDRESS')) == 0xe37243f2\\n     */\\n    bytes4 private constant _INTERFACE_ID_MINT_WITH_ADDRESS = 0xe37243f2;\\n\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory contractURI,\\n        string memory _baseURI\\n    ) public HasContractURI(contractURI) ERC721(_name, _symbol) {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_MINT_WITH_ADDRESS);\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function checkSecondarySale(uint256 _tokenId) public view override returns (bool) {\\n        return isSecondarySale[_tokenId];\\n    }\\n\\n    function setSecondarySale(uint256 _tokenId) public override {\\n        isSecondarySale[_tokenId] = true;\\n    }\\n\\n    function _mint(\\n        address _to,\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) internal {\\n        require(_exists(_tokenId) == false, \\\"ERC721: Token is already minted\\\");\\n        require(bytes(_uri).length > 0, \\\"ERC721: Uri should be set\\\");\\n\\n        _mint(_to, _tokenId);\\n        _setTokenURI(_tokenId, _uri);\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps.add(_royaltyShares[i].value);\\n        }\\n\\n        if(_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10**4,\\n                \\\"ERC721: Total fee bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10**4,\\n                \\\"ERC721: Total fee bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps,  RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        }else{\\n            revert(\\\"ERC721: Royalty option does not exist\\\");\\n        }\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n    }\\n\\n    function setBaseURI(string memory _baseURI) public onlyAdmin {\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyAdmin {\\n        _setContractURI(_contractURI);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/Royalty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../interfaces/IRoyalty.sol\\\";\\nimport \\\"../interfaces/IPrimaryRoyalty.sol\\\";\\nimport \\\"../interfaces/ICreator.sol\\\";\\n\\nabstract contract Royalty is Context, ERC165, IRoyalty, IPrimaryRoyalty, ICreator {\\n    event SetRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    event SetRoyalty (\\n        address owner,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        RoyaltyLibrary.Strategy strategy\\n    );\\n\\n    event SetPrimaryRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    // tokenId => royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyInfo) public royalty;\\n\\n    // tokenId => royaltyShares\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) public royaltyShares;\\n\\n    // tokenId => creator address\\n    mapping(uint256 => address) creators;\\n\\n    // tokenId => primary royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) primaryRoyaltyShares;\\n\\n    // Max count of royalty shares\\n    uint256 maxRoyaltyShareCount = 100;\\n\\n    /*\\n     * bytes4(keccak256('getRoyalty(uint256 _tokenId)')) == 0x71f1e123\\n     * bytes4(keccak256('getRoyaltyShares(uint256 _tokenId)')) == 0x8e9727ba\\n     * bytes4(keccak256('_setRoyalty(uint256 _tokenId, uint256 _bps, RoyaltyLibrary.Strategy _strategy')) == 0x8bb6c361\\n     * bytes4(keccak256('_addRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares)')) == 0xa0034d9f\\n     * bytes4(keccak256('royalty()')) == 0x29ee566c\\n     * bytes4(keccak256('royaltyShares()')) == 0x861475d2\\n     *\\n     * => 0x71f1e123 ^ 0x8e9727ba ^ 0x8bb6c361 ^ 0xa0034d9f ^ 0x29ee566c ^ 0x861475d2 == 0x7b296bd9\\n     */\\n\\n    // IMPORTANT: This is version 1 of the royalty. Please do not delete for record.\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n\\n    // From IRoyalty\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    constructor() public {\\n        _registerInterface(_INTERFACE_ID_ROYALTY_V2);\\n        _registerInterface(type(IPrimaryRoyalty).interfaceId);\\n        _registerInterface(type(ICreator).interfaceId);\\n    }\\n\\n    function getTokenContract() public view override returns (address) {\\n        return address(this);\\n    }\\n\\n    function getRoyalty(uint256 _tokenId) public view override returns (RoyaltyLibrary.RoyaltyInfo memory) {\\n        return royalty[_tokenId];\\n    }\\n\\n    function getRoyaltyShares(uint256 _tokenId) public view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return royaltyShares[_tokenId];\\n    }\\n\\n    function getPrimaryRoyaltyShares(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return primaryRoyaltyShares[_tokenId];\\n    }\\n\\n    function getCreator(uint256 _tokenId) external view override returns (address) {\\n        return creators[_tokenId];\\n    }\\n\\n    function _setRoyalty(uint256 _tokenId, uint256 _bps, RoyaltyLibrary.Strategy _strategy) internal {\\n        require(\\n            _bps <= 10 ** 4,\\n            \\\"Royalty: Total royalty bps should not exceed 10000\\\"\\n        );\\n        royalty[_tokenId] = RoyaltyLibrary.RoyaltyInfo({\\n        value : _bps,\\n        strategy : _strategy\\n        });\\n        emit SetRoyalty(_msgSender(), _tokenId, _bps, _strategy);\\n    }\\n\\n    function _addRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Royalty share bps value should be positive\\\");\\n            royaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n\\n    function _addPrimaryRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        // Pushing the royalty shares into the mapping\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Primary royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Primary royalty share bps value should be positive\\\");\\n            primaryRoyaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetPrimaryRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPrimaryRoyalty.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\n\\ninterface IPrimaryRoyalty {\\n\\n    /*\\n     * bytes4(keccak256('getPrimaryRoyaltyShares(uint256)')) == 0x20b029a5\\n     */\\n\\n    //    bytes4 private constant _INTERFACE_ID_PRIMARY_ROYALTY = 0x20b029a5;\\n    //\\n    //    constructor() public {\\n    //        _registerInterface(_INTERFACE_ID_PRIMARY_ROYALTY);\\n    //    }\\n\\n    function getPrimaryRoyaltyShares(uint256 _tokenId) external view returns (RoyaltyLibrary.RoyaltyShareDetails[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _burn(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/HasContractURI.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\n\\ncontract HasContractURI is ERC165 {\\n\\n    string public contractURI;\\n\\n    /*\\n     * bytes4(keccak256('contractURI()')) == 0xe8a3d485\\n     */\\n    bytes4 private constant _INTERFACE_ID_CONTRACT_URI = 0xe8a3d485;\\n\\n    constructor(string memory _contractURI) public {\\n        contractURI = _contractURI;\\n        _registerInterface(_INTERFACE_ID_CONTRACT_URI);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the contract URI\\n     * @param _contractURI string URI prefix to assign\\n     */\\n    function _setContractURI(string memory _contractURI) internal {\\n        contractURI = _contractURI;\\n    }\\n}\"\r\n    },\r\n    \"contracts/roles/MinterRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract MinterRole is AccessControl {\\n    \\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant SIGNER_ROLE = keccak256(\\\"SIGNER_ROLE\\\");\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(_msgSender()), \\\"Ownable: caller is not the admin\\\");\\n        _;\\n    }\\n\\n    modifier onlySigner() {\\n        require(isSigner(_msgSender()), \\\"Ownable: caller is not the signer\\\");\\n        _;\\n    }\\n\\n    modifier onlyMinter() {\\n        require(isMinter(_msgSender()), \\\"Ownable: caller is not the minter\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    function addSigner(address _account) public onlyAdmin {\\n        grantRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function removeSigner(address _account) public onlyAdmin {\\n        revokeRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function addMinterBatch(address[] memory _accounts) public onlyAdmin {\\n        for(uint256 i = 0; i< _accounts.length; i++) {\\n            _setupRole(MINTER_ROLE, _accounts[i]);\\n        }\\n    }\\n\\n    function addMinter(address _account) public onlyAdmin {\\n        _setupRole(MINTER_ROLE, _account);\\n    }\\n\\n    function removeMinter(address _account) public onlyAdmin {\\n        revokeRole(MINTER_ROLE, _account);\\n    }\\n\\n    function addAdmin(address _account) public onlyAdmin {\\n        _setupRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n\\n    function removeAdmin(address _account) public onlyAdmin {\\n        revokeRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n\\n    function isSigner(address _account) internal virtual view returns(bool) {\\n        return hasRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function isMinter(address _account) internal virtual view returns(bool) {\\n        return hasRole(MINTER_ROLE, _account);\\n    }\\n\\n    function isAdmin(address _account) internal virtual view returns(bool) {\\n        return hasRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view virtual returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId); // internal owner\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\ninterface ICreator {\\n    /*\\n     * bytes4(keccak256('getCreator(uint256)')) == 0xd48e638a\\n     */\\n\\n    //    bytes4 private constant _INTERFACE_ID_CREATOR = 0xd48e638a;\\n    //\\n    //    constructor() public {\\n    //        _registerInterface(_INTERFACE_ID_CREATOR);\\n    //    }\\n\\n    function getCreator(uint256 _tokenId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return _supportsERC165Interface(account, _INTERFACE_ID_ERC165) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) &&\\n            _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool[] memory) {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // success determines whether the staticcall succeeded and result determines\\n        // whether the contract at account indicates support of _interfaceId\\n        (bool success, bool result) = _callERC165SupportsInterface(account, interfaceId);\\n\\n        return (success && result);\\n    }\\n\\n    /**\\n     * @notice Calls the function with selector 0x01ffc9a7 (ERC165) and suppresses throw\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return success true if the STATICCALL succeeded, false otherwise\\n     * @return result true if the STATICCALL succeeded and the contract at account\\n     * indicates support of the interface with identifier interfaceId, false otherwise\\n     */\\n    function _callERC165SupportsInterface(address account, bytes4 interfaceId)\\n        private\\n        view\\n        returns (bool, bool)\\n    {\\n        bytes memory encodedParams = abi.encodeWithSelector(_INTERFACE_ID_ERC165, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{ gas: 30000 }(encodedParams);\\n        if (result.length < 32) return (false, false);\\n        return (success, abi.decode(result, (bool)));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v1/ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"./HasSecondarySaleFees.sol\\\";\\nimport \\\"../HasSecondarySale.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token with support for baseURI\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\nabstract contract ERC721Base is\\n    HasSecondarySaleFees,\\n    HasSecondarySale,\\n    ERC721,\\n    HasContractURI\\n{\\n    // Token name\\n    // Now in openzeppelin ERC721\\n    // string public override name;\\n\\n    // Token symbol\\n    // Now in openzeppelin ERC721\\n    // string public override symbol;\\n\\n    using SafeMath for uint256;\\n\\n    struct Fee {\\n        address payable recipient;\\n        uint256 value;\\n    }\\n\\n    // id => fees\\n    mapping(uint256 => Fee[]) public fees;\\n\\n    /// @dev sale is primary or secondary\\n    mapping(uint256 => bool) public isSecondarySale;\\n\\n    // Max count of fees\\n    uint256 maxFeesCount = 100;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory contractURI,\\n        string memory _baseURI\\n    ) public HasContractURI(contractURI) ERC721(_name, _symbol) {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function getFeeRecipients(uint256 id)\\n        public\\n        view\\n        override\\n        returns (address payable[] memory)\\n    {\\n        Fee[] memory _fees = fees[id];\\n        address payable[] memory result = new address payable[](_fees.length);\\n        for (uint256 i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].recipient;\\n        }\\n        return result;\\n    }\\n\\n    function getFeeBps(uint256 id) public view override returns (uint256[] memory) {\\n        Fee[] memory _fees = fees[id];\\n        uint256[] memory result = new uint256[](_fees.length);\\n        for (uint256 i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].value;\\n        }\\n        return result;\\n    }\\n\\n    function checkSecondarySale(uint256 id) public view override returns(bool) {\\n        return isSecondarySale[id];\\n    }\\n\\n    function setSecondarySale(uint256 id) public override {\\n        isSecondarySale[id] = true;\\n    }\\n\\n    function _mint(\\n        address to,\\n        uint256 tokenId,\\n        Fee[] memory _fees\\n    ) internal {\\n        require(\\n            _fees.length <= maxFeesCount,\\n            \\\"Amount of fee recipients can't exceed 100\\\"\\n        );\\n\\n        uint256 sumFeeBps = 0;\\n        for (uint256 i = 0; i < _fees.length; i++) {\\n            sumFeeBps = sumFeeBps.add(_fees[i].value);\\n        }\\n\\n        require(\\n            sumFeeBps <= 10000,\\n            \\\"Total fee bps should not exceed 10000\\\"\\n        );\\n\\n        _mint(to, tokenId);\\n        address[] memory recipients = new address[](_fees.length);\\n        uint256[] memory bps = new uint256[](_fees.length);\\n        for (uint256 i = 0; i < _fees.length; i++) {\\n            require(\\n                _fees[i].recipient != address(0x0),\\n                \\\"Recipient should be present\\\"\\n            );\\n            require(_fees[i].value != 0, \\\"Fee value should be positive\\\");\\n            fees[tokenId].push(_fees[i]);\\n            recipients[i] = _fees[i].recipient;\\n            bps[i] = _fees[i].value;\\n        }\\n        if (_fees.length > 0) {\\n            emit SecondarySaleFees(tokenId, recipients, bps);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v1/RefinableERC721WhiteListedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC721Base.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\nimport \\\"../../libs/Ownable.sol\\\";\\n/**\\n * @title RefinableERC721TokenWhiteListed\\n * @dev only minters can mint token.\\n */\\ncontract RefinableERC721WhiteListedToken is\\nIERC721,\\nIERC721Metadata,\\nERC721Burnable,\\nERC721Base,\\nMinterRole,\\nOwnable\\n{\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721Base(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n        _registerInterface(bytes4(keccak256(\\\"MINT_WITH_ADDRESS\\\")));\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        Fee[] memory _fees,\\n        string memory _tokenURI\\n    ) public onlyMinter {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n        _mint(msg.sender, _tokenId, _fees);\\n        _setTokenURI(_tokenId, _tokenURI);\\n    }\\n\\n    function setBaseURI(string memory _baseURI) public onlyOwner {\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyOwner {\\n        _setContractURI(_contractURI);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() public {\\n        _owner = msg.sender;\\n        emit OwnershipTransferred(address(0), msg.sender);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v1/RefinableERC721Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC721Base.sol\\\";\\nimport \\\"../../roles/SignerRole.sol\\\";\\nimport \\\"../../libs/Ownable.sol\\\";\\n\\n/**\\n * @title RefinableERC721Token\\n * @dev anyone can mint token.\\n */\\ncontract RefinableERC721Token is\\n    IERC721,\\n    IERC721Metadata,\\n    ERC721Burnable,\\n    ERC721Base,\\n    SignerRole,\\n    Ownable\\n{\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721Base(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n        _registerInterface(bytes4(keccak256(\\\"MINT_WITH_ADDRESS\\\")));\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        Fee[] memory _fees,\\n        string memory _tokenURI\\n    ) public {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n        _mint(msg.sender, _tokenId, _fees);\\n        _setTokenURI(_tokenId, _tokenURI);\\n    }\\n\\n    function setBaseURI(string memory _baseURI) public onlyOwner {\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyOwner {\\n        _setContractURI(_contractURI);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/roles/SignerRole.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\n\\ncontract SignerRole is AccessControl {\\n    \\n    bytes32 public constant SIGNER_ROLE = keccak256(\\\"SIGNER_ROLE\\\");\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin(_msgSender()), \\\"Ownable: caller is not the admin\\\");\\n        _;\\n    }\\n\\n    modifier onlySigner() {\\n        require(isSigner(_msgSender()), \\\"Ownable: caller is not the signer\\\");\\n        _;\\n    }\\n\\n    constructor() public {\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    function addAdmin(address _accont) internal onlyAdmin {\\n        grantRole(DEFAULT_ADMIN_ROLE , _accont);\\n    }\\n\\n    function removeAdmin(address _accont) internal onlyAdmin {\\n        revokeRole(DEFAULT_ADMIN_ROLE , _accont);\\n    }\\n\\n    function addSigner(address _account) public onlyAdmin {\\n        grantRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function removeSigner(address _account) public onlyAdmin {\\n        revokeRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function isSigner(address _account) public virtual view returns(bool) {\\n        return hasRole(SIGNER_ROLE, _account);\\n    }\\n\\n    function isAdmin(address _account) internal virtual view returns(bool) {\\n        return hasRole(DEFAULT_ADMIN_ROLE , _account);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v1/RefinableERC1155Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC1155Base.sol\\\";\\nimport \\\"../../roles/SignerRole.sol\\\";\\n\\ncontract RefinableERC1155Token is ERC1155Base, SignerRole {\\n    \\n    using ECDSA for bytes32;\\n\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(string memory _name, string memory _symbol, address _signer, string memory _contractURI, string memory _tokenURIPrefix, string memory _uri) ERC1155Base(_contractURI, _tokenURIPrefix, _uri) public {\\n        name = _name;\\n        symbol = _symbol;\\n\\n        addAdmin(_msgSender());\\n        addSigner(_msgSender());\\n        addSigner(_signer);\\n        _registerInterface(bytes4(keccak256('MINT_WITH_ADDRESS')));\\n    }\\n\\n    function mint(uint256 _tokenId, bytes memory _signature, Fee[] memory _fees, uint256 _supply, string memory _uri) public {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n                    .toEthSignedMessageHash()\\n                    .recover(_signature)\\n            )\\n            ,\\\"invalid signature\\\"\\n        );\\n        _mint(_tokenId, _fees, _supply, _uri);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v1/ERC1155Base.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"./HasSecondarySaleFees.sol\\\";\\nimport \\\"./ERC1155Metadata_URI.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\nimport \\\"../../libs/Ownable.sol\\\";\\nimport \\\"../HasContractURI.sol\\\";\\n\\nabstract contract ERC1155Base is HasSecondarySaleFees, Ownable, ERC1155Metadata_URI, HasContractURI, ERC1155 {\\n\\n    struct Fee {\\n        address payable recipient;\\n        uint256 value;\\n    }\\n\\n    // id => creator\\n    mapping (uint256 => address) public creators;\\n    // id => fees\\n    mapping (uint256 => Fee[]) public fees;\\n\\n    // Max count of fees\\n    uint256 maxFeesCount = 100;\\n\\n    constructor(string memory contractURI, string memory tokenURIPrefix, string memory uri) HasContractURI(contractURI) ERC1155Metadata_URI(tokenURIPrefix) ERC1155(uri) public {\\n\\n    }\\n\\n    function getFeeRecipients(uint256 id) public override view returns (address payable[] memory) {\\n        Fee[] memory _fees = fees[id];\\n        address payable[] memory result = new address payable[](_fees.length);\\n        for (uint i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].recipient;\\n        }\\n        return result;\\n    }\\n\\n    function getFeeBps(uint256 id) public override view returns (uint[] memory) {\\n        Fee[] memory _fees = fees[id];\\n        uint[] memory result = new uint[](_fees.length);\\n        for (uint i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].value;\\n        }\\n        return result;\\n    }\\n\\n    // Creates a new token type and assings _initialSupply to minter\\n    function _mint(uint256 _id, Fee[] memory _fees, uint256 _supply, string memory _uri) internal {\\n        require(\\n            _fees.length <= maxFeesCount,\\n            \\\"Amount of fee recipients can't exceed 100\\\"\\n        );\\n\\n        uint256 sumFeeBps = 0;\\n        for (uint256 i = 0; i < _fees.length; i++) {\\n            sumFeeBps = sumFeeBps.add(_fees[i].value);\\n        }\\n\\n        require(\\n            sumFeeBps <= 10000,\\n            \\\"Total fee bps should not exceed 10000\\\"\\n        );\\n\\n        require(creators[_id] == address(0x0), \\\"Token is already minted\\\");\\n        require(_supply != 0, \\\"Supply should be positive\\\");\\n        require(bytes(_uri).length > 0, \\\"uri should be set\\\");\\n\\n        creators[_id] = msg.sender;\\n        address[] memory recipients = new address[](_fees.length);\\n        uint[] memory bps = new uint[](_fees.length);\\n        for (uint i = 0; i < _fees.length; i++) {\\n            require(_fees[i].recipient != address(0x0), \\\"Recipient should be present\\\");\\n            require(_fees[i].value != 0, \\\"Fee value should be positive\\\");\\n            fees[_id].push(_fees[i]);\\n            recipients[i] = _fees[i].recipient;\\n            bps[i] = _fees[i].value;\\n        }\\n        if (_fees.length > 0) {\\n            emit SecondarySaleFees(_id, recipients, bps);\\n        }\\n        _mint(msg.sender, _id, _supply, \\\"\\\");\\n        //balanceOf(msg.sender, _id) = _supply;\\n        _setTokenURI(_id, _uri);\\n\\n        // Transfer event with mint semantic\\n        emit TransferSingle(msg.sender, address(0x0), msg.sender, _id, _supply);\\n        emit URI(_uri, _id);\\n    }\\n\\n    function burn(address _owner, uint256 _id, uint256 _value) external {\\n\\n        require(_owner == msg.sender || isApprovedForAll(_owner, msg.sender) == true, \\\"Need operator approval for 3rd party burns.\\\");\\n\\n        _burn(_owner, _id, _value);\\n        // SafeMath will throw with insuficient funds _owner\\n        // or if _id is not valid (balance will be 0)\\n        // balanceOf(_owner, _id) = balanceOf( _owner, _id).sub(_value);\\n\\n        // MUST emit event\\n        // emit TransferSingle(msg.sender, _owner, address(0x0), _id, _value);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to set its URI\\n     * @param uri string URI to assign\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory uri) override virtual internal {\\n        require(creators[tokenId] != address(0x0), \\\"_setTokenURI: Token should exist\\\");\\n        super._setTokenURI(tokenId, uri);\\n    }\\n\\n    function setTokenURIPrefix(string memory tokenURIPrefix) public onlyOwner {\\n        _setTokenURIPrefix(tokenURIPrefix);\\n    }\\n\\n    function setContractURI(string memory contractURI) public onlyOwner {\\n        _setContractURI(contractURI);\\n    }\\n\\n    function uri(uint256 _id) override(ERC1155Metadata_URI, ERC1155) external view returns (string memory) {\\n        return _tokenURI(_id);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v1/ERC1155Metadata_URI.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\\\";\\nimport \\\"../HasTokenURI.sol\\\";\\n\\n/**\\n    Note: The ERC-165 identifier for this interface is 0x0e89341c.\\n*/\\nabstract contract ERC1155Metadata_URI is IERC1155MetadataURI, HasTokenURI {\\n\\n    constructor(string memory _tokenURIPrefix) HasTokenURI(_tokenURIPrefix) public {\\n\\n    }\\n\\n    function uri(uint256 _id) override virtual external view returns (string memory) {\\n        return _tokenURI(_id);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\nimport \\\"./IERC1155MetadataURI.sol\\\";\\nimport \\\"./IERC1155Receiver.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n *\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping (uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping (address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address,uint256)')) == 0x00fdd58e\\n     *     bytes4(keccak256('balanceOfBatch(address[],uint256[])')) == 0x4e1273f4\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,uint256,bytes)')) == 0xf242432a\\n     *     bytes4(keccak256('safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)')) == 0x2eb2c2d6\\n     *\\n     *     => 0x00fdd58e ^ 0x4e1273f4 ^ 0xa22cb465 ^\\n     *        0xe985e9c5 ^ 0xf242432a ^ 0x2eb2c2d6 == 0xd9b67a26\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n\\n    /*\\n     *     bytes4(keccak256('uri(uint256)')) == 0x0e89341c\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC1155_METADATA_URI = 0x0e89341c;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor (string memory uri_) public {\\n        _setURI(uri_);\\n\\n        // register the supported interfaces to conform to ERC1155 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155);\\n\\n        // register the supported interfaces to conform to ERC1155MetadataURI via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC1155_METADATA_URI);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) external view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] memory accounts,\\n        uint256[] memory ids\\n    )\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][from] = _balances[id][from].sub(amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        _balances[id][to] = _balances[id][to].add(amount);\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        public\\n        virtual\\n        override\\n    {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            _balances[id][from] = _balances[id][from].sub(\\n                amount,\\n                \\\"ERC1155: insufficient balance for transfer\\\"\\n            );\\n            _balances[id][to] = _balances[id][to].add(amount);\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(address account, uint256 id, uint256 amount, bytes memory data) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] = _balances[id][account].add(amount);\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(address to, uint256[] memory ids, uint256[] memory amounts, bytes memory data) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] = amounts[i].add(_balances[ids[i]][to]);\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(address account, uint256 id, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        _balances[id][account] = _balances[id][account].sub(\\n            amount,\\n            \\\"ERC1155: burn amount exceeds balance\\\"\\n        );\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(address account, uint256[] memory ids, uint256[] memory amounts) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][account] = _balances[ids[i]][account].sub(\\n                amounts[i],\\n                \\\"ERC1155: burn amount exceeds balance\\\"\\n            );\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        internal\\n        virtual\\n    { }\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    )\\n        private\\n    {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/HasTokenURI.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"../libs/StringLibrary.sol\\\";\\n\\ncontract HasTokenURI {\\n    using StringLibrary for string;\\n\\n    //Token URI prefix\\n    string public tokenURIPrefix;\\n\\n    // Optional mapping for token URIs\\n    mapping(uint256 => string) private _tokenURIs;\\n\\n    constructor(string memory _tokenURIPrefix) public {\\n        tokenURIPrefix = _tokenURIPrefix;\\n    }\\n\\n    /**\\n     * @dev Returns an URI for a given token ID.\\n     * Throws if the token ID does not exist. May return an empty string.\\n     * @param tokenId uint256 ID of the token to query\\n     */\\n    function _tokenURI(uint256 tokenId) internal view returns (string memory) {\\n        return tokenURIPrefix.append(_tokenURIs[tokenId]);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param tokenId uint256 ID of the token to set its URI\\n     * @param uri string URI to assign\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory uri) virtual internal {\\n        _tokenURIs[tokenId] = uri;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI prefix.\\n     * @param _tokenURIPrefix string URI prefix to assign\\n     */\\n    function _setTokenURIPrefix(string memory _tokenURIPrefix) internal {\\n        tokenURIPrefix = _tokenURIPrefix;\\n    }\\n\\n    function _clearTokenURI(uint256 tokenId) internal {\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/StringLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nimport \\\"./UintLibrary.sol\\\";\\n\\nlibrary StringLibrary {\\n    using UintLibrary for uint256;\\n\\n    function append(string memory _a, string memory _b) internal pure returns (string memory) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory bab = new bytes(_ba.length + _bb.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\\n        return string(bab);\\n    }\\n\\n    function append(string memory _a, string memory _b, string memory _c) internal pure returns (string memory) {\\n        bytes memory _ba = bytes(_a);\\n        bytes memory _bb = bytes(_b);\\n        bytes memory _bc = bytes(_c);\\n        bytes memory bbb = new bytes(_ba.length + _bb.length + _bc.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) bbb[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) bbb[k++] = _bb[i];\\n        for (uint i = 0; i < _bc.length; i++) bbb[k++] = _bc[i];\\n        return string(bbb);\\n    }\\n\\n    function recover(string memory message, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        bytes memory msgBytes = bytes(message);\\n        bytes memory fullMessage = concat(\\n            bytes(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\"),\\n            bytes(msgBytes.length.toString()),\\n            msgBytes,\\n            new bytes(0), new bytes(0), new bytes(0), new bytes(0)\\n        );\\n        return ecrecover(keccak256(fullMessage), v, r, s);\\n    }\\n\\n    function concat(bytes memory _ba, bytes memory _bb, bytes memory _bc, bytes memory _bd, bytes memory _be, bytes memory _bf, bytes memory _bg) internal pure returns (bytes memory) {\\n        bytes memory resultBytes = new bytes(_ba.length + _bb.length + _bc.length + _bd.length + _be.length + _bf.length + _bg.length);\\n        uint k = 0;\\n        for (uint i = 0; i < _ba.length; i++) resultBytes[k++] = _ba[i];\\n        for (uint i = 0; i < _bb.length; i++) resultBytes[k++] = _bb[i];\\n        for (uint i = 0; i < _bc.length; i++) resultBytes[k++] = _bc[i];\\n        for (uint i = 0; i < _bd.length; i++) resultBytes[k++] = _bd[i];\\n        for (uint i = 0; i < _be.length; i++) resultBytes[k++] = _be[i];\\n        for (uint i = 0; i < _bf.length; i++) resultBytes[k++] = _bf[i];\\n        for (uint i = 0; i < _bg.length; i++) resultBytes[k++] = _bg[i];\\n        return resultBytes;\\n    }\\n}\"\r\n    },\r\n    \"contracts/libs/UintLibrary.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\n// SPDX-License-Identifier: UNLICENSED\\n\\nlibrary UintLibrary {\\n    function toString(uint256 _i) internal pure returns (string memory) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len - 1;\\n        while (_i != 0) {\\n            bstr[k--] = byte(uint8(48 + _i % 10));\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    )\\n        external\\n        returns(bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v1/RefinableERC1155WhiteListedToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC1155Base.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\n\\ncontract RefinableERC1155WhiteListedToken is ERC1155Base, MinterRole {\\n\\n    using ECDSA for bytes32;\\n\\n    string public name;\\n    string public symbol;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(string memory _name, string memory _symbol, address _signer, string memory _contractURI, string memory _tokenURIPrefix, string memory _uri) ERC1155Base(_contractURI, _tokenURIPrefix, _uri) public {\\n        name = _name;\\n        symbol = _symbol;\\n\\n        addSigner(_msgSender());\\n        addSigner(_signer);\\n        _registerInterface(bytes4(keccak256('MINT_WITH_ADDRESS')));\\n    }\\n\\n    function mint(uint256 _tokenId, bytes memory _signature, Fee[] memory _fees, uint256 _supply, string memory _uri) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        ,\\\"invalid signature\\\"\\n        );\\n        _mint(_tokenId, _fees, _supply, _uri);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/ERC721BaseV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721Burnable.sol\\\";\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"../HasSecondarySale.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../Royalty.sol\\\";\\n\\n/**\\n * @title Full ERC721 Token with support for baseURI\\n * This implementation includes all the required and some optional functionality of the ERC721 standard\\n * Moreover, it includes approve all functionality using operator terminology\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\nabstract contract ERC721BaseV3 is\\nHasSecondarySale,\\nHasContractURI,\\nERC721Burnable,\\nMinterRole,\\nRoyalty\\n{\\n    /// @dev sale is primary or secondary\\n    mapping(uint256 => bool) public isSecondarySale;\\n\\n    /*\\n     * bytes4(keccak256('MINT_WITH_ADDRESS')) == 0xe37243f2\\n     */\\n    bytes4 private constant _INTERFACE_ID_MINT_WITH_ADDRESS = 0xe37243f2;\\n\\n\\n    /**\\n     * @dev Constructor function\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory contractURI,\\n        string memory _baseURI\\n    ) public HasContractURI(contractURI) ERC721(_name, _symbol) {\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_MINT_WITH_ADDRESS);\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function checkSecondarySale(uint256 _tokenId) public view override returns (bool) {\\n        return isSecondarySale[_tokenId];\\n    }\\n\\n    function setSecondarySale(uint256 _tokenId) public override {\\n        isSecondarySale[_tokenId] = true;\\n    }\\n\\n    function _mint(\\n        address _to,\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) internal {\\n        require(_exists(_tokenId) == false, \\\"ERC721: Token is already minted\\\");\\n        require(bytes(_uri).length > 0, \\\"ERC721: Uri should be set\\\");\\n\\n        _mint(_to, _tokenId);\\n        _setTokenURI(_tokenId, _uri);\\n        creators[_tokenId] = _to;\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps.add(_royaltyShares[i].value);\\n        }\\n\\n        if (_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"ERC721: Total fee bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10 ** 4,\\n                \\\"ERC721: Total fee bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps, RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY) {\\n            uint256 sumPrimaryRoyaltyShareBps;\\n            for (uint256 i = 0; i < _primaryRoyaltyShares.length; i++) {\\n                sumPrimaryRoyaltyShareBps = sumPrimaryRoyaltyShareBps + _primaryRoyaltyShares[i].value;\\n            }\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            require(\\n                sumPrimaryRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total primary royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY);\\n            _addPrimaryRoyaltyShares(_tokenId, _primaryRoyaltyShares);\\n        } else {\\n            revert(\\\"ERC721: Royalty option does not exist\\\");\\n        }\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n    }\\n\\n    function setBaseURI(string memory _baseURI) public onlyAdmin {\\n        _setBaseURI(_baseURI);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyAdmin {\\n        _setContractURI(_contractURI);\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/WhiteListedTokenERC721V3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC721BaseV3.sol\\\";\\n/**\\n * @title RefinableERC721TokenWhiteListed\\n * @dev only minters can mint token.\\n\\n */\\ncontract WhiteListedTokenERC721V3 is ERC721BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721BaseV3(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory defaultPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0)\\n            defaultPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n        _mint(msg.sender, _tokenId, _royaltyShares, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyShares);\\n    }\\n\\n    function mintSimilarBatch(\\n        uint256[] memory _tokenIds,\\n        bytes[] memory _signatures,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string[] memory _uris,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n\\n        require(_tokenIds.length < 101, \\\"You can only batch mint 100 tokens\\\");\\n\\n        for(uint i = 0; i < _tokenIds.length; i++) {\\n            mint(_tokenIds[i], _signatures[i], _royaltyShares, _uris[i], _royaltyBps, _royaltyStrategy, _primaryRoyaltyShares);\\n        }\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC721: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/WhiteListedTokenERC1155V3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC1155BaseV3.sol\\\";\\nimport \\\"../../../libs/RoyaltyLibrary.sol\\\";\\n\\ncontract WhiteListedTokenERC1155V3 is ERC1155BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV3(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    //add the default royalties if the contract has set\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory defaultPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0)\\n            defaultPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyShares);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC1155: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/ERC1155BaseV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"../HasTokenURI.sol\\\";\\nimport \\\"./ERC1155Supply.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../Royalty.sol\\\";\\nimport \\\"../../interfaces/ICreator.sol\\\";\\nimport \\\"../../interfaces/IPrimaryRoyalty.sol\\\";\\n\\nabstract contract ERC1155BaseV3 is\\nHasTokenURI,\\nHasContractURI,\\nERC1155Supply,\\nMinterRole,\\nRoyalty\\n{\\n    string public name;\\n    string public symbol;\\n\\n    /*\\n     * bytes4(keccak256('MINT_WITH_ADDRESS')) == 0xe37243f2\\n     */\\n    bytes4 private constant _INTERFACE_ID_MINT_WITH_ADDRESS = 0xe37243f2;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) HasContractURI(_contractURI) HasTokenURI(_tokenURIPrefix) ERC1155(_uri) public {\\n        name = _name;\\n        symbol = _symbol;\\n        _registerInterface(_INTERFACE_ID_MINT_WITH_ADDRESS);\\n    }\\n\\n    // Creates a new token type and assings _initialSupply to minter\\n    function _mint(\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) internal {\\n        require(exists(_tokenId) == false, \\\"ERC1155: Token is already minted\\\");\\n        require(_supply != 0, \\\"ERC1155: Supply should be positive\\\");\\n        require(bytes(_uri).length > 0, \\\"ERC1155: Uri should be set\\\");\\n\\n        _mint(_msgSender(), _tokenId, _supply, \\\"\\\");\\n        _setTokenURI(_tokenId, _uri);\\n        creators[_tokenId] = _msgSender();\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps.add(_royaltyShares[i].value);\\n        }\\n\\n        if (_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"ERC1155: Total fee bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10 ** 4,\\n                \\\"ERC1155: Total fee bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps, RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY) {\\n            uint256 sumPrimaryRoyaltyShareBps;\\n            for (uint256 i = 0; i < _primaryRoyaltyShares.length; i++) {\\n                sumPrimaryRoyaltyShareBps = sumPrimaryRoyaltyShareBps + _primaryRoyaltyShares[i].value;\\n            }\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            require(\\n                sumPrimaryRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total primary royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY);\\n            _addPrimaryRoyaltyShares(_tokenId, _primaryRoyaltyShares);\\n        } else {\\n            revert(\\\"ERC1155: Royalty option does not exist\\\");\\n        }\\n\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n\\n        // Transfer event with mint semantic\\n        emit URI(_uri, _tokenId);\\n    }\\n\\n\\n    function burn(address _owner, uint256 _tokenId, uint256 _value) external {\\n        _burn(_owner, _tokenId, _value);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param _tokenId uint256 ID of the token to set its URI\\n     * @param _uri string URI to assign\\n     */\\n    function _setTokenURI(uint256 _tokenId, string memory _uri) override virtual internal {\\n        require(exists(_tokenId), \\\"ERC1155: Token should exist\\\");\\n        super._setTokenURI(_tokenId, _uri);\\n    }\\n\\n    function setTokenURIPrefix(string memory _tokenURIPrefix) public onlyAdmin {\\n        _setTokenURIPrefix(_tokenURIPrefix);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyAdmin {\\n        _setContractURI(_contractURI);\\n    }\\n\\n    function uri(uint256 _tokenId) override external view returns (string memory) {\\n        return _tokenURI(_tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v3/ERC1155Supply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates weither any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] += amounts[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual override {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155Supply: caller is not owner nor approved\\\"\\n        );\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual override {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155Supply: caller is not owner nor approved\\\"\\n        );\\n        super._burnBatch(account, ids, amounts);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/IMXHKERC1155WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC1155BaseV3.sol\\\";\\nimport \\\"../../../libs/RoyaltyLibrary.sol\\\";\\n\\ncontract IMXHKERC1155WhiteListedTokenV3 is ERC1155BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV3(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    //add the default royalties if the contract has set\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory defaultPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0)\\n            defaultPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyShares);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC1155: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/RefinableERC1155WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC1155BaseV3.sol\\\";\\n\\ncontract RefinableERC1155WhiteListedTokenV3 is ERC1155BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV3(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory customPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0) {\\n            customPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n        } else {\\n            customPrimaryRoyaltyShares = _primaryRoyaltyShares;\\n        } \\n\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, _royaltyStrategy, customPrimaryRoyaltyShares);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC1155: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/DAFERC1155WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC1155BaseV3.sol\\\";\\nimport \\\"../../../libs/RoyaltyLibrary.sol\\\";\\n\\ncontract DAFERC1155WhiteListedTokenV3 is ERC1155BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV3(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    //add the default royalties if the contract has set\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory defaultPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0)\\n            defaultPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyShares);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC1155: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/CoralERC1155WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC1155BaseV3.sol\\\";\\nimport \\\"../../../libs/RoyaltyLibrary.sol\\\";\\n\\ncontract CoralERC1155WhiteListedTokenV3 is ERC1155BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    RoyaltyLibrary.RoyaltyShareDetails[] public defaultPrimaryRoyaltyReceivers;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV3(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    //add the default royalties if the contract has set\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyReceivers);\\n    }\\n\\n    function setPrimaryDefaultRoyaltyReceivers(RoyaltyLibrary.RoyaltyShareDetails[] memory _receivers) public onlyAdmin {\\n        delete defaultPrimaryRoyaltyReceivers;\\n        for (uint256 i = 0; i < _receivers.length; i++) {\\n            defaultPrimaryRoyaltyReceivers.push(_receivers[i]);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/mock/RoyaltyERC721Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"../../interfaces/IRoyalty.sol\\\";\\nimport \\\"../../interfaces/IHasSecondarySale.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"./RanERC721Mock.sol\\\";\\nimport \\\"../../interfaces/ICreator.sol\\\";\\nimport \\\"../../interfaces/IPrimaryRoyalty.sol\\\";\\n\\n\\ncontract RoyaltyERC721Mock is Context, IRoyalty, IHasSecondarySale, ERC165, ICreator, IPrimaryRoyalty {\\n    event SetRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    event SetRoyalty (\\n        address owner,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        RoyaltyLibrary.Strategy strategy\\n    );\\n\\n    event SetPrimaryRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    // tokenId => royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyInfo) royalty;\\n\\n    // tokenId => royaltyShares\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) royaltyShares;\\n\\n    // tokenId => bool: true is first sale, false is secondary sale\\n    mapping(uint256 => bool) isSecondarySale;\\n\\n    // ERC721/1155 Address\\n    address tokenContract;\\n\\n    // Max count of royalty shares\\n    uint256 maxRoyaltyShareCount;\\n\\n    // tokenId => creator address\\n    mapping(uint256 => address) creators;\\n\\n    // tokenId => primary royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) primaryRoyaltyShares;\\n\\n    constructor (address _tokenContract, uint256 _maxRoyaltyShareCount) public {\\n        tokenContract = _tokenContract;\\n        maxRoyaltyShareCount = _maxRoyaltyShareCount;\\n\\n        _registerInterface(type(IRoyalty).interfaceId);\\n        _registerInterface(type(IHasSecondarySale).interfaceId);\\n        _registerInterface(type(IPrimaryRoyalty).interfaceId);\\n        _registerInterface(type(ICreator).interfaceId);\\n    }\\n\\n    function getTokenContract() external view override returns (address) {\\n        return tokenContract;\\n    }\\n\\n    //    // Optional\\n    //    function setTokenContract(address token);\\n\\n    function getRoyalty(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyInfo memory) {\\n        return royalty[_tokenId];\\n    }\\n\\n    function getRoyaltyShares(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return royaltyShares[_tokenId];\\n    }\\n\\n    function checkSecondarySale(uint256 _tokenId) public view override returns (bool) {\\n        return isSecondarySale[_tokenId];\\n    }\\n\\n    function setSecondarySale(uint256 _tokenId) public override {\\n        isSecondarySale[_tokenId] = true;\\n    }\\n\\n    function getPrimaryRoyaltyShares(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return primaryRoyaltyShares[_tokenId];\\n    }\\n\\n    function getCreator(uint256 _tokenId) external view override returns (address) {\\n        return creators[_tokenId];\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        string memory _uri,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public {\\n        RanERC721Mock(tokenContract).mint(_msgSender(), _tokenId);\\n        _addRoyalties(_tokenId, _royaltyShares, _royaltyBps, _royaltyStrategy, _primaryRoyaltyShares);\\n        creators[_tokenId] = _msgSender();\\n    }\\n\\n    // Optional to make it public or not\\n    function _addRoyalties(\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) internal {\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps + _royaltyShares[i].value;\\n        }\\n\\n        if (_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps, RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY) {\\n            uint256 sumPrimaryRoyaltyShareBps;\\n            for (uint256 i = 0; i < _primaryRoyaltyShares.length; i++) {\\n                sumPrimaryRoyaltyShareBps = sumPrimaryRoyaltyShareBps + _primaryRoyaltyShares[i].value;\\n            }\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            require(\\n                sumPrimaryRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total primary royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY);\\n            _addPrimaryRoyaltyShares(_tokenId, _primaryRoyaltyShares);\\n        } else {\\n            revert(\\\"Royalty: Royalty option does not exist\\\");\\n        }\\n\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n    }\\n\\n    function _setRoyalty(uint256 _tokenId, uint256 _bps, RoyaltyLibrary.Strategy _strategy) internal {\\n        require(\\n            _bps <= 10 ** 4,\\n            \\\"Royalty: Total royalty bps should not exceed 10000\\\"\\n        );\\n        royalty[_tokenId] = RoyaltyLibrary.RoyaltyInfo({\\n        value : _bps,\\n        strategy : _strategy\\n        });\\n        emit SetRoyalty(_msgSender(), _tokenId, _bps, _strategy);\\n    }\\n\\n    function _addRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        // Pushing the royalty shares into the mapping\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Royalty share bps value should be positive\\\");\\n            royaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n\\n    function _addPrimaryRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        // Pushing the royalty shares into the mapping\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Primary royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Primary royalty share bps value should be positive\\\");\\n            primaryRoyaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetPrimaryRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/mock/RanERC721Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/ERC721.sol\\\";\\n\\ncontract RanERC721Mock is ERC721 {\\n    constructor (string memory name, string memory symbol) ERC721 (name, symbol) public {}\\n\\n    function mint(address to, uint256 tokenId) public {\\n        _mint(to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/mock/RoyaltyERC1155Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/introspection/ERC165.sol\\\";\\nimport \\\"../../interfaces/IRoyalty.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"./RanERC1155Mock.sol\\\";\\nimport \\\"../../interfaces/ICreator.sol\\\";\\nimport \\\"../../interfaces/IPrimaryRoyalty.sol\\\";\\n\\n\\ncontract RoyaltyERC1155Mock is Context, IRoyalty, ERC165, ICreator, IPrimaryRoyalty {\\n    event SetRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    event SetRoyalty (\\n        address owner,\\n        uint256 indexed tokenId,\\n        uint256 value,\\n        RoyaltyLibrary.Strategy strategy\\n    );\\n\\n    event SetPrimaryRoyaltyShares (\\n        uint256 indexed tokenId,\\n        address[] recipients,\\n        uint[] bp\\n    );\\n\\n    // tokenId => royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyInfo) royalty;\\n\\n    // tokenId => royaltyShares\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) royaltyShares;\\n\\n    // tokenId => bool: true is first sale, false is secondary sale\\n    mapping(uint256 => bool) isSecondarySale;\\n\\n    // ERC721/1155 Address\\n    address tokenContract;\\n\\n    // Max count of royalty shares\\n    uint256 maxRoyaltyShareCount;\\n\\n    // tokenId => creator address\\n    mapping(uint256 => address) creators;\\n\\n    // tokenId => primary royalty\\n    mapping(uint256 => RoyaltyLibrary.RoyaltyShareDetails[]) primaryRoyaltyShares;\\n\\n    constructor (address _tokenContract, uint256 _maxRoyaltyShareCount) public {\\n        tokenContract = _tokenContract;\\n        maxRoyaltyShareCount = _maxRoyaltyShareCount;\\n\\n        _registerInterface(type(IRoyalty).interfaceId);\\n        _registerInterface(type(IPrimaryRoyalty).interfaceId);\\n        _registerInterface(type(ICreator).interfaceId);\\n    }\\n\\n    function getTokenContract() external view override returns (address) {\\n        return tokenContract;\\n    }\\n\\n    //    // Optional\\n    //    function setTokenContract(address token);\\n\\n    function getRoyalty(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyInfo memory) {\\n        return royalty[_tokenId];\\n    }\\n\\n    function getRoyaltyShares(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return royaltyShares[_tokenId];\\n    }\\n\\n    function getPrimaryRoyaltyShares(uint256 _tokenId) external view override returns (RoyaltyLibrary.RoyaltyShareDetails[] memory) {\\n        return primaryRoyaltyShares[_tokenId];\\n    }\\n\\n    function getCreator(uint256 _tokenId) external view override returns (address) {\\n        return creators[_tokenId];\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        uint256 _supply,\\n        string memory _uri,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public {\\n        RanERC1155Mock(tokenContract).mint(_msgSender(), _tokenId, _supply);\\n        _addRoyalties(_tokenId, _royaltyShares, _royaltyBps, _royaltyStrategy, _primaryRoyaltyShares);\\n        creators[_tokenId] = _msgSender();\\n    }\\n\\n    // Optional to make it public or not\\n    function _addRoyalties(\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) internal {\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps + _royaltyShares[i].value;\\n        }\\n\\n        if (_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps, RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY) {\\n            uint256 sumPrimaryRoyaltyShareBps;\\n            for (uint256 i = 0; i < _primaryRoyaltyShares.length; i++) {\\n                sumPrimaryRoyaltyShareBps = sumPrimaryRoyaltyShareBps + _primaryRoyaltyShares[i].value;\\n            }\\n            require(\\n                sumRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total royalty share bps should not exceed 10000\\\"\\n            );\\n            require(\\n                sumPrimaryRoyaltyShareBps <= 10 ** 4,\\n                \\\"Royalty: Total primary royalty share bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY);\\n            _addPrimaryRoyaltyShares(_tokenId, _primaryRoyaltyShares);\\n        } else {\\n            revert(\\\"Royalty: Royalty option does not exist\\\");\\n        }\\n\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n    }\\n\\n    function _setRoyalty(uint256 _tokenId, uint256 _bps, RoyaltyLibrary.Strategy _strategy) internal {\\n        require(\\n            _bps <= 10 ** 4,\\n            \\\"Royalty: Total royalty bps should not exceed 10000\\\"\\n        );\\n        royalty[_tokenId] = RoyaltyLibrary.RoyaltyInfo({\\n        value : _bps,\\n        strategy : _strategy\\n        });\\n        emit SetRoyalty(_msgSender(), _tokenId, _bps, _strategy);\\n    }\\n\\n    function _addRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        // Pushing the royalty shares into the mapping\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Royalty share bps value should be positive\\\");\\n            royaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n\\n    function _addPrimaryRoyaltyShares(uint256 _tokenId, RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares) internal {\\n        require(\\n            _royaltyShares.length <= maxRoyaltyShareCount,\\n            \\\"Royalty: Amount of royalty recipients can't exceed 100\\\"\\n        );\\n\\n        address[] memory recipients = new address[](_royaltyShares.length);\\n        uint[] memory bps = new uint[](_royaltyShares.length);\\n        // Pushing the royalty shares into the mapping\\n        for (uint i = 0; i < _royaltyShares.length; i++) {\\n            require(_royaltyShares[i].recipient != address(0x0), \\\"Royalty: Primary royalty share recipient should be present\\\");\\n            require(_royaltyShares[i].value != 0, \\\"Royalty: Primary royalty share bps value should be positive\\\");\\n            primaryRoyaltyShares[_tokenId].push(_royaltyShares[i]);\\n            recipients[i] = _royaltyShares[i].recipient;\\n            bps[i] = _royaltyShares[i].value;\\n        }\\n        if (_royaltyShares.length > 0) {\\n            emit SetPrimaryRoyaltyShares(_tokenId, recipients, bps);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/mock/RanERC1155Mock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n\\ncontract RanERC1155Mock is ERC1155 {\\n    constructor (string memory uri) ERC1155 (uri) public {}\\n\\n    function mint(address account, uint256 id, uint256 amount) public {\\n        _mint(account, id, amount, '');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/ERC1155Supply.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\\\";\\n\\n/**\\n * @dev Extension of ERC1155 that adds tracking of total supply per id.\\n *\\n * Useful for scenarios where Fungible and Non-fungible tokens have to be\\n * clearly identified. Note: While a totalSupply of 1 might mean the\\n * corresponding is an NFT, there is no guarantees that no other token with the\\n * same id are not going to be minted.\\n */\\nabstract contract ERC1155Supply is ERC1155 {\\n    mapping(uint256 => uint256) private _totalSupply;\\n\\n    /**\\n     * @dev Total amount of tokens in with a given id.\\n     */\\n    function totalSupply(uint256 id) public view virtual returns (uint256) {\\n        return _totalSupply[id];\\n    }\\n\\n    /**\\n     * @dev Indicates weither any token exist with a given id, or not.\\n     */\\n    function exists(uint256 id) public view virtual returns (bool) {\\n        return ERC1155Supply.totalSupply(id) > 0;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mint}.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._mint(account, id, amount, data);\\n        _totalSupply[id] += amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_mintBatch}.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual override {\\n        super._mintBatch(to, ids, amounts, data);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] += amounts[i];\\n        }\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burn}.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual override {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155Supply: caller is not owner nor approved\\\"\\n        );\\n        super._burn(account, id, amount);\\n        _totalSupply[id] -= amount;\\n    }\\n\\n    /**\\n     * @dev See {ERC1155-_burnBatch}.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual override {\\n        require(\\n            account == _msgSender() || isApprovedForAll(account, _msgSender()),\\n            \\\"ERC1155Supply: caller is not owner nor approved\\\"\\n        );\\n        super._burnBatch(account, ids, amounts);\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            _totalSupply[ids[i]] -= amounts[i];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/ERC1155BaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../HasContractURI.sol\\\";\\nimport \\\"../HasTokenURI.sol\\\";\\nimport \\\"./ERC1155Supply.sol\\\";\\nimport \\\"../../roles/MinterRole.sol\\\";\\nimport \\\"../../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../Royalty.sol\\\";\\n\\nabstract contract ERC1155BaseV2 is\\nHasTokenURI,\\nHasContractURI,\\nERC1155Supply,\\nMinterRole,\\nRoyalty\\n{\\n    string public name;\\n    string public symbol;\\n\\n    /*\\n     * bytes4(keccak256('MINT_WITH_ADDRESS')) == 0xe37243f2\\n     */\\n    bytes4 private constant _INTERFACE_ID_MINT_WITH_ADDRESS = 0xe37243f2;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) HasContractURI(_contractURI) HasTokenURI(_tokenURIPrefix) ERC1155(_uri) public {\\n        name = _name;\\n        symbol = _symbol;\\n        _registerInterface(_INTERFACE_ID_MINT_WITH_ADDRESS);\\n    }\\n\\n    // Creates a new token type and assings _initialSupply to minter\\n    function _mint(\\n        uint256 _tokenId,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) internal {\\n        require(exists(_tokenId) == false, \\\"ERC1155: Token is already minted\\\");\\n        require(_supply != 0, \\\"ERC1155: Supply should be positive\\\");\\n        require(bytes(_uri).length > 0, \\\"ERC1155: Uri should be set\\\");\\n\\n        _mint(msg.sender, _tokenId, _supply, \\\"\\\");\\n        _setTokenURI(_tokenId, _uri);\\n        uint256 sumRoyaltyShareBps;\\n        for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n            sumRoyaltyShareBps = sumRoyaltyShareBps.add(_royaltyShares[i].value);\\n        }\\n\\n        if(_royaltyStrategy == RoyaltyLibrary.Strategy.ROYALTY_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps <= 10**4,\\n                \\\"ERC1155: Total fee bps should not exceed 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, sumRoyaltyShareBps, RoyaltyLibrary.Strategy.ROYALTY_STRATEGY);\\n        } else if (_royaltyStrategy == RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY) {\\n            require(\\n                sumRoyaltyShareBps == 10**4,\\n                \\\"ERC1155: Total fee bps should be 10000\\\"\\n            );\\n            _setRoyalty(_tokenId, _royaltyBps,  RoyaltyLibrary.Strategy.PROFIT_DISTRIBUTION_STRATEGY);\\n        }else{\\n            revert(\\\"ERC1155: Royalty option does not exist\\\");\\n        }\\n\\n        _addRoyaltyShares(_tokenId, _royaltyShares);\\n\\n        // Transfer event with mint semantic\\n        emit URI(_uri, _tokenId);\\n    }\\n\\n    function burn(address _owner, uint256 _tokenId, uint256 _value) external {\\n        _burn(_owner, _tokenId, _value);\\n    }\\n\\n    /**\\n     * @dev Internal function to set the token URI for a given token.\\n     * Reverts if the token ID does not exist.\\n     * @param _tokenId uint256 ID of the token to set its URI\\n     * @param _uri string URI to assign\\n     */\\n    function _setTokenURI(uint256 _tokenId, string memory _uri) override virtual internal {\\n        require(exists(_tokenId), \\\"ERC1155: Token should exist\\\");\\n        super._setTokenURI(_tokenId, _uri);\\n    }\\n\\n    function setTokenURIPrefix(string memory _tokenURIPrefix) public onlyAdmin {\\n        _setTokenURIPrefix(_tokenURIPrefix);\\n    }\\n\\n    function setContractURI(string memory _contractURI) public onlyAdmin {\\n        _setContractURI(_contractURI);\\n    }\\n\\n    function uri(uint256 _tokenId) override external view returns (string memory) {\\n        return _tokenURI(_tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/RefinableERC1155WhiteListedTokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC1155BaseV2.sol\\\";\\n\\ncontract RefinableERC1155WhiteListedTokenV2 is ERC1155BaseV2 {\\n\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV2(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    //add the default royalties if the contract has set\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) public onlyMinter {\\n        require(\\n            hasRole(SIGNER_ROLE,\\n            keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n            .toEthSignedMessageHash()\\n            .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory newRoyaltyShares;\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0) {\\n            newRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](_royaltyShares.length + 1);\\n            for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n                newRoyaltyShares[i] = _royaltyShares[i];\\n            }\\n            newRoyaltyShares[_royaltyShares.length] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n        } else {\\n            newRoyaltyShares = _royaltyShares;\\n        }\\n\\n        _mint(_tokenId, newRoyaltyShares, _supply, _uri, _royaltyBps, _royaltyStrategy);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10**4, \\\"ERC721: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tokens/v2/RefinableERC1155TokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC1155BaseV2.sol\\\";\\n\\ncontract RefinableERC1155TokenV2 is ERC1155BaseV2 {\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _tokenURIPrefix token URI Prefix\\n     * @param _uri ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _tokenURIPrefix,\\n        string memory _uri\\n    ) ERC1155BaseV2(_name, _symbol, _contractURI, _tokenURIPrefix, _uri) public {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        uint256 _supply,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) public {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, _msgSender()))\\n                .toEthSignedMessageHash()\\n                .recover(_signature)\\n            )\\n        , \\\"invalid signature\\\"\\n        );\\n        _mint(_tokenId, _royaltyShares, _supply, _uri, _royaltyBps, _royaltyStrategy);\\n    }\\n}\"\r\n    },\r\n    \"contracts/sale/ERC1155Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport \\\"./ERC1155SaleNonceHolder.sol\\\";\\nimport \\\"../tokens/v1/HasSecondarySaleFees.sol\\\";\\nimport \\\"../proxy/TransferProxy.sol\\\";\\nimport \\\"../proxy/ServiceFeeProxy.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\nimport \\\"../managers/TradeTokenManager.sol\\\";\\nimport \\\"../managers/NftTokenManager.sol\\\";\\nimport \\\"../libs/RoyaltyLibrary.sol\\\";\\nimport \\\"../service_fee/RoyaltiesStrategy.sol\\\";\\nimport \\\"../interfaces/ICreator.sol\\\";\\n\\nimport \\\"./VipPrivatePublicSaleInfo.sol\\\";\\n\\ncontract ERC1155Sale is ReentrancyGuard, RoyaltiesStrategy, VipPrivatePublicSaleInfo {\\n  using ECDSA for bytes32;\\n    using RoyaltyLibrary for RoyaltyLibrary.Strategy;\\n\\n    event CloseOrder(\\n        address indexed token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        uint256 nonce\\n    );\\n    event Buy(\\n        address indexed token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        address payToken,\\n        uint256 price,\\n        address buyer,\\n        uint256 value\\n    );    \\n\\n    bytes constant EMPTY = \\\"\\\";\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    address public transferProxy;\\n    address public serviceFeeProxy;\\n    address public nonceHolder;\\n    address public tradeTokenManager;\\n\\n    constructor(\\n        address _transferProxy,\\n        address _nonceHolder,\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) public {\\n        transferProxy = _transferProxy;\\n        nonceHolder = _nonceHolder;\\n        serviceFeeProxy = _serviceFeeProxy;\\n        tradeTokenManager = _tradeTokenManager;\\n    }\\n\\n    function buy(\\n        address _token,\\n        address _royaltyToken,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        uint256 _selling,\\n        uint256 _buying,\\n        bytes memory _signature\\n    ) public payable nonReentrant {\\n\\n        bytes32 saleId = getID(_owner, _token, _tokenId);\\n\\n        // clean up saleInfo\\n        if(!whitelistNeeded(saleId) && saleInfo[saleId].vipSaleDate >= 0) {\\n            delete saleInfo[saleId];\\n        }\\n\\n        require(\\n            IERC1155(_token).supportsInterface(_INTERFACE_ID_ERC1155),\\n            \\\"ERC1155Sale: Invalid NFT\\\"\\n        );\\n\\n        if (_royaltyToken != address(0)) {\\n            require(\\n                IERC1155(_royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2),\\n                \\\"ERC1155Sale: Invalid royalty contract\\\"\\n            );\\n            require(\\n                IRoyalty(_royaltyToken).getTokenContract() == _token,\\n                \\\"ERC1155Sale: Royalty Token address does not match buy token\\\"\\n            );\\n        }\\n\\n        require(whitelisted(saleId, msg.sender), \\\"You should be whitelisted and sale should have started\\\");\\n\\n        require(\\n            IERC1155(_token).balanceOf(_owner, _tokenId) >= _buying,\\n            \\\"ERC1155Sale: Owner doesn't enough tokens\\\"\\n        );\\n\\n        uint256 receiveAmount;\\n        if (_payToken == address(0)) {\\n            receiveAmount = msg.value;\\n        } else {\\n            require(TradeTokenManager(tradeTokenManager).supportToken(_payToken) == true, \\\"ERC721Sale: Pay Token is not allowed\\\");\\n            receiveAmount = IBEP20(_payToken).allowance(msg.sender, address(this));\\n        }\\n\\n        uint256 price = receiveAmount.mul(10 ** 4).div(ServiceFeeProxy(serviceFeeProxy).getBuyServiceFeeBps(msg.sender).add(10 ** 4)).div(_buying);\\n\\n        uint256 nonce = verifySignature(\\n            _token,\\n            _tokenId,\\n            _payToken,\\n            _owner,\\n            _selling,\\n            price,\\n            _signature\\n        );\\n        verifyOpenAndModifyState(\\n            _token,\\n            _tokenId,\\n            _owner,\\n            nonce,\\n            _selling,\\n            _buying\\n        );\\n\\n        TransferProxy(transferProxy).erc1155safeTransferFrom(\\n            _token,\\n            _owner,\\n            msg.sender,\\n            _tokenId,\\n            _buying,\\n            EMPTY\\n        );\\n\\n        if (_royaltyToken != address(0)) {\\n            _distributeProfit(_royaltyToken, _tokenId, _payToken, _owner, price.mul(_buying), receiveAmount);\\n        } else {\\n            _distributeProfit(_token, _tokenId, _payToken, _owner, price.mul(_buying), receiveAmount);\\n        }\\n        emit Buy(_token, _tokenId, _owner, _payToken, price, msg.sender, _buying);\\n    }\\n\\n    function _distributeProfit(\\n        address _token,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        uint256 _totalPrice,\\n        uint256 _receiveAmount\\n    ) internal {\\n        bool isSecondarySale = _checkSecondarySale(_token, _tokenId, _owner);\\n        uint256 sellerServiceFeeBps = ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(_owner, isSecondarySale);\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        uint256 sellerServiceFee = _totalPrice.mul(sellerServiceFeeBps).div(10 ** 4);\\n        /*\\n           * The sellerReceiveAmount is on sale price minus seller service fee minus buyer service fee\\n           * This make sures we have enough balance even the royalties is 100%\\n        */\\n        uint256 sellerReceiveAmount = _totalPrice.sub(sellerServiceFee);\\n        uint256 royalties;\\n        if (\\n            IERC165(_token).supportsInterface(_INTERFACE_ID_FEES)\\n            || IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY)\\n            || IERC165(_token).supportsInterface(_INTERFACE_ID_ROYALTY_V2)\\n        )\\n            royalties = _payOutRoyaltiesByStrategy(_token, _tokenId, _payToken, _msgSender(), sellerReceiveAmount, isSecondarySale);\\n\\n        sellerReceiveAmount = sellerReceiveAmount.sub(royalties);\\n        if (_payToken == address(0)) {\\n            _owner.transfer(sellerReceiveAmount);\\n            serviceFeeRecipient.transfer(sellerServiceFee.add(_receiveAmount.sub(_totalPrice)));\\n        } else {\\n            IBEP20(_payToken).transferFrom(_msgSender(), _owner, sellerReceiveAmount);\\n            IBEP20(_payToken).transferFrom(_msgSender(), serviceFeeRecipient, sellerServiceFee.add(_receiveAmount.sub(_totalPrice)));\\n        }\\n    }\\n\\n    function _checkSecondarySale(address _token, uint256 _tokenId, address _seller) internal returns (bool){\\n        if (IERC165(_token).supportsInterface(type(ICreator).interfaceId)) {\\n            address creator = ICreator(_token).getCreator(_tokenId);\\n            return (creator != _seller);\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function cancel(address token, uint256 tokenId) public {\\n        uint256 nonce = ERC1155SaleNonceHolder(nonceHolder).getNonce(token, tokenId, msg.sender);\\n        ERC1155SaleNonceHolder(nonceHolder).setNonce(token, tokenId, msg.sender, nonce.add(1));\\n\\n        emit CloseOrder(token, tokenId, msg.sender, nonce.add(1));\\n    }\\n\\n    function verifySignature(\\n        address _token,\\n        uint256 _tokenId,\\n        address _payToken,\\n        address payable _owner,\\n        uint256 _selling,\\n        uint256 _price,\\n        bytes memory _signature\\n    ) internal view returns (uint256 nonce) {\\n        nonce = ERC1155SaleNonceHolder(nonceHolder).getNonce(_token, _tokenId, _owner);\\n        address owner;\\n\\n        if (_payToken == address(0)) {\\n            owner = keccak256(abi.encodePacked(_token, _tokenId, _price, _selling, nonce))\\n            .toEthSignedMessageHash()\\n            .recover(_signature);\\n        } else {\\n            owner = keccak256(abi.encodePacked(_token, _tokenId, _payToken, _price, _selling, nonce))\\n            .toEthSignedMessageHash()\\n            .recover(_signature);\\n        }\\n\\n        require(\\n            owner == _owner,\\n            \\\"ERC1155Sale: Incorrect signature\\\"\\n        );\\n    }\\n\\n    function verifyOpenAndModifyState(\\n        address _token,\\n        uint256 _tokenId,\\n        address payable _owner,\\n        uint256 _nonce,\\n        uint256 _selling,\\n        uint256 _buying\\n    ) internal {\\n        uint256 comp = ERC1155SaleNonceHolder(nonceHolder)\\n        .getCompleted(_token, _tokenId, _owner, _nonce)\\n        .add(_buying);\\n        require(comp <= _selling);\\n        ERC1155SaleNonceHolder(nonceHolder).setCompleted(_token, _tokenId, _owner, _nonce, comp);\\n\\n        if (comp == _selling) {\\n            ERC1155SaleNonceHolder(nonceHolder).setNonce(_token, _tokenId, _owner, _nonce.add(1));\\n            emit CloseOrder(_token, _tokenId, _owner, _nonce.add(1));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/sale/ERC1155SaleNonceHolder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\n\\nimport \\\"../roles/OperatorRole.sol\\\";\\n\\ncontract ERC1155SaleNonceHolder is OperatorRole {\\n    // keccak256(token, owner, tokenId) => nonce\\n    mapping(bytes32 => uint256) public nonces;\\n\\n    // keccak256(token, owner, tokenId, nonce) => completed amount\\n    mapping(bytes32 => uint256) public completed;\\n\\n    function getNonce(\\n        address token,\\n        uint256 tokenId,\\n        address owner\\n    ) public view returns (uint256) {\\n        return nonces[getNonceKey(token, tokenId, owner)];\\n    }\\n\\n    function setNonce(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public onlyOperator {\\n        nonces[getNonceKey(token, tokenId, owner)] = nonce;\\n    }\\n\\n    function getNonceKey(\\n        address token,\\n        uint256 tokenId,\\n        address owner\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(token, tokenId, owner));\\n    }\\n\\n    function getCompleted(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public view returns (uint256) {\\n        return completed[getCompletedKey(token, tokenId, owner, nonce)];\\n    }\\n\\n    function setCompleted(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce,\\n        uint256 _completed\\n    ) public onlyOperator {\\n        completed[getCompletedKey(token, tokenId, owner, nonce)] = _completed;\\n    }\\n\\n    function getCompletedKey(\\n        address token,\\n        uint256 tokenId,\\n        address owner,\\n        uint256 nonce\\n    ) public pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(token, tokenId, owner, nonce));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/ERC721Auction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\nimport \\\"../tokens/HasSecondarySale.sol\\\";\\nimport \\\"../proxy/ServiceFeeProxy.sol\\\";\\nimport \\\"../roles/AdminRole.sol\\\";\\nimport \\\"../libs/BidLibrary.sol\\\";\\nimport \\\"../managers/TradeTokenManager.sol\\\";\\nimport \\\"../managers/NftTokenManager.sol\\\";\\nimport \\\"../service_fee/RoyaltiesStrategy.sol\\\";\\n\\n/**\\n * @notice Primary sale auction contract for Refinable NFTs\\n */\\ncontract ERC721Auction is Context, ReentrancyGuard, AdminRole, RoyaltiesStrategy {\\n    using SafeMath for uint256;\\n    using Address for address payable;\\n    using BidLibrary for BidLibrary.Bid[];\\n\\n    /// @notice Event emitted only on construction. To be used by indexers\\n    event AuctionContractDeployed();\\n\\n    event PauseToggled(bool isPaused);\\n\\n    event Destroy();\\n\\n    event AuctionCreated(bytes32 auctionId, address token, uint256 indexed tokenId, address payToken);\\n\\n    event AuctionCreateTimeLimitUpdated(uint256 auctionCreateTimeLimit);\\n\\n    event AuctionStartTimeUpdated(bytes32 auctionId, address token, uint256 indexed tokenId, uint256 startTime);\\n\\n    event AuctionEndTimeUpdated(bytes32 auctionId, address token, uint256 indexed tokenId, uint256 endTime);\\n\\n    event MinBidIncrementBpsUpdated(uint256 minBidIncrementBps);\\n\\n    event MaxBidStackCountUpdated(uint256 maxBidStackCount);\\n\\n    event BidWithdrawalLockTimeUpdated(uint256 bidWithdrawalLockTime);\\n\\n    event BidPlaced(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address payToken,\\n        address indexed bidder,\\n        uint256 bidAmount,\\n        uint256 actualBidAmount\\n    );\\n\\n    event BidWithdrawn(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address payToken,\\n        address indexed bidder,\\n        uint256 bidAmount\\n    );\\n\\n    event BidRefunded(\\n        address indexed bidder,\\n        uint256 bidAmount,\\n        address payToken\\n    );\\n\\n    event AuctionResulted(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address payToken,\\n        address indexed winner,\\n        uint256 winningBidAmount\\n    );\\n\\n    event AuctionCancelled(bytes32 auctionId, address token, uint256 indexed tokenId);\\n\\n    /// @notice Parameters of an auction\\n    struct Auction {\\n        address token;\\n        address royaltyToken;\\n        uint256 tokenId;\\n        address owner;\\n        address payToken;\\n        uint256 startPrice;\\n        uint256 startTime;\\n        uint256 endTime;\\n        bool created;\\n    }\\n\\n    address public serviceFeeProxy;\\n\\n    address public tradeTokenManager;\\n\\n    /// @notice ERC721 Auction ID -> Auction Parameters\\n    mapping(bytes32 => Auction) public auctions;\\n\\n    /// @notice ERC721 Auction ID -> Bid Parameters\\n    mapping(bytes32 => BidLibrary.Bid[]) public bids;\\n\\n    /// @notice globally and across all auctions, the amount by which a bid has to increase\\n    uint256 public minBidIncrementBps = 250;\\n\\n    //@notice global auction create time limit\\n    uint256 public auctionCreateTimeLimit = 30 days;\\n\\n    /// @notice global bid withdrawal lock time\\n    uint256 public bidWithdrawalLockTime = 3 days;\\n\\n    /// @notice global limit time betwen bid time and auction end time\\n    uint256 public bidLimitBeforeEndTime = 5 minutes;\\n\\n    /// @notice max bidders stack count\\n    uint256 public maxBidStackCount = 1;\\n\\n    /// @notice for switching off auction creations, bids and withdrawals\\n    bool public isPaused;\\n\\n    bytes4 private constant _INTERFACE_ID_HAS_SECONDARY_SALE = 0x5595380a;\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    modifier whenNotPaused() {\\n        require(!isPaused, \\\"Auction: Function is currently paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyCreatedAuction(bytes32 _auctionId) {\\n        require(\\n            auctions[_auctionId].created == true,\\n            \\\"Auction: Auction does not exist\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Auction Constructor\\n    * @param _serviceFeeProxy service fee proxy\\n     */\\n    constructor(\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) public {\\n        serviceFeeProxy = _serviceFeeProxy;\\n        tradeTokenManager = _tradeTokenManager;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        emit AuctionContractDeployed();\\n    }\\n\\n    /**\\n     * @notice Creates a new auction for a given token\\n     * @dev Only the owner of a token can create an auction and must have approved the contract\\n     * @dev End time for the auction must be in the future.\\n     * @param _token Token Address that follows ERC721 standard\\n     * @param _tokenId Token ID of the token being auctioned\\n     * @param _startPrice Starting bid price of the token being auctioned\\n     * @param _startTimestamp Unix epoch in seconds for the auction start time\\n     * @param _endTimestamp Unix epoch in seconds for the auction end time.\\n     */\\n    function createAuction(\\n        address _token,\\n        address _royaltyToken,\\n        uint256 _tokenId,\\n        address _payToken,\\n        uint256 _startPrice,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp\\n    ) external whenNotPaused {\\n        require(\\n            _startTimestamp <= _getNow().add(auctionCreateTimeLimit),\\n            \\\"Auction: Exceed auction start time limit\\\"\\n        );\\n        require(\\n            IERC721(_token).supportsInterface(_INTERFACE_ID_ERC721),\\n            \\\"Auction: Invalid NFT\\\"\\n        );\\n\\n        if (_royaltyToken != address(0)) {\\n            require(\\n                IERC721(_royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2),\\n                \\\"Auction: Invalid royalty contract\\\"\\n            );\\n            require(\\n                IRoyalty(_royaltyToken).getTokenContract() == _token,\\n                \\\"Auction: Royalty Token address does not match buy token\\\"\\n            );\\n        }\\n\\n        // Check owner of the token is the creator and approved\\n        require(\\n            IERC721(_token).ownerOf(_tokenId) == msg.sender,\\n            \\\"Auction: Caller is not the owner\\\"\\n        );\\n        require(\\n            IERC721(_token).isApprovedForAll(msg.sender, address(this)),\\n            \\\"Auction: Owner has not approved\\\"\\n        );\\n\\n        if (_payToken != address(0)) {\\n            require(\\n                TradeTokenManager(tradeTokenManager).supportToken(_payToken) == true,\\n                \\\"Auction: Pay Token is not allowed\\\"\\n            );\\n        }\\n\\n        bytes32 auctionId = getAuctionId(_token, _tokenId, msg.sender);\\n\\n        // Check the auction already created, can only list 1 token at a time\\n        require(\\n            auctions[auctionId].created == false,\\n            \\\"Auction: Auction has been already created\\\"\\n        );\\n        // Check end time not before start time and that end is in the future\\n        require(\\n            _endTimestamp > _startTimestamp && _endTimestamp > _getNow(),\\n            \\\"Auction: Auction time is incorrect\\\"\\n        );\\n\\n        // Setup the auction\\n        auctions[auctionId] = Auction({\\n        token : _token,\\n        royaltyToken : _royaltyToken,\\n        tokenId : _tokenId,\\n        owner : msg.sender,\\n        payToken : _payToken,\\n        startPrice : _startPrice,\\n        startTime : _startTimestamp,\\n        endTime : _endTimestamp,\\n        created : true\\n        });\\n\\n        emit AuctionCreated(auctionId, _token, _tokenId, _payToken);\\n    }\\n\\n    /**\\n     * @notice Places a new bid, out bidding the existing bidder if found and criteria is reached\\n     * @dev Only callable when the auction is open\\n     * @dev Bids from smart contracts are prohibited to prevent griefing with always reverting receiver\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function placeBid(bytes32 _auctionId)\\n    external\\n    payable\\n    nonReentrant\\n    whenNotPaused\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        require(\\n            msg.sender.isContract() == false,\\n            \\\"Auction: No contracts permitted\\\"\\n        );\\n\\n        // Ensure auction is in flight\\n        require(\\n            _getNow() >= auctions[_auctionId].startTime && _getNow() <= auctions[_auctionId].endTime,\\n            \\\"Auction: Bidding outside of the auction window\\\"\\n        );\\n\\n        uint256 bidAmount;\\n\\n        if (auctions[_auctionId].payToken == address(0)) {\\n            bidAmount = msg.value;\\n        } else {\\n            bidAmount = IBEP20(auctions[_auctionId].payToken).allowance(msg.sender, address(this));\\n            require(\\n                IBEP20(auctions[_auctionId].payToken).transferFrom(msg.sender, address(this), bidAmount) == true,\\n                \\\"Auction: Token transfer failed\\\"\\n            );\\n        }\\n\\n        // Ensure bid adheres to outbid increment and threshold\\n        uint256 actualBidAmount = bidAmount.mul(10 ** 4).div(ServiceFeeProxy(serviceFeeProxy).getBuyServiceFeeBps(msg.sender).add(10 ** 4));\\n        uint256 minBidRequired;\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        if (bidList.length != 0) {\\n            minBidRequired =\\n            bidList[bidList.length - 1].actualBidAmount.mul(minBidIncrementBps.add(10 ** 4)).div(10 ** 4);\\n        } else {\\n            minBidRequired = auctions[_auctionId].startPrice;\\n        }\\n\\n        require(\\n            actualBidAmount >= minBidRequired,\\n            \\\"Auction: Failed to outbid min price\\\"\\n        );\\n\\n        // assign top bidder and bid time\\n        BidLibrary.Bid memory newHighestBid = BidLibrary.Bid({\\n        bidder : _msgSender(),\\n        bidAmount : bidAmount,\\n        actualBidAmount : actualBidAmount,\\n        bidTime : _getNow()\\n        });\\n\\n        bidList.push(newHighestBid);\\n\\n        //Refund old bid if bidlist overflows thans max bid stack count\\n        if (bidList.length > maxBidStackCount) {\\n            BidLibrary.Bid memory oldBid = bidList[0];\\n            if (oldBid.bidder != address(0)) {\\n                _refundBid(oldBid.bidder, oldBid.bidAmount, auctions[_auctionId].payToken);\\n            }\\n\\n            bidList.removeByIndex(0);\\n        }\\n\\n        //Increase auction end time if bid time is more than 5 mins before end time\\n        if (auctions[_auctionId].endTime <= newHighestBid.bidTime.add(bidLimitBeforeEndTime)) {\\n            _updateAuctionEndTime(_auctionId, auctions[_auctionId].endTime.add(bidLimitBeforeEndTime));\\n        }\\n\\n        emit BidPlaced(\\n            _auctionId,\\n            auctions[_auctionId].token,\\n            auctions[_auctionId].tokenId,\\n            auctions[_auctionId].payToken,\\n            _msgSender(),\\n            bidAmount,\\n            actualBidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Given a sender who is in the bid list of auction, allows them to withdraw their bid\\n     * @dev Only callable by the existing top bidder\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function withdrawBid(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    whenNotPaused\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n        require(bidList.length > 0, \\\"Auction: There is no bid\\\");\\n\\n        uint256 withdrawIndex = bidList.length;\\n        for (uint256 i = 0; i < bidList.length; i++) {\\n            if (bidList[i].bidder == _msgSender()) {\\n                withdrawIndex = i;\\n            }\\n        }\\n\\n        require(withdrawIndex != bidList.length, \\\"Auction: Caller is not bidder\\\");\\n\\n        BidLibrary.Bid storage withdrawableBid = bidList[withdrawIndex];\\n\\n        // Check withdrawal after delay time\\n        require(\\n            _getNow() >= auctions[_auctionId].endTime.add(bidWithdrawalLockTime),\\n            \\\"Auction: Cannot withdraw until auction ends\\\"\\n        );\\n\\n        if (withdrawableBid.bidder != address(0)) {\\n            _refundBid(withdrawableBid.bidder, withdrawableBid.bidAmount, auctions[_auctionId].payToken);\\n        }\\n\\n        bidList.removeByIndex(withdrawIndex);\\n\\n        emit BidWithdrawn(\\n            _auctionId,\\n            auctions[_auctionId].token,\\n            auctions[_auctionId].tokenId,\\n            auctions[_auctionId].payToken,\\n            _msgSender(),\\n            withdrawableBid.bidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Results a finished auction\\n     * @dev Only admin or smart contract\\n     * @dev Auction can only be resulted if there has been a bidder and reserve met.\\n     * @dev If there have been no bids, the auction needs to be cancelled instead using `cancelAuction()`\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function endAuction(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        Auction memory auction = auctions[_auctionId];\\n\\n        require(\\n            isAdmin(msg.sender) || (auction.owner == msg.sender),\\n            \\\"Auction: Only admin or auction owner can result the auction\\\"\\n        );\\n\\n        // Check the auction has ended\\n        require(\\n            _getNow() > auction.endTime,\\n            \\\"Auction: Auction has not ended\\\"\\n        );\\n\\n        // Ensure this contract is approved to move the token\\n        require(\\n            IERC721(auction.token).isApprovedForAll(auction.owner, address(this)),\\n            \\\"Auction: Auction not approved\\\"\\n        );\\n\\n        // Get info on who the highest bidder is\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        require(bidList.length > 0, \\\"Auction: There is no bid\\\");\\n\\n        BidLibrary.Bid memory highestBid = bidList[bidList.length - 1];\\n\\n        bool isSecondarySale;\\n        if (IERC165(auction.token).supportsInterface(_INTERFACE_ID_HAS_SECONDARY_SALE)) {\\n            isSecondarySale = HasSecondarySale(auction.token).checkSecondarySale(auction.tokenId);\\n        } else if (auction.royaltyToken != address(0) && IERC165(auction.royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2)) {\\n            isSecondarySale = HasSecondarySale(auction.royaltyToken).checkSecondarySale(auction.tokenId);\\n        }\\n        // Work out platform fee from above reserve amount\\n        uint256 totalServiceFee = highestBid.bidAmount.sub(highestBid.actualBidAmount).add(\\n            highestBid.actualBidAmount.mul(\\n                ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(auction.owner, isSecondarySale)\\n            ).div(10 ** 4)\\n        );\\n\\n        // Send platform fee\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        bool platformTransferSuccess;\\n        bool ownerTransferSuccess;\\n        uint256 royalties;\\n        if (\\n            IERC165(auction.token).supportsInterface(_INTERFACE_ID_FEES)\\n            || IERC165(auction.token).supportsInterface(_INTERFACE_ID_ROYALTY)\\n            || IERC165(auction.token).supportsInterface(_INTERFACE_ID_ROYALTY_V2)\\n        ) {\\n            royalties = _payOutRoyaltiesByStrategy(\\n                auction.token,\\n                auction.tokenId,\\n                auction.payToken,\\n                address(this),\\n                highestBid.bidAmount.sub(totalServiceFee),\\n                isSecondarySale\\n            );\\n        } else if (auction.royaltyToken != address(0) && IERC165(auction.royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2)) {\\n            require(\\n                IRoyalty(auction.royaltyToken).getTokenContract() == auction.token,\\n                \\\"Auction: Royalty Token address does not match buy token\\\"\\n            );\\n            royalties = _payOutRoyaltiesByStrategy(\\n                auction.royaltyToken,\\n                auction.tokenId,\\n                auction.payToken,\\n                address(this),\\n                highestBid.bidAmount.sub(totalServiceFee),\\n                isSecondarySale\\n            );\\n        }\\n        uint256 remain = highestBid.bidAmount.sub(totalServiceFee).sub(royalties);\\n        if (auction.payToken == address(0)) {\\n            (platformTransferSuccess,) =\\n            serviceFeeRecipient.call{value : totalServiceFee}(\\\"\\\");\\n            // Send remaining to designer\\n            if (remain > 0) {\\n                (ownerTransferSuccess,) =\\n                auction.owner.call{\\n                value : remain\\n                }(\\\"\\\");\\n            }\\n        } else {\\n            platformTransferSuccess = IBEP20(auction.payToken).transfer(serviceFeeRecipient, totalServiceFee);\\n            if (remain > 0) {\\n                ownerTransferSuccess = IBEP20(auction.payToken).transfer(auction.owner, remain);\\n            }\\n        }\\n\\n        require(\\n            platformTransferSuccess,\\n            \\\"Auction: Failed to send fee\\\"\\n        );\\n        if (remain > 0) {\\n            require(\\n                ownerTransferSuccess,\\n                \\\"Auction: Failed to send winning bid\\\"\\n            );\\n        }\\n        // Transfer the token to the winner\\n        IERC721(auction.token).safeTransferFrom(auction.owner, highestBid.bidder, auction.tokenId);\\n\\n        if (IERC165(auction.token).supportsInterface(_INTERFACE_ID_HAS_SECONDARY_SALE))\\n            HasSecondarySale(auction.token).setSecondarySale(auction.tokenId);\\n\\n        if (auction.royaltyToken != address(0) && IERC165(auction.royaltyToken).supportsInterface(_INTERFACE_ID_HAS_SECONDARY_SALE))\\n            HasSecondarySale(auction.royaltyToken).setSecondarySale(auction.tokenId);\\n\\n        // Refund bid amount to bidders who isn't the top unfortunately\\n        for (uint256 i = 0; i < bidList.length - 1; i++) {\\n            _refundBid(bidList[i].bidder, bidList[i].bidAmount, auction.payToken);\\n        }\\n\\n        // Clean up the highest bid\\n        delete bids[_auctionId];\\n        delete auctions[_auctionId];\\n\\n        emit AuctionResulted(\\n            _auctionId,\\n            auction.token,\\n            auction.tokenId,\\n            auction.payToken,\\n            highestBid.bidder,\\n            highestBid.bidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Cancels and inflight and un-resulted auctions, returning the funds to bidders if found\\n     * @dev Only admin\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function cancelAuction(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        Auction memory auction = auctions[_auctionId];\\n\\n        require(\\n            isAdmin(msg.sender) || (auction.owner == msg.sender),\\n            \\\"Auction: Only admin or auction owner can result the auction\\\"\\n        );\\n\\n        // refund bid amount to existing bidders\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        if (bidList.length > 0) {\\n            for (uint256 i = 0; i < bidList.length; i++) {\\n                _refundBid(bidList[i].bidder, bidList[i].bidAmount, auction.payToken);\\n            }\\n        }\\n\\n        // Remove auction and bids\\n        delete bids[_auctionId];\\n        delete auctions[_auctionId];\\n\\n        emit AuctionCancelled(_auctionId, auction.token, auction.tokenId);\\n    }\\n\\n    /**\\n     * @notice Update the auction create time limit by which how far ahead can auctions be created\\n     * @dev Only admin\\n     * @param _auctionCreateTimeLimit New auction create time limit\\n     */\\n    function updateAuctionCreateTimeLimit(uint256 _auctionCreateTimeLimit)\\n    external\\n    onlyAdmin\\n    {\\n        auctionCreateTimeLimit = _auctionCreateTimeLimit;\\n        emit AuctionCreateTimeLimitUpdated(_auctionCreateTimeLimit);\\n    }\\n\\n    /**\\n     * @notice Update the amount by which bids have to increase, across all auctions\\n     * @dev Only admin\\n     * @param _minBidIncrementBps New bid step in WEI\\n     */\\n    function updateMinBidIncrementBps(uint256 _minBidIncrementBps)\\n    external\\n    onlyAdmin\\n    {\\n        minBidIncrementBps = _minBidIncrementBps;\\n        emit MinBidIncrementBpsUpdated(_minBidIncrementBps);\\n    }\\n\\n    /**\\n     * @notice Update the global max bid stack count\\n     * @dev Only admin\\n     * @param _maxBidStackCount max bid stack count\\n     */\\n    function updateMaxBidStackCount(uint256 _maxBidStackCount)\\n    external\\n    onlyAdmin\\n    {\\n        maxBidStackCount = _maxBidStackCount;\\n        emit MaxBidStackCountUpdated(_maxBidStackCount);\\n    }\\n\\n    /**\\n     * @notice Update the global bid withdrawal lockout time\\n     * @dev Only admin\\n     * @param _bidWithdrawalLockTime New bid withdrawal lock time\\n     */\\n    function updateBidWithdrawalLockTime(uint256 _bidWithdrawalLockTime)\\n    external\\n    onlyAdmin\\n    {\\n        bidWithdrawalLockTime = _bidWithdrawalLockTime;\\n        emit BidWithdrawalLockTimeUpdated(_bidWithdrawalLockTime);\\n    }\\n\\n    /**\\n     * @notice Update the current start time for an auction\\n     * @dev Only admin\\n     * @dev Auction must exist\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _startTime New start time (unix epoch in seconds)\\n     */\\n    function updateAuctionStartTime(bytes32 _auctionId, uint256 _startTime)\\n    external\\n    onlyAdmin\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        auctions[_auctionId].startTime = _startTime;\\n        emit AuctionStartTimeUpdated(_auctionId, auctions[_auctionId].token, auctions[_auctionId].tokenId, _startTime);\\n    }\\n\\n    /**\\n     * @notice Update the current end time for an auction\\n     * @dev Only admin\\n     * @dev Auction must exist\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _endTimestamp New end time (unix epoch in seconds)\\n     */\\n    function updateAuctionEndTime(bytes32 _auctionId, uint256 _endTimestamp)\\n    external\\n    onlyAdmin\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        require(\\n            auctions[_auctionId].startTime < _endTimestamp && _endTimestamp > _getNow(),\\n            \\\"Auction: Auction time is incorrect\\\"\\n        );\\n\\n        _updateAuctionEndTime(_auctionId, _endTimestamp);\\n    }\\n\\n    /**\\n     * @notice Method for getting all info about the auction\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function getAuction(bytes32 _auctionId)\\n    external\\n    view\\n    returns (Auction memory)\\n    {\\n        return auctions[_auctionId];\\n    }\\n\\n    /**\\n     * @notice Method for getting all info about the bids\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function getBidList(bytes32 _auctionId) public view returns (BidLibrary.Bid[] memory) {\\n        return bids[_auctionId];\\n    }\\n\\n    /**\\n     * @notice Method for getting auction id to query the auctions mapping\\n     * @param _token Token Address that follows ERC1155 standard\\n     * @param _tokenId Token ID of the token being auctioned\\n     * @param _owner Owner address of the token Id\\n    */\\n    function getAuctionId(address _token, uint256 _tokenId, address _owner) public pure returns (bytes32) {\\n        return sha256(abi.encodePacked(_token, _tokenId, _owner));\\n    }\\n\\n    /**\\n     * @notice Method for the block timestamp\\n    */\\n    function _getNow() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Used for sending back escrowed funds from a previous bid\\n     * @param _bidder Address of the last highest bidder\\n     * @param _bidAmount Ether amount in WEI that the bidder sent when placing their bid\\n     */\\n    function _refundBid(address payable _bidder, uint256 _bidAmount, address _payToken) private {\\n        // refund previous best (if bid exists)\\n        bool successRefund;\\n        if (_payToken == address(0)) {\\n            (successRefund,) = _bidder.call{value : _bidAmount}(\\\"\\\");\\n        } else {\\n            successRefund = IBEP20(_payToken).transfer(_bidder, _bidAmount);\\n        }\\n        require(\\n            successRefund,\\n            \\\"Auction: Failed to refund\\\"\\n        );\\n        emit BidRefunded(_bidder, _bidAmount, _payToken);\\n    }\\n\\n    /**\\n     * @notice Private method used for update auction end time\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _endTimestamp timestamp of end time\\n     */\\n    function _updateAuctionEndTime(bytes32 _auctionId, uint256 _endTimestamp) private {\\n        auctions[_auctionId].endTime = _endTimestamp;\\n        emit AuctionEndTimeUpdated(_auctionId, auctions[_auctionId].token, auctions[_auctionId].tokenId, _endTimestamp);\\n    }\\n\\n    /**\\n     * @notice Toggling the pause of the contract\\n     * @dev Only admin\\n    */\\n    function toggleIsPaused() external onlyAdmin {\\n        isPaused = !isPaused;\\n        emit PauseToggled(isPaused);\\n    }\\n\\n    /**\\n     * @notice Destroy the smart contract\\n     * @dev Only admin\\n     */\\n    function destroy() external onlyAdmin {\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        selfdestruct(serviceFeeRecipient);\\n        emit Destroy();\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/libs/BidLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\n\\nlibrary BidLibrary {\\n    /// @notice Information about the sender that placed a bid on an auction\\n    struct Bid {\\n        address payable bidder;\\n        uint256 bidAmount;\\n        uint256 actualBidAmount;\\n        uint256 bidTime;\\n    }\\n\\n    function removeByIndex(Bid[] storage _list, uint256 _index) internal {\\n        for (uint256 i = _index; i < _list.length - 1; i++) {\\n            _list[i] = _list[i + 1];\\n        }\\n        _list.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/auction/mocks/ERC721AuctionMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC721Auction.sol\\\";\\nimport \\\"../../managers/TradeTokenManager.sol\\\";\\n\\n/**\\n * @notice Mock Contract of ERC721Auction\\n */\\ncontract ERC721AuctionMock is ERC721Auction {\\n    uint256 public fakeBlockTimeStamp = 100;\\n\\n    /**\\n     * @notice Auction Constructor\\n     * @param _serviceFeeProxy service fee proxy\\n     */\\n    constructor(\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) ERC721Auction(_serviceFeeProxy, _tradeTokenManager)\\n    public {}\\n\\n    function setBlockTimeStamp(uint256 _now) external {\\n        fakeBlockTimeStamp = _now;\\n    }\\n\\n    function _getNow() internal override view returns (uint256) {\\n        return fakeBlockTimeStamp;\\n    }\\n}\"\r\n    },\r\n    \"contracts/tge/RefinableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\nimport './interfaces/IBEP20.sol';\\nimport './libs/SafeMath.sol';\\nimport './libs/Context.sol';\\nimport './libs/Ownable.sol';\\n\\ncontract RefinableToken is Context, IBEP20, Ownable {\\n  using SafeMath for uint256;\\n\\n  mapping(address => uint256) private _balances;\\n\\n  mapping(address => mapping(address => uint256)) private _allowances;\\n\\n  uint256 private _totalSupply;\\n  uint8 public _decimals;\\n  string public _symbol;\\n  string public _name;\\n\\n  constructor() public {\\n    _name = 'Refinable Token';\\n    _symbol = 'FINE';\\n    _decimals = 18;\\n    _totalSupply = 5 * 10**8 * 10**18; // 500m\\n    _balances[msg.sender] = _totalSupply;\\n\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\n  }\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view virtual override returns (address) {\\n    return owner();\\n  }\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view virtual override returns (uint8) {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view virtual override returns (string memory) {\\n    return _symbol;\\n  }\\n\\n  /**\\n   * @dev Returns the token name.\\n   */\\n  function name() external view virtual override returns (string memory) {\\n    return _name;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-totalSupply}.\\n   */\\n  function totalSupply() external view virtual override returns (uint256) {\\n    return _totalSupply;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-balanceOf}.\\n   */\\n  function balanceOf(address account)\\n    external\\n    view\\n    virtual\\n    override\\n    returns (uint256)\\n  {\\n    return _balances[account];\\n  }\\n\\n  /**\\n   * @dev See {BEP20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address recipient, uint256 amount)\\n    external\\n    override\\n    returns (bool)\\n  {\\n    _transfer(_msgSender(), recipient, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-allowance}.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return _allowances[owner][spender];\\n  }\\n\\n  /**\\n   * @dev See {BEP20-approve}.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount)\\n    external\\n    override\\n    returns (bool)\\n  {\\n    _approve(_msgSender(), spender, amount);\\n    return true;\\n  }\\n\\n  /**\\n   * @dev See {BEP20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {BEP20};\\n   *\\n   * Requirements:\\n   * - `sender` and `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   * - the caller must have allowance for `sender`'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external override returns (bool) {\\n    _transfer(sender, recipient, amount);\\n    _approve(\\n      sender,\\n      _msgSender(),\\n      _allowances[sender][_msgSender()].sub(\\n        amount,\\n        'BEP20: transfer amount exceeds allowance'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {BEP20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function increaseAllowance(address spender, uint256 addedValue)\\n    public\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].add(addedValue)\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n   *\\n   * This is an alternative to {approve} that can be used as a mitigation for\\n   * problems described in {BEP20-approve}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   * - `spender` must have allowance for the caller of at least\\n   * `subtractedValue`.\\n   */\\n  function decreaseAllowance(address spender, uint256 subtractedValue)\\n    public\\n    returns (bool)\\n  {\\n    _approve(\\n      _msgSender(),\\n      spender,\\n      _allowances[_msgSender()][spender].sub(\\n        subtractedValue,\\n        'BEP20: decreased allowance below zero'\\n      )\\n    );\\n    return true;\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from the caller.\\n   *\\n   * See {BEP20-_burn}.\\n   */\\n  function burn(uint256 amount) public virtual {\\n    _burn(_msgSender(), amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n   * allowance.\\n   *\\n   * See {BEP20-_burn} and {BEP20-allowance}.\\n   *\\n   * Requirements:\\n   *\\n   * - the caller must have allowance for ``accounts``'s tokens of at least\\n   * `amount`.\\n   */\\n  function burnFrom(address account, uint256 amount) public virtual {\\n    uint256 decreasedAllowance =\\n      _allowances[account][_msgSender()].sub(\\n        amount,\\n        'BEP20: burn amount exceeds allowance'\\n      );\\n\\n    _approve(account, _msgSender(), decreasedAllowance);\\n    _burn(account, amount);\\n  }\\n\\n  /**\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\n   *\\n   * This is internal function is equivalent to {transfer}, and can be used to\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\n   *\\n   * Emits a {Transfer} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `sender` cannot be the zero address.\\n   * - `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   */\\n  function _transfer(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) internal {\\n    require(sender != address(0), 'BEP20: transfer from the zero address');\\n    require(recipient != address(0), 'BEP20: transfer to the zero address');\\n\\n    _balances[sender] = _balances[sender].sub(\\n      amount,\\n      'BEP20: transfer amount exceeds balance'\\n    );\\n    _balances[recipient] = _balances[recipient].add(amount);\\n    emit Transfer(sender, recipient, amount);\\n  }\\n\\n  /**\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\n   * total supply.\\n   *\\n   * Emits a {Transfer} event with `to` set to the zero address.\\n   *\\n   * Requirements\\n   *\\n   * - `account` cannot be the zero address.\\n   * - `account` must have at least `amount` tokens.\\n   */\\n  function _burn(address account, uint256 amount) internal {\\n    require(account != address(0), 'BEP20: burn from the zero address');\\n\\n    _balances[account] = _balances[account].sub(\\n      amount,\\n      'BEP20: burn amount exceeds balance'\\n    );\\n    _totalSupply = _totalSupply.sub(amount);\\n    emit Transfer(account, address(0), amount);\\n  }\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n   *\\n   * This is internal function is equivalent to `approve`, and can be used to\\n   * e.g. set automatic allowances for certain subsystems, etc.\\n   *\\n   * Emits an {Approval} event.\\n   *\\n   * Requirements:\\n   *\\n   * - `owner` cannot be the zero address.\\n   * - `spender` cannot be the zero address.\\n   */\\n  function _approve(\\n    address owner,\\n    address spender,\\n    uint256 amount\\n  ) internal {\\n    require(owner != address(0), 'BEP20: approve from the zero address');\\n    require(spender != address(0), 'BEP20: approve to the zero address');\\n\\n    _allowances[owner][spender] = amount;\\n    emit Approval(owner, spender, amount);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tge/libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n  /**\\n   * @dev Returns the addition of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `+` operator.\\n   *\\n   * Requirements:\\n   * - Addition cannot overflow.\\n   */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n    uint256 c = a + b;\\n    require(c >= a, 'SafeMath: addition overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return sub(a, b, 'SafeMath: subtraction overflow');\\n  }\\n\\n  /**\\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n   * overflow (when the result is negative).\\n   *\\n   * Counterpart to Solidity's `-` operator.\\n   *\\n   * Requirements:\\n   * - Subtraction cannot overflow.\\n   */\\n  function sub(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b <= a, errorMessage);\\n    uint256 c = a - b;\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the multiplication of two unsigned integers, reverting on\\n   * overflow.\\n   *\\n   * Counterpart to Solidity's `*` operator.\\n   *\\n   * Requirements:\\n   * - Multiplication cannot overflow.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n    // benefit is lost if 'b' is also tested.\\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    uint256 c = a * b;\\n    require(c / a == b, 'SafeMath: multiplication overflow');\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return div(a, b, 'SafeMath: division by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\n   * division by zero. The result is rounded towards zero.\\n   *\\n   * Counterpart to Solidity's `/` operator. Note: this function uses a\\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n   * uses an invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function div(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    // Solidity only automatically asserts when dividing by 0\\n    require(b > 0, errorMessage);\\n    uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n    return c;\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return mod(a, b, 'SafeMath: modulo by zero');\\n  }\\n\\n  /**\\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n   * Reverts with custom message when dividing by zero.\\n   *\\n   * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\\n   * invalid opcode to revert (consuming all remaining gas).\\n   *\\n   * Requirements:\\n   * - The divisor cannot be zero.\\n   */\\n  function mod(\\n    uint256 a,\\n    uint256 b,\\n    string memory errorMessage\\n  ) internal pure returns (uint256) {\\n    require(b != 0, errorMessage);\\n    return a % b;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tge/libs/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/tge/libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\nimport './Context.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  /**\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\n   */\\n  constructor() public {\\n    address msgSender = _msgSender();\\n    _owner = msgSender;\\n    emit OwnershipTransferred(address(0), msgSender);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(_owner == _msgSender(), 'Ownable: caller is not the owner');\\n    _;\\n  }\\n\\n  /**\\n   * @dev Leaves the contract without owner. It will not be possible to call\\n   * `onlyOwner` functions anymore. Can only be called by the current owner.\\n   *\\n   * NOTE: Renouncing ownership will leave the contract without an owner,\\n   * thereby removing any functionality that is only available to the owner.\\n   */\\n  function renounceOwnership() public onlyOwner {\\n    emit OwnershipTransferred(_owner, address(0));\\n    _owner = address(0);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   * Can only be called by the current owner.\\n   */\\n  function transferOwnership(address newOwner) public onlyOwner {\\n    _transferOwnership(newOwner);\\n  }\\n\\n  /**\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n   */\\n  function _transferOwnership(address newOwner) internal {\\n    require(newOwner != address(0), 'Ownable: new owner is the zero address');\\n    emit OwnershipTransferred(_owner, newOwner);\\n    _owner = newOwner;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Disperse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\nimport './tge/interfaces/IBEP20.sol';\\n\\ncontract Disperse {\\n  function disperseBNB(\\n    address payable[] calldata recipients,\\n    uint256[] calldata values\\n  ) external payable {\\n    for (uint256 i = 0; i < recipients.length; i++)\\n      recipients[i].transfer(values[i]);\\n    uint256 balance = address(this).balance;\\n    address payable change = payable(msg.sender);\\n    if (balance > 0) change.transfer(balance);\\n  }\\n\\n  function disperseToken(\\n    IBEP20 token,\\n    address[] calldata recipients,\\n    uint256[] calldata values\\n  ) external {\\n    uint256 total = 0;\\n    for (uint256 i = 0; i < recipients.length; i++) total += values[i];\\n    require(token.transferFrom(msg.sender, address(this), total));\\n    for (uint256 i = 0; i < recipients.length; i++)\\n      require(token.transfer(recipients[i], values[i]));\\n  }\\n\\n  function disperseTokenSimple(\\n    IBEP20 token,\\n    address[] calldata recipients,\\n    uint256[] calldata values\\n  ) external {\\n    for (uint256 i = 0; i < recipients.length; i++)\\n      require(token.transferFrom(msg.sender, recipients[i], values[i]));\\n  }\\n}\"\r\n    },\r\n    \"contracts/auction/ERC1155Auction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"../tge/interfaces/IBEP20.sol\\\";\\nimport \\\"../proxy/ServiceFeeProxy.sol\\\";\\nimport \\\"../roles/AdminRole.sol\\\";\\nimport \\\"../libs/BidLibrary.sol\\\";\\nimport \\\"../managers/TradeTokenManager.sol\\\";\\nimport \\\"../managers/NftTokenManager.sol\\\";\\nimport \\\"../service_fee/RoyaltiesStrategy.sol\\\";\\nimport \\\"../interfaces/ICreator.sol\\\";\\n\\n/**\\n * @notice Primary sale auction contract for Refinable NFTs\\n */\\ncontract ERC1155Auction is Context, ReentrancyGuard, AdminRole, RoyaltiesStrategy {\\n    using SafeMath for uint256;\\n    using Address for address payable;\\n    using BidLibrary for BidLibrary.Bid[];\\n    /// @notice Event emitted only on construction. To be used by indexers\\n    event AuctionContractDeployed();\\n\\n    event PauseToggled(bool isPaused);\\n\\n    event Destroy();\\n\\n    event AuctionCreated(bytes32 auctionId, address token, uint256 indexed tokenId, address owner, address payToken);\\n\\n    event AuctionCreateTimeLimitUpdated(uint256 auctionCreateTimeLimit);\\n\\n    event AuctionEndTimeUpdated(bytes32 auctionId, address token, uint256 indexed tokenId, address owner, uint256 endTime);\\n\\n    event AuctionStartTimeUpdated(bytes32 auctionId, address token, uint256 indexed tokenId, address owner, uint256 startTime);\\n\\n    event MinBidIncrementBpsUpdated(uint256 minBidIncrementBps);\\n\\n    event MaxBidStackCountUpdated(uint256 maxBidStackCount);\\n\\n    event BidWithdrawalLockTimeUpdated(uint256 bidWithdrawalLockTime);\\n\\n    event BidPlaced(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        address payToken,\\n        address indexed bidder,\\n        uint256 bidAmount,\\n        uint256 actualBidAmount\\n    );\\n\\n    event BidWithdrawn(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        address payToken,\\n        address indexed bidder,\\n        uint256 bidAmount\\n    );\\n\\n    event BidRefunded(\\n        address indexed bidder,\\n        uint256 bidAmount,\\n        address payToken\\n    );\\n\\n    event AuctionResulted(\\n        bytes32 auctionId,\\n        address token,\\n        uint256 indexed tokenId,\\n        address owner,\\n        address payToken,\\n        address indexed winner,\\n        uint256 winningBidAmount\\n    );\\n\\n    event AuctionCancelled(bytes32 auctionId, address token, uint256 indexed tokenId, address owner);\\n\\n    /// @notice Parameters of an auction\\n    struct Auction {\\n        address token;\\n        address royaltyToken;\\n        uint256 tokenId;\\n        address owner;\\n        address payToken;\\n        uint256 startPrice;\\n        uint256 startTime;\\n        uint256 endTime;\\n        bool created;\\n    }\\n\\n    address public serviceFeeProxy;\\n\\n    address public tradeTokenManager;\\n\\n    /// @notice ERC1155 Auction ID -> Auction Parameters\\n    mapping(bytes32 => Auction) public auctions;\\n\\n    /// @notice ERC1155 Auction ID -> Bid Parameters\\n    mapping(bytes32 => BidLibrary.Bid[]) public bids;\\n\\n    /// @notice globally and across all auctions, the amount by which a bid has to increase\\n    uint256 public minBidIncrementBps = 250;\\n\\n    //@notice global auction create time limit\\n    uint256 public auctionCreateTimeLimit = 30 days;\\n\\n    /// @notice global bid withdrawal lock time\\n    uint256 public bidWithdrawalLockTime = 3 days;\\n\\n    /// @notice global limit time between bid time and auction end time\\n    uint256 public bidLimitBeforeEndTime = 5 minutes;\\n\\n    /// @notice max bidders stack count\\n    uint256 public maxBidStackCount = 1;\\n\\n    /// @notice for switching off auction creations, bids and withdrawals\\n    bool public isPaused;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC1155 = 0xd9b67a26;\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY = 0x7b296bd9;\\n    bytes4 private constant _INTERFACE_ID_ROYALTY_V2 = 0x9e4a83d4;\\n\\n    modifier whenNotPaused() {\\n        require(!isPaused, \\\"Auction: Function is currently paused\\\");\\n        _;\\n    }\\n\\n    modifier onlyCreatedAuction(bytes32 _auctionId) {\\n        require(\\n            auctions[_auctionId].created == true,\\n            \\\"Auction: Auction does not exist\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @notice Auction Constructor\\n    * @param _serviceFeeProxy service fee proxy\\n     */\\n    constructor(\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) public {\\n        serviceFeeProxy = _serviceFeeProxy;\\n        tradeTokenManager = _tradeTokenManager;\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n        emit AuctionContractDeployed();\\n    }\\n\\n    /**\\n     * @notice Creates a new auction for a given token\\n     * @dev Only the owner of a token can create an auction and must have approved the contract\\n     * @dev End time for the auction must be in the future.\\n     * @param _token Token Address that follows ERC1155 standard\\n     * @param _tokenId Token ID of the token being auctioned\\n     * @param _startPrice Starting bid price of the token being auctioned\\n     * @param _startTimestamp Unix epoch in seconds for the auction start time\\n     * @param _endTimestamp Unix epoch in seconds for the auction end time.\\n     */\\n    function createAuction(\\n        address _token,\\n        address _royaltyToken,\\n        uint256 _tokenId,\\n        address _payToken,\\n        uint256 _startPrice,\\n        uint256 _startTimestamp,\\n        uint256 _endTimestamp\\n    ) external whenNotPaused {\\n        require(\\n            _startTimestamp <= _getNow().add(auctionCreateTimeLimit),\\n            \\\"Auction: Exceed auction start time limit\\\"\\n        );\\n        require(\\n            IERC1155(_token).supportsInterface(_INTERFACE_ID_ERC1155),\\n            \\\"Auction: Invalid NFT\\\"\\n        );\\n\\n        if (_royaltyToken != address(0)) {\\n            require(\\n                IERC1155(_royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2),\\n                \\\"Auction: Invalid royalty contract\\\"\\n            );\\n            require(\\n                IRoyalty(_royaltyToken).getTokenContract() == _token,\\n                \\\"Auction: Royalty Token address does not match buy token\\\"\\n            );\\n        }\\n\\n        // Check owner has token and approved\\n        require(\\n            IERC1155(_token).balanceOf(msg.sender, _tokenId) > 0,\\n            \\\"Auction: Caller does not have the token\\\"\\n        );\\n        require(\\n            IERC1155(_token).isApprovedForAll(_msgSender(), address(this)),\\n            \\\"Auction: Owner has not approved\\\"\\n        );\\n\\n        if (_payToken != address(0)) {\\n            require(\\n                TradeTokenManager(tradeTokenManager).supportToken(_payToken) == true,\\n                \\\"Auction: Pay Token is not allowed\\\"\\n            );\\n        }\\n\\n        bytes32 auctionId = getAuctionId(_token, _tokenId, msg.sender);\\n\\n        // Check the auction already created, can only list 1 token at a time\\n        require(\\n            auctions[auctionId].created == false,\\n            \\\"Auction: Auction has been already created\\\"\\n        );\\n        // Check end time not before start time and that end is in the future\\n        require(\\n            _endTimestamp > _startTimestamp && _endTimestamp > _getNow(),\\n            \\\"Auction: Auction time is incorrect\\\"\\n        );\\n\\n        // Setup the auction\\n        auctions[auctionId] = Auction({\\n        token : _token,\\n        royaltyToken : _royaltyToken,\\n        tokenId : _tokenId,\\n        owner : msg.sender,\\n        payToken : _payToken,\\n        startPrice : _startPrice,\\n        startTime : _startTimestamp,\\n        endTime : _endTimestamp,\\n        created : true\\n        });\\n\\n        emit AuctionCreated(auctionId, _token, _tokenId, msg.sender, _payToken);\\n    }\\n\\n    /**\\n     * @notice Places a new bid, out bidding the existing bidder if found and criteria is reached\\n     * @dev Only callable when the auction is open\\n     * @dev Bids from smart contracts are prohibited to prevent griefing with always reverting receiver\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function placeBid(bytes32 _auctionId)\\n    external\\n    payable\\n    nonReentrant\\n    whenNotPaused\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        require(\\n            _msgSender().isContract() == false,\\n            \\\"Auction: No contracts permitted\\\"\\n        );\\n\\n        // Ensure auction is in flight\\n        require(\\n            _getNow() >= auctions[_auctionId].startTime && _getNow() <= auctions[_auctionId].endTime,\\n            \\\"Auction: Bidding outside of the auction window\\\"\\n        );\\n\\n        uint256 bidAmount;\\n\\n        if (auctions[_auctionId].payToken == address(0)) {\\n            bidAmount = msg.value;\\n        } else {\\n            bidAmount = IBEP20(auctions[_auctionId].payToken).allowance(msg.sender, address(this));\\n            require(\\n                IBEP20(auctions[_auctionId].payToken).transferFrom(msg.sender, address(this), bidAmount) == true,\\n                \\\"Auction: Token transfer failed\\\"\\n            );\\n        }\\n\\n        // Ensure bid adheres to outbid increment and threshold\\n        uint256 actualBidAmount = bidAmount.mul(10 ** 4).div(ServiceFeeProxy(serviceFeeProxy).getBuyServiceFeeBps(msg.sender).add(10 ** 4));\\n        uint256 minBidRequired;\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        if (bidList.length != 0) {\\n            minBidRequired =\\n            bidList[bidList.length - 1].actualBidAmount.mul(minBidIncrementBps.add(10 ** 4)).div(10 ** 4);\\n        } else {\\n            minBidRequired = auctions[_auctionId].startPrice;\\n        }\\n\\n        require(\\n            actualBidAmount >= minBidRequired,\\n            \\\"Auction: Failed to outbid min price\\\"\\n        );\\n\\n        // assign top bidder and bid time\\n        BidLibrary.Bid memory newHighestBid = BidLibrary.Bid({\\n        bidder : _msgSender(),\\n        bidAmount : bidAmount,\\n        actualBidAmount : actualBidAmount,\\n        bidTime : _getNow()\\n        });\\n\\n        bidList.push(newHighestBid);\\n\\n        //Refund old bid if bidlist overflows thans max bid stack count\\n        if (bidList.length > maxBidStackCount) {\\n            BidLibrary.Bid memory oldBid = bidList[0];\\n            if (oldBid.bidder != address(0)) {\\n                _refundBid(oldBid.bidder, oldBid.bidAmount, auctions[_auctionId].payToken);\\n            }\\n\\n            bidList.removeByIndex(0);\\n        }\\n\\n        //Increase auction end time if bid time is within 5 mins after auction end time\\n        if (auctions[_auctionId].endTime <= newHighestBid.bidTime.add(bidLimitBeforeEndTime)) {\\n            _updateAuctionEndTime(_auctionId, auctions[_auctionId].endTime.add(bidLimitBeforeEndTime));\\n        }\\n\\n        emit BidPlaced(\\n            _auctionId,\\n            auctions[_auctionId].token,\\n            auctions[_auctionId].tokenId,\\n            auctions[_auctionId].owner,\\n            auctions[_auctionId].payToken,\\n            _msgSender(),\\n            bidAmount,\\n            actualBidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Given a sender who is in the bid list of auction, allows them to withdraw their bid\\n     * @dev Only callable by the existing top bidder\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function withdrawBid(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    whenNotPaused\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n        require(bidList.length > 0, \\\"Auction: There is no bid\\\");\\n\\n        uint256 withdrawIndex = bidList.length;\\n        for (uint256 i = 0; i < bidList.length; i++) {\\n            if (bidList[i].bidder == _msgSender()) {\\n                withdrawIndex = i;\\n            }\\n        }\\n\\n        require(withdrawIndex != bidList.length, \\\"Auction: Caller is not bidder\\\");\\n\\n        BidLibrary.Bid storage withdrawableBid = bidList[withdrawIndex];\\n\\n        // Check withdrawal after delay time\\n        require(\\n            _getNow() >= auctions[_auctionId].endTime.add(bidWithdrawalLockTime),\\n            \\\"Auction: Cannot withdraw until auction ends\\\"\\n        );\\n\\n        if (withdrawableBid.bidder != address(0)) {\\n            _refundBid(withdrawableBid.bidder, withdrawableBid.bidAmount, auctions[_auctionId].payToken);\\n        }\\n\\n        bidList.removeByIndex(withdrawIndex);\\n\\n        emit BidWithdrawn(\\n            _auctionId,\\n            auctions[_auctionId].token,\\n            auctions[_auctionId].tokenId,\\n            auctions[_auctionId].owner,\\n            auctions[_auctionId].payToken,\\n            _msgSender(),\\n            withdrawableBid.bidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Results a finished auction\\n     * @dev Only admin or smart contract\\n     * @dev Auction can only be resulted if there has been a bidder and reserve met.\\n     * @dev If there have been no bids, the auction needs to be cancelled instead using `cancelAuction()`\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function endAuction(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        Auction memory auction = auctions[_auctionId];\\n\\n        require(\\n            isAdmin(msg.sender) || (auction.owner == msg.sender),\\n            \\\"Auction: Only admin or auction owner can result the auction\\\"\\n        );\\n\\n        // Check the auction has ended\\n        require(\\n            _getNow() > auction.endTime,\\n            \\\"Auction: Auction has not ended\\\"\\n        );\\n\\n        // Ensure this contract is approved to move the token\\n        require(\\n            IERC1155(auction.token).isApprovedForAll(auction.owner, address(this)),\\n            \\\"Auction: Auction not approved\\\"\\n        );\\n\\n        // Get info on who the highest bidder is\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        require(bidList.length > 0, \\\"Auction: There is no bid\\\");\\n\\n        BidLibrary.Bid memory highestBid = bidList[bidList.length - 1];\\n\\n        // Send platform fee\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        bool platformTransferSuccess;\\n        bool ownerTransferSuccess;\\n\\n        uint256 totalServiceFee;\\n        uint256 royalties;\\n        if (\\n            IERC165(auction.token).supportsInterface(_INTERFACE_ID_FEES)\\n            || IERC165(auction.token).supportsInterface(_INTERFACE_ID_ROYALTY)\\n            || IERC165(auction.token).supportsInterface(_INTERFACE_ID_ROYALTY_V2)\\n        ) {\\n            bool isSecondarySale = _isSecondarySale(auction.token, auction.tokenId, auction.owner);\\n            // Work out platform fee from above reserve amount\\n            totalServiceFee = highestBid.bidAmount.sub(highestBid.actualBidAmount).add(\\n                highestBid.actualBidAmount.mul(\\n                    ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(auction.owner, isSecondarySale)\\n                ).div(10 ** 4)\\n            );\\n            royalties = _payOutRoyaltiesByStrategy(\\n                auction.token,\\n                auction.tokenId,\\n                auction.payToken,\\n                address(this),\\n                highestBid.bidAmount.sub(totalServiceFee),\\n                isSecondarySale\\n            );\\n        } else if (auction.royaltyToken != address(0) && IERC165(auction.royaltyToken).supportsInterface(_INTERFACE_ID_ROYALTY_V2)) {\\n            require(\\n                IRoyalty(auction.royaltyToken).getTokenContract() == auction.token,\\n                \\\"Auction: Royalty Token address does not match buy token\\\"\\n            );\\n            bool isSecondarySale = _isSecondarySale(auction.royaltyToken, auction.tokenId, auction.owner);\\n            // Work out platform fee from above reserve amount\\n            totalServiceFee = highestBid.bidAmount.sub(highestBid.actualBidAmount).add(\\n                highestBid.actualBidAmount.mul(\\n                    ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(auction.owner, isSecondarySale)\\n                ).div(10 ** 4)\\n            );\\n            royalties = _payOutRoyaltiesByStrategy(\\n                auction.royaltyToken,\\n                auction.tokenId,\\n                auction.payToken,\\n                address(this),\\n                highestBid.bidAmount.sub(totalServiceFee),\\n                isSecondarySale\\n            );\\n        } else {\\n            totalServiceFee = highestBid.bidAmount.sub(highestBid.actualBidAmount).add(\\n                highestBid.actualBidAmount.mul(\\n                    ServiceFeeProxy(serviceFeeProxy).getSellServiceFeeBps(auction.owner, true)\\n                ).div(10 ** 4)\\n            );\\n        }\\n\\n        uint256 remain = highestBid.bidAmount.sub(totalServiceFee).sub(royalties);\\n        if (auction.payToken == address(0)) {\\n            (platformTransferSuccess,) =\\n            serviceFeeRecipient.call{value : totalServiceFee}(\\\"\\\");\\n            // Send remaining to designer\\n            if (remain > 0) {\\n                (ownerTransferSuccess,) =\\n                auction.owner.call{\\n                value : remain\\n                }(\\\"\\\");\\n            }\\n        } else {\\n            platformTransferSuccess = IBEP20(auction.payToken).transfer(serviceFeeRecipient, totalServiceFee);\\n            if (remain > 0) {\\n                ownerTransferSuccess = IBEP20(auction.payToken).transfer(auction.owner, remain);\\n            }\\n        }\\n        require(\\n            platformTransferSuccess,\\n            \\\"Auction: Failed to send fee\\\"\\n        );\\n        if (remain > 0) {\\n            require(\\n                ownerTransferSuccess,\\n                \\\"Auction: Failed to send winning bid\\\"\\n            );\\n        }\\n\\n        // Transfer the token to the winner\\n        IERC1155(auction.token).safeTransferFrom(auction.owner, highestBid.bidder, auction.tokenId, 1, \\\"\\\");\\n\\n        // Refund bid amount to bidders who isn't the top unfortunately\\n        for (uint256 i = 0; i < bidList.length - 1; i++) {\\n            _refundBid(bidList[i].bidder, bidList[i].bidAmount, auction.payToken);\\n        }\\n\\n        // Remove auction and bids\\n        delete bids[_auctionId];\\n        delete auctions[_auctionId];\\n\\n        emit AuctionResulted(\\n            _auctionId,\\n            auction.token,\\n            auction.tokenId,\\n            auction.owner,\\n            auction.payToken,\\n            highestBid.bidder,\\n            highestBid.bidAmount\\n        );\\n    }\\n\\n    /**\\n     * @notice Cancels and inflight and un-resulted auctions, returning the funds to bidders if found\\n     * @dev Only admin\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function cancelAuction(bytes32 _auctionId)\\n    external\\n    nonReentrant\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        Auction memory auction = auctions[_auctionId];\\n\\n        require(\\n            isAdmin(msg.sender) || (auction.owner == msg.sender),\\n            \\\"Auction: Only admin or auction owner can result the auction\\\"\\n        );\\n\\n        // refund bid amount to existing bidders\\n        BidLibrary.Bid[] storage bidList = bids[_auctionId];\\n\\n        if (bidList.length > 0) {\\n            for (uint256 i = 0; i < bidList.length; i++) {\\n                _refundBid(bidList[i].bidder, bidList[i].bidAmount, auction.payToken);\\n            }\\n        }\\n\\n        // Remove auction and bids\\n        delete bids[_auctionId];\\n        delete auctions[_auctionId];\\n\\n        emit AuctionCancelled(_auctionId, auction.token, auction.tokenId, auction.owner);\\n    }\\n\\n    /**\\n     * @notice Update the amount by which bids have to increase, across all auctions\\n     * @dev Only admin\\n     * @param _minBidIncrementBps New bid step in WEI\\n     */\\n    function updateMinBidIncrementBps(uint256 _minBidIncrementBps)\\n    external\\n    onlyAdmin\\n    {\\n        minBidIncrementBps = _minBidIncrementBps;\\n        emit MinBidIncrementBpsUpdated(_minBidIncrementBps);\\n    }\\n\\n    /**\\n     * @notice Update the auction create time limit by which how far ahead can auctions be created\\n     * @dev Only admin\\n     * @param _auctionCreateTimeLimit New auction create time limit\\n     */\\n    function updateAuctionCreateTimeLimit(uint256 _auctionCreateTimeLimit)\\n    external\\n    onlyAdmin\\n    {\\n        auctionCreateTimeLimit = _auctionCreateTimeLimit;\\n        emit AuctionCreateTimeLimitUpdated(_auctionCreateTimeLimit);\\n    }\\n\\n    /**\\n     * @notice Update the global max bid stack count\\n     * @dev Only admin\\n     * @param _maxBidStackCount max bid stack count\\n     */\\n    function updateMaxBidStackCount(uint256 _maxBidStackCount)\\n    external\\n    onlyAdmin\\n    {\\n        maxBidStackCount = _maxBidStackCount;\\n        emit MaxBidStackCountUpdated(_maxBidStackCount);\\n    }\\n\\n    /**\\n     * @notice Update the global bid withdrawal lockout time\\n     * @dev Only admin\\n     * @param _bidWithdrawalLockTime New bid withdrawal lock time\\n     */\\n    function updateBidWithdrawalLockTime(uint256 _bidWithdrawalLockTime)\\n    external\\n    onlyAdmin\\n    {\\n        bidWithdrawalLockTime = _bidWithdrawalLockTime;\\n        emit BidWithdrawalLockTimeUpdated(_bidWithdrawalLockTime);\\n    }\\n\\n    /**\\n     * @notice Update the current start time for an auction\\n     * @dev Only admin\\n     * @dev Auction must exist\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _startTime New start time (unix epoch in seconds)\\n     */\\n    function updateAuctionStartTime(bytes32 _auctionId, uint256 _startTime)\\n    external\\n    onlyAdmin\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        auctions[_auctionId].startTime = _startTime;\\n        emit AuctionStartTimeUpdated(_auctionId, auctions[_auctionId].token, auctions[_auctionId].tokenId, auctions[_auctionId].owner, _startTime);\\n    }\\n\\n    /**\\n     * @notice Update the current end time for an auction\\n     * @dev Only admin\\n     * @dev Auction must exist\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _endTimestamp New end time (unix epoch in seconds)\\n     */\\n    function updateAuctionEndTime(bytes32 _auctionId, uint256 _endTimestamp)\\n    external\\n    onlyAdmin\\n    onlyCreatedAuction(_auctionId)\\n    {\\n        require(\\n            auctions[_auctionId].startTime < _endTimestamp && _endTimestamp > _getNow(),\\n            \\\"Auction: Auction time is incorrect\\\"\\n        );\\n\\n        _updateAuctionEndTime(_auctionId, _endTimestamp);\\n    }\\n\\n    /**\\n     * @notice Method for getting all info about the auction\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function getAuction(bytes32 _auctionId)\\n    external\\n    view\\n    returns (Auction memory)\\n    {\\n        return auctions[_auctionId];\\n    }\\n\\n    /**\\n     * @notice Method for getting all info about the bids\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     */\\n    function getBidList(bytes32 _auctionId) public view returns (BidLibrary.Bid[] memory) {\\n        return bids[_auctionId];\\n    }\\n\\n    /**\\n     * @notice Method for getting auction id to query the auctions mapping\\n     * @param _token Token Address that follows ERC1155 standard\\n     * @param _tokenId Token ID of the token being auctioned\\n     * @param _owner Owner address of the token Id\\n    */\\n    function getAuctionId(address _token, uint256 _tokenId, address _owner) public pure returns (bytes32) {\\n        return sha256(abi.encodePacked(_token, _tokenId, _owner));\\n    }\\n\\n    /**\\n     * @notice Method for the block timestamp\\n    */\\n    function _getNow() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    function _isSecondarySale(address _token, uint256 _tokenId, address _seller) internal returns (bool){\\n        if (IERC165(_token).supportsInterface(type(ICreator).interfaceId)) {\\n            address creator = ICreator(_token).getCreator(_tokenId);\\n            return (creator != _seller);\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Private method used for sending back escrowed funds from a previous bid\\n     * @param _bidder Address of the last highest bidder\\n     * @param _bidAmount Ether amount in WEI that the bidder sent when placing their bid\\n     */\\n    function _refundBid(address payable _bidder, uint256 _bidAmount, address _payToken) private {\\n        // refund previous best (if bid exists)\\n        bool successRefund;\\n        if (_payToken == address(0)) {\\n            (successRefund,) = _bidder.call{value : _bidAmount}(\\\"\\\");\\n        } else {\\n            successRefund = IBEP20(_payToken).transfer(_bidder, _bidAmount);\\n        }\\n        require(\\n            successRefund,\\n            \\\"Auction: Failed to refund\\\"\\n        );\\n        emit BidRefunded(_bidder, _bidAmount, _payToken);\\n    }\\n\\n    /**\\n     * @notice Private method used for update auction end time\\n     * @param _auctionId Auction ID the id can be obtained from the getAuctionId function\\n     * @param _endTimestamp timestamp of end time\\n     */\\n    function _updateAuctionEndTime(bytes32 _auctionId, uint256 _endTimestamp) private {\\n        auctions[_auctionId].endTime = _endTimestamp;\\n        emit AuctionEndTimeUpdated(_auctionId, auctions[_auctionId].token, auctions[_auctionId].tokenId, auctions[_auctionId].owner, _endTimestamp);\\n    }\\n\\n    /**\\n     * @notice Toggling the pause of the contract\\n     * @dev Only admin\\n    */\\n    function toggleIsPaused() external onlyAdmin {\\n        isPaused = !isPaused;\\n        emit PauseToggled(isPaused);\\n    }\\n\\n    /**\\n     * @notice Destroy the smart contract\\n     * @dev Only admin\\n     */\\n    function destroy() external onlyAdmin {\\n        address payable serviceFeeRecipient = ServiceFeeProxy(serviceFeeProxy).getServiceFeeRecipient();\\n        selfdestruct(serviceFeeRecipient);\\n        emit Destroy();\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/auction/mocks/ERC1155AuctionMock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../ERC1155Auction.sol\\\";\\n\\n/**\\n * @notice Mock Contract of ERC1155Auction\\n */\\ncontract ERC1155AuctionMock is ERC1155Auction {\\n    uint256 public fakeBlockTimeStamp = 100;\\n\\n    /**\\n     * @notice Auction Constructor\\n     * @param _serviceFeeProxy service fee proxy\\n     */\\n    constructor(\\n        address _serviceFeeProxy,\\n        address _tradeTokenManager\\n    ) ERC1155Auction(_serviceFeeProxy, _tradeTokenManager)\\n    public {}\\n\\n    function setBlockTimeStamp(uint256 _now) external {\\n        fakeBlockTimeStamp = _now;\\n    }\\n\\n    function _getNow() internal override view returns (uint256) {\\n        return fakeBlockTimeStamp;\\n    }\\n}\"\r\n    },\r\n    \"contracts/service_fee/ServiceFeeMatic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../interfaces/IRefinableToken.sol\\\";\\nimport \\\"../interfaces/IServiceFee.sol\\\";\\n\\n/**\\n * @notice Service Fee contract for Refinable NFT Marketplace\\n */\\ncontract ServiceFeeMatic is AccessControl, IServiceFee {\\n    using Address for address;\\n\\n    /// @notice service fee contract\\n    IRefinableToken public refinableTokenContract;\\n\\n    bytes32 public constant PROXY_ROLE = keccak256(\\\"PROXY_ROLE\\\");\\n\\n    /// @notice Service fee recipient address\\n    address payable public serviceFeeRecipient;\\n\\n    event ServiceFeeRecipientChanged(address payable serviceFeeRecipient);\\n\\n    event RefinableTokenContractUpdated(address refinableTokenContract);\\n\\n    modifier onlyAdmin() {\\n        require(\\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\\n            \\\"Ownable: caller is not the admin\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyProxy() {\\n        require(\\n            hasRole(PROXY_ROLE, _msgSender()),\\n            \\\"Ownable: caller is not the proxy\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor() public {\\n        require(\\n            _msgSender() != address(0),\\n            \\\"Auction: Invalid Platform Fee Recipient\\\"\\n        );\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Lets admin set the refinable token contract\\n     * @param _refinableTokenContract address of refinable token contract\\n     */\\n    function setRefinableTokenContract(address _refinableTokenContract) onlyAdmin external override {\\n        require(\\n            _refinableTokenContract != address(0),\\n            \\\"ServiceFee.setRefinableTokenContract: Zero address\\\"\\n        );\\n        refinableTokenContract = IRefinableToken(_refinableTokenContract);\\n        emit RefinableTokenContractUpdated(_refinableTokenContract);\\n    }\\n\\n    /**\\n     * @notice Admin can add proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function addProxy(address _proxyAddr) onlyAdmin external override {\\n        require(\\n            _proxyAddr.isContract(),\\n            \\\"ServiceFee.addProxy: address is not a contract address\\\"\\n        );\\n        grantRole(PROXY_ROLE, _proxyAddr);\\n    }\\n\\n    /**\\n     * @notice Admin can remove proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function removeProxy(address _proxyAddr) onlyAdmin external override{\\n        require(\\n            _proxyAddr.isContract(),\\n            \\\"ServiceFee.removeProxy: address is not a contract address\\\"\\n        );\\n        revokeRole(PROXY_ROLE, _proxyAddr);\\n    }\\n\\n    /**\\n     * @notice Calculate the seller service fee in according to the business logic and returns it\\n     * @param _seller address of seller\\n     * @param _isSecondarySale sale is primary or secondary\\n     */\\n    function getSellServiceFeeBps(address _seller, bool _isSecondarySale) external view onlyProxy override returns (uint256) {\\n        require(\\n            _seller != address(0),\\n            \\\"ServiceFee.getSellServiceFeeBps: Zero address\\\"\\n        );\\n\\n        // We cannot check the FINE balance since it's not deployed to Matic yet. Everything is set to 1.5% for now.\\n        // TODO: Add the bridge token so the service fee can check FINE balance on Matic\\n\\n        //        uint256 balance = refinableTokenContract.balanceOf(_seller);\\n        \\n//        if(_isSecondarySale) {\\n//            if(balance >= 10000 * 10 ** 18)\\n//                return 150;\\n//            else if(balance >= 2500 * 10 ** 18)\\n//                return 175;\\n//            else if(balance >= 250 * 10 ** 18)\\n//                return 200;\\n//            else if(balance >= 20 * 10 ** 18)\\n//                return 225;\\n//        } else {\\n//            if(balance >= 250 * 10 ** 18)\\n//                return 200;\\n//            else if(balance >= 20 * 10 ** 18)\\n//                return 225;\\n//        }\\n        return 150;\\n    }\\n\\n    /**\\n     * @notice Calculate the buyer service fee in according to the business logic and returns it\\n     * @param _buyer address of buyer\\n     */\\n    function getBuyServiceFeeBps(address _buyer) onlyProxy external view override returns (uint256) {\\n        require(\\n            _buyer != address(0),\\n            \\\"ServiceFee.getBuyServiceFeeBps: Zero address\\\"\\n        );\\n//        uint256 balance = refinableTokenContract.balanceOf(_buyer);\\n//\\n//        if(balance >= 10000 * 10 ** 18)\\n//            return 150;\\n//        else if(balance >= 2500 * 10 ** 18)\\n//            return 175;\\n//        else if(balance >= 250 * 10 ** 18)\\n//            return 200;\\n//        else if(balance >= 20 * 10 ** 18)\\n//            return 225;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Get service fee recipient address\\n     */\\n    function getServiceFeeRecipient() onlyProxy external view override returns (address payable) {\\n        return serviceFeeRecipient;\\n    }\\n\\n    /**\\n     * @notice Set service fee recipient address\\n     * @param _serviceFeeRecipient address of recipient\\n     */\\n    function setServiceFeeRecipient(address payable _serviceFeeRecipient) onlyProxy external override {\\n        require(\\n            _serviceFeeRecipient != address(0),\\n            \\\"ServiceFee.setServiceFeeRecipient: Zero address\\\"\\n        );\\n\\n        serviceFeeRecipient = _serviceFeeRecipient;\\n        emit ServiceFeeRecipientChanged(_serviceFeeRecipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRefinableToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.6.12;\\n\\ninterface IRefinableToken {\\n\\n  /**\\n   * @dev Returns the bep token owner.\\n   */\\n  function getOwner() external view returns (address);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the token symbol.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the token name.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev See {BEP20-totalSupply}.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev See {BEP20-balanceOf}.\\n   */\\n  function balanceOf(address account)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev See {BEP20-transfer}.\\n   *\\n   * Requirements:\\n   *\\n   * - `recipient` cannot be the zero address.\\n   * - the caller must have a balance of at least `amount`.\\n   */\\n  function transfer(address recipient, uint256 amount)\\n    external\\n    returns (bool);\\n\\n  /**\\n   * @dev See {BEP20-allowance}.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev See {BEP20-approve}.\\n   *\\n   * Requirements:\\n   *\\n   * - `spender` cannot be the zero address.\\n   */\\n  function approve(address spender, uint256 amount)\\n    external\\n    returns (bool);\\n\\n  /**\\n   * @dev See {BEP20-transferFrom}.\\n   *\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\n   * required by the EIP. See the note at the beginning of {BEP20};\\n   *\\n   * Requirements:\\n   * - `sender` and `recipient` cannot be the zero address.\\n   * - `sender` must have a balance of at least `amount`.\\n   * - the caller must have allowance for `sender`'s tokens of at least\\n   * `amount`.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/service_fee/ServiceFee.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"../interfaces/IRefinableToken.sol\\\";\\nimport \\\"../interfaces/IServiceFee.sol\\\";\\n\\n/**\\n * @notice Service Fee contract for Refinable NFT Marketplace\\n */\\ncontract ServiceFee is AccessControl, IServiceFee {\\n    using Address for address;\\n\\n    /// @notice service fee contract\\n    IRefinableToken public refinableTokenContract;\\n\\n    bytes32 public constant PROXY_ROLE = keccak256(\\\"PROXY_ROLE\\\");\\n\\n    /// @notice Service fee recipient address\\n    address payable public serviceFeeRecipient;\\n\\n    event ServiceFeeRecipientChanged(address payable serviceFeeRecipient);\\n\\n    event RefinableTokenContractUpdated(address refinableTokenContract);\\n\\n    modifier onlyAdmin() {\\n        require(\\n            hasRole(DEFAULT_ADMIN_ROLE, _msgSender()),\\n            \\\"Ownable: caller is not the admin\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyProxy() {\\n        require(\\n            hasRole(PROXY_ROLE, _msgSender()),\\n            \\\"Ownable: caller is not the proxy\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor() public {\\n        require(\\n            _msgSender() != address(0),\\n            \\\"Auction: Invalid Platform Fee Recipient\\\"\\n        );\\n\\n        _setupRole(DEFAULT_ADMIN_ROLE, _msgSender());\\n    }\\n\\n    /**\\n     * @notice Lets admin set the refinable token contract\\n     * @param _refinableTokenContract address of refinable token contract\\n     */\\n    function setRefinableTokenContract(address _refinableTokenContract) onlyAdmin external override {\\n        require(\\n            _refinableTokenContract != address(0),\\n            \\\"ServiceFee.setRefinableTokenContract: Zero address\\\"\\n        );\\n        refinableTokenContract = IRefinableToken(_refinableTokenContract);\\n        emit RefinableTokenContractUpdated(_refinableTokenContract);\\n    }\\n\\n    /**\\n     * @notice Admin can add proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function addProxy(address _proxyAddr) onlyAdmin external override {\\n        require(\\n            _proxyAddr.isContract(),\\n            \\\"ServiceFee.addProxy: address is not a contract address\\\"\\n        );\\n        grantRole(PROXY_ROLE, _proxyAddr);\\n    }\\n\\n    /**\\n     * @notice Admin can remove proxy address\\n     * @param _proxyAddr address of proxy\\n     */\\n    function removeProxy(address _proxyAddr) onlyAdmin external override{\\n        require(\\n            _proxyAddr.isContract(),\\n            \\\"ServiceFee.removeProxy: address is not a contract address\\\"\\n        );\\n        revokeRole(PROXY_ROLE, _proxyAddr);\\n    }\\n\\n    /**\\n     * @notice Calculate the seller service fee in according to the business logic and returns it\\n     * @param _seller address of seller\\n     * @param _isSecondarySale sale is primary or secondary\\n     */\\n    function getSellServiceFeeBps(address _seller, bool _isSecondarySale) external view onlyProxy override returns (uint256) {\\n        require(\\n            _seller != address(0),\\n            \\\"ServiceFee.getSellServiceFeeBps: Zero address\\\"\\n        );\\n\\n        uint256 balance = refinableTokenContract.balanceOf(_seller);\\n\\n        if(_isSecondarySale) {\\n            if(balance >= 10000 * 10 ** 18)\\n                return 150;\\n            else if(balance >= 2500 * 10 ** 18)\\n                return 175;\\n            else if(balance >= 250 * 10 ** 18)\\n                return 200;\\n            else if(balance >= 20 * 10 ** 18)\\n                return 225;\\n        } else {\\n            if(balance >= 250 * 10 ** 18)\\n                return 200;\\n            else if(balance >= 20 * 10 ** 18)\\n                return 225;\\n        }\\n        return 250;\\n    }\\n\\n    /**\\n     * @notice Calculate the buyer service fee in according to the business logic and returns it\\n     * @param _buyer address of buyer\\n     */\\n    function getBuyServiceFeeBps(address _buyer) onlyProxy external view override returns (uint256) {\\n        require(\\n            _buyer != address(0),\\n            \\\"ServiceFee.getBuyServiceFeeBps: Zero address\\\"\\n        );\\n        uint256 balance = refinableTokenContract.balanceOf(_buyer);\\n\\n        if(balance >= 10000 * 10 ** 18)\\n            return 150;\\n        else if(balance >= 2500 * 10 ** 18)\\n            return 175;\\n        else if(balance >= 250 * 10 ** 18)\\n            return 200;\\n        else if(balance >= 20 * 10 ** 18)\\n            return 225;\\n        return 250;\\n    }\\n\\n    /**\\n     * @notice Get service fee recipient address\\n     */\\n    function getServiceFeeRecipient() onlyProxy external view override returns (address payable) {\\n        return serviceFeeRecipient;\\n    }\\n\\n    /**\\n     * @notice Set service fee recipient address\\n     * @param _serviceFeeRecipient address of recipient\\n     */\\n    function setServiceFeeRecipient(address payable _serviceFeeRecipient) onlyProxy external override {\\n        require(\\n            _serviceFeeRecipient != address(0),\\n            \\\"ServiceFee.setServiceFeeRecipient: Zero address\\\"\\n        );\\n\\n        serviceFeeRecipient = _serviceFeeRecipient;\\n        emit ServiceFeeRecipientChanged(_serviceFeeRecipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/RefinableERC721WhiteListedTokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC721BaseV2.sol\\\";\\n/**\\n * @title RefinableERC721TokenWhiteListed\\n * @dev only minters can mint token.\\n\\n */\\ncontract RefinableERC721WhiteListedTokenV2 is ERC721BaseV2 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721BaseV2(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) public onlyMinter {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory newRoyaltyShares;\\n\\n        //add the default royalties if the contract has set\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0) {\\n            newRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](_royaltyShares.length + 1);\\n            for (uint256 i = 0; i < _royaltyShares.length; i++) {\\n                newRoyaltyShares[i] = _royaltyShares[i];\\n            }\\n            newRoyaltyShares[_royaltyShares.length] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n        } else {\\n            newRoyaltyShares = _royaltyShares;\\n        }\\n\\n        _mint(msg.sender, _tokenId, newRoyaltyShares, _uri, _royaltyBps, _royaltyStrategy);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10**4, \\\"ERC721: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v2/RefinableERC721TokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"./ERC721BaseV2.sol\\\";\\n\\n/**\\n * @title RefinableERC721Token\\n * @dev anyone can mint token.\\n */\\ncontract RefinableERC721TokenV2 is ERC721BaseV2 {\\n    using ECDSA for bytes32;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721BaseV2(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy\\n    ) public {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender))\\n                .toEthSignedMessageHash()\\n                .recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n        _mint(msg.sender, _tokenId, _royaltyShares, _uri, _royaltyBps, _royaltyStrategy);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/airdrop/ERC721AirdropMatic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @notice Airdrop contract for Refinable NFT Marketplace\\n */\\ncontract ERC721AirdropMatic is Context, ReentrancyGuard {\\n\\n    /// @notice ERC721 NFT\\n    IERC721 public token;\\n\\n    event AirdropContractDeployed();\\n    event AirdropFinished(\\n        uint256[] tokenIds,\\n        address[] recipients\\n    );\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor(\\n        IERC721 _token\\n    ) public {\\n        require(address(_token) != address(0), \\\"Invalid NFT\\\");\\n\\n        token = _token;\\n\\n        emit AirdropContractDeployed();\\n    }\\n\\n    /**\\n     * @dev Owner of token can airdrop tokens to recipients\\n     * @param _tokenIds array of token id\\n     * @param _recipients addresses of recipients\\n     */\\n    function airdrop(IERC721 _token, uint256[] memory _tokenIds, address[] memory _recipients) external nonReentrant {\\n        require(\\n            _token == token,\\n            \\\"ERC721Airdrop: Token is not allowed\\\"\\n        );\\n        require(\\n            _recipients.length == _tokenIds.length,\\n            \\\"ERC721Airdrop: Count of recipients should be same as count of token ids\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            require(\\n                _token.ownerOf(_tokenIds[i]) == _msgSender(),\\n                \\\"ERC721Airdrop: Caller is not the owner\\\"\\n            );\\n        }\\n\\n        require(\\n            _token.isApprovedForAll(_msgSender(), address(this)),\\n            \\\"ERC721Airdrop: Owner has not approved\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            _token.safeTransferFrom(_msgSender(), _recipients[i], _tokenIds[i]);\\n        }\\n\\n        emit AirdropFinished(_tokenIds, _recipients);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRefinableERC721Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title RefinableERC721Token Interface\\n */\\ninterface IRefinableERC721Token is IERC721 {\\n    struct Fee {\\n        address payable recipient;\\n        uint256 value;\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        Fee[] memory _fees,\\n        string memory _tokenURI\\n    ) external;\\n\\n    function setBaseURI(string memory _baseURI) external;\\n\\n    function setContractURI(string memory _contractURI) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/RefinableNFTFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../interfaces/IRefinableERC721Token.sol\\\";\\nimport \\\"../interfaces/IRefinableERC1155Token.sol\\\";\\nimport \\\"../libs/Ownable.sol\\\";\\n\\n/**\\n * @title RefinableNFTFactory Contract\\n */\\ncontract RefinableNFTFactory is Ownable\\n{\\n    /// @notice Event emitted only on construction. To be used by indexers\\n    event RefinableNFTFactoryContractDeployed();\\n\\n    event ERC721TokenBulkMinted(\\n        address indexed minter,\\n        uint256[] tokenIds,\\n        IRefinableERC721Token.Fee[][] fees,\\n        string[] tokenURIs\\n    );\\n\\n    /// @notice Max bulk mint count\\n    uint256 public maxBulkCount = 100;\\n\\n    /// @notice RefinableERC721 Token\\n    IRefinableERC721Token public refinableERC721Token;\\n\\n    /// @notice RefinableERC1155 Token\\n    IRefinableERC1155Token public refinableERC1155Token;\\n\\n    /**\\n     * @notice Auction Constructor\\n     * @param _refinableERC721Token RefinableERC721Token Interface\\n     * @param _refinableERC1155Token RefinableERC1155Token Interface\\n     */\\n    constructor(\\n        IRefinableERC721Token _refinableERC721Token,\\n        IRefinableERC1155Token _refinableERC1155Token\\n    ) public {\\n        require(\\n            address(_refinableERC721Token) != address(0),\\n            \\\"Invalid NFT\\\"\\n        );\\n\\n        require(\\n            address(_refinableERC1155Token) != address(0),\\n            \\\"Invalid NFT\\\"\\n        );\\n\\n        refinableERC721Token = _refinableERC721Token;\\n        refinableERC1155Token = _refinableERC1155Token;\\n\\n        emit RefinableNFTFactoryContractDeployed();\\n    }\\n\\n    function bulk_mint_erc721_token(\\n        uint256[] memory _tokenIds,\\n        bytes[] memory _signatures,\\n        IRefinableERC721Token.Fee[][] memory _fees,\\n        string[] memory _tokenURIs\\n    ) public onlyOwner {\\n        require(\\n            _tokenIds.length > 0,\\n            \\\"Empty array is provided\\\"\\n        );\\n\\n        require(\\n            _tokenIds.length < maxBulkCount,\\n            \\\"Too big array is provided\\\"\\n        );\\n\\n        require(\\n            _tokenIds.length == _signatures.length && _signatures.length == _fees.length && _fees.length == _tokenURIs.length,\\n            \\\"Size of params are not same\\\"\\n        );\\n\\n        for(uint256 i = 0; i < _tokenIds.length; i++) {\\n            refinableERC721Token.mint(_tokenIds[i], _signatures[i], _fees[i],  _tokenURIs[i]);\\n            refinableERC721Token.safeTransferFrom(address(this), msg.sender, _tokenIds[i]);\\n        }\\n\\n        emit ERC721TokenBulkMinted(msg.sender, _tokenIds, _fees, _tokenURIs);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRefinableERC1155Token.sol\": {\r\n      \"content\": \"pragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n// SPDX-License-Identifier: UNLICENSED\\n\\n/**\\n * @title RefinableERC1155Token Interface\\n */\\ninterface IRefinableERC1155Token {\\n    struct Fee {\\n        address payable recipient;\\n        uint256 value;\\n    }\\n\\n    function mint(uint256 _tokenId, bytes memory _signature, Fee[] memory _fees, uint256 _supply, string memory _uri) external;\\n}\"\r\n    },\r\n    \"contracts/airdrop/ERC721Airdrop.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @notice Airdrop contract for Refinable NFT Marketplace\\n */\\ncontract ERC721Airdrop is Context, ReentrancyGuard {\\n\\n    /// @notice ERC721 NFT\\n    IERC721 public token;\\n    IERC721 public tokenV2;\\n\\n    event AirdropContractDeployed();\\n    event AirdropFinished(\\n        uint256[] tokenIds,\\n        address[] recipients\\n    );\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor(\\n        IERC721 _token,\\n        IERC721 _tokenV2\\n    ) public {\\n        require(address(_token) != address(0), \\\"Invalid NFT\\\");\\n        require(address(_tokenV2) != address(0), \\\"Invalid NFT\\\");\\n\\n        token = _token;\\n        tokenV2 = _tokenV2;\\n\\n        emit AirdropContractDeployed();\\n    }\\n\\n    /**\\n     * @dev Owner of token can airdrop tokens to recipients\\n     * @param _tokenIds array of token id\\n     * @param _recipients addresses of recipients\\n     */\\n    function airdrop(IERC721 _token, uint256[] memory _tokenIds, address[] memory _recipients) external nonReentrant {\\n        require(\\n            _token == token || _token == tokenV2,\\n            \\\"ERC721Airdrop: Token is not allowed\\\"\\n        );\\n        require(\\n            _recipients.length == _tokenIds.length,\\n            \\\"ERC721Airdrop: Count of recipients should be same as count of token ids\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            require(\\n                _token.ownerOf(_tokenIds[i]) == _msgSender(),\\n                \\\"ERC721Airdrop: Caller is not the owner\\\"\\n            );\\n        }\\n\\n        require(\\n            _token.isApprovedForAll(_msgSender(), address(this)),\\n            \\\"ERC721Airdrop: Owner has not approved\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _tokenIds.length; i++) {\\n            _token.safeTransferFrom(_msgSender(), _recipients[i], _tokenIds[i]);\\n        }\\n\\n        emit AirdropFinished(_tokenIds, _recipients);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/airdrop/ERC1155AirdropMatic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/GSN/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\n/**\\n * @notice Airdrop contract for Refinable NFT Marketplace\\n */\\ncontract ERC1155AirdropMatic is Context, ReentrancyGuard {\\n\\n    /// @notice ERC1155 NFT\\n    IERC1155 public token;\\n\\n    event AirdropContractDeployed();\\n    event AirdropFinished(\\n        uint256 tokenId,\\n        address[] recipients\\n    );\\n\\n    /**\\n     * @dev Constructor Function\\n    */\\n    constructor(\\n        IERC1155 _token\\n    ) public {\\n        require(address(_token) != address(0), \\\"Invalid NFT\\\");\\n\\n        token = _token;\\n\\n        emit AirdropContractDeployed();\\n    }\\n\\n    /**\\n     * @dev Owner of token can airdrop tokens to recipients\\n     * @param _tokenId id of the token\\n     * @param _recipients addresses of recipients\\n     */\\n    function airdrop(IERC1155 _token, uint256 _tokenId, address[] memory _recipients) external nonReentrant {\\n        require(\\n            _token == token,\\n            \\\"ERC1155Airdrop: Token is not allowed\\\"\\n        );\\n        require(\\n            _token.balanceOf(_msgSender(), _tokenId) >= _recipients.length,\\n            \\\"ERC1155Airdrop: Caller does not have amount of tokens\\\"\\n        );\\n        require(\\n            _token.isApprovedForAll(_msgSender(), address(this)),\\n            \\\"ERC1155Airdrop: Owner has not approved\\\"\\n        );\\n\\n        for (uint256 i = 0; i < _recipients.length; i++) {\\n            _token.safeTransferFrom(_msgSender(), _recipients[i], _tokenId, 1, \\\"\\\");\\n        }\\n\\n        emit AirdropFinished(_tokenId, _recipients);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/DAFERC721WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC721BaseV3.sol\\\";\\n/**\\n * @title RefinableERC721TokenWhiteListed\\n * @dev only minters can mint token.\\n\\n */\\ncontract DAFERC721WhiteListedTokenV3 is ERC721BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    address payable public defaultRoyaltyReceiver = address(0);\\n    uint256 public defaultRoyaltyReceiverBps = 0;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721BaseV3(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory defaultPrimaryRoyaltyShares = new RoyaltyLibrary.RoyaltyShareDetails[](1);\\n        if (defaultRoyaltyReceiver != address(0) && defaultRoyaltyReceiverBps != 0)\\n            defaultPrimaryRoyaltyShares[0] = RoyaltyLibrary.RoyaltyShareDetails({\\n            recipient : defaultRoyaltyReceiver,\\n            value : defaultRoyaltyReceiverBps\\n            });\\n        _mint(msg.sender, _tokenId, _royaltyShares, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyShares);\\n    }\\n\\n    function setDefaultRoyaltyReceiver(address payable _receiver) public onlyAdmin {\\n        defaultRoyaltyReceiver = _receiver;\\n    }\\n\\n    function setDefaultRoyaltyReceiverBps(uint256 _bps) public onlyAdmin {\\n        require(_bps <= 10 ** 4, \\\"ERC721: Fee bps should not exceed 10000\\\");\\n        defaultRoyaltyReceiverBps = _bps;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/v3/whitelist/CoralERC721WhiteListedTokenV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/cryptography/ECDSA.sol\\\";\\nimport \\\"../ERC721BaseV3.sol\\\";\\n/**\\n * @title RefinableERC721TokenWhiteListed\\n * @dev only minters can mint token.\\n\\n */\\ncontract CoralERC721WhiteListedTokenV3 is ERC721BaseV3 {\\n    using ECDSA for bytes32;\\n\\n    RoyaltyLibrary.RoyaltyShareDetails[] public defaultPrimaryRoyaltyReceivers;\\n\\n    /**\\n     * @dev Constructor Function\\n     * @param _name name of the token ex: Rarible\\n     * @param _symbol symbol of the token ex: RARI\\n     * @param _root address of admin account\\n     * @param _signer address of signer account\\n     * @param _contractURI URI of contract ex: https://api-mainnet.rarible.com/contractMetadata/{address}\\n     * @param _baseURI ex: https://ipfs.daonomic.com\\n    */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        address _root,\\n        address _signer,\\n        string memory _contractURI,\\n        string memory _baseURI\\n    ) public ERC721BaseV3(_name, _symbol, _contractURI, _baseURI) {\\n        addAdmin(_root);\\n        addSigner(_signer);\\n    }\\n\\n    function mint(\\n        uint256 _tokenId,\\n        bytes memory _signature,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _royaltyShares,\\n        string memory _uri,\\n        uint256 _royaltyBps,\\n        RoyaltyLibrary.Strategy _royaltyStrategy,\\n        RoyaltyLibrary.RoyaltyShareDetails[] memory _primaryRoyaltyShares\\n    ) public onlyMinter {\\n        require(\\n            isSigner(\\n                keccak256(abi.encodePacked(address(this), _tokenId, msg.sender)).toEthSignedMessageHash().recover(_signature)\\n            ),\\n            \\\"invalid signer\\\"\\n        );\\n\\n        _mint(msg.sender, _tokenId, _royaltyShares, _uri, _royaltyBps, RoyaltyLibrary.Strategy.PRIMARY_SALE_STRATEGY, defaultPrimaryRoyaltyReceivers);\\n    }\\n\\n    function setPrimaryDefaultRoyaltyReceivers(RoyaltyLibrary.RoyaltyShareDetails[] memory _receivers) public onlyAdmin {\\n        delete defaultPrimaryRoyaltyReceivers;\\n        for (uint256 i = 0; i < _receivers.length; i++) {\\n            defaultPrimaryRoyaltyReceivers.push(_receivers[i]);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_root\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_signer\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"bp\",\"type\":\"uint256[]\"}],\"name\":\"SetPrimaryRoyaltyShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum RoyaltyLibrary.Strategy\",\"name\":\"strategy\",\"type\":\"uint8\"}],\"name\":\"SetRoyalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"bp\",\"type\":\"uint256[]\"}],\"name\":\"SetRoyaltyShares\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SIGNER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"addMinterBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"checkSecondarySale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRoyaltyReceiver\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultRoyaltyReceiverBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCreator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPrimaryRoyaltyShares\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyalty\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"enum RoyaltyLibrary.Strategy\",\"name\":\"strategy\",\"type\":\"uint8\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyaltyShares\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isSecondarySale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"_royaltyShares\",\"type\":\"tuple[]\"},{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBps\",\"type\":\"uint256\"},{\"internalType\":\"enum RoyaltyLibrary.Strategy\",\"name\":\"_royaltyStrategy\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"_primaryRoyaltyShares\",\"type\":\"tuple[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"_royaltyShares\",\"type\":\"tuple[]\"},{\"internalType\":\"string[]\",\"name\":\"_uris\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBps\",\"type\":\"uint256\"},{\"internalType\":\"enum RoyaltyLibrary.Strategy\",\"name\":\"_royaltyStrategy\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct RoyaltyLibrary.RoyaltyShareDetails[]\",\"name\":\"_primaryRoyaltyShares\",\"type\":\"tuple[]\"}],\"name\":\"mintSimilarBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"enum RoyaltyLibrary.Strategy\",\"name\":\"strategy\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royaltyShares\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_contractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"setDefaultRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bps\",\"type\":\"uint256\"}],\"name\":\"setDefaultRoyaltyReceiverBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setSecondarySale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WhiteListedTokenERC721V3", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000003f231e09f6e4e97e8fec2f1e507414460c866f23000000000000000000000000d2e49cfd5c03a72a838a2fc6bb5f6b46927e731a000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000001f4e65696c204261727265747420436f6c6c656374696f6e206279204d4f44410000000000000000000000000000000000000000000000000000000000000000114e45494c5f424152524554545f4d4f4441000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003468747470733a2f2f6170692e726566696e61626c652e636f6d2f636f6e74726163744d657461646174612f7b616464726573737d000000000000000000000000000000000000000000000000000000000000000000000000000000000000002068747470733a2f2f697066732e726566696e61626c652e636f6d2f697066732f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}