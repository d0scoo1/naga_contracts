{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.8.7;\r\n\r\n\r\n// SPDX-License-Identifier: Unlicense\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// Taken from Solmate: https://github.com/Rari-Capital/solmate\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function name() external view virtual returns (string memory);\r\n    function symbol() external view virtual returns (string memory);\r\n    function decimals() external view virtual returns (uint8);\r\n\r\n    // string public constant name     = \"TREAT\";\r\n    // string public constant symbol   = \"TREAT\";\r\n    // uint8  public constant decimals = 18;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    mapping(address => bool) public isMinter;\r\n\r\n    address public ruler;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor() { ruler = msg.sender;}\r\n\r\n    function approve(address spender, uint256 value) external returns (bool) {\r\n        allowance[msg.sender][spender] = value;\r\n\r\n        emit Approval(msg.sender, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 value) external returns (bool) {\r\n        balanceOf[msg.sender] -= value;\r\n\r\n        // This is safe because the sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            balanceOf[to] += value;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool) {\r\n        if (allowance[from][msg.sender] != type(uint256).max) {\r\n            allowance[from][msg.sender] -= value;\r\n        }\r\n\r\n        balanceOf[from] -= value;\r\n\r\n        // This is safe because the sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            balanceOf[to] += value;\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             PRIVILEGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mint(address to, uint256 value) external {\r\n        require(isMinter[msg.sender], \"FORBIDDEN TO MINT\");\r\n        _mint(to, value);\r\n    }\r\n\r\n    function burn(address from, uint256 value) external {\r\n        require(isMinter[msg.sender], \"FORBIDDEN TO BURN\");\r\n        _burn(from, value);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         Ruler Function\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setMinter(address minter, bool status) external {\r\n        require(msg.sender == ruler, \"NOT ALLOWED TO RULE\");\r\n\r\n        isMinter[minter] = status;\r\n    }\r\n\r\n    function setRuler(address ruler_) external {\r\n        require(msg.sender == ruler ||ruler == address(0), \"NOT ALLOWED TO RULE\");\r\n\r\n        ruler = ruler_;\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                          INTERNAL UTILS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 value) internal {\r\n        totalSupply += value;\r\n\r\n        // This is safe because the sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            balanceOf[to] += value;\r\n        }\r\n\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal {\r\n        balanceOf[from] -= value;\r\n\r\n        // This is safe because a user won't ever\r\n        // have a balance larger than totalSupply!\r\n        unchecked {\r\n            totalSupply -= value;\r\n        }\r\n\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n}\r\n\r\n/// @notice Modern and gas efficient ERC-721 + ERC-20/EIP-2612-like implementation,\r\n/// including the MetaData, and partially, Enumerable extensions.\r\ncontract ERC721 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    \r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);\r\n    \r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    address        implementation_;\r\n    address public admin; //Lame requirement from opensea\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                             ERC-721 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n    uint256 public oldSupply;\r\n    uint256 public minted;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    \r\n    mapping(uint256 => address) public ownerOf;\r\n        \r\n    mapping(uint256 => address) public getApproved;\r\n \r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             VIEW FUNCTION\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function owner() external view returns (address) {\r\n        return admin;\r\n    }\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC-20-LIKE LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function transfer(address to, uint256 tokenId) external {\r\n        require(msg.sender == ownerOf[tokenId], \"NOT_OWNER\");\r\n        \r\n        _transfer(msg.sender, to, tokenId);\r\n        \r\n    }\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC-721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n    \r\n    function supportsInterface(bytes4 interfaceId) external pure returns (bool supported) {\r\n        supported = interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\r\n    }\r\n    \r\n    function approve(address spender, uint256 tokenId) external {\r\n        address owner_ = ownerOf[tokenId];\r\n        \r\n        require(msg.sender == owner_ || isApprovedForAll[owner_][msg.sender], \"NOT_APPROVED\");\r\n        \r\n        getApproved[tokenId] = spender;\r\n        \r\n        emit Approval(owner_, spender, tokenId); \r\n    }\r\n    \r\n    function setApprovalForAll(address operator, bool approved) external {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n        \r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 tokenId) public {\r\n        require(\r\n            msg.sender == from \r\n            || msg.sender == getApproved[tokenId]\r\n            || isApprovedForAll[from][msg.sender], \r\n            \"NOT_APPROVED\"\r\n        );\r\n        \r\n        _transfer(from, to, tokenId);\r\n        \r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external {\r\n        safeTransferFrom(from, to, tokenId, \"\");\r\n    }\r\n    \r\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public {\r\n        transferFrom(from, to, tokenId); \r\n        \r\n        if (to.code.length != 0) {\r\n            // selector = `onERC721Received(address,address,uint,bytes)`\r\n            (, bytes memory returned) = to.staticcall(abi.encodeWithSelector(0x150b7a02,\r\n                msg.sender, from, tokenId, data));\r\n                \r\n            bytes4 selector = abi.decode(returned, (bytes4));\r\n            \r\n            require(selector == 0x150b7a02, \"NOT_ERC721_RECEIVER\");\r\n        }\r\n    }\r\n    \r\n    /*///////////////////////////////////////////////////////////////\r\n                          INTERNAL UTILS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _transfer(address from, address to, uint256 tokenId) internal {\r\n        require(ownerOf[tokenId] == from, \"not owner\");\r\n\r\n        balanceOf[from]--; \r\n        balanceOf[to]++;\r\n        \r\n        delete getApproved[tokenId];\r\n        \r\n        ownerOf[tokenId] = to;\r\n        emit Transfer(from, to, tokenId); \r\n\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal { \r\n        require(ownerOf[tokenId] == address(0), \"ALREADY_MINTED\");\r\n\r\n        totalSupply++;\r\n\r\n        // This is safe because the sum of all user\r\n        // balances can't exceed type(uint256).max!\r\n        unchecked {\r\n            balanceOf[to]++;\r\n        }\r\n        \r\n        ownerOf[tokenId] = to;\r\n                \r\n        emit Transfer(address(0), to, tokenId); \r\n    }\r\n    \r\n    function _burn(uint256 tokenId) internal { \r\n        address owner_ = ownerOf[tokenId];\r\n        \r\n        require(ownerOf[tokenId] != address(0), \"NOT_MINTED\");\r\n        \r\n        totalSupply--;\r\n        balanceOf[owner_]--;\r\n        \r\n        delete ownerOf[tokenId];\r\n                \r\n        emit Transfer(owner_, address(0), tokenId); \r\n    }\r\n}\r\n\r\ninterface ITraits {\r\n  function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\ninterface IDogewood {\r\n    // struct to store each token's traits\r\n    struct Doge {\r\n        uint8 head;\r\n        uint8 breed;\r\n        uint8 color;\r\n        uint8 class;\r\n        uint8 armor;\r\n        uint8 offhand;\r\n        uint8 mainhand;\r\n        uint16 level;\r\n    }\r\n\r\n    function getTokenTraits(uint256 tokenId) external view returns (Doge memory);\r\n    function getGenesisSupply() external view returns (uint256);\r\n    function pull(address owner, uint256[] calldata ids) external;\r\n    function manuallyAdjustDoge(uint256 id, uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level) external;\r\n    function transfer(address to, uint256 tokenId) external;\r\n    // function doges(uint256 id) external view returns(uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n}\r\n\r\n// interface DogeLike {\r\n//     function pull(address owner, uint256[] calldata ids) external;\r\n//     function manuallyAdjustDoge(uint256 id, uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level) external;\r\n//     function transfer(address to, uint256 tokenId) external;\r\n//     function doges(uint256 id) external view returns(uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n// }\r\ninterface PortalLike {\r\n    function sendMessage(bytes calldata message_) external;\r\n}\r\n\r\ninterface CastleLike {\r\n    function pullCallback(address owner, uint256[] calldata ids) external;\r\n}\r\n\r\n// interface DogewoodLike {\r\n//     function ownerOf(uint256 id) external view returns (address owner_);\r\n//     function activities(uint256 id) external view returns (address owner, uint88 timestamp, uint8 action);\r\n//     function doges(uint256 dogeId) external view returns (uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level);\r\n// }\r\ninterface ERC20Like {\r\n    function balanceOf(address from) external view returns(uint256 balance);\r\n    function burn(address from, uint256 amount) external;\r\n    function mint(address from, uint256 amount) external;\r\n    function transfer(address to, uint256 amount) external;\r\n}\r\n\r\ninterface ERC1155Like {\r\n    function mint(address to, uint256 id, uint256 amount) external;\r\n    function burn(address from, uint256 id, uint256 amount) external;\r\n}\r\n\r\ninterface ERC721Like {\r\n    function transferFrom(address from, address to, uint256 id) external;   \r\n    function transfer(address to, uint256 id) external;\r\n    function ownerOf(uint256 id) external returns (address owner);\r\n    function mint(address to, uint256 tokenid) external;\r\n}\r\n\r\ncontract Dogewood is ERC721 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                    Global STATE\r\n    //////////////////////////////////////////////////////////////*/\r\n    // max number of tokens that can be minted - 5000 in production\r\n    uint256 public constant MAX_SUPPLY = 5000;\r\n    uint256 public constant GENESIS_SUPPLY = 2500;\r\n    uint256 public constant mintCooldown = 12 hours;\r\n\r\n    // Helpers to get Percentages\r\n    uint256 constant tenPct = (type(uint16).max / 100) * 10;\r\n    uint256 constant fifteenPct = (type(uint16).max / 100) * 15;\r\n    uint256 constant fiftyPct = (type(uint16).max / 100) * 50;\r\n\r\n    bool public presaleActive;\r\n    bool public saleActive;\r\n    mapping (address => uint8) public whitelist;\r\n    mapping (address => uint8) public ogWhitelist;\r\n\r\n    uint256 public mintPriceEth;\r\n    uint256 public mintPriceZug;\r\n    uint16 public constant MAX_ZUG_MINT = 200;\r\n    uint16 public zugMintCount;\r\n\r\n    // list of probabilities for each trait type\r\n    // 0 - 6 are associated with head, breed, color, class, armor, offhand, mainhand\r\n    uint8[][7] public rarities;\r\n    // list of aliases for Walker's Alias algorithm\r\n    // 0 - 6 are associated with head, breed, color, class, armor, offhand, mainhand\r\n    uint8[][7] public aliases;\r\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\r\n    // used to ensure there are no duplicates\r\n    mapping(uint256 => uint256) public existingCombinations;\r\n\r\n    bool public rerollTreatOnly;\r\n    uint256 public rerollPriceEth;\r\n    uint256 public rerollPriceZug;\r\n    uint256[] public rerollPrice;\r\n\r\n    // level 1-20\r\n    uint256[] public upgradeLevelPrice;\r\n\r\n    bytes32 internal entropySauce;\r\n\r\n    ERC20 public treat;\r\n    ERC20 public zug;\r\n\r\n    mapping(address => bool) public auth;\r\n    mapping(uint256 => Doge) internal doges;\r\n    mapping(uint256 => Action) public activities;\r\n    mapping(uint256 => Log) public mintLogs;\r\n    mapping(RerollTypes => mapping(uint256 => uint256)) public rerollCountHistory; // rerollType => tokenId => rerollCount\r\n\r\n    // reference to Traits\r\n    ITraits public traits;\r\n\r\n    mapping(uint256 => uint256) public rerollBlocks;\r\n\r\n    // Layer2 migration data -------------\r\n    // MetadataHandlerLike public metadaHandler;\r\n    mapping(bytes4 => address) implementer;\r\n\r\n    // TODO -- remove fallback?\r\n    address constant impl = 0x7ef61741D9a2b483E75D8AA0876Ce864d98cE331;\r\n\r\n    address public castle;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    End of data\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function setImplementer(bytes4[] calldata funcs, address source) external onlyOwner {\r\n        for (uint256 index = 0; index < funcs.length; index++) {\r\n            implementer[funcs[index]] = source; \r\n        }\r\n    }\r\n\r\n    function setAddresses(\r\n        address _traits,\r\n        address _treat,\r\n        address _zug,\r\n        address _castle\r\n    ) external onlyOwner {\r\n        traits = ITraits(_traits);\r\n        treat = ERC20(_treat);\r\n        zug = ERC20(_zug);\r\n        castle = _castle;\r\n    }\r\n\r\n    function setTreat(address t_) external {\r\n        require(msg.sender == admin);\r\n        treat = ERC20(t_);\r\n    }\r\n\r\n    function setZug(address z_) external {\r\n        require(msg.sender == admin);\r\n        zug = ERC20(z_);\r\n    }\r\n\r\n    function setCastle(address c_) external {\r\n        require(msg.sender == admin);\r\n        castle = c_;\r\n    }\r\n\r\n    function setTraits(address t_) external {\r\n        require(msg.sender == admin);\r\n        traits = ITraits(t_);\r\n    }\r\n\r\n    function setAuth(address add, bool isAuth) external onlyOwner {\r\n        auth[add] = isAuth;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        admin = newOwner;\r\n    }\r\n\r\n    function setPresaleStatus(bool _status) external onlyOwner {\r\n        presaleActive = _status;\r\n    }\r\n\r\n    function setSaleStatus(bool _status) external onlyOwner {\r\n        saleActive = _status;\r\n    }\r\n\r\n    function setMintPrice(uint256 _mintPriceEth, uint256 _mintPriceZug)\r\n        external\r\n        onlyOwner\r\n    {\r\n        mintPriceEth = _mintPriceEth;\r\n        mintPriceZug = _mintPriceZug;\r\n    }\r\n\r\n    function setRerollTreatOnly(bool _rerollTreatOnly) external onlyOwner {\r\n        rerollTreatOnly = _rerollTreatOnly;\r\n    }\r\n\r\n    function setRerollPrice(\r\n        uint256 _rerollPriceEth,\r\n        uint256 _rerollPriceZug,\r\n        uint256[] calldata _rerollPriceTreat\r\n    ) external onlyOwner {\r\n        rerollPriceEth = _rerollPriceEth;\r\n        rerollPriceZug = _rerollPriceZug;\r\n        rerollPrice = _rerollPriceTreat;\r\n    }\r\n\r\n    function setUpgradeLevelPrice(uint256[] calldata _upgradeLevelPrice) external onlyOwner {\r\n        upgradeLevelPrice = _upgradeLevelPrice;\r\n    }\r\n\r\n    function editWhitelist(address[] calldata wlAddresses) external onlyOwner {\r\n        for(uint256 i; i < wlAddresses.length; i++){\r\n            whitelist[wlAddresses[i]] = 2;\r\n        }\r\n    }\r\n\r\n    function editOGWhitelist(address[] calldata wlAddresses) external onlyOwner {\r\n        for(uint256 i; i < wlAddresses.length; i++){\r\n            ogWhitelist[wlAddresses[i]] = 1;\r\n        }\r\n    }\r\n\r\n    /** RENDER */\r\n\r\n    function tokenURI(uint256 tokenId) public view returns (string memory) {\r\n        // doges[tokenId] empty check\r\n        require(rerollBlocks[tokenId] != block.number, \"ERC721Metadata: URI query for nonexistent token\");\r\n        return traits.tokenURI(tokenId);\r\n    }\r\n\r\n    event ActionMade(\r\n        address owner,\r\n        uint256 id,\r\n        uint256 timestamp,\r\n        uint8 activity\r\n    );\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                DATA STRUCTURES \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    struct Doge {\r\n        uint8 head;\r\n        uint8 breed;\r\n        uint8 color;\r\n        uint8 class;\r\n        uint8 armor;\r\n        uint8 offhand;\r\n        uint8 mainhand;\r\n        uint16 level;\r\n    }\r\n\r\n    enum Actions {\r\n        UNSTAKED,\r\n        FARMING\r\n    }\r\n    struct Action {\r\n        address owner;\r\n        uint88 timestamp;\r\n        Actions action;\r\n    }\r\n    struct Log {\r\n        address owner;\r\n        uint88 timestamp;\r\n    }\r\n    enum RerollTypes {\r\n        BREED,\r\n        CLASS\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n    function initialize() public onlyOwner {\r\n        admin = msg.sender;\r\n        auth[msg.sender] = true;\r\n\r\n        // initialize state\r\n        presaleActive = false;\r\n        saleActive = false;\r\n        mintPriceEth = 0.065 ether;\r\n        mintPriceZug = 300 ether;\r\n\r\n        // I know this looks weird but it saves users gas by making lookup O(1)\r\n        // A.J. Walker's Alias Algorithm\r\n        // head\r\n        rarities[0] = [173, 155, 255, 206, 206, 206, 114, 114, 114];\r\n        aliases[0] = [2, 2, 8, 0, 0, 0, 0, 1, 1];\r\n        // breed\r\n        rarities[1] = [255, 255, 255, 255, 255, 255, 255, 255];\r\n        aliases[1] = [7, 7, 7, 7, 7, 7, 7, 7];\r\n        // color\r\n        rarities[2] = [255, 188, 255, 229, 153, 76];\r\n        aliases[2] = [2, 2, 5, 0, 0, 1];\r\n        // class\r\n        rarities[3] = [229, 127, 178, 255, 204, 204, 204, 102];\r\n        aliases[3] = [2, 2, 3, 7, 0, 0, 1, 1];\r\n        // armor\r\n        rarities[4] = [255];\r\n        aliases[4] = [0];\r\n        // offhand\r\n        rarities[5] = [255];\r\n        aliases[5] = [0];\r\n        // mainhand\r\n        rarities[6] = [255];\r\n        aliases[6] = [0];\r\n\r\n        rerollTreatOnly = false;\r\n        // set reroll price\r\n        rerollPriceEth = 0.01 ether;\r\n        rerollPriceZug = 50 ether;\r\n        rerollPrice = [\r\n            6 ether,\r\n            12 ether,\r\n            24 ether,\r\n            48 ether,\r\n            96 ether\r\n        ];\r\n\r\n        // set upgrade level price\r\n        // level 1-20\r\n        upgradeLevelPrice = [\r\n            0 ether,\r\n            12 ether,\r\n            16 ether,\r\n            20 ether,\r\n            24 ether,\r\n            30 ether,\r\n            36 ether,\r\n            42 ether,\r\n            48 ether,\r\n            54 ether,\r\n            62 ether,\r\n            70 ether,\r\n            78 ether,\r\n            86 ether,\r\n            96 ether,\r\n            106 ether,\r\n            116 ether,\r\n            126 ether,\r\n            138 ether,\r\n            150 ether\r\n        ];\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    MODIFIERS \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    modifier noCheaters() {\r\n        uint256 size = 0;\r\n        address acc = msg.sender;\r\n        assembly {\r\n            size := extcodesize(acc)\r\n        }\r\n\r\n        require(\r\n            auth[msg.sender] || (msg.sender == tx.origin && size == 0),\r\n            \"you're trying to cheat!\"\r\n        );\r\n        _;\r\n\r\n        // We'll use the last caller hash to add entropy to next caller\r\n        entropySauce = keccak256(abi.encodePacked(acc, block.coinbase, entropySauce));\r\n    }\r\n\r\n    modifier mintCoolDownPassed(uint256 id) {\r\n        Log memory log_ = mintLogs[id];\r\n        require(\r\n            block.timestamp >= log_.timestamp + mintCooldown,\r\n            \"still in cool down\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isOwnerOfDoge(uint256 id) {\r\n        require(\r\n            ownerOf[id] == msg.sender || activities[id].owner == msg.sender,\r\n            \"not your doge\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier ownerOfDoge(uint256 id, address who_) { \r\n        require(ownerOf[id] == who_ || activities[id].owner == who_, \"not your doge\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier genesisMinting(uint8 amount) {\r\n        require(totalSupply + amount <= GENESIS_SUPPLY, \"genesis all minted\");\r\n        _;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    PUBLIC FUNCTIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mintReserved(address to, uint8 amount) public genesisMinting(amount) onlyOwner {\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(to);\r\n        }\r\n    }\r\n\r\n    function mintOG(address to, uint8 amount) public genesisMinting(amount) noCheaters {\r\n        require(amount <= ogWhitelist[msg.sender], \"Exceeds amount\");\r\n\r\n        ogWhitelist[msg.sender] = ogWhitelist[msg.sender] - amount;\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(to);\r\n        }\r\n    }\r\n\r\n    function presaleMintWithEth(uint8 amount) public payable genesisMinting(amount) noCheaters {\r\n        require(presaleActive, \"Presale must be active to mint\");\r\n        require(amount <= whitelist[msg.sender], \"Exceeds max amount\");\r\n        require(msg.value >= mintPriceEth * amount, \"Value below price\");\r\n\r\n        whitelist[msg.sender] = whitelist[msg.sender] - amount;\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(msg.sender);\r\n        }\r\n    }\r\n\r\n    function presaleMintWithZug(uint8 amount) public genesisMinting(amount) noCheaters {\r\n        require(presaleActive, \"Presale must be active to mint\");\r\n        require(whitelist[msg.sender] > 0, \"No tokens reserved for this address\");\r\n        require(amount <= whitelist[msg.sender], \"Exceeds max amount\");\r\n        require(zugMintCount+amount <= MAX_ZUG_MINT, \"Exceeds max zug mint\");\r\n\r\n        whitelist[msg.sender] = whitelist[msg.sender] - amount;\r\n\r\n        zug.transferFrom(msg.sender, address(this), mintPriceZug * amount);\r\n        zugMintCount = zugMintCount + amount;\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(msg.sender);\r\n        }\r\n    }\r\n\r\n    function mintWithEth(uint8 amount) public payable genesisMinting(amount) noCheaters {\r\n        require(saleActive, \"Sale must be active to mint\");\r\n        require(amount <= 2, \"Exceeds max amount\");\r\n        require(msg.value >= mintPriceEth * amount, \"Value below price\");\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(msg.sender);\r\n        }\r\n    }\r\n\r\n    function mintWithZug(uint8 amount) public genesisMinting(amount) noCheaters {\r\n        require(saleActive, \"Sale must be active to mint\");\r\n        require(amount <= 2, \"Exceeds max amount\");\r\n        require(zugMintCount+amount <= MAX_ZUG_MINT, \"Exceeds max zug mint\");\r\n        zug.transferFrom(msg.sender, address(this), mintPriceZug * amount);\r\n        zugMintCount = zugMintCount + amount;\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _mintDoge(msg.sender);\r\n        }\r\n    }\r\n\r\n    function recruit(uint256 id) public ownerOfDoge(id, msg.sender) mintCoolDownPassed(id) noCheaters {\r\n        require(totalSupply <= MAX_SUPPLY, \"all supply minted\");\r\n        uint256 cost = _getMintingPrice();\r\n        if (cost > 0) treat.burn(msg.sender, cost);\r\n        mintLogs[id].timestamp = uint88(block.timestamp);\r\n        _mintDoge(msg.sender);\r\n    }\r\n\r\n    function upgradeLevelWithTreat(uint256 id)\r\n        public\r\n        ownerOfDoge(id, msg.sender)\r\n        mintCoolDownPassed(id)\r\n        noCheaters\r\n    {\r\n        _claim(id); // Need to claim to not have equipment reatroactively multiplying\r\n\r\n        uint16 curVal = doges[id].level;\r\n        require(curVal < 20, \"already max level\");\r\n        treat.burn(msg.sender, upgradeLevelPrice[curVal]);\r\n        doges[id].level = curVal + 1;\r\n    }\r\n\r\n    function rerollWithEth(uint256 id, RerollTypes rerollType)\r\n        public\r\n        payable\r\n        ownerOfDoge(id, msg.sender)\r\n        mintCoolDownPassed(id)\r\n        noCheaters\r\n    {\r\n        require(!rerollTreatOnly, \"Only TREAT for reroll\");\r\n        require(msg.value >= rerollPriceEth, \"Value below price\");\r\n\r\n        _reroll(id, rerollType);\r\n    }\r\n\r\n    function rerollWithZug(uint256 id, RerollTypes rerollType)\r\n        public\r\n        ownerOfDoge(id, msg.sender)\r\n        mintCoolDownPassed(id)\r\n        noCheaters\r\n    {\r\n        require(!rerollTreatOnly, \"Only TREAT for reroll\");\r\n        zug.transferFrom(msg.sender, address(this), rerollPriceZug);\r\n        _reroll(id, rerollType);\r\n    }\r\n\r\n    function rerollWithTreat(uint256 id, RerollTypes rerollType)\r\n        public\r\n        ownerOfDoge(id, msg.sender)\r\n        mintCoolDownPassed(id)\r\n        noCheaters\r\n    {\r\n        uint256 price_ = rerollPrice[\r\n            rerollCountHistory[rerollType][id] < 5\r\n                ? rerollCountHistory[rerollType][id]\r\n                : 5\r\n        ];\r\n        treat.burn(msg.sender, price_);\r\n        _reroll(id, rerollType);\r\n    }\r\n\r\n    function _reroll(\r\n        uint256 id,\r\n        RerollTypes rerollType\r\n    ) internal {\r\n        rerollBlocks[id] = block.number;\r\n        uint256 rand_ = _rand();\r\n\r\n        if (rerollType == RerollTypes.BREED) {\r\n            doges[id].breed = uint8(_randomize(rand_, \"BREED\", id)) % uint8(rarities[1].length);\r\n        } else if (rerollType == RerollTypes.CLASS) {\r\n            uint16 randClass = uint16(_randomize(rand_, \"CLASS\", id));\r\n            doges[id].class = selectTrait(randClass, 3);\r\n        }\r\n        rerollCountHistory[rerollType][id]++;\r\n    }\r\n\r\n    /**\r\n    * allows owner to withdraw funds from minting\r\n    */\r\n    function withdraw() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n        zug.transfer(msg.sender, zug.balanceOf(address(this)));\r\n    }\r\n\r\n    function doAction(uint256 id, Actions action_)\r\n        public\r\n        ownerOfDoge(id, msg.sender)\r\n        noCheaters\r\n    {\r\n        _doAction(id, msg.sender, action_, msg.sender);\r\n    }\r\n\r\n    function _doAction(\r\n        uint256 id,\r\n        address dogeOwner,\r\n        Actions action_,\r\n        address who_\r\n    ) internal ownerOfDoge(id, who_) {\r\n        Action memory action = activities[id];\r\n        require(action.action != action_, \"already doing that\");\r\n\r\n        // Picking the largest value between block.timestamp, action.timestamp and startingTime\r\n        uint88 timestamp = uint88(\r\n            block.timestamp > action.timestamp\r\n                ? block.timestamp\r\n                : action.timestamp\r\n        );\r\n\r\n        if (action.action == Actions.UNSTAKED) _transfer(dogeOwner, address(this), id);\r\n        else {\r\n            if (block.timestamp > action.timestamp) _claim(id);\r\n            timestamp = timestamp > action.timestamp ? timestamp : action.timestamp;\r\n        }\r\n\r\n        address owner_ = action_ == Actions.UNSTAKED ? address(0) : dogeOwner;\r\n        if (action_ == Actions.UNSTAKED) _transfer(address(this), dogeOwner, id);\r\n\r\n        activities[id] = Action({\r\n            owner: owner_,\r\n            timestamp: timestamp,\r\n            action: action_\r\n        });\r\n        emit ActionMade(dogeOwner, id, block.timestamp, uint8(action_));\r\n    }\r\n\r\n    function doActionWithManyDoges(uint256[] calldata ids, Actions action_)\r\n        external\r\n    {\r\n        for (uint256 index = 0; index < ids.length; index++) {\r\n            require(\r\n                ownerOf[ids[index]] == msg.sender || activities[ids[index]].owner == msg.sender,\r\n                \"not your doge\"\r\n            );\r\n            _doAction(ids[index], msg.sender, action_, msg.sender);\r\n        }\r\n    }\r\n\r\n    function claim(uint256[] calldata ids) external {\r\n        for (uint256 index = 0; index < ids.length; index++) {\r\n            _claim(ids[index]);\r\n        }\r\n    }\r\n\r\n    function _claim(uint256 id) internal noCheaters {\r\n        Action memory action = activities[id];\r\n\r\n        if (block.timestamp <= action.timestamp) return;\r\n\r\n        uint256 timeDiff = uint256(block.timestamp - action.timestamp);\r\n\r\n        if (action.action == Actions.FARMING)\r\n            treat.mint(\r\n                action.owner,\r\n                claimableTreat(timeDiff, id, action.owner)\r\n            );\r\n\r\n        activities[id].timestamp = uint88(block.timestamp);\r\n    }\r\n\r\n    function pull(address owner_, uint256[] calldata ids) external {\r\n        require (msg.sender == castle, \"not castle\");\r\n        for (uint256 index = 0; index < ids.length; index++) {\r\n            if (activities[ids[index]].action != Actions.UNSTAKED) _doAction(ids[index], owner_, Actions.UNSTAKED, owner_);\r\n            _transfer(owner_, msg.sender, ids[index]);\r\n        }\r\n        CastleLike(msg.sender).pullCallback(owner_, ids);\r\n    }\r\n\r\n    function manuallyAdjustDoge(uint256 id, uint8 head, uint8 breed, uint8 color, uint8 class, uint8 armor, uint8 offhand, uint8 mainhand, uint16 level) external {\r\n        require(msg.sender == admin || auth[msg.sender], \"not authorized\");\r\n        doges[id].head = head;\r\n        doges[id].breed = breed;\r\n        doges[id].color = color;\r\n        doges[id].class = class;\r\n        doges[id].armor = armor;\r\n        doges[id].offhand = offhand;\r\n        doges[id].mainhand = mainhand;\r\n        doges[id].level = level;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    VIEWERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function getTokenTraits(uint256 tokenId) external view returns (Doge memory) {\r\n        if (rerollBlocks[tokenId] == block.number) return doges[0];\r\n        return doges[tokenId];\r\n    }\r\n\r\n    function claimable(uint256 id) external view returns (uint256) {\r\n        if (activities[id].action == Actions.FARMING) {\r\n            uint256 timeDiff = block.timestamp > activities[id].timestamp\r\n                ? uint256(block.timestamp - activities[id].timestamp)\r\n                : 0;\r\n            return claimableTreat(timeDiff, id, activities[id].owner);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    function getGenesisSupply() external pure returns (uint256) {\r\n        return GENESIS_SUPPLY;\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        return \"Doges\";\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return \"Doges\";\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    MINT FUNCTION\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mintDoge(address to) internal {\r\n        uint16 id = uint16(totalSupply + 1);\r\n        rerollBlocks[id] = block.number;\r\n        uint256 seed = random(id);\r\n        generate(id, seed);\r\n        _mint(to, id);\r\n        mintLogs[id] = Log({\r\n            owner: to,\r\n            timestamp: uint88(block.timestamp)\r\n        });\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    INTERNAL  HELPERS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function claimableTreat(uint256 timeDiff, uint256 id, address owner_)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Doge memory doge = doges[id];\r\n        uint256 rand_ = _rand();\r\n\r\n        uint256 treatAmount = (timeDiff * 1 ether) / 1 days;\r\n        if (doge.class == 0) { // Warrior\r\n            uint16 randPlus = uint16(_randomize(rand_, \"Warrior1\", id));\r\n            if (randPlus < fifteenPct) return treatAmount * 115 / 100;\r\n\r\n            randPlus = uint16(_randomize(rand_, \"Warrior2\", id));\r\n            if (randPlus < fifteenPct) return treatAmount * 85 / 100;\r\n            return treatAmount;\r\n        } else if(doge.class == 1) { // Rogue\r\n            uint16 randPlus = uint16(_randomize(rand_, \"Rogue\", id));\r\n            if (randPlus < tenPct) return treatAmount * 3;\r\n            return treatAmount;\r\n        } else if(doge.class == 2) { // Mage\r\n            uint16 randPlus = uint16(_randomize(rand_, \"Mage\", id));\r\n            if (randPlus < fiftyPct) return treatAmount * 5 / 10;\r\n            return treatAmount * 2;\r\n        } else if(doge.class == 3) { // Hunter\r\n            return treatAmount * 125 / 100;\r\n        } else if(doge.class == 4) { // Cleric\r\n            return treatAmount;\r\n        } else if(doge.class == 5) { // Bard\r\n            uint256 balance = balanceOf[owner_];\r\n            uint256 boost = 10 + (balance > 10 ? 10 : balance);\r\n            return treatAmount * boost / 10;\r\n        } else if(doge.class == 6) { // Merchant\r\n            return treatAmount * (8 + (rand_ % 6)) / 10;\r\n        } else if(doge.class == 7) { // Forager\r\n            return treatAmount * (3 + doge.level) / 3;\r\n        }\r\n        \r\n        return treatAmount;\r\n    }\r\n\r\n    /**\r\n    * generates traits for a specific token, checking to make sure it's unique\r\n    * @param tokenId the id of the token to generate traits for\r\n    * @param seed a pseudorandom 256 bit number to derive traits from\r\n    * @return t - a struct of traits for the given token ID\r\n    */\r\n    function generate(uint256 tokenId, uint256 seed) internal returns (Doge memory t) {\r\n        t = selectTraits(seed);\r\n        doges[tokenId] = t;\r\n        return t;\r\n\r\n        // keep the following code for future use, current version using different seed, so no need for now\r\n        // if (existingCombinations[structToHash(t)] == 0) {\r\n        //     doges[tokenId] = t;\r\n        //     existingCombinations[structToHash(t)] = tokenId;\r\n        //     return t;\r\n        // }\r\n        // return generate(tokenId, random(seed));\r\n    }\r\n\r\n    /**\r\n    * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\r\n    * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\r\n    * probability & alias tables are generated off-chain beforehand\r\n    * @param seed portion of the 256 bit seed to remove trait correlation\r\n    * @param traitType the trait type to select a trait for \r\n    * @return the ID of the randomly selected trait\r\n    */\r\n    function selectTrait(uint16 seed, uint8 traitType) internal view returns (uint8) {\r\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\r\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\r\n        return aliases[traitType][trait];\r\n    }\r\n\r\n    /**\r\n    * selects the species and all of its traits based on the seed value\r\n    * @param seed a pseudorandom 256 bit number to derive traits from\r\n    * @return t -  a struct of randomly selected traits\r\n    */\r\n    function selectTraits(uint256 seed) internal view returns (Doge memory t) {    \r\n        t.head = selectTrait(uint16(seed & 0xFFFF), 0);\r\n        seed >>= 16;\r\n        t.breed = selectTrait(uint16(seed & 0xFFFF), 1);\r\n        seed >>= 16;\r\n        t.color = selectTrait(uint16(seed & 0xFFFF), 2);\r\n        seed >>= 16;\r\n        t.class = selectTrait(uint16(seed & 0xFFFF), 3);\r\n        seed >>= 16;\r\n        t.armor = selectTrait(uint16(seed & 0xFFFF), 4);\r\n        seed >>= 16;\r\n        t.offhand = selectTrait(uint16(seed & 0xFFFF), 5);\r\n        seed >>= 16;\r\n        t.mainhand = selectTrait(uint16(seed & 0xFFFF), 6);\r\n        t.level = 1;\r\n    }\r\n\r\n    /**\r\n    * converts a struct to a 256 bit hash to check for uniqueness\r\n    * @param s the struct to pack into a hash\r\n    * @return the 256 bit hash of the struct\r\n    */\r\n    function structToHash(Doge memory s) internal pure returns (uint256) {\r\n        return uint256(bytes32(\r\n        abi.encodePacked(\r\n            s.head,\r\n            s.breed,\r\n            s.color,\r\n            s.class,\r\n            s.armor,\r\n            s.offhand,\r\n            s.mainhand,\r\n            s.level\r\n        )\r\n        ));\r\n    }\r\n\r\n    /// @dev Create a bit more of randomness\r\n    function _randomize(\r\n        uint256 rand,\r\n        string memory val,\r\n        uint256 spicy\r\n    ) internal pure returns (uint256) {\r\n        return uint256(keccak256(abi.encode(rand, val, spicy)));\r\n    }\r\n\r\n    function _rand() internal view returns (uint256) {\r\n        return\r\n            uint256(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        tx.origin,\r\n                        blockhash(block.number - 1),\r\n                        block.timestamp,\r\n                        entropySauce\r\n                    )\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n    * generates a pseudorandom number\r\n    * @param seed a value ensure different outcomes for different sources in the same block\r\n    * @return a pseudorandom value\r\n    */\r\n    function random(uint256 seed) internal view returns (uint256) {\r\n        return uint256(keccak256(abi.encodePacked(\r\n            tx.origin,\r\n            blockhash(block.number - 1),\r\n            block.timestamp,\r\n            seed\r\n        )));\r\n    }\r\n\r\n    function _getMintingPrice() internal view returns (uint256) {\r\n        uint256 supply = totalSupply;\r\n        if (supply < 2500) return 0;\r\n        if (supply < 3000) return 4 ether;\r\n        if (supply < 4600) return 25 ether;\r\n        if (supply < 5000) return 85 ether;\r\n        return 85 ether;\r\n    }\r\n\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                    FALLBACK HANDLER \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n\r\n    function _delegate(address implementation) internal virtual {\r\n        assembly {\r\n            // Copy msg.data. We take full control of memory in this inline assembly\r\n            // block because it will not return to Solidity code. We overwrite the\r\n            // Solidity scratch pad at memory position 0.\r\n            calldatacopy(0, 0, calldatasize())\r\n\r\n            // Call the implementation.\r\n            // out and outsize are 0 because we don't know the size yet.\r\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\r\n\r\n            // Copy the returned data.\r\n            returndatacopy(0, 0, returndatasize())\r\n\r\n            switch result\r\n            // delegatecall returns 0 on error.\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n    \r\n\r\n    fallback() external {\r\n        if(implementer[msg.sig] == address(0)) {\r\n            _delegate(impl);\r\n        } else {\r\n            _delegate(implementer[msg.sig]);\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"activity\",\"type\":\"uint8\"}],\"name\":\"ActionMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"GENESIS_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_ZUG_MINT\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activities\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"timestamp\",\"type\":\"uint88\"},{\"internalType\":\"enum Dogewood.Actions\",\"name\":\"action\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"castle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum Dogewood.Actions\",\"name\":\"action_\",\"type\":\"uint8\"}],\"name\":\"doAction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"enum Dogewood.Actions\",\"name\":\"action_\",\"type\":\"uint8\"}],\"name\":\"doActionWithManyDoges\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wlAddresses\",\"type\":\"address[]\"}],\"name\":\"editOGWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wlAddresses\",\"type\":\"address[]\"}],\"name\":\"editWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGenesisSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraits\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"breed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"class\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"armor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offhand\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mainhand\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"level\",\"type\":\"uint16\"}],\"internalType\":\"struct Dogewood.Doge\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"head\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"breed\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"color\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"class\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"armor\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"offhand\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"mainhand\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"level\",\"type\":\"uint16\"}],\"name\":\"manuallyAdjustDoge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintLogs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint88\",\"name\":\"timestamp\",\"type\":\"uint88\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"mintOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPriceEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPriceZug\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"mintReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"mintWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"mintWithZug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ogWhitelist\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"presaleMintWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"amount\",\"type\":\"uint8\"}],\"name\":\"presaleMintWithZug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"pull\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"recruit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rerollBlocks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum Dogewood.RerollTypes\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rerollCountHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rerollPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rerollPriceEth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rerollPriceZug\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rerollTreatOnly\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum Dogewood.RerollTypes\",\"name\":\"rerollType\",\"type\":\"uint8\"}],\"name\":\"rerollWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum Dogewood.RerollTypes\",\"name\":\"rerollType\",\"type\":\"uint8\"}],\"name\":\"rerollWithTreat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"enum Dogewood.RerollTypes\",\"name\":\"rerollType\",\"type\":\"uint8\"}],\"name\":\"rerollWithZug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_zug\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_castle\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"add\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isAuth\",\"type\":\"bool\"}],\"name\":\"setAuth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"c_\",\"type\":\"address\"}],\"name\":\"setCastle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"funcs\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"}],\"name\":\"setImplementer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mintPriceEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintPriceZug\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setPresaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rerollPriceEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rerollPriceZug\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_rerollPriceTreat\",\"type\":\"uint256[]\"}],\"name\":\"setRerollPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_rerollTreatOnly\",\"type\":\"bool\"}],\"name\":\"setRerollTreatOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setSaleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t_\",\"type\":\"address\"}],\"name\":\"setTraits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t_\",\"type\":\"address\"}],\"name\":\"setTreat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_upgradeLevelPrice\",\"type\":\"uint256[]\"}],\"name\":\"setUpgradeLevelPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"z_\",\"type\":\"address\"}],\"name\":\"setZug\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"supported\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"contract ITraits\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treat\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"upgradeLevelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"upgradeLevelWithTreat\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zug\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"zugMintCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Dogewood", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2dce70d0c946245669961fb9f871e7cde9248da6e37754b124ca3eb02145be72"}]}