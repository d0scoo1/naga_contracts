{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ShellFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/*\\n                   ShellFactory V1\\n\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2557\\n        \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2551\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551     \u2588\u2588\u2551\\n        \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551     \u2588\u2588\u2551\\n        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\\n        \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\\n\\n           An open product framework for NFTs\\n            Dreamt up & built at Playgrounds\\n\\n               https://heyshell.xyz\\n              https://playgrounds.wtf\\n\\n*/\\n\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./libraries/Ownable.sol\\\";\\nimport \\\"./IShellFactory.sol\\\";\\n\\ncontract ShellFactory is IShellFactory, Ownable {\\n    mapping(string => IShellFramework) public implementations;\\n\\n    constructor() {\\n        _transferOwnership(msg.sender);\\n    }\\n\\n    function registerImplementation(\\n        string calldata name,\\n        IShellFramework implementation\\n    ) external onlyOwner {\\n        if (implementations[name] != IShellFramework(address(0))) {\\n            revert ImplementationExists();\\n        }\\n\\n        bool isValid = implementation.supportsInterface(\\n            type(IShellFramework).interfaceId\\n        );\\n        if (!isValid) {\\n            revert InvalidImplementation();\\n        }\\n\\n        implementations[name] = implementation;\\n        emit ImplementationRegistered(name, implementation);\\n    }\\n\\n    function createCollection(\\n        string calldata name,\\n        string calldata symbol,\\n        string calldata implementationName,\\n        IEngine engine,\\n        address owner\\n    ) external returns (IShellFramework) {\\n        IShellFramework implementation = implementations[implementationName];\\n        if (implementation == IShellFramework(address(0))) {\\n            revert ImplementationNotFound();\\n        }\\n\\n        IShellFramework clone = IShellFramework(\\n            Clones.clone(address(implementation))\\n        );\\n        clone.initialize(name, symbol, engine, owner);\\n        emit CollectionCreated(clone, implementation);\\n\\n        return clone;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOwnable.sol\\\";\\n\\n/*\\n\\n    copy pasted from\\n\\n    https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\\n\\n    with some changes:\\n    - dont use _msgSender()\\n    - dont auto-init msg.sender as owner in constructor\\n\\n*/\\n\\ncontract Ownable is IOwnable {\\n    address private _owner;\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not owner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: transfer to zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IShellFactory.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libraries/IOwnable.sol\\\";\\nimport \\\"./IShellFramework.sol\\\";\\n\\n// Factory that deploys new collections on the shell platform\\ninterface IShellFactory is IOwnable {\\n    // an implementation with a specific name already exists\\n    error ImplementationExists();\\n\\n    // an implementation being added did not support IShellFramework\\n    error InvalidImplementation();\\n\\n    // an implementation with a specific name was not found\\n    error ImplementationNotFound();\\n\\n    // new contract implementation added\\n    event ImplementationRegistered(string name, IShellFramework implementation);\\n\\n    // new clone launched\\n    event CollectionCreated(\\n        IShellFramework collection,\\n        IShellFramework implementation\\n    );\\n\\n    // register a new collection implementation\\n    function registerImplementation(\\n        string calldata name,\\n        IShellFramework implementation\\n    ) external;\\n\\n    // deploy a new (cloned) collection\\n    function createCollection(\\n        string calldata name,\\n        string calldata symbol,\\n        string calldata implementationName,\\n        IEngine engine,\\n        address owner\\n    ) external returns (IShellFramework);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/IOwnable.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// (semi) standard ownable interface\\ninterface IOwnable {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function owner() external view returns (address);\\n\\n    function renounceOwnership() external;\\n\\n    function transferOwnership(address newOwner) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IShellFramework.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\nimport \\\"./libraries/IOwnable.sol\\\";\\nimport \\\"./IEngine.sol\\\";\\n\\n// storage flag\\nenum StorageLocation {\\n    INVALID,\\n    // set by the engine at any time, mutable\\n    ENGINE,\\n    // set by the engine during minting, immutable\\n    MINT_DATA,\\n    // set by the framework during minting or collection creation, immutable\\n    FRAMEWORK\\n}\\n\\n// string key / value\\nstruct StringStorage {\\n    string key;\\n    string value;\\n}\\n\\n// int key / value\\nstruct IntStorage {\\n    string key;\\n    uint256 value;\\n}\\n\\n// data provided when minting a new token\\nstruct MintEntry {\\n    address to;\\n    uint256 amount;\\n    MintOptions options;\\n}\\n\\n// Data provided by engine when minting a new token\\nstruct MintOptions {\\n    bool storeEngine;\\n    bool storeMintedTo;\\n    bool storeTimestamp;\\n    bool storeBlockNumber;\\n    StringStorage[] stringData;\\n    IntStorage[] intData;\\n}\\n\\n// Information about a fork\\nstruct Fork {\\n    IEngine engine;\\n    address owner;\\n}\\n\\n// Interface for every collection launched by shell.\\n// Concrete implementations must return true on ERC165 checks for this interface\\n// (as well as erc165 / 2981)\\n// interfaceId = TBD\\ninterface IShellFramework is IERC165, IERC2981 {\\n    // ---\\n    // Framework errors\\n    // ---\\n\\n    // an engine was provided that did no pass the expected erc165 checks\\n    error InvalidEngine();\\n\\n    // a write was attempted that is not allowed\\n    error WriteNotAllowed();\\n\\n    // an operation was attempted but msg.sender was not the expected engine\\n    error SenderNotEngine();\\n\\n    // an operation was attempted but msg.sender was not the fork owner\\n    error SenderNotForkOwner();\\n\\n    // a token fork was attempted by an invalid msg.sender\\n    error SenderCannotFork();\\n\\n    // ---\\n    // Framework events\\n    // ---\\n\\n    // a fork was created\\n    event ForkCreated(uint256 forkId, IEngine engine, address owner);\\n\\n    // a fork had a new engine installed\\n    event ForkEngineUpdated(uint256 forkId, IEngine engine);\\n\\n    // a fork had a new owner set\\n    event ForkOwnerUpdated(uint256 forkId, address owner);\\n\\n    // a token has been set to a new fork\\n    event TokenForkUpdated(uint256 tokenId, uint256 forkId);\\n\\n    // ---\\n    // Storage events\\n    // ---\\n\\n    // A fork string was stored\\n    event ForkStringUpdated(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string key,\\n        string value\\n    );\\n\\n    // A fork int was stored\\n    event ForkIntUpdated(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string key,\\n        uint256 value\\n    );\\n\\n    // A token string was stored\\n    event TokenStringUpdated(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string key,\\n        string value\\n    );\\n\\n    // A token int was stored\\n    event TokenIntUpdated(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string key,\\n        uint256 value\\n    );\\n\\n    // ---\\n    // Collection base\\n    // ---\\n\\n    // called immediately after cloning\\n    function initialize(\\n        string calldata name,\\n        string calldata symbol,\\n        IEngine engine,\\n        address owner\\n    ) external;\\n\\n    // ---\\n    // General collection info / metadata\\n    // ---\\n\\n    // collection owner (fork 0 owner)\\n    function owner() external view returns (address);\\n\\n    // collection name\\n    function name() external view returns (string memory);\\n\\n    // collection name\\n    function symbol() external view returns (string memory);\\n\\n    // next token id serial number\\n    function nextTokenId() external view returns (uint256);\\n\\n    // next fork id serial number\\n    function nextForkId() external view returns (uint256);\\n\\n    // ---\\n    // Fork functionality\\n    // ---\\n\\n    // Create a new fork with a specific engine, fork all the tokenIds to the\\n    // new engine, and return the fork ID\\n    function createFork(\\n        IEngine engine,\\n        address owner,\\n        uint256[] calldata tokenIds\\n    ) external returns (uint256);\\n\\n    // Set the engine for a specific fork. Must be fork owner\\n    function setForkEngine(uint256 forkId, IEngine engine) external;\\n\\n    // Set the fork owner. Must be fork owner\\n    function setForkOwner(uint256 forkId, address owner) external;\\n\\n    // Set the fork of a specific token. Must be token owner\\n    function setTokenFork(uint256 tokenId, uint256 forkId) external;\\n\\n    // Set the fork for several tokens. Must own all tokens\\n    function setTokenForks(uint256[] memory tokenIds, uint256 forkId) external;\\n\\n    // ---\\n    // Fork views\\n    // ---\\n\\n    // Get information about a fork\\n    function getFork(uint256 forkId) external view returns (Fork memory);\\n\\n    // Get the collection / canonical engine. getFork(0).engine\\n    function getForkEngine(uint256 forkId) external view returns (IEngine);\\n\\n    // Get a token's fork ID\\n    function getTokenForkId(uint256 tokenId) external view returns (uint256);\\n\\n    // Get a token's engine. getFork(getTokenForkId(tokenId)).engine\\n    function getTokenEngine(uint256 tokenId) external view returns (IEngine);\\n\\n    // Determine if a given msg.sender can fork a token\\n    function canSenderForkToken(address sender, uint256 tokenId)\\n        external\\n        view\\n        returns (bool);\\n\\n    // ---\\n    // Engine functionality\\n    // ---\\n\\n    // mint new tokens. Only callable by collection engine\\n    function mint(MintEntry calldata entry) external returns (uint256);\\n\\n    // mint new tokens. Only callable by collection engine\\n    function batchMint(MintEntry[] calldata entries)\\n        external\\n        returns (uint256[] memory);\\n\\n    // ---\\n    // Storage writes\\n    // ---\\n\\n    // Write a string to collection storage. Only callable by collection engine\\n    function writeForkString(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string calldata key,\\n        string calldata value\\n    ) external;\\n\\n    // Write a string to collection storage. Only callable by collection engine\\n    function writeForkInt(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string calldata key,\\n        uint256 value\\n    ) external;\\n\\n    // Write a string to token storage. Only callable by token engine\\n    function writeTokenString(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string calldata key,\\n        string calldata value\\n    ) external;\\n\\n    // Write a string to token storage. Only callable by token engine\\n    function writeTokenInt(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string calldata key,\\n        uint256 value\\n    ) external;\\n\\n    // ---\\n    // Storage reads\\n    // ---\\n\\n    // Read a string from collection storage\\n    function readForkString(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string calldata key\\n    ) external view returns (string memory);\\n\\n    // Read a uint256 from collection storage\\n    function readForkInt(\\n        StorageLocation location,\\n        uint256 forkId,\\n        string calldata key\\n    ) external view returns (uint256);\\n\\n    // Read a string from token storage\\n    function readTokenString(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string calldata key\\n    ) external view returns (string memory);\\n\\n    // Read a uint256 from token storage\\n    function readTokenInt(\\n        StorageLocation location,\\n        uint256 tokenId,\\n        string calldata key\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Called with the sale price to determine how much royalty is owed and to whom.\\n     * @param tokenId - the NFT asset queried for royalty information\\n     * @param salePrice - the sale price of the NFT asset specified by `tokenId`\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for `salePrice`\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"contracts/IEngine.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./IShellFramework.sol\\\";\\n\\n// Required interface for framework engines\\n// interfaceId = 0x0b1d171c\\ninterface IEngine is IERC165 {\\n    // Get the name for this engine\\n    function name() external pure returns (string memory);\\n\\n    // Called by the framework to resolve a response for tokenURI method\\n    function getTokenURI(IShellFramework collection, uint256 tokenId)\\n        external\\n        view\\n        returns (string memory);\\n\\n    // Called by the framework to resolve a response for royaltyInfo method\\n    function getRoyaltyInfo(\\n        IShellFramework collection,\\n        uint256 tokenId,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n\\n    // Called by the framework during a transfer, including mints (from=0) and\\n    // burns (to=0). Cannot break transfer even in the case of reverting, as the\\n    // collection will wrap the downstream call in a try/catch\\n    // collection = msg.sender\\n    function beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external;\\n\\n    // Called by the framework whenever an engine is set on a fork, including\\n    // the collection (fork id = 0). Can be used by engine developers to prevent\\n    // an engine from being installed in a collection or non-canonical fork if\\n    // desired\\n    // collection = msg.sender\\n    function afterEngineSet(uint256 forkId) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ImplementationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ImplementationNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidImplementation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IShellFramework\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IShellFramework\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"CollectionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"contract IShellFramework\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"ImplementationRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"implementationName\",\"type\":\"string\"},{\"internalType\":\"contract IEngine\",\"name\":\"engine\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"createCollection\",\"outputs\":[{\"internalType\":\"contract IShellFramework\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"implementations\",\"outputs\":[{\"internalType\":\"contract IShellFramework\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"contract IShellFramework\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"registerImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ShellFactory", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}