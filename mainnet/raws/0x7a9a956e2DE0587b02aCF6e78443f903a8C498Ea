{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.11;\r\n\r\n// Part: IDiamondCut\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {\r\n        Add,\r\n        Replace,\r\n        Remove\r\n    }\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n// Part: IERC173\r\n\r\ninterface IERC173 {\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    \r\n);\r\n\r\n    function owner() external view returns (address owner_);\r\n\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\n// Part: LibDiamond\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION =\r\n        keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct DiamondStorage {\r\n        mapping(bytes4 => bytes32) facets;\r\n        mapping(uint256 => bytes32) selectorSlots;\r\n        uint16 selectorCount;\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        address contractOwner;\r\n        mapping(address => bool) isOwner;\r\n    }\r\n\r\n    function diamondStorage()\r\n        internal\r\n        pure\r\n        returns (DiamondStorage storage ds)\r\n    {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(\r\n \r\n           msg.sender == diamondStorage().contractOwner,\r\n            \"Must be contract owner\"\r\n        );\r\n    }\r\n\r\n    event DiamondCut(\r\n        IDiamondCut.FacetCut[] _diamondCut,\r\n        address _init,\r\n        bytes _calldata\r\n    \r\n);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK =\r\n        bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        uint256 originalSelectorCount = ds.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        if (selectorCount & 7 > 0) {\r\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (\r\n            uint256 facetIndex;\r\n            facetIndex < _diamondCut.length;\r\n            facetIndex++\r\n        ) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            ds.selectorCount = uint16(selectorCount);\r\n        }\r\n        if (selectorCount & 7 > 0) {\r\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_selectors.length > 0, \"No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"Add facet has no code\");\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n \r\n               selectorIndex++\r\n            ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = ds.facets[selector];\r\n                require(\r\n                    address(bytes20(oldFacet)) == address(0),\r\n                    \"Can't add function that already exists\"\r\n                );\r\n                ds.facets[selector] =\r\n                    bytes20(_newFacetAddress) |\r\n                    bytes32(_selectorCount);\r\n     \r\n           uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                _selectorSlot =\r\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\t(bytes32(selector) >> selectorInSlotPosition);\r\n                if (selectorInSlotPosition == 224) {\r\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n   \r\n             _selectorCount++;\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(\r\n                _newFacetAddress,\r\n                \"Replace facet has no code\"\r\n     \r\n       );\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n      \r\n          bytes32 oldFacet = ds.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                require(\r\n                    oldFacetAddress != address(this),\r\n                    \"Can't replace immutable function\"\r\n                );\r\n                require(\r\n                    oldFacetAddress != _newFacetAddress,\r\n                    \"Can't replace function with same function\"\r\n                );\r\n                require(\r\n  \r\n                  oldFacetAddress != address(0),\r\n                    \"Can't replace function that doesn't exist\"\r\n                );\r\n                ds.facets[selector] =\r\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\r\n\r\n           bytes20(_newFacetAddress);\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(\r\n                _newFacetAddress == address(0),\r\n                \"Remove facet address must be address(0)\"\r\n            );\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (\r\n                uint256 selectorIndex;\r\n                selectorIndex < _selectors.length;\r\n                selectorIndex++\r\n            ) {\r\n                if (_selectorSlot == 0) {\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\r\n     \r\n               selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = ds.facets[selector];\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(0),\r\n                        \"Can't remove function that doesn't exist\"\r\n                    );\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(this),\r\n\r\n\t\t\t\t\t\t\"Can't remove immutable function\"\r\n                    );\r\n                    lastSelector = bytes4(\r\n                        _selectorSlot << (selectorInSlotIndex << 5)\r\n                    );\r\n                    if (lastSelector != selector) {\r\n                        ds.facets[lastSelector] =\r\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\r\n                            bytes20(ds.facets[lastSelector]);\r\n                    }\r\n\r\n\t\t\t\t\tdelete ds.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\r\n                        oldSelectorsSlotCount\r\n                    ];\r\n        \r\n\t\t\t\t\toldSelectorSlot =\r\n                        (oldSelectorSlot &\r\n                            ~(CLEAR_SELECTOR_MASK >>\r\n                                oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >>  oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete ds.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n\t\t\trevert(\"Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata)\r\n        internal\r\n    {\r\n        if (_init == address(0)) {\r\n            require(\r\n                _calldata.length == 0,\r\n                \"_init is address(0) but_calldata is not empty\"\r\n            );\r\n        } else {\r\n            require(\r\n                _calldata.length > 0,\r\n\t\t\t\t\"_calldata is empty but _init is not address(0)\"\r\n            );\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"_init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (!success) {\r\n                if (error.length > 0) {\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"_init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(\r\n        address _contract,\r\n        string memory _errorMessage\r\n    ) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n\r\n// File: OwnershipFacet.sol\r\n\r\ncontract OwnershipFacet is IERC173 {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external view override returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OwnershipFacet", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2ce3dbc126c63ad94012c00106ca7e197d56f2242c93238e94ee9ba36f2a3072"}]}