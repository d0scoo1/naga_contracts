{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/TwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './interfaces/ITwapOracle.sol';\\nimport './interfaces/IERC20.sol';\\nimport './libraries/SafeMath.sol';\\nimport '@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol';\\n\\ncontract TwapOracle is ITwapOracle {\\n    using SafeMath for uint256;\\n    using SafeMath for int256;\\n    uint8 public immutable override xDecimals;\\n    uint8 public immutable override yDecimals;\\n    int256 public immutable override decimalsConverter;\\n    address public override owner;\\n    address public override uniswapPair;\\n\\n    constructor(uint8 _xDecimals, uint8 _yDecimals) {\\n        require(_xDecimals <= 75 && _yDecimals <= 75, 'TO4F');\\n        if (_yDecimals > _xDecimals) {\\n            require(_yDecimals - _xDecimals <= 18, 'TO47');\\n        } else {\\n            require(_xDecimals - _yDecimals <= 18, 'TO47');\\n        }\\n        owner = msg.sender;\\n        xDecimals = _xDecimals;\\n        yDecimals = _yDecimals;\\n        decimalsConverter = (10**(18 + _xDecimals - _yDecimals)).toInt256();\\n\\n        emit OwnerSet(msg.sender);\\n    }\\n\\n    function isContract(address addr) private view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'TO00');\\n        require(_owner != address(0), 'TO02');\\n        require(_owner != owner, 'TO01');\\n        owner = _owner;\\n        emit OwnerSet(_owner);\\n    }\\n\\n    function setUniswapPair(address _uniswapPair) external override {\\n        require(msg.sender == owner, 'TO00');\\n        require(_uniswapPair != uniswapPair, 'TO01');\\n        require(_uniswapPair != address(0), 'TO02');\\n        require(isContract(_uniswapPair), 'TO0B');\\n        uniswapPair = _uniswapPair;\\n\\n        IUniswapV2Pair pairContract = IUniswapV2Pair(_uniswapPair);\\n        require(\\n            IERC20(pairContract.token0()).decimals() == xDecimals &&\\n                IERC20(pairContract.token1()).decimals() == yDecimals,\\n            'TO45'\\n        );\\n\\n        (uint112 reserve0, uint112 reserve1, ) = pairContract.getReserves();\\n        require(reserve0 != 0 && reserve1 != 0, 'TO1F');\\n        emit UniswapPairSet(_uniswapPair);\\n    }\\n\\n    // based on: https://github.com/Uniswap/v2-periphery/blob/master/contracts/libraries/UniswapV2OracleLibrary.sol\\n    function getPriceInfo() public view override returns (uint256 priceAccumulator, uint32 priceTimestamp) {\\n        IUniswapV2Pair pair = IUniswapV2Pair(uniswapPair);\\n        priceAccumulator = pair.price0CumulativeLast();\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = pair.getReserves();\\n\\n        // uint32 can be cast directly until Sun, 07 Feb 2106 06:28:15 GMT\\n        priceTimestamp = uint32(block.timestamp);\\n        if (blockTimestampLast != priceTimestamp) {\\n            // allow overflow to stay consistent with Uniswap code and save some gas\\n            uint32 timeElapsed = priceTimestamp - blockTimestampLast;\\n            priceAccumulator += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n        }\\n    }\\n\\n    function decodePriceInfo(bytes memory data) internal pure returns (uint256 price) {\\n        assembly {\\n            price := mload(add(data, 32))\\n        }\\n    }\\n\\n    function getSpotPrice() external view override returns (uint256) {\\n        (uint112 reserve0, uint112 reserve1, ) = IUniswapV2Pair(uniswapPair).getReserves();\\n        return uint256(reserve1).mul(uint256(decimalsConverter)).div(uint256(reserve0));\\n    }\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) public view override returns (uint256) {\\n        (uint256 currentPriceAccumulator, uint32 currentPriceTimestamp) = getPriceInfo();\\n\\n        require(priceTimestamp < currentPriceTimestamp, 'TO20');\\n\\n        // timeElapsed = currentPriceTimestamp - priceTimestamp (overflow is desired)\\n        // averagePrice = (currentPriceAccumulator - priceAccumulator) / timeElapsed\\n        // return value = (averagePrice * decimalsConverter) / 2**112\\n        return\\n            ((currentPriceAccumulator - priceAccumulator) / (currentPriceTimestamp - priceTimestamp)).mul(\\n                uint256(decimalsConverter)\\n            ) >> 112;\\n    }\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256 yAfter) {\\n        int256 xAfterInt = xAfter.toInt256();\\n        int256 xBeforeInt = xBefore.toInt256();\\n        int256 yBeforeInt = yBefore.toInt256();\\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\\n\\n        int256 yTradedInt = xAfterInt.sub(xBeforeInt).mul(averagePriceInt);\\n\\n        // yAfter = yBefore - yTraded = yBefore - ((xAfter - xBefore) * price)\\n        // we are multiplying yBefore by decimalsConverter to push division to the very end\\n        int256 yAfterInt = yBeforeInt.mul(decimalsConverter).sub(yTradedInt).div(decimalsConverter);\\n        require(yAfterInt >= 0, 'TO27');\\n        yAfter = uint256(yAfterInt);\\n    }\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256 xAfter) {\\n        int256 yAfterInt = yAfter.toInt256();\\n        int256 xBeforeInt = xBefore.toInt256();\\n        int256 yBeforeInt = yBefore.toInt256();\\n        int256 averagePriceInt = decodePriceInfo(data).toInt256();\\n\\n        int256 xTradedInt = yAfterInt.sub(yBeforeInt).mul(decimalsConverter);\\n\\n        // xAfter = xBefore - xTraded = xBefore - ((yAfter - yBefore) * price)\\n        // we are multiplying xBefore by averagePriceInt to push division to the very end\\n        int256 xAfterInt = xBeforeInt.mul(averagePriceInt).sub(xTradedInt).div(averagePriceInt);\\n        require(xAfterInt >= 0, 'TO28');\\n\\n        xAfter = uint256(xAfterInt);\\n    }\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256) {\\n        if (xBefore == 0 || yBefore == 0) {\\n            return 0;\\n        }\\n\\n        // ratio after swap = ratio after second mint\\n        // (xBefore + xIn) / (yBefore - xIn * price) = (xBefore + xLeft) / yBefore\\n        // xIn = xLeft * yBefore / (price * (xLeft + xBefore) + yBefore)\\n        uint256 price = decodePriceInfo(data);\\n        uint256 numerator = xLeft.mul(yBefore);\\n        uint256 denominator = price.mul(xLeft.add(xBefore)).add(yBefore.mul(uint256(decimalsConverter)));\\n        uint256 xIn = numerator.mul(uint256(decimalsConverter)).div(denominator);\\n\\n        // Don't swap when numbers are too large. This should actually never happen.\\n        if (xIn.mul(price).div(uint256(decimalsConverter)) >= yBefore || xIn >= xLeft) {\\n            return 0;\\n        }\\n\\n        return xIn;\\n    }\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view override returns (uint256) {\\n        if (xBefore == 0 || yBefore == 0) {\\n            return 0;\\n        }\\n\\n        // ratio after swap = ratio after second mint\\n        // (xBefore - yIn / price) / (yBefore + yIn) = xBefore / (yBefore + yLeft)\\n        // yIn = price * xBefore * yLeft / (price * xBefore + yLeft + yBefore)\\n        uint256 price = decodePriceInfo(data);\\n        uint256 numerator = price.mul(xBefore).mul(yLeft);\\n        uint256 denominator = price.mul(xBefore).add(yLeft.add(yBefore).mul(uint256(decimalsConverter)));\\n        uint256 yIn = numerator.div(denominator);\\n\\n        // Don't swap when numbers are too large. This should actually never happen.\\n        if (yIn.mul(uint256(decimalsConverter)).div(price) >= xBefore || yIn >= yLeft) {\\n            return 0;\\n        }\\n\\n        return yIn;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface ITwapOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n\\n    function decimalsConverter() external view returns (int256);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function owner() external view returns (address);\\n\\n    function uniswapPair() external view returns (address);\\n\\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);\\n\\n    function getSpotPrice() external view returns (uint256);\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setUniswapPair(address _uniswapPair) external;\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xAfter);\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xIn);\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yIn);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (c == mul(a, b)) {\\n            return c;\\n        } else {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n\\n        return c;\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        int256 c = a * b;\\n        require(c / a == b, 'SM29');\\n\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\nimport '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';\\nimport '@uniswap/lib/contracts/libraries/FixedPoint.sol';\\n\\n// library with helper methods for oracles that are concerned with computing average prices\\nlibrary UniswapV2OracleLibrary {\\n    using FixedPoint for *;\\n\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\n    function currentBlockTimestamp() internal view returns (uint32) {\\n        return uint32(block.timestamp % 2 ** 32);\\n    }\\n\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\n    function currentCumulativePrices(\\n        address pair\\n    ) internal view returns (uint price0Cumulative, uint price1Cumulative, uint32 blockTimestamp) {\\n        blockTimestamp = currentBlockTimestamp();\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\n\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\n        if (blockTimestampLast != blockTimestamp) {\\n            // subtraction overflow is desired\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\n            // addition overflow is desired\\n            // counterfactual\\n            price0Cumulative += uint(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\n            // counterfactual\\n            price1Cumulative += uint(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/lib/contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"pragma solidity >=0.4.0;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\nlibrary FixedPoint {\\n    // range: [0, 2**112 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // range: [0, 2**144 - 1]\\n    // resolution: 1 / 2**112\\n    struct uq144x112 {\\n        uint _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // encodes a uint144 as a UQ144x112\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\n        return uq144x112(uint256(x) << RESOLUTION);\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function div(uq112x112 memory self, uint112 x) internal pure returns (uq112x112 memory) {\\n        require(x != 0, 'FixedPoint: DIV_BY_ZERO');\\n        return uq112x112(self._x / uint224(x));\\n    }\\n\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\n    // reverts on overflow\\n    function mul(uq112x112 memory self, uint y) internal pure returns (uq144x112 memory) {\\n        uint z;\\n        require(y == 0 || (z = uint(self._x) * y) / y == uint(self._x), \\\"FixedPoint: MULTIPLICATION_OVERFLOW\\\");\\n        return uq144x112(z);\\n    }\\n\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\n    // equivalent to encode(numerator).div(denominator)\\n    function fraction(uint112 numerator, uint112 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, \\\"FixedPoint: DIV_BY_ZERO\\\");\\n        return uq112x112((uint224(numerator) << RESOLUTION) / denominator);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\n        return uint144(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TwapDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport './interfaces/ITwapPair.sol';\\nimport './interfaces/ITwapDelay.sol';\\nimport './interfaces/IWETH.sol';\\nimport './libraries/SafeMath.sol';\\nimport './libraries/Orders.sol';\\nimport './libraries/TokenShares.sol';\\nimport './libraries/AddLiquidity.sol';\\nimport './libraries/WithdrawHelper.sol';\\n\\ncontract TwapDelay is ITwapDelay {\\n    using SafeMath for uint256;\\n    using Orders for Orders.Data;\\n    using TokenShares for TokenShares.Data;\\n    Orders.Data internal orders;\\n    TokenShares.Data internal tokenShares;\\n\\n    uint256 private constant ORDER_CANCEL_TIME = 24 hours;\\n    uint256 private constant BOT_EXECUTION_TIME = 20 minutes;\\n    uint256 private constant ORDER_LIFESPAN = 48 hours;\\n\\n    address public override owner;\\n    mapping(address => bool) public override isBot;\\n\\n    constructor(\\n        address _factory,\\n        address _weth,\\n        address _bot\\n    ) {\\n        orders.factory = _factory;\\n        owner = msg.sender;\\n        isBot[_bot] = true;\\n        orders.gasPrice = tx.gasprice - (tx.gasprice % 1e6);\\n        tokenShares.setWeth(_weth);\\n        orders.delay = 30 minutes;\\n        orders.maxGasLimit = 5_000_000;\\n        orders.gasPriceInertia = 20_000_000;\\n        orders.maxGasPriceImpact = 1_000_000;\\n        orders.setTransferGasCost(address(0), Orders.ETHER_TRANSFER_CALL_COST);\\n\\n        emit OwnerSet(msg.sender);\\n    }\\n\\n    function getTransferGasCost(address token) external view override returns (uint256 gasCost) {\\n        return orders.transferGasCosts[token];\\n    }\\n\\n    function getDepositOrder(uint256 orderId) external view override returns (Orders.DepositOrder memory order) {\\n        return orders.getDepositOrder(orderId);\\n    }\\n\\n    function getWithdrawOrder(uint256 orderId) external view override returns (Orders.WithdrawOrder memory order) {\\n        return orders.getWithdrawOrder(orderId);\\n    }\\n\\n    function getSellOrder(uint256 orderId) external view override returns (Orders.SellOrder memory order) {\\n        return orders.getSellOrder(orderId);\\n    }\\n\\n    function getBuyOrder(uint256 orderId) external view override returns (Orders.BuyOrder memory order) {\\n        return orders.getBuyOrder(orderId);\\n    }\\n\\n    function getDepositDisabled(address pair) external view override returns (bool) {\\n        return orders.getDepositDisabled(pair);\\n    }\\n\\n    function getWithdrawDisabled(address pair) external view override returns (bool) {\\n        return orders.getWithdrawDisabled(pair);\\n    }\\n\\n    function getBuyDisabled(address pair) external view override returns (bool) {\\n        return orders.getBuyDisabled(pair);\\n    }\\n\\n    function getSellDisabled(address pair) external view override returns (bool) {\\n        return orders.getSellDisabled(pair);\\n    }\\n\\n    function getOrderStatus(uint256 orderId) external view override returns (Orders.OrderStatus) {\\n        return orders.getOrderStatus(orderId);\\n    }\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'TD06');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function factory() external view override returns (address) {\\n        return orders.factory;\\n    }\\n\\n    function totalShares(address token) external view override returns (uint256) {\\n        return tokenShares.totalShares[token];\\n    }\\n\\n    function weth() external view override returns (address) {\\n        return tokenShares.weth;\\n    }\\n\\n    function delay() external view override returns (uint32) {\\n        return orders.delay;\\n    }\\n\\n    function lastProcessedOrderId() external view returns (uint256) {\\n        return orders.lastProcessedOrderId;\\n    }\\n\\n    function newestOrderId() external view returns (uint256) {\\n        return orders.newestOrderId;\\n    }\\n\\n    function getOrder(uint256 orderId) external view returns (Orders.OrderType orderType, uint32 validAfterTimestamp) {\\n        return orders.getOrder(orderId);\\n    }\\n\\n    function isOrderCanceled(uint256 orderId) external view returns (bool) {\\n        return orders.canceled[orderId];\\n    }\\n\\n    function maxGasLimit() external view override returns (uint256) {\\n        return orders.maxGasLimit;\\n    }\\n\\n    function maxGasPriceImpact() external view override returns (uint256) {\\n        return orders.maxGasPriceImpact;\\n    }\\n\\n    function gasPriceInertia() external view override returns (uint256) {\\n        return orders.gasPriceInertia;\\n    }\\n\\n    function gasPrice() external view override returns (uint256) {\\n        return orders.gasPrice;\\n    }\\n\\n    function setOrderDisabled(\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setOrderDisabled(pair, orderType, disabled);\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'TD00');\\n        require(_owner != owner, 'TD01');\\n        require(_owner != address(0), 'TD02');\\n        owner = _owner;\\n        emit OwnerSet(_owner);\\n    }\\n\\n    function setBot(address _bot, bool _isBot) external override {\\n        require(msg.sender == owner, 'TD00');\\n        require(_isBot != isBot[_bot], 'TD01');\\n        isBot[_bot] = _isBot;\\n        emit BotSet(_bot, _isBot);\\n    }\\n\\n    function setMaxGasLimit(uint256 _maxGasLimit) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setMaxGasLimit(_maxGasLimit);\\n    }\\n\\n    function setDelay(uint32 _delay) external override {\\n        require(msg.sender == owner, 'TD00');\\n        require(_delay != orders.delay, 'TD01');\\n        orders.delay = _delay;\\n        emit DelaySet(_delay);\\n    }\\n\\n    function setGasPriceInertia(uint256 _gasPriceInertia) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setGasPriceInertia(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setMaxGasPriceImpact(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(address token, uint256 gasCost) external override {\\n        require(msg.sender == owner, 'TD00');\\n        orders.setTransferGasCost(token, gasCost);\\n    }\\n\\n    function deposit(Orders.DepositParams calldata depositParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.deposit(depositParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function withdraw(Orders.WithdrawParams calldata withdrawParams)\\n        external\\n        payable\\n        override\\n        lock\\n        returns (uint256 orderId)\\n    {\\n        orders.withdraw(withdrawParams);\\n        return orders.newestOrderId;\\n    }\\n\\n    function sell(Orders.SellParams calldata sellParams) external payable override lock returns (uint256 orderId) {\\n        orders.sell(sellParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function buy(Orders.BuyParams calldata buyParams) external payable override lock returns (uint256 orderId) {\\n        orders.buy(buyParams, tokenShares);\\n        return orders.newestOrderId;\\n    }\\n\\n    function execute(uint256 n) external override lock {\\n        emit Execute(msg.sender, n);\\n        uint256 gasBefore = gasleft();\\n        bool orderExecuted = false;\\n        bool senderCanExecute = isBot[msg.sender] || isBot[address(0)];\\n        for (uint256 i = 0; i < n; i++) {\\n            if (orders.canceled[orders.lastProcessedOrderId + 1]) {\\n                orders.dequeueCanceledOrder();\\n                continue;\\n            }\\n            (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getNextOrder();\\n            if (orderType == Orders.OrderType.Empty || validAfterTimestamp >= block.timestamp) {\\n                break;\\n            }\\n            require(senderCanExecute || block.timestamp >= validAfterTimestamp + BOT_EXECUTION_TIME, 'TD00');\\n            orderExecuted = true;\\n            if (orderType == Orders.OrderType.Deposit) {\\n                executeDeposit();\\n            } else if (orderType == Orders.OrderType.Withdraw) {\\n                executeWithdraw();\\n            } else if (orderType == Orders.OrderType.Sell) {\\n                executeSell();\\n            } else if (orderType == Orders.OrderType.Buy) {\\n                executeBuy();\\n            }\\n        }\\n        if (orderExecuted) {\\n            orders.updateGasPrice(gasBefore.sub(gasleft()));\\n        }\\n    }\\n\\n    function executeDeposit() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.DepositOrder memory depositOrder = orders.dequeueDepositOrder();\\n        (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: depositOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[token0]).add(orders.transferGasCosts[token1])\\n            )\\n        }(abi.encodeWithSelector(this._executeDeposit.selector, depositOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundTokens(\\n                depositOrder.to,\\n                token0,\\n                depositOrder.share0,\\n                token1,\\n                depositOrder.share1,\\n                depositOrder.unwrap\\n            );\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(\\n            depositOrder.gasLimit,\\n            depositOrder.gasPrice,\\n            gasStart,\\n            depositOrder.to\\n        );\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeWithdraw() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.WithdrawOrder memory withdrawOrder = orders.dequeueWithdrawOrder();\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: withdrawOrder.gasLimit.sub(Orders.ORDER_BASE_COST.add(Orders.PAIR_TRANSFER_COST))\\n        }(abi.encodeWithSelector(this._executeWithdraw.selector, withdrawOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\\n            refundSuccess = refundLiquidity(pair, withdrawOrder.to, withdrawOrder.liquidity);\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(\\n            withdrawOrder.gasLimit,\\n            withdrawOrder.gasPrice,\\n            gasStart,\\n            withdrawOrder.to\\n        );\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeSell() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.SellOrder memory sellOrder = orders.dequeueSellOrder();\\n        (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: sellOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[sellOrder.inverse ? token1 : token0])\\n            )\\n        }(abi.encodeWithSelector(this._executeSell.selector, sellOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(\\n                sellOrder.inverse ? token1 : token0,\\n                sellOrder.to,\\n                sellOrder.shareIn,\\n                sellOrder.unwrap\\n            );\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(sellOrder.gasLimit, sellOrder.gasPrice, gasStart, sellOrder.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function executeBuy() internal {\\n        uint256 gasStart = gasleft();\\n        Orders.BuyOrder memory buyOrder = orders.dequeueBuyOrder();\\n        (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\\n        (bool executionSuccess, bytes memory data) = address(this).call{\\n            gas: buyOrder.gasLimit.sub(\\n                Orders.ORDER_BASE_COST.add(orders.transferGasCosts[buyOrder.inverse ? token1 : token0])\\n            )\\n        }(abi.encodeWithSelector(this._executeBuy.selector, buyOrder));\\n        bool refundSuccess = true;\\n        if (!executionSuccess) {\\n            refundSuccess = refundToken(\\n                buyOrder.inverse ? token1 : token0,\\n                buyOrder.to,\\n                buyOrder.shareInMax,\\n                buyOrder.unwrap\\n            );\\n        }\\n        finalizeOrder(refundSuccess);\\n        (uint256 gasUsed, uint256 ethRefund) = refund(buyOrder.gasLimit, buyOrder.gasPrice, gasStart, buyOrder.to);\\n        emit OrderExecuted(orders.lastProcessedOrderId, executionSuccess, data, gasUsed, ethRefund);\\n    }\\n\\n    function finalizeOrder(bool refundSuccess) private {\\n        if (!refundSuccess) {\\n            orders.markRefundFailed();\\n        } else {\\n            orders.forgetLastProcessedOrder();\\n        }\\n    }\\n\\n    function refund(\\n        uint256 gasLimit,\\n        uint256 gasPriceInOrder,\\n        uint256 gasStart,\\n        address to\\n    ) private returns (uint256 gasUsed, uint256 leftOver) {\\n        uint256 feeCollected = gasLimit.mul(gasPriceInOrder);\\n        gasUsed = gasStart.sub(gasleft()).add(Orders.REFUND_BASE_COST);\\n        uint256 actualRefund = Math.min(feeCollected, gasUsed.mul(orders.gasPrice));\\n        leftOver = feeCollected.sub(actualRefund);\\n        require(refundEth(msg.sender, actualRefund), 'TD40');\\n        refundEth(payable(to), leftOver);\\n    }\\n\\n    function refundEth(address payable to, uint256 value) internal returns (bool success) {\\n        if (value == 0) {\\n            return true;\\n        }\\n        success = TransferHelper.transferETH(to, value, orders.transferGasCosts[address(0)]);\\n        emit EthRefund(to, success, value);\\n    }\\n\\n    function refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) private returns (bool) {\\n        if (share == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: orders.transferGasCosts[token] }(\\n            abi.encodeWithSelector(this._refundToken.selector, token, to, share, unwrap)\\n        );\\n        if (!success) {\\n            emit RefundFailed(to, token, share, data);\\n        }\\n        return success;\\n    }\\n\\n    function refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) private returns (bool) {\\n        (bool success, bytes memory data) = address(this).call{\\n            gas: orders.transferGasCosts[token0].add(orders.transferGasCosts[token1])\\n        }(abi.encodeWithSelector(this._refundTokens.selector, to, token0, share0, token1, share1, unwrap));\\n        if (!success) {\\n            emit RefundFailed(to, token0, share0, data);\\n            emit RefundFailed(to, token1, share1, data);\\n        }\\n        return success;\\n    }\\n\\n    function _refundTokens(\\n        address to,\\n        address token0,\\n        uint256 share0,\\n        address token1,\\n        uint256 share1,\\n        bool unwrap\\n    ) external {\\n        // no need to check sender, because it is checked in _refundToken\\n        _refundToken(token0, to, share0, unwrap);\\n        _refundToken(token1, to, share1, unwrap);\\n    }\\n\\n    function _refundToken(\\n        address token,\\n        address to,\\n        uint256 share,\\n        bool unwrap\\n    ) public {\\n        require(msg.sender == address(this), 'TD00');\\n        if (token == tokenShares.weth && unwrap) {\\n            uint256 amount = tokenShares.sharesToAmount(token, share);\\n            IWETH(tokenShares.weth).withdraw(amount);\\n            TransferHelper.safeTransferETH(to, amount, orders.transferGasCosts[address(0)]);\\n        } else {\\n            TransferHelper.safeTransfer(token, to, tokenShares.sharesToAmount(token, share));\\n        }\\n    }\\n\\n    function refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity\\n    ) private returns (bool) {\\n        if (liquidity == 0) {\\n            return true;\\n        }\\n        (bool success, bytes memory data) = address(this).call{ gas: Orders.PAIR_TRANSFER_COST }(\\n            abi.encodeWithSelector(this._refundLiquidity.selector, pair, to, liquidity, false)\\n        );\\n        if (!success) {\\n            emit RefundFailed(to, pair, liquidity, data);\\n        }\\n        return success;\\n    }\\n\\n    function _refundLiquidity(\\n        address pair,\\n        address to,\\n        uint256 liquidity\\n    ) external {\\n        require(msg.sender == address(this), 'TD00');\\n        return TransferHelper.safeTransfer(pair, to, liquidity);\\n    }\\n\\n    function _executeDeposit(Orders.DepositOrder memory depositOrder) external {\\n        require(msg.sender == address(this), 'TD00');\\n        require(depositOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\\n\\n        (address pair, address token0, address token1, uint256 amount0Left, uint256 amount1Left) = _initialDeposit(\\n            depositOrder\\n        );\\n        if (depositOrder.swap) {\\n            if (amount0Left != 0) {\\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit0(\\n                    pair,\\n                    token0,\\n                    amount0Left,\\n                    depositOrder.minSwapPrice,\\n                    encodePriceInfo(pair, depositOrder.priceAccumulator, depositOrder.timestamp)\\n                );\\n            } else if (amount1Left != 0) {\\n                (amount0Left, amount1Left) = AddLiquidity.swapDeposit1(\\n                    pair,\\n                    token1,\\n                    amount1Left,\\n                    depositOrder.maxSwapPrice,\\n                    encodePriceInfo(pair, depositOrder.priceAccumulator, depositOrder.timestamp)\\n                );\\n            }\\n        }\\n        if (amount0Left != 0 && amount1Left != 0) {\\n            (amount0Left, amount1Left) = AddLiquidity.addLiquidityAndMint(\\n                pair,\\n                depositOrder.to,\\n                token0,\\n                token1,\\n                amount0Left,\\n                amount1Left\\n            );\\n        }\\n\\n        _refundDeposit(depositOrder.to, token0, token1, amount0Left, amount1Left);\\n    }\\n\\n    function _initialDeposit(Orders.DepositOrder memory depositOrder)\\n        private\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1,\\n            uint256 amount0Left,\\n            uint256 amount1Left\\n        )\\n    {\\n        (pair, token0, token1) = orders.getPairInfo(depositOrder.pairId);\\n        uint256 amount0Desired = tokenShares.sharesToAmount(token0, depositOrder.share0);\\n        uint256 amount1Desired = tokenShares.sharesToAmount(token1, depositOrder.share1);\\n        ITwapPair(pair).sync();\\n        (amount0Left, amount1Left) = AddLiquidity.addLiquidityAndMint(\\n            pair,\\n            depositOrder.to,\\n            token0,\\n            token1,\\n            amount0Desired,\\n            amount1Desired\\n        );\\n    }\\n\\n    function _refundDeposit(\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0,\\n        uint256 amount1\\n    ) private {\\n        if (amount0 > 0) {\\n            TransferHelper.safeTransfer(token0, to, amount0);\\n        }\\n        if (amount1 > 0) {\\n            TransferHelper.safeTransfer(token1, to, amount1);\\n        }\\n    }\\n\\n    function _executeWithdraw(Orders.WithdrawOrder memory withdrawOrder) external {\\n        require(msg.sender == address(this), 'TD00');\\n        require(withdrawOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\\n\\n        (address pair, address token0, address token1) = orders.getPairInfo(withdrawOrder.pairId);\\n        ITwapPair(pair).sync();\\n        TransferHelper.safeTransfer(pair, pair, withdrawOrder.liquidity);\\n\\n        (uint256 wethAmount, uint256 amount0, uint256 amount1) = (0, 0, 0);\\n        if (withdrawOrder.unwrap && (token0 == tokenShares.weth || token1 == tokenShares.weth)) {\\n            bool success;\\n            (success, wethAmount, amount0, amount1) = WithdrawHelper.withdrawAndUnwrap(\\n                token0,\\n                token1,\\n                pair,\\n                tokenShares.weth,\\n                withdrawOrder.to,\\n                orders.transferGasCosts[address(0)]\\n            );\\n            if (!success) {\\n                tokenShares.onUnwrapFailed(withdrawOrder.to, wethAmount);\\n            }\\n        } else {\\n            (amount0, amount1) = ITwapPair(pair).burn(withdrawOrder.to);\\n        }\\n        require(amount0 >= withdrawOrder.amount0Min && amount1 >= withdrawOrder.amount1Min, 'TD03');\\n    }\\n\\n    function _executeBuy(Orders.BuyOrder memory buyOrder) external {\\n        require(msg.sender == address(this), 'TD00');\\n        require(buyOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\\n\\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(buyOrder.pairId, buyOrder.inverse);\\n        uint256 amountInMax = tokenShares.sharesToAmount(tokenIn, buyOrder.shareInMax);\\n        ITwapPair pair = ITwapPair(pairAddress);\\n        pair.sync();\\n        bytes memory priceInfo = encodePriceInfo(pairAddress, buyOrder.priceAccumulator, buyOrder.timestamp);\\n        uint256 amountIn = buyOrder.inverse\\n            ? pair.getSwapAmount1In(buyOrder.amountOut, priceInfo)\\n            : pair.getSwapAmount0In(buyOrder.amountOut, priceInfo);\\n        require(amountInMax >= amountIn, 'TD08');\\n        if (amountInMax > amountIn) {\\n            if (tokenIn == tokenShares.weth && buyOrder.unwrap) {\\n                _forceEtherTransfer(buyOrder.to, amountInMax.sub(amountIn));\\n            } else {\\n                TransferHelper.safeTransfer(tokenIn, buyOrder.to, amountInMax.sub(amountIn));\\n            }\\n        }\\n        (uint256 amount0Out, uint256 amount1Out) = buyOrder.inverse\\n            ? (buyOrder.amountOut, uint256(0))\\n            : (uint256(0), buyOrder.amountOut);\\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\\n        if (tokenOut == tokenShares.weth && buyOrder.unwrap) {\\n            pair.swap(amount0Out, amount1Out, address(this), priceInfo);\\n            _forceEtherTransfer(buyOrder.to, buyOrder.amountOut);\\n        } else {\\n            pair.swap(amount0Out, amount1Out, buyOrder.to, priceInfo);\\n        }\\n    }\\n\\n    function _executeSell(Orders.SellOrder memory sellOrder) external {\\n        require(msg.sender == address(this), 'TD00');\\n        require(sellOrder.validAfterTimestamp + ORDER_LIFESPAN >= block.timestamp, 'TD04');\\n\\n        (address pairAddress, address tokenIn, address tokenOut) = _getPairAndTokens(\\n            sellOrder.pairId,\\n            sellOrder.inverse\\n        );\\n        uint256 amountIn = tokenShares.sharesToAmount(tokenIn, sellOrder.shareIn);\\n        ITwapPair pair = ITwapPair(pairAddress);\\n        pair.sync();\\n        bytes memory priceInfo = encodePriceInfo(pairAddress, sellOrder.priceAccumulator, sellOrder.timestamp);\\n        uint256 amountOut = sellOrder.inverse\\n            ? pair.getSwapAmount0Out(amountIn, priceInfo)\\n            : pair.getSwapAmount1Out(amountIn, priceInfo);\\n        require(amountOut >= sellOrder.amountOutMin, 'TD37');\\n        (uint256 amount0Out, uint256 amount1Out) = sellOrder.inverse\\n            ? (amountOut, uint256(0))\\n            : (uint256(0), amountOut);\\n        TransferHelper.safeTransfer(tokenIn, pairAddress, amountIn);\\n        if (tokenOut == tokenShares.weth && sellOrder.unwrap) {\\n            pair.swap(amount0Out, amount1Out, address(this), priceInfo);\\n            _forceEtherTransfer(sellOrder.to, amountOut);\\n        } else {\\n            pair.swap(amount0Out, amount1Out, sellOrder.to, priceInfo);\\n        }\\n    }\\n\\n    function _getPairAndTokens(uint32 pairId, bool pairInversed)\\n        private\\n        view\\n        returns (\\n            address,\\n            address,\\n            address\\n        )\\n    {\\n        (address pairAddress, address token0, address token1) = orders.getPairInfo(pairId);\\n        (address tokenIn, address tokenOut) = pairInversed ? (token1, token0) : (token0, token1);\\n        return (pairAddress, tokenIn, tokenOut);\\n    }\\n\\n    function _forceEtherTransfer(address to, uint256 amount) internal {\\n        IWETH(tokenShares.weth).withdraw(amount);\\n        (bool success, ) = to.call{ value: amount, gas: orders.transferGasCosts[address(0)] }('');\\n        if (!success) {\\n            tokenShares.onUnwrapFailed(to, amount);\\n        }\\n    }\\n\\n    function performRefund(\\n        Orders.OrderType orderType,\\n        uint256 validAfterTimestamp,\\n        uint256 orderId,\\n        bool shouldRefundEth\\n    ) internal {\\n        require(orderType != Orders.OrderType.Empty, 'TD41');\\n        bool canOwnerRefund = validAfterTimestamp.add(365 days) < block.timestamp;\\n\\n        if (orderType == Orders.OrderType.Deposit) {\\n            Orders.DepositOrder memory depositOrder = orders.getDepositOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(depositOrder.pairId);\\n            address to = canOwnerRefund ? owner : depositOrder.to;\\n            require(\\n                refundTokens(to, token0, depositOrder.share0, token1, depositOrder.share1, depositOrder.unwrap),\\n                'TD14'\\n            );\\n            if (shouldRefundEth) {\\n                uint256 value = depositOrder.gasPrice.mul(depositOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'TD40');\\n            }\\n        } else if (orderType == Orders.OrderType.Withdraw) {\\n            Orders.WithdrawOrder memory withdrawOrder = orders.getWithdrawOrder(orderId);\\n            (address pair, , ) = orders.getPairInfo(withdrawOrder.pairId);\\n            address to = canOwnerRefund ? owner : withdrawOrder.to;\\n            require(refundLiquidity(pair, to, withdrawOrder.liquidity), 'TD14');\\n            if (shouldRefundEth) {\\n                uint256 value = withdrawOrder.gasPrice.mul(withdrawOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'TD40');\\n            }\\n        } else if (orderType == Orders.OrderType.Sell) {\\n            Orders.SellOrder memory sellOrder = orders.getSellOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(sellOrder.pairId);\\n            address to = canOwnerRefund ? owner : sellOrder.to;\\n            require(refundToken(sellOrder.inverse ? token1 : token0, to, sellOrder.shareIn, sellOrder.unwrap), 'TD14');\\n            if (shouldRefundEth) {\\n                uint256 value = sellOrder.gasPrice.mul(sellOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'TD40');\\n            }\\n        } else if (orderType == Orders.OrderType.Buy) {\\n            Orders.BuyOrder memory buyOrder = orders.getBuyOrder(orderId);\\n            (, address token0, address token1) = orders.getPairInfo(buyOrder.pairId);\\n            address to = canOwnerRefund ? owner : buyOrder.to;\\n            require(refundToken(buyOrder.inverse ? token1 : token0, to, buyOrder.shareInMax, buyOrder.unwrap), 'TD14');\\n            if (shouldRefundEth) {\\n                uint256 value = buyOrder.gasPrice.mul(buyOrder.gasLimit);\\n                require(refundEth(payable(to), value), 'TD40');\\n            }\\n        }\\n        orders.forgetOrder(orderId);\\n    }\\n\\n    function retryRefund(uint256 orderId) external override lock {\\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getFailedOrderType(orderId);\\n        performRefund(orderType, validAfterTimestamp, orderId, false);\\n    }\\n\\n    function cancelOrder(uint256 orderId) external override lock {\\n        require(orders.getOrderStatus(orderId) == Orders.OrderStatus.EnqueuedReady, 'TD52');\\n        (Orders.OrderType orderType, uint256 validAfterTimestamp) = orders.getOrder(orderId);\\n        require(validAfterTimestamp.sub(orders.delay).add(ORDER_CANCEL_TIME) < block.timestamp, 'TD1C');\\n        orders.canceled[orderId] = true;\\n        performRefund(orderType, validAfterTimestamp, orderId, true);\\n    }\\n\\n    function encodePriceInfo(\\n        address pair,\\n        uint256 priceAccumulator,\\n        uint32 priceTimestamp\\n    ) internal view returns (bytes memory data) {\\n        uint256 price = ITwapOracle(ITwapPair(pair).oracle()).getAveragePrice(priceAccumulator, priceTimestamp);\\n        // Pack everything as 32 bytes / uint256 to simplify decoding\\n        data = abi.encode(price);\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './ITwapERC20.sol';\\nimport './IReserves.sol';\\n\\ninterface ITwapPair is ITwapERC20, IReserves {\\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapDelay.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport '../libraries/Orders.sol';\\n\\ninterface ITwapDelay {\\n    event OrderExecuted(uint256 indexed id, bool indexed success, bytes data, uint256 gasSpent, uint256 ethRefunded);\\n    event RefundFailed(address indexed to, address indexed token, uint256 amount, bytes data);\\n    event EthRefund(address indexed to, bool indexed success, uint256 value);\\n    event OwnerSet(address owner);\\n    event BotSet(address bot, bool isBot);\\n    event DelaySet(uint256 delay);\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\\n    event UnwrapFailed(address to, uint256 amount);\\n    event Execute(address sender, uint256 n);\\n\\n    function factory() external returns (address);\\n\\n    function owner() external returns (address);\\n\\n    function isBot(address bot) external returns (bool);\\n\\n    function gasPriceInertia() external returns (uint256);\\n\\n    function gasPrice() external returns (uint256);\\n\\n    function maxGasPriceImpact() external returns (uint256);\\n\\n    function maxGasLimit() external returns (uint256);\\n\\n    function delay() external returns (uint32);\\n\\n    function totalShares(address token) external returns (uint256);\\n\\n    function weth() external returns (address);\\n\\n    function getTransferGasCost(address token) external returns (uint256);\\n\\n    function getDepositOrder(uint256 orderId) external returns (Orders.DepositOrder memory order);\\n\\n    function getWithdrawOrder(uint256 orderId) external returns (Orders.WithdrawOrder memory order);\\n\\n    function getSellOrder(uint256 orderId) external returns (Orders.SellOrder memory order);\\n\\n    function getBuyOrder(uint256 orderId) external returns (Orders.BuyOrder memory order);\\n\\n    function getDepositDisabled(address pair) external returns (bool);\\n\\n    function getWithdrawDisabled(address pair) external returns (bool);\\n\\n    function getBuyDisabled(address pair) external returns (bool);\\n\\n    function getSellDisabled(address pair) external returns (bool);\\n\\n    function getOrderStatus(uint256 orderId) external returns (Orders.OrderStatus);\\n\\n    function setOrderDisabled(\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) external;\\n\\n    function setOwner(address _owner) external;\\n\\n    function setBot(address _bot, bool _isBot) external;\\n\\n    function setMaxGasLimit(uint256 _maxGasLimit) external;\\n\\n    function setDelay(uint32 _delay) external;\\n\\n    function setGasPriceInertia(uint256 _gasPriceInertia) external;\\n\\n    function setMaxGasPriceImpact(uint256 _maxGasPriceImpact) external;\\n\\n    function setTransferGasCost(address token, uint256 gasCost) external;\\n\\n    function deposit(Orders.DepositParams memory depositParams) external payable returns (uint256 orderId);\\n\\n    function withdraw(Orders.WithdrawParams memory withdrawParams) external payable returns (uint256 orderId);\\n\\n    function sell(Orders.SellParams memory sellParams) external payable returns (uint256 orderId);\\n\\n    function buy(Orders.BuyParams memory buyParams) external payable returns (uint256 orderId);\\n\\n    function execute(uint256 n) external;\\n\\n    function retryRefund(uint256 orderId) external;\\n\\n    function cancelOrder(uint256 orderId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Orders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport './SafeMath.sol';\\nimport '../libraries/Math.sol';\\nimport '../interfaces/ITwapFactory.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\nimport '../libraries/TokenShares.sol';\\n\\nlibrary Orders {\\n    using SafeMath for uint256;\\n    using TokenShares for TokenShares.Data;\\n    using TransferHelper for address;\\n\\n    enum OrderType {\\n        Empty,\\n        Deposit,\\n        Withdraw,\\n        Sell,\\n        Buy\\n    }\\n    enum OrderStatus {\\n        NonExistent,\\n        EnqueuedWaiting,\\n        EnqueuedReady,\\n        ExecutedSucceeded,\\n        ExecutedFailed,\\n        Canceled\\n    }\\n\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n\\n    event DepositEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event WithdrawEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event SellEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event BuyEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n\\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\\n\\n    uint8 private constant DEPOSIT_TYPE = 1;\\n    uint8 private constant WITHDRAW_TYPE = 2;\\n    uint8 private constant BUY_TYPE = 3;\\n    uint8 private constant BUY_INVERTED_TYPE = 4;\\n    uint8 private constant SELL_TYPE = 5;\\n    uint8 private constant SELL_INVERTED_TYPE = 6;\\n\\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\\n    uint8 private constant KEEP_NOT_FAILED = 1;\\n    uint8 private constant UNWRAP_FAILED = 2;\\n    uint8 private constant KEEP_FAILED = 3;\\n\\n    uint256 private constant ETHER_TRANSFER_COST = 2600 + 1504; // EIP-2929 acct access cost + Gnosis Safe receive ETH cost\\n    uint256 private constant BUFFER_COST = 10000;\\n    uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;\\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\\n\\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\\n    uint256 public constant REFUND_BASE_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;\\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;\\n\\n    // Masks used for setting order disabled\\n    // Different bits represent different order types\\n    uint8 private constant DEPOSIT_MASK = uint8(1) << uint8(OrderType.Deposit); //   00000010\\n    uint8 private constant WITHDRAW_MASK = uint8(1) << uint8(OrderType.Withdraw); // 00000100\\n    uint8 private constant SELL_MASK = uint8(1) << uint8(OrderType.Sell); //         00001000\\n    uint8 private constant BUY_MASK = uint8(1) << uint8(OrderType.Buy); //           00010000\\n\\n    struct PairInfo {\\n        address pair;\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct Data {\\n        uint32 delay;\\n        uint256 newestOrderId;\\n        uint256 lastProcessedOrderId;\\n        mapping(uint256 => StoredOrder) orderQueue;\\n        address factory;\\n        uint256 maxGasLimit;\\n        uint256 gasPrice;\\n        uint256 gasPriceInertia;\\n        uint256 maxGasPriceImpact;\\n        mapping(uint32 => PairInfo) pairs;\\n        mapping(address => uint256) transferGasCosts;\\n        mapping(uint256 => bool) canceled;\\n        // Bit on specific positions indicates whether order type is disabled (1) or enabled (0) on specific pair\\n        mapping(address => uint8) orderDisabled;\\n    }\\n\\n    struct StoredOrder {\\n        // slot 0\\n        uint8 orderType;\\n        uint32 validAfterTimestamp;\\n        uint8 unwrapAndFailure;\\n        uint32 timestamp;\\n        uint32 gasLimit;\\n        uint32 gasPrice;\\n        uint112 liquidity;\\n        // slot 1\\n        uint112 value0;\\n        uint112 value1;\\n        uint32 pairId;\\n        // slot2\\n        address to;\\n        uint32 minSwapPrice;\\n        uint32 maxSwapPrice;\\n        bool swap;\\n        // slot3\\n        uint256 priceAccumulator;\\n    }\\n\\n    struct DepositOrder {\\n        uint32 pairId;\\n        uint256 share0;\\n        uint256 share1;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool unwrap;\\n        bool swap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    struct WithdrawOrder {\\n        uint32 pairId;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n    }\\n\\n    struct SellOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareIn;\\n        uint256 amountOutMin;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    struct BuyOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareInMax;\\n        uint256 amountOut;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\\n        if (internalType == DEPOSIT_TYPE) {\\n            orderType = OrderType.Deposit;\\n        } else if (internalType == WITHDRAW_TYPE) {\\n            orderType = OrderType.Withdraw;\\n        } else if (internalType == BUY_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == BUY_INVERTED_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == SELL_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else if (internalType == SELL_INVERTED_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else {\\n            orderType = OrderType.Empty;\\n        }\\n    }\\n\\n    function getOrder(Data storage data, uint256 orderId)\\n        public\\n        view\\n        returns (OrderType orderType, uint32 validAfterTimestamp)\\n    {\\n        StoredOrder storage order = data.orderQueue[orderId];\\n        uint8 internalType = order.orderType;\\n        validAfterTimestamp = order.validAfterTimestamp;\\n        orderType = decodeType(internalType);\\n    }\\n\\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\\n        if (orderId > data.newestOrderId) {\\n            return OrderStatus.NonExistent;\\n        }\\n        if (data.canceled[orderId]) {\\n            return OrderStatus.Canceled;\\n        }\\n        if (isRefundFailed(data, orderId)) {\\n            return OrderStatus.ExecutedFailed;\\n        }\\n        (OrderType orderType, uint32 validAfterTimestamp) = getOrder(data, orderId);\\n        if (orderType == OrderType.Empty) {\\n            return OrderStatus.ExecutedSucceeded;\\n        }\\n        if (validAfterTimestamp >= block.timestamp) {\\n            return OrderStatus.EnqueuedWaiting;\\n        }\\n        return OrderStatus.EnqueuedReady;\\n    }\\n\\n    function getPair(\\n        Data storage data,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        returns (\\n            address pair,\\n            uint32 pairId,\\n            bool inverted\\n        )\\n    {\\n        inverted = tokenA > tokenB;\\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\\n        pair = ITwapFactory(data.factory).getPair(token0, token1);\\n        require(pair != address(0), 'OS17');\\n        pairId = uint32(bytes4(keccak256(abi.encodePacked(pair))));\\n        if (data.pairs[pairId].pair == address(0)) {\\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\\n        }\\n    }\\n\\n    function getPairInfo(Data storage data, uint32 pairId)\\n        external\\n        view\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1\\n        )\\n    {\\n        PairInfo storage info = data.pairs[pairId];\\n        pair = info.pair;\\n        token0 = info.token0;\\n        token1 = info.token1;\\n    }\\n\\n    function getDepositDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & DEPOSIT_MASK != 0;\\n    }\\n\\n    function getWithdrawDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & WITHDRAW_MASK != 0;\\n    }\\n\\n    function getSellDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & SELL_MASK != 0;\\n    }\\n\\n    function getBuyDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & BUY_MASK != 0;\\n    }\\n\\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == DEPOSIT_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.share0 = stored.value0;\\n        order.share1 = stored.value1;\\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.swap = stored.swap;\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n        order.timestamp = stored.timestamp;\\n    }\\n\\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == WITHDRAW_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.liquidity = stored.liquidity;\\n        order.amount0Min = stored.value0;\\n        order.amount1Min = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n    }\\n\\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\\n        order.shareIn = stored.value0;\\n        order.amountOutMin = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n        order.timestamp = stored.timestamp;\\n    }\\n\\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\\n        order.shareInMax = stored.value0;\\n        order.amountOut = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.timestamp = stored.timestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n    }\\n\\n    function getFailedOrderType(Data storage data, uint256 orderId)\\n        external\\n        view\\n        returns (OrderType orderType, uint32 validAfterTimestamp)\\n    {\\n        require(isRefundFailed(data, orderId), 'OS21');\\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\\n    }\\n\\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\\n    }\\n\\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\\n    }\\n\\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\\n        if (timestamp == type(uint256).max) {\\n            return type(uint32).max;\\n        }\\n        timestamp32 = timestamp.toUint32();\\n    }\\n\\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS3C');\\n        gasPrice32 = (gasPrice / 1e6).toUint32();\\n    }\\n\\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\\n        gasPrice = uint256(gasPrice32) * 1e6;\\n    }\\n\\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // If the number fits in the mantissa we set the exponent to zero and return.\\n        if (number < 2 << 24) {\\n            return uint32(number << 8);\\n        }\\n        // We find the exponent by counting the number of trailing zeroes.\\n        // Simultaneously we remove those zeroes from the number.\\n        uint32 exponent;\\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\\n            // Last bit is one.\\n            if (number & 1 == 1) {\\n                break;\\n            }\\n            number = number >> 1;\\n        }\\n        // The number must fit in the mantissa.\\n        require(number < 2 << 24, 'OS1A');\\n        // Set the first three bytes to the number and the fourth to the exponent.\\n        float32 = uint32(number << 8) | exponent;\\n    }\\n\\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // We get the exponent by extracting the last byte.\\n        uint256 exponent = float32 & 0xFF;\\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\\n        require(exponent <= 256 - 24, 'OS1B');\\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\\n        // We add exponent number zeroes after the mantissa.\\n        number = mantissa << exponent;\\n    }\\n\\n    function setOrderDisabled(\\n        Data storage data,\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) external {\\n        require(orderType != Orders.OrderType.Empty, 'OS32');\\n        uint8 currentSettings = data.orderDisabled[pair];\\n\\n        // zeros with 1 bit set at position specified by orderType\\n        uint8 mask = uint8(1) << uint8(orderType);\\n\\n        // set/unset a bit accordingly to 'disabled' value\\n        if (disabled) {\\n            // OR operation to disable order\\n            // e.g. for disable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // mask for DEPOSIT  = 00000010\\n            // the result of OR  = 00010110\\n            currentSettings = currentSettings | mask;\\n        } else {\\n            // AND operation with a mask negation to enable order\\n            // e.g. for enable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // 0xff              = 11111111\\n            // mask for Deposit  = 00000010\\n            // mask negation     = 11111101\\n            // the result of AND = 00010100\\n            currentSettings = currentSettings & (mask ^ 0xff);\\n        }\\n        require(currentSettings != data.orderDisabled[pair], 'OS01');\\n        data.orderDisabled[pair] = currentSettings;\\n\\n        emit OrderDisabled(pair, orderType, disabled);\\n    }\\n\\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\\n        data.newestOrderId++;\\n        emit DepositEnqueued(data.newestOrderId, depositOrder.validAfterTimestamp, depositOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            DEPOSIT_TYPE,\\n            depositOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(depositOrder.unwrap),\\n            depositOrder.timestamp,\\n            depositOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(depositOrder.gasPrice),\\n            0, // liquidity\\n            depositOrder.share0.toUint112(),\\n            depositOrder.share1.toUint112(),\\n            depositOrder.pairId,\\n            depositOrder.to,\\n            uintToFloat32(depositOrder.minSwapPrice),\\n            uintToFloat32(depositOrder.maxSwapPrice),\\n            depositOrder.swap,\\n            depositOrder.priceAccumulator\\n        );\\n    }\\n\\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\\n        data.newestOrderId++;\\n        emit WithdrawEnqueued(data.newestOrderId, withdrawOrder.validAfterTimestamp, withdrawOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            WITHDRAW_TYPE,\\n            withdrawOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(withdrawOrder.unwrap),\\n            0, // timestamp\\n            withdrawOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(withdrawOrder.gasPrice),\\n            withdrawOrder.liquidity.toUint112(),\\n            withdrawOrder.amount0Min.toUint112(),\\n            withdrawOrder.amount1Min.toUint112(),\\n            withdrawOrder.pairId,\\n            withdrawOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            0 // priceAccumulator\\n        );\\n    }\\n\\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\\n        data.newestOrderId++;\\n        emit SellEnqueued(data.newestOrderId, sellOrder.validAfterTimestamp, sellOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\\n            sellOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(sellOrder.unwrap),\\n            sellOrder.timestamp,\\n            sellOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(sellOrder.gasPrice),\\n            0, // liquidity\\n            sellOrder.shareIn.toUint112(),\\n            sellOrder.amountOutMin.toUint112(),\\n            sellOrder.pairId,\\n            sellOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            sellOrder.priceAccumulator\\n        );\\n    }\\n\\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\\n        data.newestOrderId++;\\n        emit BuyEnqueued(data.newestOrderId, buyOrder.validAfterTimestamp, buyOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\\n            buyOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(buyOrder.unwrap),\\n            buyOrder.timestamp,\\n            buyOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(buyOrder.gasPrice),\\n            0, // liquidity\\n            buyOrder.shareInMax.toUint112(),\\n            buyOrder.amountOut.toUint112(),\\n            buyOrder.pairId,\\n            buyOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            buyOrder.priceAccumulator\\n        );\\n    }\\n\\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\\n    }\\n\\n    function markRefundFailed(Data storage data) internal {\\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\\n    }\\n\\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\\n        return getOrder(data, data.lastProcessedOrderId + 1);\\n    }\\n\\n    function dequeueCanceledOrder(Data storage data) external {\\n        data.lastProcessedOrderId++;\\n    }\\n\\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getDepositOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getSellOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getBuyOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function forgetOrder(Data storage data, uint256 orderId) internal {\\n        delete data.orderQueue[orderId];\\n    }\\n\\n    function forgetLastProcessedOrder(Data storage data) internal {\\n        delete data.orderQueue[data.lastProcessedOrderId];\\n    }\\n\\n    struct DepositParams {\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool wrap;\\n        bool swap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function deposit(\\n        Data storage data,\\n        DepositParams calldata depositParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 token0TransferCost = data.transferGasCosts[depositParams.token0];\\n        uint256 token1TransferCost = data.transferGasCosts[depositParams.token1];\\n        require(token0TransferCost != 0 && token1TransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            depositParams.to,\\n            depositParams.gasLimit,\\n            depositParams.submitDeadline,\\n            ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost)\\n        );\\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\\n        require(!getDepositDisabled(data, pairAddress), 'OS46');\\n        {\\n            // scope for value, avoids stack too deep errors\\n            uint256 value = msg.value;\\n\\n            // allocate gas refund\\n            if (depositParams.wrap) {\\n                if (depositParams.token0 == tokenShares.weth) {\\n                    value = value.sub(depositParams.amount0, 'OS1E');\\n                } else if (depositParams.token1 == tokenShares.weth) {\\n                    value = value.sub(depositParams.amount1, 'OS1E');\\n                }\\n            }\\n            allocateGasRefund(data, value, depositParams.gasLimit);\\n        }\\n\\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueDepositOrder(\\n            data,\\n            DepositOrder(\\n                pairId,\\n                inverted ? shares1 : shares0,\\n                inverted ? shares0 : shares1,\\n                depositParams.minSwapPrice,\\n                depositParams.maxSwapPrice,\\n                depositParams.wrap,\\n                depositParams.swap,\\n                depositParams.to,\\n                data.gasPrice,\\n                depositParams.gasLimit,\\n                timestamp + data.delay, // validAfterTimestamp\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    struct WithdrawParams {\\n        address token0;\\n        address token1;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\\n        require(!getWithdrawDisabled(data, pair), 'OS0A');\\n        checkOrderParams(\\n            data,\\n            withdrawParams.to,\\n            withdrawParams.gasLimit,\\n            withdrawParams.submitDeadline,\\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\\n        );\\n        require(withdrawParams.liquidity != 0, 'OS22');\\n\\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\\n        enqueueWithdrawOrder(\\n            data,\\n            WithdrawOrder(\\n                pairId,\\n                withdrawParams.liquidity,\\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\\n                withdrawParams.unwrap,\\n                withdrawParams.to,\\n                data.gasPrice,\\n                withdrawParams.gasLimit,\\n                timestampToUint32(block.timestamp) + data.delay\\n            )\\n        );\\n    }\\n\\n    struct SellParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function sell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = data.transferGasCosts[sellParams.tokenIn];\\n        require(tokenTransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            sellParams.to,\\n            sellParams.gasLimit,\\n            sellParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n        require(sellParams.amountIn != 0, 'OS24');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\\n        require(!getSellDisabled(data, pairAddress), 'OS13');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\\n            value = value.sub(sellParams.amountIn, 'OS1E');\\n        }\\n        allocateGasRefund(data, value, sellParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueSellOrder(\\n            data,\\n            SellOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                sellParams.amountOutMin,\\n                sellParams.wrapUnwrap,\\n                sellParams.to,\\n                data.gasPrice,\\n                sellParams.gasLimit,\\n                timestamp + data.delay,\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    struct BuyParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountInMax;\\n        uint256 amountOut;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function buy(\\n        Data storage data,\\n        BuyParams calldata buyParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = data.transferGasCosts[buyParams.tokenIn];\\n        require(tokenTransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            buyParams.to,\\n            buyParams.gasLimit,\\n            buyParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n        require(buyParams.amountOut != 0, 'OS23');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\\n        require(!getBuyDisabled(data, pairAddress), 'OS49');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\\n            value = value.sub(buyParams.amountInMax, 'OS1E');\\n        }\\n        allocateGasRefund(data, value, buyParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueBuyOrder(\\n            data,\\n            BuyOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                buyParams.amountOut,\\n                buyParams.wrapUnwrap,\\n                buyParams.to,\\n                data.gasPrice,\\n                buyParams.gasLimit,\\n                timestamp + data.delay,\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    function checkOrderParams(\\n        Data storage data,\\n        address to,\\n        uint256 gasLimit,\\n        uint32 submitDeadline,\\n        uint256 minGasLimit\\n    ) private view {\\n        require(submitDeadline >= block.timestamp, 'OS04');\\n        require(gasLimit <= data.maxGasLimit, 'OS3E');\\n        require(gasLimit >= minGasLimit, 'OS3D');\\n        require(to != address(0), 'OS26');\\n    }\\n\\n    function allocateGasRefund(\\n        Data storage data,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) private returns (uint256 futureFee) {\\n        futureFee = data.gasPrice.mul(gasLimit);\\n        require(value >= futureFee, 'OS1E');\\n        if (value > futureFee) {\\n            TransferHelper.safeTransferETH(msg.sender, value.sub(futureFee), data.transferGasCosts[address(0)]);\\n        }\\n    }\\n\\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\\n            data.gasPriceInertia\\n        );\\n        // we lower the precision for gas savings in order queue\\n        data.gasPrice = updated - (updated % 1e6);\\n    }\\n\\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\\n        require(_maxGasLimit != data.maxGasLimit, 'OS01');\\n        require(_maxGasLimit <= 10000000, 'OS2B');\\n        data.maxGasLimit = _maxGasLimit;\\n        emit MaxGasLimitSet(_maxGasLimit);\\n    }\\n\\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\\n        require(_gasPriceInertia != data.gasPriceInertia, 'OS01');\\n        require(_gasPriceInertia >= 1, 'OS35');\\n        data.gasPriceInertia = _gasPriceInertia;\\n        emit GasPriceInertiaSet(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\\n        require(_maxGasPriceImpact != data.maxGasPriceImpact, 'OS01');\\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS33');\\n        data.maxGasPriceImpact = _maxGasPriceImpact;\\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(\\n        Data storage data,\\n        address token,\\n        uint256 gasCost\\n    ) external {\\n        require(gasCost != data.transferGasCosts[token], 'OS01');\\n        data.transferGasCosts[token] = gasCost;\\n        emit TransferGasCostSet(token, gasCost);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './SafeMath.sol';\\nimport './TransferHelper.sol';\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n        address weth;\\n    }\\n\\n    function setWeth(Data storage data, address _weth) internal {\\n        data.weth = _weth;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            return share;\\n        }\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(totalTokenShares >= share, 'TS3A');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(totalTokenShares);\\n        data.totalShares[token] = totalTokenShares.sub(share);\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS03');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            uint256 totalTokenShares = data.totalShares[token];\\n            require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\\n            if (totalTokenShares == 0) {\\n                totalTokenShares = balanceBefore;\\n            }\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            require(balanceAfter > balanceBefore, 'TS2C');\\n            if (balanceBefore > 0) {\\n                uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\\n                data.totalShares[token] = newShares;\\n                return newShares - totalTokenShares;\\n            } else {\\n                data.totalShares[token] = balanceAfter;\\n                return balanceAfter;\\n            }\\n        }\\n    }\\n\\n    function onUnwrapFailed(\\n        Data storage data,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(data.weth).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(data.weth, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AddLiquidity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './TransferHelper.sol';\\nimport './SafeMath.sol';\\nimport './Math.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\n\\nlibrary AddLiquidity {\\n    using SafeMath for uint256;\\n\\n    function _quote(\\n        uint256 amount0,\\n        uint256 reserve0,\\n        uint256 reserve1\\n    ) private pure returns (uint256 amountB) {\\n        require(amount0 > 0, 'AL03');\\n        require(reserve0 > 0 && reserve1 > 0, 'AL07');\\n        amountB = amount0.mul(reserve1) / reserve0;\\n    }\\n\\n    function addLiquidity(\\n        address pair,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    ) internal view returns (uint256 amount0, uint256 amount1) {\\n        if (amount0Desired == 0 || amount1Desired == 0) {\\n            return (0, 0);\\n        }\\n        (uint256 reserve0, uint256 reserve1) = ITwapPair(pair).getReserves();\\n        if (reserve0 == 0 && reserve1 == 0) {\\n            (amount0, amount1) = (amount0Desired, amount1Desired);\\n        } else {\\n            uint256 amount1Optimal = _quote(amount0Desired, reserve0, reserve1);\\n            if (amount1Optimal <= amount1Desired) {\\n                (amount0, amount1) = (amount0Desired, amount1Optimal);\\n            } else {\\n                uint256 amount0Optimal = _quote(amount1Desired, reserve1, reserve0);\\n                assert(amount0Optimal <= amount0Desired);\\n                (amount0, amount1) = (amount0Optimal, amount1Desired);\\n            }\\n        }\\n    }\\n\\n    function addLiquidityAndMint(\\n        address pair,\\n        address to,\\n        address token0,\\n        address token1,\\n        uint256 amount0Desired,\\n        uint256 amount1Desired\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        (uint256 amount0, uint256 amount1) = addLiquidity(pair, amount0Desired, amount1Desired);\\n        if (amount0 == 0 || amount1 == 0) {\\n            return (amount0Desired, amount1Desired);\\n        }\\n        TransferHelper.safeTransfer(token0, pair, amount0);\\n        TransferHelper.safeTransfer(token1, pair, amount1);\\n        ITwapPair(pair).mint(to);\\n\\n        amount0Left = amount0Desired.sub(amount0);\\n        amount1Left = amount1Desired.sub(amount1);\\n    }\\n\\n    function swapDeposit0(\\n        address pair,\\n        address token0,\\n        uint256 amount0,\\n        uint256 minSwapPrice,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount0In = ITwapPair(pair).getDepositAmount0In(amount0, data);\\n        amount1Left = ITwapPair(pair).getSwapAmount1Out(amount0In, data);\\n        if (amount1Left == 0) {\\n            return (amount0, amount1Left);\\n        }\\n        uint256 price = getPrice(amount0In, amount1Left, pair);\\n        require(minSwapPrice == 0 || price >= minSwapPrice, 'AL15');\\n        TransferHelper.safeTransfer(token0, pair, amount0In);\\n        ITwapPair(pair).swap(0, amount1Left, address(this), data);\\n        amount0Left = amount0.sub(amount0In);\\n    }\\n\\n    function swapDeposit1(\\n        address pair,\\n        address token1,\\n        uint256 amount1,\\n        uint256 maxSwapPrice,\\n        bytes calldata data\\n    ) external returns (uint256 amount0Left, uint256 amount1Left) {\\n        uint256 amount1In = ITwapPair(pair).getDepositAmount1In(amount1, data);\\n        amount0Left = ITwapPair(pair).getSwapAmount0Out(amount1In, data);\\n        if (amount0Left == 0) {\\n            return (amount0Left, amount1);\\n        }\\n        uint256 price = getPrice(amount0Left, amount1In, pair);\\n        require(maxSwapPrice == 0 || price <= maxSwapPrice, 'AL16');\\n        TransferHelper.safeTransfer(token1, pair, amount1In);\\n        ITwapPair(pair).swap(amount0Left, 0, address(this), data);\\n        amount1Left = amount1.sub(amount1In);\\n    }\\n\\n    function getPrice(\\n        uint256 amount0,\\n        uint256 amount1,\\n        address pair\\n    ) internal view returns (uint256) {\\n        ITwapOracle oracle = ITwapOracle(ITwapPair(pair).oracle());\\n        return amount1.mul(uint256(oracle.decimalsConverter())).div(amount0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/WithdrawHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './Orders.sol';\\n\\nlibrary WithdrawHelper {\\n    using SafeMath for uint256;\\n\\n    function _transferToken(\\n        uint256 balanceBefore,\\n        address token,\\n        address to\\n    ) internal {\\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\\n        TransferHelper.safeTransfer(token, to, tokenAmount);\\n    }\\n\\n    function _unwrapWeth(\\n        uint256 ethAmount,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    ) internal returns (bool) {\\n        IWETH(weth).withdraw(ethAmount);\\n        (bool success, ) = to.call{ value: ethAmount, gas: gasLimit }('');\\n        return success;\\n    }\\n\\n    function withdrawAndUnwrap(\\n        address token0,\\n        address token1,\\n        address pair,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    )\\n        external\\n        returns (\\n            bool,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        bool isToken0Weth = token0 == weth;\\n        address otherToken = isToken0Weth ? token1 : token0;\\n\\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\\n        (uint256 amount0, uint256 amount1) = ITwapPair(pair).burn(address(this));\\n        _transferToken(balanceBefore, otherToken, to);\\n\\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to, gasLimit);\\n\\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './IERC20.sol';\\n\\ninterface ITwapERC20 is IERC20 {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IReserves {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface ITwapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event OwnerSet(address owner);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\\n    }\\n\\n    function safeTransferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal {\\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\\n        require(success, 'TH3F');\\n    }\\n\\n    function transferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal returns (bool success) {\\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TwapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './interfaces/ITwapPair.sol';\\nimport './libraries/Reserves.sol';\\nimport './TwapLPToken.sol';\\nimport './libraries/Math.sol';\\nimport './interfaces/IERC20.sol';\\nimport './interfaces/ITwapFactory.sol';\\nimport './interfaces/ITwapOracle.sol';\\n\\ncontract TwapPair is Reserves, TwapLPToken, ITwapPair {\\n    using SafeMath for uint256;\\n\\n    uint256 private constant PRECISION = 10**18;\\n\\n    uint256 public override mintFee = 0;\\n    uint256 public override burnFee = 0;\\n    uint256 public override swapFee = 0;\\n\\n    uint256 public constant override MINIMUM_LIQUIDITY = 10**3;\\n\\n    bytes4 private constant SELECTOR = bytes4(keccak256(bytes('transfer(address,uint256)')));\\n\\n    address public immutable override factory;\\n    address public override token0;\\n    address public override token1;\\n    address public override oracle;\\n    address public override trader;\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, 'TP06');\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    function isContract(address addr) private view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n        return size > 0;\\n    }\\n\\n    function setMintFee(uint256 fee) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(fee != mintFee, 'TP01');\\n        mintFee = fee;\\n        emit SetMintFee(fee);\\n    }\\n\\n    function setBurnFee(uint256 fee) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(fee != burnFee, 'TP01');\\n        burnFee = fee;\\n        emit SetBurnFee(fee);\\n    }\\n\\n    function setSwapFee(uint256 fee) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(fee != swapFee, 'TP01');\\n        swapFee = fee;\\n        emit SetSwapFee(fee);\\n    }\\n\\n    function setOracle(address _oracle) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(_oracle != oracle, 'TP01');\\n        require(_oracle != address(0), 'TP02');\\n        require(isContract(_oracle), 'TP1D');\\n        oracle = _oracle;\\n        emit SetOracle(_oracle);\\n    }\\n\\n    function setTrader(address _trader) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(_trader != trader, 'TP01');\\n        // Allow trader to be set as address(0) to disable interaction\\n        trader = _trader;\\n        emit SetTrader(_trader);\\n    }\\n\\n    function collect(address to) external override lock {\\n        require(msg.sender == factory, 'TP00');\\n        require(to != address(0), 'TP02');\\n        (uint256 fee0, uint256 fee1) = getFees();\\n        if (fee0 > 0) _safeTransfer(token0, to, fee0);\\n        if (fee1 > 0) _safeTransfer(token1, to, fee1);\\n        setFees(0, 0);\\n        _sync();\\n    }\\n\\n    function _safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) private {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TP05');\\n    }\\n\\n    function canTrade(address user) private view returns (bool) {\\n        return user == trader || user == factory;\\n    }\\n\\n    constructor() {\\n        factory = msg.sender;\\n    }\\n\\n    // called once by the factory at time of deployment\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external override {\\n        require(msg.sender == factory, 'TP00');\\n        require(_oracle != address(0), 'TP02');\\n        require(isContract(_oracle), 'TP1D');\\n        require(isContract(_token0) && isContract(_token1), 'TP10');\\n        token0 = _token0;\\n        token1 = _token1;\\n        oracle = _oracle;\\n        trader = _trader;\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) external override lock returns (uint256 liquidityOut) {\\n        require(canTrade(msg.sender), 'TP0C');\\n        require(to != address(0), 'TP02');\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\\n        uint256 amount0In = balance0.sub(reserve0);\\n        uint256 amount1In = balance1.sub(reserve1);\\n\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        if (_totalSupply == 0) {\\n            liquidityOut = Math.sqrt(amount0In.mul(amount1In)).sub(MINIMUM_LIQUIDITY);\\n            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\\n        } else {\\n            liquidityOut = Math.min(amount0In.mul(_totalSupply) / reserve0, amount1In.mul(_totalSupply) / reserve1);\\n        }\\n\\n        require(liquidityOut > 0, 'TP38');\\n        if (mintFee > 0) {\\n            uint256 fee = liquidityOut.mul(mintFee).div(PRECISION);\\n            liquidityOut = liquidityOut.sub(fee);\\n            _mint(factory, fee);\\n        }\\n        _mint(to, liquidityOut);\\n\\n        setReserves(balance0, balance1);\\n\\n        emit Mint(msg.sender, amount0In, amount1In, liquidityOut, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(address to) external override lock returns (uint256 amount0Out, uint256 amount1Out) {\\n        require(canTrade(msg.sender), 'TP0C');\\n        require(to != address(0), 'TP02');\\n        uint256 _totalSupply = totalSupply; // gas savings\\n        require(_totalSupply > 0, 'TP36');\\n        address _token0 = token0; // gas savings\\n        address _token1 = token1; // gas savings\\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\\n        uint256 liquidityIn = balanceOf[address(this)];\\n\\n        if (msg.sender != factory && burnFee > 0) {\\n            uint256 fee = liquidityIn.mul(burnFee).div(PRECISION);\\n            liquidityIn = liquidityIn.sub(fee);\\n            _transfer(address(this), factory, fee);\\n        }\\n        _burn(address(this), liquidityIn);\\n\\n        amount0Out = liquidityIn.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1Out = liquidityIn.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n        require(amount0Out > 0 && amount1Out > 0, 'TP39');\\n\\n        _safeTransfer(_token0, to, amount0Out);\\n        _safeTransfer(_token1, to, amount1Out);\\n\\n        (balance0, balance1) = getBalances(token0, token1);\\n        setReserves(balance0, balance1);\\n\\n        emit Burn(msg.sender, amount0Out, amount1Out, liquidityIn, to);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external override lock {\\n        require(canTrade(msg.sender), 'TP0C');\\n        require(to != address(0), 'TP02');\\n        require((amount0Out > 0 && amount1Out == 0) || (amount1Out > 0 && amount0Out == 0), 'TP31');\\n        (uint112 _reserve0, uint112 _reserve1) = getReserves();\\n        require(amount0Out < _reserve0 && amount1Out < _reserve1, 'TP07');\\n\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = token0;\\n            address _token1 = token1;\\n            require(to != _token0 && to != _token1, 'TP2D');\\n            if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n            if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n        }\\n        (uint256 balance0, uint256 balance1) = getBalances(token0, token1);\\n\\n        if (amount0Out > 0) {\\n            // trading token1 for token0\\n            require(balance1 > _reserve1, 'TP08');\\n            uint256 amount1In = balance1 - _reserve1;\\n\\n            emit Swap(msg.sender, 0, amount1In, amount0Out, 0, to);\\n\\n            uint256 fee1 = amount1In.mul(swapFee).div(PRECISION);\\n            uint256 balance1After = balance1.sub(fee1);\\n            uint256 balance0After = ITwapOracle(oracle).tradeY(balance1After, _reserve0, _reserve1, data);\\n            require(balance0 >= balance0After, 'TP2E');\\n            uint256 fee0 = balance0.sub(balance0After);\\n            addFees(fee0, fee1);\\n            setReserves(balance0After, balance1After);\\n        } else {\\n            // trading token0 for token1\\n            require(balance0 > _reserve0, 'TP08');\\n            uint256 amount0In = balance0 - _reserve0;\\n\\n            emit Swap(msg.sender, amount0In, 0, 0, amount1Out, to);\\n\\n            uint256 fee0 = amount0In.mul(swapFee).div(PRECISION);\\n            uint256 balance0After = balance0.sub(fee0);\\n            uint256 balance1After = ITwapOracle(oracle).tradeX(balance0After, _reserve0, _reserve1, data);\\n            require(balance1 >= balance1After, 'TP2E');\\n            uint256 fee1 = balance1.sub(balance1After);\\n            addFees(fee0, fee1);\\n            setReserves(balance0After, balance1After);\\n        }\\n    }\\n\\n    function sync() external override lock {\\n        require(canTrade(msg.sender), 'TP0C');\\n        _sync();\\n    }\\n\\n    // force reserves to match balances\\n    function _sync() internal {\\n        syncReserves(token0, token1);\\n        uint256 tokens = balanceOf[address(this)];\\n        if (tokens > 0) {\\n            _transfer(address(this), factory, tokens);\\n        }\\n    }\\n\\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data)\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount0In)\\n    {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        uint256 balance1After = uint256(reserve1).sub(amount1Out);\\n        uint256 balance0After = ITwapOracle(oracle).tradeY(balance1After, reserve0, reserve1, data);\\n        return balance0After.sub(uint256(reserve0)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\\n    }\\n\\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data)\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount1In)\\n    {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        uint256 balance0After = uint256(reserve0).sub(amount0Out);\\n        uint256 balance1After = ITwapOracle(oracle).tradeX(balance0After, reserve0, reserve1, data);\\n        return balance1After.add(1).sub(uint256(reserve1)).mul(PRECISION).ceil_div(PRECISION.sub(swapFee));\\n    }\\n\\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data)\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount0Out)\\n    {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        uint256 fee = amount1In.mul(swapFee).div(PRECISION);\\n        uint256 balance0After = ITwapOracle(oracle).tradeY(\\n            uint256(reserve1).add(amount1In).sub(fee),\\n            reserve0,\\n            reserve1,\\n            data\\n        );\\n        return uint256(reserve0).sub(balance0After);\\n    }\\n\\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data)\\n        public\\n        view\\n        override\\n        returns (uint256 swapAmount1Out)\\n    {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        uint256 fee = amount0In.mul(swapFee).div(PRECISION);\\n        uint256 balance1After = ITwapOracle(oracle).tradeX(\\n            uint256(reserve0).add(amount0In).sub(fee),\\n            reserve0,\\n            reserve1,\\n            data\\n        );\\n        return uint256(reserve1).sub(balance1After);\\n    }\\n\\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view override returns (uint256) {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        return ITwapOracle(oracle).depositTradeXIn(amount0, reserve0, reserve1, data);\\n    }\\n\\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view override returns (uint256) {\\n        (uint112 reserve0, uint112 reserve1) = getReserves();\\n        return ITwapOracle(oracle).depositTradeYIn(amount1, reserve0, reserve1, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Reserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/IReserves.sol';\\nimport '../interfaces/IERC20.sol';\\nimport '../libraries/SafeMath.sol';\\n\\ncontract Reserves is IReserves {\\n    using SafeMath for uint256;\\n\\n    uint112 private reserve0;\\n    uint112 private reserve1;\\n\\n    uint112 private fee0;\\n    uint112 private fee1;\\n\\n    function getReserves() public view override returns (uint112, uint112) {\\n        return (reserve0, reserve1);\\n    }\\n\\n    function setReserves(uint256 balance0MinusFee, uint256 balance1MinusFee) internal {\\n        require(balance0MinusFee != 0 && balance1MinusFee != 0, 'RS09');\\n        reserve0 = balance0MinusFee.toUint112();\\n        reserve1 = balance1MinusFee.toUint112();\\n    }\\n\\n    function syncReserves(address token0, address token1) internal {\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n\\n        uint256 oldBalance0 = uint256(reserve0) + fee0;\\n        uint256 oldBalance1 = uint256(reserve1) + fee1;\\n\\n        if (balance0 != oldBalance0 || balance1 != oldBalance1) {\\n            if (oldBalance0 != 0) {\\n                fee0 = (balance0.mul(fee0).div(oldBalance0)).toUint112();\\n            }\\n            if (oldBalance1 != 0) {\\n                fee1 = (balance1.mul(fee1).div(oldBalance1)).toUint112();\\n            }\\n\\n            setReserves(balance0.sub(fee0), balance1.sub(fee1));\\n        }\\n    }\\n\\n    function getFees() public view override returns (uint256, uint256) {\\n        return (fee0, fee1);\\n    }\\n\\n    function addFees(uint256 _fee0, uint256 _fee1) internal {\\n        setFees(_fee0.add(fee0), _fee1.add(fee1));\\n    }\\n\\n    function setFees(uint256 _fee0, uint256 _fee1) internal {\\n        fee0 = _fee0.toUint112();\\n        fee1 = _fee1.toUint112();\\n    }\\n\\n    function getBalances(address token0, address token1) internal returns (uint256, uint256) {\\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\\n        if (fee0 > balance0) {\\n            fee0 = uint112(balance0);\\n        }\\n        if (fee1 > balance1) {\\n            fee1 = uint112(balance1);\\n        }\\n        return (balance0.sub(fee0), balance1.sub(fee1));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TwapLPToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './libraries/AbstractERC20.sol';\\n\\ncontract TwapLPToken is AbstractERC20 {\\n    constructor() {\\n        name = 'Twap LP';\\n        symbol = 'TWAP-LP';\\n        decimals = 18;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/AbstractERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/ITwapERC20.sol';\\nimport './SafeMath.sol';\\n\\nabstract contract AbstractERC20 is ITwapERC20 {\\n    using SafeMath for uint256;\\n\\n    string public override name;\\n    string public override symbol;\\n    uint8 public override decimals;\\n\\n    uint256 public override totalSupply;\\n    mapping(address => uint256) public override balanceOf;\\n    mapping(address => mapping(address => uint256)) public override allowance;\\n\\n    bytes32 public constant DOMAIN_TYPEHASH =\\n        keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)');\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant override PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n    mapping(address => uint256) public override nonces;\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply = totalSupply.add(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        totalSupply = totalSupply.sub(value);\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        allowance[owner][spender] = value;\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        balanceOf[from] = balanceOf[from].sub(value);\\n        balanceOf[to] = balanceOf[to].add(value);\\n        emit Transfer(from, to, value);\\n    }\\n\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        _approve(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external override returns (bool) {\\n        _approve(msg.sender, spender, allowance[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external override returns (bool) {\\n        uint256 currentAllowance = allowance[msg.sender][spender];\\n        require(currentAllowance >= subtractedValue, 'TA48');\\n        _approve(msg.sender, spender, currentAllowance.sub(subtractedValue));\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n        _transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external override returns (bool) {\\n        if (allowance[from][msg.sender] != uint256(-1)) {\\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\\n        }\\n        _transfer(from, to, value);\\n        return true;\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external override {\\n        require(deadline >= block.timestamp, 'TA04');\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                '\\\\x19\\\\x01',\\n                getDomainSeparator(),\\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'TA2F');\\n        _approve(owner, spender, value);\\n    }\\n\\n    function getDomainSeparator() public view returns (bytes32) {\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        return\\n            keccak256(\\n                abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes('1')), chainId, address(this))\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TwapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './interfaces/ITwapFactory.sol';\\nimport './TwapPair.sol';\\n\\ncontract TwapFactory is ITwapFactory {\\n    mapping(address => mapping(address => address)) public override getPair;\\n    address[] public override allPairs;\\n    address public override owner;\\n\\n    constructor() {\\n        owner = msg.sender;\\n\\n        emit OwnerSet(msg.sender);\\n    }\\n\\n    function allPairsLength() external view override returns (uint256) {\\n        return allPairs.length;\\n    }\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external override returns (address pair) {\\n        require(msg.sender == owner, 'TF00');\\n        require(tokenA != tokenB, 'TF3B');\\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0), 'TF02');\\n        require(getPair[token0][token1] == address(0), 'TF18'); // single check is sufficient\\n        bytes memory bytecode = type(TwapPair).creationCode;\\n        bytes32 salt = keccak256(abi.encodePacked(token0, token1));\\n        assembly {\\n            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n        }\\n        ITwapPair(pair).initialize(token0, token1, oracle, trader);\\n        getPair[token0][token1] = pair;\\n        getPair[token1][token0] = pair; // populate mapping in the reverse direction\\n        allPairs.push(pair);\\n        emit PairCreated(token0, token1, pair, allPairs.length);\\n    }\\n\\n    function setOwner(address _owner) external override {\\n        require(msg.sender == owner, 'TF00');\\n        require(_owner != owner, 'TF01');\\n        require(_owner != address(0), 'TF02');\\n        owner = _owner;\\n        emit OwnerSet(_owner);\\n    }\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).setMintFee(fee);\\n    }\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).setBurnFee(fee);\\n    }\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).setSwapFee(fee);\\n    }\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).setOracle(oracle);\\n    }\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).setTrader(trader);\\n    }\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        _getPair(tokenA, tokenB).collect(to);\\n    }\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external override {\\n        require(msg.sender == owner, 'TF00');\\n        ITwapPair pair = _getPair(tokenA, tokenB);\\n        pair.transfer(address(pair), amount);\\n        pair.burn(to);\\n    }\\n\\n    function _getPair(address tokenA, address tokenB) internal view returns (ITwapPair pair) {\\n        pair = ITwapPair(getPair[tokenA][tokenB]);\\n        require(address(pair) != address(0), 'TF19');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/libraries/AddLiquidity.sol\": {\r\n        \"AddLiquidity\": \"0xb291730099d3ac9975abd4003ba3bd47401fd2fd\"\r\n      },\r\n      \"contracts/libraries/Orders.sol\": {\r\n        \"Orders\": \"0x6336788a85f54d8856782d58c1ca63c7d3844531\"\r\n      },\r\n      \"contracts/libraries/TokenShares.sol\": {\r\n        \"TokenShares\": \"0xb28c804e3dacff80701bbbafd106dbfb416a5168\"\r\n      },\r\n      \"contracts/libraries/WithdrawHelper.sol\": {\r\n        \"WithdrawHelper\": \"0x6195015b38773f468dd43620dd5a64e9bb63c2e3\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bot\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isBot\",\"type\":\"bool\"}],\"name\":\"BotSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"delay\",\"type\":\"uint256\"}],\"name\":\"DelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EthRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"Execute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"GasPriceInertiaSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"MaxGasLimitSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"MaxGasPriceImpactSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"OrderDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasSpent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethRefunded\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"RefundFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"TransferGasCostSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnwrapFailed\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.BuyOrder\",\"name\":\"buyOrder\",\"type\":\"tuple\"}],\"name\":\"_executeBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.DepositOrder\",\"name\":\"depositOrder\",\"type\":\"tuple\"}],\"name\":\"_executeDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.SellOrder\",\"name\":\"sellOrder\",\"type\":\"tuple\"}],\"name\":\"_executeSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.WithdrawOrder\",\"name\":\"withdrawOrder\",\"type\":\"tuple\"}],\"name\":\"_executeWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"_refundLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"}],\"name\":\"_refundTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.BuyParams\",\"name\":\"buyParams\",\"type\":\"tuple\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"delay\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.DepositParams\",\"name\":\"depositParams\",\"type\":\"tuple\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasPriceInertia\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getBuyDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getBuyOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareInMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.BuyOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getDepositDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getDepositOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"share0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"share1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSwapPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"swap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.DepositOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrder\",\"outputs\":[{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getOrderStatus\",\"outputs\":[{\"internalType\":\"enum Orders.OrderStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getSellDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getSellOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"inverse\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shareIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"priceAccumulator\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"timestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.SellOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTransferGasCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"}],\"name\":\"getWithdrawDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"getWithdrawOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"pairId\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"validAfterTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.WithdrawOrder\",\"name\":\"order\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"isOrderCanceled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastProcessedOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGasPriceImpact\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newestOrderId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"name\":\"retryRefund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"wrapUnwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.SellParams\",\"name\":\"sellParams\",\"type\":\"tuple\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bot\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isBot\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_delay\",\"type\":\"uint32\"}],\"name\":\"setDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasPriceInertia\",\"type\":\"uint256\"}],\"name\":\"setGasPriceInertia\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxGasPriceImpact\",\"type\":\"uint256\"}],\"name\":\"setMaxGasPriceImpact\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pair\",\"type\":\"address\"},{\"internalType\":\"enum Orders.OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"}],\"name\":\"setOrderDisabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasCost\",\"type\":\"uint256\"}],\"name\":\"setTransferGasCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unwrap\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"submitDeadline\",\"type\":\"uint32\"}],\"internalType\":\"struct Orders.WithdrawParams\",\"name\":\"withdrawParams\",\"type\":\"tuple\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TwapDelay", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c480b33ee5229de3fbdfad1d2dcd3f3bad0c56c6000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000003a1d749fa4a9e650fce844ff1c58c5faf7e2a9d1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}