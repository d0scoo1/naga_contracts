{"status": "1", "message": "OK", "result": [{"SourceCode": "/* SPDX-License-Identifier: UNLICENSED*/\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n// import \"./JHEToken.sol\";\r\ncontract JHEToken {\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {}\r\n}\r\n\r\ninterface IPriceFeed {\r\n    function latestRoundData() external view returns (\r\n        uint80 roundId,\r\n        uint256 answer,\r\n        uint256 startedAt,\r\n        uint256 updatedAt,\r\n        uint80 answeredInRound\r\n    );\r\n}\r\n\r\ncontract JHETokenSale {\r\n    using SafeMath for uint;\r\n    address public owner;\r\n    address payable public etherWallet;\r\n    JHEToken public tokenContract;\r\n    uint256 public tokensSold;\r\n    uint256 public totalFeeAmount;\r\n\r\n    _Fee[] public feeDistributions;   // array of _Fee struct\r\n\r\n    struct _Fee {\r\n        uint256 id;\r\n        string name;\r\n        address payable wallet;\r\n        uint256 percent;\r\n        bool active;\r\n    }\r\n\r\n    IPriceFeed public priceFeed;\r\n    uint256 public tokenPrice; // 100000000 = 1 usd\r\n\r\n\r\n    event Sell(address _buyer, uint256 _amount);\r\n\r\n    constructor(JHEToken _tokenContract, address payable _etherWallet, IPriceFeed _priceFeed, uint256 _tokenPrice) {\r\n        owner = msg.sender;\r\n        tokenContract = _tokenContract;\r\n        tokenPrice = _tokenPrice;\r\n        totalFeeAmount = 0;\r\n        etherWallet = _etherWallet;\r\n\r\n        priceFeed = _priceFeed;\r\n    }\r\n\r\n    function getEthAmount() public view returns(uint256) {\r\n        (,uint256 price, , , ) = priceFeed.latestRoundData();\r\n        return tokenPrice*1e18/price;\r\n    }\r\n\r\n    // Modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"owner only\");\r\n        _;\r\n    }\r\n    modifier noBalance() {\r\n        // require(totalFeeAmount == 0, \"fee not null, transfer funds first\");\r\n        require(address(this).balance == 0, \"balance not null, transfer funds first\");\r\n        _;\r\n    }\r\n\r\n    function buyTokens(uint256 _numberOfTokens) public payable {\r\n        uint256 price = getEthAmount();\r\n        uint256 tokenTotalPrice = _numberOfTokens*price/10**18;\r\n        require(tokenTotalPrice <= msg.value, \"Insufficent value\");\r\n        // calculate the total fee amount\r\n        uint256 totalFeePercent = getTotalFeePercent ();\r\n        uint256 _totalFeeAmount = tokenTotalPrice.mul(totalFeePercent).div(100000);  // FEE: 100000 = 100%\r\n        totalFeeAmount = totalFeeAmount.add (_totalFeeAmount);\r\n\r\n        require(msg.value >= tokenTotalPrice.add(_totalFeeAmount),'incorrect amount');\r\n        require(tokenContract.balanceOf(address(this)) >= _numberOfTokens,'contract has not enough token');\r\n        require(tokenContract.transfer(msg.sender, _numberOfTokens),'transfer error');\r\n\r\n        // send ether\r\n        uint256 ethAmount = msg.value;\r\n        _transferPayments(ethAmount);\r\n\r\n        tokensSold += _numberOfTokens;\r\n\r\n        emit Sell(msg.sender, _numberOfTokens);\r\n    }\r\n\r\n    // Transfer ether payments\r\n    function _transferPayments(uint256 ethAmount) internal {\r\n        require(ethAmount > 0, \"no ether recieved\");\r\n\r\n        // transfer owner's ether deducted from total Fee Amount\r\n        uint256 _ownerFunds = ethAmount.sub(totalFeeAmount);\r\n        etherWallet.transfer(_ownerFunds);\r\n\r\n        // distribute fees\r\n        uint256 feesCount = getFeeDistributionsCount();\r\n        _Fee[] storage fees = feeDistributions;\r\n\r\n        for (uint i = 0; i < feesCount; i++){\r\n            if (fees[i].active){\r\n                uint feeValue = _ownerFunds.mul(fees[i].percent).div(100000);  // FEE: 100000 = 100%\r\n                fees[i].wallet.transfer(feeValue);\r\n            }\r\n        }\r\n\r\n        // if eth rest: in case of fee deactivated...\r\n        if (address(this).balance != 0){\r\n            etherWallet.transfer(address(this).balance);\r\n        }\r\n        totalFeeAmount = 0;\r\n    }\r\n\r\n\r\n    function endSale() public onlyOwner{\r\n        require(tokenContract.transfer(owner, tokenContract.balanceOf(address(this))),'transfer error');\r\n    }\r\n\r\n    // Transfer funds\r\n    function transferFunds() public onlyOwner {\r\n        // require(address(this).balance > 0, \"no funds\");\r\n\r\n        uint256 totalFunds = address(this).balance;\r\n\r\n        // transfer owner's ether deducted from total Fee Amount\r\n        uint256 _ownerFunds = totalFunds.sub(totalFeeAmount);\r\n        etherWallet.transfer(_ownerFunds);\r\n\r\n        // distribute fees\r\n        uint256 feesCount = getFeeDistributionsCount();\r\n        _Fee[] storage fees = feeDistributions;\r\n\r\n        for (uint i = 0; i < feesCount; i++){\r\n            if (fees[i].active){\r\n                uint feeValue = _ownerFunds.mul(fees[i].percent).div(100000);  // FEE: 100000 = 100%\r\n                fees[i].wallet.transfer(feeValue);\r\n            }\r\n        }\r\n\r\n        // if eth rest: in case of fee deactivated...\r\n        if (address(this).balance != 0){\r\n            etherWallet.transfer(address(this).balance);\r\n        }\r\n        totalFeeAmount = 0;\r\n    }\r\n\r\n    /*\r\n    *       FEE: \r\n    *              1 = 0.001%\r\n    *           1000 = 1%\r\n    *         100000 = 100%\r\n    */\r\n    function setFeeDistributions(address payable _feeWallet, string memory _name, uint256 _percent) public  onlyOwner noBalance{\r\n        require(_feeWallet != address(0), \"address not valid\");\r\n        // emit FeePercentChanged(feePercent, _newFeePercent);\r\n\r\n        _Fee[] storage fees = feeDistributions;\r\n        // uint256 feesCount = fees.length;\r\n        uint256 feesCount = getFeeDistributionsCount();\r\n\r\n        bool feeExiste = false;\r\n\r\n        uint totalFeePercent = getTotalFeePercent ();\r\n        totalFeePercent = totalFeePercent.add(_percent);\r\n        require(totalFeePercent <= 100000, \"total fee cannot exceed 100\");\r\n\r\n        for (uint i = 0; i < feesCount; i++){\r\n            if (fees[i].wallet == _feeWallet){\r\n                fees[i].name    = _name;\r\n                fees[i].percent = _percent;\r\n                fees[i].active  = true;\r\n\r\n                feeExiste = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // fee not found => add as new fee\r\n        if (!feeExiste){\r\n            _Fee memory fee;\r\n\r\n            fee.id = (feesCount + 1);\r\n            fee.name = _name;\r\n            fee.wallet = _feeWallet;\r\n            fee.percent = _percent;\r\n            fee.active = true;\r\n\r\n            fees.push(fee);\r\n        }\r\n    }\r\n\r\n    function getFeeDistributionsCount() public view returns(uint) {\r\n        _Fee[] storage fees = feeDistributions;\r\n        return fees.length;\r\n    }\r\n\r\n    function getTotalFeePercent () public view returns (uint){\r\n        uint256 totalFeePercent = 0;\r\n        uint256 feesCount = getFeeDistributionsCount();\r\n        _Fee[] storage fees = feeDistributions;\r\n\r\n        for (uint i = 0; i < feesCount; i++){\r\n            if (fees[i].active){\r\n                totalFeePercent = totalFeePercent.add(fees[i].percent);\r\n            }\r\n        }\r\n\r\n        return totalFeePercent;\r\n    }\r\n\r\n    function deActivateFeeWallet(address _feeWallet) public onlyOwner {\r\n        require(_feeWallet != address(0), \"address not valid\");\r\n        // emit FeePercentChanged(feePercent, _newFeePercent);\r\n\r\n        _Fee[] storage fees = feeDistributions;\r\n        // uint256 feesCount = fees.length;\r\n        uint256 feesCount = getFeeDistributionsCount();\r\n        for (uint i = 0; i < feesCount; i++){\r\n            if (fees[i].wallet == _feeWallet){\r\n                fees[i].active = false;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Transfer Owner\r\n    function transferOwnership(address payable _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n    function _transferOwnership(address payable _newOwner) internal {\r\n        require(_newOwner != address(0), \"address not valid\");\r\n        owner = _newOwner;\r\n    }\r\n\r\n    // Transfer ether wallet\r\n    function transferEtherWallet(address payable _newEtherWallet) public onlyOwner {\r\n        _transferEtherWallet(_newEtherWallet);\r\n    }\r\n    function _transferEtherWallet(address payable _newEtherWallet) internal {\r\n        require(_newEtherWallet != address(0), \"address not valid\");\r\n        etherWallet = _newEtherWallet;\r\n    }\r\n\r\n    // set token price\r\n    function setTokenPrice(uint256 _tokenPrice) public onlyOwner {\r\n        require(_tokenPrice != 0, \"token price is null\");\r\n        tokenPrice = _tokenPrice;\r\n    }\r\n\r\n    // set price feed\r\n    function setPriceFeed(IPriceFeed _priceFeed) public onlyOwner {\r\n        priceFeed = _priceFeed;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract JHEToken\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"_etherWallet\",\"type\":\"address\"},{\"internalType\":\"contract IPriceFeed\",\"name\":\"_priceFeed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"buyTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeWallet\",\"type\":\"address\"}],\"name\":\"deActivateFeeWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"feeDistributions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEthAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeDistributionsCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_feeWallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"setFeeDistributions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"internalType\":\"contract JHEToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newEtherWallet\",\"type\":\"address\"}],\"name\":\"transferEtherWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "JHETokenSale", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000075579d1c935bc600c7b4e30c54ecf86e703e5d880000000000000000000000001daccb936d45dcb63ef829f151cb33dc9d5373000000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b84190000000000000000000000000000000000000000000000000000000003938700", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b4bc1687ebefc7d8c88bebd4a4980b3459a851ec8f49d1c1f66992a80479177b"}]}