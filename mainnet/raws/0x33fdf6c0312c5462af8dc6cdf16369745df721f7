{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: localhost/SetExchange/common/StaticCaller.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n/**\r\n * @title StaticCaller\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract StaticCaller {\r\n\r\n    function staticCall(address target, bytes memory data) internal view returns (bool result)\r\n    {\r\n        assembly {\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), mload(0x40), 0)\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function staticCallUint(address target, bytes memory data) internal view returns (uint ret)\r\n    {\r\n        bool result;\r\n        assembly {\r\n            let size := 0x20\r\n            let free := mload(0x40)\r\n            result := staticcall(gas(), target, add(data, 0x20), mload(data), free, size)\r\n            ret := mload(free)\r\n        }\r\n        require(result, \"Static call failed\");\r\n        return ret;\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/common/EIP1271.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\nabstract contract ERC1271 {\r\n\r\n  // bytes4(keccak256(\"isValidSignature(bytes,bytes)\")\r\n  bytes4 constant internal MAGICVALUE = 0x20c13b0b;\r\n\r\n  /**\r\n   * @dev Should return whether the signature provided is valid for the provided data\r\n   * @param _data Arbitrary length data signed on the behalf of address(this)\r\n   * @param _signature Signature byte array associated with _data\r\n   *\r\n   * MUST return the bytes4 magic value 0x20c13b0b when function passes.\r\n   * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\r\n   * MUST allow external calls\r\n   */\r\n  function isValidSignature(\r\n      bytes memory _data,\r\n      bytes memory _signature)\r\n      virtual\r\n      public\r\n      view\r\n      returns (bytes4 magicValue);\r\n}\r\n\r\n// File: localhost/SetExchange/common/EIP712.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n/**\r\n * @title EIP712\r\n * @author Wyvern Protocol Developers\r\n */\r\ncontract EIP712 {\r\n\r\n    struct EIP712Domain {\r\n        string  name;\r\n        string  version;\r\n        uint256 chainId;\r\n        address verifyingContract;\r\n    }\r\n\r\n    bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n        \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n    );\r\n\r\n    bytes32 DOMAIN_SEPARATOR;\r\n\r\n    function hash(EIP712Domain memory eip712Domain)\r\n        internal\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encode(\r\n            EIP712DOMAIN_TYPEHASH,\r\n            keccak256(bytes(eip712Domain.name)),\r\n            keccak256(bytes(eip712Domain.version)),\r\n            eip712Domain.chainId,\r\n            eip712Domain.verifyingContract\r\n        ));\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/common/ReentrancyGuarded.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\ncontract ReentrancyGuarded {\r\n\r\n    bool reentrancyLock = false;\r\n    modifier reentrancyGuard {\r\n        if (reentrancyLock) {\r\n            revert();\r\n        }\r\n        reentrancyLock = true;\r\n        _;\r\n        reentrancyLock = false;\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: localhost/SetExchange/common/TokenRecipient.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract TokenRecipient{\r\n    event ReceivedEther(address indexed sender, uint amount);\r\n    event ReceivedTokens(address indexed from, uint256 value, address indexed token, bytes extraData);\r\n\r\n    function receiveApproval(address from, uint256 value, address token, bytes memory extraData) public {\r\n        IERC20 t = IERC20(token);\r\n        require(t.transferFrom(from, address(this), value), \"ERC20 token transfer failed\");\r\n        emit ReceivedTokens(from, value, token, extraData);\r\n    }\r\n   \r\n    fallback () payable external {\r\n        emit ReceivedEther(msg.sender, msg.value);\r\n    }\r\n    receive () payable external {\r\n        emit ReceivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n// File: localhost/SetExchange/registry/proxy/OwnedUpgradeabilityStorage.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\ncontract OwnedUpgradeabilityStorage {\r\n\r\n    address internal _implementation;\r\n    address private _upgradeabilityOwner;\r\n    \r\n    function upgradeabilityOwner() public view returns (address) {\r\n        return _upgradeabilityOwner;\r\n    }\r\n\r\n    function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal {\r\n        _upgradeabilityOwner = newUpgradeabilityOwner;\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/proxy/Proxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\nabstract contract Proxy {\r\n  \r\n    function implementation() virtual public view returns (address);\r\n    function proxyType() virtual public pure returns (uint256 proxyTypeId);\r\n    \r\n    function _fallback() private{\r\n        \r\n        address _impl = implementation();\r\n        require(_impl != address(0), \"Proxy implementation required\");\r\n\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _impl, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n\r\n            switch result\r\n            case 0 { revert(ptr, size) }\r\n            default { return(ptr, size) }\r\n        }\r\n    }\r\n    \r\n    \r\n    fallback () payable external{\r\n      _fallback();\r\n    }\r\n    \r\n    receive() payable external{\r\n        _fallback();\r\n    }\r\n    \r\n}\r\n\r\n// File: localhost/SetExchange/registry/proxy/OwnedUpgradeabilityProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\ncontract OwnedUpgradeabilityProxy is Proxy, OwnedUpgradeabilityStorage {\r\n    \r\n    event ProxyOwnershipTransferred(address previousOwner, address newOwner);\r\n    event Upgraded(address indexed implementation);\r\n    \r\n    function implementation() override public view returns (address) {\r\n        return _implementation;\r\n    }\r\n   \r\n    function proxyType() override public pure returns (uint256 proxyTypeId) {\r\n        return 2;\r\n    }\r\n    \r\n    function _upgradeTo(address implem) internal {\r\n        require(_implementation != implem, \"Proxy already uses this implementation\");\r\n        _implementation = implem;\r\n        emit Upgraded(implem);\r\n    }\r\n    \r\n    modifier onlyProxyOwner() {\r\n        require(msg.sender == proxyOwner(), \"Only the proxy owner can call this method\");\r\n        _;\r\n    }\r\n    \r\n    function proxyOwner() public view returns (address) {\r\n        return upgradeabilityOwner();\r\n    }\r\n   \r\n    function transferProxyOwnership(address newOwner) public onlyProxyOwner {\r\n        require(newOwner != address(0), \"New owner cannot be the null address\");\r\n        emit ProxyOwnershipTransferred(proxyOwner(), newOwner);\r\n        setUpgradeabilityOwner(newOwner);\r\n    }\r\n   \r\n    //\u91cd\u70b9\u662f\u4e0b\u9762\u7684 \r\n   \r\n    function upgradeTo(address implem) public onlyProxyOwner {\r\n        _upgradeTo(implem);\r\n    }\r\n   \r\n    function upgradeToAndCall(address implem, bytes memory data) payable public onlyProxyOwner {\r\n        upgradeTo(implem);\r\n        (bool success,) = address(this).delegatecall(data);\r\n        require(success, \"Call failed after proxy upgrade\");\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/OwnableDelegateProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract OwnableDelegateProxy is OwnedUpgradeabilityProxy {\r\n\r\n\r\n    constructor(address owner, address initialImplementation, bytes memory data)  {\r\n        setUpgradeabilityOwner(owner);\r\n        _upgradeTo(initialImplementation);\r\n        (bool success,) = initialImplementation.delegatecall(data);\r\n        require(success, \"OwnableDelegateProxy failed implementation\");\r\n    }\r\n    \r\n\r\n}\r\n// File: localhost/SetExchange/registry/ProxyRegistryInterface.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ninterface ProxyRegistryInterface {\r\n    function delegateProxyImplementation() external returns (address);\r\n    function proxies(address owner) external returns (OwnableDelegateProxy);\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/@openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: localhost/SetExchange/registry/ProxyRegistry.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract ProxyRegistry is Ownable, ProxyRegistryInterface {\r\n    \r\n    address public override delegateProxyImplementation;\r\n    mapping(address => OwnableDelegateProxy) public override proxies;\r\n    //Contracts pending access. \r\n    mapping(address => uint) public pending;\r\n    //Contracts allowed to call those proxies. \r\n    mapping(address => bool) public contracts;\r\n    uint public DELAY_PERIOD = 2 weeks;\r\n\r\n    function startGrantAuthentication (address addr) public onlyOwner{\r\n        require(!contracts[addr] && pending[addr] == 0, \"Contract is already allowed in registry, or pending\");\r\n        pending[addr] = block.timestamp;\r\n    }\r\n\r\n    function endGrantAuthentication (address addr) public onlyOwner{\r\n        require(!contracts[addr] && pending[addr] != 0 && ((pending[addr] + DELAY_PERIOD) < block.timestamp), \"Contract is no longer pending or has already been approved by registry\");\r\n        pending[addr] = 0;\r\n        contracts[addr] = true;\r\n    }\r\n\r\n    function revokeAuthentication (address addr) public onlyOwner{\r\n        contracts[addr] = false;\r\n    }\r\n    \r\n     function grantAuthentication (address addr) public onlyOwner{\r\n        contracts[addr] = true;\r\n    }\r\n   \r\n    function registerProxyOverride() public returns (OwnableDelegateProxy proxy){\r\n        proxy = new OwnableDelegateProxy(msg.sender, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", msg.sender, address(this)));\r\n        proxies[msg.sender] = proxy;\r\n        return proxy;\r\n    }\r\n    \r\n    function registerProxyFor(address user) public returns (OwnableDelegateProxy proxy){\r\n        require(address(proxies[user]) == address(0), \"User already has a proxy\");\r\n        proxy = new OwnableDelegateProxy(user, delegateProxyImplementation, abi.encodeWithSignature(\"initialize(address,address)\", user, address(this)));\r\n        proxies[user] = proxy;\r\n        return proxy;\r\n    }\r\n    \r\n     function registerProxy() public returns (OwnableDelegateProxy proxy){\r\n        return registerProxyFor(msg.sender);\r\n    }\r\n\r\n    function transferAccessTo(address from, address to) public{\r\n        OwnableDelegateProxy proxy = proxies[from];\r\n        /* CHECKS */\r\n        require(msg.sender == from, \"Proxy transfer can only be called by the proxy\");\r\n        require(address(proxies[to]) == address(0), \"Proxy transfer has existing proxy as destination\");\r\n        /* EFFECTS */\r\n        delete proxies[from];\r\n        proxies[to] = proxy;\r\n    }\r\n\r\n}\r\n// File: localhost/SetExchange/registry/AuthenticatedProxy.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\ncontract AuthenticatedProxy is TokenRecipient, OwnedUpgradeabilityStorage {\r\n\r\n    bool initialized = false;\r\n    address public user;\r\n    ProxyRegistry public registry;\r\n    bool public revoked;\r\n    enum HowToCall { Call, DelegateCall }\r\n    event Revoked(bool revoked);\r\n    function initialize (address addrUser, ProxyRegistry addrRegistry) public {\r\n        require(!initialized, \"Authenticated proxy already initialized\");\r\n        initialized = true;\r\n        user = addrUser;\r\n        registry = addrRegistry;\r\n    }\r\n   //Set the revoked flag (allows a user to revoke ProxyRegistry access)\r\n    function setRevoke(bool revoke) public{\r\n        require(msg.sender == user, \"Authenticated proxy can only be revoked by its user\");\r\n        revoked = revoke;\r\n        emit Revoked(revoke);\r\n    }\r\n    //Execute a message call from the proxy contract\r\n    function proxy(address dest, HowToCall howToCall, bytes memory data) public  returns (bool result){\r\n        require(msg.sender == user || (!revoked && registry.contracts(msg.sender)), \"Authenticated proxy can only be called by its user, or by a contract authorized by the registry as long as the user has not revoked access\");\r\n        bytes memory ret;\r\n        if (howToCall == HowToCall.Call) {\r\n            (result, ret) = dest.call(data);\r\n        } else if (howToCall == HowToCall.DelegateCall) {\r\n            (result, ret) = dest.delegatecall(data);\r\n        }\r\n        return result;\r\n    }\r\n    //Execute a message call and assert success\r\n    function proxyAssert(address dest, HowToCall howToCall, bytes memory data) public{\r\n        require(proxy(dest, howToCall, data), \"Proxy assertion failed\");\r\n    }\r\n\r\n}\r\n\r\n// File: localhost/SetExchange/exchange/ExchangeCore.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//import \"../common/Console.sol\";\r\n\r\n\r\ncontract ExchangeCore is ReentrancyGuarded, StaticCaller,EIP712 {\r\n    bytes4 constant internal EIP_1271_MAGICVALUE = 0x20c13b0b;\r\n   \r\n     struct Order {\r\n        address registry;\r\n        address maker;\r\n        address staticTarget;\r\n        bytes4 staticSelector;\r\n        bytes staticExtradata;\r\n        uint maximumFill;\r\n        uint listingTime;\r\n        uint expirationTime;\r\n        uint salt;\r\n    }\r\n    \r\n    // uint basePrice;\r\n    // address paymentToken;\r\n    // address payoutAddress;\r\n    \r\n    struct Call {      \r\n        address target;      \r\n        AuthenticatedProxy.HowToCall howToCall;        \r\n        bytes data;\r\n    } \r\n    \r\n    /* Order typehash for EIP 712 compatibility. */\r\n    bytes32 constant ORDER_TYPEHASH = keccak256(\r\n        \"Order(address registry,address maker,address staticTarget,bytes4 staticSelector,bytes staticExtradata,uint256 maximumFill,uint256 listingTime,uint256 expirationTime,uint256 salt)\"\r\n    );\r\n\r\n    mapping(address => bool) public registries;\r\n    mapping(address => mapping(bytes32 => uint)) public fills;\r\n    mapping(address => mapping(bytes32 => bool)) public approved;\r\n\r\n    event OrderApproved     (bytes32 indexed hash, address registry, address indexed maker, address staticTarget, bytes4 staticSelector, bytes staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired);\r\n    event OrderFillChanged  (bytes32 indexed hash, address indexed maker, uint newFill);\r\n    event OrdersMatched     (bytes32 firstHash, bytes32 secondHash, address indexed firstMaker, address indexed secondMaker, uint newFirstFill, uint newSecondFill, bytes32 indexed metadata);\r\n\r\n    \r\n    function hashOrder(Order memory order) internal pure returns (bytes32 hash){\r\n        /* Per EIP 712. */\r\n        return keccak256(abi.encode(\r\n            ORDER_TYPEHASH,\r\n            order.registry,\r\n            order.maker,\r\n            order.staticTarget,\r\n            order.staticSelector,\r\n            keccak256(order.staticExtradata),\r\n            order.maximumFill,\r\n            order.listingTime,\r\n            order.expirationTime,\r\n            order.salt\r\n        ));\r\n    }\r\n\r\n    function hashToSign(bytes32 orderHash) internal view returns (bytes32 hash){\r\n        /* Calculate the string a user must sign. */\r\n        return keccak256(abi.encodePacked(\r\n            \"\\x19\\x01\",\r\n            DOMAIN_SEPARATOR,\r\n            orderHash\r\n        ));\r\n    }\r\n   \r\n    function exists(address what) internal view returns (bool){\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(what)\r\n        }\r\n        return size > 0;\r\n    }\r\n    \r\n    function validateOrderParameters(Order memory order, bytes32 hash) internal view returns (bool)\r\n    {\r\n        /* Order must be listed and not be expired. */\r\n        if (order.listingTime > block.timestamp || (order.expirationTime != 0 && order.expirationTime <= block.timestamp)) {\r\n            return false;\r\n        }\r\n\r\n        /* Order must not have already been completely filled. */\r\n        if (fills[order.maker][hash] >= order.maximumFill) {\r\n            return false;\r\n        }\r\n\r\n        /* Order static target must exist. */\r\n        if (!exists(order.staticTarget)) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n     function validateOrderAuthorization(bytes32 hash, address maker, bytes memory signature) internal view returns (bool){\r\n        /* Memoized authentication. If order has already been partially filled, order must be authenticated. */\r\n        if (fills[maker][hash] > 0) {\r\n            return true;\r\n        }\r\n        /* Order authentication. Order must be either: */\r\n        /* (a): sent by maker */\r\n        if (maker == msg.sender) {\r\n            return true;\r\n        }\r\n        /* (b): previously approved */\r\n        if (approved[maker][hash]) {\r\n            return true;\r\n        }\r\n\r\n        /* Calculate hash which must be signed. */\r\n        bytes32 calculatedHashToSign = hashToSign(hash);\r\n        /* Determine whether signer is a contract or account. */\r\n        bool isContract = exists(maker);\r\n\r\n        /* (c): Contract-only authentication: EIP/ERC 1271. */\r\n        if (isContract) {\r\n            if (ERC1271(maker).isValidSignature(abi.encodePacked(calculatedHashToSign), signature) == EIP_1271_MAGICVALUE) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        /* (d): Account-only authentication: ECDSA-signed by maker. */\r\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(signature, (uint8, bytes32, bytes32));\r\n        \r\n        //return true;\r\n        if (ecrecover(calculatedHashToSign, v, r, s) == maker) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n//   function ecrecoverSig(bytes32 orderHash, bytes memory signature) external view returns (address){\r\n       \r\n//         /* Calculate hash which must be signed. */\r\n//         bytes32 calculatedHashToSign = hashToSign(orderHash);\r\n//         /* (d): Account-only authentication: ECDSA-signed by maker. */\r\n//         (uint8 v, bytes32 r, bytes32 s) = abi.decode(signature, (uint8, bytes32, bytes32));\r\n//         return ecrecover(calculatedHashToSign, v, r, s);\r\n//     }\r\n    \r\n//     function ecrecoverSigVrs(bytes32 orderHash,uint8 v,bytes32 r,bytes32 s) external view returns (address){\r\n        \r\n//         /* Calculate hash which must be signed. */\r\n//         bytes32 calculatedHashToSign = hashToSign(orderHash);\r\n//         return ecrecover(calculatedHashToSign, v, r, s) ;\r\n//     }\r\n    \r\n    function approveOrderHash(bytes32 hash)  internal{\r\n        /* CHECKS */\r\n        /* Assert order has not already been approved. */\r\n        require(!approved[msg.sender][hash], \"Order has already been approved\");\r\n        /* EFFECTS */\r\n        /* Mark order as approved. */\r\n        approved[msg.sender][hash] = true;\r\n    }\r\n\r\n    function approveOrder(Order memory order, bool orderbookInclusionDesired) internal{\r\n        /* CHECKS */\r\n        /* Assert sender is authorized to approve order. */\r\n        require(order.maker == msg.sender, \"Sender is not the maker of the order and thus not authorized to approve it\");\r\n        /* Calculate order hash. */\r\n        bytes32 hash = hashOrder(order);\r\n        /* Approve order hash. */\r\n        approveOrderHash(hash);\r\n        /* Log approval event. */\r\n        emit OrderApproved(hash, order.registry, order.maker, order.staticTarget, order.staticSelector, order.staticExtradata, order.maximumFill, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\r\n    }\r\n\r\n    function setOrderFill(bytes32 hash, uint fill) internal{\r\n        /* CHECKS */\r\n        /* Assert fill is not already set. */\r\n        require(fills[msg.sender][hash] != fill, \"Fill is already set to the desired value\");\r\n        /* EFFECTS */\r\n        /* Mark order as accordingly filled. */\r\n        fills[msg.sender][hash] = fill;\r\n        /* Log order fill change event. */\r\n        emit OrderFillChanged(hash, msg.sender, fill);\r\n    }\r\n    \r\n     function encodeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        /* This array wrapping is necessary to preserve static call target function stack space. */\r\n        address[7] memory addresses = [order.registry, order.maker, call.target, counterorder.registry, counterorder.maker, countercall.target, matcher];\r\n        \r\n        AuthenticatedProxy.HowToCall[2] memory howToCalls = [call.howToCall, countercall.howToCall];\r\n        \r\n        uint[6] memory uints = [value, order.maximumFill, order.listingTime, order.expirationTime, counterorder.listingTime, fill];\r\n        \r\n        return abi.encodeWithSelector(order.staticSelector, order.staticExtradata, addresses, howToCalls, uints, call.data, countercall.data);\r\n    }\r\n    \r\n     function executeStaticCall(Order memory order, Call memory call, Order memory counterorder, Call memory countercall, address matcher, uint value, uint fill)\r\n        internal\r\n        view\r\n        returns (uint)\r\n    {\r\n        return staticCallUint(order.staticTarget, encodeStaticCall(order, call, counterorder, countercall, matcher, value, fill));\r\n    }\r\n    \r\n     function executeCall(ProxyRegistryInterface registry, address maker, Call memory call)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        /* Assert valid registry. */\r\n        require(registries[address(registry)]);\r\n\r\n        /* Assert target exists. */\r\n        require(exists(call.target), \"Call target does not exist\");\r\n\r\n        /* Retrieve delegate proxy contract. */\r\n        OwnableDelegateProxy delegateProxy = registry.proxies(maker);\r\n\r\n        /* Assert existence. */\r\n        require(address(delegateProxy) != address(0x0), \"Delegate proxy does not exist for maker\");\r\n\r\n        /* Assert implementation. */\r\n        require(delegateProxy.implementation() == registry.delegateProxyImplementation(), \"Incorrect delegate proxy implementation for maker\");\r\n\r\n        /* Typecast. */\r\n        AuthenticatedProxy proxy = AuthenticatedProxy(payable(address(delegateProxy)));\r\n\r\n        /* Execute order. */\r\n        return proxy.proxy(call.target, call.howToCall, call.data);\r\n    }\r\n    \r\n    function payEthToProxy(ProxyRegistryInterface registry, address maker,uint256 price)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        \r\n        require(registries[address(registry)]);\r\n        OwnableDelegateProxy delegateProxy = registry.proxies(maker);\r\n        require(address(delegateProxy) != address(0x0), \"Delegate proxy does not exist for maker\");\r\n        require(delegateProxy.implementation() == registry.delegateProxyImplementation(), \"Incorrect delegate proxy implementation for maker\");\r\n        AuthenticatedProxy proxy = AuthenticatedProxy(payable(address(delegateProxy)));\r\n        (bool success,)=address(proxy).call{value: price}(abi.encodeWithSignature(\"nonExistingFunction()\"));\r\n        //require(payable(proxy).send(price));\r\n        return success;\r\n    }\r\n    \r\n     function atomicMatch(Order memory firstOrder, Call memory firstCall, Order memory secondOrder, Call memory secondCall, bytes memory signatures, bytes32 metadata)\r\n        internal\r\n        reentrancyGuard\r\n    {\r\n        /* CHECKS */\r\n\r\n        /* Calculate first order hash. */\r\n        bytes32 firstHash = hashOrder(firstOrder);\r\n\r\n        /* Check first order validity. */\r\n        require(validateOrderParameters(firstOrder, firstHash), \"First order has invalid parameters\");\r\n\r\n        /* Calculate second order hash. */\r\n        bytes32 secondHash = hashOrder(secondOrder);\r\n\r\n        /* Check second order validity. */\r\n        require(validateOrderParameters(secondOrder, secondHash), \"Second order has invalid parameters\");\r\n\r\n        /* Prevent self-matching (possibly unnecessary, but safer). */\r\n        require(firstHash != secondHash, \"Self-matching orders is prohibited\");\r\n        {\r\n            /* Calculate signatures (must be awkwardly decoded here due to stack size constraints). */\r\n            (bytes memory firstSignature, bytes memory secondSignature) = abi.decode(signatures, (bytes, bytes));\r\n            \r\n             /* Check first order authorization. */\r\n             require(validateOrderAuthorization(firstHash, firstOrder.maker, firstSignature), \"First order failed authorization\");\r\n\r\n             /* Check second order authorization. */\r\n             require(validateOrderAuthorization(secondHash, secondOrder.maker, secondSignature), \"Second order failed authorization\");\r\n             //Console.log(\"firstHash\",firstHash);\r\n        }\r\n\r\n        /* INTERACTIONS */\r\n\r\n        /* Transfer any msg.value.\r\n          This is the first \"asymmetric\" part of order matching: if an order requires Ether, it must be the first order. */\r\n        if (msg.value > 0) {\r\n            //payable(address(uint160(firstOrder.maker))).transfer(msg.value);\r\n           require(payEthToProxy(ProxyRegistryInterface(secondOrder.registry), secondOrder.maker,msg.value), \"payEthToProxy call failed\");\r\n        }\r\n\r\n        /* Execute first call, assert success.\r\n          This is the second \"asymmetric\" part of order matching: execution of the second order can depend on state changes in the first order, but not vice-versa. */\r\n        require(executeCall(ProxyRegistryInterface(firstOrder.registry), firstOrder.maker, firstCall), \"First call failed\");\r\n        /* Execute second call, assert success. */\r\n        require(executeCall(ProxyRegistryInterface(secondOrder.registry), secondOrder.maker, secondCall), \"Second call failed\");\r\n        /* Static calls must happen after the effectful calls so that they can check the resulting state. */\r\n\r\n        /* Fetch previous first order fill. */\r\n        uint previousFirstFill = fills[firstOrder.maker][firstHash];\r\n        /* Fetch previous second order fill. */\r\n        uint previousSecondFill = fills[secondOrder.maker][secondHash];\r\n        \r\n        /* Execute first order static call, assert success, capture returned new fill. */\r\n        uint firstFill = executeStaticCall(firstOrder, firstCall, secondOrder, secondCall, msg.sender, msg.value, previousFirstFill);\r\n        /* Execute second order static call, assert success, capture returned new fill. */\r\n        uint secondFill = executeStaticCall(secondOrder, secondCall, firstOrder, firstCall, msg.sender, uint(0), previousSecondFill);\r\n        \r\n        /* EFFECTS */\r\n        /* Update first order fill, if necessary. */\r\n        if (firstOrder.maker != msg.sender) {\r\n            if (firstFill != previousFirstFill) {\r\n                fills[firstOrder.maker][firstHash] = firstFill;\r\n            }\r\n        }\r\n\r\n        /* Update second order fill, if necessary. */\r\n        if (secondOrder.maker != msg.sender) {\r\n            if (secondFill != previousSecondFill) {\r\n                fills[secondOrder.maker][secondHash] = secondFill;\r\n            }\r\n        }\r\n        \r\n        /* LOGS */\r\n        /* Log match event. */\r\n        emit OrdersMatched(firstHash, secondHash, firstOrder.maker, secondOrder.maker, firstFill, secondFill, metadata);\r\n    }\r\n    \r\n}\r\n// File: localhost/SetExchange/exchange/Exchange.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract Exchange is ExchangeCore {\r\n    \r\n    /* external ABI-encodable method wrappers. */\r\n\r\n    function hashOrder_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt)\r\n        external\r\n        pure\r\n        returns (bytes32 hash)\r\n    {\r\n        return hashOrder(Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt));\r\n    }\r\n\r\n    function hashToSign_(bytes32 orderHash)\r\n        external\r\n        view\r\n        returns (bytes32 hash)\r\n    {\r\n        return hashToSign(orderHash);\r\n    }\r\n    \r\n     function validateOrderParameters_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        Order memory order = Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt);\r\n        return validateOrderParameters(order, hashOrder(order));\r\n    }\r\n\r\n    function validateOrderAuthorization_(bytes32 hash, address maker, bytes calldata signature)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return validateOrderAuthorization(hash, maker, signature);\r\n    }\r\n\r\n    function approveOrderHash_(bytes32 hash)\r\n        external\r\n    {\r\n        return approveOrderHash(hash);\r\n    }\r\n\r\n    function approveOrder_(address registry, address maker, address staticTarget, bytes4 staticSelector, bytes calldata staticExtradata, uint maximumFill, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired)\r\n        external\r\n    {\r\n        return approveOrder(Order(registry, maker, staticTarget, staticSelector, staticExtradata, maximumFill, listingTime, expirationTime, salt), orderbookInclusionDesired);\r\n    }\r\n\r\n    function setOrderFill_(bytes32 hash, uint fill)\r\n        external\r\n    {\r\n        return setOrderFill(hash, fill);\r\n    }\r\n    \r\n    \r\n    function atomicMatch_(address[8] memory addr,uint[8] memory uints, bytes4[2] memory staticSelectors,\r\n        bytes memory firstExtradata, bytes memory firstCalldata, bytes memory secondExtradata, bytes memory secondCalldata,\r\n        uint8[2] memory howToCalls, bytes32 metadata, bytes memory signatures)\r\n        public\r\n        payable\r\n    {\r\n        return atomicMatch(\r\n            Order(addr[0], addr[1], addr[2], staticSelectors[0], firstExtradata, uints[0], uints[1], uints[2], uints[3]),\r\n            Call(addr[3], AuthenticatedProxy.HowToCall(howToCalls[0]), firstCalldata),\r\n            Order(addr[4], addr[5], addr[6], staticSelectors[1], secondExtradata, uints[4], uints[5], uints[6], uints[7]),\r\n            Call(addr[7], AuthenticatedProxy.HowToCall(howToCalls[1]), secondCalldata),\r\n            signatures,\r\n            metadata\r\n        );\r\n    }\r\n   \r\n}\r\n// File: localhost/SetExchange/WyvernExchange.sol\r\n\r\n\r\npragma solidity ^0.8.3;\r\n\r\n\r\ncontract WyvernExchange is Exchange {\r\n\r\n    string public constant name = \"Wyvern Exchange\";\r\n  \r\n    string public constant version = \"3.1\";\r\n\r\n    string public constant codename = \"Ancalagon\";\r\n\r\n    //constructor (uint chainId, address[] memory registryAddrs, string memory customPersonalSignPrefix){\r\n    constructor (uint chainId, address[] memory registryAddrs){\r\n        DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n            name              : name,\r\n            version           : version,\r\n            chainId           : chainId,\r\n            verifyingContract : address(this)\r\n        }));\r\n        for (uint i = 0; i < registryAddrs.length; i++) {\r\n          registries[registryAddrs[i]] = true;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"registryAddrs\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"OrderApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFill\",\"type\":\"uint256\"}],\"name\":\"OrderFillChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"firstHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"secondHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"firstMaker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"secondMaker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFirstFill\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newSecondFill\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"approveOrderHash_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"approveOrder_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[8]\",\"name\":\"addr\",\"type\":\"address[8]\"},{\"internalType\":\"uint256[8]\",\"name\":\"uints\",\"type\":\"uint256[8]\"},{\"internalType\":\"bytes4[2]\",\"name\":\"staticSelectors\",\"type\":\"bytes4[2]\"},{\"internalType\":\"bytes\",\"name\":\"firstExtradata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"firstCalldata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"secondExtradata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"secondCalldata\",\"type\":\"bytes\"},{\"internalType\":\"uint8[2]\",\"name\":\"howToCalls\",\"type\":\"uint8[2]\"},{\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"atomicMatch_\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"codename\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"hashOrder_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"hashToSign_\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"registries\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"fill\",\"type\":\"uint256\"}],\"name\":\"setOrderFill_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"validateOrderAuthorization_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"registry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"staticSelector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"maximumFill\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"}],\"name\":\"validateOrderParameters_\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WyvernExchange", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000f929e7f0b51b48c24bb870d0b228199bf93fde55", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://45bbd4e282cbaaa2079f2ebb8cc404ffab144891c826047d401e8f44fce3166c"}]}