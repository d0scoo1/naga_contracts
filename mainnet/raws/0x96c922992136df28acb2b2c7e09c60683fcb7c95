{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/**\r\n * TELETWEETS\r\n * ----------------------------------------------------------------------\r\n *\r\n * TELETWEETS donates ETH to any impactful influencer that promotes the TELETWEETS token from their \r\n * Twitter account and/or Telegram channel. TELETWEETS also donates to charities (that must be listed \r\n * on TheGivingBlock.com) nominated by those influencers and/or Twitter followers.\r\n *\r\n * If you're an influencer, simply tweet or post a Telegram promo about TELETWEETS then send us a message \r\n * via Twitter that includes the following information:\r\n *\r\n * 1) A link to your tweet and/or Telegram post.\r\n * 2) A link to the charity you'd like to nominate.\r\n * 3) Your Ethereum wallet address.\r\n *\r\n * We'll then send ETH to your wallet and add your charity to the list of nominations. We of course tweet \r\n * about your promo, which in turn brings attention to your account/channel aka beautiful reciprocation.\r\n * \r\n * All charitable donations will be completely transparent and published via the TELETWEETS Twitter account.\r\n *\r\n * Twitter: https://twitter.com/_TELETWEETS\r\n *\r\n * Everything is run solely from Twitter. To communicate with the team, please send a Twitter DM.\r\n *\r\n * Tokenomics\r\n * ----------------------------------------------------------------------\r\n *\r\n * Buy & Sell\r\n *\r\n * Charity - funds influencer and charitable donations: 4%\r\n * Auto-liquidity - helps to create a more stable price floor: 1%\r\n * Ecosystem - general running costs and founder payments: 4%\r\n *\r\n * Total Per Swap: 9%\r\n *\r\n * Trade Settings\r\n * ----------------------------------------------------------------------\r\n *\r\n * Max Transaction: 750000 / 0.75%\r\n * Max Wallet: 1000000 / 1%\r\n *\r\n * Limits shall be lifted shortly after launch.\r\n *\r\n * Wallet to wallet transfers are not subject to tax.\r\n *\r\n * Security\r\n * ----------------------------------------------------------------------\r\n *\r\n * Both the development of this contract and the launch procedure were completed with security in mind:\r\n *\r\n * 1) No configuration function can be used to honeypot or create any other form of scam.\r\n * 2) Ownership is renounced soon after launch, with the only functions that remain accessible being completely safe.\r\n * 3) 100% of liquidity is locked soon after launch.\r\n * 4) To minimise snipers, we fast-launch then ban known sniper addresses.\r\n *\r\n * Finally\r\n * ----------------------------------------------------------------------\r\n *\r\n * Safety + Charity + Twitter and Telegram influencers = recipe for success.\r\n *\r\n * Enjoy the show. Tweet tweet.\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n\r\n        _transfer(owner, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n\r\n        _approve(owner, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        uint256 fromBalance = _balances[from];\r\n\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n        }\r\n\r\n        _balances[to] += amount;\r\n\r\n        emit Transfer(from, to, amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n        }\r\n\r\n        _totalSupply -= amount;\r\n\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\ninterface IDexFactory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n\r\ninterface IDexRouter {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);\r\n}\r\n\r\ncontract TELETWEETS is Context, ERC20, Ownable {\r\n    // DEX\r\n    IDexRouter public dexRouter;\r\n    address public dexPair;\r\n\r\n    // Wallets\r\n    address public charityWallet;\r\n    address public ecosystemWallet;\r\n\r\n    // Trade settings\r\n    bool public swapEnabled = false;\r\n    bool public limitsEnabled = false;\r\n    bool private _tradingEnabled = false;\r\n\r\n    bool public transferDelayEnabled = true;\r\n    uint256 private _transferDelayBlocks = 2;\r\n    mapping(address => uint256) private _lastTransferBlock;\r\n    \r\n    uint256 private _maxTxAmount;\r\n    uint256 private _maxWalletAmount;\r\n    uint256 public swapTokensAmount;\r\n\r\n    // Trade tax\r\n    uint256 public buyCharityFee = 4;\r\n    uint256 public buyLiquidityFee = 1;\r\n    uint256 public buyEcosystemFee = 4;\r\n    uint256 public buyTotalFees = buyCharityFee + buyLiquidityFee + buyEcosystemFee;\r\n\r\n    uint256 public sellCharityFee = 4;\r\n    uint256 public sellLiquidityFee = 1;\r\n    uint256 public sellEcosystemFee = 4;\r\n    uint256 public sellTotalFees = sellCharityFee + sellLiquidityFee + sellEcosystemFee;\r\n\r\n    uint256 private _tokensForCharity = 0;\r\n    uint256 private _tokensForLiquidity = 0;\r\n    uint256 private _tokensForEcosystem = 0;\r\n\r\n    // Fees and max TX exclusions\r\n    mapping(address => bool) private _isExcludedFromFees;\r\n    mapping(address => bool) private _isExcludedFromMaxTx;\r\n\r\n    // Anti-bot\r\n    bool public antiBotEnabled = true;\r\n    mapping(address => bool) private _bots;\r\n    uint256 private _launchTime = 0;\r\n    uint256 private _launchBlock = 0;\r\n    uint256 private _botBlocks = 1;\r\n    uint256 private _botSeconds = 10;\r\n    uint256 public totalBots = 0;\r\n\r\n    // Reentrancy\r\n    bool private _isSwapLocked = false;\r\n\r\n    modifier lockSwap {\r\n        _isSwapLocked = true;\r\n        _;\r\n        _isSwapLocked = false;\r\n    }\r\n\r\n    constructor(address charityWallet_, address ecosystemWallet_) payable ERC20(\"TELETWEETS\", \"TELETWEETS\") {\r\n        require(address(this).balance > 0, \"Token: contract currency balance must be above 0\");\r\n\r\n        // DEX router\r\n        if (block.chainid == 56) {\r\n            dexRouter = IDexRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);\r\n        } else if (block.chainid == 97) {\r\n            dexRouter = IDexRouter(0x9Ac64Cc6e4415144C455BD8E4837Fea55603e5c3);\r\n        } else if (block.chainid == 1 || block.chainid == 4) {\r\n            dexRouter = IDexRouter(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        _approve(address(this), address(dexRouter), type(uint256).max);\r\n\r\n        // Mint total supply - called once here only\r\n        _mint(address(this), 100_000_000 * 1e18);\r\n\r\n        // Wallets\r\n        charityWallet = charityWallet_;\r\n        ecosystemWallet = ecosystemWallet_;\r\n    }\r\n\r\n    function teleTweets(uint256 botBlocks_, uint256 botSeconds_, uint256 maxTxAmount_, uint256 maxWalletAmount_, address[] memory botAddresses_) external onlyOwner {\r\n        require(!_tradingEnabled, \"Token: trading already enabled\");\r\n        require(botBlocks_ >= 0 && botBlocks_ <= 3, \"Token: bot blocks must range between 0 and 3\");\r\n        require(botSeconds_ >= 10 && botSeconds_ <= 120, \"Token: bot seconds must range between 10 and 120\");\r\n        require(botAddresses_.length > 0 && botAddresses_.length <= 200, \"Token: number of bot addresses cannot be above 200\");\r\n\r\n        // DEX pair\r\n        dexPair = IDexFactory(dexRouter.factory()).createPair(address(this), dexRouter.WETH());\r\n\r\n        // Exclude from fees\r\n        excludeFromFees(owner(), true);\r\n        excludeFromFees(address(this), true);\r\n        excludeFromFees(address(0xdead), true);\r\n \r\n        // Exclude from max TX\r\n        excludeFromMaxTx(owner(), true);\r\n        excludeFromMaxTx(address(this), true);\r\n        excludeFromMaxTx(address(0xdead), true);\r\n        excludeFromMaxTx(address(dexRouter), true);\r\n        excludeFromMaxTx(dexPair, true);\r\n\r\n        // Add liquidity\r\n        dexRouter.addLiquidityETH{value: address(this).balance}(address(this), balanceOf(address(this)), 0, 0, owner(), block.timestamp);\r\n        IERC20(dexPair).approve(address(dexRouter), type(uint256).max);\r\n\r\n        // Anti-bot\r\n        setBots(botAddresses_, true);\r\n\r\n        // Trade settings\r\n        setMaxTxAmount(maxTxAmount_);\r\n        setMaxWalletAmount(maxWalletAmount_);\r\n        setSwapTokensAmount(((totalSupply() * 5) / 10000) / 1e18); // 0.05%\r\n\r\n        // Launch settings\r\n        _launchTime = block.timestamp;\r\n        _launchBlock = block.number;\r\n        _botBlocks = botBlocks_;\r\n        _botSeconds = botSeconds_;\r\n\r\n        swapEnabled = true;\r\n        limitsEnabled = true;\r\n        _tradingEnabled = true;\r\n    }\r\n\r\n    function setCharityWallet(address charityWallet_) public onlyOwner {\r\n        require(charityWallet_ != address(0), \"Token: charity wallet address invalid\");\r\n\r\n        if (isExcludedFromFees(charityWallet)) {\r\n            excludeFromFees(charityWallet, false);\r\n        }\r\n\r\n        if (isExcludedFromMaxTx(charityWallet)) {\r\n            excludeFromMaxTx(charityWallet, false);\r\n        }\r\n\r\n        charityWallet = charityWallet_;\r\n\r\n        excludeFromFees(charityWallet_, true);\r\n        excludeFromMaxTx(charityWallet_, true);\r\n    }\r\n\r\n    function setEcosystemWallet(address ecosystemWallet_) public onlyOwner {\r\n        require(ecosystemWallet_ != address(0), \"Token: ecosystem wallet address invalid\");\r\n\r\n        if (isExcludedFromFees(ecosystemWallet)) {\r\n            excludeFromFees(ecosystemWallet, false);\r\n        }\r\n\r\n        if (isExcludedFromMaxTx(ecosystemWallet)) {\r\n            excludeFromMaxTx(ecosystemWallet, false);\r\n        }\r\n\r\n        ecosystemWallet = ecosystemWallet_;\r\n\r\n        excludeFromFees(ecosystemWallet_, true);\r\n        excludeFromMaxTx(ecosystemWallet_, true);\r\n    }\r\n\r\n    function disableLimits() external onlyOwner {\r\n\t\trequire(limitsEnabled, \"Token: limits already disabled\");\r\n\r\n        limitsEnabled = false;\r\n    }\r\n\r\n    function disableTransferDelay() external onlyOwner {\r\n        require(transferDelayEnabled, \"Token: transfer delay already disabled\");\r\n\r\n        transferDelayEnabled = false;\r\n    }\r\n\r\n    function setMaxTxAmount(uint256 maxTxAmount_) public onlyOwner {\r\n        require(maxTxAmount_ >= (((totalSupply() * 75) / 10000) / 1e18), \"Token: max TX amount cannot be below 0.75%\");\r\n\r\n        _maxTxAmount = maxTxAmount_ * 1e18;\r\n    }\r\n\r\n    function setMaxWalletAmount(uint256 maxWalletAmount_) public onlyOwner {\r\n        require(maxWalletAmount_ >= ((totalSupply() / 100) / 1e18), \"Token: max wallet amount cannot be below 1%\");\r\n\r\n        _maxWalletAmount = maxWalletAmount_ * 1e18;\r\n    }\r\n\r\n    function setSwapTokensAmount(uint256 swapTokensAmount_) public {\r\n        require(_msgSender() == owner() || _msgSender() == ecosystemWallet, \"Token: caller is not authorised\");\r\n        require(swapTokensAmount_ >= (((totalSupply() * 5) / 100000) / 1e18), \"Token: swap tokens amount cannot be below 0.005%\");\r\n        require(swapTokensAmount_ <= ((totalSupply() / 1000) / 1e18), \"Token: swap tokens amount cannot be above 0.1%\");\r\n\r\n        swapTokensAmount = swapTokensAmount_ * 1e18;\r\n    }\r\n\r\n    function excludeFromFees(address excludeAddress_, bool isExcluded_) public onlyOwner {\r\n        if (isExcluded_) {\r\n            require(excludeAddress_ != address(dexRouter) && excludeAddress_ != dexPair, \"Token: excluded from fees address invalid\");\r\n        } else {\r\n            require(excludeAddress_ != owner() && excludeAddress_ != address(this) && excludeAddress_ != address(0xdead), \"Token: excluded from fees address invalid\");\r\n        }\r\n\r\n        _isExcludedFromFees[excludeAddress_] = isExcluded_;\r\n    }\r\n\r\n    function isExcludedFromFees(address excludeAddress_) public view returns (bool) {\r\n        return _isExcludedFromFees[excludeAddress_];\r\n    }\r\n\r\n    function excludeFromMaxTx(address excludeAddress_, bool isExcluded_) public onlyOwner {\r\n        if (!isExcluded_) {\r\n            require(excludeAddress_ != owner() && excludeAddress_ != address(this) && excludeAddress_ != address(0xdead) && excludeAddress_ != address(dexRouter) && excludeAddress_ != dexPair, \"Token: excluded from max TX address invalid\");\r\n        }\r\n\r\n        _isExcludedFromMaxTx[excludeAddress_] = isExcluded_;\r\n    }\r\n\r\n    function isExcludedFromMaxTx(address excludeAddress_) public view returns (bool) {\r\n        return _isExcludedFromMaxTx[excludeAddress_];\r\n    }\r\n\r\n    function setAntiBotEnabled(bool antiBotEnabled_) external {\r\n        require(_msgSender() == owner() || _msgSender() == ecosystemWallet, \"Token: caller is not authorised\");\r\n\r\n        antiBotEnabled = antiBotEnabled_;\r\n    }\r\n\r\n    function setBots(address[] memory botAddresses_, bool isBlacklisting_) public {\r\n        require(_msgSender() == owner() || _msgSender() == ecosystemWallet, \"Token: caller is not authorised\");\r\n        require(botAddresses_.length > 0 && botAddresses_.length <= 200, \"Token: number of bot addresses cannot be above 200\");\r\n\r\n        if (isBlacklisting_ && _tradingEnabled) {\r\n            require(block.timestamp <= (_launchTime + (15 minutes)), \"Token: bots can only be blacklisted within the first 15 minutes from launch\");\r\n        }\r\n\r\n        for (uint256 i = 0; i < botAddresses_.length; i++) {\r\n            if (isBlacklisting_ && (botAddresses_[i] == owner() || botAddresses_[i] == address(this) || botAddresses_[i] == address(0xdead) || botAddresses_[i] == dexPair || botAddresses_[i] == address(dexRouter))) continue;\r\n\r\n            if (_bots[botAddresses_[i]] == isBlacklisting_) continue;\r\n\r\n            _bots[botAddresses_[i]] = isBlacklisting_;\r\n\r\n            if (isBlacklisting_) {\r\n                totalBots++;\r\n            } else {\r\n                totalBots--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function isBot(address botAddress_) public view returns (bool) {\r\n        return _bots[botAddress_];\r\n    }\r\n\r\n    function forceSwap(uint256 tokensAmount_) external {\r\n        require(_msgSender() == owner() || _msgSender() == ecosystemWallet, \"Token: caller is not authorised\");\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n\r\n        require(contractTokenBalance > 0, \"Token: contract token balance must be above zero\");\r\n        require(tokensAmount_ <= contractTokenBalance, \"Token: swap amount exceeds contract balance\");\r\n\r\n        _swapLiquify(tokensAmount_);\r\n    }\r\n\r\n    function withdrawCurrency() external onlyOwner {\r\n        uint256 currencyBalance = address(this).balance;\r\n\r\n        require(currencyBalance > 0, \"Token: contract currency balance must be above 0\");\r\n\r\n        (bool success, ) = _msgSender().call{value: currencyBalance}(\"\");\r\n    }\r\n\r\n    function _transfer(address from, address to, uint256 amount) internal override {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Token: transfer amount must be greater than zero\");\r\n\r\n        // Anti-bot\r\n        if (antiBotEnabled) {\r\n            require(!_bots[to] && !_bots[from], \"Token: address blacklisted\");\r\n        }\r\n\r\n        // Trading enabled\r\n        if (!_tradingEnabled) {\r\n            require(isExcludedFromFees(from) || isExcludedFromFees(to), \"Token: trading not yet enabled\");\r\n        }\r\n\r\n        if (limitsEnabled && !_isSwapLocked && from != owner() && to != owner() && to != address(0) && to != address(0xdead)) {\r\n            // Blacklist bots by timestamp & block\r\n            if ((block.timestamp <= (_launchTime + _botSeconds) || block.number <= (_launchBlock + _botBlocks)) && to != address(this) && to != dexPair && to != address(dexRouter)) {\r\n                _bots[to] = true;\r\n\r\n                totalBots++;\r\n            }\r\n\r\n            // Prevent multiple transfers in specified blocks\r\n            if (transferDelayEnabled && from != address(this) && to != dexPair && to != address(dexRouter)) {\r\n                require(_lastTransferBlock[tx.origin] < (block.number - _transferDelayBlocks) && _lastTransferBlock[to] < (block.number - _transferDelayBlocks), \"Token: transfer delay enabled\");\r\n\r\n                _lastTransferBlock[tx.origin] = block.number;\r\n                _lastTransferBlock[to] = block.number;\r\n            }\r\n\r\n            // Max TX and max wallet\r\n            if (from == dexPair && !isExcludedFromMaxTx(to)) {\r\n                // Buy\r\n                require(amount <= _maxTxAmount, \"Token: buy amount exceeds max TX limit\");\r\n                require(amount + balanceOf(to) <= _maxWalletAmount, \"Token: amount would exceed max wallet limit\");\r\n            } else if (to == dexPair && !isExcludedFromMaxTx(from)) {\r\n                // Sell\r\n                require(amount <= _maxTxAmount, \"Token: sell amount exceeds max TX limit\");\r\n            } else if (!isExcludedFromMaxTx(to)) {\r\n                // Transfer\r\n                require(amount + balanceOf(to) <= _maxWalletAmount, \"Token: amount would exceed max wallet limit\");\r\n            }\r\n        }\r\n\r\n        // Swap contract tokens, add liquidity, then distribute\r\n        if (swapEnabled && !_isSwapLocked && balanceOf(address(this)) > swapTokensAmount && from != dexPair && !isExcludedFromFees(from) && !isExcludedFromFees(to)) {\r\n            _swapLiquify(swapTokensAmount);\r\n        }\r\n\r\n        bool deductFees = !_isSwapLocked;\r\n\r\n        // Omit fees for excluded addresses\r\n        if (isExcludedFromFees(from) || isExcludedFromFees(to) || to == address(dexRouter)) {\r\n            deductFees = false;\r\n        }\r\n \r\n        uint256 totalAmount = amount;\r\n        uint256 totalFees = 0;\r\n\r\n        // Take fees on buys/sells, not wallet transfers\r\n        if (deductFees) {\r\n            if (to == dexPair && sellTotalFees > 0) {\r\n                // Sell\r\n                totalFees = (totalAmount * sellTotalFees) / 100;\r\n                _tokensForCharity += (totalFees * sellCharityFee) / sellTotalFees;\r\n                _tokensForLiquidity += (totalFees * sellLiquidityFee) / sellTotalFees;\r\n                _tokensForEcosystem += (totalFees * sellEcosystemFee) / sellTotalFees;\r\n            } else if (from == dexPair && buyTotalFees > 0) {\r\n                // Buy\r\n                totalFees = (totalAmount * buyTotalFees) / 100;\r\n                _tokensForCharity += (totalFees * buyCharityFee) / buyTotalFees;\r\n                _tokensForLiquidity += (totalFees * buyLiquidityFee) / buyTotalFees;\r\n                _tokensForEcosystem += (totalFees * buyEcosystemFee) / buyTotalFees;\r\n            }\r\n \r\n            if (totalFees > 0) {\r\n                super._transfer(from, address(this), totalFees);\r\n\r\n                totalAmount -= totalFees;\r\n            }\r\n        }\r\n\r\n        super._transfer(from, to, totalAmount);\r\n    }\r\n\r\n    function _swapLiquify(uint256 tokensAmount) private lockSwap {\r\n        uint256 totalTokens = _tokensForCharity + _tokensForLiquidity + _tokensForEcosystem;\r\n\r\n        if (totalTokens == 0) return;\r\n\r\n        uint256 halfLiquidityTokens = ((tokensAmount * _tokensForLiquidity) / totalTokens) / 2;\r\n\r\n        _swapTokensForCurrency(tokensAmount - halfLiquidityTokens);\r\n \r\n        uint256 currencyBalance = address(this).balance;\r\n\r\n        uint256 currencyForCharity = (currencyBalance * _tokensForCharity) / totalTokens;\r\n        uint256 currencyForLiquidity = (currencyBalance * _tokensForLiquidity) / totalTokens;\r\n\r\n        bool sendSuccess;\r\n\r\n        (sendSuccess, ) = address(charityWallet).call{value: currencyForCharity}(\"\");\r\n\r\n        if (halfLiquidityTokens > 0 && currencyForLiquidity > 0) {\r\n            _addLiquidity(halfLiquidityTokens, currencyForLiquidity);\r\n        }\r\n\r\n        (sendSuccess, ) = address(ecosystemWallet).call{value: address(this).balance}(\"\");\r\n\r\n        _tokensForCharity = 0;\r\n        _tokensForLiquidity = 0;\r\n        _tokensForEcosystem = 0;\r\n    }\r\n\r\n    function _swapTokensForCurrency(uint256 tokensAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = dexRouter.WETH();\r\n \r\n        _approve(address(this), address(dexRouter), tokensAmount);\r\n \r\n        dexRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(tokensAmount, 0, path, address(this), block.timestamp);\r\n    }\r\n\r\n    function _addLiquidity(uint256 tokensAmount, uint256 currencyAmount) private {\r\n        _approve(address(this), address(dexRouter), tokensAmount);\r\n\r\n        dexRouter.addLiquidityETH{value: currencyAmount}(address(this), tokensAmount, 0, 0, address(0xdead), block.timestamp);\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"charityWallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ecosystemWallet_\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"antiBotEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyCharityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyEcosystemFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"charityWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexPair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexRouter\",\"outputs\":[{\"internalType\":\"contract IDexRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableTransferDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ecosystemWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludeAddress_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded_\",\"type\":\"bool\"}],\"name\":\"excludeFromFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludeAddress_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isExcluded_\",\"type\":\"bool\"}],\"name\":\"excludeFromMaxTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount_\",\"type\":\"uint256\"}],\"name\":\"forceSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"botAddress_\",\"type\":\"address\"}],\"name\":\"isBot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludeAddress_\",\"type\":\"address\"}],\"name\":\"isExcludedFromFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"excludeAddress_\",\"type\":\"address\"}],\"name\":\"isExcludedFromMaxTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitsEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellCharityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellEcosystemFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellLiquidityFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellTotalFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"antiBotEnabled_\",\"type\":\"bool\"}],\"name\":\"setAntiBotEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"botAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"isBlacklisting_\",\"type\":\"bool\"}],\"name\":\"setBots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"charityWallet_\",\"type\":\"address\"}],\"name\":\"setCharityWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ecosystemWallet_\",\"type\":\"address\"}],\"name\":\"setEcosystemWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount_\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxWalletAmount_\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapTokensAmount_\",\"type\":\"uint256\"}],\"name\":\"setSwapTokensAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapTokensAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"botBlocks_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"botSeconds_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxTxAmount_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWalletAmount_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"botAddresses_\",\"type\":\"address[]\"}],\"name\":\"teleTweets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBots\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferDelayEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawCurrency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TELETWEETS", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b6f051704d83784a86522d06ef4cf6d895c968a600000000000000000000000012d85b9fd590be818eba239b2c6fbdd51f0f52b8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://63003beabe5bff8d83eaf90d07e68742ed1be3db314f265ca427a7151866101e"}]}