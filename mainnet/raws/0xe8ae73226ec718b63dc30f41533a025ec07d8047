{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.11;\r\n\r\ninterface WalletInterface {\r\n  event CallSuccess(\r\n    bool rolledBack,\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    bytes returnData\r\n  );\r\n\r\n  event CallFailure(\r\n    address to,\r\n    uint256 value,\r\n    bytes data,\r\n    string revertReason\r\n  );\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  // Use an array of Calls for executing generic batch calls.\r\n  struct Call {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n  }\r\n\r\n  // Use an array of CallReturns for handling generic batch calls.\r\n  struct CallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n  }\r\n\r\n  struct ValueReplacement {\r\n    uint24 returnDataOffset;\r\n    uint8 valueLength;\r\n    uint16 callIndex;\r\n  }\r\n\r\n  struct DataReplacement {\r\n    uint24 returnDataOffset;\r\n    uint24 dataLength;\r\n    uint16 callIndex;\r\n    uint24 callDataOffset;\r\n  }\r\n\r\n  struct AdvancedCall {\r\n    address to;\r\n    uint96 value;\r\n    bytes data;\r\n    ValueReplacement[] replaceValue;\r\n    DataReplacement[] replaceData;\r\n  }\r\n\r\n  struct AdvancedCallReturn {\r\n    bool ok;\r\n    bytes returnData;\r\n    uint96 callValue;\r\n    bytes callData;\r\n  }\r\n\r\n  receive() external payable;\r\n\r\n  function execute(\r\n    Call[] calldata calls\r\n  ) external returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function executeAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external returns (AdvancedCallReturn[] memory callResults);\r\n\r\n  function simulate(\r\n    Call[] calldata calls\r\n  ) external /* view */ returns (bool[] memory ok, bytes[] memory returnData);\r\n\r\n  function simulateAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ returns (AdvancedCallReturn[] memory callResults);\r\n\r\n  function claimOwnership(address owner) external;\r\n\r\n  function transferOwnership(address newOwner) external;\r\n\r\n  function cancelOwnershipTransfer() external;\r\n\r\n  function acceptOwnership() external;\r\n\r\n  function owner() external view returns (address);\r\n\r\n  function isOwner() external view returns (bool);\r\n\r\n  function isValidSignature(bytes32 digest, bytes memory signature) external view returns (bytes4);\r\n\r\n  function getImplementation() external view returns (address implementation);\r\n\r\n  function getVersion() external pure returns (uint256 version);\r\n\r\n  function initialize(address) external pure;\r\n}\r\n\r\n\r\n/**\r\n * @dev Library for determining if a given account is a contract.\r\n */\r\nlibrary Address {\r\n  function isContract(address account) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(account) }\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\r\n *\r\n * These functions can be used to verify that a message was signed by the holder\r\n * of the private keys of a given address.\r\n */\r\nlibrary ECDSA {\r\n    enum RecoverError {\r\n        NoError,\r\n        InvalidSignature,\r\n        InvalidSignatureLength,\r\n        InvalidSignatureS,\r\n        InvalidSignatureV\r\n    }\r\n\r\n    function _throwError(RecoverError error) private pure {\r\n        if (error == RecoverError.NoError) {\r\n            return; // no error: do nothing\r\n        } else if (error == RecoverError.InvalidSignature) {\r\n            revert(\"ECDSA: invalid signature\");\r\n        } else if (error == RecoverError.InvalidSignatureLength) {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        } else if (error == RecoverError.InvalidSignatureS) {\r\n            revert(\"ECDSA: invalid signature 's' value\");\r\n        } else if (error == RecoverError.InvalidSignatureV) {\r\n            revert(\"ECDSA: invalid signature 'v' value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature` or error string. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return tryRecover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return tryRecover(hash, r, vs);\r\n        } else {\r\n            return (address(0), RecoverError.InvalidSignatureLength);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address, RecoverError) {\r\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\r\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\r\n        return tryRecover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function tryRecover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address, RecoverError) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\r\n            return (address(0), RecoverError.InvalidSignatureS);\r\n        }\r\n        if (v != 27 && v != 28) {\r\n            return (address(0), RecoverError.InvalidSignatureV);\r\n        }\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        if (signer == address(0)) {\r\n            return (address(0), RecoverError.InvalidSignature);\r\n        }\r\n\r\n        return (signer, RecoverError.NoError);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\r\n     * `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\r\n        _throwError(error);\r\n        return recovered;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @notice Smart wallet supporting batch calls, EIP-1271, and call simulations.\r\n * In order to claim ownership of a given smart wallet, a signed message and\r\n * associated proof must be submitted to the \"MerkleWalletClaimer\" contract.\r\n * @author 0age\r\n */\r\ncontract SmartWallet is WalletInterface {\r\n  using Address for address;\r\n\r\n  // Skip over previously-used storage slots.\r\n  address private __DEPRECATED_SLOT_ONE__;\r\n  uint256 private __DEPRECATED_SLOT_TWO__;\r\n\r\n  // The self-call context flag is in storage slot 2. Some protected functions\r\n  // may only be called externally from calls originating from other methods on\r\n  // this contract, which enables appropriate exception handling on reverts.\r\n  // Any storage should only be set immediately preceding a self-call and should\r\n  // be cleared upon entering the protected function being called.\r\n  bytes4 internal _selfCallContext;\r\n\r\n  // Store the current owner of the contract.\r\n  address internal _owner;\r\n\r\n  // Store the next potential owner of the contract.\r\n  address internal _newPotentialOwner;\r\n\r\n  // Only this contract may call `claimOwnership` to set the initial owner.\r\n  address public constant merkleWalletClaimer = address(\r\n    0xD8470a6d796d54F13f243A4cf1a890E65bF3670E\r\n  );\r\n\r\n  // The \"upgrade beacon\" tracks the current implementation contract address/\r\n  address internal constant _UPGRADE_BEACON = address(\r\n    0x000000000026750c571ce882B17016557279ADaa\r\n  );\r\n\r\n  uint256 internal constant _VERSION = 17;\r\n\r\n  /**\r\n   * @notice Enable receipt of Ether.\r\n   */\r\n  receive() external payable override {}\r\n\r\n  /**\r\n   * @notice Execute an atomic batch of calls.\r\n   * Can only be called by the current owner.\r\n   * @param calls The calls to execute.\r\n   * @return ok The status of each call.\r\n   * @return returnData The returndata of each call.\r\n   */\r\n  function execute(\r\n    Call[] calldata calls\r\n  ) external override onlyOwner() returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this contract. However, one of the\r\n    // calls may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire a CallFailure event.\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _execute.\r\n    _selfCallContext = this.execute.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._execute.selector, calls\r\n      )\r\n    );\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    if (!externalOk) {\r\n      delete _selfCallContext;\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      Call memory currentCall = calls[i];\r\n\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          currentCall.to,\r\n          uint256(currentCall.value),\r\n          currentCall.data,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          currentCall.to,\r\n          uint256(currentCall.value),\r\n          currentCall.data,\r\n          _decodeRevertReason(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev \"Internal\" helper to execute an atomic batch of calls.\r\n   * Can only be called from this contract during a call to `execute`.\r\n   * @param calls The calls to execute.\r\n   * @return callResults The results of each call.\r\n   */\r\n  function _execute(\r\n    Call[] calldata calls\r\n  ) external returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.execute.selector);\r\n\r\n    bool rollBack = false;\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call{\r\n        value: uint256(calls[i].value)\r\n      }(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide bytes instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Execute an atomic batch of advanced calls (where returndata can be used to\r\n   * populate calldata of subsequent calls). Can only be called by the current owner.\r\n   * @param calls The advanced calls to execute.\r\n   * @return callResults The results of each advanced call.\r\n   */\r\n  function executeAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external override onlyOwner() returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Note: from this point on, there are no reverts (apart from out-of-gas or\r\n    // call-depth-exceeded) originating from this contract. However, one of the\r\n    // calls may revert, in which case the function will return `false`, along\r\n    // with the revert reason encoded as bytes, and fire an CallFailure event.\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    // Set self-call context to call _executeAdvanced.\r\n    _selfCallContext = this.executeAdvanced.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool externalOk, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._executeAdvanced.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: there are more efficient ways to check for revert reasons.\r\n    if (\r\n      rawCallResults.length > 68 && // prefix (4) + position (32) + length (32)\r\n      rawCallResults[0] == bytes1(0x08) &&\r\n      rawCallResults[1] == bytes1(0xc3) &&\r\n      rawCallResults[2] == bytes1(0x79) &&\r\n      rawCallResults[3] == bytes1(0xa0)\r\n    ) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    if (!externalOk) {\r\n      delete _selfCallContext;\r\n    }\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    callResults = abi.decode(rawCallResults, (AdvancedCallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      AdvancedCall memory currentCall = calls[i];\r\n\r\n      // Emit CallSuccess or CallFailure event based on the outcome of the call.\r\n      if (callResults[i].ok) {\r\n        // Note: while the call succeeded, the action may still have \"failed\".\r\n        emit CallSuccess(\r\n          !externalOk, // If another call failed this will have been rolled back\r\n          currentCall.to,\r\n          uint256(callResults[i].callValue),\r\n          callResults[i].callData,\r\n          callResults[i].returnData\r\n        );\r\n      } else {\r\n        // Note: while the call failed, the nonce will still be incremented,\r\n        // which will invalidate all supplied signatures.\r\n        emit CallFailure(\r\n          currentCall.to,\r\n          uint256(callResults[i].callValue),\r\n          callResults[i].callData,\r\n          _decodeRevertReason(callResults[i].returnData)\r\n        );\r\n\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev \"Internal\" helper to execute an atomic batch of advanced calls.\r\n   * Can only be called from this contract during a call to `executeAdvanced`.\r\n   * @param calls The advanced calls to execute.\r\n   * @return callResults The results of each advanced call.\r\n   */\r\n  function _executeAdvanced(\r\n    AdvancedCall[] memory calls\r\n  ) public returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.executeAdvanced.selector);\r\n\r\n    bool rollBack = false;\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      AdvancedCall memory a = calls[i];\r\n      uint256 callValue = uint256(a.value);\r\n      bytes memory callData = a.data;\r\n      uint256 callIndex;\r\n\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = a.to.call{value: callValue}(callData);\r\n      callResults[i] = AdvancedCallReturn({\r\n          ok: ok,\r\n          returnData: returnData,\r\n          callValue: uint96(callValue),\r\n          callData: callData\r\n      });\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        rollBack = true;\r\n        break;\r\n      }\r\n\r\n      for (uint256 j = 0; j < a.replaceValue.length; j++) {\r\n        callIndex = uint256(a.replaceValue[j].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace value using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 returnOffset = uint256(a.replaceValue[j].returnDataOffset);\r\n        uint256 valueLength = uint256(a.replaceValue[j].valueLength);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (valueLength == 0 || valueLength > 32) {\r\n          revert(\"bad valueLength\");\r\n        }\r\n\r\n        if (returnData.length < returnOffset + valueLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        AdvancedCall memory callTarget = calls[callIndex];\r\n        uint256 valueOffset = 32 - valueLength;\r\n        assembly {\r\n          returndatacopy(\r\n            add(add(callTarget, 32), valueOffset), returnOffset, valueLength\r\n          )\r\n        }\r\n      }\r\n\r\n      for (uint256 k = 0; k < a.replaceData.length; k++) {\r\n        callIndex = uint256(a.replaceData[k].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace data using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 callOffset = uint256(a.replaceData[k].callDataOffset);\r\n        uint256 returnOffset = uint256(a.replaceData[k].returnDataOffset);\r\n        uint256 dataLength = uint256(a.replaceData[k].dataLength);\r\n\r\n        if (returnData.length < returnOffset + dataLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        bytes memory callTargetData = calls[callIndex].data;\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (callTargetData.length < callOffset + dataLength) {\r\n          revert(\"Calldata too short to insert returndata at supplied offset.\");\r\n        }\r\n\r\n        assembly {\r\n          returndatacopy(\r\n            add(callTargetData, add(32, callOffset)), returnOffset, dataLength\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    if (rollBack) {\r\n      // Wrap in length encoding and revert (provide bytes instead of a string).\r\n      bytes memory callResultsBytes = abi.encode(callResults);\r\n      assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Simulate an atomic batch of calls. Any state changes will be rolled back.\r\n   * @param calls The calls to simulate.\r\n   * @return ok The simulated status of each call.\r\n   * @return returnData The simulated returndata of each call.\r\n   */\r\n  function simulate(\r\n    Call[] calldata calls\r\n  ) external /* view */ override returns (bool[] memory ok, bytes[] memory returnData) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    ok = new bool[](calls.length);\r\n    returnData = new bytes[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulate.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulate.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    delete _selfCallContext;\r\n\r\n    // Parse data returned from self-call into each call result and store / log.\r\n    CallReturn[] memory callResults = abi.decode(rawCallResults, (CallReturn[]));\r\n    for (uint256 i = 0; i < callResults.length; i++) {\r\n      // Set the status and the return data / revert reason from the call.\r\n      ok[i] = callResults[i].ok;\r\n      returnData[i] = callResults[i].returnData;\r\n\r\n      if (!callResults[i].ok) {\r\n        // exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev \"Internal\" helper to simulate an atomic batch of calls.\r\n   * Can only be called from this contract during a call to `simulate`.\r\n   * @param calls The calls to simulate.\r\n   * @return callResults The simulated results of each call.\r\n   */\r\n  function _simulate(\r\n    Call[] calldata calls\r\n  ) external returns (CallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulate.selector);\r\n\r\n    callResults = new CallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = calls[i].to.call{\r\n        value: uint256(calls[i].value)\r\n      }(calls[i].data);\r\n      callResults[i] = CallReturn({ok: ok, returnData: returnData});\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  /**\r\n   * @notice Simulate an atomic batch of advanced calls (where returndata can be used to\r\n   * populate calldata of subsequent calls). Any state changes will be rolled back.\r\n   * @param calls The advanced calls to simulate.\r\n   * @return callResults The simulated results of each advanced call.\r\n   */\r\n  function simulateAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ override returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure that each `to` address is a contract and is not this contract.\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      if (calls[i].value == 0) {\r\n        _ensureValidGenericCallTarget(calls[i].to);\r\n      }\r\n    }\r\n\r\n    // Specify length of returned values in order to work with them in memory.\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    // Set self-call context to call _simulateActionWithAtomicBatchCallsAtomic.\r\n    _selfCallContext = this.simulateAdvanced.selector;\r\n\r\n    // Make the atomic self-call - if any call fails, calls that preceded it\r\n    // will be rolled back and calls that follow it will not be made.\r\n    (bool mustBeFalse, bytes memory rawCallResults) = address(this).call(\r\n      abi.encodeWithSelector(\r\n        this._simulateAdvanced.selector, calls\r\n      )\r\n    );\r\n\r\n    // Note: this should never be the case, but check just to be extra safe.\r\n    if (mustBeFalse) {\r\n      revert(\"Simulation code must revert!\");\r\n    }\r\n\r\n    // Note: there are more efficient ways to check for revert reasons.\r\n    if (\r\n      rawCallResults.length > 68 && // prefix (4) + position (32) + length (32)\r\n      rawCallResults[0] == bytes1(0x08) &&\r\n      rawCallResults[1] == bytes1(0xc3) &&\r\n      rawCallResults[2] == bytes1(0x79) &&\r\n      rawCallResults[3] == bytes1(0xa0)\r\n    ) {\r\n      assembly {\r\n        returndatacopy(0, 0, returndatasize())\r\n        revert(0, returndatasize())\r\n      }\r\n    }\r\n\r\n    // Ensure that self-call context has been cleared.\r\n    delete _selfCallContext;\r\n\r\n    // Parse data returned from self-call into each call result and return.\r\n    callResults = abi.decode(rawCallResults, (AdvancedCallReturn[]));\r\n  }\r\n\r\n  /**\r\n   * @dev \"Internal\" helper to simulate an atomic batch of advanced calls.\r\n   * Can only be called from this contract during a call to `simulateAdvanced`.\r\n   * @param calls The advanced calls to simulate.\r\n   * @return callResults The simulated results of each advanced call.\r\n   */\r\n  function _simulateAdvanced(\r\n    AdvancedCall[] calldata calls\r\n  ) external /* view */ returns (AdvancedCallReturn[] memory callResults) {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    _enforceSelfCallFrom(this.simulateAdvanced.selector);\r\n\r\n    callResults = new AdvancedCallReturn[](calls.length);\r\n\r\n    for (uint256 i = 0; i < calls.length; i++) {\r\n      AdvancedCall memory a = calls[i];\r\n      uint256 callValue = uint256(a.value);\r\n      bytes memory callData = a.data;\r\n      uint256 callIndex;\r\n\r\n      // Perform low-level call and set return values using result.\r\n      (bool ok, bytes memory returnData) = a.to.call{value: callValue}(callData);\r\n      callResults[i] = AdvancedCallReturn({\r\n          ok: ok,\r\n          returnData: returnData,\r\n          callValue: uint96(callValue),\r\n          callData: callData\r\n      });\r\n      if (!ok) {\r\n        // Exit early - any calls after the first failed call will not execute.\r\n        break;\r\n      }\r\n\r\n      for (uint256 j = 0; j < a.replaceValue.length; j++) {\r\n        callIndex = uint256(a.replaceValue[j].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace value using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 returnOffset = uint256(a.replaceValue[j].returnDataOffset);\r\n        uint256 valueLength = uint256(a.replaceValue[j].valueLength);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (valueLength == 0 || valueLength > 32) {\r\n          revert(\"bad valueLength\");\r\n        }\r\n\r\n        if (returnData.length < returnOffset + valueLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        AdvancedCall memory callTarget = calls[callIndex];\r\n        uint256 valueOffset = 32 - valueLength;\r\n        assembly {\r\n          returndatacopy(\r\n            add(add(callTarget, 32), valueOffset), returnOffset, valueLength\r\n          )\r\n        }\r\n      }\r\n\r\n      for (uint256 k = 0; k < a.replaceData.length; k++) {\r\n        callIndex = uint256(a.replaceData[k].callIndex);\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (i >= callIndex) {\r\n          revert(\"Cannot replace data using call that has not yet been performed.\");\r\n        }\r\n\r\n        uint256 callOffset = uint256(a.replaceData[k].callDataOffset);\r\n        uint256 returnOffset = uint256(a.replaceData[k].returnDataOffset);\r\n        uint256 dataLength = uint256(a.replaceData[k].dataLength);\r\n\r\n        if (returnData.length < returnOffset + dataLength) {\r\n          revert(\"Return values are too short to give back a value at supplied index.\");\r\n        }\r\n\r\n        bytes memory callTargetData = calls[callIndex].data;\r\n\r\n        // Note: this check could be performed prior to execution.\r\n        if (callTargetData.length < callOffset + dataLength) {\r\n          revert(\"Calldata too short to insert returndata at supplied offset.\");\r\n        }\r\n\r\n        assembly {\r\n          returndatacopy(\r\n            add(callTargetData, add(32, callOffset)), returnOffset, dataLength\r\n          )\r\n        }\r\n      }\r\n    }\r\n\r\n    // Wrap in length encoding and revert (provide bytes instead of a string).\r\n    bytes memory callResultsBytes = abi.encode(callResults);\r\n    assembly { revert(add(32, callResultsBytes), mload(callResultsBytes)) }\r\n  }\r\n\r\n  /**\r\n   * @notice Enable the MerkleWalletClaimer contract to assign an owner.\r\n   * No other caller is permitted.\r\n   * @param newOwner The owner to assign.\r\n   */\r\n  function claimOwnership(address newOwner) external override {\r\n    require(\r\n      msg.sender == merkleWalletClaimer,\r\n      \"Only the MerkleWalletClaimer contract can call this function.\"\r\n    );\r\n\r\n    require(\r\n      _owner == address(0),\r\n      \"Cannot claim ownership with an owner already set.\"\r\n    );\r\n\r\n    require(newOwner != address(0), \"New owner cannot be the zero address.\");\r\n\r\n    _setOwner(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @notice Allow a new account (`newOwner`) to accept ownership.\r\n   * Can only be called by the current owner.\r\n   * @param newOwner the new potential owner.\r\n   */\r\n  function transferOwnership(address newOwner) external override onlyOwner() {\r\n    require(\r\n      newOwner != address(0),\r\n      \"transferOwnership: new potential owner is the zero address.\"\r\n    );\r\n\r\n    _newPotentialOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Cancel a transfer of ownership to a new account.\r\n   * Can only be called by the current owner.\r\n   */\r\n  function cancelOwnershipTransfer() external override onlyOwner() {\r\n    delete _newPotentialOwner;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfer ownership of the contract to the caller.\r\n   * Can only be called by a new potential owner set by the current owner.\r\n   */\r\n  function acceptOwnership() external override {\r\n    require(\r\n      msg.sender == _newPotentialOwner,\r\n      \"acceptOwnership: current owner must set caller as new potential owner.\"\r\n    );\r\n\r\n    delete _newPotentialOwner;\r\n\r\n    _setOwner(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the address of the current owner.\r\n   * @return The owner.\r\n   */\r\n  function owner() external view override returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns true if the caller is the current owner.\r\n   * @return True if caller is the owner, else false.\r\n   */\r\n  function isOwner() public view override returns (bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @notice Implementation of EIP-1271.\r\n   * Should return whether the signature provided is valid for the provided data.\r\n   * @param digest Hash of a message signed on the behalf of address(this)\r\n   * @param signature Signature byte array associated with digest\r\n   * @return The EIP-1271 magic value on success, otherwise empty bytes.\r\n   */\r\n  function isValidSignature(\r\n    bytes32 digest,\r\n    bytes memory signature\r\n  ) external view returns (bytes4) {\r\n    return ECDSA.recover(digest, signature) == _owner\r\n      ? this.isValidSignature.selector\r\n      : bytes4(0);\r\n  }\r\n\r\n  /**\r\n   * @notice View function for getting the current smart wallet\r\n   * implementation contract address set on the upgrade beacon.\r\n   * @return implementation The current smart wallet implementation contract.\r\n   */\r\n  function getImplementation() external view override returns (address implementation) {\r\n    (bool ok, bytes memory returnData) = _UPGRADE_BEACON.staticcall(\"\");\r\n\r\n    if (!(ok && returnData.length == 32)) {\r\n      revert(\"Could not retrieve implementation.\");\r\n    }\r\n\r\n    implementation = abi.decode(returnData, (address));\r\n  }\r\n\r\n  /**\r\n   * @notice Pure function for getting the current version.\r\n   * @return version The current version.\r\n   */\r\n  function getVersion() external pure override returns (uint256 version) {\r\n    version = _VERSION;\r\n  }\r\n\r\n  /**\r\n   * @notice Contract initialization is now a no-op.\r\n   */\r\n  function initialize(address) external pure override {}\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner(), \"caller is not the owner.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Set the owner of this contract.\r\n   * @param newOwner The new owner to set for this contract.\r\n   */\r\n  function _setOwner(address newOwner) internal {\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n\r\n    _owner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Ensure that calls to protected internal helpers originate from the\r\n   * correct source.\r\n   * @param selfCallContext The selector for the originating function.\r\n   */\r\n  function _enforceSelfCallFrom(bytes4 selfCallContext) internal {\r\n    // Ensure caller is this contract and self-call context is correctly set.\r\n    if (msg.sender != address(this) || _selfCallContext != selfCallContext) {\r\n      revert(\"External accounts or unapproved internal functions cannot call this.\");\r\n    }\r\n\r\n    // Clear the self-call context.\r\n    delete _selfCallContext;\r\n  }\r\n\r\n  /**\r\n   * @dev Ensure that calls specify a valid target.\r\n   * @param to The target account.\r\n   */\r\n  function _ensureValidGenericCallTarget(address to) internal view {\r\n    if (!to.isContract()) {\r\n      revert(\"Invalid `to` parameter - must supply a contract address containing code.\");\r\n    }\r\n\r\n    if (to == address(this)) {\r\n      revert(\"Invalid `to` parameter - cannot supply the address of this contract.\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Decode revert reasons.\r\n   * @param revertData The undecoded returndata from the reverting call.\r\n   */\r\n  function _decodeRevertReason(\r\n    bytes memory revertData\r\n  ) internal pure returns (string memory revertReason) {\r\n    // Solidity prefixes revert reason with 0x08c379a0 -> Error(string) selector\r\n    if (\r\n      revertData.length > 68 && // prefix (4) + position (32) + length (32)\r\n      revertData[0] == bytes1(0x08) &&\r\n      revertData[1] == bytes1(0xc3) &&\r\n      revertData[2] == bytes1(0x79) &&\r\n      revertData[3] == bytes1(0xa0)\r\n    ) {\r\n      // Get the revert reason without the prefix from the revert data.\r\n      bytes memory revertReasonBytes = new bytes(revertData.length - 4);\r\n      for (uint256 i = 4; i < revertData.length; i++) {\r\n        revertReasonBytes[i - 4] = revertData[i];\r\n      }\r\n\r\n      // Decode the resultant revert reason as a string.\r\n      revertReason = abi.decode(revertReasonBytes, (string));\r\n    } else {\r\n      // Simply return the default, with no revert reason.\r\n      revertReason = \"(no revert reason)\";\r\n    }\r\n  }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"revertReason\",\"type\":\"string\"}],\"name\":\"CallFailure\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"rolledBack\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"name\":\"CallSuccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_execute\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct WalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct WalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_executeAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_simulate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.CallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct WalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct WalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"_simulateAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct WalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct WalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"executeAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleWalletClaimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"simulate\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"ok\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"returnData\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint8\",\"name\":\"valueLength\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct WalletInterface.ValueReplacement[]\",\"name\":\"replaceValue\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint24\",\"name\":\"returnDataOffset\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"dataLength\",\"type\":\"uint24\"},{\"internalType\":\"uint16\",\"name\":\"callIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"callDataOffset\",\"type\":\"uint24\"}],\"internalType\":\"struct WalletInterface.DataReplacement[]\",\"name\":\"replaceData\",\"type\":\"tuple[]\"}],\"internalType\":\"struct WalletInterface.AdvancedCall[]\",\"name\":\"calls\",\"type\":\"tuple[]\"}],\"name\":\"simulateAdvanced\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"returnData\",\"type\":\"bytes\"},{\"internalType\":\"uint96\",\"name\":\"callValue\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct WalletInterface.AdvancedCallReturn[]\",\"name\":\"callResults\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SmartWallet", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d825e1b27208160707b1b9133d98335197cb066c140298708a018d7279f0cf74"}]}