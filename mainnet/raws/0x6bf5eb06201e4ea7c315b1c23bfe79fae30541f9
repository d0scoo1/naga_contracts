{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\npragma solidity ^0.8.4;\n\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}interface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\ninterface IGuarded {\n    function ANY_SIG() external view returns (bytes32);\n\n    function ANY_CALLER() external view returns (address);\n\n    function allowCaller(bytes32 sig, address who) external;\n\n    function blockCaller(bytes32 sig, address who) external;\n\n    function canCall(bytes32 sig, address who) external view returns (bool);\n}\n/// @title Guarded\n/// @notice Mixin implementing an authentication scheme on a method level\nabstract contract Guarded is IGuarded {\n    /// ======== Custom Errors ======== ///\n\n    error Guarded__notRoot();\n    error Guarded__notGranted();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Wildcard for granting a caller to call every guarded method\n    bytes32 public constant override ANY_SIG = keccak256(\"ANY_SIG\");\n    /// @notice Wildcard for granting a caller to call every guarded method\n    address public constant override ANY_CALLER = address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\n\n    /// @notice Mapping storing who is granted to which method\n    /// @dev Method Signature => Caller => Bool\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\n\n    /// ======== Events ======== ///\n\n    event AllowCaller(bytes32 sig, address who);\n    event BlockCaller(bytes32 sig, address who);\n\n    constructor() {\n        // set root\n        _setRoot(msg.sender);\n    }\n\n    /// ======== Auth ======== ///\n\n    modifier callerIsRoot() {\n        if (_canCall[ANY_SIG][msg.sender]) {\n            _;\n        } else revert Guarded__notRoot();\n    }\n\n    modifier checkCaller() {\n        if (canCall(msg.sig, msg.sender)) {\n            _;\n        } else revert Guarded__notGranted();\n    }\n\n    /// @notice Grant the right to call method `sig` to `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function allowCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = true;\n        emit AllowCaller(sig, who);\n    }\n\n    /// @notice Revoke the right to call method `sig` from `who`\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should not be able to call `sig` anymore\n    function blockCaller(bytes32 sig, address who) public override callerIsRoot {\n        _canCall[sig][who] = false;\n        emit BlockCaller(sig, who);\n    }\n\n    /// @notice Returns if `who` can call `sig`\n    /// @param sig Method signature (4Byte)\n    /// @param who Address of who should be able to call `sig`\n    function canCall(bytes32 sig, address who) public view override returns (bool) {\n        return (_canCall[sig][who] || _canCall[ANY_SIG][who] || _canCall[sig][ANY_CALLER]);\n    }\n\n    /// @notice Sets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be set as root\n    function _setRoot(address root) internal {\n        _canCall[ANY_SIG][root] = true;\n        emit AllowCaller(ANY_SIG, root);\n    }\n\n    /// @notice Unsets the root user (granted `ANY_SIG`)\n    /// @param root Address of who should be unset as root\n    function _unsetRoot(address root) internal {\n        _canCall[ANY_SIG][root] = false;\n        emit AllowCaller(ANY_SIG, root);\n    }\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\n/// @title Codex\n/// @notice `Codex` is responsible for the accounting of collateral and debt balances\n/// Uses Vat.sol from DSS (MakerDAO) / SafeEngine.sol from GEB (Reflexer Labs) as a blueprint\n/// Changes from Vat.sol / SafeEngine.sol:\n/// - only WAD precision is used (no RAD and RAY)\n/// - uses a method signature based authentication scheme\n/// - supports ERC1155, ERC721 style assets by TokenId\ncontract Codex is Guarded, ICodex {\n    /// ======== Custom Errors ======== ///\n\n    error Codex__init_vaultAlreadyInit();\n    error Codex__setParam_notLive();\n    error Codex__setParam_unrecognizedParam();\n    error Codex__transferBalance_notAllowed();\n    error Codex__transferCredit_notAllowed();\n    error Codex__modifyCollateralAndDebt_notLive();\n    error Codex__modifyCollateralAndDebt_vaultNotInit();\n    error Codex__modifyCollateralAndDebt_ceilingExceeded();\n    error Codex__modifyCollateralAndDebt_notSafe();\n    error Codex__modifyCollateralAndDebt_notAllowedSender();\n    error Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n    error Codex__modifyCollateralAndDebt_notAllowedDebtor();\n    error Codex__modifyCollateralAndDebt_debtFloor();\n    error Codex__transferCollateralAndDebt_notAllowed();\n    error Codex__transferCollateralAndDebt_notSafeSrc();\n    error Codex__transferCollateralAndDebt_notSafeDst();\n    error Codex__transferCollateralAndDebt_debtFloorSrc();\n    error Codex__transferCollateralAndDebt_debtFloorDst();\n    error Codex__modifyRate_notLive();\n\n    /// ======== Storage ======== ///\n\n    // Vault Data\n    struct Vault {\n        // Total Normalised Debt in Vault [wad]\n        uint256 totalNormalDebt;\n        // Vault's Accumulation Rate [wad]\n        uint256 rate;\n        // Vault's Debt Ceiling [wad]\n        uint256 debtCeiling;\n        // Debt Floor for Positions corresponding to this Vault [wad]\n        uint256 debtFloor;\n    }\n    // Position Data\n    struct Position {\n        // Locked Collateral in Position [wad]\n        uint256 collateral;\n        // Normalised Debt (gross debt before rate is applied) generated by Position [wad]\n        uint256 normalDebt;\n    }\n\n    /// @notice Map of delegatees who can modify collateral, debt and credit on behalf of a delegator\n    /// @dev Delegator => Delegatee => hasDelegate\n    mapping(address => mapping(address => uint256)) public override delegates;\n    /// @notice Vaults\n    /// @dev Vault => Vault Data\n    mapping(address => Vault) public override vaults;\n    /// @notice Positions\n    /// @dev Vault => TokenId => Owner => Position\n    mapping(address => mapping(uint256 => mapping(address => Position))) public override positions;\n    /// @notice Token balances not put up for collateral in a Position\n    /// @dev Vault => TokenId => Owner => Balance [wad]\n    mapping(address => mapping(uint256 => mapping(address => uint256))) public override balances;\n    /// @notice Credit balances\n    /// @dev Account => Credit [wad]\n    mapping(address => uint256) public override credit;\n    /// @notice Unbacked Debt balances\n    /// @dev Account => Unbacked Debt [wad]\n    mapping(address => uint256) public override unbackedDebt;\n\n    /// @notice Global Debt (incl. rate) outstanding == Credit Issued [wad]\n    uint256 public override globalDebt;\n    /// @notice Global Unbacked Debt (incl. rate) oustanding == Total Credit [wad]\n    uint256 public override globalUnbackedDebt;\n    /// @notice Global Debt Ceiling [wad]\n    uint256 public override globalDebtCeiling;\n\n    /// @notice Boolean indicating if this contract is live (0 - not live, 1 - live)\n    uint256 public live;\n\n    /// ======== Events ======== ///\n    event Init(address indexed vault);\n    event SetParam(bytes32 indexed param, uint256 data);\n    event SetParam(address indexed vault, bytes32 indexed param, uint256 data);\n    event GrantDelegate(address indexed delegator, address indexed delegatee);\n    event RevokeDelegate(address indexed delegator, address indexed delegatee);\n    event ModifyBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        int256 amount,\n        uint256 balance\n    );\n    event TransferBalance(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        uint256 amount,\n        uint256 srcBalance,\n        uint256 dstBalance\n    );\n    event TransferCredit(\n        address indexed src,\n        address indexed dst,\n        uint256 amount,\n        uint256 srcCredit,\n        uint256 dstCredit\n    );\n    event ModifyCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event TransferCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event ConfiscateCollateralAndDebt(\n        address indexed vault,\n        uint256 indexed tokenId,\n        address indexed user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    );\n    event SettleUnbackedDebt(address indexed debtor, uint256 debt);\n    event CreateUnbackedDebt(address indexed debtor, address indexed creditor, uint256 debt);\n    event ModifyRate(address indexed vault, address indexed creditor, int256 deltaRate);\n    event Lock();\n\n    constructor() Guarded() {\n        live = 1;\n    }\n\n    /// ======== Configuration ======== ///\n\n    /// @notice Initializes a new Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    function init(address vault) external override checkCaller {\n        if (vaults[vault].rate != 0) revert Codex__init_vaultAlreadyInit();\n        vaults[vault].rate = WAD;\n        emit Init(vault);\n    }\n\n    /// @notice Sets various variables for this contract\n    /// @dev Sender has to be allowed to call this method\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(bytes32 param, uint256 data) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"globalDebtCeiling\") globalDebtCeiling = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(param, data);\n    }\n\n    /// @notice Sets various variables for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param param Name of the variable to set\n    /// @param data New value to set for the variable [wad]\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external override checkCaller {\n        if (live == 0) revert Codex__setParam_notLive();\n        if (param == \"debtCeiling\") vaults[vault].debtCeiling = data;\n        else if (param == \"debtFloor\") vaults[vault].debtFloor = data;\n        else revert Codex__setParam_unrecognizedParam();\n        emit SetParam(vault, param, data);\n    }\n\n    /// ======== Caller Delegation ======== ///\n\n    /// @notice Grants the delegatee the ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function grantDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 1;\n        emit GrantDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Revokes the delegatee's ability to modify collateral, debt and credit balances on behalf of the caller\n    /// @param delegatee Address of the delegatee\n    function revokeDelegate(address delegatee) external override {\n        delegates[msg.sender][delegatee] = 0;\n        emit RevokeDelegate(msg.sender, delegatee);\n    }\n\n    /// @notice Checks the delegate\n    /// @param delegator Address of the delegator\n    /// @param delegatee Address of the delegatee\n    /// @return True if delegate is granted\n    function hasDelegate(address delegator, address delegatee) internal view returns (bool) {\n        return delegator == delegatee || delegates[delegator][delegatee] == 1;\n    }\n\n    /// ======== Credit and Token Balance Administration ======== ///\n\n    /// @notice Updates the token balance for a `user`\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param amount Amount to add (positive) or subtract (negative) [wad]\n    function modifyBalance(\n        address vault,\n        uint256 tokenId,\n        address user,\n        int256 amount\n    ) external override checkCaller {\n        balances[vault][tokenId][user] = add(balances[vault][tokenId][user], amount);\n        emit ModifyBalance(vault, tokenId, user, amount, balances[vault][tokenId][user]);\n    }\n\n    /// @notice Transfer an `amount` of tokens from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferBalance_notAllowed();\n        balances[vault][tokenId][src] = sub(balances[vault][tokenId][src], amount);\n        balances[vault][tokenId][dst] = add(balances[vault][tokenId][dst], amount);\n        emit TransferBalance(\n            vault,\n            tokenId,\n            src,\n            dst,\n            amount,\n            balances[vault][tokenId][src],\n            balances[vault][tokenId][dst]\n        );\n    }\n\n    /// @notice Transfer an `amount` of Credit from `src` to `dst`\n    /// @dev Sender has to be delegated by `src`\n    /// @param src From address\n    /// @param dst To address\n    /// @param amount Amount to be transferred [wad]\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external override {\n        if (!hasDelegate(src, msg.sender)) revert Codex__transferCredit_notAllowed();\n        credit[src] = sub(credit[src], amount);\n        credit[dst] = add(credit[dst], amount);\n        emit TransferCredit(src, dst, amount, credit[src], credit[dst]);\n    }\n\n    /// ======== Position Administration ======== ///\n\n    /// @notice Modifies a Position's collateral and debt balances\n    /// @dev Checks that the global debt ceiling and the vault's debt ceiling have not been exceeded,\n    /// that the Position is still safe after the modification,\n    /// that the sender is delegated by the owner if the collateral-to-debt ratio decreased,\n    /// that the sender is delegated by the collateralizer if new collateral is put up,\n    /// that the sender is delegated by the creditor if debt is settled,\n    /// and that the vault debt floor is exceeded\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the credit delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        // system is live\n        if (live == 0) revert Codex__modifyCollateralAndDebt_notLive();\n\n        Position memory p = positions[vault][tokenId][user];\n        Vault memory v = vaults[vault];\n        // vault has been initialised\n        if (v.rate == 0) revert Codex__modifyCollateralAndDebt_vaultNotInit();\n\n        p.collateral = add(p.collateral, deltaCollateral);\n        p.normalDebt = add(p.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n        uint256 debt = wmul(v.rate, p.normalDebt);\n        globalDebt = add(globalDebt, deltaDebt);\n\n        // either debt has decreased, or debt ceilings are not exceeded\n        if (deltaNormalDebt > 0 && (wmul(v.totalNormalDebt, v.rate) > v.debtCeiling || globalDebt > globalDebtCeiling))\n            revert Codex__modifyCollateralAndDebt_ceilingExceeded();\n        // position is either less risky than before, or it is safe\n        if (\n            (deltaNormalDebt > 0 || deltaCollateral < 0) &&\n            debt > wmul(p.collateral, IVault(vault).fairPrice(tokenId, true, false))\n        ) revert Codex__modifyCollateralAndDebt_notSafe();\n\n        // position is either more safe, or the owner consents\n        if ((deltaNormalDebt > 0 || deltaCollateral < 0) && !hasDelegate(user, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedSender();\n        // collateralizer consents if new collateral is put up\n        if (deltaCollateral > 0 && !hasDelegate(collateralizer, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedCollateralizer();\n\n        // creditor consents if debt is settled with credit\n        if (deltaNormalDebt < 0 && !hasDelegate(creditor, msg.sender))\n            revert Codex__modifyCollateralAndDebt_notAllowedDebtor();\n\n        // position has no debt, or a non-dusty amount\n        if (p.normalDebt != 0 && debt < v.debtFloor) revert Codex__modifyCollateralAndDebt_debtFloor();\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        credit[creditor] = add(credit[creditor], deltaDebt);\n\n        positions[vault][tokenId][user] = p;\n        vaults[vault] = v;\n\n        emit ModifyCollateralAndDebt(vault, tokenId, user, collateralizer, creditor, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Transfers a Position's collateral and debt balances to another Position\n    /// @dev Checks that the sender is delegated by `src` and `dst` Position owners,\n    /// that the `src` and `dst` Positions are still safe after the transfer,\n    /// and that the `src` and `dst` Positions' debt exceed the vault's debt floor\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param src Address of the `src` Positions owner\n    /// @param dst Address of the `dst` Positions owner\n    /// @param deltaCollateral Amount of collateral to send to (+) or from (-) the `src` Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to send to (+) or\n    /// from (-) the `dst` Position [wad]\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override {\n        Position storage pSrc = positions[vault][tokenId][src];\n        Position storage pDst = positions[vault][tokenId][dst];\n        Vault storage v = vaults[vault];\n\n        pSrc.collateral = sub(pSrc.collateral, deltaCollateral);\n        pSrc.normalDebt = sub(pSrc.normalDebt, deltaNormalDebt);\n        pDst.collateral = add(pDst.collateral, deltaCollateral);\n        pDst.normalDebt = add(pDst.normalDebt, deltaNormalDebt);\n\n        uint256 debtSrc = wmul(pSrc.normalDebt, v.rate);\n        uint256 debtDst = wmul(pDst.normalDebt, v.rate);\n\n        // both sides consent\n        if (!hasDelegate(src, msg.sender) || !hasDelegate(dst, msg.sender))\n            revert Codex__transferCollateralAndDebt_notAllowed();\n\n        // both sides safe\n        if (debtSrc > wmul(pSrc.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeSrc();\n        if (debtDst > wmul(pDst.collateral, IVault(vault).fairPrice(tokenId, true, false)))\n            revert Codex__transferCollateralAndDebt_notSafeDst();\n\n        // both sides non-dusty\n        if (pSrc.normalDebt != 0 && debtSrc < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorSrc();\n        if (pDst.normalDebt != 0 && debtDst < v.debtFloor) revert Codex__transferCollateralAndDebt_debtFloorDst();\n\n        emit TransferCollateralAndDebt(vault, tokenId, src, dst, deltaCollateral, deltaNormalDebt);\n    }\n\n    /// @notice Confiscates a Position's collateral and debt balances\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the Vault\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param user Address of the user\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param debtor Address of who provides or receives the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external override checkCaller {\n        Position storage position = positions[vault][tokenId][user];\n        Vault storage v = vaults[vault];\n\n        position.collateral = add(position.collateral, deltaCollateral);\n        position.normalDebt = add(position.normalDebt, deltaNormalDebt);\n        v.totalNormalDebt = add(v.totalNormalDebt, deltaNormalDebt);\n\n        int256 deltaDebt = wmul(v.rate, deltaNormalDebt);\n\n        balances[vault][tokenId][collateralizer] = sub(balances[vault][tokenId][collateralizer], deltaCollateral);\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], deltaDebt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, deltaDebt);\n\n        emit ConfiscateCollateralAndDebt(\n            vault,\n            tokenId,\n            user,\n            collateralizer,\n            debtor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// ======== Unbacked Debt ======== ///\n\n    /// @notice Settles unbacked debt with the sender's credit\n    /// @dev Reverts if the sender does not have sufficient credit available to settle the debt\n    /// @param debt Amount of debt to settle [wawd]\n    function settleUnbackedDebt(uint256 debt) external override {\n        address debtor = msg.sender;\n        unbackedDebt[debtor] = sub(unbackedDebt[debtor], debt);\n        credit[debtor] = sub(credit[debtor], debt);\n        globalUnbackedDebt = sub(globalUnbackedDebt, debt);\n        globalDebt = sub(globalDebt, debt);\n        emit SettleUnbackedDebt(debtor, debt);\n    }\n\n    /// @notice Create unbacked debt / credit\n    /// @dev Sender has to be allowed to call this method\n    /// @param debtor Address of the account who takes the unbacked debt\n    /// @param creditor Address of the account who gets the credit\n    /// @param debt Amount of unbacked debt / credit to generate [wad]\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external override checkCaller {\n        unbackedDebt[debtor] = add(unbackedDebt[debtor], debt);\n        credit[creditor] = add(credit[creditor], debt);\n        globalUnbackedDebt = add(globalUnbackedDebt, debt);\n        globalDebt = add(globalDebt, debt);\n        emit CreateUnbackedDebt(debtor, creditor, debt);\n    }\n\n    /// ======== Debt Interest Rates ======== ///\n\n    /// @notice Updates the rate value and collects the accrued interest for a Vault\n    /// @dev Sender has to be allowed to call this method\n    /// @param vault Address of the vault\n    /// @param creditor Address of the account who gets the accrued interest\n    /// @param deltaRate Delta to increase (+) or decrease (-) the rate [percentage in wad]\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 deltaRate\n    ) external override checkCaller {\n        if (live == 0) revert Codex__modifyRate_notLive();\n        Vault storage v = vaults[vault];\n        v.rate = add(v.rate, deltaRate);\n        int256 wad = wmul(v.totalNormalDebt, deltaRate);\n        credit[creditor] = add(credit[creditor], wad);\n        globalDebt = add(globalDebt, wad);\n        emit ModifyRate(vault, creditor, deltaRate);\n    }\n\n    /// ======== Shutdown ======== ///\n\n    /// @notice Locks the contract\n    /// @dev Sender has to be allowed to call this method\n    function lock() external override checkCaller {\n        live = 0;\n        emit Lock();\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Codex__init_vaultAlreadyInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_ceilingExceeded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_debtFloor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_notAllowedCollateralizer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_notAllowedDebtor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_notAllowedSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_notLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_notSafe\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyCollateralAndDebt_vaultNotInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__modifyRate_notLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__setParam_notLive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__setParam_unrecognizedParam\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferBalance_notAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCollateralAndDebt_debtFloorDst\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCollateralAndDebt_debtFloorSrc\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCollateralAndDebt_notAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCollateralAndDebt_notSafeDst\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCollateralAndDebt_notSafeSrc\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Codex__transferCredit_notAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Guarded__notGranted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Guarded__notRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__add_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math__add_overflow_signed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__mul_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math__mul_overflow_signed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__sub_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math__sub_overflow_signed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AllowCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"BlockCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"ConfiscateCollateralAndDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"CreateUnbackedDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"GrantDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"Init\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Lock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"ModifyBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"ModifyCollateralAndDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaRate\",\"type\":\"int256\"}],\"name\":\"ModifyRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"RevokeDelegate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"SetParam\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"SettleUnbackedDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstBalance\",\"type\":\"uint256\"}],\"name\":\"TransferBalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"TransferCollateralAndDebt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcCredit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstCredit\",\"type\":\"uint256\"}],\"name\":\"TransferCredit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_CALLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANY_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"allowCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"blockCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"confiscateCollateralAndDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"debtor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"createUnbackedDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"credit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalDebtCeiling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalUnbackedDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"grantDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"live\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"amount\",\"type\":\"int256\"}],\"name\":\"modifyBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"modifyCollateralAndDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaRate\",\"type\":\"int256\"}],\"name\":\"modifyRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"normalDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"revokeDelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"param\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"debt\",\"type\":\"uint256\"}],\"name\":\"settleUnbackedDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"transferCollateralAndDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferCredit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"unbackedDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"vaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalNormalDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtCeiling\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtFloor\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Codex", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}