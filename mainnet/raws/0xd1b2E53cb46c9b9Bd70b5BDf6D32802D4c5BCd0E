{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LosslessControllerV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\nimport \\\"./Interfaces/ILosslessERC20.sol\\\";\\nimport \\\"./Interfaces/ILosslessGovernance.sol\\\";\\nimport \\\"./Interfaces/ILosslessStaking.sol\\\";\\nimport \\\"./Interfaces/ILosslessReporting.sol\\\";\\nimport \\\"./Interfaces/IProtectionStrategy.sol\\\";\\n\\n/// @title Lossless Controller Contract\\n/// @notice The controller contract is in charge of the communication and senstive data among all Lossless Environment Smart Contracts\\ncontract LosslessControllerV3 is ILssController, Initializable, ContextUpgradeable, PausableUpgradeable {\\n    \\n    // IMPORTANT!: For future reference, when adding new variables for following versions of the controller. \\n    // All the previous ones should be kept in place and not change locations, types or names.\\n    // If thye're modified this would cause issues with the memory slots.\\n\\n    address override public pauseAdmin;\\n    address override public admin;\\n    address override public recoveryAdmin;\\n\\n    // --- V2 VARIABLES ---\\n\\n    address override public guardian;\\n    mapping(ILERC20 => Protections) private tokenProtections;\\n\\n    struct Protection {\\n        bool isProtected;\\n        ProtectionStrategy strategy;\\n    }\\n\\n    struct Protections {\\n        mapping(address => Protection) protections;\\n    }\\n\\n    // --- V3 VARIABLES ---\\n\\n    ILssStaking override public losslessStaking;\\n    ILssReporting override public losslessReporting;\\n    ILssGovernance override public losslessGovernance;\\n\\n    struct LocksQueue {\\n        mapping(uint256 => ReceiveCheckpoint) lockedFunds;\\n        uint256 touchedTimestamp;\\n        uint256 first;\\n        uint256 last;\\n    }\\n\\n    struct TokenLockedFunds {\\n        mapping(address => LocksQueue) queue;\\n    }\\n\\n    mapping(ILERC20 => TokenLockedFunds) private tokenScopedLockedFunds;\\n    \\n    struct ReceiveCheckpoint {\\n        uint256 amount;\\n        uint256 timestamp;\\n        uint256 cummulativeAmount;\\n    }\\n    \\n    uint256 public constant HUNDRED = 1e2;\\n    uint256 override public dexTranferThreshold;\\n    uint256 override public settlementTimeLock;\\n\\n    mapping(address => bool) override public dexList;\\n    mapping(address => bool) override public whitelist;\\n    mapping(address => bool) override public blacklist;\\n\\n    struct TokenConfig {\\n        uint256 tokenLockTimeframe;\\n        uint256 proposedTokenLockTimeframe;\\n        uint256 changeSettlementTimelock;\\n        uint256 emergencyMode;\\n    }\\n\\n    mapping(ILERC20 => TokenConfig) tokenConfig;\\n\\n    // --- MODIFIERS ---\\n\\n    /// @notice Avoids execution from other than the Recovery Admin\\n    modifier onlyLosslessRecoveryAdmin() {\\n        require(msg.sender == recoveryAdmin, \\\"LSS: Must be recoveryAdmin\\\");\\n        _;\\n    }\\n\\n    /// @notice Avoids execution from other than the Lossless Admin\\n    modifier onlyLosslessAdmin() {\\n        require(msg.sender == admin, \\\"LSS: Must be admin\\\");\\n        _;\\n    }\\n\\n    /// @notice Avoids execution from other than the Pause Admin\\n    modifier onlyPauseAdmin() {\\n        require(msg.sender == pauseAdmin, \\\"LSS: Must be pauseAdmin\\\");\\n        _;\\n    }\\n\\n    // --- V2 MODIFIERS ---\\n\\n    modifier onlyGuardian() {\\n        require(msg.sender == guardian, \\\"LOSSLESS: Must be Guardian\\\");\\n        _;\\n    }\\n\\n    // --- V3 MODIFIERS ---\\n\\n    /// @notice Avoids execution from other than the Lossless Admin or Lossless Environment\\n    modifier onlyLosslessEnv {\\n        require(msg.sender == address(losslessStaking)   ||\\n                msg.sender == address(losslessReporting) || \\n                msg.sender == address(losslessGovernance),\\n                \\\"LSS: Lss SC only\\\");\\n        _;\\n    }\\n\\n    // --- VIEWS ---\\n\\n    /// @notice This function will return the contract version \\n    function getVersion() external pure returns (uint256) {\\n        return 3;\\n    }\\n\\n        // --- V2 VIEWS ---\\n\\n    function isAddressProtected(ILERC20 _token, address _protectedAddress) public view returns (bool) {\\n        return tokenProtections[_token].protections[_protectedAddress].isProtected;\\n    }\\n\\n    function getProtectedAddressStrategy(ILERC20 _token, address _protectedAddress) external view returns (address) {\\n        require(isAddressProtected(_token, _protectedAddress), \\\"LSS: Address not protected\\\");\\n        return address(tokenProtections[_token].protections[_protectedAddress].strategy);\\n    }\\n\\n    // --- ADMINISTRATION ---\\n\\n    function pause() override public onlyPauseAdmin  {\\n        _pause();\\n    }    \\n    \\n    function unpause() override public onlyPauseAdmin {\\n        _unpause();\\n    }\\n\\n    /// @notice This function sets a new admin\\n    /// @dev Only can be called by the Recovery admin\\n    /// @param _newAdmin Address corresponding to the new Lossless Admin\\n    function setAdmin(address _newAdmin) override public onlyLosslessRecoveryAdmin {\\n        require(_newAdmin != admin, \\\"LERC20: Cannot set same address\\\");\\n        emit AdminChange(_newAdmin);\\n        admin = _newAdmin;\\n    }\\n\\n    /// @notice This function sets a new recovery admin\\n    /// @dev Only can be called by the previous Recovery admin\\n    /// @param _newRecoveryAdmin Address corresponding to the new Lossless Recovery Admin\\n    function setRecoveryAdmin(address _newRecoveryAdmin) override public onlyLosslessRecoveryAdmin {\\n        require(_newRecoveryAdmin != recoveryAdmin, \\\"LERC20: Cannot set same address\\\");\\n        emit RecoveryAdminChange(_newRecoveryAdmin);\\n        recoveryAdmin = _newRecoveryAdmin;\\n    }\\n\\n    /// @notice This function sets a new pause admin\\n    /// @dev Only can be called by the Recovery admin\\n    /// @param _newPauseAdmin Address corresponding to the new Lossless Recovery Admin\\n    function setPauseAdmin(address _newPauseAdmin) override public onlyLosslessRecoveryAdmin {\\n        require(_newPauseAdmin != pauseAdmin, \\\"LERC20: Cannot set same address\\\");\\n        emit PauseAdminChange(_newPauseAdmin);\\n        pauseAdmin = _newPauseAdmin;\\n    }\\n\\n\\n    // --- V3 SETTERS ---\\n\\n    /// @notice This function sets the timelock for tokens to change the settlement period\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _newTimelock Timelock in seconds\\n    function setSettlementTimeLock(uint256 _newTimelock) override public onlyLosslessAdmin {\\n        require(_newTimelock != settlementTimeLock, \\\"LSS: Cannot set same value\\\");\\n        settlementTimeLock = _newTimelock;\\n        emit NewSettlementTimelock(settlementTimeLock);\\n    }\\n\\n    /// @notice This function sets the transfer threshold for Dexes\\n    /// @dev Only can be called by the Lossless Admin\\n    /// @param _newThreshold Timelock in seconds\\n    function setDexTransferThreshold(uint256 _newThreshold) override public onlyLosslessAdmin {\\n        require(_newThreshold != dexTranferThreshold, \\\"LSS: Cannot set same value\\\");\\n        dexTranferThreshold = _newThreshold;\\n        emit NewDexThreshold(dexTranferThreshold);\\n    }\\n    \\n    /// @notice This function removes or adds an array of dex addresses from the whitelst\\n    /// @dev Only can be called by the Lossless Admin, only Lossless addresses \\n    /// @param _dexList List of dex addresses to add or remove\\n    /// @param _value True if the addresses are bieng added, false if removed\\n    function setDexList(address[] calldata _dexList, bool _value) override public onlyLosslessAdmin {\\n        for(uint256 i = 0; i < _dexList.length;) {\\n\\n            address adr = _dexList[i];\\n            require(!blacklist[adr], \\\"LSS: An address is blacklisted\\\");\\n\\n            dexList[adr] = _value;\\n\\n            if (_value) {\\n                emit NewDex(adr);\\n            } else {\\n                emit DexRemoval(adr);\\n            }\\n\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    /// @notice This function removes or adds an array of addresses from the whitelst\\n    /// @dev Only can be called by the Lossless Admin, only Lossless addresses \\n    /// @param _addrList List of addresses to add or remove\\n    /// @param _value True if the addresses are bieng added, false if removed\\n    function setWhitelist(address[] calldata _addrList, bool _value) override public onlyLosslessAdmin {\\n        for(uint256 i = 0; i < _addrList.length;) {\\n\\n            address adr = _addrList[i];\\n            require(!blacklist[adr], \\\"LSS: An address is blacklisted\\\");\\n\\n            whitelist[adr] = _value;\\n\\n            if (_value) {\\n                emit NewWhitelistedAddress(adr);\\n            } else {\\n                emit WhitelistedAddressRemoval(adr);\\n            }\\n\\n            unchecked{i++;}\\n        }\\n    }\\n\\n    /// @notice This function adds an address to the blacklist\\n    /// @dev Only can be called by the Lossless Admin, and from other Lossless Contracts\\n    /// The address gets blacklisted whenever a report is created on them.\\n    /// @param _adr Address corresponding to be added to the blacklist mapping\\n    function addToBlacklist(address _adr) override public onlyLosslessEnv {\\n        blacklist[_adr] = true;\\n        emit NewBlacklistedAddress(_adr);\\n    }\\n\\n    /// @notice This function removes an address from the blacklist\\n    /// @dev Can only be called from other Lossless Contracts, used mainly in Lossless Governance\\n    /// @param _adr Address corresponding to be removed from the blacklist mapping\\n    function resolvedNegatively(address _adr) override public onlyLosslessEnv {\\n        blacklist[_adr] = false;\\n        emit AccountBlacklistRemoval(_adr);\\n    }\\n    \\n    /// @notice This function sets the address of the Lossless Staking contract\\n    /// @param _adr Address corresponding to the Lossless Staking contract\\n    function setStakingContractAddress(ILssStaking _adr) override public onlyLosslessAdmin {\\n        require(address(_adr) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        require(_adr != losslessStaking, \\\"LSS: Cannot set same value\\\");\\n        losslessStaking = _adr;\\n        emit NewStakingContract(_adr);\\n    }\\n\\n    /// @notice This function sets the address of the Lossless Reporting contract\\n    /// @param _adr Address corresponding to the Lossless Reporting contract\\n    function setReportingContractAddress(ILssReporting _adr) override public onlyLosslessAdmin {\\n        require(address(_adr) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        require(_adr != losslessReporting, \\\"LSS: Cannot set same value\\\");\\n        losslessReporting = _adr;\\n        emit NewReportingContract(_adr);\\n    }\\n\\n    /// @notice This function sets the address of the Lossless Governance contract\\n    /// @param _adr Address corresponding to the Lossless Governance contract\\n    function setGovernanceContractAddress(ILssGovernance _adr) override public onlyLosslessAdmin {\\n        require(address(_adr) != address(0), \\\"LERC20: Cannot be zero address\\\");\\n        require(_adr != losslessGovernance, \\\"LSS: Cannot set same value\\\");\\n        losslessGovernance = _adr;\\n        emit NewGovernanceContract(_adr);\\n    }\\n\\n    /// @notice This function starts a new proposal to change the SettlementPeriod\\n    /// @param _token to propose the settlement change period on\\n    /// @param _seconds Time frame that the recieved funds will be locked\\n    function proposeNewSettlementPeriod(ILERC20 _token, uint256 _seconds) override public {\\n\\n        TokenConfig storage config = tokenConfig[_token];\\n\\n        require(msg.sender == _token.admin(), \\\"LSS: Must be Token Admin\\\");\\n        require(config.changeSettlementTimelock <= block.timestamp, \\\"LSS: Time lock in progress\\\");\\n        config.changeSettlementTimelock = block.timestamp + settlementTimeLock;\\n        config.proposedTokenLockTimeframe = _seconds;\\n        emit NewSettlementPeriodProposal(_token, _seconds);\\n    }\\n\\n    /// @notice This function executes the new settlement period after the timelock\\n    /// @param _token to set time settlement period on\\n    function executeNewSettlementPeriod(ILERC20 _token) override public {\\n\\n        TokenConfig storage config = tokenConfig[_token];\\n\\n        require(msg.sender == _token.admin(), \\\"LSS: Must be Token Admin\\\");\\n        require(config.proposedTokenLockTimeframe != 0, \\\"LSS: New Settlement not proposed\\\");\\n        require(config.changeSettlementTimelock <= block.timestamp, \\\"LSS: Time lock in progress\\\");\\n        config.tokenLockTimeframe = config.proposedTokenLockTimeframe;\\n        config.proposedTokenLockTimeframe = 0; \\n        emit SettlementPeriodChange(_token, config.tokenLockTimeframe);\\n    }\\n\\n    /// @notice This function activates the emergency mode\\n    /// @dev When a report gets generated for a token, it enters an emergency state globally.\\n    /// The emergency period will be active for one settlement period.\\n    /// During this time users can only transfer settled tokens\\n    /// @param _token Token on which the emergency mode must get activated\\n    function activateEmergency(ILERC20 _token) override external onlyLosslessEnv {\\n        tokenConfig[_token].emergencyMode = block.timestamp;\\n        emit EmergencyActive(_token);\\n    }\\n\\n    /// @notice This function deactivates the emergency mode\\n    /// @param _token Token on which the emergency mode will be deactivated\\n    function deactivateEmergency(ILERC20 _token) override external onlyLosslessEnv {\\n        tokenConfig[_token].emergencyMode = 0;\\n        emit EmergencyDeactivation(_token);\\n    }\\n\\n   // --- GUARD ---\\n\\n    // @notice Set a guardian contract.\\n    // @dev Guardian contract must be trusted as it has some access rights and can modify controller's state.\\n    function setGuardian(address _newGuardian) override external onlyLosslessAdmin whenNotPaused {\\n        require(_newGuardian != address(0), \\\"LSS: Cannot be zero address\\\");\\n        emit GuardianSet(guardian, _newGuardian);\\n        guardian = _newGuardian;\\n    }\\n\\n    // @notice Sets protection for an address with the choosen strategy.\\n    // @dev Strategies are verified in the guardian contract.\\n    // @dev This call is initiated from a strategy, but guardian proxies it.\\n    function setProtectedAddress(ILERC20 _token, address _protectedAddress, ProtectionStrategy _strategy) override external onlyGuardian whenNotPaused {\\n        Protection storage protection = tokenProtections[_token].protections[_protectedAddress];\\n        protection.isProtected = true;\\n        protection.strategy = _strategy;\\n        emit NewProtectedAddress(_token, _protectedAddress, address(_strategy));\\n    }\\n\\n    // @notice Remove the protection from the address.\\n    // @dev Strategies are verified in the guardian contract.\\n    // @dev This call is initiated from a strategy, but guardian proxies it.\\n    function removeProtectedAddress(ILERC20 _token, address _protectedAddress) override external onlyGuardian whenNotPaused {\\n        require(isAddressProtected(_token, _protectedAddress), \\\"LSS: Address not protected\\\");\\n        delete tokenProtections[_token].protections[_protectedAddress];\\n        emit RemovedProtectedAddress(_token, _protectedAddress);\\n    }\\n\\n    function _getLatestOudatedCheckpoint(LocksQueue storage queue) private view returns (uint256, uint256) {\\n        uint256 lower = queue.first;\\n        uint256 upper = queue.last;\\n        uint256 currentTimestamp = block.timestamp;\\n        uint256 center = queue.first;\\n        ReceiveCheckpoint memory cp = queue.lockedFunds[queue.last];\\n        ReceiveCheckpoint memory lowestCp = queue.lockedFunds[queue.first];\\n\\n        while (upper > lower) {\\n            center = upper - ((upper - lower) >> 1); // ceil, avoiding overflow\\n            cp = queue.lockedFunds[center];\\n            if (cp.timestamp == currentTimestamp) {\\n                return (cp.cummulativeAmount, center + 1);\\n            } else if (cp.timestamp < currentTimestamp) {\\n                lowestCp = cp;\\n                lower = center;\\n            }  else {\\n                upper = center - 1;\\n                center = upper;\\n            }\\n        }\\n\\n        if (lowestCp.timestamp < currentTimestamp) {\\n            if (cp.timestamp < lowestCp.timestamp) {\\n                return (cp.cummulativeAmount, center);\\n            } else {\\n                return (lowestCp.cummulativeAmount, lower + 1);\\n            }\\n        } else {\\n            return (0, center);\\n        }\\n    }\\n\\n    /// @notice This function will calculate the available amount that an address has to transfer. \\n    /// @param _token Address corresponding to the token being held\\n    /// @param account Address to get the available amount\\n    function _getAvailableAmount(ILERC20 _token, address account) private returns (uint256 amount) {\\n        LocksQueue storage queue = tokenScopedLockedFunds[_token].queue[account];\\n        ReceiveCheckpoint storage cp = queue.lockedFunds[queue.last];\\n        (uint256 outdatedCummulative, uint256 newFirst) = _getLatestOudatedCheckpoint(queue);\\n        queue.first = newFirst;\\n        cp.cummulativeAmount = cp.cummulativeAmount - outdatedCummulative;\\n        return _token.balanceOf(account) - cp.cummulativeAmount;\\n    }\\n\\n    // LOCKs & QUEUES\\n\\n    /// @notice This function add transfers to the lock queues\\n    /// @param _checkpoint timestamp of the transfer\\n    /// @param _recipient Address to add the locks\\n    function _enqueueLockedFunds(ReceiveCheckpoint memory _checkpoint, address _recipient) private {\\n        LocksQueue storage queue;\\n\\n        queue = tokenScopedLockedFunds[ILERC20(msg.sender)].queue[_recipient];\\n\\n        uint256 lastItem = queue.last;\\n        ReceiveCheckpoint storage lastCheckpoint = queue.lockedFunds[lastItem];\\n\\n        if (lastCheckpoint.timestamp < _checkpoint.timestamp) {\\n            // Most common scenario where the item goes at the end of the queue\\n            _checkpoint.cummulativeAmount = _checkpoint.amount + lastCheckpoint.cummulativeAmount;\\n            queue.lockedFunds[lastItem + 1] = _checkpoint;\\n            queue.last += 1;\\n\\n        } else {\\n            // Second most common scenario where the timestamps are the same \\n            // or new one is smaller than the latest one.\\n            // So the amount adds up.\\n            lastCheckpoint.amount += _checkpoint.amount;\\n            lastCheckpoint.cummulativeAmount += _checkpoint.amount;\\n        } \\n\\n        if (queue.first == 0) {\\n            queue.first += 1;\\n        }\\n    }\\n\\n    // --- REPORT RESOLUTION ---\\n\\n    /// @notice This function retrieves the funds of the reported account\\n    /// @param _addresses Array of addreses to retrieve the locked funds\\n    /// @param _token Token to retrieve the funds from\\n    /// @param _reportId Report Id related to the incident\\n    function retrieveBlacklistedFunds(address[] calldata _addresses, ILERC20 _token, uint256 _reportId) override public onlyLosslessEnv returns(uint256){\\n        uint256 totalAmount = losslessGovernance.getAmountReported(_reportId);\\n        \\n        _token.transferOutBlacklistedFunds(_addresses);\\n                \\n        (uint256 reporterReward, uint256 losslessReward, uint256 committeeReward, uint256 stakersReward) = losslessReporting.getRewards();\\n\\n        uint256 toLssStaking = totalAmount * stakersReward / HUNDRED;\\n        uint256 toLssReporting = totalAmount * reporterReward / HUNDRED;\\n        uint256 toLssGovernance = totalAmount - toLssStaking - toLssReporting;\\n\\n        require(_token.transfer(address(losslessStaking), toLssStaking), \\\"LSS: Staking retrieval failed\\\");\\n        require(_token.transfer(address(losslessReporting), toLssReporting), \\\"LSS: Reporting retrieval failed\\\");\\n        require(_token.transfer(address(losslessGovernance), toLssGovernance), \\\"LSS: Governance retrieval failed\\\");\\n\\n        return totalAmount - toLssStaking - toLssReporting - (totalAmount * (committeeReward + losslessReward) / HUNDRED);\\n    }\\n\\n\\n    /// @notice This function will lift the locks after a certain amount\\n    /// @dev The condition to lift the locks is that their checkpoint should be greater than the set amount\\n    /// @param _availableAmount Unlocked Amount\\n    /// @param _account Address to lift the locks\\n    /// @param _amount Amount to lift\\n    function _removeUsedUpLocks (uint256 _availableAmount, address _account, uint256 _amount) private {\\n        LocksQueue storage queue;\\n        ILERC20 token = ILERC20(msg.sender);\\n        queue = tokenScopedLockedFunds[token].queue[_account];\\n        require(queue.touchedTimestamp + tokenConfig[token].tokenLockTimeframe <= block.timestamp, \\\"LSS: Transfers limit reached\\\");\\n        uint256 amountLeft = _amount - _availableAmount;\\n        ReceiveCheckpoint storage cp = queue.lockedFunds[queue.last];\\n        cp.cummulativeAmount -= amountLeft;\\n        queue.touchedTimestamp = block.timestamp;\\n    }\\n\\n    // --- BEFORE HOOKS ---\\n\\n    /// @notice This function evaluates if the transfer can be made\\n    /// @param _sender Address sending the funds\\n    /// @param _recipient Address recieving the funds\\n    /// @param _amount Amount to be transfered\\n    function _evaluateTransfer(address _sender, address _recipient, uint256 _amount) private returns (bool) {\\n        ILERC20 token = ILERC20(msg.sender);\\n\\n        uint256 settledAmount = _getAvailableAmount(token, _sender);\\n        \\n        TokenConfig storage config = tokenConfig[token];\\n\\n        if (_amount > settledAmount) {\\n            require(config.emergencyMode + config.tokenLockTimeframe < block.timestamp,\\n                    \\\"LSS: Emergency mode active, cannot transfer unsettled tokens\\\");\\n            if (dexList[_recipient]) {\\n                require(_amount - settledAmount <= dexTranferThreshold,\\n                        \\\"LSS: Cannot transfer over the dex threshold\\\");\\n            } else {\\n                _removeUsedUpLocks(settledAmount, _sender, _amount);\\n            }\\n        }\\n\\n        ReceiveCheckpoint memory newCheckpoint = ReceiveCheckpoint(_amount, block.timestamp + config.tokenLockTimeframe, 0);\\n        _enqueueLockedFunds(newCheckpoint, _recipient);\\n        return true;\\n    }\\n\\n    /// @notice If address is protected, transfer validation rules have to be run inside the strategy.\\n    /// @dev isTransferAllowed reverts in case transfer can not be done by the defined rules.\\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) override external {\\n        ILERC20 token = ILERC20(msg.sender);\\n        if (tokenProtections[token].protections[_sender].isProtected) {\\n            tokenProtections[token].protections[_sender].strategy.isTransferAllowed(msg.sender, _sender, _recipient, _amount);\\n        }\\n\\n        require(!blacklist[_sender], \\\"LSS: You cannot operate\\\");\\n        \\n        if (tokenConfig[token].tokenLockTimeframe != 0) {\\n            _evaluateTransfer(_sender, _recipient, _amount);\\n        }\\n    }\\n\\n    /// @notice If address is protected, transfer validation rules have to be run inside the strategy.\\n    /// @dev isTransferAllowed reverts in case transfer can not be done by the defined rules.\\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) override external {\\n        ILERC20 token = ILERC20(msg.sender);\\n\\n        if (tokenProtections[token].protections[_sender].isProtected) {\\n            tokenProtections[token].protections[_sender].strategy.isTransferAllowed(msg.sender, _sender, _recipient, _amount);\\n        }\\n\\n        require(!blacklist[_msgSender], \\\"LSS: You cannot operate\\\");\\n        require(!blacklist[_sender], \\\"LSS: Sender is blacklisted\\\");\\n\\n        if (tokenConfig[token].tokenLockTimeframe != 0) {\\n            _evaluateTransfer(_sender, _recipient, _amount);\\n        }\\n\\n    }\\n\\n    // The following before hooks are in place as a placeholder for future products.\\n    // Also to preserve legacy LERC20 compatibility\\n    \\n    function beforeMint(address _to, uint256 _amount) override external {}\\n\\n    function beforeApprove(address _sender, address _spender, uint256 _amount) override external {}\\n\\n    function beforeBurn(address _account, uint256 _amount) override external {}\\n\\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) override external {}\\n\\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) override external {}\\n\\n\\n    // --- AFTER HOOKS ---\\n    // * After hooks are deprecated in LERC20 but we have to keep them\\n    //   here in order to support legacy LERC20.\\n\\n    function afterMint(address _to, uint256 _amount) external {}\\n\\n    function afterApprove(address _sender, address _spender, uint256 _amount) external {}\\n\\n    function afterBurn(address _account, uint256 _amount) external {}\\n\\n    function afterTransfer(address _sender, address _recipient, uint256 _amount) external {}\\n\\n    function afterTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external {}\\n\\n    function afterIncreaseAllowance(address _sender, address _spender, uint256 _addedValue) external {}\\n\\n    function afterDecreaseAllowance(address _sender, address _spender, uint256 _subtractedValue) external {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface ILERC20 {\\n    function name() external view returns (string memory);\\n    function admin() external view returns (address);\\n    function getAdmin() external view returns (address);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address _account) external view returns (uint256);\\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\\n    function allowance(address _owner, address _spender) external view returns (uint256);\\n    function approve(address _spender, uint256 _amount) external returns (bool);\\n    function transferFrom(address _sender, address _recipient, uint256 _amount) external returns (bool);\\n    function increaseAllowance(address _spender, uint256 _addedValue) external returns (bool);\\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) external returns (bool);\\n    \\n    function transferOutBlacklistedFunds(address[] calldata _from) external;\\n    function setLosslessAdmin(address _newAdmin) external;\\n    function transferRecoveryAdminOwnership(address _candidate, bytes32 _keyHash) external;\\n    function acceptRecoveryAdminOwnership(bytes memory _key) external;\\n    function proposeLosslessTurnOff() external;\\n    function executeLosslessTurnOff() external;\\n    function executeLosslessTurnOn() external;\\n\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n    event NewAdmin(address indexed _newAdmin);\\n    event NewRecoveryAdminProposal(address indexed _candidate);\\n    event NewRecoveryAdmin(address indexed _newAdmin);\\n    event LosslessTurnOffProposal(uint256 _turnOffDate);\\n    event LosslessOff();\\n    event LosslessOn();\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessGovernance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssGovernance {\\n    function LSS_TEAM_INDEX() external view returns(uint256);\\n    function TOKEN_OWNER_INDEX() external view returns(uint256);\\n    function COMMITEE_INDEX() external view returns(uint256);\\n    function committeeMembersCount() external view returns(uint256);\\n    function walletDisputePeriod() external view returns(uint256);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessController() external view returns (ILssController);\\n    function isCommitteeMember(address _account) external view returns(bool);\\n    function getIsVoted(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function getVote(uint256 _reportId, uint256 _voterIndex) external view returns(bool);\\n    function isReportSolved(uint256 _reportId) external view returns(bool);\\n    function reportResolution(uint256 _reportId) external view returns(bool);\\n    function getAmountReported(uint256 _reportId) external view returns(uint256);\\n    \\n    function setDisputePeriod(uint256 _timeFrame) external;\\n    function addCommitteeMembers(address[] memory _members) external;\\n    function removeCommitteeMembers(address[] memory _members) external;\\n    function losslessVote(uint256 _reportId, bool _vote) external;\\n    function tokenOwnersVote(uint256 _reportId, bool _vote) external;\\n    function committeeMemberVote(uint256 _reportId, bool _vote) external;\\n    function resolveReport(uint256 _reportId) external;\\n    function proposeWallet(uint256 _reportId, address wallet) external;\\n    function rejectWallet(uint256 _reportId) external;\\n    function retrieveFunds(uint256 _reportId) external;\\n    function retrieveCompensation() external;\\n    function claimCommitteeReward(uint256 _reportId) external;\\n    function setCompensationAmount(uint256 _amount) external;\\n    function losslessClaim(uint256 _reportId) external;\\n    function setRevshareAdmin(address _address) external;\\n    function setRevsharePercentage(uint256 _amount) external;\\n    function revshareClaim(uint256 _reportId) external;\\n\\n    event NewCommitteeMembers(address[] _members);\\n    event CommitteeMembersRemoval(address[] _members);\\n    event LosslessTeamPositiveVote(uint256 indexed _reportId);\\n    event LosslessTeamNegativeVote(uint256 indexed _reportId);\\n    event TokenOwnersPositiveVote(uint256 indexed _reportId);\\n    event TokenOwnersNegativeVote(uint256 indexed _reportId);\\n    event CommitteeMemberPositiveVote(uint256 indexed _reportId, address indexed _member);\\n    event CommitteeMemberNegativeVote(uint256 indexed _reportId, address indexed _member);\\n    event ReportResolve(uint256 indexed _reportId, bool indexed _resolution);\\n    event WalletProposal(uint256 indexed _reportId, address indexed _wallet);\\n    event CommitteeMemberClaim(uint256 indexed _reportId, address indexed _member, uint256 indexed _amount);\\n    event CommitteeMajorityReach(uint256 indexed _reportId, bool indexed _result);\\n    event NewDisputePeriod(uint256 indexed _newPeriod);\\n    event WalletRejection(uint256 indexed _reportId);\\n    event FundsRetrieval(uint256 indexed _reportId, uint256 indexed _amount);\\n    event CompensationRetrieval(address indexed _wallet, uint256 indexed _amount);\\n    event LosslessClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n    event NewCompensationPercentage(uint256 indexed _compensationPercentage);\\n    event NewRevshareAdmin(address indexed _revshareAdmin);\\n    event NewRevsharePercentage(uint256 indexed _revsharePercentage);\\n    event RevshareClaim(ILERC20 indexed _token, uint256 indexed _reportID, uint256 indexed _amount);\\n}\\n\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssStaking {\\n  function stakingToken() external returns(ILERC20);\\n  function losslessReporting() external returns(ILssReporting);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function stakingAmount() external returns(uint256);\\n  function getVersion() external pure returns (uint256);\\n  function getIsAccountStaked(uint256 _reportId, address _account) external view returns(bool);\\n  function getStakerCoefficient(uint256 _reportId, address _address) external view returns (uint256);\\n  function stakerClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setLssReporting(ILssReporting _losslessReporting) external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setStakingAmount(uint256 _stakingAmount) external;\\n  function stake(uint256 _reportId) external;\\n  function stakerClaim(uint256 _reportId) external;\\n\\n  event NewStake(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event StakerClaim(address indexed _staker, ILERC20 indexed _token, uint256 indexed _reportID, uint256 _amount);\\n  event NewStakingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _newToken);\\n  event NewReportingContract(ILssReporting indexed _newContract);\\n  event NewGovernanceContract(ILssGovernance indexed _newContract);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessReporting.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessController.sol\\\";\\n\\ninterface ILssReporting {\\n  function reporterReward() external returns(uint256);\\n  function losslessReward() external returns(uint256);\\n  function stakersReward() external returns(uint256);\\n  function committeeReward() external returns(uint256);\\n  function reportLifetime() external view returns(uint256);\\n  function reportingAmount() external returns(uint256);\\n  function reportCount() external returns(uint256);\\n  function stakingToken() external returns(ILERC20);\\n  function losslessController() external returns(ILssController);\\n  function losslessGovernance() external returns(ILssGovernance);\\n  function getVersion() external pure returns (uint256);\\n  function getRewards() external view returns (uint256 _reporter, uint256 _lossless, uint256 _committee, uint256 _stakers);\\n  function report(ILERC20 _token, address _account) external returns (uint256);\\n  function reporterClaimableAmount(uint256 _reportId) external view returns (uint256);\\n  function getReportInfo(uint256 _reportId) external view returns(address _reporter,\\n        address _reportedAddress,\\n        address _secondReportedAddress,\\n        uint256 _reportTimestamps,\\n        ILERC20 _reportTokens,\\n        bool _secondReports,\\n        bool _reporterClaimStatus);\\n  \\n  function pause() external;\\n  function unpause() external;\\n  function setStakingToken(ILERC20 _stakingToken) external;\\n  function setLosslessGovernance(ILssGovernance _losslessGovernance) external;\\n  function setReportingAmount(uint256 _reportingAmount) external;\\n  function setReporterReward(uint256 _reward) external;\\n  function setLosslessReward(uint256 _reward) external;\\n  function setStakersReward(uint256 _reward) external;\\n  function setCommitteeReward(uint256 _reward) external;\\n  function setReportLifetime(uint256 _lifetime) external;\\n  function secondReport(uint256 _reportId, address _account) external;\\n  function reporterClaim(uint256 _reportId) external;\\n  function retrieveCompensation(address _adr, uint256 _amount) external;\\n\\n  event ReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId, uint256 _amount);\\n  event SecondReportSubmission(ILERC20 indexed _token, address indexed _account, uint256 indexed _reportId);\\n  event NewReportingAmount(uint256 indexed _newAmount);\\n  event NewStakingToken(ILERC20 indexed _token);\\n  event NewGovernanceContract(ILssGovernance indexed _adr);\\n  event NewReporterReward(uint256 indexed _newValue);\\n  event NewLosslessReward(uint256 indexed _newValue);\\n  event NewStakersReward(uint256 indexed _newValue);\\n  event NewCommitteeReward(uint256 indexed _newValue);\\n  event NewReportLifetime(uint256 indexed _newValue);\\n  event ReporterClaim(address indexed _reporter, uint256 indexed _reportId, uint256 indexed _amount);\\n  event CompensationRetrieve(address indexed _adr, uint256 indexed _amount);\\n}\"\r\n    },\r\n    \"contracts/Interfaces/IProtectionStrategy.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface ProtectionStrategy {\\n    function isTransferAllowed(address token, address sender, address recipient, uint256 amount) external;\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces/ILosslessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ILosslessERC20.sol\\\";\\nimport \\\"./ILosslessGovernance.sol\\\";\\nimport \\\"./ILosslessStaking.sol\\\";\\nimport \\\"./ILosslessReporting.sol\\\";\\nimport \\\"./IProtectionStrategy.sol\\\";\\n\\ninterface ILssController {\\n    // function getLockedAmount(ILERC20 _token, address _account)  returns (uint256);\\n    // function getAvailableAmount(ILERC20 _token, address _account) external view returns (uint256 amount);\\n    function retrieveBlacklistedFunds(address[] calldata _addresses, ILERC20 _token, uint256 _reportId) external returns(uint256);\\n    function whitelist(address _adr) external view returns (bool);\\n    function dexList(address _dexAddress) external returns (bool);\\n    function blacklist(address _adr) external view returns (bool);\\n    function admin() external view returns (address);\\n    function pauseAdmin() external view returns (address);\\n    function recoveryAdmin() external view returns (address);\\n    function guardian() external view returns (address);\\n    function losslessStaking() external view returns (ILssStaking);\\n    function losslessReporting() external view returns (ILssReporting);\\n    function losslessGovernance() external view returns (ILssGovernance);\\n    function dexTranferThreshold() external view returns (uint256);\\n    function settlementTimeLock() external view returns (uint256);\\n    \\n    function pause() external;\\n    function unpause() external;\\n    function setAdmin(address _newAdmin) external;\\n    function setRecoveryAdmin(address _newRecoveryAdmin) external;\\n    function setPauseAdmin(address _newPauseAdmin) external;\\n    function setSettlementTimeLock(uint256 _newTimelock) external;\\n    function setDexTransferThreshold(uint256 _newThreshold) external;\\n    function setDexList(address[] calldata _dexList, bool _value) external;\\n    function setWhitelist(address[] calldata _addrList, bool _value) external;\\n    function addToBlacklist(address _adr) external;\\n    function resolvedNegatively(address _adr) external;\\n    function setStakingContractAddress(ILssStaking _adr) external;\\n    function setReportingContractAddress(ILssReporting _adr) external; \\n    function setGovernanceContractAddress(ILssGovernance _adr) external;\\n    function proposeNewSettlementPeriod(ILERC20 _token, uint256 _seconds) external;\\n    function executeNewSettlementPeriod(ILERC20 _token) external;\\n    function activateEmergency(ILERC20 _token) external;\\n    function deactivateEmergency(ILERC20 _token) external;\\n    function setGuardian(address _newGuardian) external;\\n    function removeProtectedAddress(ILERC20 _token, address _protectedAddresss) external;\\n    function beforeTransfer(address _sender, address _recipient, uint256 _amount) external;\\n    function beforeTransferFrom(address _msgSender, address _sender, address _recipient, uint256 _amount) external;\\n    function beforeApprove(address _sender, address _spender, uint256 _amount) external;\\n    function beforeIncreaseAllowance(address _msgSender, address _spender, uint256 _addedValue) external;\\n    function beforeDecreaseAllowance(address _msgSender, address _spender, uint256 _subtractedValue) external;\\n    function beforeMint(address _to, uint256 _amount) external;\\n    function beforeBurn(address _account, uint256 _amount) external;\\n    function setProtectedAddress(ILERC20 _token, address _protectedAddress, ProtectionStrategy _strategy) external;\\n\\n    event AdminChange(address indexed _newAdmin);\\n    event RecoveryAdminChange(address indexed _newAdmin);\\n    event PauseAdminChange(address indexed _newAdmin);\\n    event GuardianSet(address indexed _oldGuardian, address indexed _newGuardian);\\n    event NewProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress, address indexed _strategy);\\n    event RemovedProtectedAddress(ILERC20 indexed _token, address indexed _protectedAddress);\\n    event NewSettlementPeriodProposal(ILERC20 indexed _token, uint256 _seconds);\\n    event SettlementPeriodChange(ILERC20 indexed _token, uint256 _proposedTokenLockTimeframe);\\n    event NewSettlementTimelock(uint256 indexed _timelock);\\n    event NewDexThreshold(uint256 indexed _newThreshold);\\n    event NewDex(address indexed _dexAddress);\\n    event DexRemoval(address indexed _dexAddress);\\n    event NewWhitelistedAddress(address indexed _whitelistAdr);\\n    event WhitelistedAddressRemoval(address indexed _whitelistAdr);\\n    event NewBlacklistedAddress(address indexed _blacklistedAddres);\\n    event AccountBlacklistRemoval(address indexed _adr);\\n    event NewStakingContract(ILssStaking indexed _newAdr);\\n    event NewReportingContract(ILssReporting indexed _newAdr);\\n    event NewGovernanceContract(ILssGovernance indexed _newAdr);\\n    event EmergencyActive(ILERC20 indexed _token);\\n    event EmergencyDeactivation(ILERC20 indexed _token);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"AccountBlacklistRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dexAddress\",\"type\":\"address\"}],\"name\":\"DexRemoval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"EmergencyActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"EmergencyDeactivation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_oldGuardian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newGuardian\",\"type\":\"address\"}],\"name\":\"GuardianSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_blacklistedAddres\",\"type\":\"address\"}],\"name\":\"NewBlacklistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_dexAddress\",\"type\":\"address\"}],\"name\":\"NewDex\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_newThreshold\",\"type\":\"uint256\"}],\"name\":\"NewDexThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILssGovernance\",\"name\":\"_newAdr\",\"type\":\"address\"}],\"name\":\"NewGovernanceContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"NewProtectedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILssReporting\",\"name\":\"_newAdr\",\"type\":\"address\"}],\"name\":\"NewReportingContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"NewSettlementPeriodProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"NewSettlementTimelock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILssStaking\",\"name\":\"_newAdr\",\"type\":\"address\"}],\"name\":\"NewStakingContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_whitelistAdr\",\"type\":\"address\"}],\"name\":\"NewWhitelistedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"PauseAdminChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"RecoveryAdminChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"}],\"name\":\"RemovedProtectedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_proposedTokenLockTimeframe\",\"type\":\"uint256\"}],\"name\":\"SettlementPeriodChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_whitelistAdr\",\"type\":\"address\"}],\"name\":\"WhitelistedAddressRemoval\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUNDRED\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"activateEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"addToBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"afterApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"afterBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"afterDecreaseAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"afterIncreaseAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"afterMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"afterTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"afterTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"beforeDecreaseAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"beforeIncreaseAllowance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_msgSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"beforeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"deactivateEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dexList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dexTranferThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"executeNewSettlementPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"}],\"name\":\"getProtectedAddressStrategy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"}],\"name\":\"isAddressProtected\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessGovernance\",\"outputs\":[{\"internalType\":\"contract ILssGovernance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessReporting\",\"outputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"losslessStaking\",\"outputs\":[{\"internalType\":\"contract ILssStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_seconds\",\"type\":\"uint256\"}],\"name\":\"proposeNewSettlementPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoveryAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"}],\"name\":\"removeProtectedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"resolvedNegatively\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reportId\",\"type\":\"uint256\"}],\"name\":\"retrieveBlacklistedFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_dexList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setDexList\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newThreshold\",\"type\":\"uint256\"}],\"name\":\"setDexTransferThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssGovernance\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"setGovernanceContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGuardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPauseAdmin\",\"type\":\"address\"}],\"name\":\"setPauseAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protectedAddress\",\"type\":\"address\"},{\"internalType\":\"contract ProtectionStrategy\",\"name\":\"_strategy\",\"type\":\"address\"}],\"name\":\"setProtectedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRecoveryAdmin\",\"type\":\"address\"}],\"name\":\"setRecoveryAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssReporting\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"setReportingContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newTimelock\",\"type\":\"uint256\"}],\"name\":\"setSettlementTimeLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ILssStaking\",\"name\":\"_adr\",\"type\":\"address\"}],\"name\":\"setStakingContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addrList\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settlementTimeLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LosslessControllerV3", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}