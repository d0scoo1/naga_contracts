{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/AaveV2StablecoinCellar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/IAaveV2StablecoinCellar.sol\\\";\\nimport \\\"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\\\";\\nimport \\\"./interfaces/ILendingPool.sol\\\";\\nimport {ERC20} from \\\"@rari-capital/solmate/src/tokens/ERC20.sol\\\";\\nimport {SafeTransferLib} from \\\"@rari-capital/solmate/src/utils/SafeTransferLib.sol\\\";\\nimport {ReentrancyGuard} from \\\"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./utils/MathUtils.sol\\\";\\nimport \\\"./interfaces/IAaveIncentivesController.sol\\\";\\nimport \\\"./interfaces/IStakedTokenV2.sol\\\";\\nimport \\\"./interfaces/ISushiSwapRouter.sol\\\";\\nimport \\\"./interfaces/IGravity.sol\\\";\\n\\n/**\\n * @title Sommelier AaveV2 Stablecoin Cellar contract\\n * @notice AaveV2StablecoinCellar contract for Sommelier Network\\n * @author Sommelier Finance\\n */\\ncontract AaveV2StablecoinCellar is IAaveV2StablecoinCellar, ERC20, ReentrancyGuard, Ownable {\\n    using SafeTransferLib for ERC20;\\n\\n    struct UserDeposit {\\n        uint256 assets;\\n        uint256 shares;\\n        uint256 timeDeposited;\\n    }\\n\\n    // Uniswap Router V3 contract\\n    ISwapRouter public immutable uniswapRouter; // 0xE592427A0AEce92De3Edee1F18E0157C05861564\\n    // SushiSwap Router V2 contract\\n    ISushiSwapRouter public immutable sushiSwapRouter; // 0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F\\n    // Aave Lending Pool V2 contract\\n    ILendingPool public immutable lendingPool; // 0x7d2768dE32b0b80b7a3454c06BdAc94A69DDc7A9\\n    // Aave Incentives Controller V2 contract\\n    IAaveIncentivesController public immutable incentivesController; // 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5\\n    // Cosmos Gravity Bridge contract\\n    Gravity public immutable gravityBridge; // 0x69592e6f9d21989a043646fE8225da2600e5A0f7\\n    // Cosmos address of fee distributor\\n    bytes32 public feesDistributor; // TBD\\n    IStakedTokenV2 public immutable stkAAVE; // 0x4da27a545c0c5B758a6BA100e3a049001de870f5\\n\\n    address public immutable AAVE; // 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9\\n    address public immutable WETH; // 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\\n    address public immutable USDC; // 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\\n\\n    // Declare the variables and mappings.\\n    mapping(address => bool) public inputTokens;\\n    // The address of the token of the current lending position\\n    address public currentLendingToken;\\n    address public currentAToken;\\n    // Track user user deposits to determine active/inactive shares.\\n    mapping(address => UserDeposit[]) public userDeposits;\\n    // Last time inactive funds were entered into a strategy and made active.\\n    uint256 public lastTimeEnteredStrategy;\\n\\n    // Restrict liquidity and deposits per wallet until after security audits.\\n    // TODO: fix this\\n    uint256 public maxDeposit = 50_000e18; // $50k\\n    uint256 public maxLiquidity = 5_000_000e18; // $5m\\n\\n    uint24 public constant POOL_FEE = 3000;\\n\\n    uint256 public constant DENOMINATOR = 10_000;\\n    uint256 public constant SECS_PER_YEAR = 31_556_952;\\n    uint256 public constant PLATFORM_FEE = 100;\\n    uint256 public constant PERFORMANCE_FEE = 500;\\n\\n    uint256 public lastTimeAccruedPlatformFees;\\n    // Fees are taken in shares and redeemed for assets at the time they are transferred.\\n    uint256 public accruedPlatformFees;\\n    uint256 public accruedPerformanceFees;\\n\\n    // Emergency states in case of contract malfunction.\\n    bool public isPaused;\\n    bool public isShutdown;\\n\\n    /**\\n     * @param _uniswapRouter Uniswap V3 swap router address\\n     * @param _lendingPool Aave V2 lending pool address\\n     * @param _incentivesController _incentivesController\\n     * @param _gravityBridge Cosmos Gravity Bridge address\\n     * @param _stkAAVE stkAAVE address\\n     * @param _AAVE AAVE address\\n     * @param _WETH WETH address\\n     * @param _currentLendingToken token of lending pool where the cellar has its liquidity deposited\\n     */\\n    constructor(\\n        ISwapRouter _uniswapRouter,\\n        ISushiSwapRouter _sushiSwapRouter,\\n        ILendingPool _lendingPool,\\n        IAaveIncentivesController _incentivesController,\\n        Gravity _gravityBridge,\\n        IStakedTokenV2 _stkAAVE,\\n        address _AAVE,\\n        address _WETH,\\n        address _USDC,\\n        address _currentLendingToken\\n    ) ERC20(\\\"Sommelier Aave V2 Stablecoin Cellar LP Token\\\", \\\"sommSAAVE\\\", 18) Ownable() {\\n        uniswapRouter =  _uniswapRouter;\\n        sushiSwapRouter = _sushiSwapRouter;\\n        lendingPool = _lendingPool;\\n        incentivesController = _incentivesController;\\n        gravityBridge = _gravityBridge;\\n        stkAAVE = _stkAAVE;\\n        AAVE = _AAVE;\\n        WETH = _WETH;\\n        USDC = _USDC;\\n\\n        _updateLendingPosition(_currentLendingToken);\\n\\n        lastTimeAccruedPlatformFees = block.timestamp;\\n    }\\n\\n    // NOTE: For beta only\\n    function setFeeDistributor(bytes32 _newFeeDistributor) external onlyOwner {\\n        feesDistributor = _newFeeDistributor;\\n    }\\n\\n    /**\\n     * @notice Deposit supported tokens into the cellar.\\n     * @param token address of the supported token to deposit\\n     * @param assets amount of assets to deposit\\n     * @param minAssetsIn minimum amount of assets cellar should receive after swap (if applicable)\\n     * @param receiver address that should receive shares\\n     * @return shares amount of shares minted to receiver\\n     */\\n    function deposit(\\n        address token,\\n        uint256 assets,\\n        uint256 minAssetsIn,\\n        address receiver\\n    ) public nonReentrant returns (uint256 shares) {\\n        if (isPaused) revert ContractPaused();\\n        if (isShutdown) revert ContractShutdown();\\n\\n        if (!inputTokens[token]) revert UnapprovedToken(token);\\n        if (maxLiquidity != 0 && assets + totalAssets() > maxLiquidity)\\n            revert LiquidityRestricted(totalAssets(), maxLiquidity);\\n        if (maxDeposit != 0 && ERC20(token).balanceOf(msg.sender) + assets > maxDeposit)\\n            revert DepositRestricted(ERC20(token).balanceOf(msg.sender), maxDeposit);\\n\\n        uint256 balance = ERC20(token).balanceOf(msg.sender);\\n        if (assets > balance) assets = balance;\\n\\n        ERC20(token).safeTransferFrom(msg.sender, address(this), assets);\\n\\n        if (token != currentLendingToken) {\\n            assets = _swap(token, currentLendingToken, assets, minAssetsIn);\\n        }\\n\\n        // Must calculate shares as if assets were not yet transfered in.\\n        if ((shares = _convertToShares(assets, assets)) == 0) revert ZeroAssets();\\n\\n        _mint(receiver, shares);\\n\\n        UserDeposit[] storage deposits = userDeposits[receiver];\\n        deposits.push(UserDeposit({\\n            assets: assets,\\n            shares: shares,\\n            timeDeposited: block.timestamp\\n        }));\\n\\n        emit Deposit(msg.sender, receiver, assets, shares);\\n    }\\n\\n    function deposit(uint256 assets) external returns (uint256) {\\n        return deposit(currentLendingToken, assets, assets, msg.sender);\\n    }\\n\\n    /// @dev For ERC4626 compatibility.\\n    function deposit(uint256 assets, address receiver) external returns (uint256) {\\n        return deposit(currentLendingToken, assets, assets, receiver);\\n    }\\n\\n    /**\\n     * @notice Withdraw from the cellar.\\n     * @param assets amount of assets to withdraw\\n     * @param receiver address that should receive assets\\n     * @param owner address that should own the shares\\n     * @return shares amount of shares burned from owner\\n     */\\n    function withdraw(uint256 assets, address receiver, address owner) public returns (uint256 shares) {\\n        if (assets == 0) revert ZeroAssets();\\n        if (balanceOf[owner] == 0) revert ZeroShares();\\n\\n        uint256 withdrawnActiveShares;\\n        uint256 withdrawnInactiveShares;\\n        uint256 withdrawnInactiveAssets;\\n        uint256 originalDepositedAssets; // Used for calculating performance fees.\\n\\n        // Saves gas by avoiding calling `convertToAssets` on active shares during each loop.\\n        uint256 exchangeRate = convertToAssets(1e18);\\n\\n        UserDeposit[] storage deposits = userDeposits[owner];\\n\\n        uint256 leftToWithdraw = assets;\\n        for (uint256 i = deposits.length - 1; i + 1 != 0; i--) {\\n            UserDeposit storage d = deposits[i];\\n\\n            uint256 dAssets = d.assets;\\n            if (dAssets != 0) {\\n                uint256 dShares = d.shares;\\n\\n                uint256 withdrawnAssets;\\n                uint256 withdrawnShares;\\n\\n                // Check if deposit shares are active or inactive.\\n                if (d.timeDeposited < lastTimeEnteredStrategy) {\\n                    // Active:\\n                    dAssets = exchangeRate * dShares / 1e18;\\n                    withdrawnAssets = MathUtils.min(leftToWithdraw, dAssets);\\n                    withdrawnShares = MathUtils.mulDivUp(dShares, withdrawnAssets, dAssets);\\n\\n                    uint256 originalDepositWithdrawn = MathUtils.mulDivUp(d.assets, withdrawnShares, dShares);\\n                    // Store to calculate performance fees on future withdraws.\\n                    d.assets -= originalDepositWithdrawn;\\n\\n                    originalDepositedAssets += originalDepositWithdrawn;\\n                    withdrawnActiveShares += withdrawnShares;\\n                } else {\\n                    // Inactive:\\n                    withdrawnAssets = MathUtils.min(leftToWithdraw, dAssets);\\n                    withdrawnShares = MathUtils.mulDivUp(dShares, withdrawnAssets, dAssets);\\n\\n                    d.assets -= withdrawnAssets;\\n\\n                    withdrawnInactiveShares += withdrawnShares;\\n                    withdrawnInactiveAssets += withdrawnAssets;\\n                }\\n\\n                d.shares -= withdrawnShares;\\n\\n                leftToWithdraw -= withdrawnAssets;\\n            }\\n\\n            if (i == 0 || leftToWithdraw == 0) break;\\n        }\\n\\n        shares = withdrawnActiveShares + withdrawnInactiveShares;\\n\\n        if (msg.sender != owner) {\\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\\n        }\\n\\n        uint256 withdrawnActiveAssets = exchangeRate * withdrawnActiveShares / 1e18;\\n\\n        // Take performance fees.\\n        if (withdrawnActiveAssets > 0) {\\n            uint256 gain = withdrawnActiveAssets - originalDepositedAssets;\\n            uint256 feeInAssets = gain * PERFORMANCE_FEE / DENOMINATOR;\\n            uint256 fees = convertToShares(feeInAssets);\\n\\n            if (fees > 0) {\\n                accruedPerformanceFees += fees;\\n                withdrawnActiveAssets -= feeInAssets;\\n\\n                _mint(address(this), fees);\\n            }\\n        }\\n\\n        _burn(owner, shares);\\n\\n        if (withdrawnActiveAssets > 0) {\\n            if (!isShutdown) {\\n                // Withdraw tokens from Aave to receiver.\\n                lendingPool.withdraw(currentLendingToken, withdrawnActiveAssets, receiver);\\n            } else {\\n                ERC20(currentLendingToken).transfer(receiver, withdrawnActiveAssets);\\n            }\\n        }\\n\\n        if (withdrawnInactiveAssets > 0) {\\n            ERC20(currentLendingToken).transfer(receiver, withdrawnInactiveAssets);\\n        }\\n\\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\\n    }\\n\\n    function withdraw(uint256 assets) external returns (uint256 shares) {\\n        return withdraw(assets, msg.sender, msg.sender);\\n    }\\n\\n    /**\\n     * @notice Enters Aave stablecoin strategy.\\n     */\\n    function enterStrategy() external onlyOwner {\\n        if (isShutdown) revert ContractShutdown();\\n\\n        _depositToAave(currentLendingToken, inactiveAssets());\\n\\n        lastTimeEnteredStrategy = block.timestamp;\\n    }\\n\\n    /**\\n     * @notice Reinvest stkAAVE rewards back into cellar's current position on Aave.\\n     * @dev Must be called in the 2 day unstake period started 10 days after claimAndUnstake was run.\\n     * @param amount amount of stkAAVE to redeem and reinvest\\n     * @param minAssetsOut minimum amount of assets cellar should receive after swap\\n     */\\n    // auction model:\\n    // - send stkaave to the bridge\\n    // - add functionality to distribute SOMM rewards\\n    function reinvest(uint256 amount, uint256 minAssetsOut) public onlyOwner {\\n        stkAAVE.redeem(address(this), amount);\\n\\n        address[] memory path = new address[](3);\\n        path[0] = AAVE;\\n        path[1] = WETH;\\n        path[2] = currentLendingToken;\\n\\n        uint256 amountIn = ERC20(AAVE).balanceOf(address(this));\\n\\n        // Due to the lack of liquidity for AAVE on Uniswap, we use Sushiswap instead here.\\n        uint256 amountOut = _sushiswap(path, amountIn, minAssetsOut);\\n\\n        if (!isShutdown) {\\n            _depositToAave(currentLendingToken, amountOut);\\n        }\\n    }\\n\\n    function reinvest(uint256 minAssetsOut) external onlyOwner {\\n        reinvest(type(uint256).max, minAssetsOut);\\n    }\\n\\n    /**\\n     * @notice Claim stkAAVE rewards from Aave and begin cooldown period to unstake.\\n     * @param amount amount of rewards to claim\\n     * @return claimed amount of rewards claimed from Aave\\n     */\\n    function claimAndUnstake(uint256 amount) public onlyOwner returns (uint256 claimed) {\\n        // Necessary as claimRewards accepts a dynamic array as first param.\\n        address[] memory aToken = new address[](1);\\n        aToken[0] = currentAToken;\\n\\n        claimed = incentivesController.claimRewards(aToken, amount, address(this));\\n\\n        stkAAVE.cooldown();\\n    }\\n\\n    function claimAndUnstake() external onlyOwner returns (uint256) {\\n        return claimAndUnstake(type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Deposits cellar holdings into Aave lending pool.\\n     * @param token the address of the token\\n     * @param assets the amount of token to be deposited\\n     */\\n    function _depositToAave(address token, uint256 assets) internal {\\n        ERC20(token).safeApprove(address(lendingPool), assets);\\n\\n        // Deposit token to Aave protocol.\\n        lendingPool.deposit(token, assets, address(this), 0);\\n\\n        emit DepositToAave(token, assets);\\n    }\\n\\n    /**\\n     * @notice Redeems a token from Aave protocol.\\n     * @param token the address of the token\\n     * @param amount the token amount being redeemed\\n     * @return withdrawnAmount the withdrawn amount from Aave\\n     */\\n    function _redeemFromAave(address token, uint256 amount) internal returns (uint256 withdrawnAmount) {\\n        // Withdraw token from Aave protocol\\n        withdrawnAmount = lendingPool.withdraw(token, amount, address(this));\\n\\n        emit RedeemFromAave(token, withdrawnAmount);\\n    }\\n\\n    /**\\n     * @notice Rebalances of Aave lending position.\\n     * @param newLendingToken the address of the token of the new lending position\\n     */\\n    function rebalance(address newLendingToken, uint256 minNewLendingTokenAmount) external onlyOwner {\\n        if (!inputTokens[newLendingToken]) revert UnapprovedToken(newLendingToken);\\n        if (isShutdown) revert ContractShutdown();\\n\\n        if(newLendingToken == currentLendingToken) revert SameLendingToken(newLendingToken);\\n\\n        uint256 lendingPositionBalance = _redeemFromAave(currentLendingToken, type(uint256).max);\\n\\n        address[] memory path = new address[](2);\\n        path[0] = currentLendingToken;\\n        path[1] = newLendingToken;\\n\\n        uint256 newLendingTokenAmount = _multihopSwap(\\n            path,\\n            lendingPositionBalance,\\n            minNewLendingTokenAmount\\n        );\\n\\n        _updateLendingPosition(newLendingToken);\\n\\n        _depositToAave(newLendingToken, newLendingTokenAmount);\\n\\n        emit Rebalance(newLendingToken, newLendingTokenAmount);\\n    }\\n\\n    function transfer(address to, uint256 amount) public override returns (bool) {\\n        return transferFrom(msg.sender, to, amount);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        if (from != msg.sender) {\\n            uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n            if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n        }\\n\\n        balanceOf[from] -= amount;\\n\\n        UserDeposit[] storage depositsFrom = userDeposits[from];\\n        UserDeposit[] storage depositsTo = userDeposits[to];\\n\\n        // NOTE: Flag this for auditors.\\n        uint256 leftToTransfer = amount;\\n        for (uint256 i = depositsFrom.length - 1; i + 1 != 0; i--) {\\n            UserDeposit storage dFrom = depositsFrom[i];\\n\\n            uint256 dFromShares = dFrom.shares;\\n            if (dFromShares != 0) {\\n                uint256 transferShares = MathUtils.min(leftToTransfer, dFromShares);\\n                uint256 transferAssets = MathUtils.mulDivUp(dFrom.assets, transferShares, dFromShares);\\n\\n                dFrom.shares -= transferShares;\\n                dFrom.assets -= transferAssets;\\n\\n                depositsTo.push(UserDeposit({\\n                    assets: transferAssets,\\n                    shares: transferShares,\\n                    timeDeposited: dFrom.timeDeposited\\n                }));\\n\\n                leftToTransfer -= transferShares;\\n            }\\n\\n            if (i == 0 || leftToTransfer == 0) break;\\n        }\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /// @notice Take platform fees off of cellar's active assets.\\n    function accruePlatformFees() external {\\n        uint256 elapsedTime = block.timestamp - lastTimeAccruedPlatformFees;\\n        uint256 feeInAssets = (activeAssets() * elapsedTime * PLATFORM_FEE) / DENOMINATOR / SECS_PER_YEAR;\\n        uint256 fees = convertToShares(feeInAssets);\\n\\n        _mint(address(this), fees);\\n\\n        accruedPlatformFees += fees;\\n    }\\n\\n    /// @notice Transfer accrued fees to Cosmos to distribute.\\n    function transferFees() external onlyOwner {\\n        uint256 fees = accruedPerformanceFees + accruedPlatformFees;\\n        uint256 feeInAssets = convertToAssets(fees);\\n\\n        // Only withdraw from Aave if holding pool does not contain enough funds.\\n        uint256 holdingPoolAssets = inactiveAssets();\\n        if (holdingPoolAssets < feeInAssets) {\\n            _redeemFromAave(currentLendingToken, feeInAssets - holdingPoolAssets);\\n        }\\n\\n        _burn(address(this), fees);\\n\\n        ERC20(currentLendingToken).approve(address(gravityBridge), feeInAssets);\\n        gravityBridge.sendToCosmos(currentLendingToken, feesDistributor, feeInAssets);\\n\\n        accruedPlatformFees = 0;\\n        accruedPerformanceFees = 0;\\n\\n        emit TransferFees(fees, feeInAssets);\\n    }\\n\\n    /**\\n     * @notice Set approval for a token to be deposited into the cellar.\\n     * @param token the address of the supported token\\n     */\\n    function setInputToken(address token, bool isApproved) external onlyOwner {\\n        _validateTokenOnAave(token); // Only allow input tokens supported by Aave.\\n\\n        inputTokens[token] = isApproved;\\n\\n        emit SetInputToken(token, isApproved);\\n    }\\n\\n    /// @notice Removes initial liquidity restriction.\\n    function removeLiquidityRestriction() external onlyOwner {\\n        delete maxDeposit;\\n        delete maxLiquidity;\\n\\n        emit LiquidityRestrictionRemoved();\\n    }\\n\\n    /**\\n     * @notice Pause the contract, prevents depositing.\\n     * @param _isPaused whether the contract should be paused\\n     */\\n    function setPause(bool _isPaused) external onlyOwner {\\n        if (isShutdown) revert ContractShutdown();\\n\\n        isPaused = _isPaused;\\n\\n        emit Pause(msg.sender, _isPaused);\\n    }\\n\\n    /**\\n     * @notice Stops the contract - this is irreversible. Should only be used in an emergency,\\n     *         for example an irreversible accounting bug or an exploit.\\n     */\\n    function shutdown() external onlyOwner {\\n        if (isShutdown) revert AlreadyShutdown();\\n\\n        // Update state and put in irreversible emergency mode.\\n        isShutdown = true;\\n\\n        // Ensure contract is not paused.\\n        isPaused = false;\\n\\n        if (activeAssets() > 0) {\\n            // Withdraw everything from Aave.\\n            _redeemFromAave(currentLendingToken, type(uint256).max);\\n        }\\n\\n        emit Shutdown(msg.sender);\\n    }\\n\\n    /**\\n     * @notice Removes tokens from this cellar that are not the type of token managed\\n     *         by this cellar. This may be used in case of accidentally sending the\\n     *         wrong kind of token to this contract.\\n     * @param token address of token to transfer out of this cellar\\n     */\\n    function sweep(address token) external onlyOwner {\\n        if (inputTokens[token] || token == currentAToken || token == address(this))\\n            revert ProtectedToken(token);\\n\\n        uint256 amount = ERC20(token).balanceOf(address(this));\\n        ERC20(token).safeTransfer(msg.sender, amount);\\n\\n        emit Sweep(token, amount);\\n    }\\n\\n    /**\\n     * @notice Swaps input token by Uniswap V3.\\n     * @param tokenIn the address of the incoming token\\n     * @param tokenOut the address of the outgoing token\\n     * @param amountIn the amount of tokens to be swapped\\n     * @param amountOutMinimum the minimum amount of tokens returned\\n     * @return amountOut the amount of tokens received after swap\\n     */\\n    function _swap(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) internal returns (uint256 amountOut) {\\n        // Approve the router to spend tokenIn.\\n        ERC20(tokenIn).safeApprove(address(uniswapRouter), amountIn);\\n\\n        ISwapRouter.ExactInputSingleParams memory params = ISwapRouter\\n            .ExactInputSingleParams({\\n                tokenIn: tokenIn,\\n                tokenOut: tokenOut,\\n                fee: POOL_FEE,\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: amountIn,\\n                amountOutMinimum: amountOutMinimum,\\n                sqrtPriceLimitX96: 0\\n            });\\n\\n        // Executes the swap.\\n        amountOut = uniswapRouter.exactInputSingle(params);\\n\\n        emit Swapped(tokenIn, amountIn, tokenOut, amountOut);\\n    }\\n\\n    function swap(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external onlyOwner returns (uint256 amountOut) {\\n        return _swap(tokenIn, tokenOut, amountIn, amountOutMinimum);\\n    }\\n\\n    /**\\n     * @notice Swaps tokens by multihop swap in Uniswap V3.\\n     * @param path the token swap path (token addresses)\\n     * @param amountIn the amount of tokens to be swapped\\n     * @param amountOutMinimum the minimum amount of tokens returned\\n     * @return amountOut the amount of tokens received after swap\\n     */\\n    function _multihopSwap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) internal returns (uint256 amountOut) {\\n        // Approve the router to spend first token in path.\\n        address tokenIn = path[0];\\n        ERC20(tokenIn).safeApprove(address(uniswapRouter), amountIn);\\n\\n        bytes memory encodePackedPath = abi.encodePacked(tokenIn);\\n        for (uint256 i = 1; i < path.length; i++) {\\n            encodePackedPath = abi.encodePacked(\\n                encodePackedPath,\\n                POOL_FEE,\\n                path[i]\\n            );\\n        }\\n\\n        // Multiple pool swaps are encoded through bytes called a `path`. A path\\n        // is a sequence of token addresses and poolFees that define the pools\\n        // used in the swaps. The format for pool encoding is (tokenIn, fee,\\n        // tokenOut/tokenIn, fee, tokenOut) where tokenIn/tokenOut parameter is\\n        // the shared token across the pools.\\n        ISwapRouter.ExactInputParams memory params = ISwapRouter\\n            .ExactInputParams({\\n                path: encodePackedPath,\\n                recipient: address(this),\\n                deadline: block.timestamp,\\n                amountIn: amountIn,\\n                amountOutMinimum: amountOutMinimum\\n            });\\n\\n        // Executes the swap.\\n        amountOut = uniswapRouter.exactInput(params);\\n\\n        emit Swapped(tokenIn, amountIn, path[path.length - 1], amountOut);\\n    }\\n\\n    function multihopSwap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external onlyOwner returns (uint256) {\\n        return _multihopSwap(path, amountIn, amountOutMinimum);\\n    }\\n\\n    /**\\n     * @notice Swaps tokens by SushiSwap Router.\\n     * @param path the token swap path (token addresses)\\n     * @param amountIn the amount of tokens to be swapped\\n     * @param amountOutMinimum the minimum amount of tokens returned\\n     * @return amountOut the amount of tokens received after swap\\n     */\\n    function _sushiswap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) internal returns (uint256 amountOut) {\\n        address tokenIn = path[0];\\n\\n        // Approve the router to spend first token in path.\\n        ERC20(tokenIn).safeApprove(address(sushiSwapRouter), amountIn);\\n\\n        uint256[] memory amounts = sushiSwapRouter.swapExactTokensForTokens(\\n            amountIn,\\n            amountOutMinimum,\\n            path,\\n            address(this),\\n            block.timestamp + 60\\n        );\\n\\n        amountOut = amounts[amounts.length - 1];\\n\\n        emit Swapped(tokenIn, amountIn, path[path.length - 1], amountOut);\\n    }\\n\\n    function sushiswap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external onlyOwner returns (uint256) {\\n        return _sushiswap(path, amountIn, amountOutMinimum);\\n    }\\n\\n\\n    /// @notice Total amount of inactive asset waiting in a holding pool to be entered into a strategy.\\n    function inactiveAssets() public view returns (uint256) {\\n        return ERC20(currentLendingToken).balanceOf(address(this));\\n    }\\n\\n    /// @notice Total amount of active asset entered into a strategy.\\n    function activeAssets() public view returns (uint256) {\\n        // The aTokens' value is pegged to the value of the corresponding deposited\\n        // asset at a 1:1 ratio, so we can find the amount of assets active in a\\n        // strategy simply by taking balance of aTokens cellar holds.\\n        return ERC20(currentAToken).balanceOf(address(this));\\n    }\\n\\n    /// @notice Total amount of the underlying asset that is managed by cellar.\\n    function totalAssets() public view returns (uint256) {\\n        return activeAssets() + inactiveAssets();\\n    }\\n\\n    /**\\n     * @notice The amount of shares that the cellar would exchange for the amount of assets provided.\\n     * @param assets amount of assets to convert\\n     * @param offset amount to negatively offset total assets during calculation\\n     */\\n    function _convertToShares(uint256 assets, uint256 offset) internal view returns (uint256) {\\n        return totalSupply == 0 ? assets : MathUtils.mulDivDown(assets, totalSupply, totalAssets() - offset);\\n    }\\n\\n    function convertToShares(uint256 assets) public view returns (uint256) {\\n        return _convertToShares(assets, 0);\\n    }\\n\\n    /**\\n     * @notice The amount of assets that the cellar would exchange for the amount of shares provided.\\n     * @param shares amount of shares to convert\\n     */\\n    function convertToAssets(uint256 shares) public view returns (uint256) {\\n        return totalSupply == 0 ? shares : MathUtils.mulDivDown(shares, totalAssets(), totalSupply);\\n    }\\n\\n    /**\\n     * @notice Check if a token is being supported by Aave.\\n     * @param token address of the token being checked\\n     * @return aTokenAddress address of the token's aToken version on Aave\\n     */\\n    function _validateTokenOnAave(address token) internal view returns (address aTokenAddress) {\\n        (, , , , , , , aTokenAddress, , , , ) = lendingPool.getReserveData(token);\\n\\n        if (aTokenAddress == address(0)) revert TokenIsNotSupportedByAave(token);\\n    }\\n\\n    /**\\n     * @notice Update the current lending tokening and current aToken.\\n     * @param newLendingToken address of the new lending token\\n     */\\n    function _updateLendingPosition(address newLendingToken) internal {\\n        address aTokenAddress = _validateTokenOnAave(newLendingToken);\\n\\n        currentLendingToken = newLendingToken;\\n        currentAToken = aTokenAddress;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IAaveV2StablecoinCellar.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.11;\\n\\n/// @title interface for AaveV2StablecoinCellar\\ninterface IAaveV2StablecoinCellar {\\n    /**\\n     * @notice Emitted when assets are deposited into cellar.\\n     * @param caller the address of the caller\\n     * @param owner the address of the owner of shares\\n     * @param assets the amount of assets being deposited\\n     * @param shares the amount of shares minted to owner\\n     */\\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\\n\\n    /**\\n     * @notice Emitted when assets are withdrawn from cellar.\\n     * @param caller the address of the caller\\n     * @param owner the address of the owner of shares\\n     * @param assets the amount of assets being withdrawn\\n     * @param shares the amount of shares burned from owner\\n     */\\n    event Withdraw(\\n        address indexed caller,\\n        address indexed receiver,\\n        address indexed owner,\\n        uint256 assets,\\n        uint256 shares\\n    );\\n\\n    /**\\n     * @notice Emitted when tokens swapped.\\n     * @param tokenIn the address of the tokenIn\\n     * @param amountIn the amount of the tokenIn\\n     * @param tokenOut the address of the tokenOut\\n     * @param amountOut the amount of the tokenOut\\n     */\\n    event Swapped(\\n        address indexed tokenIn,\\n        uint256 amountIn,\\n        address tokenOut,\\n        uint256 amountOut\\n    );\\n\\n    /**\\n     * @notice Emitted on deposit to Aave.\\n     * @param token the address of the token of the lending position\\n     * @param assets the amount that has been deposited\\n     */\\n    event DepositToAave(\\n        address indexed token,\\n        uint256 assets\\n    );\\n\\n    /**\\n     * @notice Emitted on redeem from Aave.\\n     * @param token the address of the redeemed token\\n     * @param assets the amount that has been redeemed\\n     */\\n    event RedeemFromAave(\\n        address indexed token,\\n        uint256 assets\\n    );\\n\\n    /**\\n     * @notice Emitted on rebalance of Aave lending position.\\n     * @param token the address of the token of the new lending position\\n     * @param assets the amount that has been deposited\\n     */\\n    event Rebalance(\\n        address indexed token,\\n        uint256 assets\\n    );\\n\\n    /**\\n     * @notice Emitted when platform fees are transferred to Cosmos.\\n     * @param feeInShares amount of fees transferred (in shares)\\n     * @param feeInAssets amount of fees transferred (in assets)\\n     */\\n    event TransferFees(uint256 feeInShares, uint256 feeInAssets);\\n\\n    /**\\n     * @notice Emitted when liquidity restriction removed.\\n     */\\n    event LiquidityRestrictionRemoved();\\n\\n    /**\\n     * @notice Emitted when tokens accidently sent to cellar are recovered.\\n     * @param token the address of the token\\n     * @param amount amount transferred out\\n     */\\n    event Sweep(address indexed token, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when an input token is approved or unapproved.\\n     * @param token the address of the token\\n     * @param isApproved whether it is approved\\n     */\\n    event SetInputToken(address token, bool isApproved);\\n\\n    /**\\n     * @notice Emitted when cellar is paused.\\n     * @param caller address that set the pause\\n     * @param isPaused whether the contract is paused\\n     */\\n    event Pause(address caller, bool isPaused);\\n\\n    /**\\n     * @notice Emitted when cellar is shutdown.\\n     * @param caller address that called the shutdown\\n     */\\n    event Shutdown(address caller);\\n\\n    /**\\n     * @notice Attempted an action with a token that is not approved.\\n     * @param unapprovedToken address of the unapproved token\\n     */\\n    error UnapprovedToken(address unapprovedToken);\\n\\n    /**\\n     * @notice Attempted an action with zero assets.\\n     */\\n    error ZeroAssets();\\n\\n    /**\\n     * @notice Attempted an action with zero shares.\\n     */\\n    error ZeroShares();\\n\\n    /**\\n     * @notice Attempted deposit more liquidity over the liquidity limit.\\n     * @param currentLiquidity the current liquidity\\n     * @param maxLiquidity the max liquidity\\n     */\\n    error LiquidityRestricted(uint256 currentLiquidity, uint256 maxLiquidity);\\n\\n    /**\\n     * @notice Attempted deposit more than the per wallet limit.\\n     * @param currentDeposit the current deposit\\n     * @param maxDeposit the max deposit\\n     */\\n    error DepositRestricted(uint256 currentDeposit, uint256 maxDeposit);\\n\\n    /**\\n     * @notice Current lending token is updated to an asset not supported by Aave.\\n     * @param unsupportedToken address of the unsupported token\\n     */\\n    error TokenIsNotSupportedByAave(address unsupportedToken);\\n\\n    /**\\n     * @notice Attempted to sweep an asset that is managed by the cellar.\\n     * @param protectedToken address of the unsupported token\\n     */\\n    error ProtectedToken(address protectedToken);\\n\\n    /**\\n     * @notice Attempted rebalance into the same lending token.\\n     * @param lendingToken address of the lending token\\n     */\\n    error SameLendingToken(address lendingToken);\\n\\n    /**\\n     * @notice Attempted action was prevented due to contract being shutdown.\\n     */\\n    error ContractShutdown();\\n\\n    /**\\n     * @notice Attempted action was prevented due to contract being paused.\\n     */\\n    error ContractPaused();\\n\\n    /**\\n     * @notice Attempted to shutdown the contract when it was already shutdown.\\n     */\\n    error AlreadyShutdown();\\n\\n    function deposit(\\n        address token,\\n        uint256 assets,\\n        uint256 minAssetsIn,\\n        address receiver\\n    ) external returns (uint256 shares);\\n\\n    function deposit(uint256 assets) external returns (uint256);\\n\\n    function deposit(uint256 assets, address receiver) external returns (uint256);\\n\\n    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);\\n\\n    function withdraw(uint256 assets) external returns (uint256 shares);\\n\\n    function inactiveAssets() external view returns (uint256);\\n\\n    function activeAssets() external view returns (uint256);\\n\\n    function totalAssets() external view returns (uint256);\\n\\n    function convertToShares(uint256 assets) external view returns (uint256);\\n\\n    function convertToAssets(uint256 shares) external view returns (uint256);\\n\\n    function swap(\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external returns (uint256 amountOut);\\n\\n    function multihopSwap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external returns (uint256);\\n\\n    function sushiswap(\\n        address[] memory path,\\n        uint256 amountIn,\\n        uint256 amountOutMinimum\\n    ) external returns (uint256);\\n\\n    function enterStrategy() external;\\n\\n    function reinvest(uint256 amount, uint256 minAssetsOut) external;\\n\\n    function reinvest(uint256 minAssetsOut) external;\\n\\n    function claimAndUnstake(uint256 amount) external returns (uint256 claimed);\\n\\n    function claimAndUnstake() external returns (uint256);\\n\\n    function rebalance(address newLendingToken, uint256 minNewLendingTokenAmount) external;\\n\\n    function accruePlatformFees() external;\\n\\n    function transferFees() external;\\n\\n    function setInputToken(address token, bool isApproved) external;\\n\\n    function removeLiquidityRestriction() external;\\n\\n    function sweep(address token) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.7.5;\\npragma abicoder v2;\\n\\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Uniswap V3\\ninterface ISwapRouter is IUniswapV3SwapCallback {\\n    struct ExactInputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParams {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILendingPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.11;\\n\\n/**\\n * @dev Partial interface for a Aave LendingPool contract,\\n * which is the main point of interaction with an Aave protocol's market\\n **/\\ninterface ILendingPool {\\n    /**\\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\\n     * @param asset The address of the underlying asset to deposit\\n     * @param amount The amount to be deposited\\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\\n     *   is a different wallet\\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\\n     *   0 if the action is executed directly by the user, without any middle-man\\n     **/\\n    function deposit(\\n        address asset,\\n        uint256 amount,\\n        address onBehalfOf,\\n        uint16 referralCode\\n    ) external;\\n\\n    /**\\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\\n     * @param asset The address of the underlying asset to withdraw\\n     * @param amount The underlying amount to be withdrawn\\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\\n     * @param to Address that will receive the underlying, same as msg.sender if the user\\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\\n     *   different wallet\\n     * @return The final amount withdrawn\\n     **/\\n    function withdraw(\\n        address asset,\\n        uint256 amount,\\n        address to\\n    ) external returns (uint256);\\n\\n    /**\\n     * @dev Returns the state and configuration of the reserve\\n     * @param asset The address of the underlying asset of the reserve\\n     **/\\n    function getReserveData(address asset)\\n        external\\n        view\\n        returns (\\n            //stores the reserve configuration\\n            //bit 0-15: LTV\\n            //bit 16-31: Liq. threshold\\n            //bit 32-47: Liq. bonus\\n            //bit 48-55: Decimals\\n            //bit 56: Reserve is active\\n            //bit 57: reserve is frozen\\n            //bit 58: borrowing is enabled\\n            //bit 59: stable rate borrowing enabled\\n            //bit 60-63: reserved\\n            //bit 64-79: reserve factor\\n            uint256 configuration,\\n            //the liquidity index. Expressed in ray\\n            uint128 liquidityIndex,\\n            //variable borrow index. Expressed in ray\\n            uint128 variableBorrowIndex,\\n            //the current supply rate. Expressed in ray\\n            uint128 currentLiquidityRate,\\n            //the current variable borrow rate. Expressed in ray\\n            uint128 currentVariableBorrowRate,\\n            //the current stable borrow rate. Expressed in ray\\n            uint128 currentStableBorrowRate,\\n            uint40 lastUpdateTimestamp,\\n            //tokens addresses\\n            address aTokenAddress,\\n            address stableDebtTokenAddress,\\n            address variableDebtTokenAddress,\\n            //address of the interest rate strategy\\n            address interestRateStrategyAddress,\\n            //the id of the reserve. Represents the position in the list of the active reserves\\n            uint8 id\\n        );\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\nlibrary SafeTransferLib {\\n    /*///////////////////////////////////////////////////////////////\\n                            ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(callStatus, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                           ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 100 because the calldata length is 4 + 32 * 3.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool callStatus;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata to memory piece by piece:\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \\\"amount\\\" argument. No mask as it's a full 32 byte value.\\n\\n            // Call the token and store if it succeeded or not.\\n            // We use 68 because the calldata length is 4 + 32 * 2.\\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\\n        }\\n\\n        require(didLastOptionalReturnCallSucceed(callStatus), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         INTERNAL HELPER LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\\n        assembly {\\n            // Get how many bytes the call returned.\\n            let returnDataSize := returndatasize()\\n\\n            // If the call reverted:\\n            if iszero(callStatus) {\\n                // Copy the revert message into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Revert with the same message.\\n                revert(0, returnDataSize)\\n            }\\n\\n            switch returnDataSize\\n            case 32 {\\n                // Copy the return data into memory.\\n                returndatacopy(0, 0, returnDataSize)\\n\\n                // Set success to whether it returned true.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            case 0 {\\n                // There was no return data.\\n                success := 1\\n            }\\n            default {\\n                // It returned some malformed input.\\n                success := 0\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@rari-capital/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus = 1;\\n\\n    modifier nonReentrant() {\\n        require(reentrancyStatus == 1, \\\"REENTRANCY\\\");\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/MathUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\nlibrary MathUtils {\\n    uint256 internal constant RAY = 1e27;\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    // From Solmate's FixedPointMathLib\\n    function mulDivDown(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // Divide z by the denominator.\\n            z := div(z, denominator)\\n        }\\n    }\\n\\n    function mulDivUp(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 z) {\\n        assembly {\\n            // Store x * y in z for now.\\n            z := mul(x, y)\\n\\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\\n                revert(0, 0)\\n            }\\n\\n            // First, divide z - 1 by the denominator and add 1.\\n            // We allow z - 1 to underflow if z is 0, because we multiply the\\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IAaveIncentivesController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.8.11;\\n\\ninterface IAaveIncentivesController {\\n  event RewardsAccrued(address indexed user, uint256 amount);\\n\\n  event RewardsClaimed(address indexed user, address indexed to, uint256 amount);\\n\\n  event RewardsClaimed(\\n    address indexed user,\\n    address indexed to,\\n    address indexed claimer,\\n    uint256 amount\\n  );\\n\\n  event ClaimerSet(address indexed user, address indexed claimer);\\n\\n  /*\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n  function getAssetData(address asset)\\n    external\\n    view\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  /*\\n   * LEGACY **************************\\n   * @dev Returns the configuration of the distribution for a certain asset\\n   * @param asset The address of the reference asset of the distribution\\n   * @return The asset index, the emission per second and the last updated timestamp\\n   **/\\n  function assets(address asset)\\n    external\\n    view\\n    returns (\\n      uint128,\\n      uint128,\\n      uint256\\n    );\\n\\n  /**\\n   * @dev Whitelists an address to claim the rewards on behalf of another address\\n   * @param user The address of the user\\n   * @param claimer The address of the claimer\\n   */\\n  function setClaimer(address user, address claimer) external;\\n\\n  /**\\n   * @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n   * @param user The address of the user\\n   * @return The claimer address\\n   */\\n  function getClaimer(address user) external view returns (address);\\n\\n  /**\\n   * @dev Configure assets for a certain rewards emission\\n   * @param assets The assets to incentivize\\n   * @param emissionsPerSecond The emission for each asset\\n   */\\n  function configureAssets(address[] calldata assets, uint256[] calldata emissionsPerSecond)\\n    external;\\n\\n  /**\\n   * @dev Called by the corresponding asset on any update that affects the rewards distribution\\n   * @param asset The address of the user\\n   * @param userBalance The balance of the user of the asset in the lending pool\\n   * @param totalSupply The total supply of the asset in the lending pool\\n   **/\\n  function handleAction(\\n    address asset,\\n    uint256 userBalance,\\n    uint256 totalSupply\\n  ) external;\\n\\n  /**\\n   * @dev Returns the total of rewards of an user, already accrued + not yet accrued\\n   * @param user The address of the user\\n   * @return The rewards\\n   **/\\n  function getRewardsBalance(address[] calldata assets, address user)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user, on all the assets of the lending pool, accumulating the pending rewards\\n   * @param amount Amount of rewards to claim\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewards(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev Claims reward for an user on behalf, on all the assets of the lending pool, accumulating the pending rewards. The caller must\\n   * be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n   * @param amount Amount of rewards to claim\\n   * @param user Address to check and claim rewards\\n   * @param to Address that will be receiving the rewards\\n   * @return Rewards claimed\\n   **/\\n  function claimRewardsOnBehalf(\\n    address[] calldata assets,\\n    uint256 amount,\\n    address user,\\n    address to\\n  ) external returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @return the unclaimed user rewards\\n   */\\n  function getUserUnclaimedRewards(address user) external view returns (uint256);\\n\\n  /**\\n   * @dev returns the unclaimed rewards of the user\\n   * @param user the address of the user\\n   * @param asset The asset to incentivize\\n   * @return the user index for the asset\\n   */\\n  function getUserAssetData(address user, address asset) external view returns (uint256);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function REWARD_TOKEN() external view returns (address);\\n\\n  /**\\n   * @dev for backward compatibility with previous implementation of the Incentives controller\\n   */\\n  function PRECISION() external view returns (uint8);\\n\\n  /**\\n   * @dev Gets the distribution end timestamp of the emissions\\n   */\\n  function DISTRIBUTION_END() external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IStakedTokenV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\n\\npragma solidity 0.8.11;\\n\\ninterface IStakedTokenV2 {\\n  function stake(address to, uint256 amount) external;\\n\\n  function redeem(address to, uint256 amount) external;\\n\\n  function cooldown() external;\\n\\n  function claimRewards(address to, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISushiSwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.11;\\n\\n/**\\n * @notice Partial interface for a SushiSwap Router contract\\n **/\\ninterface ISushiSwapRouter {\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGravity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.11;\\n\\ninterface Gravity {\\n    function sendToCosmos(address _tokenContract, bytes32 _destination, uint256 _amount) external;\\n}\"\r\n    },\r\n    \"@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Callback for IUniswapV3PoolActions#swap\\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\\ninterface IUniswapV3SwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100,\r\n      \"details\": {\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true\r\n        }\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"_uniswapRouter\",\"type\":\"address\"},{\"internalType\":\"contract ISushiSwapRouter\",\"name\":\"_sushiSwapRouter\",\"type\":\"address\"},{\"internalType\":\"contract ILendingPool\",\"name\":\"_lendingPool\",\"type\":\"address\"},{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"_incentivesController\",\"type\":\"address\"},{\"internalType\":\"contract Gravity\",\"name\":\"_gravityBridge\",\"type\":\"address\"},{\"internalType\":\"contract IStakedTokenV2\",\"name\":\"_stkAAVE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_AAVE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_USDC\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currentLendingToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyShutdown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractShutdown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentDeposit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDeposit\",\"type\":\"uint256\"}],\"name\":\"DepositRestricted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentLiquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLiquidity\",\"type\":\"uint256\"}],\"name\":\"LiquidityRestricted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"protectedToken\",\"type\":\"address\"}],\"name\":\"ProtectedToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lendingToken\",\"type\":\"address\"}],\"name\":\"SameLendingToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unsupportedToken\",\"type\":\"address\"}],\"name\":\"TokenIsNotSupportedByAave\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"unapprovedToken\",\"type\":\"address\"}],\"name\":\"UnapprovedToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAssets\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroShares\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"DepositToAave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LiquidityRestrictionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"Rebalance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"RedeemFromAave\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"SetInputToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"Shutdown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Sweep\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeInShares\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeInAssets\",\"type\":\"uint256\"}],\"name\":\"TransferFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AAVE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DENOMINATOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERFORMANCE_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"POOL_FEE\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECS_PER_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruePlatformFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedPerformanceFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accruedPlatformFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAndUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimAndUnstake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"convertToAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"convertToShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentAToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentLendingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAssetsIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enterStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesDistributor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gravityBridge\",\"outputs\":[{\"internalType\":\"contract Gravity\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"inactiveAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"incentivesController\",\"outputs\":[{\"internalType\":\"contract IAaveIncentivesController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"inputTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isShutdown\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeAccruedPlatformFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeEnteredStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingPool\",\"outputs\":[{\"internalType\":\"contract ILendingPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"name\":\"multihopSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLendingToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minNewLendingTokenAmount\",\"type\":\"uint256\"}],\"name\":\"rebalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAssetsOut\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAssetsOut\",\"type\":\"uint256\"}],\"name\":\"reinvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"removeLiquidityRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newFeeDistributor\",\"type\":\"bytes32\"}],\"name\":\"setFeeDistributor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setInputToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isPaused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutdown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stkAAVE\",\"outputs\":[{\"internalType\":\"contract IStakedTokenV2\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sushiSwapRouter\",\"outputs\":[{\"internalType\":\"contract ISushiSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"name\":\"sushiswap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapRouter\",\"outputs\":[{\"internalType\":\"contract ISwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeDeposited\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"assets\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AaveV2StablecoinCellar", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000e592427a0aece92de3edee1f18e0157c05861564000000000000000000000000d9e1ce17f2641f24ae83637ab66a2cca9c378b9f0000000000000000000000007d2768de32b0b80b7a3454c06bdac94a69ddc7a9000000000000000000000000d784927ff2f95ba542bfc824c8a8a98f3495f6b500000000000000000000000069592e6f9d21989a043646fe8225da2600e5a0f70000000000000000000000004da27a545c0c5b758a6ba100e3a049001de870f50000000000000000000000007fc66500c84a76ad7e9c93437bfc5ac33e2ddae9000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}