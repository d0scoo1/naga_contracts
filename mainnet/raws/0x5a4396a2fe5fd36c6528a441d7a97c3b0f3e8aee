{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\n/// @title interfact to interact with ERC20 tokens\r\n/// @author elee\r\n\r\ninterface IERC20 {\r\n  function mint(address account, uint256 amount) external;\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @title Wavepool is the second genration wave contract\r\n// solhint-disable comprehensive-interface\r\ncontract WavePool {\r\n  struct RedemptionData {\r\n    uint256 claimed;\r\n    bool redeemed;\r\n  }\r\n\r\n  struct WaveMetadata {\r\n    bool enabled;\r\n    bytes32 merkleRoot;\r\n    uint256 enableTime;\r\n  }\r\n\r\n  // mapping from wave -> wave information\r\n  // wave informoation includes the merkleRoot and enableTime\r\n  mapping(uint256 => WaveMetadata) public _metadata;\r\n  // mapping from wave -> address -> claim information\r\n  // claim information includes the amount and whether or not it has been redeemed\r\n  mapping(uint256 => mapping(address => RedemptionData)) public _data;\r\n\r\n  // time at which people can claim\r\n  uint256 public _claimTime;\r\n\r\n  // the address which will receive any possible extra IPT\r\n  address public _receiver;\r\n\r\n  // the token used to claim points, USDC\r\n  IERC20 public _pointsToken; // = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // usdc\r\n  // the token to be rewarded, IPT\r\n  IERC20 public _rewardToken;\r\n\r\n  // the amount of reward tokens allocated to the contract\r\n  uint256 public _totalReward;\r\n\r\n  // this is the minimum amount of 'points' that can be redeemed for one IPT\r\n  uint256 public _floor;\r\n  // this is the maximum amount of points that can be added to the contract\r\n  uint256 public _cap;\r\n\r\n  // the amount of points token that have been sent to the contract\r\n  uint256 public _totalClaimed = 0;\r\n\r\n  uint256 public impliedPrice;\r\n  bool public saturation;\r\n  bool public calculated;\r\n\r\n  event Points(address indexed from, uint256 wave, uint256 amount);\r\n\r\n  constructor(\r\n    address receiver,\r\n    uint256 totalReward,\r\n    address rewardToken,\r\n    address pointsToken,\r\n    uint256 claimTime,\r\n    bytes32 merkle1,\r\n    uint256 enable1,\r\n    bytes32 merkle2,\r\n    uint256 enable2,\r\n    bytes32 merkle3,\r\n    uint256 enable3\r\n  ) {\r\n    // price information\r\n    _floor = 250_000;\r\n    _cap = 500_000 * 35_000_000 * 4;\r\n    _claimTime = claimTime;\r\n    // reward information\r\n    _rewardToken = IERC20(rewardToken);\r\n    _pointsToken = IERC20(pointsToken);\r\n    _totalReward = totalReward;\r\n\r\n    // set receiver of IPT\r\n    _receiver = receiver;\r\n\r\n    // wave metadata\r\n    _metadata[1].enabled = true;\r\n    _metadata[1].merkleRoot = merkle1;\r\n    _metadata[1].enableTime = enable1;\r\n\r\n    _metadata[2].enabled = true;\r\n    _metadata[2].merkleRoot = merkle2;\r\n    _metadata[2].enableTime = enable2;\r\n\r\n    _metadata[3].enabled = true;\r\n    _metadata[3].merkleRoot = merkle3;\r\n    _metadata[3].enableTime = enable3;\r\n\r\n    calculated = false;\r\n    saturation = false;\r\n  }\r\n\r\n  /// @notice tells whether the wave is enabled or not\r\n  /// @return boolean true if the wave is enabled\r\n  function isEnabled(uint256 wave) public view returns (bool) {\r\n    if (_metadata[wave].enabled != true) {\r\n      return false;\r\n    }\r\n    return block.timestamp > _metadata[wave].enableTime && block.timestamp < _claimTime;\r\n  }\r\n\r\n  /// @notice not claimable after USDC cap has been reached\r\n  function canClaim() public view returns (bool) {\r\n    return _totalClaimed <= _cap;\r\n  }\r\n\r\n  /// @notice whether or not redemption is possible\r\n  function canRedeem() public view returns (bool) {\r\n    return block.timestamp > _claimTime;\r\n  }\r\n\r\n  /// @notice calculate pricing 1 time to save gas\r\n  function calculatePricing() internal {\r\n    require(!calculated, \"Calculated already\");\r\n    // implied price is assuming pro rata, how many points you need for one reward\r\n    // for instance, if the totalReward was 1, and _totalClaimed was below 500_000, then the impliedPrice would be below 500_000\r\n    impliedPrice = _totalClaimed / (_totalReward / 1e18);\r\n    if (!(impliedPrice < _floor)) {\r\n      saturation = true;\r\n    }\r\n    calculated = true;\r\n  }\r\n\r\n  /// @notice redeem points for reward token\r\n  /// @param wave if claimed on multiple waves, must redeem for each one separately\r\n  function redeem(uint256 wave) external {\r\n    require(canRedeem() == true, \"can't redeem yet\");\r\n    require(_data[wave][msg.sender].redeemed == false, \"already redeem\");\r\n    if (!calculated) {\r\n      calculatePricing();\r\n    }\r\n\r\n    _data[wave][msg.sender].redeemed = true;\r\n    uint256 rewardAmount;\r\n    RedemptionData memory user = _data[wave][msg.sender];\r\n\r\n    if (!saturation) {\r\n      // if the implied price is smaller than the floor price, that means that\r\n      // not enough points have been claimed to get to the floor price\r\n      // in that case, charge the floor price\r\n      rewardAmount = ((1e18 * user.claimed) / _floor);\r\n    } else {\r\n      // if the implied price is above the floor price, the price is the implied price\r\n      rewardAmount = ((1e18 * user.claimed) / impliedPrice);\r\n    }\r\n    giveTo(msg.sender, rewardAmount);\r\n  }\r\n\r\n  /// @notice 1 USDC == 1 point - rewards distributed pro rata based on points\r\n  /// @param amount amount of usdc\r\n  /// @param key the total amount the points the user may claim - ammount allocated in whitelist\r\n  /// @param merkleProof a proof proving that the caller may redeem up to `key` points\r\n  function getPoints(\r\n    uint256 wave,\r\n    uint256 amount,\r\n    uint256 key,\r\n    bytes32[] memory merkleProof\r\n  ) public {\r\n    require(isEnabled(wave) == true, \"not enabled\");\r\n    uint256 target = _data[wave][msg.sender].claimed + amount;\r\n\r\n    if (_metadata[wave].merkleRoot != 0x00) {\r\n      require(verifyClaim(wave, msg.sender, key, merkleProof) == true, \"invalid proof\");\r\n      require(target <= key, \"max alloc claimed\");\r\n    }\r\n\r\n    _data[wave][msg.sender].claimed = target;\r\n    _totalClaimed = _totalClaimed + amount;\r\n\r\n    require(canClaim() == true, \"Cap reached\");\r\n\r\n    takeFrom(msg.sender, amount);\r\n    emit Points(msg.sender, wave, amount);\r\n  }\r\n\r\n  /// @notice validate the proof of a merkle drop claim\r\n  /// @param wave the wave that they are trying to redeem for\r\n  /// @param claimer the address attempting to claim\r\n  /// @param key the amount of scaled TRIBE allocated the claimer claims that they have credit over\r\n  /// @param merkleProof a proof proving that claimer may redeem up to `key` amount of tribe\r\n  /// @return boolean true if the proof is valid, false if the proof is invalid\r\n  function verifyClaim(\r\n    uint256 wave,\r\n    address claimer,\r\n    uint256 key,\r\n    bytes32[] memory merkleProof\r\n  ) private view returns (bool) {\r\n    bytes32 leaf = keccak256(abi.encodePacked(claimer, key));\r\n    bytes32 merkleRoot = _metadata[wave].merkleRoot;\r\n    return verifyProof(merkleProof, merkleRoot, leaf);\r\n  }\r\n\r\n  //solhint-disable-next-line max-line-length\r\n  //merkle logic: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c9bdb1f0ae168e00a942270f2b85d6a7d3293550/contracts/utils/cryptography/MerkleProof.sol\r\n  //MIT: OpenZeppelin Contracts v4.3.2 (utils/cryptography/MerkleProof.sol)\r\n  function verifyProof(\r\n    bytes32[] memory proof,\r\n    bytes32 root,\r\n    bytes32 leaf\r\n  ) internal pure returns (bool) {\r\n    return processProof(proof, leaf) == root;\r\n  }\r\n\r\n  function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n    bytes32 computedHash = leaf;\r\n    for (uint256 i = 0; i < proof.length; i++) {\r\n      bytes32 proofElement = proof[i];\r\n      if (computedHash <= proofElement) {\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n    return computedHash;\r\n  }\r\n\r\n  /// @notice function which transfer the point token\r\n  function takeFrom(address target, uint256 amount) internal {\r\n    bool check = _pointsToken.transferFrom(target, _receiver, amount);\r\n    require(check, \"erc20 transfer failed\");\r\n  }\r\n\r\n  /// @notice function which sends the reward token\r\n  function giveTo(address target, uint256 amount) internal {\r\n    if (_rewardToken.balanceOf(address(this)) < amount) {\r\n      amount = _rewardToken.balanceOf(address(this));\r\n    }\r\n    require(amount > 0, \"cant redeem zero\");\r\n    bool check = _rewardToken.transfer(target, amount);\r\n    require(check, \"erc20 transfer failed\");\r\n  }\r\n\r\n  ///@notice sends all unclaimed reward tokens to the receiver\r\n  function withdraw() external {\r\n    require(msg.sender == _receiver, \"Only Receiver\");\r\n    //require(block.timestamp > (_claimTime + (7 days)), \"wait for claim time\");\r\n    require(calculated, \"calculatePricing() first\");\r\n\r\n    uint256 rewardAmount;\r\n    if (!saturation) {\r\n      rewardAmount = ((1e18 * _totalClaimed) / _floor);\r\n    } else {\r\n      revert(\"Saturation reached\");\r\n    }\r\n    rewardAmount = _totalReward - rewardAmount;\r\n\r\n    giveTo(_receiver, rewardAmount);\r\n  }\r\n}\r\n// solhint-enable comprehensive-interface", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReward\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pointsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"claimTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkle1\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"enable1\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkle2\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"enable2\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkle3\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"enable3\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"wave\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Points\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_claimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_data\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"redeemed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_floor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_metadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"enableTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_pointsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_receiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_rewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calculated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canRedeem\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wave\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"key\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"getPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"impliedPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wave\",\"type\":\"uint256\"}],\"name\":\"isEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"wave\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saturation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WavePool", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a6e8772af29b29b9202a073f8e36f447689beef60000000000000000000000000000000000000000001cf389cd46047d03000000000000000000000000000000af239a6fab6a873c779f3f33dbd34104287b93e1000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000000000000000000000000000000000000000000000000000000062af5610dbf2f5eb334e66d0d4cea3b99f6f76f81f2b796f632cf2f1ab6cf3d9a1ee23b70000000000000000000000000000000000000000000000000000000062a76d10543ad191ba8182c19ab4d35b50526d7025e958bdaf3ad29097b9835797283a9f0000000000000000000000000000000000000000000000000000000062aa101000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000062acb310", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://05f288d7198e124d49054bc9ef90ccad44b197d9425071fe76b33a01a5eb15af"}]}