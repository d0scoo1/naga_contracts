{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/exchange/Exchange.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\n// __/~~~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_\\\\__/~~\\\\~\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~~\\\\/~~~\\\\__/~~\\\\/~~\\\\__/~~\\\\__/~~\\\\_\\\\__/~~\\\\~\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~~~~~~~\\\\___/~~~~\\\\___/~~\\\\__/~~\\\\_/~~\\\\__/~\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\____/~~\\\\____/~~\\\\__/~~\\\\_/~~\\\\__/~\\n// /~~~~\\\\____/~~~~~~\\\\__/~~\\\\__/~~\\\\____/~~\\\\____/~~\\\\__/~~\\\\_/~~\\\\__/~\\n// /~~\\\\__/~\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/~~\\\\_\\n// /~~\\\\__/~\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2588\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2591\u2591\u2591/~~\\\\__/~\\n// /~~\\\\__/~\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557\u2591\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2591\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2591/~~\\\\__/~~\\n// ___/~~\\\\~\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2591\u255a\u2588\u2588\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/\\n// ___/~~\\\\~\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u2591\u255a\u2588\u2588\u2554\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\_\\n// ___/~~\\\\~\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2591\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2591\u255a\u2550\u255d\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/\\n// ___/~~\\\\~\u2591\u2591\u2591\u2588\u2588\u2557\u2591\u2591\u2588\u2588\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u255d\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/~~\\\\\\n// /\\\\__/~\\\\~\u2591\u2591\u2591\u255a\u2588\u2588\u2588\u2588\u2588\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2551\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\_\\n// \\\\_/~\\\\~/~\u2591\u2591\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u255a\u2550\u2550\u2550\u2550\u2550\u255d\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/~\\n// /\\\\_/~\\\\_~\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591/~~\\\\__/\\n// __/~~~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\_~\\\\__/~\\\\~\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~~\\\\/~~~\\\\__/~~\\\\/~~\\\\__/~~\\\\__/~~\\\\_~\\\\__/~\\\\~\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~~~~~~~\\\\___/~~~~\\\\___/~~\\\\__/~~\\\\_/~~\\\\__/\\\\\\n// ___/~~\\\\__/~~\\\\__/~~\\\\_/~~\\\\__/~~\\\\____/~~\\\\____/~~\\\\__/~~\\\\_/~~\\\\_/~\\\\\\n// /~~~~\\\\____/~~~~~~\\\\__/~~\\\\__/~~\\\\____/~~\\\\____/~~\\\\__/~~\\\\_\\\\__/~\\\\~/\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {IWETH} from \\\"./interfaces/IWETH.sol\\\";\\nimport {ExchangeCore} from \\\"./core/ExchangeCore.sol\\\";\\nimport {ExchangeManager} from \\\"./core/ExchangeManager.sol\\\";\\nimport {ERC721FixedPrice} from \\\"./ERC721/FixedPrice.sol\\\";\\nimport {ReserveAuction} from \\\"./ERC721/ReserveAuction.sol\\\";\\nimport {ERC1155FixedPrice} from \\\"./ERC1155/FixedPrice.sol\\\";\\n\\n/**\\n * @title JumyExchange\\n * @notice The entry contract\\n * @author <Abderrahmen Hanafi> uranium93\\n * @notice ExchangeCore core functionality needed by other contracts\\n * @notice ExchangeManager manage and control the exchange feature\\n * @notice ERC721FixedPrice ERC721 collections list/purchase/remove/offer\\n * @notice ReserveAuction ERC721 reserve auction create/remove/bid/claim\\n * @notice ERC1155FixedPrice ERC1155 collections list/purchase/remove/offer\\n * @notice RoyaltyFeeManager get collections royalty details custom/admin/owner/EIP2981 (Inspired from LookRare)\\n * @notice CollectionRegistry register jumy creator collections to be whitelisted automatically\\n * @notice Rewards jumy reward token logic\\n */\\ncontract JumyExchange is\\n    ExchangeCore,\\n    ExchangeManager,\\n    ERC721FixedPrice,\\n    ReserveAuction,\\n    ERC1155FixedPrice\\n{\\n    constructor(\\n        address weth,\\n        address jumyNftCollection,\\n        address royaltyManagerContract,\\n        address collectionRegistryContract,\\n        address protocolFeesRecipientWallet\\n    )\\n        ExchangeCore(\\n            weth,\\n            jumyNftCollection,\\n            royaltyManagerContract,\\n            collectionRegistryContract,\\n            protocolFeesRecipientWallet\\n        )\\n    {}\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU\\npragma solidity >=0.5.0;\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/core/ExchangeCore.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {Pausable} from \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport {ReentrancyGuard} from \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {IRoyaltyFeeManager} from \\\"../interfaces/IRoyaltyFeeManager.sol\\\";\\nimport {ICollectionRegistry} from \\\"../../collections/interfaces/ICollectionRegistry.sol\\\";\\n\\nimport {IRewards} from \\\"../../rewards/interfaces/IRewards.sol\\\";\\nimport {Errors} from \\\"./Errors.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\n\\ncontract ExchangeCore is Ownable, Pausable, ReentrancyGuard, Errors {\\n    // Wrapped ETH\\n    address public immutable WETH;\\n    // Genesis jumy nft collection\\n    address public immutable JUMY_COLLECTION;\\n\\n    // Jumy royalty fee manager and registry\\n    IRoyaltyFeeManager public royaltyManager;\\n\\n    // Jumy creator collections registry\\n    ICollectionRegistry public collectionRegistry;\\n\\n    // Jumy token rewards\\n    IRewards public rewardsManager;\\n\\n    address public protocolFeesRecipient;\\n    uint256 public protocolFeesPercentage = 500; // 5%, {100_00}Base\\n\\n    // Allowed collection to be listed\\n    mapping(address => bool) public whitelistedCustomCollection;\\n\\n    // Not Allowed collection from been listed\\n    mapping(address => bool) public blackListedCollection;\\n\\n    // Not Allowed users from listing\\n    mapping(address => bool) public blackListedUser;\\n\\n    // Defines a different service fees percentage than the global one for some specific collections (e.g., Brands)\\n    mapping(address => uint256) public specialProtocolFeesPercentage;\\n\\n    // Withdrawable ETH of failed transfers\\n    mapping(address => uint256) public failedEthTransfer;\\n\\n    event RoyaltySent(\\n        address indexed to,\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    );\\n\\n    event ServiceFeesCollected(address indexed to, uint256 amount);\\n\\n    event FailedToSendEth(address to, uint256 amount);\\n\\n    event FailedEthWithdrawn(address from, address to, uint256 amount);\\n\\n    event StuckEthWithdrawn(uint256 amount);\\n\\n    event StuckERC721Transferred(\\n        address collection,\\n        uint256 tokenId,\\n        address to\\n    );\\n\\n    event StuckERC1155Transferred(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address to\\n    );\\n\\n    modifier onlyNonBlacklistedUsers() {\\n        if (blackListedUser[msg.sender]) revert BlacklistedUser();\\n        _;\\n    }\\n\\n    modifier onlyAllowedToBeListed(address collection) {\\n        if (!_isAllowedToBeListed(collection))\\n            revert Exchange_UnAuthorized_Collection();\\n        _;\\n    }\\n\\n    constructor(\\n        address weth,\\n        address jumyNftCollection,\\n        address royaltyManagerContract,\\n        address collectionRegistryContract,\\n        address protocolFeesRecipientWallet\\n    ) {\\n        if (protocolFeesRecipientWallet == address(0))\\n            revert RejectedNullishAddress();\\n\\n        if (weth == address(0)) revert RejectedNullishAddress();\\n\\n        if (jumyNftCollection == address(0)) revert RejectedNullishAddress();\\n\\n        WETH = weth;\\n        JUMY_COLLECTION = jumyNftCollection;\\n        royaltyManager = IRoyaltyFeeManager(royaltyManagerContract);\\n        collectionRegistry = ICollectionRegistry(collectionRegistryContract);\\n        protocolFeesRecipient = protocolFeesRecipientWallet;\\n    }\\n\\n    function isAllowedToBeListed(address collection)\\n        external\\n        view\\n        returns (bool)\\n    {\\n        return _isAllowedToBeListed(collection);\\n    }\\n\\n    function getProtocolFeesPercentage(address collection)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return _getProtocolFeesPercentage(collection);\\n    }\\n\\n    /**\\n     * @dev Get the service fees percentage 10_000 base (500 ==> 5%, 50 ==> 0.5%).\\n     * @notice function will check if there's any manually custom fees percentage.\\n     * set for a specific collection in the `specialProtocolFeesPercentage` mapping\\n     * if there's no custom collection specific fees it returns the global fees percentage `protocolFeesPercentage`.\\n     */\\n    function _getProtocolFeesPercentage(address collection)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        uint256 percentage = specialProtocolFeesPercentage[collection];\\n\\n        if (percentage == 0) return protocolFeesPercentage;\\n        return percentage;\\n    }\\n\\n    /**\\n     * @dev Calculate the service fees amount.\\n     * @notice Take the total amount and calculate the service fees amount\\n     * by getting the fees percentage and divide by 10,000.\\n     */\\n    function _calculateProtocolFeesAmount(uint256 amount, address collection)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return (amount * _getProtocolFeesPercentage(collection)) / 10_000;\\n    }\\n\\n    /**\\n     * @dev define the whitelist collection logic.\\n     * @notice the whitelisted collections are:\\n     * - genesis collection `JUMY_COLLECTION`.\\n     * - creators collections registered in `collectionRegistry`.\\n     * - custom manually imported collections.\\n     * @notice all manually blacklisted collection are rejected.\\n     */\\n    function _isAllowedToBeListed(address collection)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return ((!blackListedCollection[collection] &&\\n            // must not be blacklisted\\n            // if it's genesis jumy collection\\n            // if it's jumy collection created via factory\\n            // if it's any other collection added bya admin\\n            (collection == JUMY_COLLECTION)) ||\\n            collectionRegistry.isJumyCollection(collection) ||\\n            whitelistedCustomCollection[collection]);\\n    }\\n\\n    /**\\n     * @dev Split and Send ETH or FAIL.\\n     * @notice ETH amount will be split to:\\n     * - #1 Service fees, Will be sent to {protocolFeesRecipient}.\\n     * - #2 Royalty fees, Will be sent to royalty recipient.\\n     * - #3 Remaining funds (total - #1 - #2), Will be sent to {to}.\\n     *\\n     * @notice If any of the above failed to send ETH, transaction will revert.\\n     */\\n    function _executeETHPayment(\\n        address collection,\\n        uint256 tokenId,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (address royaltyFeesRecipient, uint256 royaltyCut) = royaltyManager\\n            .calculateRoyaltyFeeAndGetRecipient(collection, tokenId, amount);\\n\\n        uint256 serviceCut = _calculateProtocolFeesAmount(amount, collection);\\n\\n        uint256 recipientCut = amount - serviceCut - royaltyCut;\\n\\n        payable(to).transfer(recipientCut);\\n        payable(protocolFeesRecipient).transfer(serviceCut);\\n\\n        if (royaltyFeesRecipient != address(0)) {\\n            payable(royaltyFeesRecipient).transfer(royaltyCut);\\n            emit RoyaltySent(\\n                royaltyFeesRecipient,\\n                collection,\\n                tokenId,\\n                royaltyCut\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Split and Send ETH and save for withdraw if FAIL.\\n     * @notice ETH amount will be split to:\\n     * - #1 Service fees, Will be sent to {protocolFeesRecipient}.\\n     * - #2 Royalty fees, Will be sent to royalty recipient.\\n     * - #3 Remaining funds (total - #1 - #2), Will be sent to {to}.\\n     *\\n     * @notice If any of the above failed to send ETH, ETH amount will\\n     * be stored and made available to withdraw by the recipient.\\n     */\\n    function _executeETHPaymentWithFallback(\\n        address collection,\\n        uint256 tokenId,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (address royaltyFeesRecipient, uint256 royaltyCut) = royaltyManager\\n            .calculateRoyaltyFeeAndGetRecipient(collection, tokenId, amount);\\n\\n        uint256 serviceCut = _calculateProtocolFeesAmount(amount, collection);\\n\\n        uint256 recipientCut = amount - serviceCut - royaltyCut;\\n\\n        payable(protocolFeesRecipient).transfer(serviceCut);\\n\\n        if (!payable(to).send(recipientCut)) {\\n            failedEthTransfer[to] = recipientCut;\\n            emit FailedToSendEth(to, recipientCut);\\n        }\\n\\n        if (royaltyFeesRecipient != address(0)) {\\n            if (!payable(royaltyFeesRecipient).send(royaltyCut)) {\\n                failedEthTransfer[royaltyFeesRecipient] = royaltyCut;\\n                emit FailedToSendEth(royaltyFeesRecipient, royaltyCut);\\n                return;\\n            }\\n            emit RoyaltySent(\\n                royaltyFeesRecipient,\\n                collection,\\n                tokenId,\\n                royaltyCut\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraw WETH then Split Send ETH or FAIL.\\n     * @notice WETH will be transferred from {from} then withdrawn (WETH => ETH).\\n     * @notice ETH amount will be split to:\\n     * - #1 Service fees, Will be sent to {protocolFeesRecipient}.\\n     * - #2 Royalty fees, Will be sent to royalty recipient.\\n     * - #3 Remaining funds (total - #1 - #2), Will be sent to {to}.\\n     *\\n     * @notice If any of the above failed to send ETH, transaction will revert.\\n     */\\n    function _executeWETHPayment(\\n        address collection,\\n        uint256 tokenId,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (address royaltyFeesRecipient, uint256 royaltyCut) = royaltyManager\\n            .calculateRoyaltyFeeAndGetRecipient(collection, tokenId, amount);\\n\\n        uint256 serviceCut = _calculateProtocolFeesAmount(amount, collection);\\n\\n        uint256 recipientCut = amount - serviceCut - royaltyCut;\\n\\n        IWETH(WETH).transferFrom(from, address(this), amount);\\n\\n        IWETH(WETH).withdraw(amount);\\n\\n        payable(to).transfer(recipientCut);\\n        payable(protocolFeesRecipient).transfer(serviceCut);\\n\\n        if (royaltyFeesRecipient != address(0)) {\\n            payable(royaltyFeesRecipient).transfer(royaltyCut);\\n            emit RoyaltySent(\\n                royaltyFeesRecipient,\\n                collection,\\n                tokenId,\\n                royaltyCut\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Send ETH or save for withdraw on FAIL\\n     * @notice If FAILED to send ETH, ETH amount will be stored and made available\\n     * for withdraw.\\n     */\\n    function _sendEthWithFallback(address to, uint256 amount) internal {\\n        if (!payable(to).send(amount)) {\\n            failedEthTransfer[to] = amount;\\n            emit FailedToSendEth(to, amount);\\n            return;\\n        }\\n    }\\n\\n    function withdrawETH(address to) external nonReentrant {\\n        uint256 amount = failedEthTransfer[msg.sender];\\n\\n        if (amount == 0) revert();\\n\\n        delete failedEthTransfer[msg.sender];\\n\\n        payable(to).transfer(amount);\\n\\n        emit FailedEthWithdrawn(msg.sender, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/core/ExchangeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport {IRoyaltyFeeManager} from \\\"../interfaces/IRoyaltyFeeManager.sol\\\";\\nimport {ICollectionRegistry} from \\\"../../collections/interfaces/ICollectionRegistry.sol\\\";\\nimport {ExchangeCore} from \\\"./ExchangeCore.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\nimport {IRewards} from \\\"../../rewards/interfaces/IRewards.sol\\\";\\n\\nabstract contract ExchangeManager is ExchangeCore {\\n    event ProtocolFeesRecipientUpdated(address indexed recipient);\\n    event ProtocolFeesPercentageUpdated(uint256 percentage);\\n    event SpecialCollectionProtocolFeesUpdated(\\n        address collection,\\n        uint256 percentage\\n    );\\n    event RoyaltyManagerUpdated(address indexed royaltyManager);\\n    event CollectionRegistryUpdated(address indexed collectionRegistry);\\n    event WhitelistedCustomCollectionUpdated(address collection, bool state);\\n    event BlackListedCollectionUpdated(address collection, bool state);\\n    event BlackListedUserUpdated(address account, bool state);\\n\\n    function pause() external onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() external onlyOwner {\\n        _unpause();\\n    }\\n\\n    function updateProtocolFeesPercentage(uint256 newPercentage)\\n        external\\n        onlyOwner\\n        returns (uint256)\\n    {\\n        if (newPercentage > 5_000) revert InvalidArg(\\\"max newPercentage\\\");\\n\\n        if (newPercentage == protocolFeesPercentage)\\n            revert RejectedAlreadyInState();\\n\\n        protocolFeesPercentage = newPercentage;\\n        emit ProtocolFeesPercentageUpdated(newPercentage);\\n        return newPercentage;\\n    }\\n\\n    function updateSpecialProtocolFeesPercentage(\\n        address collection,\\n        uint256 percentage\\n    ) external onlyOwner returns (uint256) {\\n        if (percentage > 5_000) revert InvalidArg(\\\"max newPercentage\\\");\\n\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (specialProtocolFeesPercentage[collection] == percentage)\\n            revert RejectedAlreadyInState();\\n\\n        specialProtocolFeesPercentage[collection] = percentage;\\n        emit SpecialCollectionProtocolFeesUpdated(collection, percentage);\\n        return percentage;\\n    }\\n\\n    function updateProtocolFeesRecipient(address newRecipient)\\n        external\\n        onlyOwner\\n        returns (address)\\n    {\\n        if (newRecipient == address(0)) revert RejectedNullishAddress();\\n        protocolFeesRecipient = newRecipient;\\n        emit ProtocolFeesRecipientUpdated(newRecipient);\\n        return newRecipient;\\n    }\\n\\n    /**\\n     * @dev Update {royaltyManager}\\n     * @notice {onlyOwner} protected\\n     */\\n    function updateRoyaltyManager(address newRoyaltyManager)\\n        external\\n        onlyOwner\\n        returns (address)\\n    {\\n        if (newRoyaltyManager == address(0)) revert RejectedNullishAddress();\\n        royaltyManager = IRoyaltyFeeManager(newRoyaltyManager);\\n        emit RoyaltyManagerUpdated(newRoyaltyManager);\\n        return newRoyaltyManager;\\n    }\\n\\n    /**\\n     * @dev Update {rewardsManager}\\n     * @notice {onlyOwner} protected\\n     */\\n    function updateRewardsManager(address newRewardsManager)\\n        external\\n        onlyOwner\\n        returns (address)\\n    {\\n        if (newRewardsManager == address(0)) revert RejectedNullishAddress();\\n        rewardsManager = IRewards(newRewardsManager);\\n        emit RoyaltyManagerUpdated(newRewardsManager);\\n        return newRewardsManager;\\n    }\\n\\n    function updateCollectionRegistry(address newCollectionRegistry)\\n        external\\n        onlyOwner\\n        returns (address)\\n    {\\n        if (newCollectionRegistry == address(0))\\n            revert RejectedNullishAddress();\\n        collectionRegistry = ICollectionRegistry(newCollectionRegistry);\\n        emit CollectionRegistryUpdated(newCollectionRegistry);\\n        return newCollectionRegistry;\\n    }\\n\\n    function updateWhitelistedCustomCollection(address collection, bool state)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (whitelistedCustomCollection[collection] == state)\\n            revert RejectedAlreadyInState();\\n\\n        whitelistedCustomCollection[collection] = state;\\n        emit WhitelistedCustomCollectionUpdated(collection, state);\\n        return true;\\n    }\\n\\n    function updateBlacklistedUser(address account, bool state)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        if (account == address(0)) revert RejectedNullishAddress();\\n\\n        if (blackListedUser[account] == state) revert RejectedAlreadyInState();\\n\\n        blackListedUser[account] = state;\\n        emit BlackListedUserUpdated(account, state);\\n        return true;\\n    }\\n\\n    function updateBlackListedCollection(address collection, bool state)\\n        external\\n        onlyOwner\\n        returns (bool)\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (blackListedCollection[collection] == state)\\n            revert RejectedAlreadyInState();\\n\\n        blackListedCollection[collection] = state;\\n        emit BlackListedCollectionUpdated(collection, state);\\n        return true;\\n    }\\n\\n    function withdrawStuckETH(uint256 amount, address to)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        payable(to).transfer(amount);\\n        emit StuckEthWithdrawn(amount);\\n    }\\n\\n    function withdrawStuckETHFrom(address from, address to)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        uint256 amount = failedEthTransfer[from];\\n\\n        if (amount == 0) revert();\\n\\n        delete failedEthTransfer[from];\\n\\n        payable(to).transfer(amount);\\n\\n        emit StuckEthWithdrawn(amount);\\n        emit FailedEthWithdrawn(from, to, amount);\\n    }\\n\\n    function transferStuckERC721(\\n        address collection,\\n        uint256 tokenId,\\n        address to\\n    ) external onlyOwner nonReentrant {\\n        IERC721(collection).safeTransferFrom(address(this), to, tokenId);\\n\\n        emit StuckERC721Transferred(collection, tokenId, to);\\n    }\\n\\n    function transferStuckERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount,\\n        address to\\n    ) external onlyOwner nonReentrant {\\n        IERC1155(collection).safeTransferFrom(\\n            address(this),\\n            to,\\n            tokenId,\\n            amount,\\n            \\\"\\\"\\n        );\\n\\n        emit StuckERC1155Transferred(collection, tokenId, amount, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/ERC721/FixedPrice.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport {ExchangeCore} from \\\"../core/ExchangeCore.sol\\\";\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\n\\nabstract contract ERC721FixedPrice is ExchangeCore {\\n    struct FixedPriceListing {\\n        address seller;\\n        uint256 price;\\n    }\\n\\n    struct Offer {\\n        uint256 value;\\n        uint256 expiresAt;\\n    }\\n\\n    mapping(address => mapping(uint256 => FixedPriceListing))\\n        public fixedPriceListings;\\n\\n    mapping(address => mapping(uint256 => mapping(address => Offer)))\\n        public offers;\\n\\n    event ItemListed(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price\\n    );\\n\\n    event ItemUpdated(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price\\n    );\\n\\n    event ItemRemoved(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId\\n    );\\n\\n    event ItemPurchased(\\n        address indexed buyer,\\n        address seller,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price\\n    );\\n\\n    event OfferMade(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        uint256 expiresAt\\n    );\\n\\n    event OfferUpdated(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        uint256 expiresAt\\n    );\\n\\n    event OfferCancelled(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId\\n    );\\n\\n    event OfferAccepted(\\n        address beneficiary,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price\\n    );\\n\\n    function listItem(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        _listItem(collection, tokenId, price);\\n\\n        emit ItemListed(msg.sender, collection, tokenId, price);\\n    }\\n\\n    function listItem(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        address royaltyReceiver,\\n        uint256 royaltyPercentage\\n    ) external whenNotPaused onlyNonBlacklistedUsers nonReentrant {\\n        if (collection != JUMY_COLLECTION)\\n            revert Exchange_Rejected_Genesis_Collection_Only();\\n\\n        _listItem(collection, tokenId, price);\\n\\n        royaltyManager.setJumyTokenRoyalty(\\n            collection,\\n            tokenId,\\n            royaltyReceiver,\\n            royaltyPercentage\\n        );\\n\\n        emit ItemListed(msg.sender, collection, tokenId, price);\\n    }\\n\\n    function updateItem(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        _listItem(collection, tokenId, price);\\n\\n        emit ItemUpdated(msg.sender, collection, tokenId, price);\\n    }\\n\\n    function removeItem(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (fixedPriceListings[collection][tokenId].seller != msg.sender) {\\n            revert Exchange_Not_Sale_Owner();\\n        }\\n\\n        delete fixedPriceListings[collection][tokenId];\\n\\n        emit ItemRemoved(msg.sender, collection, tokenId);\\n    }\\n\\n    function purchaseItem(\\n        address collection,\\n        uint256 tokenId,\\n        address to\\n    ) external payable nonReentrant {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n        if (to == address(0)) revert RejectedNullishAddress();\\n\\n        FixedPriceListing memory item = fixedPriceListings[collection][tokenId];\\n\\n        if (item.seller == address(0) || item.price == 0)\\n            revert Exchange_Listing_Not_Found();\\n\\n        if (msg.value != item.price) revert Exchange_Wrong_Price_Value();\\n\\n        delete fixedPriceListings[collection][tokenId];\\n\\n        ExchangeCore._executeETHPayment(\\n            collection,\\n            tokenId,\\n            item.seller,\\n            item.price\\n        );\\n\\n        IERC721(collection).transferFrom(item.seller, to, tokenId);\\n\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.purchaseEvent(\\n                item.seller,\\n                to,\\n                item.price,\\n                collection,\\n                tokenId\\n            );\\n        }\\n\\n        emit ItemPurchased(to, item.seller, collection, tokenId, item.price);\\n    }\\n\\n    function makeOffer(\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        address collection,\\n        uint256 tokenId\\n    ) external nonReentrant {\\n        uint256 expiresAt = _updateOffer(\\n            offerValue,\\n            validityDuration,\\n            collection,\\n            tokenId\\n        );\\n\\n        emit OfferMade(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            offerValue,\\n            validityDuration,\\n            expiresAt\\n        );\\n    }\\n\\n    function updateOffer(\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        address collection,\\n        uint256 tokenId\\n    ) external nonReentrant {\\n        uint256 expiresAt = _updateOffer(\\n            offerValue,\\n            validityDuration,\\n            collection,\\n            tokenId\\n        );\\n\\n        emit OfferUpdated(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            offerValue,\\n            validityDuration,\\n            expiresAt\\n        );\\n    }\\n\\n    function cancelOffer(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        delete offers[collection][tokenId][msg.sender];\\n\\n        emit OfferCancelled(msg.sender, collection, tokenId);\\n    }\\n\\n    function acceptOffer(\\n        address beneficiary,\\n        uint256 offerValue,\\n        address collection,\\n        uint256 tokenId\\n    ) external nonReentrant {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n        if (beneficiary == address(0)) revert RejectedNullishAddress();\\n\\n        Offer memory offer = offers[collection][tokenId][beneficiary];\\n\\n        delete offers[collection][tokenId][beneficiary];\\n        delete fixedPriceListings[collection][tokenId];\\n\\n        if (offer.value != offerValue)\\n            revert Exchange_Wrong_Offer_Value(offer.value);\\n        if (offer.expiresAt < block.timestamp)\\n            revert Exchange_Expired_Offer(offer.expiresAt);\\n\\n        ExchangeCore._executeWETHPayment(\\n            collection,\\n            tokenId,\\n            beneficiary,\\n            msg.sender,\\n            offerValue\\n        );\\n        IERC721(collection).safeTransferFrom(msg.sender, beneficiary, tokenId);\\n\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.purchaseEvent(\\n                msg.sender,\\n                beneficiary,\\n                offer.value,\\n                collection,\\n                tokenId\\n            );\\n        }\\n\\n        emit OfferAccepted(beneficiary, collection, tokenId, offerValue);\\n    }\\n\\n    function _listItem(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 price\\n    ) private {\\n        if (price == 0) revert Exchange_Invalid_Nullish_Price();\\n\\n        if (IERC721(collection).ownerOf(tokenId) != msg.sender)\\n            revert Exchange_Not_The_Token_Owner();\\n\\n        if (\\n            !IERC721(collection).isApprovedForAll(msg.sender, address(this)) &&\\n            IERC721(collection).getApproved(tokenId) != address(this)\\n        ) revert Exchange_Insufficient_Operator_Privilege();\\n\\n        fixedPriceListings[collection][tokenId] = FixedPriceListing(\\n            msg.sender,\\n            price\\n        );\\n    }\\n\\n    function _updateOffer(\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        address collection,\\n        uint256 tokenId\\n    ) private returns (uint256 expiresAt) {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (validityDuration == 0) revert Exchange_Rejected_Nullish_Duration();\\n\\n        if (offerValue == 0) revert Exchange_Rejected_Nullish_Offer_Value();\\n\\n        uint256 wethAllowance = IWETH(WETH).allowance(\\n            msg.sender,\\n            address(this)\\n        );\\n        if (wethAllowance < offerValue)\\n            revert Exchange_Insufficient_WETH_Allowance(wethAllowance);\\n\\n        uint256 _expiresAt = block.timestamp + validityDuration;\\n\\n        offers[collection][tokenId][msg.sender].value = offerValue;\\n        offers[collection][tokenId][msg.sender].expiresAt = _expiresAt;\\n\\n        return _expiresAt;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/ERC721/ReserveAuction.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {ExchangeCore} from \\\"../core/ExchangeCore.sol\\\";\\n\\nabstract contract ReserveAuction is ExchangeCore {\\n    uint32 constant AUCTION_DURATION = 24 hours;\\n    uint16 constant MINIMUM_BID_END_AUCTION_BUFFER = 15 minutes;\\n    uint8 constant MINIMUM_BID_INCREASE_PERCENTAGE = 5;\\n\\n    struct Auction {\\n        address seller;\\n        uint256 startPrice;\\n        address maxBidder;\\n        uint256 maxBid;\\n        uint256 startsAt;\\n        uint128 endsAt;\\n    }\\n\\n    mapping(address => mapping(uint256 => Auction)) public auctions;\\n\\n    event ReserveAuctionCreated(\\n        address creator,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 startPrice,\\n        uint256 startsAt\\n    );\\n\\n    event ReserveAuctionBid(\\n        address bidder,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 startedAt,\\n        uint256 bidValue,\\n        uint256 endsAt\\n    );\\n\\n    event ReserveAuctionClaimed(\\n        address seller,\\n        address maxBidder,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 startedAt,\\n        uint256 endedAt,\\n        uint256 maxBid\\n    );\\n\\n    event ReserveAuctionCanceled(\\n        address seller,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 startedAt\\n    );\\n\\n    function createReserveAuction(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 startPrice,\\n        uint256 startsAt\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        if (startsAt < block.timestamp)\\n            revert Exchange_Starts_At_Must_Be_In_Future();\\n        if (startsAt - block.timestamp > 15 days)\\n            revert Exchange_Starts_At_Too_Far();\\n\\n        _createReserveAuction(collection, tokenId, startPrice, startsAt);\\n    }\\n\\n    function createReserveAuction(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 startPrice\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        _createReserveAuction(collection, tokenId, startPrice, block.timestamp);\\n    }\\n\\n    function createReserveAuction(\\n        address collection,\\n        uint256 tokenId,\\n        address royaltyReceiver,\\n        uint256 royaltyPercentage,\\n        uint256 startPrice,\\n        uint256 startsAt\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        if (collection != JUMY_COLLECTION)\\n            revert Exchange_Rejected_Genesis_Collection_Only();\\n\\n        if (startsAt < block.timestamp)\\n            revert Exchange_Starts_At_Must_Be_In_Future();\\n        if (startsAt - block.timestamp > 15 days)\\n            revert Exchange_Starts_At_Too_Far();\\n\\n        _createReserveAuction(collection, tokenId, startPrice, startsAt);\\n\\n        royaltyManager.setJumyTokenRoyalty(\\n            collection,\\n            tokenId,\\n            royaltyReceiver,\\n            royaltyPercentage\\n        );\\n    }\\n\\n    function createReserveAuction(\\n        address collection,\\n        uint256 tokenId,\\n        address royaltyReceiver,\\n        uint256 royaltyPercentage,\\n        uint256 startPrice\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        if (collection != JUMY_COLLECTION)\\n            revert Exchange_Rejected_Genesis_Collection_Only();\\n\\n        _createReserveAuction(collection, tokenId, startPrice, block.timestamp);\\n\\n        royaltyManager.setJumyTokenRoyalty(\\n            collection,\\n            tokenId,\\n            royaltyReceiver,\\n            royaltyPercentage\\n        );\\n    }\\n\\n    function bid(address collection, uint256 tokenId)\\n        external\\n        payable\\n        nonReentrant\\n        onlyNonBlacklistedUsers\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        Auction memory auction = auctions[collection][tokenId];\\n\\n        if (block.timestamp < auction.startsAt)\\n            revert Exchange_Drop_Not_Started_Yet();\\n\\n        // FLOW 01:: Auction did't start yet, and this is the first bid\\n        // Execute the bellow block and return\\n        if (auction.endsAt == 0) {\\n            if (msg.value < auction.startPrice)\\n                revert Exchange_Invalid_Start_Price(\\n                    auction.startPrice,\\n                    msg.value\\n                );\\n            auctions[collection][tokenId].endsAt =\\n                uint128(block.timestamp) +\\n                AUCTION_DURATION;\\n\\n            auctions[collection][tokenId].maxBidder = msg.sender;\\n            auctions[collection][tokenId].maxBid = msg.value;\\n\\n            emit ReserveAuctionBid(\\n                msg.sender,\\n                collection,\\n                tokenId,\\n                auction.startsAt,\\n                msg.value,\\n                auctions[collection][tokenId].endsAt\\n            );\\n            return;\\n        }\\n\\n        // FLOW 02:: Auction already started but expired\\n        // (FLOW 01) is ignored\\n        if (block.timestamp > auction.endsAt) {\\n            revert Exchange_Rejected_Ended_Auction(\\n                auction.endsAt,\\n                block.timestamp\\n            );\\n        }\\n\\n        // FLOW 03:: Auction already started and not expired\\n        // (FLOW 01) and (FLOW 02) are ignored\\n        // Extend if it Will expire in less than 15 minutes\\n        uint128 fifteenMinutesLater = uint128(block.timestamp) +\\n            MINIMUM_BID_END_AUCTION_BUFFER;\\n        if (fifteenMinutesLater > auction.endsAt) {\\n            auctions[collection][tokenId].endsAt = fifteenMinutesLater;\\n        }\\n\\n        // Revert if value is not 5% higher than previous bid\\n        uint256 minimumNextBid = auction.maxBid +\\n            ((auction.maxBid * MINIMUM_BID_INCREASE_PERCENTAGE) / 100);\\n        if (msg.value < minimumNextBid)\\n            revert Exchange_Rejected_Must_Be_5_Percent_Higher(\\n                minimumNextBid,\\n                msg.value\\n            );\\n\\n        auctions[collection][tokenId].maxBidder = msg.sender;\\n        auctions[collection][tokenId].maxBid = msg.value;\\n\\n        // Refund previous bidder, send eth with fallback\\n        ExchangeCore._sendEthWithFallback(auction.maxBidder, auction.maxBid);\\n\\n        emit ReserveAuctionBid(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            auction.startsAt,\\n            msg.value,\\n            auctions[collection][tokenId].endsAt\\n        );\\n    }\\n\\n    function cancelAuction(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        if (auctions[collection][tokenId].seller != msg.sender)\\n            revert Exchange_Rejected_Not_Auction_Owner();\\n\\n        if (auctions[collection][tokenId].endsAt != 0)\\n            revert Exchange_Rejected_Auction_In_Progress();\\n\\n        uint256 startedAt = auctions[collection][tokenId].startsAt;\\n\\n        delete auctions[collection][tokenId];\\n\\n        IERC721(collection).transferFrom(address(this), msg.sender, tokenId);\\n\\n        emit ReserveAuctionCanceled(msg.sender, collection, tokenId, startedAt);\\n    }\\n\\n    function claimAuction(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        Auction memory auction = auctions[collection][tokenId];\\n        delete auctions[collection][tokenId];\\n\\n        // Auction not found\\n        if (auction.seller == address(0) || auction.maxBidder == address(0))\\n            revert Exchange_Auction_Not_Found();\\n\\n        // Auction didn't start yet\\n        if (auction.endsAt == 0)\\n            revert Exchange_Rejected_Auction_Not_Started_Yet();\\n\\n        // Auction still in progress\\n        if (block.timestamp < auction.endsAt)\\n            revert Exchange_Rejected_Auction_In_Progress();\\n\\n        ExchangeCore._executeETHPaymentWithFallback(\\n            collection,\\n            tokenId,\\n            auction.seller,\\n            auction.maxBid\\n        );\\n\\n        IERC721(collection).transferFrom(\\n            address(this),\\n            auction.maxBidder,\\n            tokenId\\n        );\\n\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.purchaseEvent(\\n                auction.maxBidder,\\n                auction.seller,\\n                auction.maxBid,\\n                collection,\\n                tokenId\\n            );\\n        }\\n\\n        emit ReserveAuctionClaimed(\\n            auction.seller,\\n            auction.maxBidder,\\n            collection,\\n            tokenId,\\n            auction.startsAt,\\n            auction.endsAt,\\n            auction.maxBid\\n        );\\n    }\\n\\n    function _createReserveAuction(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 startPrice,\\n        uint256 startsAt\\n    ) private {\\n        if (startPrice == 0) revert Exchange_Invalid_Nullish_Price();\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        IERC721(collection).transferFrom(msg.sender, address(this), tokenId);\\n\\n        auctions[collection][tokenId] = Auction({\\n            seller: msg.sender,\\n            startPrice: startPrice,\\n            maxBidder: address(0),\\n            maxBid: 0,\\n            startsAt: startsAt,\\n            endsAt: 0\\n        });\\n\\n        emit ReserveAuctionCreated(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            startPrice,\\n            startsAt\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/ERC1155/FixedPrice.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nimport {ExchangeCore} from \\\"../core/ExchangeCore.sol\\\";\\nimport {IERC1155} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\n\\nabstract contract ERC1155FixedPrice is ExchangeCore {\\n    struct FixedPriceListingERC1155 {\\n        uint256 quantity;\\n        uint256 price;\\n    }\\n\\n    struct OfferERC1155 {\\n        uint256 value;\\n        uint128 quantity;\\n        uint128 expiresAt;\\n    }\\n\\n    mapping(address => mapping(uint256 => mapping(address => FixedPriceListingERC1155)))\\n        public fixedPriceListingsERC1155;\\n\\n    mapping(address => mapping(uint256 => mapping(address => OfferERC1155)))\\n        public offersERC1155;\\n\\n    event ItemListedERC1155(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 quantity\\n    );\\n\\n    event ItemUpdatedERC1155(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 quantity\\n    );\\n\\n    event PriceChangedERC1155(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 quantity\\n    );\\n\\n    event ItemRemovedERC1155(\\n        address indexed account,\\n        address indexed collection,\\n        uint256 tokenId\\n    );\\n\\n    event ItemPurchasedERC1155(\\n        address indexed buyer,\\n        address seller,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 price\\n    );\\n\\n    event OfferMadeERC1155(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        uint256 expiresAt\\n    );\\n\\n    event OfferUpdatedERC1155(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 offerValue,\\n        uint256 validityDuration,\\n        uint256 expiresAt\\n    );\\n\\n    event OfferCancelledERC1155(\\n        address account,\\n        address indexed collection,\\n        uint256 tokenId\\n    );\\n\\n    event OfferAcceptedERC1155(\\n        address beneficiary,\\n        address seller,\\n        address indexed collection,\\n        uint256 tokenId,\\n        uint128 quantity,\\n        uint256 price\\n    );\\n\\n    function listItemERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 price\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        _listItem(collection, tokenId, quantity, price);\\n\\n        emit ItemListedERC1155(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            price,\\n            quantity\\n        );\\n    }\\n\\n    function updateListItemERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 price\\n    )\\n        external\\n        onlyAllowedToBeListed(collection)\\n        whenNotPaused\\n        onlyNonBlacklistedUsers\\n        nonReentrant\\n    {\\n        _listItem(collection, tokenId, quantity, price);\\n\\n        emit ItemUpdatedERC1155(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            price,\\n            quantity\\n        );\\n    }\\n\\n    function removeItemERC1155(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        delete fixedPriceListingsERC1155[collection][tokenId][msg.sender];\\n\\n        emit ItemRemovedERC1155(msg.sender, collection, tokenId);\\n    }\\n\\n    function purchaseItemERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        address seller,\\n        address to\\n    ) external payable nonReentrant {\\n        if (\\n            collection == address(0) || to == address(0) || seller == address(0)\\n        ) revert RejectedNullishAddress();\\n\\n        FixedPriceListingERC1155 memory item = fixedPriceListingsERC1155[\\n            collection\\n        ][tokenId][seller];\\n\\n        if (item.quantity == 0 || item.price == 0)\\n            revert Exchange_Listing_Not_Found();\\n\\n        if (item.quantity != quantity) {\\n            revert Exchange_Unmatched_Quantity(item.quantity, quantity);\\n        }\\n\\n        if (msg.value != item.price) revert Exchange_Wrong_Price_Value();\\n\\n        delete fixedPriceListingsERC1155[collection][tokenId][seller];\\n\\n        ExchangeCore._executeETHPayment(\\n            collection,\\n            tokenId,\\n            seller,\\n            item.price\\n        );\\n\\n        IERC1155(collection).safeTransferFrom(\\n            seller,\\n            to,\\n            tokenId,\\n            item.quantity,\\n            \\\"\\\"\\n        );\\n\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.purchaseEvent(\\n                seller,\\n                to,\\n                item.price,\\n                collection,\\n                tokenId,\\n                quantity\\n            );\\n        }\\n\\n        emit ItemPurchasedERC1155(\\n            msg.sender,\\n            seller,\\n            collection,\\n            tokenId,\\n            quantity,\\n            item.price\\n        );\\n    }\\n\\n    function makeOfferERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint128 quantity,\\n        uint128 validityDuration,\\n        uint256 offerValue\\n    ) external nonReentrant {\\n        uint256 expiresAt = _updateOffer(\\n            collection,\\n            tokenId,\\n            quantity,\\n            validityDuration,\\n            offerValue\\n        );\\n\\n        emit OfferMadeERC1155(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            quantity,\\n            offerValue,\\n            validityDuration,\\n            expiresAt\\n        );\\n    }\\n\\n    function cancelOfferERC1155(address collection, uint256 tokenId)\\n        external\\n        nonReentrant\\n    {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        delete offersERC1155[collection][tokenId][msg.sender];\\n\\n        emit OfferCancelledERC1155(msg.sender, collection, tokenId);\\n    }\\n\\n    function updateOfferERC1155(\\n        address collection,\\n        uint256 tokenId,\\n        uint128 quantity,\\n        uint128 validityDuration,\\n        uint256 offerValue\\n    ) external nonReentrant {\\n        uint256 expiresAt = _updateOffer(\\n            collection,\\n            tokenId,\\n            quantity,\\n            validityDuration,\\n            offerValue\\n        );\\n\\n        emit OfferUpdatedERC1155(\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            quantity,\\n            offerValue,\\n            validityDuration,\\n            expiresAt\\n        );\\n    }\\n\\n    function acceptOfferERC1155(\\n        address beneficiary,\\n        address collection,\\n        uint256 tokenId,\\n        uint128 quantity,\\n        uint256 offerValue\\n    ) external nonReentrant {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n        if (beneficiary == address(0)) revert RejectedNullishAddress();\\n        if (quantity == 0) revert Exchange_Rejected_Nullish_Quantity();\\n\\n        OfferERC1155 memory offer = offersERC1155[collection][tokenId][\\n            beneficiary\\n        ];\\n\\n        delete offersERC1155[collection][tokenId][beneficiary];\\n        delete fixedPriceListingsERC1155[collection][tokenId][msg.sender];\\n\\n        if (offer.value != offerValue)\\n            revert Exchange_Wrong_Offer_Value(offer.value);\\n\\n        if (offer.expiresAt < block.timestamp)\\n            revert Exchange_Expired_Offer(offer.expiresAt);\\n\\n        if (quantity != offer.quantity)\\n            revert Exchange_Unmatched_Quantity(offer.quantity, quantity);\\n\\n        ExchangeCore._executeWETHPayment(\\n            collection,\\n            tokenId,\\n            beneficiary,\\n            msg.sender,\\n            offerValue\\n        );\\n        IERC1155(collection).safeTransferFrom(\\n            msg.sender,\\n            beneficiary,\\n            tokenId,\\n            quantity,\\n            \\\"\\\"\\n        );\\n\\n        if (address(rewardsManager) != address(0)) {\\n            rewardsManager.purchaseEvent(\\n                msg.sender,\\n                beneficiary,\\n                offer.value,\\n                collection,\\n                tokenId,\\n                quantity\\n            );\\n        }\\n\\n        emit OfferAcceptedERC1155(\\n            beneficiary,\\n            msg.sender,\\n            collection,\\n            tokenId,\\n            quantity,\\n            offerValue\\n        );\\n    }\\n\\n    function _updateOffer(\\n        address collection,\\n        uint256 tokenId,\\n        uint128 quantity,\\n        uint128 validityDuration,\\n        uint256 offerValue\\n    ) private returns (uint256 expiresAt) {\\n        if (collection == address(0)) revert RejectedNullishAddress();\\n\\n        if (validityDuration == 0) revert Exchange_Rejected_Nullish_Duration();\\n\\n        if (offerValue == 0) revert Exchange_Rejected_Nullish_Offer_Value();\\n\\n        if (quantity == 0) revert Exchange_Rejected_Nullish_Quantity();\\n\\n        uint256 wethAllowance = IWETH(WETH).allowance(\\n            msg.sender,\\n            address(this)\\n        );\\n        if (wethAllowance < offerValue)\\n            revert Exchange_Insufficient_WETH_Allowance(wethAllowance);\\n\\n        uint128 _expiresAt = uint128(block.timestamp) + validityDuration;\\n\\n        offersERC1155[collection][tokenId][msg.sender] = OfferERC1155({\\n            value: offerValue,\\n            quantity: quantity,\\n            expiresAt: _expiresAt\\n        });\\n\\n        return _expiresAt;\\n    }\\n\\n    function _listItem(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 quantity,\\n        uint256 price\\n    ) private {\\n        if (price == 0) revert Exchange_Invalid_Nullish_Price();\\n\\n        if (IERC1155(collection).balanceOf(msg.sender, tokenId) < quantity)\\n            revert Exchange_Not_The_Token_Owner();\\n\\n        if (!IERC1155(collection).isApprovedForAll(msg.sender, address(this)))\\n            revert Exchange_Insufficient_Operator_Privilege();\\n\\n        fixedPriceListingsERC1155[collection][tokenId][\\n            msg.sender\\n        ] = FixedPriceListingERC1155(quantity, price);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/interfaces/IRoyaltyFeeManager.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\ninterface IRoyaltyFeeManager {\\n    function calculateRoyaltyFeeAndGetRecipient(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external view returns (address, uint256);\\n\\n    function updateRoyaltyInfoForCollection(\\n        address collection,\\n        address setter,\\n        address receiver,\\n        uint256 fee\\n    ) external;\\n\\n    function updateRoyaltyFeeLimit(uint256 _royaltyFeeLimit) external;\\n\\n    function royaltyInfo(address collection, uint256 amount)\\n        external\\n        view\\n        returns (address, uint256);\\n\\n    function royaltyFeeInfoCollection(address collection)\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            uint256\\n        );\\n\\n    function setJumyTokenRoyalty(\\n        address collection,\\n        uint256 tokenId,\\n        address receiver,\\n        uint256 percentage\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/collections/interfaces/ICollectionRegistry.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\ninterface ICollectionRegistry {\\n    function isJumyCollection(address collection) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/interfaces/IRewards.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\ninterface IRewards {\\n    function purchaseEvent(\\n        address buyer,\\n        address seller,\\n        uint256 price,\\n        address collection,\\n        uint256 tokenId\\n    ) external;\\n\\n    function purchaseEvent(\\n        address buyer,\\n        address seller,\\n        uint256 price,\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/core/Errors.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n\\nabstract contract Errors {\\n    error RejectedNullishAddress();\\n    error RejectedAlreadyInState();\\n    error InvalidArg(string message);\\n    error BlacklistedUser();\\n\\n    error Exchange_Not_The_Token_Owner();\\n    error Exchange_UnAuthorized_Collection();\\n    error Exchange_Insufficient_Operator_Privilege();\\n    error Exchange_Invalid_Nullish_Price();\\n    error Exchange_Not_Sale_Owner();\\n    error Exchange_Wrong_Price_Value();\\n    error Exchange_Listing_Not_Found();\\n    error Exchange_Rejected_Nullish_Duration();\\n    error Exchange_Rejected_Nullish_Offer_Value();\\n    error Exchange_Insufficient_WETH_Allowance(uint256 minAllowance);\\n    error Exchange_Wrong_Offer_Value(uint256 offerValue);\\n    error Exchange_Expired_Offer(uint256 expiredAt);\\n    error Exchange_Unmatched_Quantity(uint256 expected, uint256 received);\\n    error Exchange_Rejected_Nullish_Quantity();\\n\\n    error Exchange_Rejected_Genesis_Collection_Only();\\n\\n    // Reserve Auction\\n    error Exchange_Invalid_Start_Price(uint256 expected, uint256 received);\\n    error Exchange_Rejected_Ended_Auction(uint256 endsAt, uint256 current);\\n    error Exchange_Rejected_Must_Be_5_Percent_Higher(\\n        uint256 expected,\\n        uint256 received\\n    );\\n    error Exchange_Rejected_Not_Auction_Owner();\\n    error Exchange_Rejected_Auction_In_Progress();\\n    error Exchange_Auction_Not_Found();\\n    error Exchange_Rejected_Auction_Not_Started_Yet();\\n\\n    error Exchange_Starts_At_Must_Be_In_Future();\\n    error Exchange_Starts_At_Too_Far();\\n    error Exchange_Drop_Not_Started_Yet();\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"jumyNftCollection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"royaltyManagerContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collectionRegistryContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"protocolFeesRecipientWallet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BlacklistedUser\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Auction_Not_Found\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Drop_Not_Started_Yet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expiredAt\",\"type\":\"uint256\"}],\"name\":\"Exchange_Expired_Offer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Insufficient_Operator_Privilege\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAllowance\",\"type\":\"uint256\"}],\"name\":\"Exchange_Insufficient_WETH_Allowance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Invalid_Nullish_Price\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Exchange_Invalid_Start_Price\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Listing_Not_Found\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Not_Sale_Owner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Not_The_Token_Owner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Auction_In_Progress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Auction_Not_Started_Yet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"}],\"name\":\"Exchange_Rejected_Ended_Auction\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Genesis_Collection_Only\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Exchange_Rejected_Must_Be_5_Percent_Higher\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Not_Auction_Owner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Nullish_Duration\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Nullish_Offer_Value\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Rejected_Nullish_Quantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Starts_At_Must_Be_In_Future\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Starts_At_Too_Far\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_UnAuthorized_Collection\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"Exchange_Unmatched_Quantity\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"}],\"name\":\"Exchange_Wrong_Offer_Value\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Exchange_Wrong_Price_Value\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"InvalidArg\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RejectedAlreadyInState\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RejectedNullishAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"BlackListedCollectionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"BlackListedUserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collectionRegistry\",\"type\":\"address\"}],\"name\":\"CollectionRegistryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedEthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedToSendEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ItemListed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"ItemListedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ItemPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ItemPurchasedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ItemRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ItemRemovedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ItemUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"ItemUpdatedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"OfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"OfferAcceptedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"OfferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"OfferCancelledERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"OfferMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"OfferMadeERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"OfferUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"OfferUpdatedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"PriceChangedERC1155\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeesPercentageUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ProtocolFeesRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"maxBidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startsAt\",\"type\":\"uint256\"}],\"name\":\"ReserveAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"royaltyManager\",\"type\":\"address\"}],\"name\":\"RoyaltyManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoyaltySent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ServiceFeesCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"SpecialCollectionProtocolFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"StuckERC1155Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"StuckERC721Transferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StuckEthWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"WhitelistedCustomCollectionUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"JUMY_COLLECTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"acceptOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"}],\"name\":\"acceptOfferERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"maxBidder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxBid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"endsAt\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListedCollection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"blackListedUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelOfferERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claimAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionRegistry\",\"outputs\":[{\"internalType\":\"contract ICollectionRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startsAt\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startsAt\",\"type\":\"uint256\"}],\"name\":\"createReserveAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"failedEthTransfer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fixedPriceListings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"fixedPriceListingsERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"getProtocolFeesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"isAllowedToBeListed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyPercentage\",\"type\":\"uint256\"}],\"name\":\"listItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"listItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"listItemERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"makeOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"validityDuration\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"}],\"name\":\"makeOfferERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"offers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"offersERC1155\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"expiresAt\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeesRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"purchaseItem\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"purchaseItemERC1155\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"removeItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"removeItemERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsManager\",\"outputs\":[{\"internalType\":\"contract IRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyManager\",\"outputs\":[{\"internalType\":\"contract IRoyaltyFeeManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"specialProtocolFeesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferStuckERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferStuckERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"updateBlackListedCollection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"updateBlacklistedUser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCollectionRegistry\",\"type\":\"address\"}],\"name\":\"updateCollectionRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateItem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"updateListItemERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validityDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"updateOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"quantity\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"validityDuration\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"offerValue\",\"type\":\"uint256\"}],\"name\":\"updateOfferERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPercentage\",\"type\":\"uint256\"}],\"name\":\"updateProtocolFeesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"updateProtocolFeesRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardsManager\",\"type\":\"address\"}],\"name\":\"updateRewardsManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRoyaltyManager\",\"type\":\"address\"}],\"name\":\"updateRoyaltyManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"updateSpecialProtocolFeesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"updateWhitelistedCustomCollection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedCustomCollection\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawStuckETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdrawStuckETHFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "JumyExchange", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000f9650764f0e4a74964f1b80700807da4e1f3e172000000000000000000000000a56ca6d5d17ca66b3d764b1050881339df7ccdb4000000000000000000000000dbb927c79aa020fe983f27fcd3bde6dbcac5465b000000000000000000000000022a20f6f759288dc65a62be09d2ee2210ae7a92", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}