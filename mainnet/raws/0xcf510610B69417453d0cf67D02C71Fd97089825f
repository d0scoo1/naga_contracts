{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: GPL v3\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface BDERC721 {\r\n\tfunction balanceOf(address wallet) external view returns(uint256);\r\n\tfunction ownerOf(uint256 tokenID) external view returns(address);\r\n\tfunction getApproved(uint256 tokenId) external view returns (address operator);\r\n\tfunction safeTransferFrom(address from,address to,uint256 tokenId) external;\r\n}\r\n\r\ninterface BDERC20 {\r\n\tfunction balanceOf(address wallet) external view returns(uint256);\r\n\tfunction allowance(address owner, address spender) external view returns(uint256);\r\n\tfunction transferFrom(address owner, address spender, uint256 amount) external returns(bool);\r\n\tfunction transfer(address reciever, uint256 amount) external returns(bool);\r\n\tfunction burnFrom(address owner, uint256 amount) external returns(bool);\r\n}\r\n\r\ncontract BasementStaking is Ownable {\r\n\r\n\tstruct NFTStaking {\r\n\t\t// check if the NFT contract address is supported\r\n\t\tbool supported;\r\n\t\t// the cost of the next level\r\n\t\tuint256 advanceCost;\r\n\t\t// the reward of the next level\r\n\t\tuint256 tsReward;\r\n\t\t// maximum staking amount\r\n\t\tuint256 maxStakingS;\r\n\t\t// min staking time before reward\r\n\t\tuint256 tsForReward;\r\n\t\t// the addresses of all the stakers for this NFT contract\r\n\t\taddress[] stakers;\r\n\t}\r\n\r\n\tmapping(address => NFTStaking) supportedNFTs;\r\n\r\n\taddress public EXP;\r\n\tuint256 private baseCost = 1 ether;\r\n\t\r\n\r\n\tstruct Stakes {\r\n\t\taddress nftOwner;\r\n\t\tuint256 lockTS;\r\n\t\tuint256 lockAccumlation;\r\n\t\tuint256 tokenLevel;\r\n\t\tbool isStaked;\r\n\t}\r\n\r\n    function onERC721Received(address , address , uint256 , bytes calldata ) public pure returns(bytes4){\r\n        return(IERC721Receiver.onERC721Received.selector);\r\n    }\r\n\r\n\tconstructor(address experience){\r\n\t\tEXP = experience;\r\n\t}\r\n\r\n\t// nft contract => tokenids\r\n\tmapping(address => mapping(uint256 => Stakes)) NFTstakes;\r\n\t// nft contract => wallet => nfts\r\n\tmapping(address => mapping(address => uint256[])) walletNFTs;\r\n\r\n\tevent NFTUpgraded(address indexed NFTcontract, address indexed NFTOwner, uint256 tokenID, uint256 oldLevel, uint256 newLevel);\r\n\r\n\t/**\r\n\t\tnftContract => contract of the nft \r\n\t\t_advCost => cost to level up\r\n\t\t_reward => amount of $EXP to return after X amount of time\r\n\t\t_maxStakeTime => maximum amount to stake in seconds\r\n\t\t_timeToReward => X amount of time before a staked NFT can get the _reward\r\n\t*/\r\n\tfunction changeStakingProps(address nftContract, uint256 _advCost, uint256 _reward, uint256 _maxStakeTime, uint256 _timeToReward) external onlyOwner {\r\n\t\tsupportedNFTs[nftContract].supported = true;\r\n\t\tsupportedNFTs[nftContract].advanceCost = _advCost;\r\n\t\tsupportedNFTs[nftContract].tsReward = _reward;\r\n\t\tsupportedNFTs[nftContract].maxStakingS = _maxStakeTime;\r\n\t\tsupportedNFTs[nftContract].tsForReward = _timeToReward;\r\n\t}\r\n\r\n\tfunction UnsupportNFT(address nftContract) external onlyOwner {\r\n\t\tsupportedNFTs[nftContract].supported = false;\r\n\t}\r\n\r\n\tfunction recieve20Payment(address wallet, uint256 amount) internal returns(bool){\r\n\t\tif(amount == 0){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tamount = amount*baseCost;\r\n\t\trequire(BDERC20(EXP).allowance(wallet, address(this)) >= amount, \"DwellersStaking: Need to approve EXP\");\r\n\t\trequire(BDERC20(EXP).transferFrom(wallet, address(this), amount), \"DwellersStaking: Need to transfer EXP\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction burn20Payment(address wallet, uint256 amount) internal returns(bool){\r\n\t\tif(amount == 0){\r\n\t\t\treturn true;\r\n\t\t}\t\t\r\n\t\tamount = amount*baseCost;\r\n\t\trequire(BDERC20(EXP).allowance(wallet, address(this)) >= amount, \"DwellersStaking: Need to approve EXP\");\r\n\t\trequire(BDERC20(EXP).burnFrom(wallet, amount), \"DwellersStaking: Need to BURN EXP\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction send20Payment(address wallet, uint256 amount) internal returns(bool){\r\n\t\tif(amount == 0){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tamount = amount*baseCost;\r\n\t\trequire(BDERC20(EXP).balanceOf(address(this)) >= amount, \"DwellersStaking: Not enough funds\");\r\n\t\trequire(BDERC20(EXP).transfer(wallet, amount), \"DwellersStaking: Cannot transfer funds\");\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction recieve721Token(address nftContract, address wallet, uint256 tokenID) internal returns(bool) {\r\n\t\trequire(BDERC721(nftContract).ownerOf(tokenID) == wallet, \"DwellersStaking: Must be the owner of the NFT to stake\");\r\n\t\trequire(BDERC721(nftContract).getApproved(tokenID) == address(this), \"DwellersStaking: Must approve BasementStaking to stake\");\r\n\t\tBDERC721(nftContract).safeTransferFrom(wallet, address(this), tokenID);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction send721Token(address nftContract, address wallet, uint256 tokenID) internal returns(bool) {\r\n\t\trequire(BDERC721(nftContract).ownerOf(tokenID) == address(this), \"DwellersStaking: does NOT own this NFT\");\r\n\t\tBDERC721(nftContract).safeTransferFrom(address(this), wallet, tokenID);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction rev721(address nftContract) external onlyOwner{\r\n\t\taddress[] memory allStakers = supportedNFTs[nftContract].stakers;\r\n\t\tfor(uint256 i=0; i<allStakers.length; i++){\r\n\t\t\tuint256[] memory _allWalletNFTs = walletNFTs[nftContract][allStakers[i]];\r\n\t\t\tfor(uint256 j=0; j<_allWalletNFTs.length; j++){\r\n\t\t\t\tsend721Token(nftContract, allStakers[i], _allWalletNFTs[j]);\r\n\t\t\t} \r\n\t\t}\r\n\t}\r\n\r\n\tfunction isNFTcontractSupported(address nftContract) public view returns(bool){\r\n\r\n\t\treturn(supportedNFTs[nftContract].supported);\r\n\t}\r\n\r\n\tfunction getAllNFTsStaked(address nftContract, address wallet) public view returns(uint256[] memory allNFTs){\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\treturn(walletNFTs[nftContract][wallet]);\r\n\t}\r\n\r\n\tfunction getNFTowner(address nftContract, uint256 tokenID) public view returns(address){\r\n\t\tif(NFTstakes[nftContract][tokenID].nftOwner == address(0)){\r\n\t\t\taddress _owner = BDERC721(nftContract).ownerOf(tokenID);\r\n\t\t\trequire(_owner != address(0),\"This NFT has not been minted yet\");\r\n\t\t\treturn _owner;\r\n\t\t}\r\n\t\treturn(NFTstakes[nftContract][tokenID].nftOwner);\r\n\t}\r\n\r\n\tfunction getNFTLevel(address nftContract, uint256 tokenID) public view returns(uint256){\r\n\r\n\t\treturn(NFTstakes[nftContract][tokenID].tokenLevel);\r\n\t}\r\n\r\n\tfunction calcUpgradeLevels(uint256 amount, uint256 perlevelCost) public pure returns(uint256){\r\n\t\treturn((amount/perlevelCost));\r\n\t}\r\n\r\n\tfunction upgradeDweller(address nftContract, uint256 tokenID, uint256 expAmount) external {\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\tuint256 levelsCount = calcUpgradeLevels(expAmount, supportedNFTs[nftContract].advanceCost);\r\n\t\trequire(levelsCount != 0, \"Cannot upgrade 0 levels, increase EXP\");\r\n\t\trequire(burn20Payment(msg.sender, expAmount), \"DwellersStaking: Need to spend EXP to upgrade\");\r\n\t\trequire(getNFTowner(nftContract, tokenID) == msg.sender, \"DwellersStaking: only the owner of the NFT can upgrade\");\r\n\t\tuint256 currentLevel = getNFTLevel(nftContract, tokenID);\r\n\t\tNFTstakes[nftContract][tokenID].tokenLevel += levelsCount;\r\n\t\temit NFTUpgraded(nftContract, msg.sender, tokenID, currentLevel, (currentLevel+levelsCount));\r\n\t}\r\n\r\n\tfunction getAllNFTStakers(address nftContract) public view returns(address[] memory){\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\treturn(supportedNFTs[nftContract].stakers);\r\n\t}\r\n\r\n\tfunction removeFromNFTStakers(address nftContract, address wallet) internal {\r\n\t\taddress[] storage _stakers = supportedNFTs[nftContract].stakers;\r\n\t\tuint256 index =0;\r\n\t\tfor(uint256 i=0; i<_stakers.length; i++){\r\n\t\t\tif(_stakers[i] == wallet){\r\n\t\t\t\tindex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(index == _stakers.length-1){\r\n\t\t\t_stakers.pop();\r\n\t\t}else{\r\n\t\t\tfor(uint256 i=index; i<_stakers.length-1; i++){\r\n\t\t\t\t_stakers[i] = _stakers[i+1];\r\n\t\t\t}\r\n\t\t\t_stakers.pop();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction removeFromWalletNFTs(address nftContract, address wallet, uint256 tokenID) internal {\r\n\t\tuint256[] storage _wNFTs = walletNFTs[nftContract][wallet];\r\n\t\tuint256 index = 0;\r\n\t\tfor(uint256 i=0; i<_wNFTs.length; i++){\r\n\t\t\tif(_wNFTs[i] == tokenID){\r\n\t\t\t\tindex = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfor(uint256 i=index; i<_wNFTs.length-1; i++){\r\n\t\t\t_wNFTs[i] = _wNFTs[i+1];\r\n\t\t}\r\n\t\t_wNFTs.pop();\r\n\t}\r\n\r\n\tfunction _safeRemoveStake(address nftContract, address wallet, uint256 tokenID) internal {\r\n\t\tremoveFromWalletNFTs(nftContract, wallet, tokenID);\r\n\t\tremoveFromNFTStakers(nftContract, wallet);\r\n\t\tStakes storage _stake = NFTstakes[nftContract][tokenID];\r\n\t\t_stake.isStaked = false;\r\n\t\t_stake.nftOwner = address(0);\r\n\t\t_stake.lockTS = uint256(0);\r\n\t}\r\n\r\n\tfunction _safeAddStake(address nftContract, address wallet, uint256 tokenID) internal {\r\n\t\tStakes storage _stake = NFTstakes[nftContract][tokenID];\r\n\t\trequire(_stake.lockAccumlation <= supportedNFTs[nftContract].maxStakingS, \"DwellersStaking: Cannot stake more than 2 years\");\r\n\t\t_stake.isStaked = true;\r\n\t\t_stake.nftOwner = wallet;\r\n\t\t_stake.lockTS = block.timestamp;\r\n\t\twalletNFTs[nftContract][wallet].push(tokenID);\r\n\t\tsupportedNFTs[nftContract].stakers.push(wallet);\r\n\t}\r\n\r\n\tfunction getUnstakingFee(address nftContract, uint256 tokenID) external view returns(uint256){\r\n\t\tStakes memory _stake = NFTstakes[nftContract][tokenID];\r\n\t\tNFTStaking memory stakingProps = supportedNFTs[nftContract];\r\n\t\tuint256 unstakeFee = calcUnstakingFee(_stake.lockAccumlation, stakingProps.tsForReward, stakingProps.tsReward);\r\n\t\treturn(unstakeFee);\r\n\t}\r\n\r\n\r\n\tfunction unstakeDweller(address nftContract, uint256 tokenID) external {\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\tStakes memory _stake = NFTstakes[nftContract][tokenID];\r\n\t\trequire(_stake.nftOwner == msg.sender, \"DwellersStaking: cannot unstake an NFT that does not belong to the sender\");\r\n\t\tNFTStaking memory stakingProps = supportedNFTs[nftContract];\r\n\t\tif(_stake.lockAccumlation < stakingProps.maxStakingS){\r\n\t\t\trequire(burn20Payment(msg.sender, calcUnstakingFee(_stake.lockAccumlation, stakingProps.tsForReward, stakingProps.tsReward)), \"DwellersStaking: need to pay 33% of accumlated tokens to unstake early\");\r\n\t\t}\r\n        require(send721Token(nftContract, msg.sender, tokenID),\"Unable to send the NFT back\");\r\n\t\t_safeRemoveStake(nftContract, msg.sender, tokenID);\r\n\t}\r\n\r\n\tfunction stakeDweller(address nftContract, uint256 tokenID) external {\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\trequire(recieve721Token(nftContract, msg.sender, tokenID), \"DwellersStaking: Unable to stake this NFT\");\r\n\t\t_safeAddStake(nftContract, msg.sender, tokenID);\r\n\t}\r\n\r\n\tfunction calcReward(uint256 lockTs, uint256 ts, uint256 rewardTime, uint256 rewardAmount) public pure returns(uint256 reward, uint256 accumlation){\r\n\t\tuint256 deltaT = (ts - lockTs);\r\n\t\treward = ((deltaT/rewardTime)*rewardAmount);\r\n\t\taccumlation = ((deltaT/rewardTime)*rewardTime);\r\n\t}\r\n\r\n\tfunction calcUnstakingFee(uint256 accumlation, uint256 rewardTime, uint256 rewardAmount) public pure returns(uint256 unstakingFee){\r\n\r\n\t\treturn((accumlation*rewardAmount*33)/(rewardTime*100));\r\n\t}\r\n\r\n\tfunction avalToClaim(address nftContract, address wallet) public view returns(uint256 rewardable){\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\tuint256[] memory _wallet = getAllNFTsStaked(nftContract, wallet);\r\n\t\tif(_wallet.length == 0){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 ts = block.timestamp;\r\n\t\tNFTStaking memory stakingProps = supportedNFTs[nftContract];\r\n\t\tfor(uint256 i=0; i<_wallet.length; i++){\r\n\t\t\tif((NFTstakes[nftContract][_wallet[i]].lockTS + stakingProps.tsForReward <= ts) && (NFTstakes[nftContract][_wallet[i]].lockAccumlation < stakingProps.maxStakingS)){\r\n\t\t\t\tStakes memory _stake = NFTstakes[nftContract][_wallet[i]];\r\n\t\t\t\t(uint256 _rwrd,) = calcReward(_stake.lockTS, ts, stakingProps.tsForReward, stakingProps.tsReward);\r\n\t\t\t\trewardable += _rwrd;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getStakes(address nftContract, uint256 tokenID) public view returns(Stakes memory){\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\treturn(NFTstakes[nftContract][tokenID]);\r\n\t}\r\n\r\n\tfunction ClaimStakingRewards(address nftContract) external {\r\n\t\trequire(isNFTcontractSupported(nftContract), \"DwellersStaking: This NFT contract is not supported\");\r\n\t\tuint256[] memory _wallet = getAllNFTsStaked(nftContract, msg.sender);\r\n\t\trequire(_wallet.length > 0, \"DwellersStaking: You do not have any staked NFTs\");\r\n\t\tuint256 rewardable = 0;\r\n\t\tuint256 ts = block.timestamp;\r\n\t\tNFTStaking memory stakingProps = supportedNFTs[nftContract];\r\n\t\tfor(uint256 i=0; i<_wallet.length; i++){\r\n\t\t\tif((NFTstakes[nftContract][_wallet[i]].lockTS + stakingProps.tsForReward <= ts) && (NFTstakes[nftContract][_wallet[i]].lockAccumlation < stakingProps.maxStakingS)){\r\n\t\t\t\tStakes storage _stake = NFTstakes[nftContract][_wallet[i]];\r\n\t\t\t\t(uint256 _rwrd, uint256 _rAcc) = calcReward(_stake.lockTS, ts ,stakingProps.tsForReward, stakingProps.tsReward);\r\n\t\t\t\trewardable += _rwrd;\r\n\t\t\t\t_stake.lockTS = ts;\r\n\t\t\t\t_stake.lockAccumlation += _rAcc;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(send20Payment(msg.sender, rewardable), \"DwellersStaking: Unable to reward staking\");\r\n\t}\r\n\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"experience\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"NFTcontract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"NFTOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLevel\",\"type\":\"uint256\"}],\"name\":\"NFTUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"ClaimStakingRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EXP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"UnsupportNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"avalToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lockTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"calcReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accumlation\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"accumlation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"calcUnstakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unstakingFee\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perlevelCost\",\"type\":\"uint256\"}],\"name\":\"calcUpgradeLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_advCost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxStakeTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timeToReward\",\"type\":\"uint256\"}],\"name\":\"changeStakingProps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"getAllNFTStakers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getAllNFTsStaked\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"allNFTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getNFTLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getNFTowner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"lockTS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lockAccumlation\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenLevel\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"}],\"internalType\":\"struct BasementStaking.Stakes\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getUnstakingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"isNFTcontractSupported\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"}],\"name\":\"rev721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"stakeDweller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"unstakeDweller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expAmount\",\"type\":\"uint256\"}],\"name\":\"upgradeDweller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BasementStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000044cd5df997ad83a51c8d0a93ef886f307faba8e", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://97c24518467882fc7be3ad70a4cf8e3a458548f542ef29b71030d21ecb24e8f0"}]}