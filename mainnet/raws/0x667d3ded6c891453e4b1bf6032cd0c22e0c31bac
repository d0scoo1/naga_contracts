{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/OrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './SellOrder.sol';\\nimport './interfaces/IOrderBook.sol';\\n\\n/// @dev A factory for creating orders. The Graph should index this contract.\\ncontract OrderBook is IOrderBook {\\n    /// @dev all the sell orders available in the order book\\n    mapping(address => bool) public sellOrders;\\n\\n    /// @dev the fee rate in parts per million\\n    uint256 public fee = 10000; // 1%\\n\\n    /// @dev the authority over this order book, ie the DAO\\n    address private _owner;\\n\\n    /// @dev Throws if msg.sender is not the owner.\\n    error NotOwner();\\n\\n    /// @dev initializes a new order book\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        if (owner() != msg.sender) {\\n            revert NotOwner();\\n        }\\n        _;\\n    }\\n\\n    /// @dev changes the fee rate\\n    function setFee(uint256 _fee) external onlyOwner {\\n        emit FeeChanged(fee, _fee);\\n        fee = _fee;\\n    }\\n\\n    /// @dev changes the owner of this order book\\n    function setOwner(address _newOwner) external onlyOwner {\\n        emit OwnerChanged(owner(), _newOwner);\\n        _owner = _newOwner;\\n    }\\n\\n    /// @dev Creates a new sell order that can be easily indexed by something like theGraph.\\n    function createSellOrder(\\n        address seller,\\n        IERC20 token,\\n        uint256 stake,\\n        string memory uri,\\n        uint256 timeout\\n    ) external returns (SellOrder) {\\n        SellOrder sellOrder = new SellOrder(seller, token, stake, uri, timeout);\\n        emit SellOrderCreated(address(sellOrder));\\n        sellOrders[address(sellOrder)] = true;\\n        return sellOrder;\\n    }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/SellOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport './interfaces/IOrderBook.sol';\\n\\ncontract SellOrder {\\n    /// @dev msg.sender is not the seller\\n    error MustBeSeller();\\n\\n    /// @dev A function is run at the wrong time in the lifecycle\\n    error InvalidState(State expected, State received);\\n\\n    /// @dev Emitted when `buyer` submits and offer.\\n    event OfferSubmitted(\\n        address indexed buyer,\\n        uint256 indexed price,\\n        uint256 indexed stake,\\n        string uri\\n    );\\n\\n    /// @dev Emitted when `buyer` withdrew and offer.\\n    event OfferWithdrawn(address indexed buyer);\\n\\n    /// @dev Emitted when `buyer`'s offer was commited too.\\n    event OfferCommitted(address indexed buyer);\\n\\n    /// @dev Emitted when `buyer` withdrew and offer.\\n    event OfferConfirmed(address indexed buyer);\\n\\n    /// @dev Emitted when `buyer` withdrew and offer.\\n    event OfferEnforced(address indexed buyer);\\n\\n    /// @dev The token used for payment & staking, such as wETH, DAI, or USDC.\\n    IERC20 public token;\\n\\n    /// @dev The seller\\n    address public seller;\\n\\n    /// @dev the maximum delivery time before the order can said to have failed.\\n    uint256 public timeout;\\n\\n    /// @dev the amount the seller is offering to stake per order.\\n    uint256 public orderStake;\\n\\n    /// @dev order book\\n    address public orderBook;\\n\\n    /// @dev the URI where metadata about this SellOrder can be found\\n    string private _uri;\\n\\n    /// @dev The state of an offer\\n    enum State {\\n        Closed,\\n        Open,\\n        Committed\\n    }\\n\\n    struct Offer {\\n        /// @dev the amount the buyer is willing to pay\\n        uint256 price;\\n        /// @dev the amount the buyer is willing to stake\\n        uint256 stake;\\n        /// @dev the uri of metadata that can contain shipping information (typically encrypted)\\n        string uri;\\n        /// @dev the state of the offer\\n        State state;\\n        /// @dev the block.timestamp in which acceptOffer() was called. 0 otherwise\\n        uint256 acceptedAt;\\n    }\\n\\n    /// @dev A mapping of potential offers to the amount of tokens they are willing to stake\\n    mapping(address => Offer) public offers;\\n\\n    /// @dev The denominator of parts per million\\n    uint256 constant ONE_MILLION = 1000000;\\n\\n    /// @dev Creates a new sell order.\\n    constructor(\\n        address seller_,\\n        IERC20 token_,\\n        uint256 orderStake_,\\n        string memory uri_,\\n        uint256 timeout_\\n    ) {\\n        orderBook = msg.sender;\\n        seller = seller_;\\n        token = token_;\\n        orderStake = orderStake_;\\n        _uri = uri_;\\n        timeout = timeout_;\\n    }\\n\\n    /// @dev returns the URI of the sell order, containing it's metadata\\n    function orderURI() external view virtual returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /// @dev sets the URI of the sell order, containing it's metadata\\n    function setURI(string memory uri_) external virtual onlySeller {\\n        _uri = uri_;\\n    }\\n\\n    /// @dev reverts if the function is not at the expected state\\n    modifier onlyState(address buyer_, State expected) {\\n        if (offers[buyer_].state != expected) {\\n            revert InvalidState(expected, offers[buyer_].state);\\n        }\\n\\n        _;\\n    }\\n\\n    /// @dev reverts if msg.sender is not the seller\\n    modifier onlySeller() {\\n        if (msg.sender != seller) {\\n            revert MustBeSeller();\\n        }\\n\\n        _;\\n    }\\n\\n    /// @dev creates an offer\\n    function submitOffer(\\n        uint256 price,\\n        uint256 stake,\\n        string memory uri\\n    ) external virtual onlyState(msg.sender, State.Closed) {\\n        uint256 allowance = token.allowance(msg.sender, address(this));\\n        require(allowance >= stake + price, 'Insufficient allowance');\\n\\n        offers[msg.sender] = Offer(price, stake, uri, State.Open, 0);\\n\\n        bool result = token.transferFrom(\\n            msg.sender,\\n            address(this),\\n            stake + price\\n        );\\n        require(result, 'Transfer failed');\\n\\n        emit OfferSubmitted(msg.sender, price, stake, uri);\\n    }\\n\\n    /// @dev allows a buyer to withdraw the offer\\n    function withdrawOffer()\\n        external\\n        virtual\\n        onlyState(msg.sender, State.Open)\\n    {\\n        Offer memory offer = offers[msg.sender];\\n\\n        bool result = token.transfer(msg.sender, offer.stake + offer.price);\\n        assert(result);\\n\\n        offers[msg.sender] = Offer(0, 0, offer.uri, State.Closed, 0);\\n\\n        emit OfferWithdrawn(msg.sender);\\n    }\\n\\n    /// @dev Commits a seller to an offer\\n    function commit(address buyer_)\\n        external\\n        virtual\\n        onlyState(buyer_, State.Open)\\n        onlySeller\\n    {\\n        // Deposit the stake required to commit to the offer\\n        uint256 allowance = token.allowance(msg.sender, address(this));\\n        require(allowance >= orderStake);\\n        bool result = token.transferFrom(msg.sender, address(this), orderStake);\\n        assert(result);\\n\\n        // Update the status of the buyer's offer\\n        Offer memory offer = offers[buyer_];\\n        offers[buyer_] = Offer(\\n            offer.price,\\n            offer.stake,\\n            offer.uri,\\n            State.Committed,\\n            block.timestamp\\n        );\\n\\n        emit OfferCommitted(buyer_);\\n    }\\n\\n    /// @dev Marks the order as sucessfully completed, and transfers the tokens.\\n    function confirm() external virtual onlyState(msg.sender, State.Committed) {\\n        // Close the offer\\n        Offer memory offer = offers[msg.sender];\\n        offers[msg.sender] = Offer(\\n            0,\\n            0,\\n            offer.uri,\\n            State.Closed,\\n            block.timestamp\\n        );\\n\\n        // Return the stake to the buyer\\n        bool result0 = token.transfer(msg.sender, offer.stake);\\n        assert(result0);\\n\\n        // Return the stake to the seller\\n        bool result1 = token.transfer(seller, orderStake);\\n        assert(result1);\\n\\n        uint256 toOrderBook = (offer.price * IOrderBook(orderBook).fee()) /\\n            ONE_MILLION;\\n        uint256 toSeller = offer.price - toOrderBook;\\n\\n        // Transfer payment to the seller\\n        bool result2 = token.transfer(seller, toSeller);\\n        assert(result2);\\n\\n        // Transfer payment to the order book\\n        bool result3 = token.transfer(\\n            IOrderBook(orderBook).owner(),\\n            toOrderBook\\n        );\\n        assert(result3);\\n\\n        emit OfferConfirmed(msg.sender);\\n    }\\n\\n    /// @dev Allows anyone to enforce an offer.\\n    function enforce(address buyer_)\\n        external\\n        virtual\\n        onlyState(buyer_, State.Committed)\\n    {\\n        Offer memory offer = offers[buyer_];\\n        require(block.timestamp > timeout + offer.acceptedAt);\\n\\n        // Close the offer\\n        offers[buyer_] = Offer(0, 0, offer.uri, State.Closed, block.timestamp);\\n\\n        // Transfer the payment to the seller\\n        bool result0 = token.transfer(seller, offer.price);\\n        assert(result0);\\n\\n        // Transfer the buyer's stake to address(dead).\\n        bool result1 = token.transfer(\\n            address(0x000000000000000000000000000000000000dEaD),\\n            offer.stake\\n        );\\n        assert(result1);\\n\\n        // Transfer the seller's stake to address(dead).\\n        bool result2 = token.transfer(\\n            address(0x000000000000000000000000000000000000dEaD),\\n            orderStake\\n        );\\n        assert(result2);\\n\\n        emit OfferEnforced(buyer_);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '../SellOrder.sol';\\n\\ninterface IOrderBook {\\n    event SellOrderCreated(address indexed sellOrder);\\n\\n    event OwnerChanged(address previous, address next);\\n\\n    event FeeChanged(uint256 previous, uint256 next);\\n\\n    function owner() external view returns (address);\\n\\n    function fee() external view returns (uint256);\\n\\n    function setFee(uint256 _fee) external;\\n\\n    function setOwner(address _newOwner) external;\\n\\n    function createSellOrder(\\n        address seller,\\n        IERC20 token,\\n        uint256 stake,\\n        string memory uri,\\n        uint256 timeout\\n    ) external returns (SellOrder);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previous\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"next\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"next\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellOrder\",\"type\":\"address\"}],\"name\":\"SellOrderCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"createSellOrder\",\"outputs\":[{\"internalType\":\"contract SellOrder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sellOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrderBook", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}