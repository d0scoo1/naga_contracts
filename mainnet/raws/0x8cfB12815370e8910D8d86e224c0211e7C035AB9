{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/UnstructuredProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./Proxy.sol\\\";\\n\\ncontract UnstructuredProxy is Proxy {\\n\\n    // Storage position of the address of the current implementation\\n    bytes32 private constant implementationPosition =\\n    keccak256(\\\"org.smartdefi.implementation.address\\\");\\n\\n    // Storage position of the owner of the contract\\n    bytes32 private constant proxyOwnerPosition =\\n    keccak256(\\\"org.smartdefi.proxy.owner\\\");\\n\\n    /**\\n    * @dev Throws if called by any account other than the owner.\\n    */\\n    modifier onlyProxyOwner() {\\n        require (msg.sender == proxyOwner(), \\\"Not Proxy owner\\\");\\n        _;\\n    }\\n\\n    /**\\n    * @dev the constructor sets owner\\n    */\\n    constructor() {\\n        _setUpgradeabilityOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer ownership\\n     * @param _newOwner The address to transfer ownership to\\n     */\\n    function transferProxyOwnership(address _newOwner)\\n    public onlyProxyOwner\\n    {\\n        require(_newOwner != address(0));\\n        _setUpgradeabilityOwner(_newOwner);\\n    }\\n\\n    /**\\n     * @dev Allows the proxy owner to upgrade the implementation\\n     * @param _impl address of the new implementation\\n     */\\n    function upgradeTo(address _impl)\\n    public onlyProxyOwner\\n    {\\n        _upgradeTo(_impl);\\n    }\\n\\n    /**\\n     * @dev Tells the address of the current implementation\\n     * @return impl address of the current implementation\\n     */\\n    function _implementation()\\n    internal\\n    view\\n    override\\n    returns (address impl)\\n    {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            impl := sload(position)\\n        }\\n    }\\n\\n    function implementation() external view returns (address) {\\n        return _implementation();\\n    }\\n\\n    /**\\n     * @dev Tells the address of the owner\\n     * @return owner the address of the owner\\n     */\\n    function proxyOwner() public view returns (address owner) {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            owner := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the address of the current implementation\\n     * @param _newImplementation address of the new implementation\\n     */\\n    function _setImplementation(address _newImplementation)\\n    internal\\n    {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /**\\n     * @dev Upgrades the implementation address\\n     * @param _newImplementation address of the new implementation\\n     */\\n    function _upgradeTo(address _newImplementation) internal {\\n        address currentImplementation = _implementation();\\n        require(currentImplementation != _newImplementation);\\n        _setImplementation(_newImplementation);\\n    }\\n\\n    /**\\n     * @dev Sets the address of the owner\\n     */\\n    function _setUpgradeabilityOwner(address _newProxyOwner)\\n    internal\\n    {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            sstore(position, _newProxyOwner)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n        // Copy msg.data. We take full control of memory in this inline assembly\\n        // block because it will not return to Solidity code. We overwrite the\\n        // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n        // Call the implementation.\\n        // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n        // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_impl\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UnstructuredProxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x68be2a348b8c35a1235e374ee179d079b40ad030", "SwarmSource": ""}]}