{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2021-09-21\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n// File: Interfaces/IKashiPair.sol\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\npragma solidity 0.7.1;\r\n\r\n\r\ninterface IKashiPair {\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event LogAccrue(uint256 accruedAmount, uint256 feeFraction, uint64 rate, uint256 utilization);\r\n    event LogAddAsset(address indexed from, address indexed to, uint256 share, uint256 fraction);\r\n    event LogAddCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogBorrow(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogExchangeRate(uint256 rate);\r\n    event LogFeeTo(address indexed newFeeTo);\r\n    event LogRemoveAsset(address indexed from, address indexed to, uint256 share, uint256 fraction);\r\n    event LogRemoveCollateral(address indexed from, address indexed to, uint256 share);\r\n    event LogRepay(address indexed from, address indexed to, uint256 amount, uint256 part);\r\n    event LogWithdrawFees(address indexed feeTo, uint256 feesEarnedFraction);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    \r\n    struct AccrueInfo {\r\n        uint64 interestPerSecond;\r\n        uint64 lastAccrued;\r\n        uint128 feesEarnedFraction;\r\n    }\r\n\r\n    function accrueInfo() external view returns(AccrueInfo memory);\r\n\r\n    function addAsset(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) external returns (uint256 fraction);\r\n\r\n    function addCollateral(\r\n        address to,\r\n        bool skim,\r\n        uint256 share\r\n    ) external;\r\n    \r\n    function accrue() external;\r\n\r\n    function allowance(address, address) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function asset() external view returns (IERC20);\r\n\r\n    function balanceOf(address) external view returns (uint256);\r\n\r\n    function borrow(address to, uint256 amount) external returns (uint256 part, uint256 share);\r\n\r\n    function claimOwnership() external;\r\n\r\n    function collateral() external view returns (IERC20);\r\n\r\n    function cook(\r\n        uint8[] calldata actions,\r\n        uint256[] calldata values,\r\n        bytes[] calldata datas\r\n    ) external payable returns (uint256 value1, uint256 value2);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function exchangeRate() external view returns (uint256);\r\n\r\n    function feeTo() external view returns (address);\r\n\r\n    function init(bytes calldata data) external payable;\r\n\r\n    function isSolvent(address user, bool open) external view returns (bool);\r\n\r\n    function masterContract() external view returns (address);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function nonces(address) external view returns (uint256);\r\n\r\n    function oracleData() external view returns (bytes memory);\r\n\r\n    function owner() external view returns (address);\r\n\r\n    function pendingOwner() external view returns (address);\r\n\r\n    function permit(\r\n        address owner_,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    function removeAsset(address to, uint256 fraction) external returns (uint256 share);\r\n\r\n    function removeCollateral(address to, uint256 share) external;\r\n\r\n    function repay(\r\n        address to,\r\n        bool skim,\r\n        uint256 part\r\n    ) external returns (uint256 amount);\r\n\r\n    function setFeeTo(address newFeeTo) external;\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function totalAsset() external view returns (uint128 elastic, uint128 base);\r\n\r\n    function totalBorrow() external view returns (uint128 elastic, uint128 base);\r\n\r\n    function totalCollateralShare() external view returns (uint256);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) external;\r\n\r\n    function updateExchangeRate() external returns (bool updated, uint256 rate);\r\n\r\n    function userBorrowPart(address) external view returns (uint256);\r\n\r\n    function userCollateralShare(address) external view returns (uint256);\r\n\r\n    function withdrawFees() external;\r\n}\r\n// File: Interfaces/ICallFacet.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\ninterface ICallFacet {\r\n\r\n    event CallerAdded(address indexed caller);\r\n    event CallerRemoved(address indexed caller);\r\n    event Call(address indexed caller, address indexed target, bytes data, uint256 value);\r\n\r\n    /**\r\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool. Reverts if one of the calls fails\r\n        @param _targets Array of addresses of targets to call\r\n        @param _calldata Array of calldata for each call\r\n        @param _values Array of amounts of ETH to send with the call\r\n    */\r\n    function call(\r\n        address[] memory _targets,\r\n        bytes[] memory _calldata,\r\n        uint256[] memory _values\r\n    ) external;\r\n\r\n    /**\r\n        @notice Lets whitelisted callers execute a batch of arbitrary calls from the pool without sending any Ether. Reverts if one of the calls fail\r\n        @param _targets Array of addresses of targets to call\r\n        @param _calldata Array of calldata for each call\r\n    */\r\n    function callNoValue(\r\n        address[] memory _targets,\r\n        bytes[] memory _calldata\r\n    ) external;\r\n\r\n    /**\r\n        @notice Lets whitelisted callers execute a single arbitrary call from the pool. Reverts if the call fails\r\n        @param _target Address of the target to call\r\n        @param _calldata Calldata of the call\r\n        @param _value Amount of ETH to send with the call\r\n    */\r\n    function singleCall(\r\n        address _target,\r\n        bytes calldata _calldata,\r\n        uint256 _value\r\n    ) external;\r\n\r\n    /**\r\n        @notice Add a whitelisted caller. Can only be called by the contract owner\r\n        @param _caller Caller to add\r\n    */\r\n    function addCaller(address _caller) external;\r\n\r\n    /**\r\n        @notice Remove a whitelisted caller. Can only be called by the contract owner\r\n    */\r\n    function removeCaller(address _caller) external;\r\n\r\n    /**\r\n        @notice Checks if an address is a whitelisted caller\r\n        @param _caller Address to check\r\n        @return If the address is whitelisted\r\n    */\r\n    function canCall(address _caller) external view returns (bool);\r\n\r\n    /**\r\n        @notice Get all whitelisted callers\r\n        @return Array of whitelisted callers\r\n    */\r\n    function getCallers() external view returns (address[] memory);\r\n}\r\n// File: Interfaces/IERC20Facet.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\ninterface IERC20Facet {\r\n    \r\n    /**\r\n        @notice Get the token name\r\n        @return The token name\r\n    */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n        @notice Get the token symbol\r\n        @return The token symbol \r\n    */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n        @notice Get the amount of decimals\r\n        @return Amount of decimals\r\n    */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n        @notice Mints tokens. Can only be called by the contract owner or the contract itself\r\n        @param _receiver Address receiving the tokens\r\n        @param _amount Amount to mint\r\n    */\r\n    function mint(address _receiver, uint256 _amount) external;\r\n\r\n    /**\r\n        @notice Burns tokens. Can only be called by the contract owner or the contract itself\r\n        @param _from Address to burn from\r\n        @param _amount Amount to burn\r\n    */\r\n    function burn(address _from, uint256 _amount) external;\r\n\r\n    /**\r\n        @notice Sets up the metadata and initial supply. Can be called by the contract owner\r\n        @param _initialSupply Initial supply of the token\r\n        @param _name Name of the token\r\n        @param _symbol Symbol of the token\r\n    */\r\n    function initialize(\r\n        uint256 _initialSupply,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) external;\r\n\r\n    /**\r\n        @notice Set the token name of the contract. Can only be called by the contract owner or the contract itself\r\n        @param _name New token name\r\n    */\r\n    function setName(string calldata _name) external;\r\n\r\n    /**\r\n        @notice Set the token symbol of the contract. Can only be called by the contract owner or the contract itself\r\n        @param _symbol New token symbol\r\n    */\r\n    function setSymbol(string calldata _symbol) external;\r\n    \r\n    /**\r\n        @notice Increase the amount of tokens another address can spend\r\n        @param _spender Spender\r\n        @param _amount Amount to increase by\r\n    */\r\n    function increaseApproval(address _spender, uint256 _amount) external returns (bool);\r\n\r\n    /**\r\n        @notice Decrease the amount of tokens another address can spend\r\n        @param _spender Spender\r\n        @param _amount Amount to decrease by\r\n    */\r\n    function decreaseApproval(address _spender, uint256 _amount) external returns (bool);\r\n\r\n}\r\n// File: Interfaces/IBasketFacet.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\ninterface IBasketFacet {\r\n\r\n    event TokenAdded(address indexed _token);\r\n    event TokenRemoved(address indexed _token);\r\n    event EntryFeeSet(uint256 fee);\r\n    event ExitFeeSet(uint256 fee);\r\n    event AnnualizedFeeSet(uint256 fee);\r\n    event FeeBeneficiarySet(address indexed beneficiary);\r\n    event EntryFeeBeneficiaryShareSet(uint256 share);\r\n    event ExitFeeBeneficiaryShareSet(uint256 share);\r\n\r\n    event PoolJoined(address indexed who, uint256 amount);\r\n    event PoolExited(address indexed who, uint256 amount);\r\n    event FeeCharged(uint256 amount);\r\n    event LockSet(uint256 lockBlock);\r\n    event CapSet(uint256 cap);\r\n\r\n    /** \r\n        @notice Sets entry fee paid when minting\r\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\r\n    */\r\n    function setEntryFee(uint256 _fee) external;\r\n\r\n    /**\r\n        @notice Get the entry fee\r\n        @return Current entry fee\r\n    */\r\n    function getEntryFee() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Set the exit fee paid when exiting\r\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\r\n    */\r\n    function setExitFee(uint256 _fee) external;\r\n\r\n    /**\r\n        @notice Get the exit fee\r\n        @return Current exit fee\r\n    */\r\n    function getExitFee() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Set the annualized fee. Often referred to as streaming fee\r\n        @param _fee Amount of fee. 1e18 == 100%, capped at 10%\r\n    */\r\n    function setAnnualizedFee(uint256 _fee) external;\r\n\r\n    /**\r\n        @notice Get the annualized fee.\r\n        @return Current annualized fee.\r\n    */\r\n    function getAnnualizedFee() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Set the address receiving the fees.\r\n    */\r\n    function setFeeBeneficiary(address _beneficiary) external;\r\n\r\n    /**\r\n        @notice Get the fee benificiary\r\n        @return The current fee beneficiary\r\n    */\r\n    function getFeeBeneficiary() external view returns(address);\r\n\r\n    /**\r\n        @notice Set the fee beneficiaries share of the entry fee\r\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100% \r\n    */\r\n    function setEntryFeeBeneficiaryShare(uint256 _share) external;\r\n\r\n    /**\r\n        @notice Get the entry fee beneficiary share\r\n        @return Feeshare amount\r\n    */\r\n    function getEntryFeeBeneficiaryShare() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Set the fee beneficiaries share of the exit fee\r\n        @notice _share Share of the fee. 1e18 == 100%. Capped at 100% \r\n    */\r\n    function setExitFeeBeneficiaryShare(uint256 _share) external;\r\n\r\n    /**\r\n        @notice Get the exit fee beneficiary share\r\n        @return Feeshare amount\r\n    */\r\n    function getExitFeeBeneficiaryShare() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Calculate the oustanding annualized fee\r\n        @return Amount of pool tokens to be minted to charge the annualized fee\r\n    */\r\n    function calcOutStandingAnnualizedFee() external view returns(uint256);\r\n\r\n    /**\r\n        @notice Charges the annualized fee\r\n    */\r\n    function chargeOutstandingAnnualizedFee() external;\r\n\r\n    /**\r\n        @notice Pulls underlying from caller and mints the pool token\r\n        @param _amount Amount of pool tokens to mint\r\n    */\r\n    function joinPool(uint256 _amount) external;\r\n\r\n    /**\r\n        @notice Burns pool tokens from the caller and returns underlying assets\r\n    */\r\n    function exitPool(uint256 _amount) external;\r\n\r\n    /**\r\n        @notice Get if the pool is locked or not. (not accepting exit and entry)\r\n        @return Boolean indicating if the pool is locked\r\n    */\r\n    function getLock() external view returns (bool);\r\n\r\n    /**\r\n        @notice Get the block until which the pool is locked\r\n        @return The lock block\r\n    */\r\n    function getLockBlock() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Set the lock block\r\n        @param _lock Block height of the lock\r\n    */\r\n    function setLock(uint256 _lock) external;\r\n\r\n    /**\r\n        @notice Get the maximum of pool tokens that can be minted\r\n        @return Cap\r\n    */\r\n    function getCap() external view returns (uint256);\r\n\r\n    /**\r\n        @notice Set the maximum of pool tokens that can be minted\r\n        @param _maxCap Max cap \r\n    */\r\n    function setCap(uint256 _maxCap) external;\r\n\r\n    /**\r\n        @notice Get the amount of tokens owned by the pool\r\n        @param _token Addres of the token\r\n        @return Amount owned by the contract\r\n    */\r\n    function balance(address _token) external view returns (uint256);\r\n\r\n    /**\r\n        @notice Get the tokens in the pool\r\n        @return Array of tokens in the pool\r\n    */\r\n    function getTokens() external view returns (address[] memory);\r\n\r\n    /**\r\n        @notice Add a token to the pool. Should have at least a balance of 10**6\r\n        @param _token Address of the token to add\r\n    */\r\n    function addToken(address _token) external;\r\n\r\n    /**\r\n        @notice Removes a token from the pool\r\n        @param _token Address of the token to remove\r\n    */\r\n    function removeToken(address _token) external;\r\n\r\n    /**\r\n        @notice Checks if a token was added to the pool\r\n        @param _token address of the token\r\n        @return If token is in the pool or not\r\n    */\r\n    function getTokenInPool(address _token) external view returns (bool);\r\n\r\n    /**\r\n        @notice Calculate the amounts of underlying needed to mint that pool amount.\r\n        @param _amount Amount of pool tokens to mint\r\n        @return tokens Tokens needed\r\n        @return amounts Amounts of underlying needed\r\n    */\r\n    function calcTokensForAmount(uint256 _amount)\r\n        external\r\n        view\r\n        returns (address[] memory tokens, uint256[] memory amounts);\r\n\r\n    /**\r\n        @notice Calculate the amounts of underlying to receive when burning that pool amount\r\n        @param _amount Amount of pool tokens to burn\r\n        @return tokens Tokens returned\r\n        @return amounts Amounts of underlying returned\r\n    */\r\n    function calcTokensForAmountExit(uint256 _amount)\r\n        external\r\n        view\r\n        returns (address[] memory tokens, uint256[] memory amounts);\r\n}\r\n// File: Interfaces/IERC173.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n// File: Interfaces/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n// File: Interfaces/IExperiPie.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n    @title ExperiPie Interface\r\n    @dev Combines all ExperiPie facet interfaces into one\r\n*/\r\ninterface IExperiPie is IERC20, IBasketFacet, IERC20Facet, IERC173, ICallFacet {\r\n}\r\n// File: Interfaces/ILendingLogic.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\ninterface ILendingLogic {\r\n    /**\r\n        @notice Get the APR based on underlying token.\r\n        @param _token Address of the underlying token\r\n        @return Interest with 18 decimals\r\n    */\r\n    function getAPRFromUnderlying(address _token) external view returns(uint256);\r\n\r\n    /**\r\n        @notice Get the APR based on wrapped token.\r\n        @param _token Address of the wrapped token\r\n        @return Interest with 18 decimals\r\n    */\r\n    function getAPRFromWrapped(address _token) external view returns(uint256);\r\n\r\n    /**\r\n        @notice Get the calls needed to lend.\r\n        @param _underlying Address of the underlying token\r\n        @param _amount Amount of the underlying token\r\n        @return targets Addresses of the contracts to call\r\n        @return data Calldata of the calls\r\n    */\r\n    function lend(address _underlying, uint256 _amount, address _tokenHolder) external view returns(address[] memory targets, bytes[] memory data);\r\n\r\n    /**\r\n        @notice Get the calls needed to unlend\r\n        @param _wrapped Address of the wrapped token\r\n        @param _amount Amount of the underlying tokens\r\n        @return targets Addresses of the contracts to call\r\n        @return data Calldata of the calls\r\n    */\r\n    function unlend(address _wrapped, uint256 _amount, address _tokenHolder) external view returns(address[] memory targets, bytes[] memory data);\r\n\r\n    /**\r\n        @notice Get the underlying wrapped exchange rate\r\n        @param _wrapped Address of the wrapped token\r\n        @return The exchange rate\r\n    */\r\n    function exchangeRate(address _wrapped) external returns(uint256);\r\n\r\n    /**\r\n        @notice Get the underlying wrapped exchange rate in a view (non state changing) way\r\n        @param _wrapped Address of the wrapped token\r\n        @return The exchange rate\r\n    */\r\n    function exchangeRateView(address _wrapped) external view returns(uint256);\r\n}\r\n\r\n// File: OpenZeppelin/Context.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with GSN meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n// File: OpenZeppelin/Ownable.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: LendingRegistry.sol\r\n\r\n\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n// TODO consider making this contract upgradeable\r\ncontract LendingRegistry is Ownable {\r\n\r\n    // Maps wrapped token to protocol\r\n    mapping(address => bytes32) public wrappedToProtocol;\r\n    // Maps wrapped token to underlying\r\n    mapping(address => address) public wrappedToUnderlying;\r\n\r\n    mapping(address => mapping(bytes32 => address)) public underlyingToProtocolWrapped;\r\n\r\n    // Maps protocol to addresses containing lend and unlend logic\r\n    mapping(bytes32 => address) public protocolToLogic;\r\n\r\n    event WrappedToProtocolSet(address indexed wrapped, bytes32 indexed protocol);\r\n    event WrappedToUnderlyingSet(address indexed wrapped, address indexed underlying);\r\n    event ProtocolToLogicSet(bytes32 indexed protocol, address indexed logic);\r\n    event UnderlyingToProtocolWrappedSet(address indexed underlying, bytes32 indexed protocol, address indexed wrapped);\r\n\r\n    /**\r\n        @notice Set which protocl a wrapped token belongs to\r\n        @param _wrapped Address of the wrapped token\r\n        @param _protocol Bytes32 key of the protocol\r\n    */\r\n    function setWrappedToProtocol(address _wrapped, bytes32 _protocol) onlyOwner external {\r\n        wrappedToProtocol[_wrapped] = _protocol;\r\n        emit WrappedToProtocolSet(_wrapped, _protocol);\r\n    }\r\n\r\n    /**\r\n        @notice Set what is the underlying for a wrapped token\r\n        @param _wrapped Address of the wrapped token\r\n        @param _underlying Address of the underlying token\r\n    */\r\n    function setWrappedToUnderlying(address _wrapped, address _underlying) onlyOwner external {\r\n        wrappedToUnderlying[_wrapped] = _underlying;\r\n        emit WrappedToUnderlyingSet(_wrapped, _underlying);\r\n    }\r\n\r\n    /**\r\n        @notice Set the logic contract for the protocol\r\n        @param _protocol Bytes32 key of the protocol\r\n        @param _logic Address of the lending logic contract for that protocol\r\n    */\r\n    function setProtocolToLogic(bytes32 _protocol, address _logic) onlyOwner external {\r\n        protocolToLogic[_protocol] = _logic;\r\n        emit ProtocolToLogicSet(_protocol, _logic);\r\n    }\r\n\r\n    /**\r\n        @notice Set the wrapped token for the underlying deposited in this protocol\r\n        @param _underlying Address of the unerlying token\r\n        @param _protocol Bytes32 key of the protocol\r\n        @param _wrapped Address of the wrapped token\r\n    */\r\n    function setUnderlyingToProtocolWrapped(address _underlying, bytes32 _protocol, address _wrapped) onlyOwner external {\r\n        underlyingToProtocolWrapped[_underlying][_protocol] = _wrapped;\r\n        emit UnderlyingToProtocolWrappedSet(_underlying, _protocol, _wrapped);\r\n    }\r\n\r\n    /**\r\n        @notice Get tx data to lend the underlying amount in a specific protocol\r\n        @param _underlying Address of the underlying token\r\n        @param _amount Amount to lend\r\n        @param _protocol Bytes32 key of the protocol\r\n        @return targets Addresses of the contracts to call\r\n        @return data Calldata for the calls\r\n    */\r\n    function getLendTXData(address _underlying, uint256 _amount, address _tokenHolder, bytes32 _protocol) external view returns(address[] memory targets, bytes[] memory data) {\r\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[_protocol]);\r\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\r\n\r\n        return lendingLogic.lend(_underlying, _amount, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n        @notice Get the tx data to unlend the wrapped amount\r\n        @param _wrapped Address of the wrapped token\r\n        @param _amount Amount of wrapped token to unlend\r\n        @return targets Addresses of the contracts to call\r\n        @return data Calldata for the calls\r\n    */\r\n    function getUnlendTXData(address _wrapped, uint256 _amount, address _tokenHolder) external view returns(address[] memory targets, bytes[] memory data) {\r\n        ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[wrappedToProtocol[_wrapped]]);\r\n        require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\r\n\r\n        return lendingLogic.unlend(_wrapped, _amount, _tokenHolder);\r\n    }\r\n\r\n    /**\r\n        @notice Get the beste apr for the give protocols\r\n        @dev returns default values if lending logic not found\r\n        @param _underlying Address of the underlying token\r\n        @param _protocols Array of protocols to include\r\n        @return apr The APR\r\n        @return protocol Protocol that provides the APR\r\n    */\r\n    function getBestApr(address _underlying, bytes32[] memory _protocols) external view returns(uint256 apr, bytes32 protocol) {\r\n        uint256 bestApr;\r\n        bytes32 bestProtocol;\r\n\r\n        for(uint256 i = 0; i < _protocols.length; i++) {\r\n            bytes32 protocol = _protocols[i];\r\n            ILendingLogic lendingLogic = ILendingLogic(protocolToLogic[protocol]);\r\n            require(address(lendingLogic) != address(0), \"NO_LENDING_LOGIC_SET\");\r\n\r\n            uint256 apr = lendingLogic.getAPRFromUnderlying(_underlying);\r\n            if (apr > bestApr) {\r\n                bestApr = apr;\r\n                bestProtocol = protocol;\r\n            }\r\n        }\r\n\r\n        return (bestApr, bestProtocol);\r\n    }\r\n}\r\n// File: OpenZeppelin/Math.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n// File: OpenZeppelin/ReentrancyGuard.sol\r\n\r\n\r\n\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\ncontract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: LendingManager.sol\r\n\r\n\r\npragma experimental ABIEncoderV2;\r\npragma solidity ^0.7.1;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LendingManager is Ownable, ReentrancyGuard {\r\n    using Math for uint256;\r\n\r\n    LendingRegistry public lendingRegistry;\r\n    IExperiPie public basket;\r\n\r\n    event Lend(address indexed underlying, uint256 amount, bytes32 indexed protocol);\r\n    event UnLend(address indexed wrapped, uint256 amount);\r\n    /**\r\n        @notice Constructor\r\n        @param _lendingRegistry Address of the lendingRegistry contract\r\n        @param _basket Address of the pool/pie/basket to manage\r\n    */\r\n    constructor(address _lendingRegistry, address _basket) public {\r\n        require(_lendingRegistry != address(0), \"INVALID_LENDING_REGISTRY\");\r\n        require(_basket != address(0), \"INVALID_BASKET\");\r\n        lendingRegistry = LendingRegistry(_lendingRegistry);\r\n        basket = IExperiPie(_basket);\r\n    }\r\n\r\n    /**\r\n        @notice Move underlying to a lending protocol\r\n        @param _underlying Address of the underlying token\r\n        @param _amount Amount of underlying to lend\r\n        @param _protocol Bytes32 protocol key to lend to\r\n    */\r\n    function lend(address _underlying, uint256 _amount, bytes32 _protocol) public onlyOwner nonReentrant {\r\n        // _amount or actual balance, whatever is less\r\n        uint256 amount = _amount.min(IERC20(_underlying).balanceOf(address(basket)));\r\n\r\n        lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol).call{ value: 0 }(abi.encodeWithSelector(IKashiPair.accrue.selector));\r\n\r\n        //lend token\r\n        (\r\n            address[] memory _targets,\r\n            bytes[] memory _data\r\n        ) = lendingRegistry.getLendTXData(_underlying, amount, address(basket),_protocol);\r\n\r\n        basket.callNoValue(_targets, _data);\r\n\r\n        // if needed remove underlying from basket\r\n        removeToken(_underlying);\r\n\r\n        // add wrapped token\r\n        addToken(lendingRegistry.underlyingToProtocolWrapped(_underlying, _protocol));\r\n\r\n        emit Lend(_underlying, _amount, _protocol);\r\n    }\r\n\r\n    /**\r\n        @notice Unlend wrapped token from its lending protocol\r\n        @param _wrapped Address of the wrapped token\r\n        @param _amount Amount of the wrapped token to unlend\r\n    */\r\n    function unlend(address _wrapped, uint256 _amount) public onlyOwner nonReentrant {\r\n        \r\n        // _amount or actual balance, whatever is less\r\n        uint256 amount = _amount.min(IERC20(_wrapped).balanceOf(address(basket)));\r\n        \r\n        //Unlend token\r\n        (\r\n            address[] memory _targets,\r\n            bytes[] memory _data\r\n        ) = lendingRegistry.getUnlendTXData(_wrapped, amount, address(basket));\r\n        basket.callNoValue(_targets, _data);\r\n\r\n        // if needed add underlying\r\n        addToken(lendingRegistry.wrappedToUnderlying(_wrapped));\r\n\r\n        // if needed remove wrapped\r\n        removeToken(_wrapped);\r\n\r\n        emit UnLend(_wrapped, _amount);\r\n    }\r\n\r\n    /**\r\n        @notice Unlend and immediately lend in a different protocol\r\n        @param _wrapped Address of the wrapped token to bounce to another protocol\r\n        @param _amount Amount of the wrapped token to bounce to the other protocol\r\n        @param _toProtocol Protocol to deposit bounced tokens in\r\n        @dev Uses reentrency protection of unlend() and lend()\r\n    */\r\n    function bounce(address _wrapped, uint256 _amount, bytes32 _toProtocol) external {\r\n       unlend(_wrapped, _amount);\r\n       // Bounce all to new protocol\r\n       lend(lendingRegistry.wrappedToUnderlying(_wrapped), uint256(-1), _toProtocol);\r\n    }\r\n\r\n    function removeToken(address _token) internal {\r\n        uint256 balance = basket.balance(_token);\r\n        bool inPool = basket.getTokenInPool(_token);\r\n        //if there is a token balance of the token is not in the pool, skip\r\n        if(balance != 0 || !inPool) {\r\n            return;\r\n        }\r\n\r\n        // remove token\r\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.removeToken.selector, _token), 0);\r\n    }\r\n\r\n    function addToken(address _token) internal {\r\n        uint256 balance = basket.balance(_token);\r\n        bool inPool = basket.getTokenInPool(_token);\r\n        // If token has no balance or is already in the pool, skip\r\n        if(balance == 0 || inPool) {\r\n            return;\r\n        }\r\n\r\n        // add token\r\n        basket.singleCall(address(basket), abi.encodeWithSelector(basket.addToken.selector, _token), 0);\r\n    }\r\n \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lendingRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_basket\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"protocol\",\"type\":\"bytes32\"}],\"name\":\"Lend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wrapped\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnLend\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"basket\",\"outputs\":[{\"internalType\":\"contract IExperiPie\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapped\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_toProtocol\",\"type\":\"bytes32\"}],\"name\":\"bounce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_protocol\",\"type\":\"bytes32\"}],\"name\":\"lend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingRegistry\",\"outputs\":[{\"internalType\":\"contract LendingRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapped\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"unlend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LendingManager", "CompilerVersion": "v0.7.1+commit.f4a555be", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c94bc5c62c53e88d67c3874f5e8f91c6a99656ca0000000000000000000000005ee08f40b637417bcc9d2c51b62f4820ec9cf5d8", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d124bfa8add6a0397249da8e2369bba4491d8f3b5c0ce61c713b4b0bc17d930a"}]}