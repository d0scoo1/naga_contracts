{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.7.4;\r\n\r\n/** \r\n\ud83d\udd25 The Spiritual Stones are required to access the Sacred Ethereum Realm and obtain the Triforce.\r\nWill you be brave enough to collect all of them and become the Triforce holder ? \ud83d\udd25\r\n\r\n\u2b55 The Triforce's rules \u2b55\r\n\r\n- The Spiritual Stones are required to access the Sacred Ethereum Realm and obtain the Triforce. The Triforce will give specific advantages to those who have managed to acquire it during their journey.\r\n- You\u2019ll have your Spiritual Stone for one hour unless someone beats your condition which will make him becoming the new Spiritual Stone's owner.\r\n- Once the hour is finished, the counter will be reset and everyone will be able to compete again for the Spiritual Stones.\r\n- If you sell any tokens at all while holding a Stone, you are not worthy anymore to own a Spiritual Stone.\r\n\r\nSee more details on our website: https://triforceeth.com\r\n\r\nWebsite: https://triforceeth.com\r\nTwitter: https://twitter.com/TheTriforceETH\r\nTelegram: https://t.me/TheTriforceEntry\r\n*/\r\n// SPDX-License-Identifier: Unlicensed\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address _owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IDEXFactory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function getAmountsIn(uint256 amountOut, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function getAmountsOut(uint256 amountIn, address[] memory path)\r\n        external\r\n        view\r\n        returns (uint256[] memory amounts);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint256 amountADesired,\r\n        uint256 amountBDesired,\r\n        uint256 amountAMin,\r\n        uint256 amountBMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        returns (\r\n            uint256 amountA,\r\n            uint256 amountB,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n}\r\n\r\nabstract contract Auth {\r\n    address internal owner;\r\n    mapping(address => bool) internal authorizations;\r\n\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        authorizations[_owner] = true;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\");\r\n        _;\r\n    }\r\n    modifier authorized() {\r\n        require(isAuthorized(msg.sender), \"!AUTHORIZED\");\r\n        _;\r\n    }\r\n\r\n    function authorize(address adr) public onlyOwner {\r\n        authorizations[adr] = true;\r\n    }\r\n\r\n    function unauthorize(address adr) public onlyOwner {\r\n        authorizations[adr] = false;\r\n    }\r\n\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n\r\n    function isAuthorized(address adr) public view returns (bool) {\r\n        return authorizations[adr];\r\n    }\r\n\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        authorizations[adr] = true;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\nabstract contract ERC20Interface {\r\n    function balanceOf(address whom) public view virtual returns (uint256);\r\n}\r\n\r\ncontract Triforce is IERC20, Auth {\r\n    using SafeMath for uint256;\r\n\r\n    string constant _name = \"TRIFORCE\";\r\n    string constant _symbol = \"TRIFORCE\";\r\n    uint8 constant _decimals = 18;\r\n\r\n    address DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    address ZERO = 0x0000000000000000000000000000000000000000;\r\n    address routerAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n\r\n    uint256 _totalSupply = 10000 * (10**_decimals);\r\n    uint256 private _liqAddBlock = 0;\r\n    uint256 public biggestBuy = 0;\r\n    uint256 public biggestBuySum = 0;\r\n    uint256 public lowestBuy = uint256(-1);\r\n    uint256 public lastRubyChange = 0;\r\n    uint256 public lastSapphireChange = 0;\r\n    uint256 public lastEmeraldChange = 0;\r\n    uint256 public resetPeriod = 1 hours;\r\n    address[] private rewardedAddresses;\r\n    address[] private _sniipers;\r\n    mapping(address => uint256) _balances;\r\n    mapping(address => mapping(address => uint256)) _allowances;\r\n    mapping(address => bool) public isFeeExempt;\r\n    mapping(address => bool) public isTxLimitExempt;\r\n    mapping(address => bool) public hasSold;\r\n    mapping(address => bool) private _liquidityHolders;\r\n    mapping(address => bool) private _isSniiper;\r\n    mapping(address => uint256) public totalBuySumPerAddress;\r\n    mapping(address => uint256) public totalRewardsPerAddress;\r\n\r\n    uint256 public marketingFee = 9;\r\n    uint256 public sapphireFee = 3; // Biggest buy sum\r\n    uint256 public rubyFee = 2; // Biggest buy\r\n    uint256 public emeraldFee = 1; // Lowest buy\r\n    uint256 public totalFee = 0;\r\n    uint256 public totalFeeIfSelling = 0;\r\n    address public autoLiquidityReceiver;\r\n    address public marketingWallet;\r\n    address public Sapphire;\r\n    address public Ruby;\r\n    address public Emerald;\r\n\r\n    IDEXRouter public router;\r\n    address public pair;\r\n\r\n    bool _hasLiqBeenAdded = false;\r\n    bool sniiperProtection = true;\r\n    bool inSwapAndLiquify;\r\n    bool public swapAndLiquifyEnabled = true;\r\n    uint256 public _maxTxAmount = _totalSupply / 100;\r\n    uint256 public _maxWalletAmount = _totalSupply / 50;\r\n    uint256 public swapThreshold = _totalSupply / 200;\r\n\r\n    modifier lockTheSwap() {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n    event AutoLiquify(uint256 amountETH, uint256 amountToken);\r\n    event NewSapphire(address ring, uint256 buyAmount);\r\n    event NewRuby(address ring, uint256 buyAmount);\r\n    event NewEmerald(address ring, uint256 buyAmount);\r\n    event SapphirePayout(address ring, uint256 amountETH);\r\n    event RubyPayout(address ring, uint256 amountETH);\r\n    event EmeraldPayout(address ring, uint256 amountETH);\r\n    event SapphireSold(address ring, uint256 amountETH);\r\n    event RubySold(address ring, uint256 amountETH);\r\n    event EmeraldSold(address ring, uint256 amountETH);\r\n\r\n    constructor() Auth(msg.sender) {\r\n        router = IDEXRouter(routerAddress);\r\n        pair = IDEXFactory(router.factory()).createPair(\r\n            router.WETH(),\r\n            address(this)\r\n        );\r\n        _allowances[address(this)][address(router)] = uint256(-1);\r\n        isFeeExempt[DEAD] = true;\r\n        isTxLimitExempt[DEAD] = true;\r\n        isFeeExempt[msg.sender] = true;\r\n        isFeeExempt[address(this)] = true;\r\n        isTxLimitExempt[msg.sender] = true;\r\n        isTxLimitExempt[address(this)] = true;\r\n        isTxLimitExempt[pair] = true;\r\n        _liquidityHolders[msg.sender] = true;\r\n        autoLiquidityReceiver = msg.sender;\r\n        marketingWallet = msg.sender;\r\n        Sapphire = msg.sender;\r\n        Ruby = msg.sender;\r\n        Emerald = msg.sender;\r\n        totalFee = marketingFee.add(rubyFee).add(emeraldFee).add(sapphireFee);\r\n        totalFeeIfSelling = totalFee;\r\n        _balances[msg.sender] = _totalSupply;\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getCirculatingSupply() public view returns (uint256) {\r\n        return _totalSupply.sub(balanceOf(DEAD)).sub(balanceOf(ZERO));\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function setMaxTxAmount(uint256 amount) external authorized {\r\n        _maxTxAmount = amount;\r\n    }\r\n\r\n    function setMaxWalletAmount(uint256 amount) external authorized {\r\n        _maxWalletAmount = amount;\r\n    }\r\n\r\n    function setFees(\r\n        uint256 newMarketingFee,\r\n        uint256 newSapphireFee,\r\n        uint256 newRubyFee,\r\n        uint256 newEmeraldFee\r\n    ) external authorized {\r\n        marketingFee = newMarketingFee;\r\n        sapphireFee = newSapphireFee;\r\n        rubyFee = newRubyFee;\r\n        emeraldFee = newEmeraldFee;\r\n        totalFee = marketingFee.add(rubyFee).add(emeraldFee).add(sapphireFee);\r\n        totalFeeIfSelling = totalFee;\r\n    }\r\n\r\n    function allowance(address holder, address spender)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address spender) external returns (bool) {\r\n        return approve(spender, uint256(-1));\r\n    }\r\n\r\n    function setIsFeeExempt(address holder, bool exempt) external authorized {\r\n        isFeeExempt[holder] = exempt;\r\n    }\r\n\r\n    function setIsTxLimitExempt(address holder, bool exempt)\r\n        external\r\n        authorized\r\n    {\r\n        isTxLimitExempt[holder] = exempt;\r\n    }\r\n\r\n    function setSwapThreshold(uint256 threshold) external authorized {\r\n        swapThreshold = threshold;\r\n    }\r\n\r\n    function setFeeReceivers(\r\n        address newLiquidityReceiver,\r\n        address newMarketingWallet\r\n    ) external authorized {\r\n        autoLiquidityReceiver = newLiquidityReceiver;\r\n        marketingWallet = newMarketingWallet;\r\n    }\r\n\r\n    function _checkLiquidityAdd(address from, address to) private {\r\n        require(!_hasLiqBeenAdded, \"Liquidity already added and marked.\");\r\n        if (_liquidityHolders[from] && to == pair) {\r\n            _hasLiqBeenAdded = true;\r\n            _liqAddBlock = block.number;\r\n        }\r\n    }\r\n\r\n    function setResetPeriodInSeconds(uint256 newResetPeriod)\r\n        external\r\n        authorized\r\n    {\r\n        resetPeriod = newResetPeriod;\r\n    }\r\n\r\n    function _resetSapphire() internal {\r\n        biggestBuySum = 0;\r\n        Sapphire = marketingWallet;\r\n        lastSapphireChange = block.timestamp;\r\n    }\r\n\r\n    function _resetRuby() internal {\r\n        biggestBuy = 0;\r\n        Ruby = marketingWallet;\r\n        lastRubyChange = block.timestamp;\r\n    }\r\n\r\n    function _resetEmerald() internal {\r\n        lowestBuy = uint256(-1);\r\n        Emerald = marketingWallet;\r\n        lastEmeraldChange = block.timestamp;\r\n    }\r\n\r\n    function epochResetSapphire() external view returns (uint256) {\r\n        return lastSapphireChange + resetPeriod;\r\n    }\r\n\r\n    function epochResetRuby() external view returns (uint256) {\r\n        return lastRubyChange + resetPeriod;\r\n    }\r\n\r\n    function epochResetEmerald() external view returns (uint256) {\r\n        return lastEmeraldChange + resetPeriod;\r\n    }\r\n\r\n    function approxETHRewards()\r\n        external\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n        uint256 receivedETH = router.getAmountsOut(swapThreshold, path)[1];\r\n        uint256 amountETHSapphire = receivedETH.mul(sapphireFee).div(totalFee);\r\n        uint256 amountETHRuby = receivedETH.mul(rubyFee).div(totalFee);\r\n        uint256 amountETHEmerald = receivedETH.mul(emeraldFee).div(totalFee);\r\n        return (amountETHSapphire, amountETHRuby, amountETHEmerald);\r\n    }\r\n\r\n    function disableSniiperProtection() public authorized {\r\n        sniiperProtection = false;\r\n    }\r\n\r\n    function byeByeSniipers() public authorized lockTheSwap {\r\n        if (_sniipers.length > 0) {\r\n            uint256 oldContractBalance = _balances[address(this)];\r\n            for (uint256 i = 0; i < _sniipers.length; i++) {\r\n                _balances[address(this)] = _balances[address(this)].add(\r\n                    _balances[_sniipers[i]]\r\n                );\r\n                emit Transfer(\r\n                    _sniipers[i],\r\n                    address(this),\r\n                    _balances[_sniipers[i]]\r\n                );\r\n                _balances[_sniipers[i]] = 0;\r\n            }\r\n            uint256 collectedTokens = _balances[address(this)] -\r\n                oldContractBalance;\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = router.WETH();\r\n\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n                collectedTokens,\r\n                0,\r\n                path,\r\n                marketingWallet,\r\n                block.timestamp\r\n            );\r\n        }\r\n    }\r\n\r\n    function _checkTxLimit(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal {\r\n        if (block.timestamp - lastSapphireChange > resetPeriod) {\r\n            _resetSapphire();\r\n        }\r\n        if (block.timestamp - lastRubyChange > resetPeriod) {\r\n            _resetRuby();\r\n        }\r\n        if (block.timestamp - lastEmeraldChange > resetPeriod) {\r\n            _resetEmerald();\r\n        }\r\n        if (\r\n            sender != owner &&\r\n            recipient != owner &&\r\n            !isTxLimitExempt[recipient] &&\r\n            recipient != ZERO &&\r\n            recipient != DEAD &&\r\n            recipient != pair &&\r\n            recipient != address(this)\r\n        ) {\r\n            require(amount <= _maxTxAmount, \"MAX TX\");\r\n            uint256 contractBalanceRecipient = balanceOf(recipient);\r\n            require(\r\n                contractBalanceRecipient + amount <= _maxWalletAmount,\r\n                \"Exceeds maximum wallet token amount\"\r\n            );\r\n            address[] memory path = new address[](2);\r\n            path[0] = router.WETH();\r\n            path[1] = address(this);\r\n            uint256 usedEth = router.getAmountsIn(amount, path)[0];\r\n            totalBuySumPerAddress[recipient] += usedEth;\r\n            if (!hasSold[recipient]) {\r\n                if (totalBuySumPerAddress[recipient] > biggestBuySum) {\r\n                    biggestBuySum = totalBuySumPerAddress[recipient];\r\n                    lastSapphireChange = block.timestamp;\r\n                    if (Sapphire != recipient) {\r\n                        Sapphire = recipient;\r\n                        emit NewSapphire(Sapphire, biggestBuySum);\r\n                    }\r\n                }\r\n                if (usedEth > biggestBuy) {\r\n                    biggestBuy = usedEth;\r\n                    lastRubyChange = block.timestamp;\r\n                    if (Ruby != recipient) {\r\n                        Ruby = recipient;\r\n                        emit NewRuby(Ruby, biggestBuy);\r\n                    }\r\n                }\r\n                if (usedEth < lowestBuy) {\r\n                    lowestBuy = usedEth;\r\n                    lastEmeraldChange = block.timestamp;\r\n                    if (Emerald != recipient) {\r\n                        Emerald = recipient;\r\n                        emit NewEmerald(Emerald, lowestBuy);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            sender != owner &&\r\n            recipient != owner &&\r\n            !isTxLimitExempt[sender] &&\r\n            sender != pair &&\r\n            recipient != address(this)\r\n        ) {\r\n            require(amount <= _maxTxAmount, \"MAX TX\");\r\n            if (Sapphire == sender) {\r\n                emit SapphireSold(Sapphire, biggestBuySum);\r\n                _resetSapphire();\r\n                hasSold[sender] = true;\r\n            }\r\n            if (Ruby == sender) {\r\n                emit RubySold(Ruby, biggestBuy);\r\n                _resetRuby();\r\n                hasSold[sender] = true;\r\n            }\r\n            if (Emerald == sender) {\r\n                emit EmeraldSold(Emerald, lowestBuy);\r\n                _resetEmerald();\r\n                hasSold[sender] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function setSwapBackSettings(bool enableSwapBack, uint256 newSwapBackLimit)\r\n        external\r\n        authorized\r\n    {\r\n        swapAndLiquifyEnabled = enableSwapBack;\r\n        swapThreshold = newSwapBackLimit;\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        override\r\n        returns (bool)\r\n    {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != uint256(-1)) {\r\n            _allowances[sender][msg.sender] = _allowances[sender][msg.sender]\r\n                .sub(amount, \"Insufficient Allowance\");\r\n        }\r\n        _transferFrom(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        if (inSwapAndLiquify) {\r\n            return _basicTransfer(sender, recipient, amount);\r\n        }\r\n        if (sniiperProtection) {\r\n            if (!_hasLiqBeenAdded) {\r\n                _checkLiquidityAdd(sender, recipient);\r\n            } else {\r\n                if (\r\n                    _liqAddBlock > 0 &&\r\n                    sender == pair &&\r\n                    !_liquidityHolders[sender] &&\r\n                    !_liquidityHolders[recipient]\r\n                ) {\r\n                    if (block.number - _liqAddBlock < 2) {\r\n                        if (!_isSniiper[recipient]) {\r\n                            _sniipers.push(recipient);\r\n                        }\r\n                        _isSniiper[recipient] = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (\r\n            msg.sender != pair &&\r\n            !inSwapAndLiquify &&\r\n            swapAndLiquifyEnabled &&\r\n            _balances[address(this)] >= swapThreshold\r\n        ) {\r\n            swapBack();\r\n        }\r\n        _checkTxLimit(sender, recipient, amount);\r\n        require(!isWalletToWallet(sender, recipient), \"Don't cheat\");\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        uint256 amountReceived = !isFeeExempt[sender] && !isFeeExempt[recipient]\r\n            ? takeFee(sender, recipient, amount)\r\n            : amount;\r\n        _balances[recipient] = _balances[recipient].add(amountReceived);\r\n        emit Transfer(msg.sender, recipient, amountReceived);\r\n        return true;\r\n    }\r\n\r\n    function _basicTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (bool) {\r\n        _balances[sender] = _balances[sender].sub(\r\n            amount,\r\n            \"Insufficient Balance\"\r\n        );\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function takeFee(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) internal returns (uint256) {\r\n        uint256 feeApplicable = pair == recipient\r\n            ? totalFeeIfSelling\r\n            : totalFee;\r\n        uint256 feeAmount = amount.mul(feeApplicable).div(100);\r\n        _balances[address(this)] = _balances[address(this)].add(feeAmount);\r\n        emit Transfer(sender, address(this), feeAmount);\r\n        return amount.sub(feeAmount);\r\n    }\r\n\r\n    function isWalletToWallet(address sender, address recipient)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (isFeeExempt[sender] || isFeeExempt[recipient]) {\r\n            return false;\r\n        }\r\n        if (sender == pair || recipient == pair) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function swapBack() internal lockTheSwap {\r\n        uint256 tokensToLiquify = swapThreshold;\r\n        uint256 amountToSwap = tokensToLiquify;\r\n\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = router.WETH();\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            amountToSwap,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        uint256 amountETH = address(this).balance;\r\n        uint256 amountETHMarketing = amountETH.mul(marketingFee).div(totalFee);\r\n        uint256 amountETHSapphire = amountETH.mul(sapphireFee).div(totalFee);\r\n        uint256 amountETHRuby = amountETH.mul(rubyFee).div(totalFee);\r\n        uint256 amountETHEmerald = amountETH.mul(emeraldFee).div(totalFee);\r\n\r\n        (bool tmpSuccess, ) = payable(marketingWallet).call{\r\n            value: amountETHMarketing,\r\n            gas: 30000\r\n        }(\"\");\r\n        (bool tmpSuccess2, ) = payable(Sapphire).call{\r\n            value: amountETHSapphire,\r\n            gas: 30000\r\n        }(\"\");\r\n        if (totalRewardsPerAddress[Sapphire] == 0) {\r\n            rewardedAddresses.push(Sapphire);\r\n        }\r\n        totalRewardsPerAddress[Sapphire] += amountETHSapphire;\r\n        emit SapphirePayout(Sapphire, amountETHSapphire);\r\n        (bool tmpSuccess3, ) = payable(Ruby).call{\r\n            value: amountETHRuby,\r\n            gas: 30000\r\n        }(\"\");\r\n        if (totalRewardsPerAddress[Ruby] == 0) {\r\n            rewardedAddresses.push(Ruby);\r\n        }\r\n        totalRewardsPerAddress[Ruby] += amountETHRuby;\r\n        emit RubyPayout(Ruby, amountETHRuby);\r\n        (bool tmpSuccess4, ) = payable(Emerald).call{\r\n            value: amountETHEmerald,\r\n            gas: 30000\r\n        }(\"\");\r\n        if (totalRewardsPerAddress[Emerald] == 0) {\r\n            rewardedAddresses.push(Emerald);\r\n        }\r\n        totalRewardsPerAddress[Emerald] += amountETHEmerald;\r\n        emit EmeraldPayout(Emerald, amountETHEmerald);\r\n\r\n        // only to supress warning msg\r\n        tmpSuccess = false;\r\n        tmpSuccess2 = false;\r\n        tmpSuccess3 = false;\r\n        tmpSuccess4 = false;\r\n    }\r\n\r\n    function getAllRewards()\r\n        external\r\n        view\r\n        returns (address[] memory, uint256[] memory)\r\n    {\r\n        address[] memory mAddresses = new address[](rewardedAddresses.length);\r\n        uint256[] memory mRewards = new uint256[](rewardedAddresses.length);\r\n        for (uint256 i = 0; i < rewardedAddresses.length; i++) {\r\n            mAddresses[i] = rewardedAddresses[i];\r\n            mRewards[i] = totalRewardsPerAddress[rewardedAddresses[i]];\r\n        }\r\n        return (mAddresses, mRewards);\r\n    }\r\n\r\n    function recoverLosteth() external authorized {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function recoverLostTokens(address _token, uint256 _amount)\r\n        external\r\n        authorized\r\n    {\r\n        IERC20(_token).transfer(msg.sender, _amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"}],\"name\":\"AutoLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"EmeraldPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"EmeraldSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"NewEmerald\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"NewRuby\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmount\",\"type\":\"uint256\"}],\"name\":\"NewSapphire\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"RubyPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"RubySold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"SapphirePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"ring\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"}],\"name\":\"SapphireSold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Emerald\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Ruby\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Sapphire\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"approxETHRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"autoLiquidityReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"biggestBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"biggestBuySum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"byeByeSniipers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableSniiperProtection\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emeraldFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochResetEmerald\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochResetRuby\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochResetSapphire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllRewards\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCirculatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasSold\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTxLimitExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEmeraldChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRubyChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastSapphireChange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lowestBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverLostTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recoverLosteth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IDEXRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rubyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sapphireFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newLiquidityReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newMarketingWallet\",\"type\":\"address\"}],\"name\":\"setFeeReceivers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMarketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newSapphireFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newRubyFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newEmeraldFee\",\"type\":\"uint256\"}],\"name\":\"setFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"exempt\",\"type\":\"bool\"}],\"name\":\"setIsTxLimitExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newResetPeriod\",\"type\":\"uint256\"}],\"name\":\"setResetPeriodInSeconds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableSwapBack\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"newSwapBackLimit\",\"type\":\"uint256\"}],\"name\":\"setSwapBackSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setSwapThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBuySumPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFeeIfSelling\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalRewardsPerAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"unauthorize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Triforce", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d66be5e8b937b91977484e9140a1b81797a2c0aa6165af6f54fb52e51e960995"}]}