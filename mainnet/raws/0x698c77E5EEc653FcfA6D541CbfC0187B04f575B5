{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/GelatoMakerJob.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n//solhint-disable compiler-version\\npragma solidity 0.8.11;\\nimport {GelatoBytes} from \\\"./gelato/GelatoBytes.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\n\\ninterface ISequencer {\\n    struct WorkableJob {\\n        address job;\\n        bool canWork;\\n        bytes args;\\n    }\\n\\n    function getNextJobs(\\n        bytes32 network,\\n        uint256 startIndex,\\n        uint256 endIndexExcl\\n    ) external returns (WorkableJob[] memory);\\n\\n    function numJobs() external view returns (uint256);\\n}\\n\\ninterface IJob {\\n    function work(bytes32 network, bytes calldata args) external;\\n\\n    function workable(bytes32 network)\\n        external\\n        returns (bool canWork, bytes memory args);\\n}\\n\\ncontract GelatoMakerJob {\\n    using GelatoBytes for bytes;\\n\\n    address public immutable pokeMe;\\n\\n    constructor(address _pokeMe) {\\n        pokeMe = _pokeMe;\\n    }\\n\\n    //solhint-disable code-complexity\\n    //solhint-disable function-max-lines\\n    function checker(\\n        address _sequencer,\\n        bytes32 _network,\\n        uint256 _startIndex,\\n        uint256 _endIndex\\n    ) external returns (bool, bytes memory) {\\n        ISequencer sequencer = ISequencer(_sequencer);\\n        uint256 numJobs = sequencer.numJobs();\\n\\n        if (numJobs == 0)\\n            return (false, bytes(\\\"GelatoMakerJob: No jobs listed\\\"));\\n        if (_startIndex >= numJobs) {\\n            bytes memory msg1 = bytes.concat(\\n                \\\"GelatoMakerJob: Only jobs available up to index \\\",\\n                bytes(Strings.toString(numJobs - 1))\\n            );\\n\\n            bytes memory msg2 = bytes.concat(\\n                \\\", inputted startIndex is \\\",\\n                bytes(Strings.toString(_startIndex))\\n            );\\n            return (false, bytes.concat(msg1, msg2));\\n        }\\n\\n        uint256 endIndex = _endIndex > numJobs ? numJobs : _endIndex;\\n\\n        ISequencer.WorkableJob[] memory jobs = ISequencer(_sequencer)\\n            .getNextJobs(_network, _startIndex, endIndex);\\n\\n        uint256 numWorkable;\\n        for (uint256 i; i < jobs.length; i++) {\\n            if (jobs[i].canWork) numWorkable++;\\n        }\\n\\n        if (numWorkable == 0)\\n            return (false, bytes(\\\"GelatoMakerJob: No workable jobs\\\"));\\n\\n        address[] memory tos = new address[](numWorkable);\\n        bytes[] memory datas = new bytes[](numWorkable);\\n\\n        uint256 wIndex;\\n        for (uint256 i; i < jobs.length; i++) {\\n            if (jobs[i].canWork) {\\n                tos[wIndex] = jobs[i].job;\\n                datas[wIndex] = abi.encodeWithSelector(\\n                    IJob.work.selector,\\n                    _network,\\n                    jobs[i].args\\n                );\\n                wIndex++;\\n            }\\n        }\\n\\n        bytes memory execPayload = abi.encodeWithSelector(\\n            this.doJobs.selector,\\n            tos,\\n            datas\\n        );\\n\\n        return (true, execPayload);\\n    }\\n\\n    function doJobs(address[] calldata _tos, bytes[] calldata _datas) external {\\n        require(msg.sender == pokeMe, \\\"GelatoMakerJob: Only PokeMe\\\");\\n        require(\\n            _tos.length == _datas.length,\\n            \\\"GelatoMakerJob: Length mismatch\\\"\\n        );\\n\\n        for (uint256 i; i < _tos.length; i++) {\\n            _doJob(_tos[i], _datas[i]);\\n        }\\n    }\\n\\n    function _doJob(address _to, bytes memory _data) private {\\n        (bool success, bytes memory returnData) = _to.call(_data);\\n        if (!success) returnData.revertWithError(\\\"GelatoMakerJob: \\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/gelato/GelatoBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n//solhint-disable compiler-version\\npragma solidity 0.8.11;\\n\\nlibrary GelatoBytes {\\n    function calldataSliceSelector(bytes calldata _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function memorySliceSelector(bytes memory _bytes)\\n        internal\\n        pure\\n        returns (bytes4 selector)\\n    {\\n        selector =\\n            _bytes[0] |\\n            (bytes4(_bytes[1]) >> 8) |\\n            (bytes4(_bytes[2]) >> 16) |\\n            (bytes4(_bytes[3]) >> 24);\\n    }\\n\\n    function revertWithError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                revert(string(abi.encodePacked(_tracingInfo, string(_bytes))));\\n            } else {\\n                revert(\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"))\\n                );\\n            }\\n        } else {\\n            revert(\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"))\\n            );\\n        }\\n    }\\n\\n    function returnError(bytes memory _bytes, string memory _tracingInfo)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // 68: 32-location, 32-length, 4-ErrorSelector, UTF-8 err\\n        if (_bytes.length % 32 == 4) {\\n            bytes4 selector;\\n            assembly {\\n                selector := mload(add(0x20, _bytes))\\n            }\\n            if (selector == 0x08c379a0) {\\n                // Function selector for Error(string)\\n                assembly {\\n                    _bytes := add(_bytes, 68)\\n                }\\n                return string(abi.encodePacked(_tracingInfo, string(_bytes)));\\n            } else {\\n                return\\n                    string(abi.encodePacked(_tracingInfo, \\\"NoErrorSelector\\\"));\\n            }\\n        } else {\\n            return\\n                string(abi.encodePacked(_tracingInfo, \\\"UnexpectedReturndata\\\"));\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pokeMe\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sequencer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_network\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndex\",\"type\":\"uint256\"}],\"name\":\"checker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tos\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_datas\",\"type\":\"bytes[]\"}],\"name\":\"doJobs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pokeMe\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GelatoMakerJob", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b3f5503f93d5ef84b06993a1975b9d21b962892f", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}