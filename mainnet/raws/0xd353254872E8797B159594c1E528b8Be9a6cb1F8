{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/base/governance/Announcer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./ControllableV2.sol\\\";\\r\\nimport \\\"./ControllerStorage.sol\\\";\\r\\nimport \\\"../interface/IAnnouncer.sol\\\";\\r\\n\\r\\n/// @title Contract for holding scheduling for time-lock actions\\r\\n/// @dev Use with TetuProxy\\r\\n/// @author belbix\\r\\ncontract Announcer is ControllableV2, IAnnouncer {\\r\\n\\r\\n  /// @notice Version of the contract\\r\\n  /// @dev Should be incremented when contract is changed\\r\\n  string public constant VERSION = \\\"1.2.0\\\";\\r\\n  bytes32 internal constant _TIME_LOCK_SLOT = 0x244FE7C39AF244D294615908664E79A2F65DD3F4D5C387AF1D52197F465D1C2E;\\r\\n\\r\\n  /// @dev Hold schedule for time-locked operations\\r\\n  mapping(bytes32 => uint256) public override timeLockSchedule;\\r\\n  /// @dev Hold values for upgrade\\r\\n  TimeLockInfo[] private _timeLockInfos;\\r\\n  /// @dev Hold indexes for upgrade info\\r\\n  mapping(TimeLockOpCodes => uint256) public timeLockIndexes;\\r\\n  /// @dev Hold indexes for upgrade info by address\\r\\n  mapping(TimeLockOpCodes => mapping(address => uint256)) public multiTimeLockIndexes;\\r\\n  /// @dev Deprecated, don't remove for keep slot ordering\\r\\n  mapping(TimeLockOpCodes => bool) public multiOpCodes;\\r\\n\\r\\n  /// @notice Address change was announced\\r\\n  event AddressChangeAnnounce(TimeLockOpCodes opCode, address newAddress);\\r\\n  /// @notice Uint256 change was announced\\r\\n  event UintChangeAnnounce(TimeLockOpCodes opCode, uint256 newValue);\\r\\n  /// @notice Ratio change was announced\\r\\n  event RatioChangeAnnounced(TimeLockOpCodes opCode, uint256 numerator, uint256 denominator);\\r\\n  /// @notice Token movement was announced\\r\\n  event TokenMoveAnnounced(TimeLockOpCodes opCode, address target, address token, uint256 amount);\\r\\n  /// @notice Proxy Upgrade was announced\\r\\n  event ProxyUpgradeAnnounced(address _contract, address _implementation);\\r\\n  /// @notice Mint was announced\\r\\n  event MintAnnounced(uint256 totalAmount, address _distributor, address _otherNetworkFund);\\r\\n  /// @notice Announce was closed\\r\\n  event AnnounceClosed(bytes32 opHash);\\r\\n  /// @notice Strategy Upgrade was announced\\r\\n  event StrategyUpgradeAnnounced(address _contract, address _implementation);\\r\\n  /// @notice Vault stop action announced\\r\\n  event VaultStop(address _contract);\\r\\n\\r\\n  constructor() {\\r\\n    require(_TIME_LOCK_SLOT == bytes32(uint256(keccak256(\\\"eip1967.announcer.timeLock\\\")) - 1), \\\"wrong timeLock\\\");\\r\\n  }\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  /// @dev Use it only once after first logic setup\\r\\n  /// @param _controller Controller address\\r\\n  /// @param _timeLock TimeLock period\\r\\n  function initialize(address _controller, uint256 _timeLock) external initializer {\\r\\n    ControllableV2.initializeControllable(_controller);\\r\\n\\r\\n    // fill timeLock\\r\\n    bytes32 slot = _TIME_LOCK_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _timeLock)\\r\\n    }\\r\\n\\r\\n    // placeholder for index 0\\r\\n    _timeLockInfos.push(TimeLockInfo(TimeLockOpCodes.ZeroPlaceholder, 0, address(0), new address[](0), new uint256[](0)));\\r\\n  }\\r\\n\\r\\n  /// @dev Operations allowed only for Governance address\\r\\n  modifier onlyGovernance() {\\r\\n    require(_isGovernance(msg.sender), \\\"not governance\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @dev Operations allowed for Governance or Dao addresses\\r\\n  modifier onlyGovernanceOrDao() {\\r\\n    require(_isGovernance(msg.sender)\\r\\n      || IController(_controller()).isDao(msg.sender), \\\"not governance or dao\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /// @dev Operations allowed for Governance or Dao addresses\\r\\n  modifier onlyControlMembers() {\\r\\n    require(\\r\\n      _isGovernance(msg.sender)\\r\\n      || _isController(msg.sender)\\r\\n      || IController(_controller()).isDao(msg.sender)\\r\\n      || IController(_controller()).vaultController() == msg.sender\\r\\n    , \\\"not control member\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  // ************** VIEW ********************\\r\\n\\r\\n  /// @notice Return time-lock period (in seconds) saved in the contract slot\\r\\n  /// @return result TimeLock period\\r\\n  function timeLock() public view returns (uint256 result) {\\r\\n    bytes32 slot = _TIME_LOCK_SLOT;\\r\\n    assembly {\\r\\n      result := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Length of the the array of all undone announced actions\\r\\n  /// @return Array length\\r\\n  function timeLockInfosLength() external view returns (uint256) {\\r\\n    return _timeLockInfos.length;\\r\\n  }\\r\\n\\r\\n  /// @notice Return information about announced time-locks for given index\\r\\n  /// @param idx Index of time lock info\\r\\n  /// @return TimeLock information\\r\\n  function timeLockInfo(uint256 idx) external override view returns (TimeLockInfo memory) {\\r\\n    return _timeLockInfos[idx];\\r\\n  }\\r\\n\\r\\n  // ************** ANNOUNCES **************\\r\\n\\r\\n  /// @notice Only Governance can do it.\\r\\n  ///         Announce address change. You will be able to setup new address after Time-lock period\\r\\n  /// @param opCode Operation code from the list\\r\\n  ///                 0 - Governance\\r\\n  ///                 1 - Dao\\r\\n  ///                 2 - FeeRewardForwarder\\r\\n  ///                 3 - Bookkeeper\\r\\n  ///                 4 - MintHelper\\r\\n  ///                 5 - RewardToken\\r\\n  ///                 6 - FundToken\\r\\n  ///                 7 - PsVault\\r\\n  ///                 8 - Fund\\r\\n  ///                 19 - VaultController\\r\\n  /// @param newAddress New address\\r\\n  function announceAddressChange(TimeLockOpCodes opCode, address newAddress) external onlyGovernance {\\r\\n    require(timeLockIndexes[opCode] == 0, \\\"already announced\\\");\\r\\n    require(newAddress != address(0), \\\"zero address\\\");\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, newAddress));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    address[] memory values = new address[](1);\\r\\n    values[0] = newAddress;\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, _controller(), values, new uint256[](0)));\\r\\n    timeLockIndexes[opCode] = (_timeLockInfos.length - 1);\\r\\n\\r\\n    emit AddressChangeAnnounce(opCode, newAddress);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it.\\r\\n  ///         Announce some single uint256 change. You will be able to setup new value after Time-lock period\\r\\n  /// @param opCode Operation code from the list\\r\\n  ///                 20 - RewardBoostDuration\\r\\n  ///                 21 - RewardRatioWithoutBoost\\r\\n  /// @param newValue New value\\r\\n  function announceUintChange(TimeLockOpCodes opCode, uint256 newValue) external onlyGovernance {\\r\\n    require(timeLockIndexes[opCode] == 0, \\\"already announced\\\");\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, newValue));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    uint256[] memory values = new uint256[](1);\\r\\n    values[0] = newValue;\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, address(0), new address[](0), values));\\r\\n    timeLockIndexes[opCode] = (_timeLockInfos.length - 1);\\r\\n\\r\\n    emit UintChangeAnnounce(opCode, newValue);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance or DAO can do it.\\r\\n  ///         Announce ratio change. You will be able to setup new ratio after Time-lock period\\r\\n  /// @param opCode Operation code from the list\\r\\n  ///                 9 - PsRatio\\r\\n  ///                 10 - FundRatio\\r\\n  /// @param numerator New numerator\\r\\n  /// @param denominator New denominator\\r\\n  function announceRatioChange(TimeLockOpCodes opCode, uint256 numerator, uint256 denominator) external override onlyGovernanceOrDao {\\r\\n    require(timeLockIndexes[opCode] == 0, \\\"already announced\\\");\\r\\n    require(numerator <= denominator, \\\"invalid values\\\");\\r\\n    require(denominator != 0, \\\"cannot divide by 0\\\");\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, numerator, denominator));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    uint256[] memory values = new uint256[](2);\\r\\n    values[0] = numerator;\\r\\n    values[1] = denominator;\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, _controller(), new address[](0), values));\\r\\n    timeLockIndexes[opCode] = (_timeLockInfos.length - 1);\\r\\n\\r\\n    emit RatioChangeAnnounced(opCode, numerator, denominator);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce token movement. You will be able to transfer after Time-lock period\\r\\n  /// @param opCode Operation code from the list\\r\\n  ///                 11 - ControllerTokenMove\\r\\n  ///                 12 - StrategyTokenMove\\r\\n  ///                 13 - FundTokenMove\\r\\n  /// @param target Destination of the transfer\\r\\n  /// @param token Token the user wants to move.\\r\\n  /// @param amount Amount that you want to move\\r\\n  function announceTokenMove(TimeLockOpCodes opCode, address target, address token, uint256 amount)\\r\\n  external onlyGovernance {\\r\\n    require(timeLockIndexes[opCode] == 0, \\\"already announced\\\");\\r\\n    require(target != address(0), \\\"zero target\\\");\\r\\n    require(token != address(0), \\\"zero token\\\");\\r\\n    require(amount != 0, \\\"zero amount\\\");\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, target, token, amount));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    address[] memory adrValues = new address[](1);\\r\\n    adrValues[0] = token;\\r\\n    uint256[] memory intValues = new uint256[](1);\\r\\n    intValues[0] = amount;\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, target, adrValues, intValues));\\r\\n    timeLockIndexes[opCode] = (_timeLockInfos.length - 1);\\r\\n\\r\\n    emit TokenMoveAnnounced(opCode, target, token, amount);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce weekly mint. You will able to mint after Time-lock period\\r\\n  /// @param totalAmount Total amount to mint.\\r\\n  ///                    33% will go to current network, 67% to FundKeeper for other networks\\r\\n  /// @param _distributor Distributor address, usually NotifyHelper\\r\\n  /// @param _otherNetworkFund Fund address, usually FundKeeper\\r\\n  function announceMint(\\r\\n    uint256 totalAmount,\\r\\n    address _distributor,\\r\\n    address _otherNetworkFund,\\r\\n    bool mintAllAvailable\\r\\n  ) external onlyGovernance {\\r\\n    TimeLockOpCodes opCode = TimeLockOpCodes.Mint;\\r\\n\\r\\n    require(timeLockIndexes[opCode] == 0, \\\"already announced\\\");\\r\\n    require(totalAmount != 0 || mintAllAvailable, \\\"zero amount\\\");\\r\\n    require(_distributor != address(0), \\\"zero distributor\\\");\\r\\n    require(_otherNetworkFund != address(0), \\\"zero fund\\\");\\r\\n\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, totalAmount, _distributor, _otherNetworkFund, mintAllAvailable));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    address[] memory adrValues = new address[](2);\\r\\n    adrValues[0] = _distributor;\\r\\n    adrValues[1] = _otherNetworkFund;\\r\\n    uint256[] memory intValues = new uint256[](1);\\r\\n    intValues[0] = totalAmount;\\r\\n\\r\\n    address mintHelper = IController(_controller()).mintHelper();\\r\\n\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, mintHelper, adrValues, intValues));\\r\\n    timeLockIndexes[opCode] = _timeLockInfos.length - 1;\\r\\n\\r\\n    emit MintAnnounced(totalAmount, _distributor, _otherNetworkFund);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce Batch Proxy upgrade\\r\\n  /// @param _contracts Array of Proxy contract addresses for upgrade\\r\\n  /// @param _implementations Array of New implementation addresses\\r\\n  function announceTetuProxyUpgradeBatch(address[] calldata _contracts, address[] calldata _implementations)\\r\\n  external onlyGovernance {\\r\\n    require(_contracts.length == _implementations.length, \\\"wrong arrays\\\");\\r\\n    for (uint256 i = 0; i < _contracts.length; i++) {\\r\\n      announceTetuProxyUpgrade(_contracts[i], _implementations[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce Proxy upgrade. You will able to mint after Time-lock period\\r\\n  /// @param _contract Proxy contract address for upgrade\\r\\n  /// @param _implementation New implementation address\\r\\n  function announceTetuProxyUpgrade(address _contract, address _implementation) public onlyGovernance {\\r\\n    TimeLockOpCodes opCode = TimeLockOpCodes.TetuProxyUpdate;\\r\\n\\r\\n    require(multiTimeLockIndexes[opCode][_contract] == 0, \\\"already announced\\\");\\r\\n    require(_contract != address(0), \\\"zero contract\\\");\\r\\n    require(_implementation != address(0), \\\"zero implementation\\\");\\r\\n\\r\\n    bytes32 opHash = keccak256(abi.encode(opCode, _contract, _implementation));\\r\\n    timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n    address[] memory values = new address[](1);\\r\\n    values[0] = _implementation;\\r\\n    _timeLockInfos.push(TimeLockInfo(opCode, opHash, _contract, values, new uint256[](0)));\\r\\n    multiTimeLockIndexes[opCode][_contract] = (_timeLockInfos.length - 1);\\r\\n\\r\\n    emit ProxyUpgradeAnnounced(_contract, _implementation);\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce strategy update for given vaults\\r\\n  /// @param _targets Vault addresses\\r\\n  /// @param _strategies Strategy addresses\\r\\n  function announceStrategyUpgrades(address[] calldata _targets, address[] calldata _strategies) external onlyGovernance {\\r\\n    TimeLockOpCodes opCode = TimeLockOpCodes.StrategyUpgrade;\\r\\n    require(_targets.length == _strategies.length, \\\"wrong arrays\\\");\\r\\n    for (uint256 i = 0; i < _targets.length; i++) {\\r\\n      require(multiTimeLockIndexes[opCode][_targets[i]] == 0, \\\"already announced\\\");\\r\\n      bytes32 opHash = keccak256(abi.encode(opCode, _targets[i], _strategies[i]));\\r\\n      timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n      address[] memory values = new address[](1);\\r\\n      values[0] = _strategies[i];\\r\\n      _timeLockInfos.push(TimeLockInfo(opCode, opHash, _targets[i], values, new uint256[](0)));\\r\\n      multiTimeLockIndexes[opCode][_targets[i]] = (_timeLockInfos.length - 1);\\r\\n\\r\\n      emit StrategyUpgradeAnnounced(_targets[i], _strategies[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Only Governance can do it. Announce the stop vault action\\r\\n  /// @param _vaults Vault addresses\\r\\n  function announceVaultStopBatch(address[] calldata _vaults) external onlyGovernance {\\r\\n    TimeLockOpCodes opCode = TimeLockOpCodes.VaultStop;\\r\\n    for (uint256 i = 0; i < _vaults.length; i++) {\\r\\n      require(multiTimeLockIndexes[opCode][_vaults[i]] == 0, \\\"already announced\\\");\\r\\n      bytes32 opHash = keccak256(abi.encode(opCode, _vaults[i]));\\r\\n      timeLockSchedule[opHash] = block.timestamp + timeLock();\\r\\n\\r\\n      _timeLockInfos.push(TimeLockInfo(opCode, opHash, _vaults[i], new address[](0), new uint256[](0)));\\r\\n      multiTimeLockIndexes[opCode][_vaults[i]] = (_timeLockInfos.length - 1);\\r\\n\\r\\n      emit VaultStop(_vaults[i]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Close any announce. Use in emergency case.\\r\\n  /// @param opCode TimeLockOpCodes uint8 value\\r\\n  /// @param opHash keccak256(abi.encode()) code with attributes.\\r\\n  /// @param target Address for multi time lock. Set zero address if not required.\\r\\n  function closeAnnounce(TimeLockOpCodes opCode, bytes32 opHash, address target) external onlyGovernance {\\r\\n    clearAnnounce(opHash, opCode, target);\\r\\n    emit AnnounceClosed(opHash);\\r\\n  }\\r\\n\\r\\n  /// @notice Only controller can use it. Clear announce after successful call time-locked function\\r\\n  /// @param opHash Generated keccak256 opHash\\r\\n  /// @param opCode TimeLockOpCodes uint8 value\\r\\n  function clearAnnounce(bytes32 opHash, TimeLockOpCodes opCode, address target) public override onlyControlMembers {\\r\\n    timeLockSchedule[opHash] = 0;\\r\\n    if (multiTimeLockIndexes[opCode][target] != 0) {\\r\\n      multiTimeLockIndexes[opCode][target] = 0;\\r\\n    } else {\\r\\n      timeLockIndexes[opCode] = 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/governance/ControllableV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"../../openzeppelin/Initializable.sol\\\";\\r\\nimport \\\"../interface/IControllable.sol\\\";\\r\\nimport \\\"../interface/IControllableExtended.sol\\\";\\r\\nimport \\\"../interface/IController.sol\\\";\\r\\n\\r\\n/// @title Implement basic functionality for any contract that require strict control\\r\\n///        V2 is optimised version for less gas consumption\\r\\n/// @dev Can be used with upgradeable pattern.\\r\\n///      Require call initializeControllable() in any case.\\r\\n/// @author belbix\\r\\nabstract contract ControllableV2 is Initializable, IControllable, IControllableExtended {\\r\\n\\r\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\r\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\r\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\r\\n\\r\\n  event ContractInitialized(address controller, uint ts, uint block);\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\r\\n  /// @dev Use it only once after first logic setup\\r\\n  /// @param __controller Controller address\\r\\n  function initializeControllable(address __controller) public initializer {\\r\\n    _setController(__controller);\\r\\n    _setCreated(block.timestamp);\\r\\n    _setCreatedBlock(block.number);\\r\\n    emit ContractInitialized(__controller, block.timestamp, block.number);\\r\\n  }\\r\\n\\r\\n  /// @dev Return true if given address is controller\\r\\n  function isController(address _value) external override view returns (bool) {\\r\\n    return _isController(_value);\\r\\n  }\\r\\n\\r\\n  function _isController(address _value) internal view returns (bool) {\\r\\n    return _value == _controller();\\r\\n  }\\r\\n\\r\\n  /// @notice Return true if given address is setup as governance in Controller\\r\\n  function isGovernance(address _value) external override view returns (bool) {\\r\\n    return _isGovernance(_value);\\r\\n  }\\r\\n\\r\\n  function _isGovernance(address _value) internal view returns (bool) {\\r\\n    return IController(_controller()).governance() == _value;\\r\\n  }\\r\\n\\r\\n  // ************* SETTERS/GETTERS *******************\\r\\n\\r\\n  /// @notice Return controller address saved in the contract slot\\r\\n  function controller() external view override returns (address) {\\r\\n    return _controller();\\r\\n  }\\r\\n\\r\\n  function _controller() internal view returns (address result) {\\r\\n    bytes32 slot = _CONTROLLER_SLOT;\\r\\n    assembly {\\r\\n      result := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Set a controller address to contract slot\\r\\n  function _setController(address _newController) private {\\r\\n    require(_newController != address(0));\\r\\n    bytes32 slot = _CONTROLLER_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _newController)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Return creation timestamp\\r\\n  /// @return ts Creation timestamp\\r\\n  function created() external view override returns (uint256 ts) {\\r\\n    bytes32 slot = _CREATED_SLOT;\\r\\n    assembly {\\r\\n      ts := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Filled only once when contract initialized\\r\\n  /// @param _value block.timestamp\\r\\n  function _setCreated(uint256 _value) private {\\r\\n    bytes32 slot = _CREATED_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _value)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Return creation block number\\r\\n  /// @return ts Creation block number\\r\\n  function createdBlock() external view returns (uint256 ts) {\\r\\n    bytes32 slot = _CREATED_BLOCK_SLOT;\\r\\n    assembly {\\r\\n      ts := sload(slot)\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Filled only once when contract initialized\\r\\n  /// @param _value block.number\\r\\n  function _setCreatedBlock(uint256 _value) private {\\r\\n    bytes32 slot = _CREATED_BLOCK_SLOT;\\r\\n    assembly {\\r\\n      sstore(slot, _value)\\r\\n    }\\r\\n  }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/governance/ControllerStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"../interface/IController.sol\\\";\\r\\nimport \\\"../../openzeppelin/Initializable.sol\\\";\\r\\n\\r\\n/// @title Eternal storage + getters and setters pattern\\r\\n/// @dev If a key value is changed it will be required to setup it again.\\r\\n/// @author belbix\\r\\nabstract contract ControllerStorage is Initializable, IController {\\r\\n\\r\\n  // don't change names or ordering!\\r\\n  mapping(bytes32 => uint256) private uintStorage;\\r\\n  mapping(bytes32 => address) private addressStorage;\\r\\n\\r\\n  /// @notice Address changed the variable with `name`\\r\\n  event UpdatedAddressSlot(string indexed name, address oldValue, address newValue);\\r\\n  /// @notice Value changed the variable with `name`\\r\\n  event UpdatedUint256Slot(string indexed name, uint256 oldValue, uint256 newValue);\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  /// @dev Use it only once after first logic setup\\r\\n  /// @param __governance Governance address\\r\\n  function initializeControllerStorage(\\r\\n    address __governance\\r\\n  ) public initializer {\\r\\n    _setGovernance(__governance);\\r\\n  }\\r\\n\\r\\n  // ******************* SETTERS AND GETTERS **********************\\r\\n\\r\\n  // ----------- ADDRESSES ----------\\r\\n  function _setGovernance(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"governance\\\", _governance(), _address);\\r\\n    setAddress(\\\"governance\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return governance address\\r\\n  /// @return Governance address\\r\\n  function governance() external override view returns (address) {\\r\\n    return _governance();\\r\\n  }\\r\\n\\r\\n  function _governance() internal view returns (address) {\\r\\n    return getAddress(\\\"governance\\\");\\r\\n  }\\r\\n\\r\\n  function _setDao(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"dao\\\", _dao(), _address);\\r\\n    setAddress(\\\"dao\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return DAO address\\r\\n  /// @return DAO address\\r\\n  function dao() external override view returns (address) {\\r\\n    return _dao();\\r\\n  }\\r\\n\\r\\n  function _dao() internal view returns (address) {\\r\\n    return getAddress(\\\"dao\\\");\\r\\n  }\\r\\n\\r\\n  function _setFeeRewardForwarder(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"feeRewardForwarder\\\", feeRewardForwarder(), _address);\\r\\n    setAddress(\\\"feeRewardForwarder\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return FeeRewardForwarder address\\r\\n  /// @return FeeRewardForwarder address\\r\\n  function feeRewardForwarder() public override view returns (address) {\\r\\n    return getAddress(\\\"feeRewardForwarder\\\");\\r\\n  }\\r\\n\\r\\n  function _setBookkeeper(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"bookkeeper\\\", _bookkeeper(), _address);\\r\\n    setAddress(\\\"bookkeeper\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Bookkeeper address\\r\\n  /// @return Bookkeeper address\\r\\n  function bookkeeper() external override view returns (address) {\\r\\n    return _bookkeeper();\\r\\n  }\\r\\n\\r\\n  function _bookkeeper() internal view returns (address) {\\r\\n    return getAddress(\\\"bookkeeper\\\");\\r\\n  }\\r\\n\\r\\n  function _setMintHelper(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"mintHelper\\\", mintHelper(), _address);\\r\\n    setAddress(\\\"mintHelper\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return MintHelper address\\r\\n  /// @return MintHelper address\\r\\n  function mintHelper() public override view returns (address) {\\r\\n    return getAddress(\\\"mintHelper\\\");\\r\\n  }\\r\\n\\r\\n  function _setRewardToken(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"rewardToken\\\", rewardToken(), _address);\\r\\n    setAddress(\\\"rewardToken\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return TETU address\\r\\n  /// @return TETU address\\r\\n  function rewardToken() public override view returns (address) {\\r\\n    return getAddress(\\\"rewardToken\\\");\\r\\n  }\\r\\n\\r\\n  function _setFundToken(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"fundToken\\\", fundToken(), _address);\\r\\n    setAddress(\\\"fundToken\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return a token address used for FundKeeper\\r\\n  /// @return FundKeeper's main token address\\r\\n  function fundToken() public override view returns (address) {\\r\\n    return getAddress(\\\"fundToken\\\");\\r\\n  }\\r\\n\\r\\n  function _setPsVault(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"psVault\\\", psVault(), _address);\\r\\n    setAddress(\\\"psVault\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Profit Sharing pool address\\r\\n  /// @return Profit Sharing pool address\\r\\n  function psVault() public override view returns (address) {\\r\\n    return getAddress(\\\"psVault\\\");\\r\\n  }\\r\\n\\r\\n  function _setFund(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"fund\\\", fund(), _address);\\r\\n    setAddress(\\\"fund\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return FundKeeper address\\r\\n  /// @return FundKeeper address\\r\\n  function fund() public override view returns (address) {\\r\\n    return getAddress(\\\"fund\\\");\\r\\n  }\\r\\n\\r\\n  function _setDistributor(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"distributor\\\", distributor(), _address);\\r\\n    setAddress(\\\"distributor\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Reward distributor address\\r\\n  /// @return Distributor address\\r\\n  function distributor() public override view returns (address) {\\r\\n    return getAddress(\\\"distributor\\\");\\r\\n  }\\r\\n\\r\\n  function _setAnnouncer(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"announcer\\\", _announcer(), _address);\\r\\n    setAddress(\\\"announcer\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Announcer address\\r\\n  /// @return Announcer address\\r\\n  function announcer() external override view returns (address) {\\r\\n    return _announcer();\\r\\n  }\\r\\n\\r\\n  function _announcer() internal view returns (address) {\\r\\n    return getAddress(\\\"announcer\\\");\\r\\n  }\\r\\n\\r\\n  function _setVaultController(address _address) internal {\\r\\n    emit UpdatedAddressSlot(\\\"vaultController\\\", vaultController(), _address);\\r\\n    setAddress(\\\"vaultController\\\", _address);\\r\\n  }\\r\\n\\r\\n  /// @notice Return FundKeeper address\\r\\n  /// @return FundKeeper address\\r\\n  function vaultController() public override view returns (address) {\\r\\n    return getAddress(\\\"vaultController\\\");\\r\\n  }\\r\\n\\r\\n  // ----------- INTEGERS ----------\\r\\n  function _setPsNumerator(uint256 _value) internal {\\r\\n    emit UpdatedUint256Slot(\\\"psNumerator\\\", psNumerator(), _value);\\r\\n    setUint256(\\\"psNumerator\\\", _value);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Profit Sharing pool ratio's numerator\\r\\n  /// @return Profit Sharing pool ratio numerator\\r\\n  function psNumerator() public view override returns (uint256) {\\r\\n    return getUint256(\\\"psNumerator\\\");\\r\\n  }\\r\\n\\r\\n  function _setPsDenominator(uint256 _value) internal {\\r\\n    emit UpdatedUint256Slot(\\\"psDenominator\\\", psDenominator(), _value);\\r\\n    setUint256(\\\"psDenominator\\\", _value);\\r\\n  }\\r\\n\\r\\n  /// @notice Return Profit Sharing pool ratio's denominator\\r\\n  /// @return Profit Sharing pool ratio denominator\\r\\n  function psDenominator() public view override returns (uint256) {\\r\\n    return getUint256(\\\"psDenominator\\\");\\r\\n  }\\r\\n\\r\\n  function _setFundNumerator(uint256 _value) internal {\\r\\n    emit UpdatedUint256Slot(\\\"fundNumerator\\\", fundNumerator(), _value);\\r\\n    setUint256(\\\"fundNumerator\\\", _value);\\r\\n  }\\r\\n\\r\\n  /// @notice Return FundKeeper ratio's numerator\\r\\n  /// @return FundKeeper ratio numerator\\r\\n  function fundNumerator() public view override returns (uint256) {\\r\\n    return getUint256(\\\"fundNumerator\\\");\\r\\n  }\\r\\n\\r\\n  function _setFundDenominator(uint256 _value) internal {\\r\\n    emit UpdatedUint256Slot(\\\"fundDenominator\\\", fundDenominator(), _value);\\r\\n    setUint256(\\\"fundDenominator\\\", _value);\\r\\n  }\\r\\n\\r\\n  /// @notice Return FundKeeper ratio's denominator\\r\\n  /// @return FundKeeper ratio denominator\\r\\n  function fundDenominator() public view override returns (uint256) {\\r\\n    return getUint256(\\\"fundDenominator\\\");\\r\\n  }\\r\\n\\r\\n  // ******************** STORAGE INTERNAL FUNCTIONS ********************\\r\\n\\r\\n  function setAddress(string memory key, address _address) private {\\r\\n    addressStorage[keccak256(abi.encodePacked(key))] = _address;\\r\\n  }\\r\\n\\r\\n  function getAddress(string memory key) private view returns (address) {\\r\\n    return addressStorage[keccak256(abi.encodePacked(key))];\\r\\n  }\\r\\n\\r\\n  function setUint256(string memory key, uint256 _value) private {\\r\\n    uintStorage[keccak256(abi.encodePacked(key))] = _value;\\r\\n  }\\r\\n\\r\\n  function getUint256(string memory key) private view returns (uint256) {\\r\\n    return uintStorage[keccak256(abi.encodePacked(key))];\\r\\n  }\\r\\n\\r\\n  //slither-disable-next-line unused-state\\r\\n  uint256[50] private ______gap;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IAnnouncer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IAnnouncer {\\r\\n\\r\\n  /// @dev Time lock operation codes\\r\\n  enum TimeLockOpCodes {\\r\\n    // TimeLockedAddresses\\r\\n    Governance, // 0\\r\\n    Dao, // 1\\r\\n    FeeRewardForwarder, // 2\\r\\n    Bookkeeper, // 3\\r\\n    MintHelper, // 4\\r\\n    RewardToken, // 5\\r\\n    FundToken, // 6\\r\\n    PsVault, // 7\\r\\n    Fund, // 8\\r\\n    // TimeLockedRatios\\r\\n    PsRatio, // 9\\r\\n    FundRatio, // 10\\r\\n    // TimeLockedTokenMoves\\r\\n    ControllerTokenMove, // 11\\r\\n    StrategyTokenMove, // 12\\r\\n    FundTokenMove, // 13\\r\\n    // Other\\r\\n    TetuProxyUpdate, // 14\\r\\n    StrategyUpgrade, // 15\\r\\n    Mint, // 16\\r\\n    Announcer, // 17\\r\\n    ZeroPlaceholder, //18\\r\\n    VaultController, //19\\r\\n    RewardBoostDuration, //20\\r\\n    RewardRatioWithoutBoost, //21\\r\\n    VaultStop //22\\r\\n  }\\r\\n\\r\\n  /// @dev Holder for human readable info\\r\\n  struct TimeLockInfo {\\r\\n    TimeLockOpCodes opCode;\\r\\n    bytes32 opHash;\\r\\n    address target;\\r\\n    address[] adrValues;\\r\\n    uint256[] numValues;\\r\\n  }\\r\\n\\r\\n  function clearAnnounce(bytes32 opHash, TimeLockOpCodes opCode, address target) external;\\r\\n\\r\\n  function timeLockSchedule(bytes32 opHash) external returns (uint256);\\r\\n\\r\\n  function timeLockInfo(uint256 idx) external returns (TimeLockInfo memory);\\r\\n\\r\\n  // ************ DAO ACTIONS *************\\r\\n  function announceRatioChange(TimeLockOpCodes opCode, uint256 numerator, uint256 denominator) external;\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/openzeppelin/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\r\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\r\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\r\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\r\\n *\\r\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\r\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\r\\n *\\r\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\r\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\r\\n */\\r\\nabstract contract Initializable {\\r\\n  /**\\r\\n   * @dev Indicates that the contract has been initialized.\\r\\n   */\\r\\n  bool private _initialized;\\r\\n\\r\\n  /**\\r\\n   * @dev Indicates that the contract is in the process of being initialized.\\r\\n   */\\r\\n  bool private _initializing;\\r\\n\\r\\n  /**\\r\\n   * @dev Modifier to protect an initializer function from being invoked twice.\\r\\n   */\\r\\n  modifier initializer() {\\r\\n    require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n    bool isTopLevelCall = !_initializing;\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = true;\\r\\n      _initialized = true;\\r\\n    }\\r\\n\\r\\n    _;\\r\\n\\r\\n    if (isTopLevelCall) {\\r\\n      _initializing = false;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IControllable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IControllable {\\r\\n\\r\\n  function isController(address _contract) external view returns (bool);\\r\\n\\r\\n  function isGovernance(address _contract) external view returns (bool);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IControllableExtended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/// @dev This interface contains additional functions for Controllable class\\r\\n///      Don't extend the exist Controllable for the reason of huge coherence\\r\\ninterface IControllableExtended {\\r\\n\\r\\n  function created() external view returns (uint256 ts);\\r\\n\\r\\n  function controller() external view returns (address adr);\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/base/interface/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: ISC\\r\\n/**\\r\\n* By using this software, you understand, acknowledge and accept that Tetu\\r\\n* and/or the underlying software are provided \u201cas is\u201d and \u201cas available\u201d\\r\\n* basis and without warranties or representations of any kind either expressed\\r\\n* or implied. Any use of this open source software released under the ISC\\r\\n* Internet Systems Consortium license is done at your own risk to the fullest\\r\\n* extent permissible pursuant to applicable law any and all liability as well\\r\\n* as all warranties, including any fitness for a particular purpose with respect\\r\\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\ninterface IController {\\r\\n\\r\\n  function addVaultsAndStrategies(address[] memory _vaults, address[] memory _strategies) external;\\r\\n\\r\\n  function addStrategy(address _strategy) external;\\r\\n\\r\\n  function governance() external view returns (address);\\r\\n\\r\\n  function dao() external view returns (address);\\r\\n\\r\\n  function bookkeeper() external view returns (address);\\r\\n\\r\\n  function feeRewardForwarder() external view returns (address);\\r\\n\\r\\n  function mintHelper() external view returns (address);\\r\\n\\r\\n  function rewardToken() external view returns (address);\\r\\n\\r\\n  function fundToken() external view returns (address);\\r\\n\\r\\n  function psVault() external view returns (address);\\r\\n\\r\\n  function fund() external view returns (address);\\r\\n\\r\\n  function distributor() external view returns (address);\\r\\n\\r\\n  function announcer() external view returns (address);\\r\\n\\r\\n  function vaultController() external view returns (address);\\r\\n\\r\\n  function whiteList(address _target) external view returns (bool);\\r\\n\\r\\n  function vaults(address _target) external view returns (bool);\\r\\n\\r\\n  function strategies(address _target) external view returns (bool);\\r\\n\\r\\n  function psNumerator() external view returns (uint256);\\r\\n\\r\\n  function psDenominator() external view returns (uint256);\\r\\n\\r\\n  function fundNumerator() external view returns (uint256);\\r\\n\\r\\n  function fundDenominator() external view returns (uint256);\\r\\n\\r\\n  function isAllowedUser(address _adr) external view returns (bool);\\r\\n\\r\\n  function isDao(address _adr) external view returns (bool);\\r\\n\\r\\n  function isHardWorker(address _adr) external view returns (bool);\\r\\n\\r\\n  function isRewardDistributor(address _adr) external view returns (bool);\\r\\n\\r\\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\\r\\n\\r\\n  function isValidVault(address _vault) external view returns (bool);\\r\\n\\r\\n  function isValidStrategy(address _strategy) external view returns (bool);\\r\\n\\r\\n  function rebalance(address _strategy) external;\\r\\n\\r\\n  // ************ DAO ACTIONS *************\\r\\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator) external;\\r\\n\\r\\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator) external;\\r\\n\\r\\n  function changeWhiteListStatus(address[] calldata _targets, bool status) external;\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 150\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"AddressChangeAnnounce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"opHash\",\"type\":\"bytes32\"}],\"name\":\"AnnounceClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_otherNetworkFund\",\"type\":\"address\"}],\"name\":\"MintAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"ProxyUpgradeAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"RatioChangeAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"StrategyUpgradeAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenMoveAnnounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"UintChangeAnnounce\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"VaultStop\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"announceAddressChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_distributor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_otherNetworkFund\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"mintAllAvailable\",\"type\":\"bool\"}],\"name\":\"announceMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"numerator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"announceRatioChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_targets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_strategies\",\"type\":\"address[]\"}],\"name\":\"announceStrategyUpgrades\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"announceTetuProxyUpgrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_contracts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_implementations\",\"type\":\"address[]\"}],\"name\":\"announceTetuProxyUpgradeBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"announceTokenMove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"announceUintChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_vaults\",\"type\":\"address[]\"}],\"name\":\"announceVaultStopBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"opHash\",\"type\":\"bytes32\"},{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"clearAnnounce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"opHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"closeAnnounce\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timeLock\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__controller\",\"type\":\"address\"}],\"name\":\"initializeControllable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"multiOpCodes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"multiTimeLockIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"timeLockIndexes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"timeLockInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IAnnouncer.TimeLockOpCodes\",\"name\":\"opCode\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"opHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"adrValues\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"numValues\",\"type\":\"uint256[]\"}],\"internalType\":\"struct IAnnouncer.TimeLockInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeLockInfosLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"timeLockSchedule\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Announcer", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "150", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}