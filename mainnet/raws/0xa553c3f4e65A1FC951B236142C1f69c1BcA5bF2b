{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/commands/CloseCommand.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\nimport \\\"../interfaces/ICommand.sol\\\";\\nimport \\\"../interfaces/ManagerLike.sol\\\";\\nimport \\\"../interfaces/BotLike.sol\\\";\\nimport \\\"../interfaces/MPALike.sol\\\";\\nimport \\\"../ServiceRegistry.sol\\\";\\nimport \\\"../McdView.sol\\\";\\n\\ncontract CloseCommand is ICommand {\\n    address public immutable serviceRegistry;\\n    string private constant CDP_MANAGER_KEY = \\\"CDP_MANAGER\\\";\\n    string private constant MCD_VIEW_KEY = \\\"MCD_VIEW\\\";\\n    string private constant MPA_KEY = \\\"MULTIPLY_PROXY_ACTIONS\\\";\\n\\n    constructor(address _serviceRegistry) {\\n        serviceRegistry = _serviceRegistry;\\n    }\\n\\n    function isExecutionCorrect(uint256 cdpId, bytes memory) external view override returns (bool) {\\n        address viewAddress = ServiceRegistry(serviceRegistry).getRegisteredService(MCD_VIEW_KEY);\\n        McdView viewerContract = McdView(viewAddress);\\n        (uint256 collateral, uint256 debt) = viewerContract.getVaultInfo(cdpId);\\n        return !(collateral > 0 || debt > 0);\\n    }\\n\\n    function isExecutionLegal(uint256 _cdpId, bytes memory triggerData)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        (, , uint256 slLevel) = abi.decode(triggerData, (uint256, uint16, uint256));\\n\\n        address managerAddress = ServiceRegistry(serviceRegistry).getRegisteredService(\\n            CDP_MANAGER_KEY\\n        );\\n        ManagerLike manager = ManagerLike(managerAddress);\\n        if (manager.owns(_cdpId) == address(0)) {\\n            return false;\\n        }\\n        address viewAddress = ServiceRegistry(serviceRegistry).getRegisteredService(MCD_VIEW_KEY);\\n        uint256 collRatio = McdView(viewAddress).getRatio(_cdpId, true);\\n        bool vaultNotEmpty = collRatio != 0; // MCD_VIEW contract returns 0 (instead of infinity) as a collateralisation ratio of empty vault\\n        return vaultNotEmpty && collRatio <= slLevel * 10**16;\\n    }\\n\\n    function execute(\\n        bytes calldata executionData,\\n        uint256,\\n        bytes memory triggerData\\n    ) external override {\\n        (, uint16 triggerType, ) = abi.decode(triggerData, (uint256, uint16, uint256));\\n\\n        address mpaAddress = ServiceRegistry(serviceRegistry).getRegisteredService(MPA_KEY);\\n\\n        bytes4 prefix = abi.decode(executionData, (bytes4));\\n        bytes4 expectedSelector;\\n\\n        if (triggerType == 1) {\\n            expectedSelector = MPALike.closeVaultExitCollateral.selector;\\n        } else if (triggerType == 2) {\\n            expectedSelector = MPALike.closeVaultExitDai.selector;\\n        } else revert(\\\"unsupported-triggerType\\\");\\n\\n        require(prefix == expectedSelector, \\\"wrong-payload\\\");\\n        //since all global values in this contract are either const or immutable, this delegate call do not break any storage\\n        //this is simplest approach, most similar to way we currently call dsProxy\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool status, ) = mpaAddress.delegatecall(executionData);\\n\\n        require(status, \\\"execution failed\\\");\\n    }\\n\\n    function isTriggerDataValid(uint256 _cdpId, bytes memory triggerData)\\n        external\\n        pure\\n        override\\n        returns (bool)\\n    {\\n        (uint256 cdpId, uint16 triggerType, uint256 slLevel) = abi.decode(\\n            triggerData,\\n            (uint256, uint16, uint256)\\n        );\\n        return slLevel > 100 && _cdpId == cdpId && (triggerType == 1 || triggerType == 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICommand.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface ICommand {\\n    function isTriggerDataValid(uint256 _cdpId, bytes memory triggerData)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExecutionCorrect(uint256 cdpId, bytes memory triggerData)\\n        external\\n        view\\n        returns (bool);\\n\\n    function isExecutionLegal(uint256 cdpId, bytes memory triggerData) external view returns (bool);\\n\\n    function execute(\\n        bytes calldata executionData,\\n        uint256 cdpId,\\n        bytes memory triggerData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ManagerLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface ManagerLike {\\n    function cdpCan(\\n        address owner,\\n        uint256 cdpId,\\n        address allowedAddr\\n    ) external view returns (uint256);\\n\\n    function vat() external view returns (address);\\n\\n    function ilks(uint256) external view returns (bytes32);\\n\\n    function owns(uint256) external view returns (address);\\n\\n    function urns(uint256) external view returns (address);\\n\\n    function cdpAllow(\\n        uint256 cdp,\\n        address usr,\\n        uint256 ok\\n    ) external;\\n\\n    function frob(\\n        uint256,\\n        int256,\\n        int256\\n    ) external;\\n\\n    function flux(\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function move(\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function exit(\\n        address,\\n        uint256,\\n        address,\\n        uint256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/BotLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface BotLike {\\n    function addRecord(\\n        uint256 cdpId,\\n        uint256 triggerType,\\n        uint256 replacedTriggerId,\\n        bytes memory triggerData\\n    ) external;\\n\\n    function removeRecord(\\n        // This function should be executed allways in a context of AutomationBot address not DsProxy,\\n        //msg.sender should be dsProxy\\n        uint256 cdpId,\\n        uint256 triggerId\\n    ) external;\\n\\n    function execute(\\n        bytes calldata executionData,\\n        uint256 cdpId,\\n        bytes calldata triggerData,\\n        address commandAddress,\\n        uint256 triggerId,\\n        uint256 daiCoverage\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/MPALike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface MPALike {\\n    struct CdpData {\\n        address gemJoin;\\n        address payable fundsReceiver;\\n        uint256 cdpId;\\n        bytes32 ilk;\\n        uint256 requiredDebt;\\n        uint256 borrowCollateral;\\n        uint256 withdrawCollateral;\\n        uint256 withdrawDai;\\n        uint256 depositDai;\\n        uint256 depositCollateral;\\n        bool skipFL;\\n        string methodName;\\n    }\\n\\n    struct AddressRegistry {\\n        address jug;\\n        address manager;\\n        address multiplyProxyActions;\\n        address lender;\\n        address exchange;\\n    }\\n\\n    struct ExchangeData {\\n        address fromTokenAddress;\\n        address toTokenAddress;\\n        uint256 fromTokenAmount;\\n        uint256 toTokenAmount;\\n        uint256 minToTokenAmount;\\n        address exchangeAddress;\\n        bytes _exchangeCalldata;\\n    }\\n\\n    function closeVaultExitCollateral(\\n        ExchangeData calldata exchangeData,\\n        CdpData memory cdpData,\\n        AddressRegistry calldata addressRegistry\\n    ) external;\\n\\n    function closeVaultExitDai(\\n        ExchangeData calldata exchangeData,\\n        CdpData memory cdpData,\\n        AddressRegistry calldata addressRegistry\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/ServiceRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract ServiceRegistry {\\n    uint256 public constant MAX_DELAY = 30 days;\\n\\n    mapping(bytes32 => uint256) public lastExecuted;\\n    mapping(bytes32 => address) private namedService;\\n    address public owner;\\n    uint256 public requiredDelay;\\n\\n    modifier validateInput(uint256 len) {\\n        require(msg.data.length == len, \\\"registry/illegal-padding\\\");\\n        _;\\n    }\\n\\n    modifier delayedExecution() {\\n        bytes32 operationHash = keccak256(msg.data);\\n        uint256 reqDelay = requiredDelay;\\n\\n        /* solhint-disable not-rely-on-time */\\n        if (lastExecuted[operationHash] == 0 && reqDelay > 0) {\\n            // not called before, scheduled for execution\\n            lastExecuted[operationHash] = block.timestamp;\\n            emit ChangeScheduled(operationHash, block.timestamp + reqDelay, msg.data);\\n        } else {\\n            require(\\n                block.timestamp - reqDelay > lastExecuted[operationHash],\\n                \\\"registry/delay-too-small\\\"\\n            );\\n            emit ChangeApplied(operationHash, block.timestamp, msg.data);\\n            _;\\n            lastExecuted[operationHash] = 0;\\n        }\\n        /* solhint-enable not-rely-on-time */\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, \\\"registry/only-owner\\\");\\n        _;\\n    }\\n\\n    constructor(uint256 initialDelay) {\\n        require(initialDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = initialDelay;\\n        owner = msg.sender;\\n    }\\n\\n    function transferOwnership(address newOwner)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n        delayedExecution\\n    {\\n        owner = newOwner;\\n    }\\n\\n    function changeRequiredDelay(uint256 newDelay)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n        delayedExecution\\n    {\\n        require(newDelay <= MAX_DELAY, \\\"registry/invalid-delay\\\");\\n        requiredDelay = newDelay;\\n    }\\n\\n    function getServiceNameHash(string memory name) external pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(name));\\n    }\\n\\n    function addNamedService(bytes32 serviceNameHash, address serviceAddress)\\n        external\\n        onlyOwner\\n        validateInput(68)\\n        delayedExecution\\n    {\\n        require(namedService[serviceNameHash] == address(0), \\\"registry/service-override\\\");\\n        namedService[serviceNameHash] = serviceAddress;\\n    }\\n\\n    function updateNamedService(bytes32 serviceNameHash, address serviceAddress)\\n        external\\n        onlyOwner\\n        validateInput(68)\\n        delayedExecution\\n    {\\n        require(namedService[serviceNameHash] != address(0), \\\"registry/service-does-not-exist\\\");\\n        namedService[serviceNameHash] = serviceAddress;\\n    }\\n\\n    function removeNamedService(bytes32 serviceNameHash) external onlyOwner validateInput(36) {\\n        require(namedService[serviceNameHash] != address(0), \\\"registry/service-does-not-exist\\\");\\n        namedService[serviceNameHash] = address(0);\\n        emit NamedServiceRemoved(serviceNameHash);\\n    }\\n\\n    function getRegisteredService(string memory serviceName) external view returns (address) {\\n        return namedService[keccak256(abi.encodePacked(serviceName))];\\n    }\\n\\n    function getServiceAddress(bytes32 serviceNameHash) external view returns (address) {\\n        return namedService[serviceNameHash];\\n    }\\n\\n    function clearScheduledExecution(bytes32 scheduledExecution)\\n        external\\n        onlyOwner\\n        validateInput(36)\\n    {\\n        require(lastExecuted[scheduledExecution] > 0, \\\"registry/execution-not-scheduled\\\");\\n        lastExecuted[scheduledExecution] = 0;\\n        emit ChangeCancelled(scheduledExecution);\\n    }\\n\\n    event ChangeScheduled(bytes32 dataHash, uint256 scheduledFor, bytes data);\\n    event ChangeApplied(bytes32 dataHash, uint256 appliedAt, bytes data);\\n    event ChangeCancelled(bytes32 dataHash);\\n    event NamedServiceRemoved(bytes32 nameHash);\\n}\\n\"\r\n    },\r\n    \"contracts/McdView.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\nimport \\\"./interfaces/ManagerLike.sol\\\";\\nimport \\\"./interfaces/ICommand.sol\\\";\\nimport \\\"./interfaces/BotLike.sol\\\";\\nimport \\\"./ServiceRegistry.sol\\\";\\n\\nimport \\\"./interfaces/SpotterLike.sol\\\";\\nimport \\\"./interfaces/VatLike.sol\\\";\\nimport \\\"./interfaces/OsmMomLike.sol\\\";\\nimport \\\"./interfaces/OsmLike.sol\\\";\\nimport \\\"./external/DSMath.sol\\\";\\n\\n/// @title Getter contract for Vault info from Maker protocol\\ncontract McdView is DSMath {\\n    ManagerLike public manager;\\n    VatLike public vat;\\n    SpotterLike public spotter;\\n    OsmMomLike public osmMom;\\n    address public owner;\\n    mapping(address => bool) public whitelisted;\\n\\n    constructor(\\n        address _vat,\\n        address _manager,\\n        address _spotter,\\n        address _mom,\\n        address _owner\\n    ) {\\n        manager = ManagerLike(_manager);\\n        vat = VatLike(_vat);\\n        spotter = SpotterLike(_spotter);\\n        osmMom = OsmMomLike(_mom);\\n        owner = _owner;\\n    }\\n\\n    function approve(address _allowedReader, bool isApproved) external {\\n        require(msg.sender == owner, \\\"mcd-view/not-authorised\\\");\\n        whitelisted[_allowedReader] = isApproved;\\n    }\\n\\n    /// @notice Gets Vault info (collateral, debt)\\n    /// @param vaultId Id of the Vault\\n    function getVaultInfo(uint256 vaultId) public view returns (uint256, uint256) {\\n        address urn = manager.urns(vaultId);\\n        bytes32 ilk = manager.ilks(vaultId);\\n\\n        (uint256 collateral, uint256 debt) = vat.urns(ilk, urn);\\n        (, uint256 rate, , , ) = vat.ilks(ilk);\\n\\n        return (collateral, rmul(debt, rate));\\n    }\\n\\n    /// @notice Gets a price of the asset\\n    /// @param ilk Ilk of the Vault\\n    function getPrice(bytes32 ilk) public view returns (uint256) {\\n        (, uint256 mat) = spotter.ilks(ilk);\\n        (, , uint256 spot, , ) = vat.ilks(ilk);\\n\\n        return div(rmul(rmul(spot, spotter.par()), mat), 10**9);\\n    }\\n\\n    /// @notice Gets oracle next price of the asset\\n    /// @param ilk Ilk of the Vault\\n    function getNextPrice(bytes32 ilk) public view returns (uint256) {\\n        require(whitelisted[msg.sender], \\\"mcd-view/not-whitelisted\\\");\\n        OsmLike osm = OsmLike(osmMom.osms(ilk));\\n        (bytes32 val, bool status) = osm.peep();\\n        require(status, \\\"mcd-view/osm-price-error\\\");\\n        return uint256(val);\\n    }\\n\\n    /// @notice Gets Vaults ratio\\n    /// @param vaultId Id of the Vault\\n    function getRatio(uint256 vaultId, bool useNextPrice) public view returns (uint256) {\\n        bytes32 ilk = manager.ilks(vaultId);\\n        uint256 price = useNextPrice ? getNextPrice(ilk) : getPrice(ilk);\\n        (uint256 collateral, uint256 debt) = getVaultInfo(vaultId);\\n        if (debt == 0) return 0;\\n        return wdiv(wmul(collateral, price), debt);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SpotterLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface IPipInterface {\\n    function read() external returns (bytes32);\\n}\\n\\ninterface SpotterLike {\\n    function ilks(bytes32) external view returns (IPipInterface pip, uint256 mat);\\n\\n    function par() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/VatLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface VatLike {\\n    function urns(bytes32, address) external view returns (uint256 ink, uint256 art);\\n\\n    function ilks(bytes32)\\n        external\\n        view\\n        returns (\\n            uint256 art, // Total Normalised Debt      [wad]\\n            uint256 rate, // Accumulated Rates         [ray]\\n            uint256 spot, // Price with Safety Margin  [ray]\\n            uint256 line, // Debt Ceiling              [rad]\\n            uint256 dust // Urn Debt Floor             [rad]\\n        );\\n\\n    function gem(bytes32, address) external view returns (uint256); // [wad]\\n\\n    function can(address, address) external view returns (uint256);\\n\\n    function dai(address) external view returns (uint256);\\n\\n    function frob(\\n        bytes32,\\n        address,\\n        address,\\n        address,\\n        int256,\\n        int256\\n    ) external;\\n\\n    function hope(address) external;\\n\\n    function move(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function fork(\\n        bytes32,\\n        address,\\n        address,\\n        int256,\\n        int256\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OsmMomLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface OsmMomLike {\\n    function osms(bytes32) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/OsmLike.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface OsmLike {\\n    function peep() external view returns (bytes32, bool);\\n\\n    function bud(address) external view returns (uint256);\\n\\n    function kiss(address a) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/DSMath.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ncontract DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"\\\");\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x / y;\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 internal constant WAD = 10**18;\\n    uint256 internal constant RAY = 10**27;\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_serviceRegistry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"executionData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"triggerData\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"isExecutionCorrect\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"triggerData\",\"type\":\"bytes\"}],\"name\":\"isExecutionLegal\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cdpId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"triggerData\",\"type\":\"bytes\"}],\"name\":\"isTriggerDataValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"serviceRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CloseCommand", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "0000000000000000000000009b4ae7b164d195df9c4da5d08be88b2848b2eada", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}