{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/NestedFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./abstracts/OwnableProxyDelegation.sol\\\";\\nimport \\\"./abstracts/MixinOperatorResolver.sol\\\";\\nimport \\\"./libraries/ExchangeHelpers.sol\\\";\\nimport \\\"./interfaces/external/IWETH.sol\\\";\\nimport \\\"./interfaces/INestedFactory.sol\\\";\\nimport \\\"./FeeSplitter.sol\\\";\\nimport \\\"./NestedReserve.sol\\\";\\nimport \\\"./NestedAsset.sol\\\";\\nimport \\\"./NestedRecords.sol\\\";\\nimport \\\"./Withdrawer.sol\\\";\\n\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title Creates, updates and destroys NestedAssets (portfolios).\\n/// @notice Responsible for the business logic of the protocol and interaction with operators\\ncontract NestedFactory is INestedFactory, ReentrancyGuard, OwnableProxyDelegation, MixinOperatorResolver {\\n    /* ----------------------------- VARIABLES ----------------------------- */\\n\\n    address private constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    /// @dev Supported operators by the factory contract\\n    bytes32[] private operators;\\n\\n    /// @dev Current feeSplitter contract/address\\n    FeeSplitter public feeSplitter;\\n\\n    /// @dev Current reserve contract/address\\n    NestedReserve public immutable reserve;\\n\\n    /// @dev Current nested asset (ERC721) contract/address\\n    NestedAsset public immutable nestedAsset;\\n\\n    /// @dev Wrapped Ether contract/address\\n    /// Note: Will be WMATIC, WAVAX, WBNB,... Depending on the chain.\\n    IWETH public immutable weth;\\n\\n    /// @dev Current records contract/address\\n    NestedRecords public immutable nestedRecords;\\n\\n    /// @dev Helper to withdraw native tokens from wrapper\\n    Withdrawer private immutable withdrawer;\\n\\n    /// @dev Fees when funds stay in portfolios\\n    ///      From 1 to 10,000 (0.01% to 100%)\\n    uint256 public entryFees;\\n\\n    /// @dev Fees when funds are withdrawed\\n    ///      From 1 to 10,000 (0.01% to 100%)\\n    uint256 public exitFees;\\n\\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\\n\\n    constructor(\\n        NestedAsset _nestedAsset,\\n        NestedRecords _nestedRecords,\\n        NestedReserve _reserve,\\n        FeeSplitter _feeSplitter,\\n        IWETH _weth,\\n        address _operatorResolver,\\n        Withdrawer _withdrawer\\n    ) MixinOperatorResolver(_operatorResolver) {\\n        require(\\n            address(_nestedAsset) != address(0) &&\\n                address(_nestedRecords) != address(0) &&\\n                address(_reserve) != address(0) &&\\n                address(_feeSplitter) != address(0) &&\\n                address(_weth) != address(0) &&\\n                _operatorResolver != address(0) &&\\n                address(_withdrawer) != address(0),\\n            \\\"NF: INVALID_ADDRESS\\\"\\n        );\\n        nestedAsset = _nestedAsset;\\n        nestedRecords = _nestedRecords;\\n        reserve = _reserve;\\n        feeSplitter = _feeSplitter;\\n        weth = _weth;\\n        withdrawer = _withdrawer;\\n    }\\n\\n    /// @dev Receive function\\n    receive() external payable {\\n        require(msg.sender == address(withdrawer), \\\"NF: ETH_SENDER_NOT_WITHDRAWER\\\");\\n    }\\n\\n    /* ------------------------------ MODIFIERS ---------------------------- */\\n\\n    /// @dev Reverts the transaction if the caller is not the token owner\\n    /// @param _nftId The NFT Id\\n    modifier onlyTokenOwner(uint256 _nftId) {\\n        require(nestedAsset.ownerOf(_nftId) == _msgSender(), \\\"NF: CALLER_NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    /// @dev Reverts the transaction if the nft is locked (hold by design).\\n    /// The block.timestamp must be greater than NFT record lock timestamp\\n    /// @param _nftId The NFT Id\\n    modifier isUnlocked(uint256 _nftId) {\\n        require(block.timestamp > nestedRecords.getLockTimestamp(_nftId), \\\"NF: LOCKED_NFT\\\");\\n        _;\\n    }\\n\\n    /* ------------------------------- VIEWS ------------------------------- */\\n\\n    /// @notice Get the required operators\\n    function resolverOperatorsRequired() public view override returns (bytes32[] memory) {\\n        return operators;\\n    }\\n\\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\\n\\n    /// @inheritdoc INestedFactory\\n    function addOperator(bytes32 operator) external override onlyOwner {\\n        require(operator != bytes32(\\\"\\\"), \\\"NF: INVALID_OPERATOR_NAME\\\");\\n        bytes32[] memory operatorsCache = operators;\\n        for (uint256 i = 0; i < operatorsCache.length; i++) {\\n            require(operatorsCache[i] != operator, \\\"NF: EXISTENT_OPERATOR\\\");\\n        }\\n        operators.push(operator);\\n        rebuildCache();\\n        emit OperatorAdded(operator);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function removeOperator(bytes32 operator) external override onlyOwner {\\n        bytes32[] storage operatorsCache = operators;\\n        uint256 operatorsLength = operatorsCache.length;\\n        for (uint256 i = 0; i < operatorsLength; i++) {\\n            if (operatorsCache[i] == operator) {\\n                operatorsCache[i] = operators[operatorsLength - 1];\\n                operatorsCache.pop();\\n                if (operatorCache[operator].implementation != address(0)) {\\n                    delete operatorCache[operator]; // remove from cache\\n                }\\n                rebuildCache();\\n                emit OperatorRemoved(operator);\\n                return;\\n            }\\n        }\\n        revert(\\\"NF: NON_EXISTENT_OPERATOR\\\");\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function setFeeSplitter(FeeSplitter _feeSplitter) external override onlyOwner {\\n        require(address(_feeSplitter) != address(0), \\\"NF: INVALID_FEE_SPLITTER_ADDRESS\\\");\\n        feeSplitter = _feeSplitter;\\n        emit FeeSplitterUpdated(address(_feeSplitter));\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function setEntryFees(uint256 _entryFees) external override onlyOwner {\\n        require(_entryFees != 0, \\\"NF: ZERO_FEES\\\");\\n        require(_entryFees <= 10000, \\\"NF: FEES_OVERFLOW\\\");\\n        entryFees = _entryFees;\\n        emit EntryFeesUpdated(_entryFees);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function setExitFees(uint256 _exitFees) external override onlyOwner {\\n        require(_exitFees != 0, \\\"NF: ZERO_FEES\\\");\\n        require(_exitFees <= 10000, \\\"NF: FEES_OVERFLOW\\\");\\n        exitFees = _exitFees;\\n        emit ExitFeesUpdated(_exitFees);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function unlockTokens(IERC20 _token) external override onlyOwner {\\n        uint256 amount = _token.balanceOf(address(this));\\n        SafeERC20.safeTransfer(_token, msg.sender, amount);\\n        emit TokensUnlocked(address(_token), amount);\\n    }\\n\\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\\n\\n    /// @inheritdoc INestedFactory\\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n    {\\n        uint256 batchedOrdersLength = _batchedOrders.length;\\n        require(batchedOrdersLength != 0, \\\"NF: INVALID_MULTI_ORDERS\\\");\\n\\n        _checkMsgValue(_batchedOrders);\\n        uint256 nftId = nestedAsset.mint(_msgSender(), _originalTokenId);\\n\\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(nftId, _batchedOrders[i], false);\\n            _transferFeeWithRoyalty(fees, tokenSold, nftId);\\n        }\\n\\n        emit NftCreated(nftId, _originalTokenId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders)\\n        external\\n        payable\\n        override\\n        nonReentrant\\n        onlyTokenOwner(_nftId)\\n        isUnlocked(_nftId)\\n    {\\n        _checkMsgValue(_batchedOrders);\\n        _processInputOrders(_nftId, _batchedOrders);\\n        emit NftUpdated(_nftId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders)\\n        external\\n        override\\n        nonReentrant\\n        onlyTokenOwner(_nftId)\\n        isUnlocked(_nftId)\\n    {\\n        _processOutputOrders(_nftId, _batchedOrders);\\n        emit NftUpdated(_nftId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function processInputAndOutputOrders(\\n        uint256 _nftId,\\n        BatchedInputOrders[] calldata _batchedInputOrders,\\n        BatchedOutputOrders[] calldata _batchedOutputOrders\\n    ) external payable override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\\n        _checkMsgValue(_batchedInputOrders);\\n        _processInputOrders(_nftId, _batchedInputOrders);\\n        _processOutputOrders(_nftId, _batchedOutputOrders);\\n        emit NftUpdated(_nftId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function destroy(\\n        uint256 _nftId,\\n        IERC20 _buyToken,\\n        Order[] calldata _orders\\n    ) external override nonReentrant onlyTokenOwner(_nftId) isUnlocked(_nftId) {\\n        address[] memory tokens = nestedRecords.getAssetTokens(_nftId);\\n        uint256 tokensLength = tokens.length;\\n        require(_orders.length != 0, \\\"NF: INVALID_ORDERS\\\");\\n        require(tokensLength == _orders.length, \\\"NF: INPUTS_LENGTH_MUST_MATCH\\\");\\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \\\"NF: RESERVE_MISMATCH\\\");\\n\\n        uint256 buyTokenInitialBalance = _buyToken.balanceOf(address(this));\\n\\n        for (uint256 i = 0; i < tokensLength; i++) {\\n            address token = tokens[i];\\n            uint256 amount = _safeWithdraw(token, _nftId);\\n            _safeSubmitOrder(token, address(_buyToken), amount, _nftId, _orders[i]);\\n        }\\n\\n        // Amount calculation to send fees and tokens\\n        uint256 amountBought = _buyToken.balanceOf(address(this)) - buyTokenInitialBalance;\\n        uint256 amountFees = (amountBought * exitFees) / 10000; // Exit Fees\\n        unchecked {\\n            amountBought -= amountFees;\\n\\n            _transferFeeWithRoyalty(amountFees, _buyToken, _nftId);\\n            _safeTransferAndUnwrap(_buyToken, amountBought, _msgSender());\\n        }\\n\\n        // Burn NFT\\n        nestedRecords.removeNFT(_nftId);\\n        nestedAsset.burn(_msgSender(), _nftId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function withdraw(uint256 _nftId, uint256 _tokenIndex)\\n        external\\n        override\\n        nonReentrant\\n        onlyTokenOwner(_nftId)\\n        isUnlocked(_nftId)\\n    {\\n        uint256 assetTokensLength = nestedRecords.getAssetTokensLength(_nftId);\\n        require(assetTokensLength > _tokenIndex, \\\"NF: INVALID_TOKEN_INDEX\\\");\\n        // Use destroy instead if NFT has a single holding\\n        require(assetTokensLength > 1, \\\"NF: UNALLOWED_EMPTY_PORTFOLIO\\\");\\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \\\"NF: RESERVE_MISMATCH\\\");\\n\\n        address token = nestedRecords.getAssetTokens(_nftId)[_tokenIndex];\\n\\n        uint256 amount = _safeWithdraw(token, _nftId);\\n        _safeTransferWithFees(IERC20(token), amount, _msgSender(), _nftId);\\n\\n        nestedRecords.deleteAsset(_nftId, _tokenIndex);\\n        emit NftUpdated(_nftId);\\n    }\\n\\n    /// @inheritdoc INestedFactory\\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external override onlyTokenOwner(_nftId) {\\n        nestedRecords.updateLockTimestamp(_nftId, _timestamp);\\n    }\\n\\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\\n\\n    /// @dev Internal logic extraction of processInputOrders()\\n    /// @param _nftId The id of the NFT to update\\n    /// @param _batchedOrders The order to execute\\n    function _processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) private {\\n        uint256 batchedOrdersLength = _batchedOrders.length;\\n        require(batchedOrdersLength != 0, \\\"NF: INVALID_MULTI_ORDERS\\\");\\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \\\"NF: RESERVE_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\\n            (uint256 fees, IERC20 tokenSold) = _submitInOrders(\\n                _nftId,\\n                _batchedOrders[i],\\n                _batchedOrders[i].fromReserve\\n            );\\n            _transferFeeWithRoyalty(fees, tokenSold, _nftId);\\n        }\\n    }\\n\\n    /// @dev Internal logic extraction of processOutputOrders()\\n    /// @param _nftId The id of the NFT to update\\n    /// @param _batchedOrders The order to execute\\n    function _processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) private {\\n        uint256 batchedOrdersLength = _batchedOrders.length;\\n        require(batchedOrdersLength != 0, \\\"NF: INVALID_MULTI_ORDERS\\\");\\n        require(nestedRecords.getAssetReserve(_nftId) == address(reserve), \\\"NF: RESERVE_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < batchedOrdersLength; i++) {\\n            (uint256 feesAmount, uint256 amountBought) = _submitOutOrders(\\n                _nftId,\\n                _batchedOrders[i],\\n                _batchedOrders[i].toReserve\\n            );\\n            _transferFeeWithRoyalty(feesAmount, _batchedOrders[i].outputToken, _nftId);\\n            if (!_batchedOrders[i].toReserve) {\\n                _safeTransferAndUnwrap(_batchedOrders[i].outputToken, amountBought - feesAmount, _msgSender());\\n            }\\n        }\\n    }\\n\\n    /// @dev For every orders, call the operator with the calldata\\n    /// to submit orders (where the input is one asset).\\n    /// @param _nftId The id of the NFT impacted by the orders\\n    /// @param _batchedOrders The order to process\\n    /// @param _fromReserve True if the input tokens are from the reserve (portfolio)\\n    /// @return feesAmount The total amount of fees on the input\\n    /// @return tokenSold The ERC20 token sold (in case of ETH to WETH)\\n    function _submitInOrders(\\n        uint256 _nftId,\\n        BatchedInputOrders calldata _batchedOrders,\\n        bool _fromReserve\\n    ) private returns (uint256 feesAmount, IERC20 tokenSold) {\\n        uint256 batchLength = _batchedOrders.orders.length;\\n        require(batchLength != 0, \\\"NF: INVALID_ORDERS\\\");\\n        uint256 _inputTokenAmount;\\n        (tokenSold, _inputTokenAmount) = _transferInputTokens(\\n            _nftId,\\n            _batchedOrders.inputToken,\\n            _batchedOrders.amount,\\n            _fromReserve\\n        );\\n\\n        uint256 amountSpent;\\n        for (uint256 i = 0; i < batchLength; i++) {\\n            amountSpent += _submitOrder(\\n                address(tokenSold),\\n                _batchedOrders.orders[i].token,\\n                _nftId,\\n                _batchedOrders.orders[i],\\n                true // always to the reserve\\n            );\\n        }\\n        feesAmount = (amountSpent * entryFees) / 10000; // Entry Fees\\n        require(amountSpent <= _inputTokenAmount - feesAmount, \\\"NF: OVERSPENT\\\");\\n        unchecked {\\n            uint256 underSpentAmount = _inputTokenAmount - feesAmount - amountSpent;\\n            if (underSpentAmount != 0) {\\n                SafeERC20.safeTransfer(tokenSold, _fromReserve ? address(reserve) : _msgSender(), underSpentAmount);\\n            }\\n\\n            // If input is from the reserve, update the records\\n            if (_fromReserve) {\\n                _decreaseHoldingAmount(_nftId, address(tokenSold), _inputTokenAmount - underSpentAmount);\\n            }\\n        }\\n    }\\n\\n    /// @dev For every orders, call the operator with the calldata\\n    /// to submit sell orders (where the output is one asset).\\n    /// @param _nftId The id of the NFT impacted by the orders\\n    /// @param _batchedOrders The order to process\\n    /// @param _toReserve True if the output is store in the reserve/records (portfolio), false if not.\\n    /// @return feesAmount The total amount of fees on the output\\n    /// @return amountBought The total amount bought\\n    function _submitOutOrders(\\n        uint256 _nftId,\\n        BatchedOutputOrders calldata _batchedOrders,\\n        bool _toReserve\\n    ) private returns (uint256 feesAmount, uint256 amountBought) {\\n        uint256 batchLength = _batchedOrders.orders.length;\\n        require(batchLength != 0, \\\"NF: INVALID_ORDERS\\\");\\n        require(_batchedOrders.amounts.length == batchLength, \\\"NF: INPUTS_LENGTH_MUST_MATCH\\\");\\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this));\\n\\n        IERC20 _inputToken;\\n        uint256 _inputTokenAmount;\\n        for (uint256 i = 0; i < batchLength; i++) {\\n            (_inputToken, _inputTokenAmount) = _transferInputTokens(\\n                _nftId,\\n                IERC20(_batchedOrders.orders[i].token),\\n                _batchedOrders.amounts[i],\\n                true\\n            );\\n\\n            // Submit order and update holding of spent token\\n            uint256 amountSpent = _submitOrder(\\n                address(_inputToken),\\n                address(_batchedOrders.outputToken),\\n                _nftId,\\n                _batchedOrders.orders[i],\\n                false\\n            );\\n            require(amountSpent <= _inputTokenAmount, \\\"NF: OVERSPENT\\\");\\n\\n            unchecked {\\n                uint256 underSpentAmount = _inputTokenAmount - amountSpent;\\n                if (underSpentAmount != 0) {\\n                    SafeERC20.safeTransfer(_inputToken, address(reserve), underSpentAmount);\\n                }\\n                _decreaseHoldingAmount(_nftId, address(_inputToken), _inputTokenAmount - underSpentAmount);\\n            }\\n        }\\n\\n        amountBought = _batchedOrders.outputToken.balanceOf(address(this)) - amountBought;\\n\\n        unchecked {\\n            // Entry or Exit Fees\\n            feesAmount = (amountBought * (_toReserve ? entryFees : exitFees)) / 10000;\\n\\n            if (_toReserve) {\\n                _transferToReserveAndStore(_batchedOrders.outputToken, amountBought - feesAmount, _nftId);\\n            }\\n        }\\n    }\\n\\n    /// @dev Call the operator to submit the order and add the output\\n    /// assets to the reserve (if needed).\\n    /// @param _inputToken Token used to make the orders\\n    /// @param _outputToken Expected output token\\n    /// @param _nftId The nftId\\n    /// @param _order The order calldata\\n    /// @param _toReserve True if the output is store in the reserve/records, false if not.\\n    /// @return amountSpent The _inputToken amount spent (with the order)\\n    function _submitOrder(\\n        address _inputToken,\\n        address _outputToken,\\n        uint256 _nftId,\\n        Order calldata _order,\\n        bool _toReserve\\n    ) private returns (uint256 amountSpent) {\\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\\n        require(success, \\\"NF: OPERATOR_CALL_FAILED\\\");\\n\\n        if (_toReserve) {\\n            _transferToReserveAndStore(IERC20(_outputToken), amounts[0], _nftId);\\n        }\\n        amountSpent = amounts[1];\\n    }\\n\\n    /// @dev Call the operator to submit the order but dont stop if the call to the operator fail.\\n    ///      It will send the input token back to the msg.sender.\\n    /// Note : The _toReserve Boolean has been removed (compare to _submitOrder) since it was\\n    ///        useless for the only use case (destroy).\\n    /// @param _inputToken Token used to make the orders\\n    /// @param _outputToken Expected output token\\n    /// @param _amountToSpend The input amount available (to spend)\\n    /// @param _nftId The nftId\\n    /// @param _order The order calldata\\n    function _safeSubmitOrder(\\n        address _inputToken,\\n        address _outputToken,\\n        uint256 _amountToSpend,\\n        uint256 _nftId,\\n        Order calldata _order\\n    ) private {\\n        (bool success, uint256[] memory amounts) = callOperator(_order, _inputToken, _outputToken);\\n        if (success) {\\n            require(amounts[1] <= _amountToSpend, \\\"NF: OVERSPENT\\\");\\n            unchecked {\\n                uint256 underSpentAmount = _amountToSpend - amounts[1];\\n                if (underSpentAmount != 0) {\\n                    SafeERC20.safeTransfer(IERC20(_inputToken), _msgSender(), underSpentAmount);\\n                }\\n            }\\n        } else {\\n            _safeTransferWithFees(IERC20(_inputToken), _amountToSpend, _msgSender(), _nftId);\\n        }\\n    }\\n\\n    /// @dev Transfer tokens to the reserve, and compute the amount received to store\\n    /// in the records. We need to know the amount received in case of deflationary tokens.\\n    /// @param _token The token to transfer (IERC20)\\n    /// @param _amount The amount to send to the reserve\\n    /// @param _nftId The Token ID to store the assets\\n    function _transferToReserveAndStore(\\n        IERC20 _token,\\n        uint256 _amount,\\n        uint256 _nftId\\n    ) private {\\n        address reserveAddr = address(reserve);\\n        uint256 balanceReserveBefore = _token.balanceOf(reserveAddr);\\n\\n        // Send output to reserve\\n        SafeERC20.safeTransfer(_token, reserveAddr, _amount);\\n\\n        uint256 balanceReserveAfter = _token.balanceOf(reserveAddr);\\n\\n        nestedRecords.store(_nftId, address(_token), balanceReserveAfter - balanceReserveBefore, reserveAddr);\\n    }\\n\\n    /// @dev Choose between ERC20 (safeTransfer) and ETH (deposit), to transfer from the Reserve\\n    ///      or the user wallet, to the factory.\\n    /// @param _nftId The NFT id\\n    /// @param _inputToken The token to receive\\n    /// @param _inputTokenAmount Amount to transfer\\n    /// @param _fromReserve True to transfer from the reserve\\n    /// @return Token transfered (in case of ETH)\\n    /// @return The real amount received after the transfer to the factory\\n    function _transferInputTokens(\\n        uint256 _nftId,\\n        IERC20 _inputToken,\\n        uint256 _inputTokenAmount,\\n        bool _fromReserve\\n    ) private returns (IERC20, uint256) {\\n        if (address(_inputToken) == ETH) {\\n            require(!_fromReserve, \\\"NF: NO_ETH_FROM_RESERVE\\\");\\n            require(address(this).balance >= _inputTokenAmount, \\\"NF: INVALID_AMOUNT_IN\\\");\\n            weth.deposit{ value: _inputTokenAmount }();\\n            return (IERC20(address(weth)), _inputTokenAmount);\\n        }\\n\\n        uint256 balanceBefore = _inputToken.balanceOf(address(this));\\n        if (_fromReserve) {\\n            require(\\n                nestedRecords.getAssetHolding(_nftId, address(_inputToken)) >= _inputTokenAmount,\\n                \\\"NF: INSUFFICIENT_AMOUNT_IN\\\"\\n            );\\n            // Get input from reserve\\n            reserve.withdraw(_inputToken, _inputTokenAmount);\\n        } else {\\n            SafeERC20.safeTransferFrom(_inputToken, _msgSender(), address(this), _inputTokenAmount);\\n        }\\n        return (_inputToken, _inputToken.balanceOf(address(this)) - balanceBefore);\\n    }\\n\\n    /// @dev Send a fee to the FeeSplitter, royalties will be paid to the owner of the original asset\\n    /// @param _amount Amount to send\\n    /// @param _token Token to send\\n    /// @param _nftId User portfolio ID used to find a potential royalties recipient\\n    function _transferFeeWithRoyalty(\\n        uint256 _amount,\\n        IERC20 _token,\\n        uint256 _nftId\\n    ) private {\\n        address originalOwner = nestedAsset.originalOwner(_nftId);\\n        ExchangeHelpers.setMaxAllowance(_token, address(feeSplitter));\\n        if (originalOwner != address(0)) {\\n            feeSplitter.sendFeesWithRoyalties(originalOwner, _token, _amount);\\n        } else {\\n            feeSplitter.sendFees(_token, _amount);\\n        }\\n    }\\n\\n    /// @dev Decrease the amount of a NFT holding\\n    /// @param _nftId The NFT id\\n    /// @param _inputToken The token holding\\n    /// @param _amount The amount to subtract from the actual holding amount\\n    function _decreaseHoldingAmount(\\n        uint256 _nftId,\\n        address _inputToken,\\n        uint256 _amount\\n    ) private {\\n        nestedRecords.updateHoldingAmount(\\n            _nftId,\\n            _inputToken,\\n            nestedRecords.getAssetHolding(_nftId, _inputToken) - _amount\\n        );\\n    }\\n\\n    /// @dev Transfer a token amount from the factory to the recipient.\\n    ///      The token is unwrapped if WETH.\\n    /// @param _token The token to transfer\\n    /// @param _amount The amount to transfer\\n    /// @param _dest The address receiving the funds\\n    function _safeTransferAndUnwrap(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _dest\\n    ) private {\\n        // if buy token is WETH, unwrap it instead of transferring it to the sender\\n        if (address(_token) == address(weth)) {\\n            ExchangeHelpers.setMaxAllowance(IERC20(address(weth)), address(withdrawer));\\n            withdrawer.withdraw(_amount);\\n            (bool success, ) = _dest.call{ value: _amount }(\\\"\\\");\\n            require(success, \\\"NF: ETH_TRANSFER_ERROR\\\");\\n        } else {\\n            SafeERC20.safeTransfer(_token, _dest, _amount);\\n        }\\n    }\\n\\n    /// @dev Transfer from factory and collect fees\\n    /// @param _token The token to transfer\\n    /// @param _amount The amount (with fees) to transfer\\n    /// @param _dest The address receiving the funds\\n    /// @param _nftId The nft Id (for royalty fees)\\n    function _safeTransferWithFees(\\n        IERC20 _token,\\n        uint256 _amount,\\n        address _dest,\\n        uint256 _nftId\\n    ) private {\\n        uint256 feeAmount = (_amount * exitFees) / 10000; // Exit Fee\\n        unchecked {\\n            _transferFeeWithRoyalty(feeAmount, _token, _nftId);\\n            SafeERC20.safeTransfer(_token, _dest, _amount - feeAmount);\\n        }\\n    }\\n\\n    /// @dev Withdraw from reserve with care of deflationary tokens.\\n    /// @param _token The token to withdraw\\n    /// @param _nftId The NFT id to withdraw from\\n    /// @return The withdrawed amount from the reserve\\n    function _safeWithdraw(address _token, uint256 _nftId) private returns (uint256) {\\n        uint256 holdingAmount = nestedRecords.getAssetHolding(_nftId, _token);\\n        uint256 balanceBefore = IERC20(_token).balanceOf(address(this));\\n        reserve.withdraw(IERC20(_token), holdingAmount);\\n        return IERC20(_token).balanceOf(address(this)) - balanceBefore;\\n    }\\n\\n    /// @dev Verify that msg.value is equal to the amount needed (in the orders)\\n    /// @param _batchedOrders The batched input orders\\n    function _checkMsgValue(BatchedInputOrders[] calldata _batchedOrders) private {\\n        uint256 ethNeeded;\\n        for (uint256 i = 0; i < _batchedOrders.length; i++) {\\n            if (address(_batchedOrders[i].inputToken) == ETH) {\\n                ethNeeded += _batchedOrders[i].amount;\\n            }\\n        }\\n        require(msg.value == ethNeeded, \\\"NF: WRONG_MSG_VALUE\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/OwnableProxyDelegation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/StorageSlot.sol\\\";\\n\\n/// @notice Ownable re-implementation to initialize the owner in the\\n///         proxy storage after an \\\"upgradeToAndCall()\\\" (delegatecall).\\n/// @dev The implementation contract owner will be address zero (by removing the constructor)\\nabstract contract OwnableProxyDelegation is Context {\\n    /// @dev The contract owner\\n    address private _owner;\\n\\n    /// @dev Storage slot with the proxy admin (see TransparentUpgradeableProxy from OZ)\\n    bytes32 internal constant _ADMIN_SLOT = bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1);\\n\\n    /// @dev True if the owner is setted\\n    bool public initialized;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /// @notice Initialize the owner (by the proxy admin)\\n    /// @param ownerAddr The owner address\\n    function initialize(address ownerAddr) external {\\n        require(ownerAddr != address(0), \\\"OPD: INVALID_ADDRESS\\\");\\n        require(!initialized, \\\"OPD: INITIALIZED\\\");\\n        require(StorageSlot.getAddressSlot(_ADMIN_SLOT).value == msg.sender, \\\"OPD: FORBIDDEN\\\");\\n\\n        _setOwner(ownerAddr);\\n\\n        initialized = true;\\n    }\\n\\n    /// @dev Returns the address of the current owner.\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /// @dev Throws if called by any account other than the owner.\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"OPD: NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    /// @dev Leaves the contract without owner. It will not be possible to call\\n    /// `onlyOwner` functions anymore. Can only be called by the current owner.\\n    ///\\n    /// NOTE: Renouncing ownership will leave the contract without an owner,\\n    /// thereby removing any functionality that is only available to the owner.\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Transfers ownership of the contract to a new account (`newOwner`).\\n    /// Can only be called by the current owner.\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"OPD: INVALID_ADDRESS\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Update the owner address\\n    /// @param newOwner The new owner address\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/MixinOperatorResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"../OperatorResolver.sol\\\";\\nimport \\\"../interfaces/IOperatorResolver.sol\\\";\\nimport \\\"../interfaces/INestedFactory.sol\\\";\\n\\n/// @title Mixin operator resolver\\n/// @notice Store in cache operators name and address/selector\\nabstract contract MixinOperatorResolver {\\n    /// @notice Emitted when cache is updated\\n    /// @param name The operator name\\n    /// @param destination The operator address\\n    event CacheUpdated(bytes32 name, IOperatorResolver.Operator destination);\\n\\n    /// @dev The OperatorResolver used to build the cache\\n    OperatorResolver public immutable resolver;\\n\\n    /// @dev Cache operators map of the name and Operator struct (address/selector)\\n    mapping(bytes32 => IOperatorResolver.Operator) internal operatorCache;\\n\\n    constructor(address _resolver) {\\n        require(_resolver != address(0), \\\"MOR: INVALID_ADDRESS\\\");\\n        resolver = OperatorResolver(_resolver);\\n    }\\n\\n    /// @dev This function is public not external in order for it to be overridden and\\n    ///      invoked via super in subclasses\\n    function resolverOperatorsRequired() public view virtual returns (bytes32[] memory) {}\\n\\n    /// @notice Rebuild the operatorCache\\n    function rebuildCache() public {\\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\\n        bytes32 name;\\n        IOperatorResolver.Operator memory destination;\\n        // The resolver must call this function whenever it updates its state\\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\\n            name = requiredOperators[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            destination = resolver.getOperator(name);\\n            if (destination.implementation != address(0)) {\\n                operatorCache[name] = destination;\\n            } else {\\n                delete operatorCache[name];\\n            }\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    /// @notice Check the state of operatorCache\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory requiredOperators = resolverOperatorsRequired();\\n        bytes32 name;\\n        IOperatorResolver.Operator memory cacheTmp;\\n        IOperatorResolver.Operator memory actualValue;\\n        for (uint256 i = 0; i < requiredOperators.length; i++) {\\n            name = requiredOperators[i];\\n            cacheTmp = operatorCache[name];\\n            actualValue = resolver.getOperator(name);\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (\\n                actualValue.implementation != cacheTmp.implementation ||\\n                actualValue.selector != cacheTmp.selector ||\\n                cacheTmp.implementation == address(0)\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @dev Get operator address in cache and require (if exists)\\n    /// @param name The operator name\\n    /// @return The operator address\\n    function requireAndGetAddress(bytes32 name) internal view returns (IOperatorResolver.Operator memory) {\\n        IOperatorResolver.Operator memory _foundAddress = operatorCache[name];\\n        require(_foundAddress.implementation != address(0), string(abi.encodePacked(\\\"MOR: MISSING_OPERATOR: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    /// @dev Build the calldata (with safe datas) and call the Operator\\n    /// @param _order The order to execute\\n    /// @param _inputToken The input token address\\n    /// @param _outputToken The output token address\\n    /// @return success If the operator call is successful\\n    /// @return amounts The amounts from the execution (used and received)\\n    ///         - amounts[0] : The amount of output token\\n    ///         - amounts[1] : The amount of input token USED by the operator (can be different than expected)\\n    function callOperator(\\n        INestedFactory.Order calldata _order,\\n        address _inputToken,\\n        address _outputToken\\n    ) internal returns (bool success, uint256[] memory amounts) {\\n        IOperatorResolver.Operator memory _operator = requireAndGetAddress(_order.operator);\\n        // Parameters are concatenated and padded to 32 bytes.\\n        // We are concatenating the selector + given params\\n        bytes memory data;\\n        (success, data) = _operator.implementation.delegatecall(bytes.concat(_operator.selector, _order.callData));\\n\\n        if (success) {\\n            address[] memory tokens;\\n            (amounts, tokens) = abi.decode(data, (uint256[], address[]));\\n            require(tokens[0] == _outputToken, \\\"MOR: INVALID_OUTPUT_TOKEN\\\");\\n            require(tokens[1] == _inputToken, \\\"MOR: INVALID_INPUT_TOKEN\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ExchangeHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/// @notice Helpers for swapping tokens\\nlibrary ExchangeHelpers {\\n    using SafeERC20 for IERC20;\\n\\n    /// @dev Perform a swap between two tokens\\n    /// @param _sellToken Token to exchange\\n    /// @param _swapTarget The address of the contract that swaps tokens\\n    /// @param _swapCallData Call data provided by 0x to fill the quote\\n    /// @return True if the call succeeded, false if not\\n    function fillQuote(\\n        IERC20 _sellToken,\\n        address _swapTarget,\\n        bytes memory _swapCallData\\n    ) internal returns (bool) {\\n        setMaxAllowance(_sellToken, _swapTarget);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = _swapTarget.call(_swapCallData);\\n        return success;\\n    }\\n\\n    /// @dev sets the allowance for a token to the maximum if it is not already at max\\n    /// @param _token The token to use for the allowance setting\\n    /// @param _spender Spender to allow\\n    function setMaxAllowance(IERC20 _token, address _spender) internal {\\n        uint256 _currentAllowance = _token.allowance(address(this), _spender);\\n        if (_currentAllowance != type(uint256).max) {\\n            // Decrease to 0 first for tokens mitigating the race condition\\n            _token.safeDecreaseAllowance(_spender, _currentAllowance);\\n            _token.safeIncreaseAllowance(_spender, type(uint256).max);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/external/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.11;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/INestedFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../NestedReserve.sol\\\";\\nimport \\\"../FeeSplitter.sol\\\";\\n\\n/// @title NestedFactory interface\\ninterface INestedFactory {\\n    /* ------------------------------ EVENTS ------------------------------ */\\n\\n    /// @dev Emitted when the feeSplitter is updated\\n    /// @param feeSplitter The new feeSplitter address\\n    event FeeSplitterUpdated(address feeSplitter);\\n\\n    /// @dev Emitted when the entryFees is updated\\n    /// @param entryFees The new entryFees amount\\n    event EntryFeesUpdated(uint256 entryFees);\\n\\n    /// @dev Emitted when the exitFees is updated\\n    /// @param exitFees The new exitFees amount\\n    event ExitFeesUpdated(uint256 exitFees);\\n\\n    /// @dev Emitted when the reserve is updated\\n    /// @param reserve The new reserve address\\n    event ReserveUpdated(address reserve);\\n\\n    /// @dev Emitted when a NFT (portfolio) is created\\n    /// @param nftId The NFT token Id\\n    /// @param originalNftId If replicated, the original NFT token Id\\n    event NftCreated(uint256 indexed nftId, uint256 originalNftId);\\n\\n    /// @dev Emitted when a NFT (portfolio) is updated\\n    /// @param nftId The NFT token Id\\n    event NftUpdated(uint256 indexed nftId);\\n\\n    /// @dev Emitted when a new operator is added\\n    /// @param newOperator The new operator bytes name\\n    event OperatorAdded(bytes32 newOperator);\\n\\n    /// @dev Emitted when an operator is removed\\n    /// @param oldOperator The old operator bytes name\\n    event OperatorRemoved(bytes32 oldOperator);\\n\\n    /// @dev Emitted when tokens are unlocked (sent to the owner)\\n    /// @param token The unlocked token address\\n    /// @param amount The unlocked amount\\n    event TokensUnlocked(address token, uint256 amount);\\n\\n    /* ------------------------------ STRUCTS ------------------------------ */\\n\\n    /// @dev Represent an order made to the factory when creating/editing an NFT\\n    /// @param operator The bytes32 name of the Operator\\n    /// @param token The expected token address in output/input\\n    /// @param callData The operator parameters (delegatecall)\\n    struct Order {\\n        bytes32 operator;\\n        address token;\\n        bytes callData;\\n    }\\n\\n    /// @dev Represent multiple input orders for a given token to perform multiple trades.\\n    /// @param inputToken The input token\\n    /// @param amount The amount to transfer (input amount)\\n    /// @param orders The orders to perform using the input token.\\n    /// @param _fromReserve Specify the input token source (true if reserve, false if wallet)\\n    ///        Note: fromReserve can be read as \\\"from portfolio\\\"\\n    struct BatchedInputOrders {\\n        IERC20 inputToken;\\n        uint256 amount;\\n        Order[] orders;\\n        bool fromReserve;\\n    }\\n\\n    /// @dev Represent multiple output orders to receive a given token\\n    /// @param outputToken The output token\\n    /// @param amounts The amount of sell tokens to use\\n    /// @param orders Orders calldata\\n    /// @param toReserve Specify the output token destination (true if reserve, false if wallet)\\n    ///        Note: toReserve can be read as \\\"to portfolio\\\"\\n    struct BatchedOutputOrders {\\n        IERC20 outputToken;\\n        uint256[] amounts;\\n        Order[] orders;\\n        bool toReserve;\\n    }\\n\\n    /* ------------------------------ OWNER FUNCTIONS ------------------------------ */\\n\\n    /// @notice Add an operator (name) for building cache\\n    /// @param operator The operator name to add\\n    function addOperator(bytes32 operator) external;\\n\\n    /// @notice Remove an operator (name) for building cache\\n    /// @param operator The operator name to remove\\n    function removeOperator(bytes32 operator) external;\\n\\n    /// @notice Sets the address receiving the fees\\n    /// @param _feeSplitter The address of the receiver\\n    function setFeeSplitter(FeeSplitter _feeSplitter) external;\\n\\n    /// @notice Sets the entry fees amount\\n    ///         Where 1 = 0.01% and 10000 = 100%\\n    /// @param _entryFees Entry fees amount\\n    function setEntryFees(uint256 _entryFees) external;\\n\\n    /// @notice Sets the exit fees amount\\n    ///         Where 1 = 0.01% and 10000 = 100%\\n    /// @param _exitFees Exit fees amount\\n    function setExitFees(uint256 _exitFees) external;\\n\\n    /// @notice The Factory is not storing funds, but some users can make\\n    /// bad manipulations and send tokens to the contract.\\n    /// In response to that, the owner can retrieve the factory balance of a given token\\n    /// to later return users funds.\\n    /// @param _token The token to retrieve.\\n    function unlockTokens(IERC20 _token) external;\\n\\n    /* ------------------------------ USERS FUNCTIONS ------------------------------ */\\n\\n    /// @notice Create a portfolio and store the underlying assets from the positions\\n    /// @param _originalTokenId The id of the NFT replicated, 0 if not replicating\\n    /// @param _batchedOrders The order to execute\\n    function create(uint256 _originalTokenId, BatchedInputOrders[] calldata _batchedOrders) external payable;\\n\\n    /// @notice Process multiple input orders\\n    /// @param _nftId The id of the NFT to update\\n    /// @param _batchedOrders The order to execute\\n    function processInputOrders(uint256 _nftId, BatchedInputOrders[] calldata _batchedOrders) external payable;\\n\\n    /// @notice Process multiple output orders\\n    /// @param _nftId The id of the NFT to update\\n    /// @param _batchedOrders The order to execute\\n    function processOutputOrders(uint256 _nftId, BatchedOutputOrders[] calldata _batchedOrders) external;\\n\\n    /// @notice Process multiple input orders and then multiple output orders\\n    /// @param _nftId The id of the NFT to update\\n    /// @param _batchedInputOrders The input orders to execute (first)\\n    /// @param _batchedOutputOrders The output orders to execute (after)\\n    function processInputAndOutputOrders(\\n        uint256 _nftId,\\n        BatchedInputOrders[] calldata _batchedInputOrders,\\n        BatchedOutputOrders[] calldata _batchedOutputOrders\\n    ) external payable;\\n\\n    /// @notice Burn NFT and exchange all tokens for a specific ERC20 then send it back to the user\\n    /// @dev Will unwrap WETH output to ETH\\n    /// @param _nftId The id of the NFT to destroy\\n    /// @param _buyToken The output token\\n    /// @param _orders Orders calldata\\n    function destroy(\\n        uint256 _nftId,\\n        IERC20 _buyToken,\\n        Order[] calldata _orders\\n    ) external;\\n\\n    /// @notice Withdraw a token from the reserve and transfer it to the owner without exchanging it\\n    /// @param _nftId NFT token ID\\n    /// @param _tokenIndex Index in array of tokens for this NFT and holding.\\n    function withdraw(uint256 _nftId, uint256 _tokenIndex) external;\\n\\n    /// @notice Update the lock timestamp of an NFT record.\\n    /// Note: Can only increase the lock timestamp.\\n    /// @param _nftId The NFT id to get the record\\n    /// @param _timestamp The new timestamp.\\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external;\\n}\\n\"\r\n    },\r\n    \"contracts/FeeSplitter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"./interfaces/external/IWETH.sol\\\";\\n\\n/// @title Manage the fees between shareholders\\n/// @notice Receives fees collected by the NestedFactory, and splits the income among\\n/// shareholders (the NFT owners, Nested treasury and a NST buybacker contract).\\ncontract FeeSplitter is Ownable, ReentrancyGuard {\\n    /* ------------------------------ EVENTS ------------------------------ */\\n\\n    /// @dev Emitted when a payment is released\\n    /// @param to The address receiving the payment\\n    /// @param token The token transfered\\n    /// @param amount The amount paid\\n    event PaymentReleased(address to, address token, uint256 amount);\\n\\n    /// @dev Emitted when a payment is received\\n    /// @param from The address sending the tokens\\n    /// @param token The token received\\n    /// @param amount The amount received\\n    event PaymentReceived(address from, address token, uint256 amount);\\n\\n    /// @dev Emitted when the royalties weight is updated\\n    /// @param weight The new weight\\n    event RoyaltiesWeightUpdated(uint256 weight);\\n\\n    /// @dev Emitted when a new shareholder is added\\n    /// @param account The new shareholder account\\n    /// @param weight The shareholder weight\\n    event ShareholdersAdded(address account, uint256 weight);\\n\\n    /// @dev Emitted when a shareholder weight is updated\\n    /// @param account The shareholder address\\n    /// @param weight The new weight\\n    event ShareholderUpdated(address account, uint256 weight);\\n\\n    /// @dev Emitted when royalties are claim released\\n    /// @param to The address claiming the royalties\\n    /// @param token The token received\\n    /// @param value The amount received\\n    event RoyaltiesReceived(address to, address token, uint256 value);\\n\\n    /* ------------------------------ STRUCTS ------------------------------ */\\n\\n    /// @dev Represent a shareholder\\n    /// @param account Shareholders address that can receive income\\n    /// @param weight Determines share allocation\\n    struct Shareholder {\\n        address account;\\n        uint96 weight;\\n    }\\n\\n    /// @dev Registers shares and amount release for a specific token or ETH\\n    struct TokenRecords {\\n        uint256 totalShares;\\n        uint256 totalReleased;\\n        mapping(address => uint256) shares;\\n        mapping(address => uint256) released;\\n    }\\n\\n    /* ----------------------------- VARIABLES ----------------------------- */\\n\\n    /// @dev Map of tokens with the tokenRecords\\n    mapping(address => TokenRecords) private tokenRecords;\\n\\n    /// @dev All the shareholders (array)\\n    Shareholder[] private shareholders;\\n\\n    /// @dev Royalties part weights when applicable\\n    uint256 public royaltiesWeight;\\n\\n    uint256 public totalWeights;\\n\\n    address public immutable weth;\\n\\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\\n\\n    constructor(\\n        address[] memory _accounts,\\n        uint96[] memory _weights,\\n        uint256 _royaltiesWeight,\\n        address _weth\\n    ) {\\n        require(_weth != address(0), \\\"FS: INVALID_ADDRESS\\\");\\n        // Initial shareholders addresses and weights\\n        setShareholders(_accounts, _weights);\\n        setRoyaltiesWeight(_royaltiesWeight);\\n        weth = _weth;\\n    }\\n\\n    /// @dev Receive ether after a WETH withdraw call\\n    receive() external payable {\\n        require(msg.sender == weth, \\\"FS: ETH_SENDER_NOT_WETH\\\");\\n    }\\n\\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\\n\\n    /// @notice Sets the weight assigned to the royalties part for the fee\\n    /// @param _weight The new royalties weight\\n    function setRoyaltiesWeight(uint256 _weight) public onlyOwner {\\n        require(_weight != 0, \\\"FS: WEIGHT_ZERO\\\");\\n        totalWeights = totalWeights + _weight - royaltiesWeight;\\n        royaltiesWeight = _weight;\\n        emit RoyaltiesWeightUpdated(_weight);\\n    }\\n\\n    /// @notice Sets a new list of shareholders\\n    /// @param _accounts Shareholders accounts list\\n    /// @param _weights Weight for each shareholder. Determines part of the payment allocated to them\\n    function setShareholders(address[] memory _accounts, uint96[] memory _weights) public onlyOwner {\\n        delete shareholders;\\n        uint256 accountsLength = _accounts.length;\\n        require(accountsLength != 0, \\\"FS: EMPTY_ARRAY\\\");\\n        require(accountsLength == _weights.length, \\\"FS: INPUTS_LENGTH_MUST_MATCH\\\");\\n        totalWeights = royaltiesWeight;\\n\\n        for (uint256 i = 0; i < accountsLength; i++) {\\n            _addShareholder(_accounts[i], _weights[i]);\\n        }\\n    }\\n\\n    /// @notice Updates weight for a shareholder\\n    /// @param _accountIndex Account to change the weight of\\n    /// @param _weight The new weight\\n    function updateShareholder(uint256 _accountIndex, uint96 _weight) external onlyOwner {\\n        require(_weight != 0, \\\"FS: INVALID_WEIGHT\\\");\\n        require(_accountIndex < shareholders.length, \\\"FS: INVALID_ACCOUNT_INDEX\\\");\\n        Shareholder storage _shareholder = shareholders[_accountIndex];\\n        totalWeights = totalWeights + _weight - _shareholder.weight;\\n        require(totalWeights != 0, \\\"FS: TOTAL_WEIGHTS_ZERO\\\");\\n        _shareholder.weight = _weight;\\n        emit ShareholderUpdated(_shareholder.account, _weight);\\n    }\\n\\n    /* -------------------------- USERS FUNCTIONS -------------------------- */\\n\\n    /// @notice Release multiple tokens and handle ETH unwrapping\\n    /// @param _tokens ERC20 tokens to release\\n    function releaseTokens(IERC20[] calldata _tokens) external nonReentrant {\\n        uint256 amount;\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            amount = _releaseToken(_msgSender(), _tokens[i]);\\n            if (address(_tokens[i]) == weth) {\\n                IWETH(weth).withdraw(amount);\\n                (bool success, ) = _msgSender().call{ value: amount }(\\\"\\\");\\n                require(success, \\\"FS: ETH_TRANFER_ERROR\\\");\\n            } else {\\n                SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\\n            }\\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\\n        }\\n    }\\n\\n    /// @notice Release multiple tokens without ETH unwrapping\\n    /// @param _tokens ERC20 tokens to release\\n    function releaseTokensNoETH(IERC20[] calldata _tokens) external nonReentrant {\\n        uint256 amount;\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            amount = _releaseToken(_msgSender(), _tokens[i]);\\n            SafeERC20.safeTransfer(_tokens[i], _msgSender(), amount);\\n            emit PaymentReleased(_msgSender(), address(_tokens[i]), amount);\\n        }\\n    }\\n\\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token. No royalties are expected.\\n    /// @param _token Currency for the fee as an ERC20 token\\n    /// @param _amount Amount of token as fee to be claimed by this contract\\n    function sendFees(IERC20 _token, uint256 _amount) external nonReentrant {\\n        uint256 weights;\\n        unchecked {\\n            weights = totalWeights - royaltiesWeight;\\n        }\\n\\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\\n\\n        _sendFees(_token, _token.balanceOf(address(this)) - balanceBeforeTransfer, weights);\\n    }\\n\\n    /// @notice Sends a fee to this contract for splitting, as an ERC20 token\\n    /// @param _royaltiesTarget The account that can claim royalties\\n    /// @param _token Currency for the fee as an ERC20 token\\n    /// @param _amount Amount of token as fee to be claimed by this contract\\n    function sendFeesWithRoyalties(\\n        address _royaltiesTarget,\\n        IERC20 _token,\\n        uint256 _amount\\n    ) external nonReentrant {\\n        require(_royaltiesTarget != address(0), \\\"FS: INVALID_ROYALTIES_TARGET\\\");\\n\\n        uint256 balanceBeforeTransfer = _token.balanceOf(address(this));\\n        SafeERC20.safeTransferFrom(_token, _msgSender(), address(this), _amount);\\n        uint256 amountReceived = _token.balanceOf(address(this)) - balanceBeforeTransfer;\\n\\n        uint256 _totalWeights = totalWeights;\\n        uint256 royaltiesAmount = (amountReceived * royaltiesWeight) / _totalWeights;\\n\\n        _sendFees(_token, amountReceived, _totalWeights);\\n        _addShares(_royaltiesTarget, royaltiesAmount, address(_token));\\n\\n        emit RoyaltiesReceived(_royaltiesTarget, address(_token), royaltiesAmount);\\n    }\\n\\n    /* ------------------------------- VIEWS ------------------------------- */\\n\\n    /// @notice Returns the amount due to an account. Call releaseToken to withdraw the amount.\\n    /// @param _account Account address to check the amount due for\\n    /// @param _token ERC20 payment token address\\n    /// @return The total amount due for the requested currency\\n    function getAmountDue(address _account, IERC20 _token) public view returns (uint256) {\\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\\n        uint256 _totalShares = _tokenRecords.totalShares;\\n        if (_totalShares == 0) return 0;\\n\\n        uint256 totalReceived = _tokenRecords.totalReleased + _token.balanceOf(address(this));\\n        return (totalReceived * _tokenRecords.shares[_account]) / _totalShares - _tokenRecords.released[_account];\\n    }\\n\\n    /// @notice Getter for the total shares held by shareholders.\\n    /// @param _token Payment token address\\n    /// @return The total shares count\\n    function totalShares(address _token) external view returns (uint256) {\\n        return tokenRecords[_token].totalShares;\\n    }\\n\\n    /// @notice Getter for the total amount of token already released.\\n    /// @param _token Payment token address\\n    /// @return The total amount release to shareholders\\n    function totalReleased(address _token) external view returns (uint256) {\\n        return tokenRecords[_token].totalReleased;\\n    }\\n\\n    /// @notice Getter for the amount of shares held by an account.\\n    /// @param _account Account the shares belong to\\n    /// @param _token Payment token address\\n    /// @return The shares owned by the account\\n    function shares(address _account, address _token) external view returns (uint256) {\\n        return tokenRecords[_token].shares[_account];\\n    }\\n\\n    /// @notice Getter for the amount of Ether already released to a shareholders.\\n    /// @param _account The target account for this request\\n    /// @param _token Payment token address\\n    /// @return The amount already released to this account\\n    function released(address _account, address _token) external view returns (uint256) {\\n        return tokenRecords[_token].released[_account];\\n    }\\n\\n    /// @notice Finds a shareholder and return its index\\n    /// @param _account Account to find\\n    /// @return The shareholder index in the storage array\\n    function findShareholder(address _account) external view returns (uint256) {\\n        for (uint256 i = 0; i < shareholders.length; i++) {\\n            if (shareholders[i].account == _account) return i;\\n        }\\n        revert(\\\"FS: SHAREHOLDER_NOT_FOUND\\\");\\n    }\\n\\n    /* ------------------------- PRIVATE FUNCTIONS ------------------------- */\\n\\n    /// @notice Transfers a fee to this contract\\n    /// @dev This method calculates the amount received, to support deflationary tokens\\n    /// @param _token Currency for the fee\\n    /// @param _amount Amount of token sent\\n    /// @param _totalWeights Total weights to determine the share count to allocate\\n    function _sendFees(\\n        IERC20 _token,\\n        uint256 _amount,\\n        uint256 _totalWeights\\n    ) private {\\n        Shareholder[] memory shareholdersCache = shareholders;\\n        for (uint256 i = 0; i < shareholdersCache.length; i++) {\\n            _addShares(\\n                shareholdersCache[i].account,\\n                (_amount * shareholdersCache[i].weight) / _totalWeights,\\n                address(_token)\\n            );\\n        }\\n        emit PaymentReceived(_msgSender(), address(_token), _amount);\\n    }\\n\\n    /// @dev Increase the shares of a shareholder\\n    /// @param _account The shareholder address\\n    /// @param _shares The shares of the holder\\n    /// @param _token The updated token\\n    function _addShares(\\n        address _account,\\n        uint256 _shares,\\n        address _token\\n    ) private {\\n        TokenRecords storage _tokenRecords = tokenRecords[_token];\\n        _tokenRecords.shares[_account] += _shares;\\n        _tokenRecords.totalShares += _shares;\\n    }\\n\\n    function _releaseToken(address _account, IERC20 _token) private returns (uint256) {\\n        uint256 amountToRelease = getAmountDue(_account, _token);\\n        require(amountToRelease != 0, \\\"FS: NO_PAYMENT_DUE\\\");\\n\\n        TokenRecords storage _tokenRecords = tokenRecords[address(_token)];\\n        _tokenRecords.released[_account] += amountToRelease;\\n        _tokenRecords.totalReleased += amountToRelease;\\n\\n        return amountToRelease;\\n    }\\n\\n    function _addShareholder(address _account, uint96 _weight) private {\\n        require(_weight != 0, \\\"FS: ZERO_WEIGHT\\\");\\n        require(_account != address(0), \\\"FS: INVALID_ADDRESS\\\");\\n        for (uint256 i = 0; i < shareholders.length; i++) {\\n            require(shareholders[i].account != _account, \\\"FS: ALREADY_SHAREHOLDER\\\");\\n        }\\n\\n        shareholders.push(Shareholder(_account, _weight));\\n        totalWeights += _weight;\\n        emit ShareholdersAdded(_account, _weight);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NestedReserve.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./abstracts/OwnableFactoryHandler.sol\\\";\\n\\n/// @title Stores underlying assets of NestedNFTs.\\n/// @notice The factory itself can only trigger a transfer after verification that the user\\n///         holds funds present in this contract. Only the factory can withdraw/transfer assets.\\ncontract NestedReserve is OwnableFactoryHandler {\\n    /// @notice Release funds to a recipient\\n    /// @param _recipient The receiver\\n    /// @param _token The token to transfer\\n    /// @param _amount The amount to transfer\\n    function transfer(\\n        address _recipient,\\n        IERC20 _token,\\n        uint256 _amount\\n    ) external onlyFactory {\\n        require(_recipient != address(0), \\\"NRS: INVALID_ADDRESS\\\");\\n        SafeERC20.safeTransfer(_token, _recipient, _amount);\\n    }\\n\\n    /// @notice Release funds to the factory\\n    /// @param _token The ERC20 to transfer\\n    /// @param _amount The amount to transfer\\n    function withdraw(IERC20 _token, uint256 _amount) external onlyFactory {\\n        SafeERC20.safeTransfer(_token, msg.sender, _amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NestedAsset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\nimport \\\"./abstracts/OwnableFactoryHandler.sol\\\";\\n\\n/// @title Collection of NestedNFTs used to represent ownership of real assets stored in NestedReserves\\n/// @dev Only NestedFactory contracts are allowed to call functions that write to storage\\ncontract NestedAsset is ERC721Enumerable, OwnableFactoryHandler {\\n    using Counters for Counters.Counter;\\n\\n    /* ----------------------------- VARIABLES ----------------------------- */\\n\\n    Counters.Counter private _tokenIds;\\n\\n    /// @dev Base URI (API)\\n    string public baseUri;\\n\\n    /// @dev Token URI when not revealed\\n    string public unrevealedTokenUri;\\n\\n    /// @dev NFT contract URI\\n    string public contractUri;\\n\\n    /// @dev Stores the original asset of each asset\\n    mapping(uint256 => uint256) public originalAsset;\\n\\n    /// @dev Stores owners of burnt assets\\n    mapping(uint256 => address) public lastOwnerBeforeBurn;\\n\\n    /// @dev True if revealed, false if not.\\n    bool public isRevealed;\\n\\n    /* ---------------------------- CONSTRUCTORS --------------------------- */\\n\\n    constructor() ERC721(\\\"NestedNFT\\\", \\\"NESTED\\\") {}\\n\\n    /* ----------------------------- MODIFIERS ----------------------------- */\\n\\n    /// @dev Reverts the transaction if the address is not the token owner\\n    modifier onlyTokenOwner(address _address, uint256 _tokenId) {\\n        require(_address == ownerOf(_tokenId), \\\"NA: FORBIDDEN_NOT_OWNER\\\");\\n        _;\\n    }\\n\\n    /* ------------------------------- VIEWS ------------------------------- */\\n\\n    /// @notice Get the Uniform Resource Identifier (URI) for `tokenId` token.\\n    /// @param _tokenId The id of the NestedAsset\\n    /// @return The token Uniform Resource Identifier (URI)\\n    function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\\n        require(_exists(_tokenId), \\\"URI query for nonexistent token\\\");\\n        if (isRevealed) {\\n            return super.tokenURI(_tokenId);\\n        } else {\\n            return unrevealedTokenUri;\\n        }\\n    }\\n\\n    /// @inheritdoc ERC721\\n    function _baseURI() internal view override returns (string memory) {\\n        return baseUri;\\n    }\\n\\n    /// @notice Returns the owner of the original token if the token was replicated\\n    /// If the original asset was burnt, the last owner before burn is returned\\n    /// @param _tokenId The asset for which we want to know the original owner\\n    /// @return The owner of the original asset\\n    function originalOwner(uint256 _tokenId) external view returns (address) {\\n        uint256 originalAssetId = originalAsset[_tokenId];\\n\\n        if (originalAssetId != 0) {\\n            return _exists(originalAssetId) ? ownerOf(originalAssetId) : lastOwnerBeforeBurn[originalAssetId];\\n        }\\n        return address(0);\\n    }\\n\\n    /* ---------------------------- ONLY FACTORY --------------------------- */\\n\\n    /// @notice Mints an ERC721 token for the user and stores the original asset used to create the new asset if any\\n    /// @param _owner The account address that signed the transaction\\n    /// @param _replicatedTokenId The token id of the replicated asset, 0 if no replication\\n    /// @return The minted token's id\\n    function mint(address _owner, uint256 _replicatedTokenId) public onlyFactory returns (uint256) {\\n        _tokenIds.increment();\\n\\n        uint256 tokenId = _tokenIds.current();\\n        _safeMint(_owner, tokenId);\\n\\n        // Stores the first asset of the replication chain as the original\\n        if (_replicatedTokenId == 0) {\\n            return tokenId;\\n        }\\n\\n        require(_exists(_replicatedTokenId), \\\"NA: NON_EXISTENT_TOKEN_ID\\\");\\n        require(tokenId != _replicatedTokenId, \\\"NA: SELF_DUPLICATION\\\");\\n\\n        uint256 originalTokenId = originalAsset[_replicatedTokenId];\\n        originalAsset[tokenId] = originalTokenId != 0 ? originalTokenId : _replicatedTokenId;\\n\\n        return tokenId;\\n    }\\n\\n    /// @notice Burns an ERC721 token\\n    /// @param _owner The account address that signed the transaction\\n    /// @param _tokenId The id of the NestedAsset\\n    function burn(address _owner, uint256 _tokenId) external onlyFactory onlyTokenOwner(_owner, _tokenId) {\\n        lastOwnerBeforeBurn[_tokenId] = _owner;\\n        _burn(_tokenId);\\n    }\\n\\n    /* ----------------------------- ONLY OWNER ---------------------------- */\\n\\n    /// @notice Update isRevealed to reveal or hide the token URI\\n    function setIsRevealed(bool _isRevealed) external onlyOwner {\\n        isRevealed = _isRevealed;\\n    }\\n\\n    /// @notice Set the base URI (once revealed)\\n    /// @param _baseUri The new baseURI\\n    function setBaseURI(string memory _baseUri) external onlyOwner {\\n        require(bytes(_baseUri).length != 0, \\\"NA: EMPTY_URI\\\");\\n        baseUri = _baseUri;\\n    }\\n\\n    /// @notice Set the unrevealed token URI (fixed)\\n    /// @param _newUri The new unrevealed URI\\n    function setUnrevealedTokenURI(string memory _newUri) external onlyOwner {\\n        require(bytes(_newUri).length != 0, \\\"NA: EMPTY_URI\\\");\\n        unrevealedTokenUri = _newUri;\\n    }\\n\\n    /// @notice Set the contract URI\\n    /// @param _newUri The new contract URI\\n    function setContractURI(string memory _newUri) external onlyOwner {\\n        contractUri = _newUri;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/NestedRecords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"./abstracts/OwnableFactoryHandler.sol\\\";\\n\\n/// @title Tracks data for underlying assets of NestedNFTs\\ncontract NestedRecords is OwnableFactoryHandler {\\n    /* ------------------------------ EVENTS ------------------------------ */\\n\\n    /// @dev Emitted when maxHoldingsCount is updated\\n    /// @param maxHoldingsCount The new value\\n    event MaxHoldingsChanges(uint256 maxHoldingsCount);\\n\\n    /// @dev Emitted when the lock timestamp of an NFT is increased\\n    /// @param nftId The NFT ID\\n    /// @param timestamp The new lock timestamp of the portfolio\\n    event LockTimestampIncreased(uint256 nftId, uint256 timestamp);\\n\\n    /// @dev Emitted when the reserve is updated for a specific portfolio\\n    /// @param nftId The NFT ID\\n    /// @param newReserve The new reserve address\\n    event ReserveUpdated(uint256 nftId, address newReserve);\\n\\n    /* ------------------------------ STRUCTS ------------------------------ */\\n\\n    /// @dev Store user asset informations\\n    struct NftRecord {\\n        mapping(address => uint256) holdings;\\n        address[] tokens;\\n        address reserve;\\n        uint256 lockTimestamp;\\n    }\\n\\n    /* ----------------------------- VARIABLES ----------------------------- */\\n\\n    /// @dev stores for each NFT ID an asset record\\n    mapping(uint256 => NftRecord) public records;\\n\\n    /// @dev The maximum number of holdings for an NFT record\\n    uint256 public maxHoldingsCount;\\n\\n    /* ---------------------------- CONSTRUCTOR ---------------------------- */\\n\\n    constructor(uint256 _maxHoldingsCount) {\\n        maxHoldingsCount = _maxHoldingsCount;\\n    }\\n\\n    /* -------------------------- OWNER FUNCTIONS -------------------------- */\\n\\n    /// @notice Sets the maximum number of holdings for an NFT record\\n    /// @param _maxHoldingsCount The new maximum number of holdings\\n    function setMaxHoldingsCount(uint256 _maxHoldingsCount) external onlyOwner {\\n        require(_maxHoldingsCount != 0, \\\"NRC: INVALID_MAX_HOLDINGS\\\");\\n        maxHoldingsCount = _maxHoldingsCount;\\n        emit MaxHoldingsChanges(maxHoldingsCount);\\n    }\\n\\n    /* ------------------------- FACTORY FUNCTIONS ------------------------- */\\n\\n    /// @notice Update the amount for a specific holding and delete\\n    /// the holding if the amount is zero.\\n    /// @param _nftId The id of the NFT\\n    /// @param _token The token/holding address\\n    /// @param _amount Updated amount for this asset\\n    function updateHoldingAmount(\\n        uint256 _nftId,\\n        address _token,\\n        uint256 _amount\\n    ) public onlyFactory {\\n        if (_amount == 0) {\\n            uint256 tokenIndex = 0;\\n            address[] memory tokens = getAssetTokens(_nftId);\\n            while (tokenIndex < tokens.length) {\\n                if (tokens[tokenIndex] == _token) {\\n                    deleteAsset(_nftId, tokenIndex);\\n                    break;\\n                }\\n                tokenIndex++;\\n            }\\n        } else {\\n            records[_nftId].holdings[_token] = _amount;\\n        }\\n    }\\n\\n    /// @notice Fully delete a holding record for an NFT\\n    /// @param _nftId The id of the NFT\\n    /// @param _tokenIndex The token index in holdings array\\n    function deleteAsset(uint256 _nftId, uint256 _tokenIndex) public onlyFactory {\\n        address[] storage tokens = records[_nftId].tokens;\\n        address token = tokens[_tokenIndex];\\n\\n        require(records[_nftId].holdings[token] != 0, \\\"NRC: HOLDING_INACTIVE\\\");\\n\\n        delete records[_nftId].holdings[token];\\n        tokens[_tokenIndex] = tokens[tokens.length - 1];\\n        tokens.pop();\\n    }\\n\\n    /// @notice Delete a holding item in holding mapping. Does not remove token in NftRecord.tokens array\\n    /// @param _nftId NFT's identifier\\n    /// @param _token Token address for holding to remove\\n    function freeHolding(uint256 _nftId, address _token) public onlyFactory {\\n        delete records[_nftId].holdings[_token];\\n    }\\n\\n    /// @notice Helper function that creates a record or add the holding if record already exists\\n    /// @param _nftId The NFT's identifier\\n    /// @param _token The token/holding address\\n    /// @param _amount Amount to add for this asset\\n    /// @param _reserve Reserve address\\n    function store(\\n        uint256 _nftId,\\n        address _token,\\n        uint256 _amount,\\n        address _reserve\\n    ) external onlyFactory {\\n        NftRecord storage _nftRecord = records[_nftId];\\n\\n        uint256 amount = records[_nftId].holdings[_token];\\n        require(_amount != 0, \\\"NRC: INVALID_AMOUNT\\\");\\n        if (amount != 0) {\\n            require(_nftRecord.reserve == _reserve, \\\"NRC: RESERVE_MISMATCH\\\");\\n            updateHoldingAmount(_nftId, _token, amount + _amount);\\n            return;\\n        }\\n        require(_nftRecord.tokens.length < maxHoldingsCount, \\\"NRC: TOO_MANY_TOKENS\\\");\\n        require(\\n            _reserve != address(0) && (_reserve == _nftRecord.reserve || _nftRecord.reserve == address(0)),\\n            \\\"NRC: INVALID_RESERVE\\\"\\n        );\\n\\n        _nftRecord.holdings[_token] = _amount;\\n        _nftRecord.tokens.push(_token);\\n        _nftRecord.reserve = _reserve;\\n    }\\n\\n    /// @notice The factory can update the lock timestamp of a NFT record\\n    /// The new timestamp must be greater than the records lockTimestamp\\n    //  if block.timestamp > actual lock timestamp\\n    /// @param _nftId The NFT id to get the record\\n    /// @param _timestamp The new timestamp\\n    function updateLockTimestamp(uint256 _nftId, uint256 _timestamp) external onlyFactory {\\n        require(_timestamp > records[_nftId].lockTimestamp, \\\"NRC: LOCK_PERIOD_CANT_DECREASE\\\");\\n        records[_nftId].lockTimestamp = _timestamp;\\n        emit LockTimestampIncreased(_nftId, _timestamp);\\n    }\\n\\n    /// @notice Delete from mapping assetTokens\\n    /// @param _nftId The id of the NFT\\n    function removeNFT(uint256 _nftId) external onlyFactory {\\n        delete records[_nftId];\\n    }\\n\\n    /// @notice Set the reserve where assets are stored\\n    /// @param _nftId The NFT ID to update\\n    /// @param _nextReserve Address for the new reserve\\n    function setReserve(uint256 _nftId, address _nextReserve) external onlyFactory {\\n        records[_nftId].reserve = _nextReserve;\\n        emit ReserveUpdated(_nftId, _nextReserve);\\n    }\\n\\n    /* ------------------------------- VIEWS ------------------------------- */\\n\\n    /// @notice Get content of assetTokens mapping\\n    /// @param _nftId The id of the NFT\\n    /// @return Array of token addresses\\n    function getAssetTokens(uint256 _nftId) public view returns (address[] memory) {\\n        return records[_nftId].tokens;\\n    }\\n\\n    /// @notice Get reserve the assets are stored in\\n    /// @param _nftId The NFT ID\\n    /// @return The reserve address these assets are stored in\\n    function getAssetReserve(uint256 _nftId) external view returns (address) {\\n        return records[_nftId].reserve;\\n    }\\n\\n    /// @notice Get how many tokens are in a portfolio/NFT\\n    /// @param _nftId NFT ID to examine\\n    /// @return The array length\\n    function getAssetTokensLength(uint256 _nftId) external view returns (uint256) {\\n        return records[_nftId].tokens.length;\\n    }\\n\\n    /// @notice Get holding amount for a given nft id\\n    /// @param _nftId The id of the NFT\\n    /// @param _token The address of the token\\n    /// @return The holding amount\\n    function getAssetHolding(uint256 _nftId, address _token) public view returns (uint256) {\\n        return records[_nftId].holdings[_token];\\n    }\\n\\n    /// @notice Returns the holdings associated to a NestedAsset\\n    /// @param _nftId the id of the NestedAsset\\n    /// @return Two arrays with the same length :\\n    ///         - The token addresses in the portfolio\\n    ///         - The respective amounts\\n    function tokenHoldings(uint256 _nftId) external view returns (address[] memory, uint256[] memory) {\\n        address[] memory tokens = getAssetTokens(_nftId);\\n        uint256 tokensCount = tokens.length;\\n        uint256[] memory amounts = new uint256[](tokensCount);\\n\\n        for (uint256 i = 0; i < tokensCount; i++) {\\n            amounts[i] = getAssetHolding(_nftId, tokens[i]);\\n        }\\n        return (tokens, amounts);\\n    }\\n\\n    /// @notice Get the lock timestamp of a portfolio/NFT\\n    /// @param _nftId The NFT ID\\n    /// @return The lock timestamp from the NftRecord\\n    function getLockTimestamp(uint256 _nftId) external view returns (uint256) {\\n        return records[_nftId].lockTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Withdrawer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/external/IWETH.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\n/// @title Native token withdrawer\\n/// @dev Withdraw native token from the wrapper contract on behalf\\n///      of the sender. Upgradeable proxy contracts are not able to receive\\n///      native tokens from contracts via `transfer` (EIP1884), they need a\\n///      middleman forwarding all available gas and reverting on errors.\\ncontract Withdrawer is ReentrancyGuard {\\n    IWETH public immutable weth;\\n\\n    constructor(IWETH _weth) {\\n        weth = _weth;\\n    }\\n\\n    receive() external payable {\\n        require(msg.sender == address(weth), \\\"WD: ETH_SENDER_NOT_WETH\\\");\\n    }\\n\\n    /// @notice Withdraw native token from wrapper contract\\n    /// @param amount The amount to withdraw\\n    function withdraw(uint256 amount) external nonReentrant {\\n        weth.transferFrom(msg.sender, address(this), amount);\\n        weth.withdraw(amount);\\n        Address.sendValue(payable(msg.sender), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"hardhat/console.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/StorageSlot.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlot {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/OperatorResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"./interfaces/IOperatorResolver.sol\\\";\\nimport \\\"./abstracts/MixinOperatorResolver.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Operator Resolver implementation\\n/// @notice Resolve the operators address\\ncontract OperatorResolver is IOperatorResolver, Ownable {\\n    /// @dev Operators map of the name and address\\n    mapping(bytes32 => Operator) public operators;\\n\\n    /// @inheritdoc IOperatorResolver\\n    function getOperator(bytes32 name) external view override returns (Operator memory) {\\n        return operators[name];\\n    }\\n\\n    /// @inheritdoc IOperatorResolver\\n    function requireAndGetOperator(bytes32 name, string calldata reason)\\n        external\\n        view\\n        override\\n        returns (Operator memory)\\n    {\\n        Operator memory _foundOperator = operators[name];\\n        require(_foundOperator.implementation != address(0), reason);\\n        return _foundOperator;\\n    }\\n\\n    /// @inheritdoc IOperatorResolver\\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        uint256 namesLength = names.length;\\n        require(namesLength == destinations.length, \\\"OR: INPUTS_LENGTH_MUST_MATCH\\\");\\n        for (uint256 i = 0; i < namesLength; i++) {\\n            if (\\n                operators[names[i]].implementation != destinations[i].implementation ||\\n                operators[names[i]].selector != destinations[i].selector\\n            ) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    /// @inheritdoc IOperatorResolver\\n    function importOperators(\\n        bytes32[] calldata names,\\n        Operator[] calldata operatorsToImport,\\n        MixinOperatorResolver[] calldata destinations\\n    ) external override onlyOwner {\\n        require(names.length == operatorsToImport.length, \\\"OR: INPUTS_LENGTH_MUST_MATCH\\\");\\n        bytes32 name;\\n        Operator calldata destination;\\n        for (uint256 i = 0; i < names.length; i++) {\\n            name = names[i];\\n            destination = operatorsToImport[i];\\n            operators[name] = destination;\\n            emit OperatorImported(name, destination);\\n        }\\n\\n        // rebuild caches atomically\\n        // see. https://github.com/code-423n4/2021-11-nested-findings/issues/217\\n        rebuildCaches(destinations);\\n    }\\n\\n    /// @notice rebuild the caches of mixin smart contracts\\n    /// @param destinations The list of mixinOperatorResolver to rebuild\\n    function rebuildCaches(MixinOperatorResolver[] calldata destinations) public onlyOwner {\\n        for (uint256 i = 0; i < destinations.length; i++) {\\n            destinations[i].rebuildCache();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOperatorResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"../abstracts/MixinOperatorResolver.sol\\\";\\n\\n/// @title Operator address resolver interface\\ninterface IOperatorResolver {\\n    /// @dev Represents an operator definition\\n    /// @param implementation Contract address\\n    /// @param selector Function selector\\n    struct Operator {\\n        address implementation;\\n        bytes4 selector;\\n    }\\n\\n    /// @notice Emitted when an operator is imported\\n    /// @param name The operator name\\n    /// @param destination The operator definition\\n    event OperatorImported(bytes32 name, Operator destination);\\n\\n    /// @notice Get an operator (address/selector) for a given name\\n    /// @param name The operator name\\n    /// @return The operator struct (address/selector)\\n    function getOperator(bytes32 name) external view returns (Operator memory);\\n\\n    /// @notice Get an operator (address/selector) for a given name but require the operator to exist.\\n    /// @param name The operator name\\n    /// @param reason Require message\\n    /// @return The operator struct (address/selector)\\n    function requireAndGetOperator(bytes32 name, string calldata reason) external view returns (Operator memory);\\n\\n    /// @notice Check if some operators are imported with the right name (and vice versa)\\n    /// @dev The check is performed on the index, make sure that the two arrays match\\n    /// @param names The operator names\\n    /// @param destinations The operator addresses\\n    /// @return True if all the addresses/names are correctly imported, false otherwise\\n    function areOperatorsImported(bytes32[] calldata names, Operator[] calldata destinations)\\n        external\\n        view\\n        returns (bool);\\n\\n    /// @notice Import/replace operators\\n    /// @dev names and destinations arrays must coincide\\n    /// @param names Hashes of the operators names to register\\n    /// @param operatorsToImport Operators to import\\n    /// @param destinations Destinations to rebuild cache atomically\\n    function importOperators(\\n        bytes32[] calldata names,\\n        Operator[] calldata operatorsToImport,\\n        MixinOperatorResolver[] calldata destinations\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/abstracts/OwnableFactoryHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title Asbtract \\\"Ownable\\\" contract managing a whitelist of factories\\nabstract contract OwnableFactoryHandler is Ownable {\\n    /// @dev Emitted when a new factory is added\\n    /// @param newFactory Address of the new factory\\n    event FactoryAdded(address newFactory);\\n\\n    /// @dev Emitted when a factory is removed\\n    /// @param oldFactory Address of the removed factory\\n    event FactoryRemoved(address oldFactory);\\n\\n    /// @dev Supported factories to interact with\\n    mapping(address => bool) public supportedFactories;\\n\\n    /// @dev Reverts the transaction if the caller is a supported factory\\n    modifier onlyFactory() {\\n        require(supportedFactories[msg.sender], \\\"OFH: FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    /// @notice Add a supported factory\\n    /// @param _factory The address of the new factory\\n    function addFactory(address _factory) external onlyOwner {\\n        require(_factory != address(0), \\\"OFH: INVALID_ADDRESS\\\");\\n        supportedFactories[_factory] = true;\\n        emit FactoryAdded(_factory);\\n    }\\n\\n    /// @notice Remove a supported factory\\n    /// @param _factory The address of the factory to remove\\n    function removeFactory(address _factory) external onlyOwner {\\n        require(supportedFactories[_factory], \\\"OFH: NOT_SUPPORTED\\\");\\n        supportedFactories[_factory] = false;\\n        emit FactoryRemoved(_factory);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract NestedAsset\",\"name\":\"_nestedAsset\",\"type\":\"address\"},{\"internalType\":\"contract NestedRecords\",\"name\":\"_nestedRecords\",\"type\":\"address\"},{\"internalType\":\"contract NestedReserve\",\"name\":\"_reserve\",\"type\":\"address\"},{\"internalType\":\"contract FeeSplitter\",\"name\":\"_feeSplitter\",\"type\":\"address\"},{\"internalType\":\"contract IWETH\",\"name\":\"_weth\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operatorResolver\",\"type\":\"address\"},{\"internalType\":\"contract Withdrawer\",\"name\":\"_withdrawer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"}],\"indexed\":false,\"internalType\":\"struct IOperatorResolver.Operator\",\"name\":\"destination\",\"type\":\"tuple\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"entryFees\",\"type\":\"uint256\"}],\"name\":\"EntryFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"exitFees\",\"type\":\"uint256\"}],\"name\":\"ExitFeesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeSplitter\",\"type\":\"address\"}],\"name\":\"FeeSplitterUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originalNftId\",\"type\":\"uint256\"}],\"name\":\"NftCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"NftUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newOperator\",\"type\":\"bytes32\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"oldOperator\",\"type\":\"bytes32\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"ReserveUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensUnlocked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"}],\"name\":\"addOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_originalTokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"fromReserve\",\"type\":\"bool\"}],\"internalType\":\"struct INestedFactory.BatchedInputOrders[]\",\"name\":\"_batchedOrders\",\"type\":\"tuple[]\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_buyToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"_orders\",\"type\":\"tuple[]\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeSplitter\",\"outputs\":[{\"internalType\":\"contract FeeSplitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nestedAsset\",\"outputs\":[{\"internalType\":\"contract NestedAsset\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nestedRecords\",\"outputs\":[{\"internalType\":\"contract NestedRecords\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"fromReserve\",\"type\":\"bool\"}],\"internalType\":\"struct INestedFactory.BatchedInputOrders[]\",\"name\":\"_batchedInputOrders\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"toReserve\",\"type\":\"bool\"}],\"internalType\":\"struct INestedFactory.BatchedOutputOrders[]\",\"name\":\"_batchedOutputOrders\",\"type\":\"tuple[]\"}],\"name\":\"processInputAndOutputOrders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"fromReserve\",\"type\":\"bool\"}],\"internalType\":\"struct INestedFactory.BatchedInputOrders[]\",\"name\":\"_batchedOrders\",\"type\":\"tuple[]\"}],\"name\":\"processInputOrders\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"contract IERC20\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct INestedFactory.Order[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bool\",\"name\":\"toReserve\",\"type\":\"bool\"}],\"internalType\":\"struct INestedFactory.BatchedOutputOrders[]\",\"name\":\"_batchedOrders\",\"type\":\"tuple[]\"}],\"name\":\"processOutputOrders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"operator\",\"type\":\"bytes32\"}],\"name\":\"removeOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserve\",\"outputs\":[{\"internalType\":\"contract NestedReserve\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract OperatorResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolverOperatorsRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_entryFees\",\"type\":\"uint256\"}],\"name\":\"setEntryFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_exitFees\",\"type\":\"uint256\"}],\"name\":\"setExitFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract FeeSplitter\",\"name\":\"_feeSplitter\",\"type\":\"address\"}],\"name\":\"setFeeSplitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unlockTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"updateLockTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"contract IWETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenIndex\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NestedFactory", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "0000000000000000000000006cbe14812b9d537878b975994948aeb917339331000000000000000000000000db714302a7ffcc9610610a01126e1257b90a67a10000000000000000000000000535f1f43ee274123291bbab284948caed46c65d000000000000000000000000b818de71b8acee27c17a40446012663d4c71b437000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000004a7307e94fd83b2fe88537729640ea7a0ad376b0000000000000000000000008792f0ee8e1dcfcdf69421fe98b9eb4752191fe5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}