{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.8.2 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.4.1\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/proxy/beacon/IBeacon.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\r\n */\r\ninterface IBeacon {\r\n    /**\r\n     * @dev Must return an address that can be used as a delegate call target.\r\n     *\r\n     * {BeaconProxy} will check that this address is a contract.\r\n     */\r\n    function implementation() external view returns (address);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/StorageSlot.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Library for reading and writing primitive types to specific storage slots.\r\n *\r\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\r\n * This library helps with reading and writing to such slots without the need for inline assembly.\r\n *\r\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\r\n *\r\n * Example usage to set ERC1967 implementation slot:\r\n * ```\r\n * contract ERC1967 {\r\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n *\r\n *     function _getImplementation() internal view returns (address) {\r\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n *     }\r\n *\r\n *     function _setImplementation(address newImplementation) internal {\r\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\r\n */\r\nlibrary StorageSlot {\r\n    struct AddressSlot {\r\n        address value;\r\n    }\r\n\r\n    struct BooleanSlot {\r\n        bool value;\r\n    }\r\n\r\n    struct Bytes32Slot {\r\n        bytes32 value;\r\n    }\r\n\r\n    struct Uint256Slot {\r\n        uint256 value;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\r\n     */\r\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\r\n     */\r\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\r\n     */\r\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\r\n     */\r\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\r\n        assembly {\r\n            r.slot := slot\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\r\n\r\npragma solidity ^0.8.2;\r\n\r\n\r\n\r\n/**\r\n * @dev This abstract contract provides getters and event emitting update functions for\r\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\r\n *\r\n * _Available since v4.1._\r\n *\r\n * @custom:oz-upgrades-unsafe-allow delegatecall\r\n */\r\nabstract contract ERC1967Upgrade {\r\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\r\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\r\n\r\n    /**\r\n     * @dev Emitted when the implementation is upgraded.\r\n     */\r\n    event Upgraded(address indexed implementation);\r\n\r\n    /**\r\n     * @dev Returns the current implementation address.\r\n     */\r\n    function _getImplementation() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 implementation slot.\r\n     */\r\n    function _setImplementation(address newImplementation) private {\r\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\r\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeTo(address newImplementation) internal {\r\n        _setImplementation(newImplementation);\r\n        emit Upgraded(newImplementation);\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCall(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _upgradeTo(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(newImplementation, data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function _upgradeToAndCallSecure(\r\n        address newImplementation,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        address oldImplementation = _getImplementation();\r\n\r\n        // Initial upgrade and setup call\r\n        _setImplementation(newImplementation);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(newImplementation, data);\r\n        }\r\n\r\n        // Perform rollback test if not already in progress\r\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\r\n        if (!rollbackTesting.value) {\r\n            // Trigger rollback using upgradeTo from the new implementation\r\n            rollbackTesting.value = true;\r\n            Address.functionDelegateCall(\r\n                newImplementation,\r\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\r\n            );\r\n            rollbackTesting.value = false;\r\n            // Check rollback was effective\r\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\r\n            // Finally reset to the new implementation and log the upgrade\r\n            _upgradeTo(newImplementation);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Storage slot with the admin of the contract.\r\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\r\n     * validated in the constructor.\r\n     */\r\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\r\n\r\n    /**\r\n     * @dev Emitted when the admin account has changed.\r\n     */\r\n    event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n    /**\r\n     * @dev Returns the current admin.\r\n     */\r\n    function _getAdmin() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new address in the EIP1967 admin slot.\r\n     */\r\n    function _setAdmin(address newAdmin) private {\r\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\r\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Changes the admin of the proxy.\r\n     *\r\n     * Emits an {AdminChanged} event.\r\n     */\r\n    function _changeAdmin(address newAdmin) internal {\r\n        emit AdminChanged(_getAdmin(), newAdmin);\r\n        _setAdmin(newAdmin);\r\n    }\r\n\r\n    /**\r\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\r\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\r\n\r\n    /**\r\n     * @dev Emitted when the beacon is upgraded.\r\n     */\r\n    event BeaconUpgraded(address indexed beacon);\r\n\r\n    /**\r\n     * @dev Returns the current beacon.\r\n     */\r\n    function _getBeacon() internal view returns (address) {\r\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\r\n    }\r\n\r\n    /**\r\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\r\n     */\r\n    function _setBeacon(address newBeacon) private {\r\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\r\n        require(\r\n            Address.isContract(IBeacon(newBeacon).implementation()),\r\n            \"ERC1967: beacon implementation is not a contract\"\r\n        );\r\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\r\n    }\r\n\r\n    /**\r\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\r\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\r\n     *\r\n     * Emits a {BeaconUpgraded} event.\r\n     */\r\n    function _upgradeBeaconToAndCall(\r\n        address newBeacon,\r\n        bytes memory data,\r\n        bool forceCall\r\n    ) internal {\r\n        _setBeacon(newBeacon);\r\n        emit BeaconUpgraded(newBeacon);\r\n        if (data.length > 0 || forceCall) {\r\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol@v4.4.1\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\r\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\r\n *\r\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\r\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\r\n * `UUPSUpgradeable` with a custom implementation of upgrades.\r\n *\r\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\r\n *\r\n * _Available since v4.1._\r\n */\r\nabstract contract UUPSUpgradeable is ERC1967Upgrade {\r\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\r\n    address private immutable __self = address(this);\r\n\r\n    /**\r\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\r\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\r\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\r\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\r\n     * fail.\r\n     */\r\n    modifier onlyProxy() {\r\n        require(address(this) != __self, \"Function must be called through delegatecall\");\r\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\r\n     * encoded in `data`.\r\n     *\r\n     * Calls {_authorizeUpgrade}.\r\n     *\r\n     * Emits an {Upgraded} event.\r\n     */\r\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\r\n        _authorizeUpgrade(newImplementation);\r\n        _upgradeToAndCallSecure(newImplementation, data, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\r\n     * {upgradeTo} and {upgradeToAndCall}.\r\n     *\r\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\r\n     *\r\n     * ```solidity\r\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\r\n     * ```\r\n     */\r\n    function _authorizeUpgrade(address newImplementation) internal virtual;\r\n}\r\n\r\n\r\n// File contracts/upgrade/Owned.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// Modified from https://docs.synthetix.io/contracts/source/contracts/owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    /// @dev Change constructor to initialize function for upgradeable contract\r\n    function initializeOwner(address _owner) internal {\r\n        require(owner == address(0), \"Already initialized\");\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    function _onlyOwner() private view {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n// File contracts/upgrade/Pausable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n// Modified from https://docs.synthetix.io/contracts/source/contracts/pausable\r\ncontract Pausable is Owned {\r\n    uint public lastPauseTime;\r\n    bool public paused;\r\n\r\n    /// @dev Change constructor to initialize function for upgradeable contract\r\n    function initializePausable(address _owner) internal {\r\n        super.initializeOwner(_owner);\r\n\r\n        require(owner != address(0), \"Owner must be set\");\r\n        // Paused will be false, and lastPauseTime will be 0 upon initialisation\r\n    }\r\n\r\n    /**\r\n     * @notice Change the paused state of the contract\r\n     * @dev Only the contract owner may call this.\r\n     */\r\n    function setPaused(bool _paused) external onlyOwner {\r\n        // Ensure we're actually changing the state before we do anything\r\n        if (_paused == paused) {\r\n            return;\r\n        }\r\n\r\n        // Set our paused state.\r\n        paused = _paused;\r\n\r\n        // If applicable, set the last pause time.\r\n        if (paused) {\r\n            lastPauseTime = block.timestamp;\r\n        }\r\n\r\n        // Let everyone know that our pause state has changed.\r\n        emit PauseChanged(paused);\r\n    }\r\n\r\n    event PauseChanged(bool isPaused);\r\n\r\n    modifier notPaused {\r\n        require(!paused, \"This action cannot be performed while the contract is paused\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/upgrade/ReentrancyGuard.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the `nonReentrant` modifier\r\n * available, which can be aplied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n */\r\ncontract ReentrancyGuard {\r\n    /// @dev counter to allow mutex lock with only one SSTORE operation\r\n    uint256 private _guardCounter;\r\n\r\n    /// @dev Change constructor to initialize function for upgradeable contract\r\n    function initializeReentrancyGuard() internal {\r\n        require(_guardCounter == 0, \"Already initialized\");\r\n        // The counter starts at one to prevent changing it from zero to a non-zero\r\n        // value, which is a more expensive operation.\r\n        _guardCounter = 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _guardCounter += 1;\r\n        uint256 localCounter = _guardCounter;\r\n        _;\r\n        require(localCounter == _guardCounter, \"ReentrancyGuard: reentrant call\");\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IDepositCompound.sol\r\n\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\n// Curve DepositCompound contract interface\r\ninterface IDepositCompound {\r\n    function underlying_coins(int128 arg0) external view returns (address);\r\n\r\n    function token() external view returns (address);\r\n\r\n    function add_liquidity(uint256[2] calldata uamounts, uint256 min_mint_amount) external;\r\n\r\n    function remove_liquidity(uint256 _amount, uint256[2] calldata min_uamounts) external;\r\n\r\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_uamount, bool donate_dust) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IConvexBaseRewardPool.sol\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\ninterface IConvexBaseRewardPool {\r\n    // Views\r\n\r\n    function rewards(address account) external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function earned(address account) external view returns (uint256);\r\n\r\n    function getRewardForDuration() external view returns (uint256);\r\n\r\n    function lastTimeRewardApplicable() external view returns (uint256);\r\n\r\n    function rewardPerToken() external view returns (uint256);\r\n\r\n    function stakingToken() external view returns (address);\r\n\r\n    function rewardToken() external view returns (address);\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    // Mutative\r\n\r\n    function getReward(address _account, bool _claimExtras) external returns (bool);\r\n\r\n    function stake(uint256 _amount) external returns (bool);\r\n\r\n    function withdraw(uint256 amount, bool claim) external returns (bool);\r\n\r\n    function withdrawAll(bool claim) external returns (bool);\r\n\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns (bool);\r\n\r\n    function withdrawAllAndUnwrap(bool claim) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IConvexBooster.sol\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\ninterface IConvexBooster {\r\n    struct PoolInfo {\r\n        address lptoken;\r\n        address token;\r\n        address gauge;\r\n        address crvRewards;\r\n        address stash;\r\n        bool shutdown;\r\n    }\r\n    function poolInfo(uint256 _pid) view external returns (PoolInfo memory);\r\n\r\n    function crv() external view returns (address);\r\n\r\n    function minter() external view returns (address);\r\n\r\n    function deposit(uint256 _pid, uint256 _amount, bool _stake) external returns(bool);\r\n\r\n    function depositAll(uint256 _pid, bool _stake) external returns(bool);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPancakePair.sol\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\ninterface IPancakePair {\r\n    function token0() external returns (address);\r\n    function token1() external returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IConverterUniV3.sol\r\n\r\npragma solidity >=0.5.0 <0.9.0;\r\n\r\ninterface IConverterUniV3 {\r\n    function NATIVE_TOKEN() external view returns (address);\r\n\r\n    function convert(\r\n        address _inTokenAddress,\r\n        uint256 _amount,\r\n        uint256 _convertPercentage,\r\n        address _outTokenAddress,\r\n        uint256 _minReceiveAmount,\r\n        address _recipient\r\n    ) external;\r\n\r\n    function convertAndAddLiquidity(\r\n        address _inTokenAddress,\r\n        uint256 _amount,\r\n        address _outTokenAddress,\r\n        uint256 _minReceiveAmountSwap,\r\n        uint256 _minInTokenAmountAddLiq,\r\n        uint256 _minOutTokenAmountAddLiq,\r\n        address _recipient\r\n    ) external;\r\n\r\n    function removeLiquidityAndConvert(\r\n        IPancakePair _lp,\r\n        uint256 _lpAmount,\r\n        uint256 _minToken0Amount,\r\n        uint256 _minToken1Amount,\r\n        uint256 _token0Percentage,\r\n        address _recipient\r\n    ) external;\r\n\r\n    function convertUniV3(\r\n        address _inTokenAddress,\r\n        uint256 _amount,\r\n        uint256 _convertPercentage,\r\n        address _outTokenAddress,\r\n        uint256 _minReceiveAmount,\r\n        address _recipient,\r\n        bytes memory _path\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IWeth.sol\r\n\r\npragma solidity >=0.7.0;\r\n\r\ninterface IWETH {\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 amount) external;\r\n\r\n    function transfer(address dst, uint256 wad) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address src,\r\n        address dst,\r\n        uint256 wad\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File contracts/curve_convex_farm/StakeCurveConvex.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Modified from https://docs.synthetix.io/contracts/source/contracts/stakingrewards\r\n/// @title A wrapper contract over Convex Booster and BaseRewardPool contract that allows single asset in/out.\r\n/// 1. User provide token0 or token1\r\n/// 2. contract converts half to the other token and provide liquidity on Curve\r\n/// 3. stake LP token via Convex Booster contract\r\n/// @dev Be aware that staking entry is Convex Booster contract while withdraw/getReward entry is BaseRewardPool contract.\r\n/// @notice Asset tokens are token0 and token1. Staking token is the LP token of token0/token1.\r\ncontract StakeCurveConvex is ReentrancyGuard, Pausable, UUPSUpgradeable {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct BalanceDiff {\r\n        uint256 balBefore;\r\n        uint256 balAfter;\r\n        uint256 balDiff;\r\n    }\r\n\r\n    /* ========== STATE VARIABLES ========== */\r\n\r\n    string public name;\r\n    uint256 public pid; // Pool ID in Convex Booster\r\n    IConverterUniV3 public converter;\r\n    IERC20 public lp;\r\n    IERC20 public token0;\r\n    IERC20 public token1;\r\n    IERC20 public crv;\r\n    IERC20 public cvx;\r\n    IERC20 public BCNT;\r\n\r\n    IDepositCompound public curveDepositCompound;\r\n    IConvexBooster public convexBooster;\r\n    IConvexBaseRewardPool public convexBaseRewardPool;\r\n\r\n    /// @dev Piggyback on BaseRewardPool' reward accounting\r\n    mapping(address => uint256) internal _userRewardPerTokenPaid;\r\n    mapping(address => uint256) internal _rewards;\r\n\r\n    uint256 internal _totalSupply;\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    uint256 public bcntRewardAmount;\r\n    address public operator;\r\n\r\n    bytes public cvxToBCNTUniV3SwapPath; // e.g., CVX -> WETH -> BCNT\r\n    bytes public crvToBCNTUniV3SwapPath; // e.g., CRV -> WETH -> BCNT\r\n\r\n    /* ========== FALLBACKS ========== */\r\n\r\n    receive() external payable {}\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    function initialize(\r\n        string memory _name,\r\n        uint256 _pid,\r\n        address _owner,\r\n        address _operator,\r\n        IConverterUniV3 _converter,\r\n        address _curveDepositCompound,\r\n        address _convexBooster,\r\n        address _convexBaseRewardPool,\r\n        address _BCNT\r\n    ) external {\r\n        require(keccak256(abi.encodePacked(name)) == keccak256(abi.encodePacked(\"\")), \"Already initialized\");\r\n        super.initializePausable(_owner);\r\n        super.initializeReentrancyGuard();\r\n\r\n        name = _name;\r\n        pid = _pid;\r\n        operator = _operator;\r\n        converter = _converter;\r\n        curveDepositCompound = IDepositCompound(_curveDepositCompound);\r\n        lp = IERC20(curveDepositCompound.token());\r\n        token0 = IERC20(curveDepositCompound.underlying_coins(0));\r\n        token1 = IERC20(curveDepositCompound.underlying_coins(1));\r\n        convexBooster = IConvexBooster(_convexBooster);\r\n        convexBaseRewardPool = IConvexBaseRewardPool(_convexBaseRewardPool);\r\n        crv = IERC20(convexBaseRewardPool.rewardToken());\r\n        require(address(convexBooster.crv()) == address(crv));\r\n        cvx = IERC20(convexBooster.minter());\r\n        BCNT = IERC20(_BCNT);\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n\r\n    /// @dev Get the implementation contract of this proxy contract.\r\n    /// Only to be used on the proxy contract. Otherwise it would return zero address.\r\n    function implementation() external view returns (address) {\r\n        return _getImplementation();\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) external view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /// @notice Get the reward share earned by specified account.\r\n    function _share(address account) public view returns (uint256) {\r\n        uint256 rewardPerToken = convexBaseRewardPool.rewardPerToken();\r\n        return (_balances[account] * (rewardPerToken - _userRewardPerTokenPaid[account]) / (1e18)) + _rewards[account];\r\n    }\r\n\r\n    /// @notice Get the total reward share in this contract.\r\n    /// @notice Total reward is tracked with `_rewards[address(this)]` and `_userRewardPerTokenPaid[address(this)]`\r\n    function _shareTotal() public view returns (uint256) {\r\n        uint256 rewardPerToken = convexBaseRewardPool.rewardPerToken();\r\n        return (_totalSupply * (rewardPerToken - _userRewardPerTokenPaid[address(this)]) / (1e18)) + _rewards[address(this)];\r\n    }\r\n\r\n    /// @notice Get the compounded LP amount earned by specified account.\r\n    function earned(address account) public view returns (uint256) {\r\n        uint256 rewardsShare;\r\n        if (account == address(this)){\r\n            rewardsShare = _shareTotal();\r\n        } else {\r\n            rewardsShare = _share(account);\r\n        }\r\n\r\n        uint256 earnedCompoundedLPAmount;\r\n        if (rewardsShare > 0) {\r\n            uint256 totalShare = _shareTotal();\r\n            // Earned compounded LP amount is proportional to how many rewards this account has\r\n            // among total rewards\r\n            earnedCompoundedLPAmount = bcntRewardAmount * rewardsShare / totalShare;\r\n        }\r\n        return earnedCompoundedLPAmount;\r\n    }\r\n\r\n    /* ========== MUTATIVE FUNCTIONS ========== */\r\n\r\n    function _convertAndAddLiquidity(\r\n        bool isToken0,\r\n        bool shouldTransferFromSender, \r\n        uint256 amount,\r\n        uint256 minLiqAddedAmount\r\n    ) internal returns (uint256 lpAmount) {\r\n        require(amount > 0, \"Cannot stake 0\");\r\n        uint256 lpAmountBefore = lp.balanceOf(address(this));\r\n        uint256 token0AmountBefore = token0.balanceOf(address(this));\r\n        uint256 token1AmountBefore = token1.balanceOf(address(this));\r\n\r\n        // Add liquidity\r\n        uint256[2] memory uamounts;\r\n        if (isToken0) {\r\n            if (shouldTransferFromSender) {\r\n                token0.safeTransferFrom(msg.sender, address(this), amount);\r\n            }\r\n            uamounts[0] = amount;\r\n            uamounts[1] = 0;\r\n            token0.safeApprove(address(curveDepositCompound), amount);\r\n            curveDepositCompound.add_liquidity(uamounts, minLiqAddedAmount);\r\n        } else {\r\n            if (shouldTransferFromSender) {\r\n                token1.safeTransferFrom(msg.sender, address(this), amount);\r\n            }\r\n            uamounts[0] = 0;\r\n            uamounts[1] = amount;\r\n            token1.safeApprove(address(curveDepositCompound), amount);\r\n            curveDepositCompound.add_liquidity(uamounts, minLiqAddedAmount);\r\n        }\r\n\r\n        uint256 lpAmountAfter = lp.balanceOf(address(this));\r\n        uint256 token0AmountAfter = token0.balanceOf(address(this));\r\n        uint256 token1AmountAfter = token1.balanceOf(address(this));\r\n\r\n        lpAmount = (lpAmountAfter - lpAmountBefore);\r\n\r\n        // Return leftover token to msg.sender\r\n        if (shouldTransferFromSender && (token0AmountAfter - token0AmountBefore) > 0) {\r\n            token0.safeTransfer(msg.sender, (token0AmountAfter - token0AmountBefore));\r\n        }\r\n        if (shouldTransferFromSender && (token1AmountAfter - token1AmountBefore) > 0) {\r\n            token1.safeTransfer(msg.sender, (token1AmountAfter - token1AmountBefore));\r\n        }\r\n    }\r\n\r\n    /// @dev Be aware that staking entry is Convex Booster contract while withdraw/getReward entry is BaseRewardPool contract.\r\n    /// This is because staking token for BaseRewardPool is the deposit token that can only minted by Booster.\r\n    /// Booster.deposit() will do some processing and stake into BaseRewardPool for us.\r\n    function _stake(address staker, uint256 lpAmount) internal {\r\n        lp.safeApprove(address(convexBooster), lpAmount);\r\n        convexBooster.deposit(\r\n            pid,\r\n            lpAmount,\r\n            true // True indicate to also stake into BaseRewardPool\r\n        );\r\n        _totalSupply = _totalSupply + lpAmount;\r\n        _balances[staker] = _balances[staker] + lpAmount;\r\n        emit Staked(staker, lpAmount);\r\n    }\r\n\r\n    /// @notice Taken token0 or token1 in, provide liquidity in Curve and stake\r\n    /// the LP token into Convex contract. Leftover token0 or token1 will be returned to msg.sender.\r\n    /// @param isToken0 Determine if token0 is the token msg.sender going to use for staking, token1 otherwise\r\n    /// @param amount Amount of token0 or token1 to stake\r\n    /// @param minLiqAddedAmount The minimum amount of LP token received when adding liquidity\r\n    function stake(\r\n        bool isToken0,\r\n        uint256 amount,\r\n        uint256 minLiqAddedAmount\r\n    ) public nonReentrant notPaused updateReward(msg.sender) {\r\n        uint256 lpAmount = _convertAndAddLiquidity(isToken0, true, amount, minLiqAddedAmount);\r\n        _stake(msg.sender, lpAmount);\r\n    }\r\n\r\n    /// @notice Take LP tokens and stake into Convex contract.\r\n    /// @param lpAmount Amount of LP tokens to stake\r\n    function stakeWithLP(uint256 lpAmount) public nonReentrant notPaused updateReward(msg.sender) {\r\n        lp.safeTransferFrom(msg.sender, address(this), lpAmount);\r\n        _stake(msg.sender, lpAmount);\r\n    }\r\n\r\n    function _removeLP(IERC20 token, bool toToken0, uint256 amount, uint256 minAmountReceived) internal returns (uint256) {\r\n        uint256 balBefore = token.balanceOf(address(this));\r\n\r\n        lp.safeApprove(address(curveDepositCompound), amount);\r\n        curveDepositCompound.remove_liquidity_one_coin(\r\n            amount,\r\n            toToken0 ? int128(0) : int128(1),\r\n            minAmountReceived,\r\n            true // Donate dust\r\n        );\r\n        uint256 balAfter = token.balanceOf(address(this));\r\n        return balAfter - balBefore;\r\n    }\r\n\r\n    /// @notice Withdraw stake from BaseRewardPool, remove liquidity and convert one asset to another.\r\n    /// @param toToken0 Determine to convert all to token0 or token 1\r\n    /// @param minAmountReceived The minimum amount of token0 or token1 received when removing liquidity\r\n    /// @param amount Amount of stake to withdraw\r\n    function withdraw(\r\n        bool toToken0,\r\n        uint256 minAmountReceived,\r\n        uint256 amount\r\n    ) public nonReentrant updateReward(msg.sender) {\r\n        require(amount > 0, \"Cannot withdraw 0\");\r\n\r\n        // Update records:\r\n        // substract withdrawing LP amount from total LP amount staked\r\n        _totalSupply = (_totalSupply - amount);\r\n        // substract withdrawing LP amount from user's balance\r\n        _balances[msg.sender] = (_balances[msg.sender] - amount);\r\n\r\n        // Withdraw and unwrap to LP token\r\n        convexBaseRewardPool.withdrawAndUnwrap(\r\n            amount,\r\n            false // No need to getReward when withdraw\r\n        );\r\n\r\n        IERC20 token = toToken0 ? token0 : token1;\r\n        uint256 receivedTokenAmount = _removeLP(token, toToken0, amount, minAmountReceived);\r\n        token.safeTransfer(msg.sender, receivedTokenAmount);\r\n\r\n        emit Withdrawn(msg.sender, amount);\r\n    }\r\n\r\n    /// @notice Withdraw LP tokens from BaseRewardPool contract and return to user.\r\n    /// @param lpAmount Amount of LP tokens to withdraw\r\n    function withdrawWithLP(uint256 lpAmount) public nonReentrant notPaused updateReward(msg.sender) {\r\n        require(lpAmount > 0, \"Cannot withdraw 0\");\r\n\r\n        // Update records:\r\n        // substract withdrawing LP amount from total LP amount staked\r\n        _totalSupply = (_totalSupply - lpAmount);\r\n        // substract withdrawing LP amount from user's balance\r\n        _balances[msg.sender] = (_balances[msg.sender] - lpAmount);\r\n\r\n        // Withdraw and unwrap to LP token\r\n        convexBaseRewardPool.withdrawAndUnwrap(\r\n            lpAmount,\r\n            false // No need to getReward when withdraw\r\n        );\r\n        lp.safeTransfer(msg.sender, lpAmount);\r\n\r\n        emit Withdrawn(msg.sender, lpAmount);\r\n    }\r\n\r\n    /// @notice Transfer BCNT reward to user.\r\n    function getReward() public updateReward(msg.sender)  {        \r\n        uint256 reward = _rewards[msg.sender];\r\n        uint256 totalReward = _rewards[address(this)];\r\n        if (reward > 0) {\r\n            // userbcntRewardAmount: based on user's reward and totalReward,\r\n            // determine how many BCNT reward can user take away.\r\n            // NOTE: totalReward = _rewards[address(this)];\r\n            uint256 userbcntRewardAmount = bcntRewardAmount * reward / totalReward;\r\n\r\n            // Update records:\r\n            // substract user's rewards from totalReward\r\n            _rewards[msg.sender] = 0;\r\n            _rewards[address(this)] = (totalReward - reward);\r\n            // substract userbcntRewardAmount from bcntRewardAmount\r\n            bcntRewardAmount = (bcntRewardAmount - userbcntRewardAmount);\r\n\r\n            BCNT.safeTransfer(msg.sender, userbcntRewardAmount);\r\n\r\n            emit RewardPaid(msg.sender, userbcntRewardAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw all stake from BaseRewardPool, remove liquidity, get the reward out and convert one asset to another.\r\n    /// @param toToken0 Determine to convert all to token0 or token 1\r\n    /// @param minAmountReceived The minimum amount of token0 or token1 received when removing liquidity\r\n    function exit(bool toToken0, uint256 minAmountReceived) external {\r\n        withdraw(toToken0, minAmountReceived, _balances[msg.sender]);\r\n        getReward();\r\n    }\r\n\r\n    /// @notice Withdraw all stake from BaseRewardPool, get the reward out and convert one asset to another.\r\n    function exitWithLP() external {\r\n        withdrawWithLP(_balances[msg.sender]);\r\n        getReward();\r\n    }\r\n\r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    /// @notice Get all reward out from BaseRewardPool contract, convert rewards to BCNT.\r\n    /// @param minCrvToBCNTSwap The minimum amount of BCNT received when swapping CRV to BCNT\r\n    /// @param minCvxToBCNTSwap The minimum amount of BCNT received when swapping CVX to BCNT\r\n    function accrueBCNT(\r\n        uint256 minCrvToBCNTSwap,\r\n        uint256 minCvxToBCNTSwap\r\n    ) external nonReentrant updateReward(address(0)) onlyOperator {\r\n        // getReward will get us CRV and CVX\r\n        convexBaseRewardPool.getReward(address(this), true);\r\n\r\n        BalanceDiff memory bcntAmountDiff;\r\n        bcntAmountDiff.balBefore = BCNT.balanceOf(address(this));\r\n\r\n        // Try convert CRV to BCNT\r\n        uint256 crvBalance = crv.balanceOf(address(this));\r\n        if (crvBalance > 0) {\r\n            crv.approve(address(converter), crvBalance);\r\n            // try converter.convert(address(crv), crvBalance, 100, address(token0), minCrvToBCNTSwap, address(this)) {\r\n            try converter.convertUniV3(address(crv), crvBalance, 100, address(BCNT), minCrvToBCNTSwap, address(this), crvToBCNTUniV3SwapPath) {\r\n\r\n            } catch Error(string memory reason) {\r\n                emit ConvertFailed(address(crv), address(BCNT), crvBalance, reason, bytes(\"\"));\r\n            } catch (bytes memory lowLevelData) {\r\n                emit ConvertFailed(address(crv), address(BCNT), crvBalance, \"\", lowLevelData);\r\n            }\r\n        }\r\n        // Try convert CVX to BCNT\r\n        uint256 cvxBalance = cvx.balanceOf(address(this));\r\n        if (cvxBalance > 0) {\r\n            cvx.approve(address(converter), cvxBalance);\r\n            try converter.convertUniV3(address(cvx), cvxBalance, 100, address(BCNT), minCvxToBCNTSwap, address(this), cvxToBCNTUniV3SwapPath) {\r\n\r\n            } catch Error(string memory reason) {\r\n                emit ConvertFailed(address(cvx), address(BCNT), cvxBalance, reason, bytes(\"\"));\r\n            } catch (bytes memory lowLevelData) {\r\n                emit ConvertFailed(address(cvx), address(BCNT), cvxBalance, \"\", lowLevelData);\r\n            }\r\n        }\r\n\r\n        bcntAmountDiff.balAfter = BCNT.balanceOf(address(this));\r\n        bcntAmountDiff.balDiff = (bcntAmountDiff.balAfter - bcntAmountDiff.balBefore);\r\n        bcntRewardAmount = bcntRewardAmount + bcntAmountDiff.balDiff;\r\n\r\n        emit Compounded(bcntAmountDiff.balDiff);\r\n    }\r\n\r\n    function addBCNTReward(uint256 amount) external onlyOperator {\r\n        BCNT.safeTransferFrom(operator, address(this), amount);\r\n        bcntRewardAmount = bcntRewardAmount + amount;\r\n    }\r\n\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyOwner {\r\n        require(tokenAddress != address(lp), \"Cannot withdraw the staking token\");\r\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\r\n        emit Recovered(tokenAddress, tokenAmount);\r\n    }\r\n\r\n    function updateCVXToBCNTUniV3SwapPath(bytes calldata newPath) external onlyOperator {\r\n        cvxToBCNTUniV3SwapPath = newPath;\r\n\r\n        emit UpdateCVXToBCNTUniV3SwapPath(newPath);\r\n    }\r\n\r\n    function updateCRVToBCNTUniV3SwapPath(bytes calldata newPath) external onlyOperator {\r\n        crvToBCNTUniV3SwapPath = newPath;\r\n\r\n        emit UpdateCRVToBCNTUniV3SwapPath(newPath);\r\n    }\r\n\r\n    function updateOperator(address newOperator) external onlyOwner {\r\n        operator = newOperator;\r\n\r\n        emit UpdateOperator(newOperator);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal view override onlyOwner {}\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier updateReward(address account) {\r\n        uint256 rewardPerTokenStored = convexBaseRewardPool.rewardPerToken();\r\n        if (account != address(0)) {\r\n            _rewards[account] = _share(account);\r\n            _userRewardPerTokenPaid[account] = rewardPerTokenStored;\r\n\r\n            // Use _rewards[address(this)] to keep track of rewards earned by all accounts.\r\n            _rewards[address(this)] = _shareTotal();\r\n            _userRewardPerTokenPaid[address(this)] = rewardPerTokenStored;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator, \"Only the contract operator may perform this action\");\r\n        _;\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n\r\n    event UpdateCVXToBCNTUniV3SwapPath(bytes newPath);\r\n    event UpdateCRVToBCNTUniV3SwapPath(bytes newPath);\r\n    event UpdateOperator(address newOperator);\r\n    event Staked(address indexed user, uint256 amount);\r\n    event ConvertFailed(address fromToken, address toToken, uint256 fromAmount, string reason, bytes lowLevelData);\r\n    event Compounded(uint256 bcntAmount);\r\n    event RewardPaid(address indexed user, uint256 rewardLPAmount);\r\n    event Withdrawn(address indexed user, uint256 amount);\r\n    event Recovered(address token, uint256 amount);\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bcntAmount\",\"type\":\"uint256\"}],\"name\":\"Compounded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"reason\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lowLevelData\",\"type\":\"bytes\"}],\"name\":\"ConvertFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPaused\",\"type\":\"bool\"}],\"name\":\"PauseChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardLPAmount\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newPath\",\"type\":\"bytes\"}],\"name\":\"UpdateCRVToBCNTUniV3SwapPath\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newPath\",\"type\":\"bytes\"}],\"name\":\"UpdateCVXToBCNTUniV3SwapPath\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BCNT\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"_share\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_shareTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minCrvToBCNTSwap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCvxToBCNTSwap\",\"type\":\"uint256\"}],\"name\":\"accrueBCNT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addBCNTReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bcntRewardAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"contract IConverterUniV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexBaseRewardPool\",\"outputs\":[{\"internalType\":\"contract IConvexBaseRewardPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convexBooster\",\"outputs\":[{\"internalType\":\"contract IConvexBooster\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crv\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"crvToBCNTUniV3SwapPath\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curveDepositCompound\",\"outputs\":[{\"internalType\":\"contract IDepositCompound\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvx\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvxToBCNTUniV3SwapPath\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toToken0\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minAmountReceived\",\"type\":\"uint256\"}],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exitWithLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"contract IConverterUniV3\",\"name\":\"_converter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveDepositCompound\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_convexBooster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_convexBaseRewardPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_BCNT\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPauseTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lp\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pid\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isToken0\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLiqAddedAmount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"stakeWithLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"newPath\",\"type\":\"bytes\"}],\"name\":\"updateCRVToBCNTUniV3SwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"newPath\",\"type\":\"bytes\"}],\"name\":\"updateCVXToBCNTUniV3SwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"toToken0\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minAmountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawWithLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "StakeCurveConvex", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4a167c77bde991308540e93efba08b3499b6db2c9da555334f1b043a2de6ad4f"}]}