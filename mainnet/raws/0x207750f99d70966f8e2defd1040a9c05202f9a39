{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n///////////////////////////////////////\r\n//   ____       __  ___     __   __  //\r\n//  /_  / ___ __\\ \\/ (_)__ / /__/ /  //\r\n//   / /_/ -_) _ \\  / / -_) / _  /   //\r\n//  /___/\\__/_//_/_/_/\\__/_/\\_,_/    //\r\n//               by 0xInuarashi.eth  //\r\n///////////////////////////////////////\r\n\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\ninterface iZen {\r\n    function mintAsController(address to_, uint256 amount_) external;\r\n}\r\n\r\ninterface iZenApe {\r\n    function balanceOf(address address_) external view returns (uint256);\r\n}\r\n\r\ncontract ZenYield is Ownable {\r\n    \r\n    // Interfaces\r\n    iZen public Zen = iZen(0x0fAD2A1F9aB421C1740c0456ec62c155518824aF); \r\n    function setZen(address address_) external onlyOwner { \r\n        Zen = iZen(address_); \r\n    }\r\n\r\n    iZenApe public ZenApe = iZenApe(0x838804a3dd7c717396a68F94E736eAf76b911632);\r\n    function setZenApe(address address_) external onlyOwner {\r\n        ZenApe = iZenApe(address_);\r\n    }\r\n\r\n    // Times\r\n    uint40 public yieldStartTime = 1651327200; // Apr 30 2022 14:00:00 GMT+0000\r\n    uint40 public yieldEndTime = 1682863200; // Apr 30 2023 14:00:00 GMT+0000\r\n    function setYieldEndTime(uint40 yieldEndTime_) external onlyOwner { \r\n        yieldEndTime = yieldEndTime_; }\r\n\r\n    // Yield Info\r\n    uint256 public globalModulus = 10e14; // Round up 14 Decimals\r\n    uint256 public yieldRatePerToken = 5 ether / globalModulus; // 5 Zen per Day\r\n    struct Yield { uint40 lastUpdateTime; uint216 pendingRewards; }\r\n    mapping(address => Yield) public addressToYield;\r\n\r\n    // Events\r\n    event Claim(address to_, uint256 amount_, uint256 time_);\r\n    event CreditsDeducted(address from_, uint256 amount_);\r\n    event CreditsAdded(address to_, uint256 amount_);\r\n\r\n    // Internal Calculators\r\n    function _getSmallerValueUint40(uint40 a, uint40 b) internal pure returns (uint40) {\r\n        return a < b ? a : b;\r\n    }\r\n    function _getTimestamp() internal view returns (uint40) {\r\n        return _getSmallerValueUint40( uint40(block.timestamp), yieldEndTime );\r\n    }\r\n    function _getYieldRate(address address_) internal view returns (uint40) {\r\n        return uint40(ZenApe.balanceOf(address_) * yieldRatePerToken);\r\n    }\r\n\r\n    // Internal Accountants\r\n    function _getPendingRewards(address address_) internal view returns (uint216) {\r\n        uint256 _totalYieldRate = uint256(_getYieldRate(address_));\r\n        if (_totalYieldRate == 0) return 0;\r\n        uint256 _time = uint256(_getTimestamp());\r\n        uint256 _lastUpdate = uint256(addressToYield[address_].lastUpdateTime);\r\n\r\n        if (_lastUpdate > yieldStartTime) {\r\n            return uint216( (_totalYieldRate * (_time - _lastUpdate) / 1 days) );\r\n        } \r\n        // Has ZenApe before Zen Token\r\n        else if (_lastUpdate == 0 && _totalYieldRate > 0) {\r\n            return uint216( (_totalYieldRate * (_time - yieldStartTime) / 1 days) );\r\n        } else { return 0; }\r\n    }\r\n    function _updateReward(address address_) internal {\r\n        uint40 _lastUpdate = addressToYield[address_].lastUpdateTime;\r\n\r\n        if (_lastUpdate > 0) {\r\n            addressToYield[address_].pendingRewards += _getPendingRewards(address_);\r\n        }\r\n        // Has ZenApe before Zen Token\r\n        else if (_lastUpdate == 0 && ZenApe.balanceOf(address_) != 0) {\r\n            addressToYield[address_].pendingRewards += _getPendingRewards(address_);\r\n        }\r\n        \r\n        if (_lastUpdate != yieldEndTime) {\r\n            addressToYield[address_].lastUpdateTime = _getTimestamp();\r\n        }\r\n    }\r\n    function _claimReward(address address_) internal {\r\n        // This does not update before claim. So, in internal flows, update first.\r\n        uint216 _pendingRewards = addressToYield[address_].pendingRewards;\r\n        \r\n        if (_pendingRewards > 0) {\r\n            uint256 _expandedReward = uint256(_pendingRewards * globalModulus);\r\n\r\n            addressToYield[address_].pendingRewards = 0;\r\n\r\n            Zen.mintAsController(address_, _expandedReward);\r\n        }\r\n    }\r\n\r\n    // ZenApe Functions\r\n    function updateReward(address from_, address to_, uint256 tokenId_) public {\r\n        require(msg.sender == address(ZenApe), \r\n            \"You are not ZenApe!\");\r\n        \r\n        _updateReward(from_);\r\n        _updateReward(to_);\r\n    }\r\n    \r\n    // Public Functions\r\n    function updateRewardFor(address address_) public {\r\n        _updateReward(address_);\r\n    }\r\n    function claimReward(address address_) public {\r\n        _updateReward(address_);\r\n        _claimReward(address_);\r\n    }\r\n\r\n    // View Functions\r\n    function getYieldRateOfAddress(address address_) public view returns (uint256) {\r\n        return uint256( uint256(_getYieldRate(address_)) * globalModulus);\r\n    }\r\n    function getStorageClaimableTokens(address address_) public view returns (uint256) {\r\n        return uint256( uint256(\r\n            addressToYield[address_].pendingRewards) * globalModulus);\r\n    }\r\n    function getPendingClaimableTokens(address address_) public view returns (uint256) {\r\n        return uint256( uint256(_getPendingRewards(address_)) * globalModulus );\r\n    }\r\n    function getTotalClaimableTokens(address address_) public view returns (uint256) {\r\n        return getStorageClaimableTokens(address_) \r\n            + getPendingClaimableTokens(address_);\r\n    }\r\n    function raw_getStorageClaimableTokens(address address_) public view \r\n    returns (uint256) {\r\n        return uint256(addressToYield[address_].pendingRewards);\r\n    }\r\n    function raw_getPendingClaimableTokens(address address_) public view\r\n    returns (uint256) {\r\n        return uint256(_getPendingRewards(address_));\r\n    }\r\n    function raw_getTotalClaimableTokens(address address_) public view\r\n    returns (uint256) {\r\n        return raw_getStorageClaimableTokens(address_) \r\n            + raw_getPendingClaimableTokens(address_);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time_\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"CreditsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"CreditsDeducted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Zen\",\"outputs\":[{\"internalType\":\"contract iZen\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ZenApe\",\"outputs\":[{\"internalType\":\"contract iZenApe\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToYield\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"lastUpdateTime\",\"type\":\"uint40\"},{\"internalType\":\"uint216\",\"name\":\"pendingRewards\",\"type\":\"uint216\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getPendingClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getStorageClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getTotalClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getYieldRateOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalModulus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"raw_getPendingClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"raw_getStorageClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"raw_getTotalClaimableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint40\",\"name\":\"yieldEndTime_\",\"type\":\"uint40\"}],\"name\":\"setYieldEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setZen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setZenApe\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"updateReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"updateRewardFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldEndTime\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldRatePerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldStartTime\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ZenYield", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://53e70de7be0118eb7414b0ce8d1fc177e57fd3af916054fd2f0b240ecd623731"}]}