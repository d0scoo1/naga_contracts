{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.4;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\n\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\ninterface ICodex {\n    function init(address vault) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address,\n        bytes32,\n        uint256\n    ) external;\n\n    function credit(address) external view returns (uint256);\n\n    function unbackedDebt(address) external view returns (uint256);\n\n    function balances(\n        address,\n        uint256,\n        address\n    ) external view returns (uint256);\n\n    function vaults(address vault)\n        external\n        view\n        returns (\n            uint256 totalNormalDebt,\n            uint256 rate,\n            uint256 debtCeiling,\n            uint256 debtFloor\n        );\n\n    function positions(\n        address vault,\n        uint256 tokenId,\n        address position\n    ) external view returns (uint256 collateral, uint256 normalDebt);\n\n    function globalDebt() external view returns (uint256);\n\n    function globalUnbackedDebt() external view returns (uint256);\n\n    function globalDebtCeiling() external view returns (uint256);\n\n    function delegates(address, address) external view returns (uint256);\n\n    function grantDelegate(address) external;\n\n    function revokeDelegate(address) external;\n\n    function modifyBalance(\n        address,\n        uint256,\n        address,\n        int256\n    ) external;\n\n    function transferBalance(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function transferCredit(\n        address src,\n        address dst,\n        uint256 amount\n    ) external;\n\n    function modifyCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function transferCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address src,\n        address dst,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function confiscateCollateralAndDebt(\n        address vault,\n        uint256 tokenId,\n        address user,\n        address collateralizer,\n        address debtor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) external;\n\n    function settleUnbackedDebt(uint256 debt) external;\n\n    function createUnbackedDebt(\n        address debtor,\n        address creditor,\n        uint256 debt\n    ) external;\n\n    function modifyRate(\n        address vault,\n        address creditor,\n        int256 rate\n    ) external;\n\n    function lock() external;\n}// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\n\n\n\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\ninterface IFIATExcl {\n    function mint(address to, uint256 amount) external;\n\n    function burn(address from, uint256 amount) external;\n}\n\ninterface IFIAT is IFIATExcl, IERC20, IERC20Permit, IERC20Metadata {}\n\ninterface IMoneta {\n    function codex() external view returns (ICodex);\n\n    function fiat() external view returns (IFIAT);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function enter(address user, uint256 amount) external;\n\n    function exit(address user, uint256 amount) external;\n}// Copyright (C) 2020 Maker Ecosystem Growth Holdings, INC.\n\nuint256 constant MLN = 10**6;\nuint256 constant BLN = 10**9;\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**18;\nuint256 constant RAD = 10**18;\n\n/* solhint-disable func-visibility, no-inline-assembly */\n\nerror Math__toInt256_overflow(uint256 x);\n\nfunction toInt256(uint256 x) pure returns (int256) {\n    if (x > uint256(type(int256).max)) revert Math__toInt256_overflow(x);\n    return int256(x);\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x <= y ? x : y;\n    }\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x >= y ? x : y;\n    }\n}\n\nerror Math__diff_overflow(uint256 x, uint256 y);\n\nfunction diff(uint256 x, uint256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) - int256(y);\n        if (!(int256(x) >= 0 && int256(y) >= 0)) revert Math__diff_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow(uint256 x, uint256 y);\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add_overflow(x, y);\n    }\n}\n\nerror Math__add48_overflow(uint256 x, uint256 y);\n\nfunction add48(uint48 x, uint48 y) pure returns (uint48 z) {\n    unchecked {\n        if ((z = x + y) < x) revert Math__add48_overflow(x, y);\n    }\n}\n\nerror Math__add_overflow_signed(uint256 x, int256 y);\n\nfunction add(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x + uint256(y);\n        if (!(y >= 0 || z <= x)) revert Math__add_overflow_signed(x, y);\n        if (!(y <= 0 || z >= x)) revert Math__add_overflow_signed(x, y);\n    }\n}\n\nerror Math__sub_overflow(uint256 x, uint256 y);\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if ((z = x - y) > x) revert Math__sub_overflow(x, y);\n    }\n}\n\nerror Math__sub_overflow_signed(uint256 x, int256 y);\n\nfunction sub(uint256 x, int256 y) pure returns (uint256 z) {\n    unchecked {\n        z = x - uint256(y);\n        if (!(y <= 0 || z <= x)) revert Math__sub_overflow_signed(x, y);\n        if (!(y >= 0 || z >= x)) revert Math__sub_overflow_signed(x, y);\n    }\n}\n\nerror Math__mul_overflow(uint256 x, uint256 y);\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (!(y == 0 || (z = x * y) / y == x)) revert Math__mul_overflow(x, y);\n    }\n}\n\nerror Math__mul_overflow_signed(uint256 x, int256 y);\n\nfunction mul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = int256(x) * y;\n        if (int256(x) < 0) revert Math__mul_overflow_signed(x, y);\n        if (!(y == 0 || z / y == int256(x))) revert Math__mul_overflow_signed(x, y);\n    }\n}\n\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, y) / WAD;\n    }\n}\n\nfunction wmul(uint256 x, int256 y) pure returns (int256 z) {\n    unchecked {\n        z = mul(x, y) / int256(WAD);\n    }\n}\n\nerror Math__div_overflow(uint256 x, uint256 y);\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        if (y == 0) revert Math__div_overflow(x, y);\n        return x / y;\n    }\n}\n\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    unchecked {\n        z = mul(x, WAD) / y;\n    }\n}\n\n// optimized version from dss PR #78\nfunction wpow(\n    uint256 x,\n    uint256 n,\n    uint256 b\n) pure returns (uint256 z) {\n    unchecked {\n        assembly {\n            switch n\n            case 0 {\n                z := b\n            }\n            default {\n                switch x\n                case 0 {\n                    z := 0\n                }\n                default {\n                    switch mod(n, 2)\n                    case 0 {\n                        z := b\n                    }\n                    default {\n                        z := x\n                    }\n                    let half := div(b, 2) // for rounding.\n                    for {\n                        n := div(n, 2)\n                    } n {\n                        n := div(n, 2)\n                    } {\n                        let xx := mul(x, x)\n                        if shr(128, x) {\n                            revert(0, 0)\n                        }\n                        let xxRound := add(xx, half)\n                        if lt(xxRound, xx) {\n                            revert(0, 0)\n                        }\n                        x := div(xxRound, b)\n                        if mod(n, 2) {\n                            let zx := mul(z, x)\n                            if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) {\n                                revert(0, 0)\n                            }\n                            let zxRound := add(zx, half)\n                            if lt(zxRound, zx) {\n                                revert(0, 0)\n                            }\n                            z := div(zxRound, b)\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n/* solhint-disable func-visibility, no-inline-assembly */\ninterface IPriceFeed {\n    function peek() external returns (bytes32, bool);\n\n    function read() external view returns (bytes32);\n}\n\ninterface ICollybus {\n    function vaults(address) external view returns (uint128, uint128);\n\n    function spots(address) external view returns (uint256);\n\n    function rates(uint256) external view returns (uint256);\n\n    function rateIds(address, uint256) external view returns (uint256);\n\n    function redemptionPrice() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint128 data\n    ) external;\n\n    function setParam(\n        address vault,\n        uint256 tokenId,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function updateDiscountRate(uint256 rateId, uint256 rate) external;\n\n    function updateSpot(address token, uint256 spot) external;\n\n    function read(\n        address vault,\n        address underlier,\n        uint256 tokenId,\n        uint256 maturity,\n        bool net\n    ) external view returns (uint256 price);\n\n    function lock() external;\n}\n\ninterface IVault {\n    function codex() external view returns (ICodex);\n\n    function collybus() external view returns (ICollybus);\n\n    function token() external view returns (address);\n\n    function tokenScale() external view returns (uint256);\n\n    function underlierToken() external view returns (address);\n\n    function underlierScale() external view returns (uint256);\n\n    function vaultType() external view returns (bytes32);\n\n    function live() external view returns (uint256);\n\n    function lock() external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function maturity(uint256 tokenId) external returns (uint256);\n\n    function fairPrice(\n        uint256 tokenId,\n        bool net,\n        bool face\n    ) external view returns (uint256);\n\n    function enter(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n\n    function exit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external;\n}\n\ninterface IVaultFC is IVault {\n\n    function currencyId() external view returns (uint256);\n\n    function tenor() external view returns (uint256);\n\n    function redeemAndExit(\n        uint256 tokenId,\n        address user,\n        uint256 amount\n    ) external returns (uint256 redeemed);\n\n    function redeems(\n        uint256 tokenId,\n        uint256 amount,\n        uint256 cTokenExRate\n    ) external view returns (uint256);\n}\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/utils/ERC1155Holder.sol)\n\n\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\n\n\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\n\n\n\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\n\n\n\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev _Available since v3.1._\n */\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n}\n\n/**\n * Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.\n *\n * IMPORTANT: When inheriting this contract, you must include a way to use the received tokens, otherwise they will be\n * stuck.\n *\n * @dev _Available since v3.1._\n */\ncontract ERC1155Holder is ERC1155Receiver {\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\ninterface IDebtAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function tokenToSellBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function aer() external view returns (address);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(\n        address recipient,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 tokensToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock() external;\n\n    function cancelAuction(uint256 id) external;\n}\ninterface ISurplusAuction {\n    function auctions(uint256)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            address,\n            uint48,\n            uint48\n        );\n\n    function codex() external view returns (ICodex);\n\n    function token() external view returns (IERC20);\n\n    function minBidBump() external view returns (uint256);\n\n    function bidDuration() external view returns (uint48);\n\n    function auctionDuration() external view returns (uint48);\n\n    function auctionCounter() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function startAuction(uint256 creditToSell, uint256 bid) external returns (uint256 id);\n\n    function redoAuction(uint256 id) external;\n\n    function submitBid(\n        uint256 id,\n        uint256 creditToSell,\n        uint256 bid\n    ) external;\n\n    function closeAuction(uint256 id) external;\n\n    function lock(uint256 credit) external;\n\n    function cancelAuction(uint256 id) external;\n}\n\ninterface IAer {\n    function codex() external view returns (ICodex);\n\n    function surplusAuction() external view returns (ISurplusAuction);\n\n    function debtAuction() external view returns (IDebtAuction);\n\n    function debtQueue(uint256) external view returns (uint256);\n\n    function queuedDebt() external view returns (uint256);\n\n    function debtOnAuction() external view returns (uint256);\n\n    function auctionDelay() external view returns (uint256);\n\n    function debtAuctionSellSize() external view returns (uint256);\n\n    function debtAuctionBidSize() external view returns (uint256);\n\n    function surplusAuctionSellSize() external view returns (uint256);\n\n    function surplusBuffer() external view returns (uint256);\n\n    function live() external view returns (uint256);\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function queueDebt(uint256 debt) external;\n\n    function unqueueDebt(uint256 queuedAt) external;\n\n    function settleDebtWithSurplus(uint256 debt) external;\n\n    function settleAuctionedDebt(uint256 debt) external;\n\n    function startDebtAuction() external returns (uint256 auctionId);\n\n    function startSurplusAuction() external returns (uint256 auctionId);\n\n    function transferCredit(address to, uint256 credit) external;\n\n    function lock() external;\n}\n\ninterface IPublican {\n    function vaults(address vault) external view returns (uint256, uint256);\n\n    function codex() external view returns (ICodex);\n\n    function aer() external view returns (IAer);\n\n    function baseInterest() external view returns (uint256);\n\n    function init(address vault) external;\n\n    function setParam(\n        address vault,\n        bytes32 param,\n        uint256 data\n    ) external;\n\n    function setParam(bytes32 param, uint256 data) external;\n\n    function setParam(bytes32 param, address data) external;\n\n    function virtualRate(address vault) external returns (uint256 rate);\n\n    function collect(address vault) external returns (uint256 rate);\n}\n/// @title VaultActions\n/// @notice A set of base vault actions to inherited from\nabstract contract VaultActions {\n    /// ======== Custom Errors ======== ///\n\n    error VaultActions__exitMoneta_zeroUserAddress();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Codex\n    ICodex public immutable codex;\n    /// @notice Moneta\n    IMoneta public immutable moneta;\n    /// @notice FIAT token\n    IFIAT public immutable fiat;\n    /// @notice Publican\n    IPublican public immutable publican;\n\n    constructor(\n        address codex_,\n        address moneta_,\n        address fiat_,\n        address publican_\n    ) {\n        codex = ICodex(codex_);\n        moneta = IMoneta(moneta_);\n        fiat = IFIAT(fiat_);\n        publican = IPublican(publican_);\n    }\n\n    /// @notice Sets `amount` as the allowance of `spender` over the UserProxy's FIAT\n    /// @param spender Address of the spender\n    /// @param amount Amount of tokens to approve [wad]\n    function approveFIAT(address spender, uint256 amount) external {\n        fiat.approve(spender, amount);\n    }\n\n    /// @dev Redeems FIAT for internal credit\n    /// @param to Address of the recipient\n    /// @param amount Amount of FIAT to exit [wad]\n    function exitMoneta(address to, uint256 amount) public {\n        if (to == address(0)) revert VaultActions__exitMoneta_zeroUserAddress();\n\n        // proxy needs to delegate ability to transfer internal credit on its behalf to Moneta first\n        if (codex.delegates(address(this), address(moneta)) != 1) codex.grantDelegate(address(moneta));\n\n        moneta.exit(to, amount);\n    }\n\n    /// @dev The user needs to previously call approveFIAT with the address of Moneta as the spender\n    /// @param from Address of the account which provides FIAT\n    /// @param amount Amount of FIAT to enter [wad]\n    function enterMoneta(address from, uint256 amount) public {\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) fiat.transferFrom(from, address(this), amount);\n\n        moneta.enter(address(this), amount);\n    }\n\n    /// @notice Deposits `amount` of `token` with `tokenId` from `from` into the `vault`\n    /// @dev Virtual method to be implement in token specific UserAction contracts\n    function enterVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address from,\n        uint256 amount\n    ) public virtual;\n\n    /// @notice Withdraws `amount` of `token` with `tokenId` to `to` from the `vault`\n    /// @dev Virtual method to be implement in token specific UserAction contracts\n    function exitVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) public virtual;\n\n    /// @notice method for adjusting collateral and debt balances of a position.\n    /// 1. updates the interest rate accumulator for the given vault\n    /// 2. enters FIAT into Moneta if deltaNormalDebt is negative (applies rate to deltaNormalDebt)\n    /// 3. enters Collateral into Vault if deltaCollateral is positive\n    /// 3. modifies collateral and debt balances in Codex\n    /// 4. exits FIAT from Moneta if deltaNormalDebt is positive (applies rate to deltaNormalDebt)\n    /// 5. exits Collateral from Vault if deltaCollateral is negative\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the vault's collateral token\n    /// @param tokenId ERC1155 or ERC721 style TokenId (leave at 0 for ERC20)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param deltaCollateral Amount of collateral to put up (+) for or remove (-) from this Position [wad]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) for this Position [wad]\n    function modifyCollateralAndDebt(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address position,\n        address collateralizer,\n        address creditor,\n        int256 deltaCollateral,\n        int256 deltaNormalDebt\n    ) public {\n        // update the interest rate accumulator in Codex for the vault\n        if (deltaNormalDebt != 0) publican.collect(vault);\n\n        if (deltaNormalDebt < 0) {\n            // add due interest from normal debt\n            (, uint256 rate, , ) = codex.vaults(vault);\n            enterMoneta(creditor, uint256(-wmul(rate, deltaNormalDebt)));\n        }\n\n        // transfer tokens to be used as collateral into Vault\n        if (deltaCollateral > 0) {\n            enterVault(\n                vault,\n                token,\n                tokenId,\n                collateralizer,\n                wmul(uint256(deltaCollateral), IVault(vault).tokenScale())\n            );\n        }\n\n        // update collateral and debt balanaces\n        codex.modifyCollateralAndDebt(\n            vault,\n            tokenId,\n            position,\n            address(this),\n            address(this),\n            deltaCollateral,\n            deltaNormalDebt\n        );\n\n        // redeem newly generated internal credit for FIAT\n        if (deltaNormalDebt > 0) {\n            // forward all generated credit by applying rate\n            (, uint256 rate, , ) = codex.vaults(vault);\n            exitMoneta(creditor, wmul(uint256(deltaNormalDebt), rate));\n        }\n\n        // withdraw tokens not be used as collateral anymore from Vault\n        if (deltaCollateral < 0) {\n            exitVault(\n                vault,\n                token,\n                tokenId,\n                collateralizer,\n                wmul(uint256(-deltaCollateral), IVault(vault).tokenScale())\n            );\n        }\n    }\n}\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a PRBProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @title Vault1155Actions\n/// @notice A set of vault actions for modifying positions collateralized by ERC1155 tokens\ncontract Vault1155Actions is VaultActions {\n    /// ======== Custom Errors ======== ///\n\n    error Vault1155Actions__enterVault_zeroVaultAddress();\n    error Vault1155Actions__enterVault_zeroTokenAddress();\n    error Vault1155Actions__exitVault_zeroVaultAddress();\n    error Vault1155Actions__exitVault_zeroToAddress();\n    error Vault1155Actions__exitVault_zeroTokenAddress();\n\n    constructor(\n        address codex_,\n        address moneta_,\n        address fiat_,\n        address publican_\n    ) VaultActions(codex_, moneta_, fiat_, publican_) {}\n\n    /// @notice Deposits amount of `token` with `tokenId` from `from` into the `vault`\n    /// @dev Implements virtual method defined in VaultActions for ERC1155 tokens\n    /// @param vault Address of the Vault to enter\n    /// @param token Address of the collateral token\n    /// @param tokenId ERC1155 TokenId\n    /// @param from Address from which to take the deposit from\n    /// @param amount Amount of collateral tokens to deposit [tokenScale]\n    function enterVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address from,\n        uint256 amount\n    ) public virtual override {\n        if (vault == address(0)) revert Vault1155Actions__enterVault_zeroVaultAddress();\n        if (token == address(0)) revert Vault1155Actions__enterVault_zeroTokenAddress();\n\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) {\n            IERC1155(token).safeTransferFrom(from, address(this), tokenId, amount, new bytes(0));\n        }\n\n        IERC1155(token).setApprovalForAll(address(vault), true);\n        IVault(vault).enter(tokenId, address(this), amount);\n    }\n\n    /// @notice Withdraws amount of `token` with `tokenId` to `to` from the `vault`\n    /// @dev Implements virtual method defined in VaultActions for ERC1155 tokens\n    /// @param vault Address of the Vault to exit\n    /// @param token Address of the collateral token\n    /// @param tokenId ERC1155 TokenId\n    /// @param to Address which receives the withdrawn collateral tokens\n    /// @param amount Amount of collateral tokens to exit [tokenScale]\n    function exitVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) public virtual override {\n        if (vault == address(0)) revert Vault1155Actions__exitVault_zeroVaultAddress();\n        if (token == address(0)) revert Vault1155Actions__exitVault_zeroTokenAddress();\n        if (to == address(0)) revert Vault1155Actions__exitVault_zeroToAddress();\n\n        IVault(vault).exit(tokenId, to, amount);\n    }\n}\ninterface INotional {\n    enum DepositActionType {\n        None,\n        DepositAsset,\n        DepositUnderlying,\n        DepositAssetAndMintNToken,\n        DepositUnderlyingAndMintNToken,\n        RedeemNToken,\n        ConvertCashToNToken\n    }\n\n    struct MarketParameters {\n        bytes32 storageSlot;\n        uint256 maturity;\n        int256 totalfCash;\n        int256 totalAssetCash;\n        int256 totalLiquidity;\n        uint256 lastImpliedRate;\n        uint256 oracleRate;\n        uint256 previousTradeTime;\n    }\n\n    enum TokenType {\n        UnderlyingToken,\n        cToken,\n        cETH,\n        Ether,\n        NonMintable\n    }\n\n    struct Token {\n        address tokenAddress;\n        bool hasTransferFee;\n        int256 decimals;\n        TokenType tokenType;\n        uint256 maxCollateralBalance;\n    }\n\n    struct BalanceActionWithTrades {\n        DepositActionType actionType;\n        uint16 currencyId;\n        uint256 depositActionAmount;\n        uint256 withdrawAmountInternalPrecision;\n        bool withdrawEntireCashBalance;\n        bool redeemToUnderlying;\n        bytes32[] trades;\n    }\n\n    struct AssetRateParameters {\n        address rateOracle;\n        int256 rate;\n        int256 underlyingDecimals;\n    }\n\n    function getActiveMarkets(uint16 currencyId) external view returns (MarketParameters[] memory);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function batchBalanceAndTradeAction(address account, BalanceActionWithTrades[] calldata actions) external payable;\n\n    function getSettlementRate(uint16 currencyId, uint40 maturity) external view returns (AssetRateParameters memory);\n\n    function settleAccount(address account) external;\n\n    function withdraw(\n        uint16 currencyId,\n        uint88 amountInternalPrecision,\n        bool redeemToUnderlying\n    ) external returns (uint256);\n\n    function getfCashAmountGivenCashAmount(\n        uint16 currencyId,\n        int88 netCashToAccount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view returns (int256);\n\n    function getCashAmountGivenfCashAmount(\n        uint16 currencyId,\n        int88 fCashAmount,\n        uint256 marketIndex,\n        uint256 blockTime\n    ) external view returns (int256, int256);\n\n    function getCurrency(uint16 currencyId)\n        external\n        view\n        returns (Token memory assetToken, Token memory underlyingToken);\n}\n\n/// @title Constants\n/// @notice Copied from https://github.com/notional-finance/contracts-v2/blob/master/contracts/global/Constants.sol\n/// Replaced OZ safe math with Math.sol\nlibrary Constants {\n    int256 internal constant INTERNAL_TOKEN_PRECISION = 1e8;\n\n    uint256 internal constant MAX_TRADED_MARKET_INDEX = 7;\n\n    uint256 internal constant DAY = 86400;\n    uint256 internal constant WEEK = DAY * 6;\n    uint256 internal constant MONTH = WEEK * 5;\n    uint256 internal constant QUARTER = MONTH * 3;\n    uint256 internal constant YEAR = QUARTER * 4;\n\n    uint256 internal constant DAYS_IN_WEEK = 6;\n    uint256 internal constant DAYS_IN_MONTH = 30;\n    uint256 internal constant DAYS_IN_QUARTER = 90;\n\n    uint8 internal constant FCASH_ASSET_TYPE = 1;\n    uint8 internal constant MAX_LIQUIDITY_TOKEN_INDEX = 8;\n\n    bytes2 internal constant UNMASK_FLAGS = 0x3FFF;\n    uint16 internal constant MAX_CURRENCIES = uint16(UNMASK_FLAGS);\n}\n\n/// @title DatetTime\n/// @notice Copied from\n/// https://github.com/notional-finance/contracts-v2/blob/master/contracts/internal/markets/DateTime.sol\n/// Added Custom Errors\nlibrary DateTime {\n    error DateTime__getReferenceTime_invalidBlockTime();\n    error DateTime__getTradedMarket_invalidIndex();\n    error DateTime__getMarketIndex_zeroMaxMarketIndex();\n    error DateTime__getMarketIndex_invalidMaxMarketIndex();\n    error DateTime__getMarketIndex_marketNotFound();\n\n    function getReferenceTime(uint256 blockTime) internal pure returns (uint256) {\n        if (blockTime < Constants.QUARTER) revert DateTime__getReferenceTime_invalidBlockTime();\n        return blockTime - (blockTime % Constants.QUARTER);\n    }\n\n    function getTradedMarket(uint256 index) internal pure returns (uint256) {\n        if (index == 1) return Constants.QUARTER;\n        if (index == 2) return 2 * Constants.QUARTER;\n        if (index == 3) return Constants.YEAR;\n        if (index == 4) return 2 * Constants.YEAR;\n        if (index == 5) return 5 * Constants.YEAR;\n        if (index == 6) return 10 * Constants.YEAR;\n        if (index == 7) return 20 * Constants.YEAR;\n\n        revert DateTime__getTradedMarket_invalidIndex();\n    }\n\n    function getMarketIndex(\n        uint256 maxMarketIndex,\n        uint256 maturity,\n        uint256 blockTime\n    ) internal pure returns (uint256, bool) {\n        if (maxMarketIndex == 0) revert DateTime__getMarketIndex_zeroMaxMarketIndex();\n        if (maxMarketIndex > Constants.MAX_TRADED_MARKET_INDEX) revert DateTime__getMarketIndex_invalidMaxMarketIndex();\n\n        uint256 tRef = DateTime.getReferenceTime(blockTime);\n\n        for (uint256 i = 1; i <= maxMarketIndex; i++) {\n            uint256 marketMaturity = add(tRef, DateTime.getTradedMarket(i));\n            // If market matches then is not idiosyncratic\n            if (marketMaturity == maturity) return (i, false);\n            // Returns the market that is immediately greater than the maturity\n            if (marketMaturity > maturity) return (i, true);\n        }\n\n        revert DateTime__getMarketIndex_marketNotFound();\n    }\n}\n\n/// @title EncodeDecode\n/// @notice Copied from\n/// https://github.com/notional-finance/notional-solidity-sdk/blob/master/contracts/lib/EncodeDecode.sol\n/// Added Custom Errors\nlibrary EncodeDecode {\n    error EncodeDecode__encodeERC1155Id_MAX_CURRENCIES();\n    error EncodeDecode__encodeERC1155Id_invalidMaturity();\n    error EncodeDecode__encodeERC1155Id_MAX_LIQUIDITY_TOKEN_INDEX();\n\n    enum TradeActionType {\n        Lend,\n        Borrow,\n        AddLiquidity,\n        RemoveLiquidity,\n        PurchaseNTokenResidual,\n        SettleCashDebt\n    }\n\n    function decodeERC1155Id(uint256 id)\n        internal\n        pure\n        returns (\n            uint16 currencyId,\n            uint40 maturity,\n            uint8 assetType\n        )\n    {\n        assetType = uint8(id);\n        maturity = uint40(id >> 8);\n        currencyId = uint16(id >> 48);\n    }\n\n    function encodeERC1155Id(\n        uint256 currencyId,\n        uint256 maturity,\n        uint256 assetType\n    ) internal pure returns (uint256) {\n        if (currencyId > Constants.MAX_CURRENCIES) revert EncodeDecode__encodeERC1155Id_MAX_CURRENCIES();\n        if (maturity > type(uint40).max) revert EncodeDecode__encodeERC1155Id_invalidMaturity();\n        if (assetType > Constants.MAX_LIQUIDITY_TOKEN_INDEX) {\n            revert EncodeDecode__encodeERC1155Id_MAX_LIQUIDITY_TOKEN_INDEX();\n        }\n\n        return\n            uint256(\n                (bytes32(uint256(uint16(currencyId))) << 48) |\n                    (bytes32(uint256(uint40(maturity))) << 8) |\n                    bytes32(uint256(uint8(assetType)))\n            );\n    }\n\n    function encodeLendTrade(\n        uint8 marketIndex,\n        uint88 fCashAmount,\n        uint32 minImpliedRate\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                (uint256(uint8(TradeActionType.Lend)) << 248) |\n                    (uint256(marketIndex) << 240) |\n                    (uint256(fCashAmount) << 152) |\n                    (uint256(minImpliedRate) << 120)\n            );\n    }\n\n    function encodeBorrowTrade(\n        uint8 marketIndex,\n        uint88 fCashAmount,\n        uint32 maxImpliedRate\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                uint256(\n                    (uint256(uint8(TradeActionType.Borrow)) << 248) |\n                        (uint256(marketIndex) << 240) |\n                        (uint256(fCashAmount) << 152) |\n                        (uint256(maxImpliedRate) << 120)\n                )\n            );\n    }\n}\n\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n// WARNING: These functions meant to be used as a a library for a PRBProxy. Some are unsafe if you call them directly.\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\n/// @title VaultFCActions\n/// @notice A set of vault actions for modifying positions collateralized by Notional Finance fCash tokens\ncontract VaultFCActions is Vault1155Actions {\n    using SafeERC20 for IERC20;\n\n    /// ======== Custom Errors ======== ///\n\n    error VaultFCActions__buyCollateralAndModifyDebt_zeroMaxUnderlierAmount();\n    error VaultFCActions__sellCollateralAndModifyDebt_zeroFCashAmount();\n    error VaultFCActions__sellCollateralAndModifyDebt_matured();\n    error VaultFCActions__redeemCollateralAndModifyDebt_zeroFCashAmount();\n    error VaultFCActions__redeemCollateralAndModifyDebt_notMatured();\n    error VaultFCActions__getMarketIndex_invalidMarket();\n    error VaultFCActions__getUnderlierToken_invalidUnderlierTokenType();\n    error VaultFCActions__getCToken_invalidAssetTokenType();\n    error VaultFCActions__sellfCash_amountOverflow();\n    error VaultFCActions__redeemfCash_amountOverflow();\n    error VaultFCActions__vaultRedeemAndExit_zeroVaultAddress();\n    error VaultFCActions__vaultRedeemAndExit_zeroTokenAddress();\n    error VaultFCActions__vaultRedeemAndExit_zeroToAddress();\n    error VaultFCActions__onERC1155Received_invalidCaller();\n    error VaultFCActions__onERC1155Received_invalidValue();\n\n    /// ======== Storage ======== ///\n\n    /// @notice Address of the Notional V2 monolith\n    INotional public immutable notionalV2;\n    /// @notice Scale for all fCash tokens (== tokenScale)\n    uint256 public immutable fCashScale;\n\n    constructor(\n        address codex,\n        address moneta,\n        address fiat,\n        address publican_,\n        address notionalV2_\n    ) Vault1155Actions(codex, moneta, fiat, publican_) {\n        notionalV2 = INotional(notionalV2_);\n        fCashScale = uint256(Constants.INTERNAL_TOKEN_PRECISION);\n    }\n\n    /// ======== Position Management ======== ///\n\n    /// @notice Buys fCash from underliers before it modifies a Position's collateral\n    /// and debt balances and mints/burns FIAT using the underlier token.\n    /// The underlier is swapped to fCash token used as collateral.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the collateral token (fCash)\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param fCashAmount Amount of fCash to buy via underliers and add as collateral [tokenScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    /// @param minImpliedRate Min. accepted annualized implied lending rate for swapping underliers for fCash [1e9]\n    /// @param maxUnderlierAmount Max. amount of underlier to swap for fCash [underlierScale]\n    function buyCollateralAndModifyDebt(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 fCashAmount,\n        int256 deltaNormalDebt,\n        uint32 minImpliedRate,\n        uint256 maxUnderlierAmount\n    ) public {\n        if (maxUnderlierAmount == 0) revert VaultFCActions__buyCollateralAndModifyDebt_zeroMaxUnderlierAmount();\n\n        // buy fCash and transfer tokens to be used as collateral into VaultFC\n        _buyFCash(tokenId, collateralizer, maxUnderlierAmount, minImpliedRate, uint88(fCashAmount));\n        int256 deltaCollateral = toInt256(wdiv(fCashAmount, fCashScale));\n\n        // enter fCash and collateralize position\n        modifyCollateralAndDebt(\n            vault,\n            token,\n            tokenId,\n            position,\n            address(this),\n            creditor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// @notice Sells the fCash for underliers after it modifies a Position's collateral and debt balances\n    /// and mints/burns FIAT using the underlier token.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the collateral token (fCash)\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param fCashAmount Amount of fCash to remove as collateral and to swap for underliers [tokenScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    /// @param maxImpliedRate Max. accepted annualized implied borrow rate for swapping fCash for underliers [1e9]\n    function sellCollateralAndModifyDebt(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 fCashAmount,\n        int256 deltaNormalDebt,\n        uint32 maxImpliedRate\n    ) public {\n        if (fCashAmount == 0) revert VaultFCActions__sellCollateralAndModifyDebt_zeroFCashAmount();\n        if (block.timestamp >= getMaturity(tokenId)) revert VaultFCActions__sellCollateralAndModifyDebt_matured();\n\n        int256 deltaCollateral = -toInt256(wdiv(fCashAmount, fCashScale));\n\n        // withdraw fCash from the position\n        modifyCollateralAndDebt(\n            vault,\n            token,\n            tokenId,\n            position,\n            address(this),\n            creditor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n\n        // sell fCash\n        _sellfCash(tokenId, collateralizer, uint88(fCashAmount), maxImpliedRate);\n    }\n\n    /// @notice Redeems fCash for underliers after it modifies a Position's collateral and debt balances\n    /// and mints/burns FIAT using the underlier token.\n    /// @dev The user needs to previously approve the UserProxy for spending collateral tokens or FIAT tokens\n    /// If `position` is not the UserProxy, the `position` owner needs grant a delegate to UserProxy via Codex\n    /// @param vault Address of the Vault\n    /// @param token Address of the collateral token (fCash)\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param position Address of the position's owner\n    /// @param collateralizer Address of who puts up or receives the collateral delta as underlier tokens\n    /// @param creditor Address of who provides or receives the FIAT delta for the debt delta\n    /// @param fCashAmount Amount of fCash to remove as collateral and to redeem for underliers [tokenScale]\n    /// @param deltaNormalDebt Amount of normalized debt (gross, before rate is applied) to generate (+) or\n    /// settle (-) on this Position [wad]\n    function redeemCollateralAndModifyDebt(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address position,\n        address collateralizer,\n        address creditor,\n        uint256 fCashAmount,\n        int256 deltaNormalDebt\n    ) public {\n        if (fCashAmount == 0) revert VaultFCActions__redeemCollateralAndModifyDebt_zeroFCashAmount();\n        if (block.timestamp < getMaturity(tokenId)) revert VaultFCActions__redeemCollateralAndModifyDebt_notMatured();\n\n        int256 deltaCollateral = -toInt256(wdiv(fCashAmount, fCashScale));\n\n        // withdraw fCash from the position and redeem them for underliers\n        modifyCollateralAndDebt(\n            vault,\n            token,\n            tokenId,\n            position,\n            collateralizer,\n            creditor,\n            deltaCollateral,\n            deltaNormalDebt\n        );\n    }\n\n    /// @notice Buys fCash tokens (shares) from the Notional AMM\n    /// @dev The amount of underlier set as argument is the upper limit to be paid\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param from Address who pays for the fCash\n    /// @param maxUnderlierAmount Max. amount of underlier to swap for fCash [underlierScale]\n    /// @param minImpliedRate Min. accepted annualized implied lending rate for lending out underliers for fCash [1e9]\n    /// @param fCashAmount Amount of fCash to buy via underliers [tokenScale]\n    function _buyFCash(\n        uint256 tokenId,\n        address from,\n        uint256 maxUnderlierAmount,\n        uint32 minImpliedRate,\n        uint88 fCashAmount\n    ) internal {\n        (IERC20 underlier, ) = getUnderlierToken(tokenId);\n\n        uint256 balanceBefore = 0;\n        // if `from` is set to an external address then transfer amount to the proxy first\n        // requires `from` to have set an allowance for the proxy\n        if (from != address(0) && from != address(this)) {\n            balanceBefore = underlier.balanceOf(address(this));\n            underlier.safeTransferFrom(from, address(this), maxUnderlierAmount);\n        }\n\n        INotional.BalanceActionWithTrades[] memory action = new INotional.BalanceActionWithTrades[](1);\n        action[0].actionType = INotional.DepositActionType.DepositUnderlying;\n        action[0].depositActionAmount = maxUnderlierAmount;\n        action[0].currencyId = getCurrencyId(tokenId);\n        action[0].withdrawEntireCashBalance = true;\n        action[0].redeemToUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = EncodeDecode.encodeLendTrade(getMarketIndex(tokenId), fCashAmount, minImpliedRate);\n\n        if (underlier.allowance(address(this), address(notionalV2)) < maxUnderlierAmount) {\n            // approve notionalV2 to transfer underlier tokens on behalf of proxy\n            underlier.approve(address(notionalV2), maxUnderlierAmount);\n        }\n\n        notionalV2.batchBalanceAndTradeAction(address(this), action);\n\n        // Send any residuals underlier back to the sender\n        if (from != address(0) && from != address(this)) {\n            uint256 balanceAfter = underlier.balanceOf(address(this));\n            uint256 residual = balanceAfter - balanceBefore;\n            if (residual > 0) underlier.safeTransfer(from, residual);\n        }\n    }\n\n    /// @dev Sells an fCash tokens (shares) back on the Notional AMM\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param fCashAmount The amount of fCash to sell [tokenScale]\n    /// @param to Receiver of the underlier tokens\n    /// @param maxImpliedRate Max. accepted annualized implied borrow rate for swapping fCash for underliers [1e9]\n    function _sellfCash(\n        uint256 tokenId,\n        address to,\n        uint88 fCashAmount,\n        uint32 maxImpliedRate\n    ) internal {\n        if (fCashAmount > type(uint88).max) revert VaultFCActions__sellfCash_amountOverflow();\n\n        (IERC20 underlier, ) = getUnderlierToken(tokenId);\n\n        INotional.BalanceActionWithTrades[] memory action = new INotional.BalanceActionWithTrades[](1);\n        action[0].actionType = INotional.DepositActionType.None;\n        action[0].currencyId = getCurrencyId(tokenId);\n        action[0].withdrawEntireCashBalance = true;\n        action[0].redeemToUnderlying = true;\n        action[0].trades = new bytes32[](1);\n        action[0].trades[0] = EncodeDecode.encodeBorrowTrade(getMarketIndex(tokenId), fCashAmount, maxImpliedRate);\n\n        uint256 balanceBefore = underlier.balanceOf(address(this));\n        notionalV2.batchBalanceAndTradeAction(address(this), action);\n        uint256 balanceAfter = underlier.balanceOf(address(this));\n\n        // Send the resulting underlier to the user\n        underlier.safeTransfer(to, balanceAfter - balanceBefore);\n    }\n\n    /// @notice Redeems fCash for underliers (if fCash has matured) and transfers them from the `vault` to `to`\n    /// @param vault Address of the Vault to exit\n    /// @param token Address of the collateral token (fCash)\n    /// @param tokenId fCash Id (ERC1155 token id)\n    /// @param to Address which receives the fCash / redeemed underlier tokens\n    /// @param amount Amount of collateral tokens to exit or redeem and exit [tokenScale]\n    function exitVault(\n        address vault,\n        address token,\n        uint256 tokenId,\n        address to,\n        uint256 amount\n    ) public override {\n        if (block.timestamp < getMaturity(tokenId)) {\n            super.exitVault(vault, token, tokenId, to, amount);\n        } else {\n            if (vault == address(0)) revert VaultFCActions__vaultRedeemAndExit_zeroVaultAddress();\n            if (token == address(0)) revert VaultFCActions__vaultRedeemAndExit_zeroTokenAddress();\n            if (to == address(0)) revert VaultFCActions__vaultRedeemAndExit_zeroToAddress();\n            IVaultFC(vault).redeemAndExit(tokenId, to, amount);\n        }\n    }\n\n    /// ======== View Methods ======== ///\n\n    /// @notice Returns an amount of fCash tokens for a given amount of the fCashs underlier token (e.g. USDC)\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param amount Amount of underlier token [underlierScale]\n    /// @return Amount of fCash [tokenScale]\n    function underlierToFCash(uint256 tokenId, uint256 amount) public view returns (uint256) {\n        (, uint256 underlierScale) = getUnderlierToken(tokenId);\n        return\n            uint256(\n                _adjustForRounding(\n                    notionalV2.getfCashAmountGivenCashAmount(\n                        getCurrencyId(tokenId),\n                        -int88(toInt256(div(mul(amount, fCashScale), underlierScale))),\n                        getMarketIndex(tokenId),\n                        block.timestamp\n                    )\n                )\n            );\n    }\n\n    /// @notice Returns a amount of the fCashs underlier token for a given amount of fCash tokens (e.g. fUSDC)\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @param amount Amount of fCash [tokenScale]\n    /// @return Amount of underlier [underlierScale]\n    function fCashToUnderlier(uint256 tokenId, uint256 amount) external view returns (uint256) {\n        (, uint256 underlierScale) = getUnderlierToken(tokenId);\n        (, int256 netUnderlyingCash) = notionalV2.getCashAmountGivenfCashAmount(\n            getCurrencyId(tokenId),\n            -int88(toInt256(amount)),\n            getMarketIndex(tokenId),\n            block.timestamp\n        );\n        return div(mul(underlierScale, uint256(_adjustForRounding(netUnderlyingCash))), uint256(fCashScale));\n    }\n\n    /// @notice Returns the underlying fCash currency\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @return currencyId (Notional Finance)\n    function getCurrencyId(uint256 tokenId) public pure returns (uint16 currencyId) {\n        (currencyId, , ) = EncodeDecode.decodeERC1155Id(tokenId);\n    }\n\n    /// @notice Returns the current market index for this fCash asset. If this returns\n    /// zero that means it is idiosyncratic and cannot be traded.\n    /// @param tokenId fCash Id (ERC1155 tokenId)\n    /// @return Index of the Notional Finance market\n    function getMarketIndex(uint256 tokenId) public view returns (uint8) {\n        (uint256 marketIndex, bool isInvalidMarket) = DateTime.getMarketIndex(\n            Constants.MAX_TRADED_MARKET_INDEX,\n            getMaturity(tokenId),\n            block.timestamp\n        );\n        if (isInvalidMarket) revert VaultFCActions__getMarketIndex_invalidMarket();\n\n        // Market index as defined does not overflow this conversion\n        return uint8(marketIndex);\n    }\n\n    /// @notice Returns the underlying fCash maturity of the token\n    function getMaturity(uint256 tokenId) public pure returns (uint40 maturity) {\n        (, maturity, ) = EncodeDecode.decodeERC1155Id(tokenId);\n    }\n\n    /// @notice Returns the underlier of the token of the token that this token settles to, and its precision scale.\n    /// E.g. for fUSDC it returns the USDC address and the scale of USDC\n    /// @param tokenId fCash ID (ERC1155 tokenId)\n    /// @return underlierToken Address of the underlier (for fUSDC it would be USDC)\n    /// @return underlierScale Precision of the underlier (USDC it would be 1e6)\n    function getUnderlierToken(uint256 tokenId) public view returns (IERC20 underlierToken, uint256 underlierScale) {\n        (, INotional.Token memory underlier) = notionalV2.getCurrency(getCurrencyId(tokenId));\n        if (underlier.tokenType != INotional.TokenType.UnderlyingToken) {\n            revert VaultFCActions__getUnderlierToken_invalidUnderlierTokenType();\n        }\n        // decimals is 1eDecimals\n        return (IERC20(underlier.tokenAddress), uint256(underlier.decimals));\n    }\n\n    /// @notice Returns the cToken (from Compound) which the fCash settles to at maturity\n    /// @param tokenId fCash ID (ERC1155 tokenId)\n    /// @return cToken Address of the cToken\n    /// @return cTokenScale Precision scale of the cToken (1e8)\n    function getCToken(uint256 tokenId) public view returns (IERC20 cToken, uint256 cTokenScale) {\n        (INotional.Token memory asset, ) = notionalV2.getCurrency(getCurrencyId(tokenId));\n        if (asset.tokenType != INotional.TokenType.cToken) {\n            revert VaultFCActions__getCToken_invalidAssetTokenType();\n        }\n        // decimals is 1eDecimals\n        return (IERC20(asset.tokenAddress), uint256(asset.decimals));\n    }\n\n    /// @dev Adjusts the returned cash values for potential rounding issues in calculations\n    function _adjustForRounding(int256 x) private pure returns (int256) {\n        int256 y = (x < 1e7) ? int256(1) : (x / 1e7);\n        return x - y;\n    }\n\n    /// ======== ERC1155 ======== ///\n\n    /// @notice Grants or revokes permission to `spender` to transfer the UserProxy's ERC1155 tokens,\n    /// according to `approved`\n    /// @param token Address of the ERC1155 token\n    /// @param spender Address of the spender\n    /// @param approved Boolean indicating `spender` approval\n    function setApprovalForAll(\n        address token,\n        address spender,\n        bool approved\n    ) external {\n        IERC1155(token).setApprovalForAll(spender, approved);\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"codex\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"moneta\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fiat\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"publican_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"notionalV2_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DateTime__getMarketIndex_invalidMaxMarketIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateTime__getMarketIndex_marketNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateTime__getMarketIndex_zeroMaxMarketIndex\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateTime__getReferenceTime_invalidBlockTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DateTime__getTradedMarket_invalidIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__add_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__div_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"Math__mul_overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"Math__mul_overflow_signed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"Math__toInt256_overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Vault1155Actions__enterVault_zeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Vault1155Actions__enterVault_zeroVaultAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Vault1155Actions__exitVault_zeroToAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Vault1155Actions__exitVault_zeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Vault1155Actions__exitVault_zeroVaultAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultActions__exitMoneta_zeroUserAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__buyCollateralAndModifyDebt_zeroMaxUnderlierAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__getCToken_invalidAssetTokenType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__getMarketIndex_invalidMarket\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__getUnderlierToken_invalidUnderlierTokenType\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__onERC1155Received_invalidCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__onERC1155Received_invalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__redeemCollateralAndModifyDebt_notMatured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__redeemCollateralAndModifyDebt_zeroFCashAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__redeemfCash_amountOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__sellCollateralAndModifyDebt_matured\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__sellCollateralAndModifyDebt_zeroFCashAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__sellfCash_amountOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__vaultRedeemAndExit_zeroToAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__vaultRedeemAndExit_zeroTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"VaultFCActions__vaultRedeemAndExit_zeroVaultAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveFIAT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fCashAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"},{\"internalType\":\"uint32\",\"name\":\"minImpliedRate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"maxUnderlierAmount\",\"type\":\"uint256\"}],\"name\":\"buyCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"codex\",\"outputs\":[{\"internalType\":\"contract ICodex\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterMoneta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enterVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exitMoneta\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exitVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fCashScale\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fCashToUnderlier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fiat\",\"outputs\":[{\"internalType\":\"contract IFIAT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"cToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cTokenScale\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrencyId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currencyId\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMarketIndex\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMaturity\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"maturity\",\"type\":\"uint40\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnderlierToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"underlierToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlierScale\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"deltaCollateral\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"modifyCollateralAndDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moneta\",\"outputs\":[{\"internalType\":\"contract IMoneta\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notionalV2\",\"outputs\":[{\"internalType\":\"contract INotional\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publican\",\"outputs\":[{\"internalType\":\"contract IPublican\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fCashAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"}],\"name\":\"redeemCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"position\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateralizer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"creditor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fCashAmount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"deltaNormalDebt\",\"type\":\"int256\"},{\"internalType\":\"uint32\",\"name\":\"maxImpliedRate\",\"type\":\"uint32\"}],\"name\":\"sellCollateralAndModifyDebt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"underlierToFCash\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VaultFCActions", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "0000000000000000000000006bf5eb06201e4ea7c315b1c23bfe79fae30541f9000000000000000000000000ea8efd605845f4cfaa8ee6c757390196e1b3f736000000000000000000000000586aa273f262909eef8fa02d90ab65f5015e05160000000000000000000000003ff548c77a82b377258b5220164e7ae267ed89780000000000000000000000001344a36a1b56144c3bc62e7757377d288fde0369", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}