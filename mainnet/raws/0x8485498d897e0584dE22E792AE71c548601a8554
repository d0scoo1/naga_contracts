{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GNU LGPLv3\r\n// File: UsePay/UsePAY/Storage/WrapAddresses.sol\r\n\r\n\r\npragma solidity >= 0.7.0;\r\n\r\ncontract WrapAddresses {\r\n    // address internal iAddresses = 0x30BafbA23f24d386a39210280590B0346c0dfd92; // UePAY_eth_rinkeby\r\n    // address internal iAddresses = 0x31716bbA4B12A52592c041ED19Dc06B5F99e20e8; //UsePAY_bsc_testnet\r\n\r\n    // address internal iAddresses = 0xeD05ccB1f106D57bd18C6e3bD88dB70AC936de68; // UsePAY_bsc_mainnet\r\n    address internal iAddresses = 0xeD05ccB1f106D57bd18C6e3bD88dB70AC936de68; // UsePAY_eth_mainnet\r\n\r\n    // address internal iAddresses = ; // UsePAY_eth_mainnet\r\n    // address internal iAddresses = ; // UsePAY_bsc_mainnet\r\n\r\n\r\n    // address internal iAddresses = 0x48aa9c47897B50dBF8B7dc3A1bFa4b05C481EB3d; //Bridge_eth_mainnet\r\n    // address internal iAddresses = 0x48aa9c47897B50dBF8B7dc3A1bFa4b05C481EB3d; // Bridge_bsc_mainnet\r\n    \r\n\r\n\r\n    modifier onlyManager(address _addr) {\r\n        checkManager(_addr);\r\n        _;\r\n    }\r\n    \r\n    function checkManager(address _addr) internal view {\r\n        (, bytes memory result ) = address( iAddresses ).staticcall(abi.encodeWithSignature(\"checkManger(address)\",_addr));\r\n        require( abi.decode(result,(bool)) , \"This address is not Manager\");\r\n    } \r\n}\r\n\r\n// File: UsePay/UsePAY/Commander/Commander.sol\r\n\r\n\r\npragma solidity >= 0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ncontract Commander is WrapAddresses {\r\n    \r\n    event giftEvent(address indexed pack,address fromAddr ,address[] toAddr); // 0: pack indexed, 1: from, 2: to, 3: count\r\n    event giveEvent(address indexed pack,address fromAddr ,address[] toAddr); // 0: pack indexed, 1: from, 2: to, 3: count\r\n    \r\n    struct ExactInputSingleParams {\r\n        address tokenIn;\r\n        address tokenOut;\r\n        uint24 fee;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n        uint160 sqrtPriceLimitX96;\r\n    }\r\n    \r\n    struct ExactInputParams {\r\n        bytes path;\r\n        address recipient;\r\n        uint256 deadline;\r\n        uint256 amountIn;\r\n        uint256 amountOutMinimum;\r\n    }\r\n    \r\n    function _transfer(uint16 tokenType, address _to , uint256 value ) internal {\r\n        if ( tokenType == 100 ) {\r\n            payable(_to).transfer(value);\r\n        } else { \r\n            (bool success0,bytes memory tokenResult) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",uint16(tokenType)));\r\n            require(success0,\"0\");\r\n            (bool success, ) = address(abi.decode(tokenResult,(address))).call(abi.encodeWithSignature(\"transfer(address,uint256)\",_to,value));\r\n            require(success,\"TOKEN transfer Fail\");\r\n        }\r\n    }\r\n    \r\n    function _getBalance(uint16 tokenType) internal view returns (uint256) {\r\n        uint balance = 0;\r\n        if ( tokenType ==  100  ) {\r\n            balance = address(this).balance;\r\n        } else {\r\n            (,bytes memory tokenResult) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",uint16(tokenType)));\r\n            (,bytes memory result) = address(abi.decode(tokenResult,(address))).staticcall(abi.encodeWithSignature(\"balanceOf(address)\",address(this)));\r\n            balance = abi.decode(result,(uint256));\r\n        }   \r\n        return balance;\r\n    }\r\n    \r\n    function _swap( address _to, uint256 amountIn ) internal returns (uint256) {\r\n        (,bytes memory result0 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",1200));\r\n        (address routerAddr) = abi.decode(result0,(address));\r\n        (,bytes memory resultDFM ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",101));\r\n        (bool success, bytes memory result) = address( routerAddr ).call{ value: amountIn }(abi.encodeWithSignature(\"exactInputSingle((address,address,uint24,address,uint256,uint256,uint256,uint160))\",getExactInputSigleParams( _to, amountIn, abi.decode(resultDFM,(address))) ) );\r\n        require( success , \"swap ETH->TOKEN fail\" );\r\n            (uint256 amountOut) = abi.decode(result,(uint256));\r\n            return amountOut;\r\n\r\n            //  ( bool success1,) = address( _fromToken ).call( abi.encodeWithSignature( \"approve(address,uint256)\", routerAddr, amountIn ) );\r\n            //  require( success1 , \"tokenApprove Fail\" );\r\n            //  ( bool success2, bytes memory result ) = address( routerAddr ).call( abi.encodeWithSignature( \"exactInput((bytes,address,uint256,uint256,uint256))\", getExactInputParams( _to, amountIn, _fromToken, _toToken ) ) );\r\n            //  require( success2 , \"swap TOKEN->TOKEN Fail\" );\r\n            //  (uint256 amountOut) = abi.decode(result,(uint256));\r\n            // return amountOut;\r\n        \r\n    }\r\n    \r\n    \r\n    function getExactInputSigleParams( address _to, uint256 _amountIn, address _tokenAddr ) internal view returns ( ExactInputSingleParams memory ){\r\n        (,bytes memory result0 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",103));\r\n        (address WETH) = abi.decode(result0,(address));\r\n        uint24 fee = 500;\r\n        uint256 deadline = block.timestamp + 15;\r\n        uint256 amountOutMin = 0;\r\n        uint160 sqrtPriceLimitX96 = 0;\r\n        return ExactInputSingleParams( WETH, _tokenAddr, fee, _to, deadline, _amountIn, amountOutMin, sqrtPriceLimitX96 );\r\n    }\r\n    \r\n    function getExactInputParams( address _to, uint256 _amountIn ,address _fromToken, address _toToken) internal view returns ( ExactInputParams memory ) {\r\n        (,bytes memory result0 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",103));\r\n        (address WETH) = abi.decode(result0,(address));\r\n        bytes memory path = MergeBytes(MergeBytes(MergeBytes(MergeBytes(addressToBytes(_fromToken),uintToBytes(500)),addressToBytes(WETH)),uintToBytes(500)),addressToBytes(_toToken));\r\n        address recipient = _to;\r\n        uint256 deadline = block.timestamp + 15;\r\n        uint256 amountIn = _amountIn;\r\n        uint256 amountOutMin = 1;\r\n        return ExactInputParams( path, recipient, deadline, amountIn, amountOutMin );\r\n    }\r\n    \r\n    function addressToBytes(address a) private pure returns( bytes memory) {\r\n        return abi.encodePacked(a);\r\n    }\r\n    \r\n    \r\n    function uintToBytes( uint24 a ) private pure returns( bytes memory ) {\r\n        return abi.encodePacked(a);\r\n    }\r\n \r\n    function MergeBytes(bytes memory a, bytes memory b) internal pure returns (bytes memory c) {\r\n        uint alen = a.length;\r\n        uint totallen = alen + b.length;\r\n        uint loopsa = (a.length + 31) / 32;\r\n        uint loopsb = (b.length + 31) / 32;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(m, totallen)\r\n            for {  let i := 0 } lt(i, loopsa) { i := add(1, i) } { mstore(add(m, mul(32, add(1, i))), mload(add(a, mul(32, add(1, i))))) }\r\n            for {  let i := 0 } lt(i, loopsb) { i := add(1, i) } { mstore(add(m, add(mul(32, add(1, i)), alen)), mload(add(b, mul(32, add(1, i))))) }\r\n            mstore(0x40, add(m, add(32, totallen)))\r\n            c := m\r\n        }\r\n    }\r\n    \r\n    \r\n    function checkFee(uint count) internal {\r\n        uint8 n = 0;\r\n        if(count>10) {\r\n            while (count >= 10) {\r\n                count = count/10;\r\n                n++;\r\n            }\r\n            require( msg.value > getPrice() * n * 5 , \"C01\");\r\n        } else {\r\n            require( msg.value > getPrice() , \"C01\");\r\n        }\r\n        \r\n    }\r\n\r\n    function getPrice() internal view returns (uint)\r\n    {\r\n        (,bytes memory result0 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",1201));\r\n        (address uniswapFactory) = abi.decode(result0,(address));\r\n        (,bytes memory result1 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",102));\r\n        (address USDT) = abi.decode(result1,(address));\r\n        (,bytes memory result2 ) = address(iAddresses).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",103));\r\n        (address WETH) = abi.decode(result2,(address));\r\n        (,bytes memory result3 ) = address(uniswapFactory).staticcall(abi.encodeWithSignature(\"getPool(address,address,uint24)\",USDT,WETH,500));    \r\n        address poolAddr = abi.decode(result3,(address));\r\n        (,bytes memory result4 ) = poolAddr.staticcall(abi.encodeWithSignature(\"slot0()\"));\r\n        uint sqrtPriceX96 = abi.decode(result4,(uint));\r\n        return sqrtPriceX96 * sqrtPriceX96 * 1e6 >> (96 * 2);\r\n    }\r\n    \r\n    function getCountFee(uint count) external view returns (uint256) {\r\n        uint8 n = 0;\r\n        if(count > 10) {\r\n            while( count >= 10 ) {\r\n                count = count/10;\r\n                n++;\r\n            }\r\n            return getPrice() * n * 5;\r\n        } else {\r\n            return getPrice();\r\n        }\r\n    }\r\n}\r\n// File: UsePay/UsePAY/Pack/Pack.sol\r\n\r\n\r\npragma solidity >= 0.7.0;\r\n\r\n\r\ncontract Ticket is WrapAddresses {\r\n\r\n    uint8 ver = 1;\r\n\r\n    struct pack {\r\n        uint32 hasCount;\r\n        uint32 useCount;\r\n    }\r\n    \r\n    address internal owner;\r\n    uint256 internal quantity;\r\n    uint256 internal refundCount = 0;\r\n    \r\n    struct PackInfo {\r\n        uint32 total;\r\n        uint32 times0;\r\n        uint32 times1;\r\n        uint32 times2;\r\n        uint32 times3;\r\n        uint256 price;\r\n        uint16 tokenType;\r\n        uint8 noshowValue;\r\n        uint8 maxCount;\r\n    }\r\n    \r\n    mapping(address=>pack) internal buyList;\r\n    \r\n    PackInfo internal packInfo;\r\n    uint8 internal isCalculated = 0;\r\n    uint32 internal totalUsedCount = 0;\r\n}\r\n\r\ncontract Coupon is WrapAddresses {\r\n    \r\n    uint8 ver = 1;\r\n\r\n    struct pack {\r\n        uint32 hasCount;\r\n        uint32 useCount;\r\n    }\r\n    \r\n    uint256 internal quantity;\r\n    \r\n    mapping(address=>pack) internal buyList;\r\n    \r\n    struct PackInfo {\r\n        uint32 total;\r\n        uint32 maxCount;\r\n        uint32 times0;\r\n        uint32 times1;\r\n        uint32 times2;\r\n        uint32 times3;\r\n    }\r\n    address internal owner;\r\n    PackInfo internal packInfo;\r\n}\r\n\r\ncontract Subscription is WrapAddresses {\r\n\r\n    uint8 ver = 1;\r\n\r\n    struct pack {\r\n        uint32 hasCount;\r\n    }\r\n    \r\n    uint256 internal refundCount = 0;\r\n    uint256 internal noshowCount = 0;\r\n    uint256 internal noshowLimit = 0;\r\n    uint256 internal quantity;\r\n    uint256 internal isLive = 0;\r\n    uint256 internal noShowTime = 0;\r\n    address internal owner;\r\n    \r\n    struct PackInfo {\r\n        uint32 total;\r\n        uint32 times0;\r\n        uint32 times1;\r\n        uint32 times2;\r\n        uint32 times3;\r\n        uint256 price;\r\n        uint16 tokenType;\r\n    }\r\n    \r\n    mapping(address=>pack) internal buyList;\r\n    \r\n    PackInfo packInfo;\r\n}\r\n// File: UsePay/UsePAY/Pack/CouponPack.sol\r\n\r\n\r\npragma solidity >= 0.7.0;\r\n\r\n\r\ncontract CouponPack is Coupon {\r\n    constructor ( PackInfo memory _packInfo , address _owner ) {\r\n        packInfo = _packInfo;\r\n        owner = _owner;\r\n        quantity = _packInfo.total;\r\n    }\r\n    \r\n    \r\n    receive () external payable {}\r\n    fallback() external payable {\r\n        (bool success, bytes memory result0) = address( iAddresses ).staticcall(abi.encodeWithSignature(\"viewAddress(uint16)\",10001));\r\n        require( success, \"viewCouponCommander Fail\");\r\n        (address coupon_commander) = abi.decode(result0,(address));\r\n        //get Data \r\n        assembly {\r\n            let ptr := mload( 0x40 )\r\n            calldatacopy( ptr, 0, calldatasize() )\r\n            let result := delegatecall( gas(), coupon_commander , ptr, calldatasize(), 0, 0 )\r\n            returndatacopy( ptr, 0, returndatasize() )\r\n            switch result \r\n                case 0 { //fail\r\n                    revert( ptr, returndatasize() )\r\n                } \r\n                default { //success\r\n                    return( ptr, returndatasize() )\r\n                }\r\n        }\r\n    }\r\n}\r\n// File: UsePay/UsePAY/Commander/CouponCommander.sol\r\n\r\n\r\npragma solidity >= 0.7.0;\r\n\r\n\r\ncontract CouponCommander is Commander,Coupon {\r\n     \r\n    event buyEvent(address indexed pack, uint256 buyNum, address buyer,uint256 count); // 0: pack indexed, 1: buyer, 2: count \r\n    event useEvent(address indexed pack, address user,uint256 count); // 0: pack indexed, 1: buyer, 2: count \r\n    event requestRefundEvent(address indexed pack, address buyer ,uint256 count); // 0: pack indexed, 1: buyer, 2: count\r\n    event calculateRefundEvent(address indexed pack, address[] buyers ) ;\r\n    event calculateEvent(address indexed); \r\n    event changeTotalEvent(address indexed,uint256 _before,uint256 _after);\r\n\r\n    //-----------------------------------------\r\n    //  modifiers\r\n    //-----------------------------------------\r\n    \r\n    \r\n    modifier onlyOwner() { require ( msg.sender == owner, \"O01\" ); _; }\r\n    modifier canUse(uint256 count) { \r\n        require ( buyList[msg.sender].hasCount - buyList[msg.sender].useCount >= count, \"U02\" );\r\n        _; \r\n    }\r\n    modifier canBuy(uint256 count) { \r\n        require (count<=packInfo.maxCount,\"\");\r\n        require ( block.timestamp >= packInfo.times0 && block.timestamp <= packInfo.times1, \"B01\" ); \r\n        require ( quantity - count >= 0 , \"B04\"); \r\n        _; \r\n    }\r\n\r\n\r\n    function _buy(uint32 count, address buyer) private {\r\n        buyList[buyer].hasCount = buyList[buyer].hasCount+( count );\r\n        quantity = quantity - count ;\r\n    }\r\n    \r\n    \r\n    //-----------------------------------------\r\n    //  payableFunctions\r\n    //-----------------------------------------\r\n    \r\n    function buy( uint32 count , uint256 buyNum ) external payable canBuy(count) {\r\n        _buy(count, msg.sender);\r\n        emit buyEvent(  address( this ), buyNum, msg.sender, count );\r\n    }\r\n    \r\n    function give(address[] memory toAddr) external payable canUse( toAddr.length ) {\r\n        require(block.timestamp<packInfo.times3,\"\");\r\n        buyList[msg.sender].hasCount = buyList[msg.sender].hasCount- uint32(toAddr.length);\r\n        for(uint i=0; i<toAddr.length; i++) {\r\n            buyList[toAddr[i]].hasCount++;\r\n        }\r\n        emit giveEvent( address(this), msg.sender, toAddr );\r\n    }\r\n    \r\n    function gift( address[] memory toAddr ) external payable canBuy(toAddr.length) {\r\n        for ( uint i =0; i<toAddr.length; i++) {\r\n            buyList[toAddr[i]].hasCount++;\r\n        }\r\n        quantity = quantity - toAddr.length ;\r\n        emit giftEvent( address(this), msg.sender, toAddr);\r\n    }\r\n    \r\n    function use( uint32 _count ) external payable canUse( _count ) {\r\n        require ( block.timestamp > packInfo.times2 && block.timestamp < packInfo.times1, \"U01\" );\r\n        buyList[msg.sender].useCount = buyList[msg.sender].useCount+(_count);\r\n        emit useEvent( address( this ), msg.sender, _count );\r\n    }\r\n    \r\n    function changeTotal(uint32 _count) external payable onlyOwner {\r\n        require(packInfo.total - quantity <= _count,\"count too high\");\r\n        if ( _count > packInfo.total ) {\r\n            checkFee(_count-packInfo.total);    \r\n            _swap(msg.sender,msg.value);\r\n            quantity = quantity + ( _count - packInfo.total );\r\n        }else {\r\n            quantity = quantity - ( packInfo.total - _count );\r\n        }\r\n        emit changeTotalEvent(address(this),packInfo.total,_count);\r\n        packInfo.total = _count;\r\n    }\r\n    \r\n    \r\n    //-----------------------------------------\r\n    //  viewFunctions\r\n    //-----------------------------------------\r\n    function viewInfo() external view returns (PackInfo memory) { return packInfo; }\r\n    \r\n    function viewUser(address _addr) external view returns (pack memory) { return buyList[_addr]; }\r\n    \r\n    function viewQuantity() external view returns (uint256) { return quantity; }\r\n    \r\n    function viewOwner() external view returns (address) { return owner; }\r\n\r\n    function viewVersion() external view returns (uint8) { return ver; }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"buyEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"calculateEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"buyers\",\"type\":\"address[]\"}],\"name\":\"calculateRefundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_before\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_after\",\"type\":\"uint256\"}],\"name\":\"changeTotalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"toAddr\",\"type\":\"address[]\"}],\"name\":\"giftEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"toAddr\",\"type\":\"address[]\"}],\"name\":\"giveEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"requestRefundEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pack\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"useEvent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"count\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"buyNum\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_count\",\"type\":\"uint32\"}],\"name\":\"changeTotal\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getCountFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toAddr\",\"type\":\"address[]\"}],\"name\":\"gift\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"toAddr\",\"type\":\"address[]\"}],\"name\":\"give\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_count\",\"type\":\"uint32\"}],\"name\":\"use\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"total\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"times0\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"times1\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"times2\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"times3\",\"type\":\"uint32\"}],\"internalType\":\"struct Coupon.PackInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewQuantity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"viewUser\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"hasCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"useCount\",\"type\":\"uint32\"}],\"internalType\":\"struct Coupon.pack\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewVersion\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CouponCommander", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://064f94a9fac5148f37786826124d5bd818a5ce71a86f77de0e76587287ea27cd"}]}