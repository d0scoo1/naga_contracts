{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"NftContractPanther.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./utils/Ownable.sol\\\";\\r\\nimport \\\"./utils/ECDSA.sol\\\";\\r\\nimport \\\"./utils/EIP712.sol\\\";\\r\\n\\r\\ncontract PantherNft is ERC721, EIP712, Ownable {\\r\\n    string public baseURI;\\r\\n    uint96 public royaltyFeesInBips;\\r\\n    address public royaltyAddress;\\r\\n    bool public publicAllowed = false;\\r\\n    uint120 public MAX_SUPPLY = 1000;\\r\\n    uint256 public mintCost;\\r\\n    string private constant SIGNING_DOMAIN = \\\"PANTHER_CON\\\";\\r\\n    string private constant SIGNATURE_VERSION = \\\"1\\\";\\r\\n    address private signAddress;\\r\\n    bool pauseMint = false;\\r\\n    uint256 private supplyLeft = 1000;\\r\\n\\r\\n    mapping(uint256 => uint256) private randNumber;\\r\\n    mapping(address => bool) public availed;\\r\\n\\r\\n    constructor(\\r\\n        string memory _name,\\r\\n        string memory _symbol,\\r\\n        string memory _base,\\r\\n        uint256 mint_cost,\\r\\n        uint96 _fees,\\r\\n        address _signAddress\\r\\n    ) ERC721(_name, _symbol) EIP712(SIGNING_DOMAIN, SIGNATURE_VERSION) {\\r\\n        baseURI = _base;\\r\\n        require(_fees <= 10000, \\\"cannot exceed 10000\\\");\\r\\n        royaltyFeesInBips = _fees;\\r\\n        royaltyAddress = msg.sender;\\r\\n        mintCost = mint_cost;\\r\\n        signAddress = _signAddress;\\r\\n    }\\r\\n\\r\\n    function _baseURI() internal view virtual override returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n\\r\\n    function getChainId() public view returns (uint256) {\\r\\n        return block.chainid;\\r\\n    }\\r\\n\\r\\n    function setSignAddress(address _signAddress) external onlyOwner {\\r\\n        signAddress = _signAddress;\\r\\n    }\\r\\n\\r\\n    function setMintCost(uint256 val) external onlyOwner {\\r\\n        mintCost = val;\\r\\n    }\\r\\n\\r\\n    function setPauseMint(bool val) external onlyOwner {\\r\\n        pauseMint = val;\\r\\n    }\\r\\n\\r\\n    function mintWhitelist(uint256 val, bytes memory signature) public payable {\\r\\n        require(pauseMint == false, \\\"Minting is paused\\\");\\r\\n        uint256 q = supplyLeft;\\r\\n        require(supplyLeft >= 1, \\\"Max supply reached\\\");\\r\\n        unchecked {\\r\\n            supplyLeft--;\\r\\n        }\\r\\n        require(val <= 10000, \\\"MAX DISCOUNT IS 10000\\\");\\r\\n        require(\\r\\n            check(msg.sender, val, signature) == signAddress,\\r\\n            \\\"Invalid signature\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            _balanceOf[msg.sender]++;\\r\\n        }\\r\\n        if (val > 0) {\\r\\n            bool flag = availed[msg.sender];\\r\\n            availed[msg.sender] = true;\\r\\n            require(flag == false, \\\"Discount already applied\\\");\\r\\n        }\\r\\n        if (val < 10000) {\\r\\n            uint256 toPay = ((10000 - val) * (mintCost)) / 10000;\\r\\n            require(msg.value >= toPay, \\\"Not engough eth\\\");\\r\\n        }\\r\\n        if (val == 0) {\\r\\n            require(msg.value >= mintCost, \\\"Not engough eth\\\");\\r\\n        }\\r\\n        uint256 id = uint256(\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    msg.sender,\\r\\n                    block.timestamp,\\r\\n                    q,\\r\\n                    block.difficulty\\r\\n                )\\r\\n            )\\r\\n        ) % q;\\r\\n\\r\\n        unchecked {\\r\\n            id++;\\r\\n        }\\r\\n\\r\\n        if (randNumber[id] == 0) {\\r\\n            require(ownerOf[id] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[id] = msg.sender;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), msg.sender, id);\\r\\n        } else {\\r\\n            uint256 v = randNumber[id];\\r\\n            require(ownerOf[v] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[v] = msg.sender;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), msg.sender, v);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function check(\\r\\n        address to,\\r\\n        uint256 val,\\r\\n        bytes memory signature\\r\\n    ) public view returns (address) {\\r\\n        return _verify(to, val, signature);\\r\\n    }\\r\\n\\r\\n    function _verify(\\r\\n        address to,\\r\\n        uint256 val,\\r\\n        bytes memory signature\\r\\n    ) internal view returns (address) {\\r\\n        bytes32 digest = _hash(to, val);\\r\\n        return ECDSA.recover(digest, signature);\\r\\n    }\\r\\n\\r\\n    function _hash(address to, uint256 val) internal view returns (bytes32) {\\r\\n        return\\r\\n            _hashTypedDataV4(\\r\\n                keccak256(\\r\\n                    abi.encode(\\r\\n                        keccak256(\\\"PantherStruct(address to,uint256 val)\\\"),\\r\\n                        to,\\r\\n                        val\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function mintOwner(address to, uint256 id) external onlyOwner {\\r\\n        uint256 q = supplyLeft;\\r\\n        require(id <= q, \\\"Id out of range\\\");\\r\\n        require(supplyLeft >= 1, \\\"Max supply reached\\\");\\r\\n        unchecked {\\r\\n            supplyLeft--;\\r\\n        }\\r\\n        unchecked {\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n        if (randNumber[id] == 0) {\\r\\n            require(ownerOf[id] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[id] = to;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), to, id);\\r\\n        } else {\\r\\n            uint256 v = randNumber[id];\\r\\n            require(ownerOf[v] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[v] = to;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), to, v);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function mintPublic(address to) public payable {\\r\\n        require(pauseMint == false, \\\"Minting is paused\\\");\\r\\n        require(msg.value > (mintCost - 1), \\\"Not engough eth\\\");\\r\\n        require(publicAllowed, \\\"Open minting not allowed\\\");\\r\\n        uint256 q = supplyLeft;\\r\\n        require(supplyLeft >= 1, \\\"Max supply reached\\\");\\r\\n        unchecked {\\r\\n            supplyLeft--;\\r\\n        }\\r\\n\\r\\n        uint256 id = uint256(\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    msg.sender,\\r\\n                    block.timestamp,\\r\\n                    block.difficulty,\\r\\n                    q\\r\\n                )\\r\\n            )\\r\\n        ) % q;\\r\\n\\r\\n        unchecked {\\r\\n            id++;\\r\\n        }\\r\\n\\r\\n        if (randNumber[id] == 0) {\\r\\n            require(ownerOf[id] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[id] = to;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), to, id);\\r\\n        } else {\\r\\n            uint256 v = randNumber[id];\\r\\n            require(ownerOf[v] == address(0), \\\"Already minted\\\");\\r\\n            ownerOf[v] = to;\\r\\n            if (randNumber[q] == 0) {\\r\\n                randNumber[id] = q;\\r\\n            } else {\\r\\n                randNumber[id] = randNumber[q];\\r\\n            }\\r\\n            emit Transfer(address(0), to, v);\\r\\n        }\\r\\n        unchecked {\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\r\\n        external\\r\\n        view\\r\\n        returns (address, uint256)\\r\\n    {\\r\\n        return (royaltyAddress, calculateRoyalty(_salePrice));\\r\\n    }\\r\\n\\r\\n    function setPublicMint(bool _status) external onlyOwner {\\r\\n        publicAllowed = _status;\\r\\n    }\\r\\n\\r\\n    function setRoyaltyInfo(address _royaltyAddress, uint96 _royaltyFeesInBips)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(_royaltyFeesInBips <= 10000, \\\"cannot exceed 10000\\\");\\r\\n        royaltyAddress = _royaltyAddress;\\r\\n        royaltyFeesInBips = _royaltyFeesInBips;\\r\\n    }\\r\\n\\r\\n    function calculateRoyalty(uint256 _salePrice)\\r\\n        public\\r\\n        view\\r\\n        returns (uint256)\\r\\n    {\\r\\n        return (_salePrice / 10000) * royaltyFeesInBips;\\r\\n    }\\r\\n\\r\\n    function withdrawEth() external onlyOwner {\\r\\n        address payable own = payable(owner());\\r\\n        (bool success, ) = payable(own).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(success, \\\"Transaction failed\\\");\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ECDSA.sol\\\";\\r\\n\\r\\nabstract contract EIP712 {\\r\\n    /* solhint-disable var-name-mixedcase */\\r\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\r\\n    // invalidate the cached domain separator if the chain id changes.\\r\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\r\\n    uint256 private immutable _CACHED_CHAIN_ID;\\r\\n    address private immutable _CACHED_THIS;\\r\\n\\r\\n    bytes32 private immutable _HASHED_NAME;\\r\\n    bytes32 private immutable _HASHED_VERSION;\\r\\n    bytes32 private immutable _TYPE_HASH;\\r\\n\\r\\n    /* solhint-enable var-name-mixedcase */\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the domain separator and parameter caches.\\r\\n     *\\r\\n     * The meaning of `name` and `version` is specified in\\r\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\r\\n     *\\r\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\r\\n     * - `version`: the current major version of the signing domain.\\r\\n     *\\r\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\r\\n     * contract upgrade].\\r\\n     */\\r\\n    constructor(string memory name, string memory version) {\\r\\n        bytes32 hashedName = keccak256(bytes(name));\\r\\n        bytes32 hashedVersion = keccak256(bytes(version));\\r\\n        bytes32 typeHash = keccak256(\\r\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\r\\n        );\\r\\n        _HASHED_NAME = hashedName;\\r\\n        _HASHED_VERSION = hashedVersion;\\r\\n        _CACHED_CHAIN_ID = block.chainid;\\r\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\\r\\n            typeHash,\\r\\n            hashedName,\\r\\n            hashedVersion\\r\\n        );\\r\\n        _CACHED_THIS = address(this);\\r\\n        _TYPE_HASH = typeHash;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the domain separator for the current chain.\\r\\n     */\\r\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\r\\n        if (\\r\\n            address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID\\r\\n        ) {\\r\\n            return _CACHED_DOMAIN_SEPARATOR;\\r\\n        } else {\\r\\n            return\\r\\n                _buildDomainSeparator(\\r\\n                    _TYPE_HASH,\\r\\n                    _HASHED_NAME,\\r\\n                    _HASHED_VERSION\\r\\n                );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _buildDomainSeparator(\\r\\n        bytes32 typeHash,\\r\\n        bytes32 nameHash,\\r\\n        bytes32 versionHash\\r\\n    ) private view returns (bytes32) {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    typeHash,\\r\\n                    nameHash,\\r\\n                    versionHash,\\r\\n                    block.chainid,\\r\\n                    address(this)\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\r\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\r\\n     *\\r\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\r\\n     *\\r\\n     * ```solidity\\r\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\r\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\r\\n     *     mailTo,\\r\\n     *     keccak256(bytes(mailContents))\\r\\n     * )));\\r\\n     * address signer = ECDSA.recover(digest, signature);\\r\\n     * ```\\r\\n     */\\r\\n    function _hashTypedDataV4(bytes32 structHash)\\r\\n        internal\\r\\n        view\\r\\n        virtual\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS,\\r\\n        InvalidSignatureV\\r\\n    }\\r\\n\\r\\n    function _throwError(RecoverError error) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert(\\\"ECDSA: invalid signature\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureV) {\\r\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function tryRecover(bytes32 hash, bytes memory signature)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address, RecoverError)\\r\\n    {\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else if (signature.length == 64) {\\r\\n            bytes32 r;\\r\\n            bytes32 vs;\\r\\n\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                vs := mload(add(signature, 0x40))\\r\\n            }\\r\\n            return tryRecover(hash, r, vs);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function recover(bytes32 hash, bytes memory signature)\\r\\n        internal\\r\\n        pure\\r\\n        returns (address)\\r\\n    {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        bytes32 s = vs &\\r\\n            bytes32(\\r\\n                0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\\r\\n            );\\r\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\r\\n        return tryRecover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    function recover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        if (\\r\\n            uint256(s) >\\r\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\r\\n        ) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS);\\r\\n        }\\r\\n        if (v != 27 && v != 28) {\\r\\n            return (address(0), RecoverError.InvalidSignatureV);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature);\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError);\\r\\n    }\\r\\n\\r\\n    function recover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    function toEthSignedMessageHash(bytes32 hash)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        // 32 is the length in bytes of hash,\\r\\n        // enforced by the type signature above\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function toEthSignedMessageHash(bytes memory s)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\r\\n                    \\\"\\\\x19Ethereum Signed Message:\\\\n\\\",\\r\\n                    Strings.toString(s.length),\\r\\n                    s\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\\r\\n        internal\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash)\\r\\n            );\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransfered(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(_msgSender() == owner(), \\\"Caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Owner cannot be zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = owner();\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransfered(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./utils/ERC165.sol\\\";\\r\\nimport \\\"./utils/IERC721Metadata.sol\\\";\\r\\nimport \\\"./utils/Address.sol\\\";\\r\\nimport \\\"./utils/Strings.sol\\\";\\r\\nimport \\\"./utils/Context.sol\\\";\\r\\n\\r\\ninterface ERC721TokenReceiver {\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 id,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\\r\\ncontract ERC721 is Context {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 indexed id\\r\\n    );\\r\\n\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    function supportsInterface(bytes4 interfaceId)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bool)\\r\\n    {\\r\\n        return\\r\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\r\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\r\\n            interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\\r\\n            interfaceId == 0x2a55205a; //For Royalty\\r\\n    }\\r\\n\\r\\n    string public name;\\r\\n\\r\\n    string public symbol;\\r\\n\\r\\n    mapping(address => uint256) internal _balanceOf;\\r\\n\\r\\n    mapping(uint256 => address) public ownerOf;\\r\\n\\r\\n    mapping(uint256 => address) public getApproved;\\r\\n\\r\\n    mapping(uint256 => uint256) public tokenType;\\r\\n\\r\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\r\\n\\r\\n    constructor(string memory _name, string memory _symbol) {\\r\\n        name = _name;\\r\\n        symbol = _symbol;\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (string memory)\\r\\n    {\\r\\n        require(_exists(tokenId), \\\"No token with this Id exists\\\");\\r\\n\\r\\n        string memory baseURI = _baseURI();\\r\\n        return\\r\\n            bytes(baseURI).length > 0\\r\\n                ? string(abi.encodePacked(baseURI, tokenId.toString(), \\\".json\\\"))\\r\\n                : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\r\\n        address owner = ownerOf[tokenId];\\r\\n        return owner != address(0);\\r\\n    }\\r\\n\\r\\n    function _baseURI() internal view virtual returns (string memory) {\\r\\n        return \\\"\\\";\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _acc) public view returns (uint256) {\\r\\n        return _balanceOf[_acc];\\r\\n    }\\r\\n\\r\\n    function approve(address spender, uint256 id) public virtual {\\r\\n        address owner = ownerOf[id];\\r\\n\\r\\n        require(\\r\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\r\\n            \\\"Not authorized\\\"\\r\\n        );\\r\\n\\r\\n        getApproved[id] = spender;\\r\\n\\r\\n        emit Approval(owner, spender, id);\\r\\n    }\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\r\\n        isApprovedForAll[msg.sender][operator] = approved;\\r\\n\\r\\n        emit ApprovalForAll(msg.sender, operator, approved);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public virtual {\\r\\n        require(from == ownerOf[id], \\\"WRONG FROM\\\");\\r\\n\\r\\n        require(to != address(0), \\\"WRONG TO\\\");\\r\\n\\r\\n        require(\\r\\n            msg.sender == from ||\\r\\n                isApprovedForAll[from][msg.sender] ||\\r\\n                msg.sender == getApproved[id],\\r\\n            \\\"NOT AUTHORIZED\\\"\\r\\n        );\\r\\n\\r\\n        unchecked {\\r\\n            _balanceOf[from]--;\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        ownerOf[id] = to;\\r\\n\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(from, to, id);\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    \\\"\\\"\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes memory data\\r\\n    ) public virtual {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    data\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _mint(\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        uint8 tknType\\r\\n    ) internal virtual {\\r\\n        require(to != address(0), \\\"INVALID_TO\\\");\\r\\n\\r\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\r\\n\\r\\n        unchecked {\\r\\n            _balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        ownerOf[id] = to;\\r\\n        tokenType[id] = tknType;\\r\\n\\r\\n        emit Transfer(address(0), to, id);\\r\\n    }\\r\\n\\r\\n    function _burn(uint256 id) internal virtual {\\r\\n        address owner = ownerOf[id];\\r\\n        require(msg.sender == owner, \\\"NOT_PERMITED\\\");\\r\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\r\\n\\r\\n        delete ownerOf[id];\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(msg.sender, address(0), id);\\r\\n    }\\r\\n\\r\\n    // function _safeMint(address to, uint256 id) internal virtual {\\r\\n    //     _mint(to, id);\\r\\n\\r\\n    //     require(\\r\\n    //         to.code.length == 0 ||\\r\\n    //             ERC721TokenReceiver(to).onERC721Received(\\r\\n    //                 msg.sender,\\r\\n    //                 address(0),\\r\\n    //                 id,\\r\\n    //                 \\\"\\\"\\r\\n    //             ) ==\\r\\n    //             ERC721TokenReceiver.onERC721Received.selector,\\r\\n    //         \\\"UNSAFE_RECIPIENT\\\"\\r\\n    //     );\\r\\n    // }\\r\\n\\r\\n    // function _safeMint(\\r\\n    //     address to,\\r\\n    //     uint256 id,\\r\\n    //     bytes memory data\\r\\n    // ) internal virtual {\\r\\n    //     _mint(to, id);\\r\\n\\r\\n    //     require(\\r\\n    //         to.code.length == 0 ||\\r\\n    //             ERC721TokenReceiver(to).onERC721Received(\\r\\n    //                 msg.sender,\\r\\n    //                 address(0),\\r\\n    //                 id,\\r\\n    //                 data\\r\\n    //             ) ==\\r\\n    //             ERC721TokenReceiver.onERC721Received.selector,\\r\\n    //         \\\"UNSAFE_RECIPIENT\\\"\\r\\n    //     );\\r\\n    // }\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\n\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n   \\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n         \\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp >>= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nlibrary Address{\\r\\n\\r\\n    function isContract(address account) internal view returns(bool){\\r\\n        return account.code.length > 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recepient , uint amount) internal{\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success,) = recepient.call{value:amount}(\\\"\\\");\\r\\n        require(success,\\\"transaction failed\\\");\\r\\n\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"utils/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"../IERC721.sol\\\";\\r\\n\\r\\ninterface IERC721Metadata is IERC721{\\r\\n\\r\\n    function name() external view returns(string memory);\\r\\n\\r\\n    function symbol() external view returns(string memory);\\r\\n\\r\\n    function tokenURI(uint tokenId) external view returns(string memory);\\r\\n\\r\\n\\r\\n}\"\r\n    },\r\n    \"utils/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        override\\r\\n        returns (bool)\\r\\n    {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\nimport \\\"./utils/IERC165.sol\\\";\\r\\n\\r\\ninterface IERC721 is IERC165 {\\r\\n    event Transfer(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 indexed tokenId\\r\\n    );\\r\\n\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 indexed tokenId\\r\\n    );\\r\\n\\r\\n    event ApprovalForAll(\\r\\n        address indexed owner,\\r\\n        address indexed operator,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    function getApproved(uint256 tokenId) external view returns (address);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    function isApprovedForAll(address owner, address operator)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"utils/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.7;\\r\\n\\r\\ninterface IERC165 {\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_base\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"mint_cost\",\"type\":\"uint256\"},{\"internalType\":\"uint96\",\"name\":\"_fees\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"_signAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint120\",\"name\":\"\",\"type\":\"uint120\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"availed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_acc\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"calculateRoyalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"check\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintCost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"mintOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mintPublic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"mintWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyFeesInBips\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"setMintCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"val\",\"type\":\"bool\"}],\"name\":\"setPauseMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setPublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_royaltyAddress\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"_royaltyFeesInBips\",\"type\":\"uint96\"}],\"name\":\"setRoyaltyInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signAddress\",\"type\":\"address\"}],\"name\":\"setSignAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenType\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PantherNft", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000003e2c284391c000000000000000000000000000000000000000000000000000000000000000001f40000000000000000000000003c6d70c523f62ba838f92695e2a44cda1582ecd1000000000000000000000000000000000000000000000000000000000000001f50616e746865725175616e742047656e6573697320436f6c6c656374696f6e000000000000000000000000000000000000000000000000000000000000000004504e5451000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000036697066733a2f2f516d52666b616e357058787a466d5767543541373672374b4e69777873716d626e66746e744171417467715971572f00000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}