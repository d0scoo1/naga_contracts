{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.11;\n\n\n\n// Part: IDiamondCut\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n\n// Part: LibDiamond\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"diamond.standard.diamond.storage\");\n\n    struct DiamondStorage {\n        mapping(bytes4 => bytes32) facets;\n        mapping(uint256 => bytes32) selectorSlots;\n        uint16 selectorCount;\n        mapping(bytes4 => bool) supportedInterfaces;\n        address contractOwner;\n        mapping(address => bool) isOwner;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(\n            msg.sender == diamondStorage().contractOwner,\n            \"Must be contract owner\"\n        );\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        if (selectorCount & 7 > 0) {\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        if (selectorCount & 7 > 0) {\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(_selectors.length > 0, \"No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"Add facet has no code\");\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"Can't add function that already exists\"\n                );\n                ds.facets[selector] =\n                    bytes20(_newFacetAddress) |\n                    bytes32(_selectorCount);\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                _selectorSlot =\n                    (_selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                if (selectorInSlotPosition == 224) {\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"Replace facet has no code\"\n            );\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                require(\n                    oldFacetAddress != address(this),\n                    \"Can't replace immutable function\"\n                );\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"Can't replace function with same function\"\n                );\n                require(\n                    oldFacetAddress != address(0),\n                    \"Can't replace function that doesn't exist\"\n                );\n                ds.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(_newFacetAddress);\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(\n                _newFacetAddress == address(0),\n                \"Remove facet address must be address(0)\"\n            );\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (\n                uint256 selectorIndex;\n                selectorIndex < _selectors.length;\n                selectorIndex++\n            ) {\n                if (_selectorSlot == 0) {\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"Can't remove function that doesn't exist\"\n                    );\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"Can't remove immutable function\"\n                    );\n                    lastSelector = bytes4(\n                        _selectorSlot << (selectorInSlotIndex << 5)\n                    );\n                    if (lastSelector != selector) {\n                        ds.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    _selectorSlot =\n                        (_selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata)\n        internal\n    {\n        if (_init == address(0)) {\n            require(\n                _calldata.length == 0,\n                \"_init is address(0) but_calldata is not empty\"\n            );\n        } else {\n            require(\n                _calldata.length > 0,\n                \"_calldata is empty but _init is not address(0)\"\n            );\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"_init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    revert(string(error));\n                } else {\n                    revert(\"_init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n\n// File: DiamondCutFacet.sol\n\ncontract DiamondCutFacet is IDiamondCut {\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external {\n        LibDiamond.enforceIsContractOwner();\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        if (selectorCount & 7 > 0) {\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        for (\n            uint256 facetIndex;\n            facetIndex < _diamondCut.length;\n            facetIndex++\n        ) {\n            (selectorCount, selectorSlot) = LibDiamond\n                .addReplaceRemoveFacetSelectors(\n                    selectorCount,\n                    selectorSlot,\n                    _diamondCut[facetIndex].facetAddress,\n                    _diamondCut[facetIndex].action,\n                    _diamondCut[facetIndex].functionSelectors\n                );\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n\n        if (selectorCount & 7 > 0) {\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DiamondCutFacet", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}