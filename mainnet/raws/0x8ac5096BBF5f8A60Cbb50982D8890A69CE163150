{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Batch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./AppType.sol\\\";\\nimport \\\"./Utils.sol\\\";\\n\\nlibrary BatchFactory {\\n    using LeafUtils for AppType.NFT;\\n    using LeafUtils for AppType.Pass;\\n    using MerkleProof for bytes32[];\\n\\n    event BatchCreated(\\n        uint256 batchId,\\n        AppType.BatchKind kind,\\n        uint256 isOpenAt,\\n        bool disabled,\\n        bytes32 root,\\n        address collection\\n    );\\n    event BatchUpdated(\\n        uint256 batchId,\\n        uint256 isOpenAt,\\n        bool disabled,\\n        bytes32 root,\\n        address collection\\n    );\\n    event ExcludedLeaf(bytes32 leaf, uint256 batchId, bool isExcluded);\\n    event AuthorizedMint(\\n        uint256 nftBatchId,\\n        uint256 passBatchId,\\n        string nftUri,\\n        uint256 tierId,\\n        address swapToken,\\n        uint256 swapAmount,\\n        address account,\\n        uint256 newTokenId\\n    );\\n\\n    function createBatch(\\n        AppType.State storage state,\\n        AppType.BatchKind kind,\\n        uint256 isOpenAt,\\n        bool disabled,\\n        bytes32 root,\\n        address collection\\n    ) public {\\n        require(\\n            msg.sender == state.config.addresses[AppType.AddressConfig.DAO],\\n            \\\"E012\\\"\\n        );\\n        uint256 newBatchId = ++state.id[AppType.Model.BATCH];\\n        state.batches[newBatchId] = AppType.Batch({\\n            id: newBatchId,\\n            kind: kind,\\n            isOpenAt: isOpenAt,\\n            disabled: disabled,\\n            root: root,\\n            collection: collection\\n        });\\n        emit BatchCreated(\\n            newBatchId,\\n            kind,\\n            isOpenAt,\\n            disabled,\\n            root,\\n            collection\\n        );\\n    }\\n\\n    function updateBatch(\\n        AppType.State storage state,\\n        uint256 batchId,\\n        uint256 isOpenAt,\\n        bool disabled,\\n        bytes32 root,\\n        address collection\\n    ) public {\\n        require(\\n            msg.sender == state.config.addresses[AppType.AddressConfig.DAO],\\n            \\\"E012\\\"\\n        );\\n\\n        require(state.batches[batchId].id == batchId, \\\"E001\\\");\\n        AppType.Batch storage batch = state.batches[batchId];\\n        batch.isOpenAt = isOpenAt;\\n        batch.disabled = disabled;\\n        batch.root = root;\\n        batch.collection = collection;\\n        emit BatchUpdated(batchId, isOpenAt, disabled, root, collection);\\n    }\\n\\n    function readBatch(AppType.State storage state, uint256 batchId)\\n        public\\n        view\\n        returns (\\n            AppType.BatchKind kind,\\n            uint256 isOpenAt,\\n            bool disabled,\\n            bytes32 root\\n        )\\n    {\\n        require(state.batches[batchId].id == batchId, \\\"E001\\\");\\n        return (\\n            state.batches[batchId].kind,\\n            state.batches[batchId].isOpenAt,\\n            state.batches[batchId].disabled,\\n            state.batches[batchId].root\\n        );\\n    }\\n\\n    function excludeNFTLeaf(\\n        AppType.State storage state,\\n        AppType.NFT memory nft,\\n        bool isExcluded\\n    ) public {\\n        require(\\n            msg.sender == state.config.addresses[AppType.AddressConfig.DAO],\\n            \\\"E012\\\"\\n        );\\n\\n        bytes32 leaf = nft.nftLeaf(state);\\n        state.excludedLeaves[leaf] = isExcluded;\\n        emit ExcludedLeaf(leaf, nft.batchId, isExcluded);\\n    }\\n\\n    function excludePassLeaf(\\n        AppType.State storage state,\\n        AppType.Pass memory pass,\\n        bool isExcluded\\n    ) public {\\n        require(\\n            msg.sender == state.config.addresses[AppType.AddressConfig.DAO],\\n            \\\"E012\\\"\\n        );\\n\\n        bytes32 leaf = pass.passLeaf(state);\\n        state.excludedLeaves[leaf] = isExcluded;\\n        emit ExcludedLeaf(leaf, pass.batchId, isExcluded);\\n    }\\n\\n    function authorizeMint(\\n        AppType.State storage state,\\n        AppType.NFT memory nft,\\n        AppType.Pass memory pass,\\n        AppType.Proof memory proof\\n    ) public returns (uint256 newTokenId) {\\n        require(!state.config.bools[AppType.BoolConfig.PAUSED], \\\"E013\\\");\\n\\n        if (!state.config.bools[AppType.BoolConfig.ALLOW_MINT_WITHOUT_PASS]) {\\n            AppType.Batch storage passBatch = state.batches[pass.batchId];\\n\\n            require(\\n                passBatch.id == pass.batchId &&\\n                    passBatch.kind == AppType.BatchKind.PASS &&\\n                    passBatch.isOpenAt <= block.timestamp &&\\n                    !passBatch.disabled,\\n                \\\"E002\\\"\\n            );\\n\\n            bytes32 passLeaf = pass.passLeaf(state);\\n            require(state.usedLeaves[passLeaf] < pass.balance, \\\"E003\\\");\\n\\n            require(proof.pass.verify(passBatch.root, passLeaf), \\\"E004\\\");\\n            require(state.excludedLeaves[passLeaf] == false, \\\"E005\\\");\\n            ++state.usedLeaves[passLeaf];\\n        }\\n\\n        {\\n            AppType.Batch storage nftBatch = state.batches[nft.batchId];\\n\\n            require(\\n                nftBatch.id == nft.batchId &&\\n                    nftBatch.kind == AppType.BatchKind.NFT &&\\n                    nftBatch.isOpenAt <= block.timestamp &&\\n                    !nftBatch.disabled,\\n                \\\"E006\\\"\\n            );\\n\\n            bytes32 nftLeaf = nft.nftLeaf(state);\\n            require(state.usedLeaves[nftLeaf] == 0, \\\"E007\\\");\\n            require(proof.nft.verify(nftBatch.root, nftLeaf), \\\"E008\\\");\\n            require(state.excludedLeaves[nftLeaf] == false, \\\"E009\\\");\\n            ++state.usedLeaves[nftLeaf];\\n        }\\n\\n        uint256 swapAmount = state.tierSwapAmounts[nft.tierId][nft.swapToken];\\n\\n        {\\n            require(swapAmount > 0, \\\"E010\\\");\\n\\n            if (nft.swapToken == address(0)) {\\n                require(msg.value >= swapAmount, \\\"E011\\\");\\n                payable(\\n                    state.config.addresses[AppType.AddressConfig.FEE_WALLET]\\n                ).transfer(swapAmount);\\n            } else {\\n                IERC20(nft.swapToken).transferFrom(\\n                    msg.sender,\\n                    state.config.addresses[AppType.AddressConfig.FEE_WALLET],\\n                    swapAmount\\n                );\\n            }\\n        }\\n\\n        newTokenId = uint256(keccak256(abi.encode(nft.uri)));\\n\\n        emit AuthorizedMint(\\n            nft.batchId,\\n            pass.batchId,\\n            nft.uri,\\n            nft.tierId,\\n            nft.swapToken,\\n            swapAmount,\\n            msg.sender,\\n            newTokenId\\n        );\\n    }\\n}\\n\\n// Error Codes\\n\\n// E001 - Batch not found\\n// E002 - Pass Batch not found\\n// E003 - Pass already used\\n// E004 - Pass not found\\n// E005 - Pass is excluded\\n// E006 - NFT Batch not found\\n// E007 - NFT already Minted\\n// E008 - NFT not found\\n// E009 - NFT is excluded\\n// E010 - swapAmount is 0\\n// E011 - Insufficient swap amount sent to mint\\n// E012 - Only DAO can perform this operation\\n// E013 - Minting is PAUSED\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/AppType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.14;\\n\\nlibrary AppType {\\n    enum BatchKind {\\n        PASS,\\n        NFT\\n    }\\n\\n    enum Model {\\n        BATCH\\n    }\\n\\n    enum AddressConfig {\\n        NONE,\\n        DAO,\\n        FEE_WALLET\\n    }\\n\\n    enum UintConfig {\\n        NONE,\\n        CHAIN_ID\\n    }\\n\\n    enum BoolConfig {\\n        NONE,\\n        ALLOW_MINT_WITHOUT_PASS,\\n        PAUSED\\n    }\\n\\n    enum StringConfig {\\n        NONE,\\n        APP_NAME\\n    }\\n\\n    struct IConfigKey {\\n        AddressConfig addressK;\\n        UintConfig uintK;\\n        BoolConfig boolK;\\n        StringConfig stringK;\\n    }\\n\\n    struct IConfigValue {\\n        address addressV;\\n        uint256 uintV;\\n        bool boolV;\\n        string stringV;\\n    }\\n\\n    struct Config {\\n        mapping(AddressConfig => address) addresses;\\n        mapping(UintConfig => uint256) uints;\\n        mapping(BoolConfig => bool) bools;\\n        mapping(StringConfig => string) strings;\\n    }\\n\\n    struct NFT {\\n        uint256 batchId;\\n        uint256 tierId;\\n        string uri;\\n        address swapToken;\\n        uint96 royaltyPercent;\\n    }\\n\\n    struct Pass {\\n        uint256 batchId;\\n        uint256 balance;\\n    }\\n\\n    struct Proof {\\n        bytes32[] pass;\\n        bytes32[] nft;\\n    }\\n\\n    struct Batch {\\n        BatchKind kind;\\n        uint256 id;\\n        uint256 isOpenAt;\\n        bool disabled;\\n        bytes32 root;\\n        address collection;\\n    }\\n\\n    struct State {\\n        mapping(Model => uint256) id;\\n        mapping(uint256 => Batch) batches;\\n        mapping(bytes32 => bool) excludedLeaves;\\n        mapping(bytes32 => uint256) usedLeaves;\\n        mapping(uint256 => mapping(address => uint256)) tierSwapAmounts;\\n        Config config;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.14;\\n\\nimport \\\"./AppType.sol\\\";\\n\\nlibrary LeafUtils {\\n    function nftLeaf(AppType.NFT memory nft, AppType.State storage state)\\n        public\\n        view\\n        returns (bytes32 leaf)\\n    {\\n        leaf = keccak256(\\n            abi.encodePacked(\\n                nft.batchId,\\n                uint256(AppType.BatchKind.NFT),\\n                nft.uri,\\n                nft.royaltyPercent,\\n                nft.tierId,\\n                state.config.strings[AppType.StringConfig.APP_NAME],\\n                state.config.uints[AppType.UintConfig.CHAIN_ID]\\n            )\\n        );\\n        return leaf;\\n    }\\n\\n    function passLeaf(AppType.Pass memory pass, AppType.State storage state)\\n        public\\n        view\\n        returns (bytes32 leaf)\\n    {\\n        leaf = keccak256(\\n            abi.encodePacked(\\n                pass.batchId,\\n                uint256(AppType.BatchKind.PASS),\\n                msg.sender,\\n                pass.balance,\\n                state.config.strings[AppType.StringConfig.APP_NAME],\\n                state.config.uints[AppType.UintConfig.CHAIN_ID]\\n            )\\n        );\\n        return leaf;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/Utils.sol\": {\r\n        \"LeafUtils\": \"0x6cd30bc4aa428b778a794826f2d66f4c449b0d4c\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftBatchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"passBatchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"nftUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tierId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"swapToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTokenId\",\"type\":\"uint256\"}],\"name\":\"AuthorizedMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum AppType.BatchKind\",\"name\":\"kind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"isOpenAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"BatchCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"isOpenAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"disabled\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"BatchUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"leaf\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExcluded\",\"type\":\"bool\"}],\"name\":\"ExcludedLeaf\",\"type\":\"event\"}]", "ContractName": "BatchFactory", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}