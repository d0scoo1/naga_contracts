{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/usdb/bonds/TradFiBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n\\npragma solidity 0.7.5;\\n\\ninterface IOwnable {\\n    function policy() external view returns (address);\\n\\n    function renounceManagement() external;\\n\\n    function pushManagement( address newOwner_ ) external;\\n\\n    function pullManagement() external;\\n}\\n\\ncontract Ownable is IOwnable {\\n\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor () {\\n        _owner = msg.sender;\\n        emit OwnershipPushed( address(0), _owner );\\n    }\\n\\n    function policy() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require( _owner == msg.sender, \\\"Ownable: caller is not the owner\\\" );\\n        _;\\n    }\\n\\n    modifier onlyDepositor(address _depositor) {\\n        require( _depositor == msg.sender, \\\"caller is not the depositor\\\" );\\n        _;\\n    }\\n\\n    function renounceManagement() public virtual override onlyPolicy() {\\n        emit OwnershipPushed( _owner, address(0) );\\n        _owner = address(0);\\n    }\\n\\n    function pushManagement( address newOwner_ ) public virtual override onlyPolicy() {\\n        require( newOwner_ != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipPushed( _owner, newOwner_ );\\n        _newOwner = newOwner_;\\n    }\\n\\n    function pullManagement() public virtual override {\\n        require( msg.sender == _newOwner, \\\"Ownable: must be new owner to pull\\\");\\n        emit OwnershipPulled( _owner, _newOwner );\\n        _owner = _newOwner;\\n    }\\n}\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\\n\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n}\\n\\nlibrary Address {\\n\\n    function isContract(address account) internal view returns (bool) {\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            if (returndata.length > 0) {\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n    function addressToString(address _address) internal pure returns(string memory) {\\n        bytes32 _bytes = bytes32(uint256(_address));\\n        bytes memory HEX = \\\"0123456789abcdef\\\";\\n        bytes memory _addr = new bytes(42);\\n\\n        _addr[0] = '0';\\n        _addr[1] = 'x';\\n\\n        for(uint256 i = 0; i < 20; i++) {\\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\\n        }\\n\\n        return string(_addr);\\n\\n    }\\n}\\n\\ninterface IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\nabstract contract ERC20 is IERC20 {\\n\\n    using SafeMath for uint256;\\n\\n    // TODO comment actual hash value.\\n    bytes32 constant private ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256( \\\"ERC20Token\\\" );\\n\\n    mapping (address => uint256) internal _balances;\\n\\n    mapping (address => mapping (address => uint256)) internal _allowances;\\n\\n    uint256 internal _totalSupply;\\n\\n    string internal _name;\\n\\n    string internal _symbol;\\n\\n    uint8 internal _decimals;\\n\\n    constructor (string memory name_, string memory symbol_, uint8 decimals_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = decimals_;\\n    }\\n\\n    function name() public view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public view override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account_, uint256 ammount_) internal virtual {\\n        require(account_ != address(0), \\\"ERC20: mint to the zero address\\\");\\n        _beforeTokenTransfer(address( this ), account_, ammount_);\\n        _totalSupply = _totalSupply.add(ammount_);\\n        _balances[account_] = _balances[account_].add(ammount_);\\n        emit Transfer(address( this ), account_, ammount_);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _beforeTokenTransfer( address from_, address to_, uint256 amount_ ) internal virtual { }\\n}\\n\\ninterface IERC2612Permit {\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\\nlibrary Counters {\\n    using SafeMath for uint256;\\n\\n    struct Counter {\\n\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        counter._value += 1;\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        counter._value = counter._value.sub(1);\\n    }\\n}\\n\\nabstract contract ERC20Permit is ERC20, IERC2612Permit {\\n    using Counters for Counters.Counter;\\n\\n    mapping(address => Counters.Counter) private _nonces;\\n\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    bytes32 public DOMAIN_SEPARATOR;\\n\\n    constructor() {\\n        uint256 chainID;\\n        assembly {\\n            chainID := chainid()\\n        }\\n\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name())),\\n                keccak256(bytes(\\\"1\\\")), // Version\\n                chainID,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual override {\\n        require(block.timestamp <= deadline, \\\"Permit: expired deadline\\\");\\n\\n        bytes32 hashStruct =\\n        keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, amount, _nonces[owner].current(), deadline));\\n\\n        bytes32 _hash = keccak256(abi.encodePacked(uint16(0x1901), DOMAIN_SEPARATOR, hashStruct));\\n\\n        address signer = ecrecover(_hash, v, r, s);\\n        require(signer != address(0) && signer == owner, \\\"ZeroSwapPermit: Invalid signature\\\");\\n\\n        _nonces[owner].increment();\\n        _approve(owner, spender, amount);\\n    }\\n\\n    function nonces(address owner) public view override returns (uint256) {\\n        return _nonces[owner].current();\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\nlibrary FullMath {\\n    function fullMul(uint256 x, uint256 y) private pure returns (uint256 l, uint256 h) {\\n        uint256 mm = mulmod(x, y, uint256(-1));\\n        l = x * y;\\n        h = mm - l;\\n        if (mm < l) h -= 1;\\n    }\\n\\n    function fullDiv(\\n        uint256 l,\\n        uint256 h,\\n        uint256 d\\n    ) private pure returns (uint256) {\\n        uint256 pow2 = d & -d;\\n        d /= pow2;\\n        l /= pow2;\\n        l += h * ((-pow2) / pow2 + 1);\\n        uint256 r = 1;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        r *= 2 - d * r;\\n        return l * r;\\n    }\\n\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 d\\n    ) internal pure returns (uint256) {\\n        (uint256 l, uint256 h) = fullMul(x, y);\\n        uint256 mm = mulmod(x, y, d);\\n        if (mm > l) h -= 1;\\n        l -= mm;\\n        require(h < d, 'FullMath::mulDiv: overflow');\\n        return fullDiv(l, h, d);\\n    }\\n}\\n\\nlibrary FixedPoint {\\n\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    struct uq144x112 {\\n        uint256 _x;\\n    }\\n\\n    uint8 private constant RESOLUTION = 112;\\n    uint256 private constant Q112 = 0x10000000000000000000000000000;\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000;\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\n\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n\\n    function decode112with18(uq112x112 memory self) internal pure returns (uint) {\\n\\n        return uint(self._x) / 5192296858534827;\\n    }\\n\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\n\\n        if (numerator <= uint144(-1)) {\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        } else {\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\\n            return uq112x112(uint224(result));\\n        }\\n    }\\n}\\n\\n// Info for bond holder\\nstruct Bond {\\n    uint payout; // USDB to be paid\\n    uint vesting; // Blocks left to vest\\n    uint lastBlock; // Last interaction\\n    uint pricePaid; // In DAI, for front end viewing\\n    uint vestingSeconds; // Blocks left to vest\\n    uint lastTimestamp; // Last interaction\\n}\\n\\nlibrary IterableMapping {\\n\\n\\n    // Iterable mapping from address to uint;\\n    struct Map {\\n        address[] keys;\\n        mapping(address => Bond[]) values;\\n        mapping(address => uint) indexOf;\\n        mapping(address => bool) inserted;\\n    }\\n\\n    function get(Map storage map, address key, uint index) public view returns (Bond storage) {\\n        return map.values[key][index];\\n    }\\n\\n    function getKeyAtIndex(Map storage map, uint index) public view returns (address) {\\n        return map.keys[index];\\n    }\\n\\n    function size(Map storage map) public view returns (uint) {\\n        return map.keys.length;\\n    }\\n\\n    function set(\\n        Map storage map,\\n        address key,\\n        Bond storage val\\n    ) public {\\n        if (map.inserted[key]) {\\n            map.values[key].push(val);\\n\\n        } else {\\n            map.inserted[key] = true;\\n\\n            map.values[key].push(val);\\n            map.indexOf[key] = map.keys.length;\\n            map.keys.push(key);\\n        }\\n    }\\n\\n    function remove(Map storage map, address key) public {\\n        if (!map.inserted[key]) {\\n            return;\\n        }\\n\\n        delete map.inserted[key];\\n        delete map.values[key];\\n\\n        uint index = map.indexOf[key];\\n        uint lastIndex = map.keys.length - 1;\\n        address lastKey = map.keys[lastIndex];\\n\\n        map.indexOf[lastKey] = index;\\n        delete map.indexOf[key];\\n\\n        map.keys[index] = lastKey;\\n        map.keys.pop();\\n    }\\n}\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\\ninterface ITreasury {\\n    function deposit( uint _amount, address _token, uint _profit ) external returns ( uint send_ );\\n    function valueOf( address _token, uint _amount ) external view returns ( uint value_ );\\n    function mintRewards( address _recipient, uint _amount ) external;\\n}\\n\\ninterface IBondCalculator {\\n    function valuation( address _LP, uint _amount ) external view returns ( uint );\\n    function markdown( address _LP ) external view returns ( uint );\\n}\\n\\ninterface IStaking {\\n    function stake( uint _amount, address _recipient ) external returns ( bool );\\n}\\n\\ninterface IStakingHelper {\\n    function stake( uint _amount, address _recipient ) external;\\n}\\n\\ninterface IMintable {\\n    function mint(address to, uint256 amount) external;\\n}\\n\\ninterface IBurnable {\\n    function burn(uint256 amount) external;\\n}\\n\\ninterface IUsdbMinter {\\n    function getMarketPrice() external view returns (uint);\\n}\\n\\n/// @notice Traditional Finance bond\\n/// @dev this is ISO bond - x% discount with 6 weeks vesting\\ncontract TradFiBondDepository is Ownable, ReentrancyGuard {\\n\\n    using FixedPoint for *;\\n    using SafeERC20 for IERC20;\\n    using SafeMath for uint;\\n    using IterableMapping for IterableMapping.Map;\\n\\n\\n\\n    /* ======== EVENTS ======== */\\n\\n    event BondCreated( uint deposit, uint indexed payout, uint indexed expiresTimestamp, uint expiresBlock, uint indexed priceInUSD );\\n    event BondRedeemed( address indexed recipient, uint payout, uint remainingSeconds, uint remainingBlocks );\\n    event BondCancelled( address indexed recipient, uint index, uint deposit, uint possiblePayout, uint forfeited);\\n\\n\\n\\n\\n    /* ======== STATE VARIABLES ======== */\\n\\n    address public immutable FHM; // token given as payment for bond\\n    address public immutable USDB; // USDB\\n    address public immutable principle; // token used to create bond\\n    address public immutable treasury; // mints FHM when receives principle\\n    address public immutable DAO; // receives profit share from bond\\n    address public immutable usdbMinter; // receives profit share from bond\\n\\n    Terms public terms; // stores terms for new bonds\\n\\n    IterableMapping.Map private depositors; // stores depositors bond information\\n\\n    uint public totalDebt; // total value of outstanding bonds; used for pricing\\n    uint public lastDecay; // reference block for debt decay\\n\\n    bool public useWhitelist;\\n    bool public useCircuitBreaker;\\n    mapping(address => bool) public whitelist;\\n    SoldBonds[] public soldBondsInHour;\\n    Bond public _bondInfo;\\n    uint public usersCount;\\n    uint public limitBondCount; //limit bond counts users can deposit\\n\\n    /* ======== STRUCTS ======== */\\n\\n    // Info for creating new bonds\\n    struct Terms {\\n        uint vestingTermSeconds; // in seconds\\n        uint vestingTerm; // safeguard, use some vestingTermSeconds/2 in blocks\\n        uint discount; // discount in in thousandths of a % i.e. 5000 = 5%\\n        uint maxPayout; // in thousandths of a %. i.e. 500 = 0.5%\\n        uint fee; // as % of bond payout, in hundreds. ( 500 = 5% = 0.05 for every 1 paid)\\n        uint maxDebt; // 9 decimal debt ratio, max % total supply created as debt\\n        uint soldBondsLimitUsd; //\\n        uint prematureReturnRate; // as % of premature return rate, in hundreds. ( 9500 = 95% = 0.95)\\n    }\\n\\n    struct SoldBonds {\\n        uint timestampFrom;\\n        uint timestampTo;\\n        uint payoutInUsd;\\n    }\\n\\n    /* ======== INITIALIZATION ======== */\\n\\n    constructor (\\n        address _FHM,\\n        address _USDB,\\n        address _principle,\\n        address _treasury,\\n        address _DAO,\\n        address _usdbMinter\\n    ) {\\n        require( _FHM != address(0) );\\n        FHM = _FHM;\\n        require( _USDB != address(0) );\\n        USDB = _USDB;\\n        require( _principle != address(0) );\\n        principle = _principle;\\n        require( _treasury != address(0) );\\n        treasury = _treasury;\\n        require( _DAO != address(0) );\\n        DAO = _DAO;\\n        require( _usdbMinter != address(0) );\\n        usdbMinter = _usdbMinter;\\n        useWhitelist = true;\\n        whitelist[msg.sender] = true;\\n        usersCount = 0;\\n    }\\n\\n    /**\\n     *  @notice initializes bond parameters\\n     *  @param _vestingTermSeconds uint\\n     *  @param _vestingTerm uint\\n     *  @param _discount uint\\n     *  @param _maxPayout uint\\n     *  @param _fee uint\\n     *  @param _maxDebt uint\\n     *  @param _initialDebt uint\\n     *  @param _soldBondsLimitUsd uint\\n     *  @param _useWhitelist bool\\n     *  @param _useCircuitBreaker bool\\n     *  @param _prematureReturnRate uint\\n     *  @param _limitBondCount uint\\n     */\\n    function initializeBondTerms(\\n        uint _vestingTermSeconds,\\n        uint _vestingTerm,\\n        uint _discount,\\n        uint _maxPayout,\\n        uint _fee,\\n        uint _maxDebt,\\n        uint _initialDebt,\\n        uint _soldBondsLimitUsd,\\n        bool _useWhitelist,\\n        bool _useCircuitBreaker,\\n        uint _prematureReturnRate,\\n        uint _limitBondCount\\n    ) external onlyPolicy() {\\n        terms = Terms ({\\n        vestingTermSeconds: _vestingTermSeconds,\\n        vestingTerm: _vestingTerm,\\n        discount: _discount,\\n        maxPayout: _maxPayout,\\n        fee: _fee,\\n        maxDebt: _maxDebt,\\n        soldBondsLimitUsd: _soldBondsLimitUsd,\\n        prematureReturnRate: _prematureReturnRate\\n        });\\n        totalDebt = _initialDebt;\\n        lastDecay = block.number;\\n        useWhitelist = _useWhitelist;\\n        useCircuitBreaker = _useCircuitBreaker;\\n        limitBondCount = _limitBondCount;\\n    }\\n\\n\\n\\n\\n    /* ======== POLICY FUNCTIONS ======== */\\n\\n    enum PARAMETER { VESTING, PAYOUT, FEE, DEBT, VESTING_SECONDS }\\n    /**\\n     *  @notice set parameters for new bonds\\n     *  @param _parameter PARAMETER\\n     *  @param _input uint\\n     */\\n    function setBondTerms ( PARAMETER _parameter, uint _input ) external onlyPolicy() {\\n        if ( _parameter == PARAMETER.VESTING ) { // 0\\n            require( _input >= 10000, \\\"Vesting must be longer than 10000 blocks\\\" );\\n            terms.vestingTerm = _input;\\n        } else if ( _parameter == PARAMETER.PAYOUT ) { // 1\\n            require( _input <= 1000, \\\"Payout cannot be above 1 percent\\\" );\\n            terms.maxPayout = _input;\\n        } else if ( _parameter == PARAMETER.FEE ) { // 2\\n            require( _input <= 10000, \\\"DAO fee cannot exceed payout\\\" );\\n            terms.fee = _input;\\n        } else if ( _parameter == PARAMETER.DEBT ) { // 3\\n            terms.maxDebt = _input;\\n        } else if ( _parameter == PARAMETER.VESTING_SECONDS ) { // 4\\n            terms.vestingTermSeconds = _input;\\n        }\\n    }\\n\\n    /* ======== USER FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice deposit bond\\n     *  @param _amount uint\\n     *  @param _maxPrice uint\\n     *  @param _depositor address\\n     *  @return uint\\n     */\\n    function deposit(\\n        uint _amount,\\n        uint _maxPrice,\\n        address _depositor\\n    ) external nonReentrant returns ( uint ) {\\n        require( _depositor != address(0), \\\"Invalid address\\\" );\\n        //check the user's bond count\\n        Bond[] memory _userBondInfo = depositors.values[_depositor];\\n        require(_userBondInfo.length < limitBondCount, \\\"Exceed the limit amounts of bond\\\");\\n        // allow only whitelisted contracts\\n        if (useWhitelist) require(whitelist[msg.sender], \\\"SENDER_IS_NOT_IN_WHITELIST\\\");\\n\\n        decayDebt();\\n        require( totalDebt <= terms.maxDebt, \\\"Max capacity reached\\\" );\\n\\n        uint priceInUSD = bondPriceInUSD(); // Stored in bond info\\n        uint nativePrice = bondPrice();\\n\\n        require( _maxPrice >= nativePrice, \\\"Slippage limit: more than max price\\\" ); // slippage protection\\n\\n        uint value = ITreasury( treasury ).valueOf( principle, _amount ).mul(10 ** 9);\\n        uint payout = payoutFor( value ); // payout to bonder is computed\\n\\n        require( payout >= 10_000_000_000_000_000, \\\"Bond too small\\\" ); // must be > 0.01 USDB ( underflow protection )\\n        require( payout <= maxPayout(), \\\"Bond too large\\\"); // size protection because there is no slippage\\n        require( !circuitBreakerActivated(payout), \\\"CIRCUIT_BREAKER_ACTIVE\\\"); //\\n\\n        uint payoutInFhm = payoutInFhmFor(payout);\\n\\n        // profits are calculated\\n        uint fee = payoutInFhm.mul( terms.fee ).div( 10000 );\\n\\n        IERC20( principle ).safeTransferFrom( msg.sender, address( DAO ), _amount );\\n        ITreasury( treasury ).mintRewards( address(this), payoutInFhm.add(fee));\\n\\n\\n        // mint USDB with guaranteed discount\\n        IMintable(USDB).mint( address(this), payout);\\n\\n        // burn whatever FHM got from treasury in current market price\\n        IBurnable( FHM ).burn( payoutInFhm ) ;\\n\\n        if ( fee != 0 ) { // fee is transferred to dao\\n            IERC20( FHM ).safeTransfer( DAO, fee );\\n        }\\n\\n        // total debt is increased\\n        totalDebt = totalDebt.add( value );\\n\\n        // update sold bonds\\n        if (useCircuitBreaker) updateSoldBonds(payout);\\n\\n        // depositor info is stored\\n        _bondInfo = Bond({\\n            payout: payout,\\n            vestingSeconds: terms.vestingTermSeconds,\\n            lastTimestamp: block.timestamp,\\n            vesting: terms.vestingTerm,\\n            lastBlock: block.number,\\n            pricePaid: priceInUSD\\n        });\\n\\n        // new user bonding\\n        if(!depositors.inserted[_depositor]) {\\n            usersCount ++;\\n        }\\n        depositors.set(_depositor, _bondInfo );\\n\\n        // indexed events are emitted\\n        emit BondCreated( _amount, payout, block.timestamp.add(terms.vestingTermSeconds), block.number.add( terms.vestingTerm ), priceInUSD );\\n\\n        return payout;\\n    }\\n\\n    function redeemAll(uint _from, uint _to) public returns (uint[] memory) {\\n        require(_from >= 0 && _from < depositors.size(), \\\"`from` is invalid\\\");\\n        require(_to >= 0 && _to <= depositors.size(), \\\"`to` is invalid\\\");\\n        require(_from < _to, \\\"`to` should be equal and greater than `from`\\\");\\n\\n        uint[] memory _removedIndices;\\n        uint _counter = 0;\\n        for (uint i = _from; i < _to; i++) {\\n            address _recipient = depositors.getKeyAtIndex(i);\\n            if (i > depositors.size()) {\\n                break;\\n            }\\n            if (redeemOne(_recipient)) {\\n                _removedIndices[_counter++] = i;\\n                depositors.remove(_recipient);\\n            }\\n        }\\n        return _removedIndices;\\n    }\\n\\n    function redeem(uint[] memory _newIndices) public returns (uint[] memory) {\\n        require(_newIndices.length > 0, \\\"Redeems unavailable\\\");\\n\\n        uint[] memory _removedIndices;\\n        uint _counter = 0;\\n        for (uint i = 0; i <= _newIndices.length; i ++) {\\n            address _recipient = depositors.getKeyAtIndex(_newIndices[i]);\\n            if (redeemOne(_recipient)) {\\n                _removedIndices[_counter++] = i;\\n                depositors.remove(_recipient);\\n            }\\n        }\\n        return _removedIndices;\\n    }\\n\\n    function redeemOne(address _depositor) public returns (bool _toDelete) {\\n        Bond[] storage _userBondInfo = depositors.values[_depositor];\\n        require(_userBondInfo.length > 0, \\\"There is no bonding\\\");\\n\\n        uint _finalAmount = 0;\\n        uint _length = _userBondInfo.length;\\n\\n        uint index = 0;\\n        while(index < _length) {\\n            uint percentVested = percentVestedFor(_depositor, index); // (seconds since last interaction / vesting term remaining)\\n            uint percentVestedBlocks = percentVestedBlocksFor(_depositor, index); // (blocks since last interaction / vesting term remaining)\\n\\n            if (percentVested >= 10000 && percentVestedBlocks >= 10000) {\\n                Bond memory removeMe;\\n                removeMe = _userBondInfo[index];\\n                _userBondInfo[index] = _userBondInfo[_length - 1];\\n                _userBondInfo[_length - 1] = removeMe;\\n                _userBondInfo.pop();\\n                _finalAmount = _finalAmount.add(removeMe.payout);\\n                _length --;\\n            } else {\\n                index ++;\\n            }\\n        }\\n        if (_length == 0) {\\n            _toDelete = true;\\n        }\\n\\n        if (_finalAmount > 0) {\\n            IERC20(USDB).transfer(_depositor, _finalAmount);\\n            emit BondRedeemed(_depositor, _finalAmount, 0, 0);\\n        }\\n\\n        return _toDelete;\\n    }\\n\\n    /**\\n     *  @notice returns asset when depositor wants to cancel bond\\n     *  @param _depositor address\\n     *  @param index uint\\n     *  @return forfeited uint\\n     */\\n    function cancelBond( address _depositor, uint index ) public onlyDepositor(_depositor) returns (uint forfeited) {\\n        Bond[] storage infos = depositors.values[_depositor];\\n        uint _length = infos.length;\\n        require(index < _length, \\\"INDEX_OUT_OF_BOUNDS\\\");\\n\\n        uint percentVested = percentVestedFor( _depositor, index );\\n        require( percentVested < 10000, \\\"Current bond is already finished.\\\" );\\n\\n        Bond storage info = infos[index];\\n        uint possiblePayout = info.payout;\\n        uint _deposit = possiblePayout.mul(info.pricePaid).div(1e18);\\n        forfeited = _deposit.mul(terms.prematureReturnRate).div(10000);\\n\\n        require( _deposit >= forfeited, \\\"prematureReturnRate is too big.\\\" );\\n\\n        uint remainingBalance = possiblePayout.sub(forfeited);\\n\\n        if (_length >= 2 && index != _length - 1) {\\n            infos[index] = infos[_length - 1];\\n            infos[_length - 1] = info;\\n            infos.pop();\\n        } else if (_length >= 2 && index == _length - 1) {\\n            infos.pop();\\n        } else {\\n            depositors.remove(_depositor);\\n        }\\n\\n        IERC20( USDB ).transfer(_depositor, forfeited);\\n        IERC20( USDB ).transfer(DAO, remainingBalance);\\n\\n        emit BondCancelled(_depositor, index, _deposit, possiblePayout, forfeited);\\n    }\\n\\n\\n    /**\\n     *  @notice return bond info\\n     *  @param _depositor address\\n     *  @param index uint\\n     *  @return payout uint\\n     *  @return vestingSeconds uint\\n     *  @return lastTimestamp uint\\n     *  @return vesting uint\\n     *  @return lastBlock uint\\n     *  @return pricePaid uint\\n     */\\n    function bondInfo(address _depositor, uint index) public view returns ( uint payout, uint vestingSeconds, uint lastTimestamp, uint vesting,uint lastBlock,uint pricePaid ) {\\n        Bond memory info = depositors.get(_depositor, index);\\n        payout = info.payout;\\n        vestingSeconds = info.vestingSeconds;\\n        lastTimestamp = info.lastTimestamp;\\n        vesting = info.vesting;\\n        lastBlock = info.lastBlock;\\n        pricePaid = info.pricePaid;\\n    }\\n\\n    /* ======== INTERNAL HELPER FUNCTIONS ======== */\\n\\n    function modifyWhitelist(address user, bool add) external onlyPolicy {\\n        if (add) {\\n            require(!whitelist[user], \\\"ALREADY_IN_WHITELIST\\\");\\n            whitelist[user] = true;\\n        } else {\\n            require(whitelist[user], \\\"NOT_IN_WHITELIST\\\");\\n            delete whitelist[user];\\n        }\\n    }\\n\\n    function updateSoldBonds(uint _payout) internal {\\n        uint length = soldBondsInHour.length;\\n        if (length == 0) {\\n            soldBondsInHour.push(SoldBonds({\\n            timestampFrom: block.timestamp,\\n            timestampTo: block.timestamp + 1 hours,\\n            payoutInUsd: _payout\\n            }));\\n            return;\\n        }\\n\\n        SoldBonds storage soldBonds = soldBondsInHour[length - 1];\\n        // update in existing interval\\n        if (soldBonds.timestampFrom < block.timestamp && soldBonds.timestampTo >= block.timestamp) {\\n            soldBonds.payoutInUsd = soldBonds.payoutInUsd.add(_payout);\\n        } else {\\n            // create next interval if its continuous\\n            uint nextTo = soldBonds.timestampTo + 1 hours;\\n            if (block.timestamp <= nextTo) {\\n                soldBondsInHour.push(SoldBonds({\\n                timestampFrom: soldBonds.timestampTo,\\n                timestampTo: nextTo,\\n                payoutInUsd: _payout\\n                }));\\n            } else {\\n                soldBondsInHour.push(SoldBonds({\\n                timestampFrom: block.timestamp,\\n                timestampTo: block.timestamp + 1 hours,\\n                payoutInUsd: _payout\\n                }));\\n            }\\n        }\\n    }\\n\\n    function circuitBreakerCurrentPayout() public view returns (uint _amount) {\\n        if (soldBondsInHour.length == 0) return 0;\\n\\n        uint max = 0;\\n        if (soldBondsInHour.length >= 24) max = soldBondsInHour.length - 24;\\n\\n        uint to = block.timestamp;\\n        uint from = to - 24 hours;\\n        for (uint i = max; i < soldBondsInHour.length; i++) {\\n            SoldBonds memory soldBonds = soldBondsInHour[i];\\n            if (soldBonds.timestampFrom >= from && soldBonds.timestampFrom <= to) {\\n                _amount = _amount.add(soldBonds.payoutInUsd);\\n            }\\n        }\\n\\n        return _amount;\\n    }\\n\\n    function circuitBreakerActivated(uint payout) public view returns (bool) {\\n        if (!useCircuitBreaker) return false;\\n        payout = payout.add(circuitBreakerCurrentPayout());\\n        return payout > terms.soldBondsLimitUsd;\\n    }\\n\\n    function getMarketPrice() public view returns (uint _marketPrice) {\\n        _marketPrice = IUsdbMinter(usdbMinter).getMarketPrice();\\n    }\\n\\n    /**\\n     *  @notice reduce total debt\\n     */\\n    function decayDebt() internal {\\n        totalDebt = totalDebt.sub( debtDecay() );\\n        lastDecay = block.number;\\n    }\\n\\n\\n\\n\\n    /* ======== VIEW FUNCTIONS ======== */\\n\\n    /**\\n     *  @notice determine maximum bond size\\n     *  @return uint\\n     */\\n    function maxPayout() public view returns ( uint ) {\\n        return IERC20(USDB).totalSupply().mul( terms.maxPayout ).div( 100000 );\\n    }\\n\\n    /**\\n     *  @notice calculate interest due for new bond\\n     *  @param _value uint\\n     *  @return uint\\n     */\\n    function payoutFor( uint _value ) public view returns ( uint ) {\\n        return FixedPoint.fraction( _value, bondPriceInUSD() ).decode112with18();\\n    }\\n\\n    function payoutInFhmFor( uint _usdbValue) public view returns ( uint ) {\\n        return FixedPoint.fraction( _usdbValue, getMarketPrice()).decode112with18().div( 1e16 ).div(1e9);\\n    }\\n\\n    /**\\n    *  @notice converts bond price to DAI value\\n     *  @return price_ uint\\n     */\\n    function bondPriceInUSD() public view returns ( uint price_ ) {\\n        uint _originalPrice = 1;\\n        _originalPrice = _originalPrice.mul( 10 ** 18 );\\n\\n        uint _discount = _originalPrice.mul(terms.discount).div(10 ** 5);\\n        price_ = _originalPrice.sub(_discount);\\n    }\\n\\n\\n    /**\\n     *  @notice calculate current bond premium\\n     *  @return price_ uint\\n     */\\n    function bondPrice() public view returns ( uint price_ ) {\\n       return bondPriceInUSD().div(1e16);\\n    }\\n\\n    /**\\n     *  @notice calculate current ratio of debt to USDB supply\\n     *  @return debtRatio_ uint\\n     */\\n    function debtRatio() public view returns ( uint debtRatio_ ) {\\n        uint supply = IERC20(USDB).totalSupply();\\n        debtRatio_ = FixedPoint.fraction(\\n            currentDebt().mul( 1e9 ),\\n            supply\\n        ).decode112with18().div( 1e18 );\\n    }\\n\\n    /**\\n     *  @notice debt ratio in same terms for reserve or liquidity bonds\\n     *  @return uint\\n     */\\n    function standardizedDebtRatio() external view returns ( uint ) {\\n        return debtRatio();\\n    }\\n\\n    /**\\n     *  @notice calculate debt factoring in decay\\n     *  @return uint\\n     */\\n    function currentDebt() public view returns ( uint ) {\\n        return totalDebt.sub( debtDecay() );\\n    }\\n\\n    /**\\n     *  @notice amount to decay total debt by\\n     *  @return decay_ uint\\n     */\\n    function debtDecay() public view returns ( uint decay_ ) {\\n        uint blocksSinceLast = block.number.sub( lastDecay );\\n        decay_ = totalDebt.mul( blocksSinceLast ).div( terms.vestingTerm );\\n        if ( decay_ > totalDebt ) {\\n            decay_ = totalDebt;\\n        }\\n    }\\n\\n\\n    /**\\n     *  @notice calculate how far into vesting a depositor is\\n     *  @param _depositor address\\n     *  @param index uint\\n     *  @return percentVested_ uint\\n     */\\n    function percentVestedFor( address _depositor, uint index ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = depositors.get(_depositor, index);\\n        uint secondsSinceLast = block.timestamp.sub( bond.lastTimestamp );\\n        uint vestingSeconds = bond.vestingSeconds;\\n\\n        if ( vestingSeconds > 0 ) {\\n            percentVested_ = secondsSinceLast.mul( 10000 ).div(vestingSeconds);\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    function percentVestedBlocksFor( address _depositor, uint index ) public view returns ( uint percentVested_ ) {\\n        Bond memory bond = depositors.get(_depositor, index);\\n        uint blocksSinceLast = block.number.sub( bond.lastBlock );\\n        uint vesting = bond.vesting;\\n\\n        if ( vesting > 0 ) {\\n            percentVested_ = blocksSinceLast.mul( 10000 ).div( vesting );\\n        } else {\\n            percentVested_ = 0;\\n        }\\n    }\\n\\n    /**\\n     *  @notice users' bond length\\n     *  @param _depositor address\\n     *  @return  uint\\n     */\\n     function bondlength( address _depositor) external view returns (uint) {\\n        return depositors.values[_depositor].length;\\n     }\\n    /**\\n     *  @notice calculate amount of FHM available for claim by depositor\\n     *  @param _depositor address\\n     *  @param index uint\\n     *  @return pendingPayout_ uint\\n     */\\n    function pendingPayoutFor( address _depositor, uint index ) external view returns ( uint pendingPayout_ ) {\\n        uint percentVested = percentVestedFor( _depositor, index );\\n        uint percentVestedBlocks = percentVestedBlocksFor( _depositor, index );\\n        uint payout = depositors.get(_depositor, index).payout;\\n\\n        if ( percentVested >= 10000 && percentVestedBlocks >= 10000) {\\n            pendingPayout_ = payout;\\n        } else {\\n            pendingPayout_ = 0;\\n        }\\n    }\\n\\n    /* ======= AUXILLIARY ======= */\\n\\n    /**\\n     *  @notice allow anyone to send lost tokens (excluding principle or FHM) to the DAO\\n     *  @return bool\\n     */\\n    function recoverLostToken( address _token ) external returns ( bool ) {\\n        require( _token != FHM );\\n        require( _token != USDB);\\n        require( _token != principle );\\n        IERC20( _token ).safeTransfer( DAO, IERC20( _token ).balanceOf( address(this) ) );\\n        return true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "IterableMapping", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}