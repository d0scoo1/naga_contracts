{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function trySub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n\r\n    function tryMul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function tryMod(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (bool, uint256)\r\n    {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n\r\n    function mod(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    function getApproved(uint256 tokenId)\r\n        external\r\n        view\r\n        returns (address operator);\r\n\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\nlibrary EnumerableSet {\r\n    struct Set {\r\n        bytes32[] _values;\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n            set._values.pop();\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _contains(Set storage set, bytes32 value)\r\n        private\r\n        view\r\n        returns (bool)\r\n    {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    function _at(Set storage set, uint256 index)\r\n        private\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return set._values[index];\r\n    }\r\n\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    function remove(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    function contains(Bytes32Set storage set, bytes32 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(Bytes32Set storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    function values(Bytes32Set storage set)\r\n        internal\r\n        view\r\n        returns (bytes32[] memory)\r\n    {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function remove(AddressSet storage set, address value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function contains(AddressSet storage set, address value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(AddressSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    function values(AddressSet storage set)\r\n        internal\r\n        view\r\n        returns (address[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    function remove(UintSet storage set, uint256 value)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    function contains(UintSet storage set, uint256 value)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    function at(UintSet storage set, uint256 index)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    function values(UintSet storage set)\r\n        internal\r\n        view\r\n        returns (uint256[] memory)\r\n    {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n    address private _coOwner;\r\n\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function coOwner() public view virtual returns (address) {\r\n        return _coOwner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(\r\n            owner() == _msgSender() || coOwner() == _msgSender(),\r\n            \"Ownable: caller is not the owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function setCoOwner(address newCoOwner) external {\r\n        _coOwner = newCoOwner;\r\n    }\r\n}\r\n\r\ncontract NFTStaking is Ownable {\r\n    using SafeMath for uint256;\r\n    using Counters for Counters.Counter;\r\n    using EnumerableSet for EnumerableSet.UintSet;\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n    EnumerableSet.AddressSet private blacklisted;\r\n\r\n    IERC20 public DurhamInuToken;\r\n    bool public isPaused = false;\r\n\r\n    EnumerableSet.AddressSet private allowedNfts;\r\n\r\n    struct StakedNft {\r\n        uint256 nftId;\r\n        address nftAddress;\r\n    }\r\n    struct StakeItem {\r\n        uint256 stakedTokens;\r\n        StakedNft stakedNft;\r\n        EnumerableSet.UintSet raffleIds;\r\n        bool isStaked;\r\n        uint256 lastUpdated;\r\n    }\r\n\r\n    mapping(address => StakeItem) private currentStakeInfo;\r\n    mapping(uint256 => address) public raffleEntries;\r\n    EnumerableSet.UintSet private removedRaffleIds;\r\n\r\n    EnumerableSet.AddressSet private stakedAddresses;\r\n\r\n    Counters.Counter private raffleIds;\r\n\r\n    uint256 public minToken = 1e5 * 10**18; // 100K tokens, 1 entry per minimum tokens\r\n    uint256 public maxQty = 10; // qty * minToken\r\n\r\n    uint8 public entryPerMinToken = 1;\r\n    uint8 public entryPerNft = 5;\r\n\r\n    struct PrizeItem {\r\n        bool isTangible;\r\n        string name;\r\n        string desc;\r\n        string imageUrl;\r\n        uint256 ethReward;\r\n        uint256 requiredPoints;\r\n    }\r\n\r\n    mapping(uint256 => PrizeItem) private prizeItems;\r\n    uint256 private prizeLength;\r\n\r\n    struct ClaimedHistoryItem {\r\n        address userAddress;\r\n        string email;\r\n        bool isTangible;\r\n        string name;\r\n        string desc;\r\n        uint256 ethReward;\r\n        uint256 requiredPoints;\r\n        uint256 timestamp;\r\n    }\r\n    Counters.Counter private claimedHistoryIds;\r\n    mapping(uint256 => ClaimedHistoryItem) private claimedHistoryMap;\r\n    mapping(address => uint256[]) private userClaimedIds;\r\n\r\n    struct WinnerHistoryItem {\r\n        address userAddress;\r\n        uint256 rewardPoints;\r\n        uint256 timestamp;\r\n    }\r\n    mapping(uint256 => WinnerHistoryItem) private WinnerHistories;\r\n    Counters.Counter private winnerIds;\r\n\r\n    mapping(address => uint256) private rewardPointBalance;\r\n\r\n    Counters.Counter public totalTangibleClaims;\r\n    Counters.Counter public totalNonTangibleClaims;\r\n    struct Staker {\r\n        address userAddress;\r\n        uint256 stakedTokens;\r\n        uint256 nftId;\r\n        address nftAddress;\r\n        uint256 noOfEntries;\r\n        bool isStaked;\r\n        uint256 lastUpdated;\r\n    }\r\n\r\n    event StakeTokens(address _address, uint256 _tokenAmount);\r\n    event StakeNFT(address _address, uint256 _tokenId, uint256 _tokenAddress);\r\n    event UnStake(address _address);\r\n    event ClaimPrize(address _address, uint256 _prizeItem);\r\n\r\n    constructor(address _durhamInuTokenAddress, address[] memory _allowedNfts) {\r\n        DurhamInuToken = IERC20(_durhamInuTokenAddress);\r\n\r\n        for (uint256 i = 0; i < _allowedNfts.length; i++) {\r\n            allowedNfts.add(_allowedNfts[i]);\r\n        }\r\n    }\r\n\r\n    function setEntryPerNFT(uint8 _entryPerNFT) external onlyOwner {\r\n        require(_entryPerNFT > 0);\r\n        entryPerNft = _entryPerNFT;\r\n    }\r\n\r\n    function setAllowableNFts(address[] calldata _nftAddress, bool _isAllowed)\r\n        external\r\n        onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < _nftAddress.length; i++) {\r\n            if (_isAllowed && !allowedNfts.contains(_nftAddress[i])) {\r\n                allowedNfts.add(_nftAddress[i]);\r\n            } else if (!_isAllowed && allowedNfts.contains(_nftAddress[i])) {\r\n                allowedNfts.remove(_nftAddress[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function setTokenStakeSettings(\r\n        uint256 _minToken,\r\n        uint256 _maxQty,\r\n        uint8 _entryPerMinToken\r\n    ) external onlyOwner {\r\n        require(_minToken > 0 && _maxQty > 0 && _entryPerMinToken > 0);\r\n        minToken = _minToken;\r\n        maxQty = _maxQty;\r\n        entryPerMinToken = _entryPerMinToken;\r\n    }\r\n\r\n    function clearAndSetPrizes(PrizeItem[] calldata _prizeItems)\r\n        external\r\n        onlyOwner\r\n    {\r\n        prizeLength = _prizeItems.length;\r\n        for (uint256 x = 0; x < prizeLength; x++) {\r\n            if (_prizeItems[x].isTangible) {\r\n                require(\r\n                    _prizeItems[x].ethReward == 0,\r\n                    \"Durham_Inu_Staking: ETH reward must be 0 for tangible prize\"\r\n                );\r\n            } else {\r\n                require(\r\n                    _prizeItems[x].ethReward > 0,\r\n                    \"Durham_Inu_Staking:  ETH reward must be greater than 0 for non-tangible prize\"\r\n                );\r\n            }\r\n            prizeItems[x + 1] = _prizeItems[x];\r\n        }\r\n    }\r\n\r\n    function getAllowedNfts() external view returns (address[] memory) {\r\n        return allowedNfts.values();\r\n    }\r\n\r\n    function getPrizeList() external view returns (PrizeItem[] memory) {\r\n        PrizeItem[] memory prizeList = new PrizeItem[](prizeLength);\r\n        for (uint256 x = 0; x < prizeLength; x++) {\r\n            prizeList[x] = prizeItems[x + 1];\r\n        }\r\n        return prizeList;\r\n    }\r\n\r\n    function getUserCurrentStakeInfo(address _address)\r\n        external\r\n        view\r\n        returns (Staker memory staker)\r\n    {\r\n        staker.userAddress = _address;\r\n        staker.stakedTokens = currentStakeInfo[_address].stakedTokens;\r\n        staker.nftId = currentStakeInfo[_address].stakedNft.nftId;\r\n        staker.nftAddress = currentStakeInfo[_address].stakedNft.nftAddress;\r\n        staker.noOfEntries = currentStakeInfo[_address].raffleIds.length();\r\n        staker.isStaked = currentStakeInfo[_address].isStaked;\r\n        staker.lastUpdated = currentStakeInfo[_address].lastUpdated;\r\n    }\r\n\r\n    function getAllCurrentStakers(uint256 _limit, uint256 _pageNumber)\r\n        external\r\n        view\r\n        onlyOwner\r\n        returns (Staker[] memory)\r\n    {\r\n        require(\r\n            _limit > 0 && _pageNumber > 0,\r\n            \"Durham_Inu_Staking: Invalid arguments\"\r\n        );\r\n\r\n        uint256 stakerCount = stakedAddresses.length();\r\n        uint256 end = _pageNumber * _limit;\r\n        uint256 start = end - _limit;\r\n        require(start < stakerCount, \"Durham_Inu_Staking: Out of range\");\r\n        uint256 limit = _limit;\r\n        if (end > stakerCount) {\r\n            end = stakerCount;\r\n            limit = stakerCount % _limit;\r\n        }\r\n\r\n        Staker[] memory stakers = new Staker[](limit);\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = start; i < end; i++) {\r\n            stakers[currentIndex].userAddress = stakedAddresses.at(i);\r\n            stakers[currentIndex].stakedTokens = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].stakedTokens;\r\n\r\n            stakers[currentIndex].nftId = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].stakedNft.nftId;\r\n            stakers[currentIndex].nftAddress = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].stakedNft.nftAddress;\r\n            stakers[currentIndex].noOfEntries = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].raffleIds.length();\r\n            stakers[currentIndex].isStaked = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].isStaked;\r\n            stakers[currentIndex].lastUpdated = currentStakeInfo[\r\n                stakedAddresses.at(i)\r\n            ].lastUpdated;\r\n\r\n            currentIndex += 1;\r\n        }\r\n        return stakers;\r\n    }\r\n\r\n    function getCurrentStakersCount() external view returns (uint256) {\r\n        return stakedAddresses.length();\r\n    }\r\n\r\n    function getRewardPointsBalance(address _address)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return rewardPointBalance[_address];\r\n    }\r\n\r\n    function getUserStatus(address _address)\r\n        external\r\n        view\r\n        returns (\r\n            bool canStake,\r\n            bool canUnStake,\r\n            bool canClaim\r\n        )\r\n    {\r\n        canStake = !currentStakeInfo[_address].isStaked;\r\n        canUnStake = currentStakeInfo[_address].isStaked;\r\n        canClaim = rewardPointBalance[_address] > 0;\r\n    }\r\n\r\n    function getWinnerHistory(uint256 _limit, uint256 _pageNumber)\r\n        external\r\n        view\r\n        returns (WinnerHistoryItem[] memory)\r\n    {\r\n        require(\r\n            _limit > 0 && _pageNumber > 0,\r\n            \"Durham_Inu_Staking: Invalid arguments\"\r\n        );\r\n\r\n        uint256 winnerCount = winnerIds.current();\r\n        uint256 end = _pageNumber * _limit;\r\n        uint256 start = end - _limit;\r\n        require(start < winnerCount, \"Durham_Inu_Staking: Out of range\");\r\n        uint256 limit = _limit;\r\n        if (end > winnerCount) {\r\n            end = winnerCount;\r\n            limit = winnerCount % _limit;\r\n        }\r\n\r\n        WinnerHistoryItem[] memory winners = new WinnerHistoryItem[](limit);\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = end; i > start; i--) {\r\n            winners[currentIndex] = WinnerHistories[i];\r\n            currentIndex += 1;\r\n        }\r\n        return winners;\r\n    }\r\n\r\n    function getWinnersCount() external view returns (uint256) {\r\n        return winnerIds.current();\r\n    }\r\n\r\n    function getUserClaimedHistory(\r\n        address _address,\r\n        uint256 _limit,\r\n        uint256 _pageNumber\r\n    ) external view returns (ClaimedHistoryItem[] memory) {\r\n        require(\r\n            _limit > 0 && _pageNumber > 0,\r\n            \"Durham_Inu_Staking: Invalid arguments\"\r\n        );\r\n\r\n        uint256 userClaimedCount = userClaimedIds[_address].length;\r\n        uint256 end = _pageNumber * _limit;\r\n        uint256 start = end - _limit;\r\n        require(start < userClaimedCount, \"Durham_Inu_Staking: Out of range\");\r\n        uint256 limit = _limit;\r\n        if (end > userClaimedCount) {\r\n            end = userClaimedCount;\r\n            limit = userClaimedCount % _limit;\r\n        }\r\n\r\n        ClaimedHistoryItem[] memory myClaimedEth = new ClaimedHistoryItem[](\r\n            limit\r\n        );\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = end; i > start; i--) {\r\n            uint256 hId = userClaimedIds[_address][i - 1];\r\n            myClaimedEth[currentIndex] = claimedHistoryMap[hId];\r\n            currentIndex += 1;\r\n        }\r\n        return myClaimedEth;\r\n    }\r\n\r\n    function getUserClaimedHistoryCount(address _address)\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return userClaimedIds[_address].length;\r\n    }\r\n\r\n    function getAllClaimedHistory(uint256 _limit, uint256 _pageNumber)\r\n        external\r\n        view\r\n        returns (ClaimedHistoryItem[] memory)\r\n    {\r\n        require(\r\n            _limit > 0 && _pageNumber > 0,\r\n            \"Durham_Inu_Staking: Invalid arguments\"\r\n        );\r\n\r\n        uint256 claimedCount = claimedHistoryIds.current();\r\n        uint256 end = _pageNumber * _limit;\r\n        uint256 start = end - _limit;\r\n        require(start < claimedCount, \"Durham_Inu_Staking: Out of range\");\r\n        uint256 limit = _limit;\r\n        if (end > claimedCount) {\r\n            end = claimedCount;\r\n            limit = claimedCount % _limit;\r\n        }\r\n\r\n        ClaimedHistoryItem[] memory claims = new ClaimedHistoryItem[](limit);\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = end; i > start; i--) {\r\n            claims[currentIndex] = claimedHistoryMap[i];\r\n            currentIndex += 1;\r\n        }\r\n        return claims;\r\n    }\r\n\r\n    function getAllClaimedHistoryCount() external view returns (uint256) {\r\n        return claimedHistoryIds.current();\r\n    }\r\n\r\n    function drawWinner(uint256 _rewardPoints, uint256 _seed)\r\n        external\r\n        onlyOwner\r\n    {\r\n        require(\r\n            stakedAddresses.length() > 0,\r\n            \"Durham_Inu_Staking: can't draw a winner, no staker found\"\r\n        );\r\n        uint256 lastWinnerId = winnerIds.current();\r\n        address lastWinnerAddress = WinnerHistories[lastWinnerId].userAddress;\r\n        address winnerAddress = address(0);\r\n        uint256 seed = _seed;\r\n        uint256 counter = 0;\r\n        while (winnerAddress == address(0)) {\r\n            uint256 randNumber = rand(\r\n                raffleIds.current(),\r\n                seed,\r\n                lastWinnerId,\r\n                lastWinnerAddress\r\n            );\r\n            counter = counter.add(1);\r\n            seed = seed.add(counter);\r\n            if (counter > 10) {\r\n                uint256 randNumber2 = rand(\r\n                    stakedAddresses.length(),\r\n                    seed,\r\n                    lastWinnerId,\r\n                    lastWinnerAddress\r\n                );\r\n                if (randNumber2 > 0) {\r\n                    winnerAddress = stakedAddresses.at(randNumber2 - 1);\r\n                }\r\n            } else {\r\n                winnerAddress = raffleEntries[randNumber];\r\n            }\r\n        }\r\n\r\n        winnerIds.increment();\r\n        uint256 winnerId = winnerIds.current();\r\n\r\n        WinnerHistories[winnerId].userAddress = winnerAddress;\r\n        WinnerHistories[winnerId].rewardPoints = _rewardPoints;\r\n        WinnerHistories[winnerId].timestamp = block.timestamp;\r\n\r\n        rewardPointBalance[winnerAddress] = rewardPointBalance[winnerAddress]\r\n            .add(_rewardPoints);\r\n    }\r\n\r\n    function stakeTokensOnly(uint256 _qty) external {\r\n        require(\r\n            !blacklisted.contains(msg.sender),\r\n            \"Durham_Inu_Staking: address is blocked\"\r\n        );\r\n        require(!isPaused, \"Durham_Inu_Staking: Staking is paused\");\r\n        require(\r\n            currentStakeInfo[msg.sender].isStaked == false,\r\n            \"Durham_Inu_Staking: You can stake once at a time\"\r\n        );\r\n\r\n        stakedAddresses.add(msg.sender);\r\n        _stakeTokens(msg.sender, _qty);\r\n    }\r\n\r\n    function stakeTokensAndNft(\r\n        uint256 _qty,\r\n        uint256 _nftId,\r\n        address _nftAddress\r\n    ) external {\r\n        require(\r\n            !blacklisted.contains(msg.sender),\r\n            \"Durham_Inu_Staking: address is blocked\"\r\n        );\r\n        require(!isPaused, \"Durham_Inu_Staking: Staking is paused\");\r\n        require(\r\n            currentStakeInfo[msg.sender].isStaked == false,\r\n            \"Durham_Inu_Staking: You can stake once at a time\"\r\n        );\r\n\r\n        stakedAddresses.add(msg.sender);\r\n        _stakeTokens(msg.sender, _qty);\r\n        _stakeNft(msg.sender, _nftId, _nftAddress);\r\n    }\r\n\r\n    function unstake() external {\r\n        stakedAddresses.remove(msg.sender);\r\n        _unStake(msg.sender);\r\n    }\r\n\r\n    function _stakeTokens(address _address, uint256 _qty) internal {\r\n        require(\r\n            maxQty >= _qty,\r\n            \"Durham_Inu_Staking: exceed the maximum quantity allowed\"\r\n        );\r\n        uint256 userTokenBalance = DurhamInuToken.balanceOf(_address);\r\n        uint256 tokenAmount = minToken * _qty;\r\n        require(\r\n            userTokenBalance >= tokenAmount,\r\n            \"Durham_Inu_Staking: not enought durham inu token\"\r\n        );\r\n        uint256 entries = _qty.mul(uint256(entryPerMinToken));\r\n        for (uint256 x = 0; x < entries; x++) {\r\n            uint256 id;\r\n            if (removedRaffleIds.length() > 0) {\r\n                id = removedRaffleIds.at(0);\r\n                removedRaffleIds.remove(id);\r\n            } else {\r\n                raffleIds.increment();\r\n                id = raffleIds.current();\r\n            }\r\n            raffleEntries[id] = _address;\r\n            currentStakeInfo[_address].raffleIds.add(id);\r\n        }\r\n\r\n        currentStakeInfo[_address].stakedTokens = tokenAmount;\r\n        currentStakeInfo[_address].isStaked = true;\r\n        currentStakeInfo[_address].lastUpdated = block.timestamp;\r\n        DurhamInuToken.transferFrom(_address, address(this), tokenAmount);\r\n\r\n        emit StakeTokens(_address, tokenAmount);\r\n    }\r\n\r\n    function _stakeNft(\r\n        address _address,\r\n        uint256 _nftId,\r\n        address _nftAddress\r\n    ) internal {\r\n        require(\r\n            allowedNfts.contains(_nftAddress),\r\n            \"Durham_Inu_Staking: this nft is not allowed to stake\"\r\n        );\r\n        require(\r\n            IERC721(_nftAddress).ownerOf(_nftId) == _address,\r\n            \"Durham_Inu_Staking: you are not the owner of this nft\"\r\n        );\r\n        for (uint8 x = 0; x < entryPerNft; x++) {\r\n            uint256 id;\r\n            if (removedRaffleIds.length() > 0) {\r\n                id = removedRaffleIds.at(0);\r\n                removedRaffleIds.remove(id);\r\n            } else {\r\n                raffleIds.increment();\r\n                id = raffleIds.current();\r\n            }\r\n            raffleEntries[id] = _address;\r\n            currentStakeInfo[_address].raffleIds.add(id);\r\n        }\r\n\r\n        currentStakeInfo[_address].stakedNft.nftId = _nftId;\r\n        currentStakeInfo[_address].stakedNft.nftAddress = _nftAddress;\r\n        currentStakeInfo[_address].isStaked = true;\r\n        currentStakeInfo[_address].lastUpdated = block.timestamp;\r\n        IERC721(_nftAddress).transferFrom(_address, address(this), _nftId);\r\n    }\r\n\r\n    function _unStake(address _address) internal {\r\n        require(\r\n            !blacklisted.contains(_address),\r\n            \"Durham_Inu_Staking: address is blocked\"\r\n        );\r\n        require(\r\n            currentStakeInfo[_address].isStaked == true,\r\n            \"Durham_Inu_Staking: no staked items\"\r\n        );\r\n\r\n        uint256 stakedTokens = currentStakeInfo[_address].stakedTokens;\r\n        uint256 stakedNftId = currentStakeInfo[_address].stakedNft.nftId;\r\n        address stakedNftAddress = currentStakeInfo[_address]\r\n            .stakedNft\r\n            .nftAddress;\r\n        uint256 userRaffleCount = currentStakeInfo[_address].raffleIds.length();\r\n\r\n        for (uint256 x = 0; x < userRaffleCount; x++) {\r\n            uint256 id = currentStakeInfo[_address].raffleIds.at(0);\r\n            removedRaffleIds.add(id);\r\n\r\n            raffleEntries[id] = address(0);\r\n            currentStakeInfo[_address].raffleIds.remove(id);\r\n        }\r\n\r\n        currentStakeInfo[_address].stakedTokens = 0;\r\n        currentStakeInfo[_address].stakedNft.nftId = 0;\r\n        currentStakeInfo[_address].stakedNft.nftAddress = address(0);\r\n        currentStakeInfo[_address].isStaked = false;\r\n        currentStakeInfo[_address].lastUpdated = block.timestamp;\r\n        if (stakedTokens > 0) {\r\n            DurhamInuToken.transfer(_address, stakedTokens);\r\n        }\r\n\r\n        if (stakedNftId > 0 && stakedNftAddress != address(0)) {\r\n            IERC721(stakedNftAddress).transferFrom(\r\n                address(this),\r\n                _address,\r\n                stakedNftId\r\n            );\r\n        }\r\n\r\n        emit UnStake(_address);\r\n    }\r\n\r\n    function claim(uint256 _prizeItem, string calldata _email) external {\r\n        require(\r\n            _prizeItem != 0 && _prizeItem <= prizeLength,\r\n            \"Durham_Inu_Staking: Invalid prize item\"\r\n        );\r\n        require(\r\n            rewardPointBalance[msg.sender] >=\r\n                prizeItems[_prizeItem].requiredPoints,\r\n            \"Durham_Inu_Staking: Not enough reward points\"\r\n        );\r\n        rewardPointBalance[msg.sender] = rewardPointBalance[msg.sender].sub(\r\n            prizeItems[_prizeItem].requiredPoints\r\n        );\r\n\r\n        bool isTangible = prizeItems[_prizeItem].isTangible;\r\n        uint256 ethReward = prizeItems[_prizeItem].ethReward;\r\n        claimedHistoryIds.increment();\r\n        uint256 hId = claimedHistoryIds.current();\r\n        claimedHistoryMap[hId].userAddress = msg.sender;\r\n        claimedHistoryMap[hId].isTangible = isTangible;\r\n        claimedHistoryMap[hId].name = prizeItems[_prizeItem].name;\r\n        claimedHistoryMap[hId].desc = prizeItems[_prizeItem].desc;\r\n        claimedHistoryMap[hId].ethReward = ethReward;\r\n        claimedHistoryMap[hId].requiredPoints = prizeItems[_prizeItem]\r\n            .requiredPoints;\r\n        claimedHistoryMap[hId].timestamp = block.timestamp;\r\n        claimedHistoryMap[hId].email = _email;\r\n        userClaimedIds[msg.sender].push(hId);\r\n        if (!prizeItems[_prizeItem].isTangible) {\r\n            require(\r\n                address(this).balance >= ethReward,\r\n                \"Durham_Inu_Staking: Not enough contract balance\"\r\n            );\r\n            (bool status, ) = msg.sender.call{value: ethReward}(\"\");\r\n            require(status);\r\n\r\n            totalNonTangibleClaims.increment();\r\n        } else {\r\n            totalTangibleClaims.increment();\r\n        }\r\n\r\n        emit ClaimPrize(msg.sender, _prizeItem);\r\n    }\r\n\r\n    function setBlacklist(address[] calldata _accounts, bool _isBlock)\r\n        external\r\n        onlyOwner\r\n    {\r\n        for (uint256 i = 0; i < _accounts.length; i++) {\r\n            if (_isBlock && !blacklisted.contains(_accounts[i])) {\r\n                blacklisted.add(_accounts[i]);\r\n            } else if (!_isBlock && blacklisted.contains(_accounts[i])) {\r\n                blacklisted.remove(_accounts[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBlacklisted() external view returns (address[] memory) {\r\n        return blacklisted.values();\r\n    }\r\n\r\n    function pause() external onlyOwner {\r\n        require(!isPaused, \"Durham_Inu_Staking: Staking is already paused\");\r\n        isPaused = true;\r\n    }\r\n\r\n    function resume() external onlyOwner {\r\n        require(isPaused, \"Durham_Inu_Staking: Staking is already resumed\");\r\n        isPaused = false;\r\n    }\r\n\r\n    function getThisBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function manualWithdraw() external onlyOwner returns (bool) {\r\n        (bool status, ) = _msgSender().call{value: address(this).balance}(\"\");\r\n        return status;\r\n    }\r\n\r\n    function transferAnyTokens(\r\n        address _tokenAddr,\r\n        address _to,\r\n        uint256 _amount\r\n    ) public onlyOwner {\r\n        require(\r\n            _tokenAddr != address(DurhamInuToken),\r\n            \"Durham_Inu_Staking: Cannot transfer this token\"\r\n        );\r\n        IERC20(_tokenAddr).transfer(_to, _amount);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function rand(\r\n        uint256 _max,\r\n        uint256 _seed,\r\n        uint256 _lastWinnerId,\r\n        address _lastWinnerAddress\r\n    ) internal view returns (uint256) {\r\n        if (_max == 0) {\r\n            return 0;\r\n        }\r\n        uint256 _rand = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    _seed,\r\n                    _lastWinnerId,\r\n                    _lastWinnerAddress,\r\n                    _lastWinnerAddress.balance,\r\n                    block.number,\r\n                    block.timestamp,\r\n                    block.coinbase\r\n                )\r\n            )\r\n        );\r\n        return _rand % (_max + 1);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_durhamInuTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_allowedNfts\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prizeItem\",\"type\":\"uint256\"}],\"name\":\"ClaimPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAddress\",\"type\":\"uint256\"}],\"name\":\"StakeNFT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"StakeTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"UnStake\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DurhamInuToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_prizeItem\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_email\",\"type\":\"string\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isTangible\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageUrl\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ethReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.PrizeItem[]\",\"name\":\"_prizeItems\",\"type\":\"tuple[]\"}],\"name\":\"clearAndSetPrizes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"drawWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPerMinToken\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entryPerNft\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pageNumber\",\"type\":\"uint256\"}],\"name\":\"getAllClaimedHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"email\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isTangible\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ethReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.ClaimedHistoryItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllClaimedHistoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pageNumber\",\"type\":\"uint256\"}],\"name\":\"getAllCurrentStakers\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"noOfEntries\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.Staker[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllowedNfts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlacklisted\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStakersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizeList\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isTangible\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"imageUrl\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ethReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredPoints\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.PrizeItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRewardPointsBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThisBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pageNumber\",\"type\":\"uint256\"}],\"name\":\"getUserClaimedHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"email\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isTangible\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"desc\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"ethReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.ClaimedHistoryItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserClaimedHistoryCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserCurrentStakeInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"stakedTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"noOfEntries\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isStaked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdated\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.Staker\",\"name\":\"staker\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getUserStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"canStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canUnStake\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"canClaim\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_pageNumber\",\"type\":\"uint256\"}],\"name\":\"getWinnerHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTStaking.WinnerHistoryItem[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWinnersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxQty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raffleEntries\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nftAddress\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"setAllowableNFts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_accounts\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_isBlock\",\"type\":\"bool\"}],\"name\":\"setBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newCoOwner\",\"type\":\"address\"}],\"name\":\"setCoOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_entryPerNFT\",\"type\":\"uint8\"}],\"name\":\"setEntryPerNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxQty\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_entryPerMinToken\",\"type\":\"uint8\"}],\"name\":\"setTokenStakeSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nftId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"stakeTokensAndNft\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_qty\",\"type\":\"uint256\"}],\"name\":\"stakeTokensOnly\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNonTangibleClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalTangibleClaims\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NFTStaking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000042f3a4901b2b2c5e2d6bc8dadb8c1d8d5afd261800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000001000000000000000000000000d169fa05acc223bda346f68c59f4c9c1d6946e07", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://45504a5ab610fb18b38b2b875c5dc1ebb8690d0e1d31ec2cd4e5bc3aa67ea86b"}]}