{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Redistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface InitializablePool {\\n  function initialize(address uniBurn, address uniswapPair) external;\\n}\\n\\ninterface IUniBurn {\\n  function burnWETH() external;\\n}\\n\\ncontract Redistributor {\\n  // Calldata\\n  uint256 internal constant ERC20_transferFrom_signature = (\\n    0x23b872dd00000000000000000000000000000000000000000000000000000000\\n  );\\n  uint256 internal constant ERC20_transferFrom_sig_ptr = 0x0;\\n  uint256 internal constant ERC20_transferFrom_from_ptr = 0x04;\\n  uint256 internal constant ERC20_transferFrom_to_ptr = 0x24;\\n  uint256 internal constant ERC20_transferFrom_amount_ptr = 0x44;\\n  uint256 internal constant ERC20_transferFrom_length = 0x64;\\n\\n  uint256 internal constant ERC20_transferFrom_returndata_ptr = 0x44;\\n  uint256 internal constant ERC20_transferFrom_returndata_length = 0x20;\\n\\n  // Treasury\\n  address internal constant Treasury = 0x78a3eF33cF033381FEB43ba4212f2Af5A5A0a2EA;\\n\\n  // Machine state\\n  uint256 internal constant FreeMemoryPointerSlot = 0x40;\\n  uint256 internal constant ZeroSlot = 0x60;\\n\\n  // LP burn contract\\n  address internal immutable uniBurn;\\n\\n  // Pool addresses\\n  address internal constant defi5 = 0xfa6de2697D59E88Ed7Fc4dFE5A33daC43565ea41;\\n  address internal constant cc10 = 0x17aC188e09A7890a1844E5E65471fE8b0CcFadF3;\\n  address internal constant fff = 0xaBAfA52D3d5A2c18A4C1Ae24480D22B831fC0413;\\n\\n  // Token addresses\\n  address internal constant weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n  address internal constant uni = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\\n  address internal constant aave = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\\n  address internal constant comp = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\\n  address internal constant snx = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\\n  address internal constant crv = 0xD533a949740bb3306d119CC777fa900bA034cd52;\\n  address internal constant mkr = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\\n  address internal constant sushi = 0x6B3595068778DD592e39A122f4f5a5cF09C90fE2;\\n  address internal constant yfi = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e;\\n  address internal constant uma = 0x04Fa0d235C4abf4BcF4787aF4CF447DE572eF828;\\n  address internal constant bat = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\\n  address internal constant omg = 0xd26114cd6EE289AccF82350c8d8487fedB8A0C07;\\n  address internal constant wbtc = 0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599;\\n  address internal constant degen = 0x126c121f99e1E211dF2e5f8De2d96Fa36647c855;\\n\\n  constructor(address _uniBurn) {\\n    uniBurn = _uniBurn;\\n  }\\n\\n  function restoreBalances() external {\\n    address _uniBurn = uniBurn;\\n    assembly {\\n      // Cache free memory pointer to restore after assembly block\\n      let memPointer := mload(FreeMemoryPointerSlot)\\n      // Write function selector and from address for ERC20.transferFrom\\n      // to calldata buffer in scratch space\\n      mstore(ERC20_transferFrom_sig_ptr, ERC20_transferFrom_signature)\\n      mstore(ERC20_transferFrom_from_ptr, Treasury)\\n      // Function to execute token transfer with current recipient\\n      function executeTransfer(token, amount) {\\n        // Write token amount to calldata buffer\\n        mstore(ERC20_transferFrom_amount_ptr, amount)\\n        // Make call & copy up to 32 bytes of return data\\n        let callStatus := call(\\n          gas(),\\n          token,\\n          0,\\n          ERC20_transferFrom_sig_ptr,\\n          ERC20_transferFrom_length,\\n          ERC20_transferFrom_returndata_ptr,\\n          ERC20_transferFrom_returndata_length\\n        )\\n\\n        // Determine whether transfer was successful using status & result.\\n        if iszero(\\n          and(\\n            // Set success to whether the call reverted, if not check it\\n            // either returned exactly 1 (can't just be non-zero data), or\\n            // had no return data.\\n            or(\\n              and(\\n                eq(mload(ERC20_transferFrom_returndata_ptr), 1),\\n                gt(returndatasize(), 31)\\n              ),\\n              iszero(returndatasize())\\n            ),\\n            callStatus\\n          )\\n        ) {\\n          returndatacopy(0, 0, returndatasize())\\n          revert(0, returndatasize())\\n        }\\n      }\\n\\n      // Restore defi5 underlying balances\\n      mstore(ERC20_transferFrom_to_ptr, defi5)\\n      executeTransfer(uni, 0x016369e53540bcbc1e27)\\n      executeTransfer(aave, 0x0d2be1248bae9513d2)\\n      executeTransfer(comp, 0x0833f5897bb9eeb379)\\n      executeTransfer(snx, 0x1df7abd4ddbeae7c57)\\n      executeTransfer(crv, 0x0272e24ba836f5cb4b03)\\n      executeTransfer(mkr, 0x996c11a09f7388a0)\\n      executeTransfer(sushi, 0x17eb5d4665b98343a481)\\n\\n      // Restore cc10 underlying balances\\n      mstore(ERC20_transferFrom_to_ptr, cc10)\\n      executeTransfer(uni, 0x193dc30b99de3c32)\\n      executeTransfer(comp, 0x05c74d1abfdc801e)\\n      executeTransfer(snx, 0x8a09b419e2bd9491)\\n      executeTransfer(crv, 0x01ad44f2827f4b9718)\\n      executeTransfer(yfi, 0x090e17a411a7e8)\\n      executeTransfer(uma, 0x6f6919019e481bc7)\\n      executeTransfer(mkr, 0x8b693ab24d6315)\\n      executeTransfer(bat, 0x04d1be9d73c4c3d1fe)\\n      executeTransfer(sushi, 0xa0f2c9bc6835a4ca)\\n      executeTransfer(omg, 0x1c5b46af431169a51a)\\n\\n      // Restore fff underlying balances\\n      mstore(ERC20_transferFrom_to_ptr, fff)\\n      executeTransfer(weth, 0x65c6f3c00d3dd975)\\n      executeTransfer(wbtc, 0x02daefe8)\\n      executeTransfer(degen, 0x010c0d3cd7a1f3ab127a)\\n\\n      // Transfer WETH to UniBurn\\n      mstore(ERC20_transferFrom_to_ptr, _uniBurn)\\n      executeTransfer(weth, 0xee62d13a63f52d33)\\n\\n      // Restore free memory pointer and zero slot\\n      mstore(FreeMemoryPointerSlot, memPointer)\\n      mstore(ZeroSlot, 0x0)\\n    }\\n    // Initialize pools\\n    InitializablePool(defi5).initialize(\\n      _uniBurn,\\n      0x8dCBa0B75c1038c4BaBBdc0Ff3bD9a8f6979Dd13\\n    );\\n    InitializablePool(cc10).initialize(\\n      _uniBurn,\\n      0x2701eA55b8B4f0FE46C15a0F560e9cf0C430f833\\n    );\\n    InitializablePool(fff).initialize(\\n      _uniBurn,\\n      0x9A60F0A46C1485D4BDA7750AdB0dB1b17Aa48A33\\n    );\\n    IUniBurn(_uniBurn).burnWETH();\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_uniBurn\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"restoreBalances\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Redistributor", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000589f9d287766d810aafccaee3a133f22c13eb6f8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}