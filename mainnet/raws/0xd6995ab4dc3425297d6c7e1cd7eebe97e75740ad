{"status": "1", "message": "OK", "result": [{"SourceCode": "// 0xRACER is a brand new team-based pot lottery game. \r\n// Users are grouped into teams based on the first byte of their address.\r\n// Team One: 0x0..., 0x1..., 0x2..., 0x3..., 0x4..., 0x5..., 0x6..., 0x7...\r\n// Team Two: 0x8..., 0x9..., 0xa..., 0xb..., 0xc..., 0xd..., 0xe..., 0x0...\r\n\r\n// DISCLAIMER: This is an experimental game in distributed psychology and distributed technology.\r\n// DISCLAIMER: You can, and likely will, lose any ETH you send to this contract. Don't send more than you can afford to lose. Or any at all.\r\n\r\n// RULES:\r\n\r\n// 1. The team with the highest buy volume when the clock expires wins the pot.\r\n// 2. The pot is divided among the winning team members, proportional to a weighted share of team volume. \r\n// 3. Each team has a different share price that increases at a rate of 102% per ETH of buy volume.\r\n// 4. Every new buy adds time to the clock at the rate of 1 second/finney. The timer is capped at 24h.\r\n// 5. You can also reduce the clock at the rate of 1 second/finney, but this does not count towards your share. The timer can't go below 5 minutes with this method.\r\n// 6. Referrals and dividends are distributed by team. 50% of each new buy is proportionally split between that team's members.\r\n// 7. New seeded rounds with new teams will begin on a semi-regular basis based on user interest. Each game will use a new contract.\r\n// 8. In the unlikely event of a tie, the pot is distributed proportionally as weighted shares of total volume.\r\n// 9. The minimum buy starts at 1 finney and increases with share price. No maximum.\r\n// 10. There is no maximum buy, but large buys receive proportionally fewer shares. For example: 1 x 100 ETH buy (33,333 shares) vs. 100 x 1 ETH (55,265 shares).\r\n// 10. No contracts allowed.\r\n// 11. Users can withdraw earned dividends from referrals or pot wins at any time. Shares cannot be sold.\r\n// 12. The round will automatically open based on a preset timer.\r\n// 13. The contract will be closed no sooner than 100 days after the round ends. Any unclaimed user funds left past this time may be lost.\r\n\r\n// STRATEGY:\r\n\r\n// A. This game is designed to support multiple modes of play.\r\n// B. Get in early and shill your team to collect divs.\r\n// C. Manage risk by playing both sides of the fence.\r\n// D. Flex your whale wallet by front running and reducing the timer.\r\n// E. Piggy back on big players by making sure you're on the same team.\r\n// F. Gain a larger share of divs by supporting the underdog.\r\n// G. Buy smaller amounts to maximize your share count.\r\n\r\n// https://zeroxracer.surge.sh/\r\n// https://discord.gg/6Q7kGpc\r\n// by nightman\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract ZEROxRACER {\r\n\r\n    //VARIABLES AND CONSTANTS\r\n\r\n    //global \r\n    address public owner;\r\n    uint256 public devBalance;\r\n    uint256 public devFeeRate = 4; //4% of pot, not volume; effective dev fee, including premine, is ~2.5-3.5% depending on volume\r\n    uint256 public precisionFactor = 6; //shares precise to 0.0001%\r\n    address public addressThreshold = 0x7F00000000000000000000000000000000000000; //0x00-0x7f on Team One; 0x80-0xff on Team Two\r\n    uint256 public divRate = 50; //50% dividends for each buy, distributed proportionally to weighted team volume\r\n\r\n    //team accounting\r\n    uint256 public teamOneId = 1; \r\n    string public teamOnePrefix = \"Team 0x1234567\";\r\n    uint256 public teamOneVolume;\r\n    uint256 public teamOneShares;\r\n    uint256 public teamOneDivsTotal;\r\n    uint256 public teamOneDivsUnclaimed;\r\n    uint256 public teamOneSharePrice = 1000000000000000; //1 finney starting price; increases 102% per ETH bought\r\n\r\n\r\n    uint256 public teamTwoId = 2;\r\n    string public teamTwoPrefix = \"Team 0x89abcdef\";\r\n    uint256 public teamTwoVolume;\r\n    uint256 public teamTwoShares;\r\n    uint256 public teamTwoDivsTotal;\r\n    uint256 public teamTwoDivsUnclaimed;\r\n    uint256 public teamTwoSharePrice = 1000000000000000; //1 finney starting price; increases 102% per ETH bought\r\n\r\n    //user accounting\r\n    address[] public teamOneMembers;\r\n    mapping (address => bool) public isTeamOneMember;\r\n    mapping (address => uint256) public userTeamOneStake;\r\n    mapping (address => uint256) public userTeamOneShares;\r\n    mapping (address => uint256) private userDivsTeamOneTotal;\r\n    mapping (address => uint256) private userDivsTeamOneClaimed;\r\n    mapping (address => uint256) private userDivsTeamOneUnclaimed;\r\n    mapping (address => uint256) private userDivRateTeamOne;\r\n    \r\n    address[] public teamTwoMembers;\r\n    mapping (address => bool) public isTeamTwoMember;\r\n    mapping (address => uint256) public userTeamTwoStake;\r\n    mapping (address => uint256) public userTeamTwoShares;\r\n    mapping (address => uint256) private userDivsTeamTwoTotal;\r\n    mapping (address => uint256) private userDivsTeamTwoClaimed;\r\n    mapping (address => uint256) private userDivsTeamTwoUnclaimed;\r\n    mapping (address => uint256) private userDivRateTeamTwo;\r\n\r\n    //round accounting\r\n    uint256 public pot;\r\n    uint256 public timerStart;\r\n    uint256 public timerMax;\r\n    uint256 public roundStartTime;\r\n    uint256 public roundEndTime;\r\n    bool public roundOpen = false;\r\n    bool public roundSetUp = false;\r\n    bool public roundResolved = false;\r\n    \r\n\r\n    //CONSTRUCTOR\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit contractLaunched(owner);\r\n    }\r\n    \r\n\r\n    //MODIFIERS\r\n\r\n    modifier onlyOwner() { \r\n        require (msg.sender == owner, \"you are not the owner\"); \r\n        _; \r\n    }\r\n\r\n    modifier gameOpen() {\r\n        require (roundResolved == false);\r\n        require (roundSetUp == true);\r\n        require (now < roundEndTime, \"it is too late to play\");\r\n        require (now >= roundStartTime, \"it is too early to play\");\r\n        _; \r\n    }\r\n\r\n    modifier onlyHumans() { \r\n        require (msg.sender == tx.origin, \"you cannot use a contract\"); \r\n        _; \r\n    }\r\n    \r\n\r\n    //EVENTS\r\n\r\n    event potFunded(\r\n        address _funder, \r\n        uint256 _amount,\r\n        string _message\r\n    );\r\n    \r\n    event teamBuy(\r\n        address _buyer, \r\n        uint256 _amount, \r\n        uint256 _teamID,\r\n        string _message\r\n    );\r\n    \r\n    event roundEnded(\r\n        uint256 _winningTeamId, \r\n        string _winningTeamString, \r\n        uint256 _pot,\r\n        string _message\r\n    );\r\n    \r\n    event newRoundStarted(\r\n        uint256 _timeStart, \r\n        uint256 _timeMax,\r\n        uint256 _seed,\r\n        string _message\r\n    );\r\n\r\n    event userWithdrew(\r\n        address _user,\r\n        uint256 _teamID,\r\n        uint256 _teamAmount,\r\n        string _message\r\n    );\r\n\r\n    event devWithdrew(\r\n        address _owner,\r\n        uint256 _amount, \r\n        string _message\r\n    );\r\n\r\n    event contractClosed(\r\n        address _owner,\r\n        uint256 _amount,\r\n        string _message\r\n    );\r\n\r\n    event contractLaunched(\r\n        address _owner\r\n    );\r\n\r\n\r\n    //DEV FUNCTIONS\r\n\r\n    //start round\r\n    function openRound (uint _timerStart, uint _timerMax) public payable onlyOwner() {\r\n        require (roundOpen == false, \"you can only start the game once\");\r\n        require (roundResolved == false, \"you cannot restart a finished game\"); \r\n        require (msg.value == 2 ether, \"you must give a decent seed\");\r\n\r\n        //round set up\r\n        roundSetUp = true;\r\n        timerStart = _timerStart;\r\n        timerMax = _timerMax;\r\n        roundStartTime = 1535504400; //Tuesday, August 28, 2018 9:00:00 PM Eastern Time\r\n        roundEndTime = 1535504400 + timerStart;\r\n        pot += msg.value;\r\n\r\n        //the seed is also a sneaky premine\r\n        //set up correct accounting for 1 ETH buy to each team without calling buy()\r\n        address devA = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\r\n        address devB = 0x84ECB387395a1be65E133c75Ff9e5FCC6F756DB3;\r\n        teamOneVolume = 1 ether;\r\n        teamTwoVolume = 1 ether;\r\n        teamOneMembers.push(devA);\r\n        teamTwoMembers.push(devB);\r\n        isTeamOneMember[devA] = true;\r\n        isTeamOneMember[devB] = true;\r\n        userTeamOneStake[devA] = 1 ether;\r\n        userTeamTwoStake[devB] = 1 ether;\r\n        userTeamOneShares[devA] = 1000;\r\n        userTeamTwoShares[devB] = 1000;\r\n        teamOneShares = 1000;\r\n        teamTwoShares = 1000;\r\n\r\n        emit newRoundStarted(timerStart, timerMax, msg.value, \"a new game was just set up\");\r\n    }\r\n\r\n    //dev withdraw\r\n    function devWithdraw() public onlyOwner() {\r\n        require (devBalance > 0, \"you must have an available balance\");\r\n        require(devBalance <= address(this).balance, \"you cannot print money\");\r\n\r\n        uint256 shareTemp = devBalance;\r\n        devBalance = 0;\r\n        owner.transfer(shareTemp);\r\n\r\n        emit devWithdrew(owner, shareTemp, \"the dev just withdrew\");\r\n    }\r\n\r\n    //close contract \r\n    //this function allows the dev to collect any wei dust from rounding errors no sooner than 100 days after the game ends\r\n    //wei dust will be at most (teamOneVolume + teamTwoVolume) / 10 ** precisionFactor (ie, 0.0001% of the total buy volume)\r\n    //users must withdraw any earned divs before this date, or risk losing them\r\n    function zeroOut() public onlyOwner() { \r\n        require (now >= roundEndTime + 100 days, \"too early to exit scam\"); \r\n        require (roundResolved == true && roundOpen == false, \"the game is not resolved\");\r\n\r\n        emit contractClosed(owner, address(this).balance, \"the contract is now closed\");\r\n\r\n        selfdestruct(owner);\r\n    }\r\n\r\n\r\n    //PUBLIC FUNCTIONS\r\n\r\n    function buy() public payable gameOpen() onlyHumans() { \r\n\r\n        //toggle roundOpen on first buy after roundStartTime\r\n        if (roundOpen == false && now >= roundStartTime && now < roundEndTime) {\r\n            roundOpen = true;\r\n        }\r\n        \r\n        //establish team affiliation \r\n        uint256 _teamID;\r\n        if (checkAddressTeamOne(msg.sender) == true) {\r\n            _teamID = 1;\r\n        } else if (checkAddressTeamTwo(msg.sender) == true) {\r\n            _teamID = 2;\r\n        }\r\n\r\n        //adjust pot and div balances\r\n        if (_teamID == 1 && teamOneMembers.length == 0 || _teamID == 2 && teamTwoMembers.length == 0) { \r\n            //do not distribute divs on first buy from either team. prevents black-holed ether\r\n            //redundant if openRound() includes a premine\r\n            pot += msg.value;\r\n        } else {\r\n            uint256 divContribution = uint256(SafeMaths.div(SafeMaths.mul(msg.value, divRate), 100)); \r\n            uint256 potContribution = msg.value - divContribution;\r\n            pot += potContribution; \r\n            distributeDivs(divContribution, _teamID); \r\n        }\r\n\r\n        //adjust time \r\n        timeAdjustPlus();\r\n\r\n        //update team and player accounting \r\n        if (_teamID == 1) {\r\n            require (msg.value >= teamOneSharePrice, \"you must buy at least one Team One share\");\r\n\r\n            if (isTeamOneMember[msg.sender] == false) {\r\n                isTeamOneMember[msg.sender] = true;\r\n                teamOneMembers.push(msg.sender);\r\n            }\r\n\r\n            userTeamOneStake[msg.sender] += msg.value;\r\n            teamOneVolume += msg.value;\r\n\r\n            //adjust team one share price\r\n            uint256 shareIncreaseOne = SafeMaths.mul(SafeMaths.div(msg.value, 100000), 2); //increases 102% per ETH spent\r\n            teamOneSharePrice += shareIncreaseOne;\r\n\r\n            uint256 newSharesOne = SafeMaths.div(msg.value, teamOneSharePrice);\r\n            userTeamOneShares[msg.sender] += newSharesOne;\r\n            teamOneShares += newSharesOne;\r\n\r\n        } else if (_teamID == 2) {\r\n            require (msg.value >= teamTwoSharePrice, \"you must buy at least one Team Two share\");\r\n\r\n            if (isTeamTwoMember[msg.sender] == false) {\r\n                isTeamTwoMember[msg.sender] = true;\r\n                teamTwoMembers.push(msg.sender);\r\n            }\r\n\r\n            userTeamTwoStake[msg.sender] += msg.value;\r\n            teamTwoVolume += msg.value;\r\n\r\n            //adjust team two share price\r\n            uint256 shareIncreaseTwo = SafeMaths.mul(SafeMaths.div(msg.value, 100000), 2); //increases 102% per ETH spent\r\n            teamTwoSharePrice += shareIncreaseTwo;\r\n\r\n            uint256 newSharesTwo = SafeMaths.div(msg.value, teamTwoSharePrice);\r\n            userTeamTwoShares[msg.sender] += newSharesTwo;\r\n            teamTwoShares += newSharesTwo;\r\n        }\r\n    \r\n        emit teamBuy(msg.sender, msg.value, _teamID, \"a new buy just happened\");\r\n    }  \r\n\r\n    function resolveRound() public onlyHumans() { \r\n\r\n        //can be called by anyone if the round has ended \r\n        require (now > roundEndTime, \"you can only call this if time has expired\");\r\n        require (roundSetUp == true, \"you cannot call this before the game starts\");\r\n        require (roundResolved == false, \"you can only call this once\");\r\n\r\n        //resolve round based on current winner \r\n        if (teamOneVolume > teamTwoVolume) {\r\n            teamOneWin();\r\n        } else if (teamOneVolume < teamTwoVolume) {\r\n            teamTwoWin();\r\n        } else if (teamOneVolume == teamTwoVolume) {\r\n            tie();\r\n        }\r\n\r\n        //ensure this function can only be called once\r\n        roundResolved = true; \r\n        roundOpen = false;\r\n    }\r\n\r\n    function userWithdraw() public onlyHumans() {\r\n\r\n        //user divs calculated on withdraw to prevent runaway gas costs associated with looping balance updates in distributeDivs\r\n        if (userTeamOneShares[msg.sender] > 0) { \r\n\r\n            //first, calculate total earned user divs as a proportion of their shares vs. team shares\r\n            //second, determine whether the user has available divs \r\n            //precise to 0.0001%\r\n            userDivRateTeamOne[msg.sender] = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamOneShares[msg.sender], 10 ** (precisionFactor + 1)), teamOneShares) + 5, 10);\r\n            userDivsTeamOneTotal[msg.sender] = uint256(SafeMaths.div(SafeMaths.mul(teamOneDivsTotal, userDivRateTeamOne[msg.sender]), 10 ** precisionFactor));\r\n            userDivsTeamOneUnclaimed[msg.sender] = SafeMaths.sub(userDivsTeamOneTotal[msg.sender], userDivsTeamOneClaimed[msg.sender]);\r\n\r\n            if (userDivsTeamOneUnclaimed[msg.sender] > 0) {\r\n                //sanity check\r\n                assert(userDivsTeamOneUnclaimed[msg.sender] <= address(this).balance && userDivsTeamOneUnclaimed[msg.sender] <= teamOneDivsUnclaimed);\r\n\r\n                //update user accounting and transfer\r\n                teamOneDivsUnclaimed -= userDivsTeamOneUnclaimed[msg.sender];\r\n                userDivsTeamOneClaimed[msg.sender] = userDivsTeamOneTotal[msg.sender];\r\n                uint256 shareTempTeamOne = userDivsTeamOneUnclaimed[msg.sender];\r\n                userDivsTeamOneUnclaimed[msg.sender] = 0;\r\n                msg.sender.transfer(shareTempTeamOne);\r\n\r\n                emit userWithdrew(msg.sender, 1, shareTempTeamOne, \"a user just withdrew team one shares\");\r\n            }\r\n\r\n        }  else if (userTeamTwoShares[msg.sender] > 0) {\r\n\r\n            //first, calculate total earned user divs as a proportion of their shares vs. team shares\r\n            //second, determine whether the user has available divs \r\n            //precise to 0.0001%\r\n            userDivRateTeamTwo[msg.sender] = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamTwoShares[msg.sender], 10 ** (precisionFactor + 1)), teamTwoShares) + 5, 10);\r\n            userDivsTeamTwoTotal[msg.sender] = uint256(SafeMaths.div(SafeMaths.mul(teamTwoDivsTotal, userDivRateTeamTwo[msg.sender]), 10 ** precisionFactor));\r\n            userDivsTeamTwoUnclaimed[msg.sender] = SafeMaths.sub(userDivsTeamTwoTotal[msg.sender], userDivsTeamTwoClaimed[msg.sender]);\r\n\r\n            if (userDivsTeamTwoUnclaimed[msg.sender] > 0) {\r\n                //sanity check\r\n                assert(userDivsTeamTwoUnclaimed[msg.sender] <= address(this).balance && userDivsTeamTwoUnclaimed[msg.sender] <= teamTwoDivsUnclaimed);\r\n\r\n                //update user accounting and transfer\r\n                teamTwoDivsUnclaimed -= userDivsTeamTwoUnclaimed[msg.sender];\r\n                userDivsTeamTwoClaimed[msg.sender] = userDivsTeamTwoTotal[msg.sender];\r\n                uint256 shareTempTeamTwo = userDivsTeamTwoUnclaimed[msg.sender];\r\n                userDivsTeamTwoUnclaimed[msg.sender] = 0;\r\n                msg.sender.transfer(shareTempTeamTwo);\r\n\r\n                emit userWithdrew(msg.sender, 2, shareTempTeamTwo, \"a user just withdrew team one shares\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function fundPot() public payable onlyHumans() gameOpen() {\r\n        //ETH sent with this function is a benevolent gift. It does not count towards user shares or adjust the clock\r\n        pot += msg.value;\r\n        emit potFunded(msg.sender, msg.value, \"a generous person funded the pot\");\r\n    }\r\n\r\n    function reduceTime() public payable onlyHumans() gameOpen() {\r\n        //ETH sent with this function does not count towards user shares \r\n        timeAdjustNeg();\r\n        pot += msg.value;\r\n        emit potFunded(msg.sender, msg.value, \"someone just reduced the clock\");\r\n    }\r\n\r\n\r\n    //VIEW FUNCTIONS\r\n\r\n    function calcUserDivsTotal(address _user) public view returns(uint256 _divs) {\r\n\r\n        //calculated locally to avoid unnecessary state change\r\n        if (userTeamOneShares[_user] > 0) {\r\n\r\n            uint256 userDivRateTeamOneView = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamOneShares[_user], 10 ** (precisionFactor + 1)), teamOneShares) + 5, 10);\r\n            uint256 userDivsTeamOneTotalView = uint256(SafeMaths.div(SafeMaths.mul(teamOneDivsTotal, userDivRateTeamOneView), 10 ** precisionFactor));\r\n\r\n        } else if (userTeamTwoShares[_user] > 0) {\r\n\r\n            uint256 userDivRateTeamTwoView = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamTwoShares[_user], 10 ** (precisionFactor + 1)), teamTwoShares) + 5, 10);\r\n            uint256 userDivsTeamTwoTotalView = uint256(SafeMaths.div(SafeMaths.mul(teamTwoDivsTotal, userDivRateTeamTwoView), 10 ** precisionFactor));\r\n\r\n        }\r\n\r\n        uint256 userDivsTotal = userDivsTeamOneTotalView + userDivsTeamTwoTotalView;\r\n        return userDivsTotal;\r\n    }\r\n\r\n    function calcUserDivsAvailable(address _user) public view returns(uint256 _divs) {\r\n\r\n        //calculated locally to avoid unnecessary state change\r\n        if (userTeamOneShares[_user] > 0) {\r\n\r\n            uint256 userDivRateTeamOneView = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamOneShares[_user], 10 ** (precisionFactor + 1)), teamOneShares) + 5, 10);\r\n            uint256 userDivsTeamOneTotalView = uint256(SafeMaths.div(SafeMaths.mul(teamOneDivsTotal, userDivRateTeamOneView), 10 ** precisionFactor));\r\n            uint256 userDivsTeamOneUnclaimedView = SafeMaths.sub(userDivsTeamOneTotalView, userDivsTeamOneClaimed[_user]);\r\n\r\n        } else if (userTeamTwoShares[_user] > 0) {\r\n\r\n            uint256 userDivRateTeamTwoView = SafeMaths.div(SafeMaths.div(SafeMaths.mul(userTeamTwoShares[_user], 10 ** (precisionFactor + 1)), teamTwoShares) + 5, 10);\r\n            uint256 userDivsTeamTwoTotalView = uint256(SafeMaths.div(SafeMaths.mul(teamTwoDivsTotal, userDivRateTeamTwoView), 10 ** precisionFactor));\r\n            uint256 userDivsTeamTwoUnclaimedView = SafeMaths.sub(userDivsTeamTwoTotalView, userDivsTeamTwoClaimed[_user]);\r\n\r\n        }\r\n\r\n        uint256 userDivsUnclaimed = userDivsTeamOneUnclaimedView + userDivsTeamTwoUnclaimedView;\r\n        return userDivsUnclaimed;\r\n    }\r\n\r\n    function currentRoundInfo() public view returns(\r\n        uint256 _pot, \r\n        uint256 _teamOneVolume, \r\n        uint256 _teamTwoVolume, \r\n        uint256 _teamOnePlayerCount,\r\n        uint256 _teamTwoPlayerCount,\r\n        uint256 _totalPlayerCount,\r\n        uint256 _timerStart, \r\n        uint256 _timerMax, \r\n        uint256 _roundStartTime, \r\n        uint256 _roundEndTime, \r\n        uint256 _timeLeft,\r\n        string _currentWinner\r\n    ) {\r\n        return (\r\n            pot, \r\n            teamOneVolume, \r\n            teamTwoVolume, \r\n            teamOneTotalPlayers(), \r\n            teamTwoTotalPlayers(), \r\n            totalPlayers(), \r\n            timerStart, \r\n            timerMax, \r\n            roundStartTime, \r\n            roundEndTime, \r\n            getTimeLeft(),\r\n            currentWinner()\r\n        );\r\n    }\r\n\r\n    function getTimeLeft() public view returns(uint256 _timeLeftSeconds) {\r\n        //game over: display zero\r\n        if (now >= roundEndTime) {\r\n            return 0;\r\n        //game not yet started: display countdown until roundStartTime\r\n        } else if (roundOpen == false && roundResolved == false && roundSetUp == false) {\r\n            return roundStartTime - now;\r\n        //game in progress: display time left \r\n        } else {\r\n            return roundEndTime - now;\r\n        }\r\n    }\r\n    \r\n    function teamOneTotalPlayers() public view returns(uint256 _teamOnePlayerCount) {\r\n        return teamOneMembers.length;\r\n    }\r\n\r\n    function teamTwoTotalPlayers() public view returns(uint256 _teamTwoPlayerCount) {\r\n        return teamTwoMembers.length;\r\n    }\r\n\r\n    function totalPlayers() public view returns(uint256 _totalPlayerCount) {\r\n        return teamOneMembers.length + teamTwoMembers.length;\r\n    }\r\n\r\n    function adjustedPotBalance() public view returns(uint256 _adjustedPotBalance) {\r\n        uint256 devFee = uint256(SafeMaths.div(SafeMaths.mul(pot, devFeeRate), 100));\r\n        return pot - devFee;\r\n    }\r\n\r\n    function contractBalance() public view returns(uint256 _contractBalance) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function currentTime() public view returns(uint256 _time) {\r\n        return now;\r\n    }\r\n\r\n    function currentWinner() public view returns(string _winner) {\r\n        if (teamOneVolume > teamTwoVolume) {\r\n            return teamOnePrefix;\r\n        } else if (teamOneVolume < teamTwoVolume) {\r\n            return teamTwoPrefix;\r\n        } else if (teamOneVolume == teamTwoVolume) {\r\n            return \"a tie? wtf\";\r\n        }\r\n    }\r\n\r\n\r\n    //INTERNAL FUNCTIONS\r\n\r\n    //time adjustments\r\n    function timeAdjustPlus() internal {\r\n        if (msg.value >= 1 finney) {\r\n            uint256 timeFactor = 1000000000000000; //one finney in wei\r\n            uint256 timeShares = uint256(SafeMaths.div(msg.value, timeFactor)); \r\n\r\n            if (timeShares + roundEndTime > now + timerMax) {\r\n                roundEndTime = now + timerMax;\r\n            } else {\r\n                roundEndTime += timeShares; //add one second per finney  \r\n            }\r\n        }\r\n    }\r\n\r\n    function timeAdjustNeg() internal {\r\n        if (msg.value >= 1 finney) {\r\n            uint256 timeFactor = 1000000000000000; //one finney in wei\r\n            uint256 timeShares = uint256(SafeMaths.div(msg.value, timeFactor));\r\n\r\n            // prevents extreme edge case underflow if someone sends more than 1.5 million ETH\r\n            require (timeShares < roundEndTime, \"you sent an absurd amount! relax vitalik\"); \r\n\r\n            if (roundEndTime - timeShares < now + 5 minutes) {\r\n                roundEndTime = now + 5 minutes; //you can't win by buying up the clock, but you can come close\r\n            } else {\r\n                roundEndTime -= timeShares; //subtract one second per finney  \r\n            }\r\n        }\r\n    }\r\n\r\n    //divs \r\n    function distributeDivs(uint256 _divContribution, uint256 _teamID) internal {\r\n        if (_teamID == 1) {\r\n            teamOneDivsTotal += _divContribution;\r\n            teamOneDivsUnclaimed += _divContribution;\r\n        } else if (_teamID == 2) {\r\n            teamTwoDivsTotal += _divContribution;\r\n            teamTwoDivsUnclaimed += _divContribution;\r\n        }\r\n    }\r\n\r\n    //round payouts\r\n    function teamOneWin() internal {\r\n        uint256 devShare = uint256(SafeMaths.div(SafeMaths.mul(pot, devFeeRate), 100)); \r\n        devBalance += devShare;\r\n        uint256 potAdjusted = pot - devShare;\r\n\r\n        teamOneDivsTotal += potAdjusted;\r\n        teamOneDivsUnclaimed += potAdjusted;\r\n\r\n        emit roundEnded(1, teamOnePrefix, potAdjusted, \"team one won!\");\r\n    }\r\n\r\n    function teamTwoWin() internal {\r\n        uint256 devShare = uint256(SafeMaths.div(SafeMaths.mul(pot, devFeeRate), 100)); \r\n        devBalance += devShare;\r\n        uint256 potAdjusted = pot - devShare;\r\n\r\n        teamTwoDivsTotal += potAdjusted;\r\n        teamTwoDivsUnclaimed += potAdjusted;\r\n\r\n        emit roundEnded(2, teamTwoPrefix, potAdjusted, \"team two won!\");        \r\n    }\r\n\r\n    function tie() internal { //very unlikely this will happen, but just in case \r\n        uint256 devShare = uint256(SafeMaths.div(SafeMaths.mul(pot, devFeeRate), 100)); \r\n        devBalance += devShare;\r\n        uint256 potAdjusted = pot - devShare;\r\n\r\n        teamOneDivsTotal += SafeMaths.div(potAdjusted, 2);\r\n        teamOneDivsUnclaimed += SafeMaths.div(potAdjusted, 2);\r\n        teamTwoDivsTotal += SafeMaths.div(potAdjusted, 2);\r\n        teamTwoDivsUnclaimed += SafeMaths.div(potAdjusted, 2);\r\n\r\n        emit roundEnded(0, \"Tied\", potAdjusted, \"a tie?! wtf\");\r\n    }\r\n\r\n\r\n    //convert and address to bytes format\r\n    function toBytes(address a) internal pure returns (bytes b) {\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n        return b;\r\n    }\r\n    \r\n    //take the first byte of a bytes argument and return bytes1\r\n    function toBytes1(bytes data) internal pure returns (bytes1) {\r\n        uint val;\r\n        for (uint i = 0; i < 1; i++)  {\r\n            val *= 256;\r\n            if (i < data.length)\r\n                val |= uint8(data[i]);\r\n        }\r\n        return bytes1(val);\r\n    }\r\n    \r\n    //combine the above function\r\n    function addressToBytes1(address input) internal pure returns(bytes1) {\r\n        bytes1 output = toBytes1(toBytes(input));\r\n        return output;\r\n    }\r\n\r\n    //address checks\r\n    function checkAddressTeamOne(address _input) internal view returns(bool) {\r\n        if (addressToBytes1(_input) <= addressToBytes1(addressThreshold)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function checkAddressTeamTwo(address _input) internal view returns(bool) {\r\n        if (addressToBytes1(_input) > addressToBytes1(addressThreshold)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n}  \r\n\r\n//LIBRARIES\r\n\r\nlibrary SafeMaths {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundInfo\",\"outputs\":[{\"name\":\"_pot\",\"type\":\"uint256\"},{\"name\":\"_teamOneVolume\",\"type\":\"uint256\"},{\"name\":\"_teamTwoVolume\",\"type\":\"uint256\"},{\"name\":\"_teamOnePlayerCount\",\"type\":\"uint256\"},{\"name\":\"_teamTwoPlayerCount\",\"type\":\"uint256\"},{\"name\":\"_totalPlayerCount\",\"type\":\"uint256\"},{\"name\":\"_timerStart\",\"type\":\"uint256\"},{\"name\":\"_timerMax\",\"type\":\"uint256\"},{\"name\":\"_roundStartTime\",\"type\":\"uint256\"},{\"name\":\"_roundEndTime\",\"type\":\"uint256\"},{\"name\":\"_timeLeft\",\"type\":\"uint256\"},{\"name\":\"_currentWinner\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timerStart\",\"type\":\"uint256\"},{\"name\":\"_timerMax\",\"type\":\"uint256\"}],\"name\":\"openRound\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamOneMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundOpen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoDivsTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoSharePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTeamOneShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneDivsTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTeamOneMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneSharePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundSetUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calcUserDivsTotal\",\"outputs\":[{\"name\":\"_divs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneDivsUnclaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOnePrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"zeroOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resolveRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneTotalPlayers\",\"outputs\":[{\"name\":\"_teamOnePlayerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adjustedPotBalance\",\"outputs\":[{\"name\":\"_adjustedPotBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTeamTwoStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTeamTwoShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"_contractBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoDivsUnclaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTeamOneStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fundPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"precisionFactor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"userWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentWinner\",\"outputs\":[{\"name\":\"_winner\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isTeamTwoMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"devWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundResolved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"_timeLeftSeconds\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timerMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timerStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamTwoMembers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reduceTime\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPlayers\",\"outputs\":[{\"name\":\"_totalPlayerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"calcUserDivsAvailable\",\"outputs\":[{\"name\":\"_divs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamTwoTotalPlayers\",\"outputs\":[{\"name\":\"_teamTwoPlayerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_funder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"potFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_teamID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"teamBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_winningTeamId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_winningTeamString\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_pot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"roundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_timeStart\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_timeMax\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_seed\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"newRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_teamID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_teamAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"userWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"devWithdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_message\",\"type\":\"string\"}],\"name\":\"contractClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"contractLaunched\",\"type\":\"event\"}]", "ContractName": "ZEROxRACER", "CompilerVersion": "v0.4.24+commit.e67f0147", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c736ea7a96b0bed6a2b60065ad7a7de79be34eafc47c0de1144813e92151b46f"}]}