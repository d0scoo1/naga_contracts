{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Achievements.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"openzeppelin/utils/Strings.sol\\\";\\nimport \\\"solmate/tokens/ERC1155.sol\\\";\\n\\nimport \\\"./Owned.sol\\\";\\n\\n/// @title Solarbots Achievements\\n/// @author Solarbots (https://solarbots.io)\\n/// @notice All achievements are soulbound,\\n/// i.e. can't be transferred by the token owner.\\n/// Only approved operators can mint, transfer, and burn\\n/// tokens. Token owners can only burn their own tokens.\\ncontract Achievements is ERC1155, Owned {\\n    // ---------- CONSTANTS ----------\\n\\n    /// @dev \\\"Error(string)\\\" signature: bytes32(bytes4(keccak256(\\\"Error(string)\\\")))\\n    bytes32 private constant _ERROR_FUNCTION_SIGNATURE = 0x08c379a000000000000000000000000000000000000000000000000000000000;\\n\\n    /// @dev bytes32(abi.encodePacked(\\\"INSUFFICIENT_BALANCE\\\"))\\n    bytes32 private constant _INSUFFICIENT_BALANCE_MESSAGE = 0x494e53554646494349454e545f42414c414e4345000000000000000000000000;\\n\\n    /// @dev \\\"INSUFFICIENT_BALANCE\\\" is 20 characters long\\n    uint256 private constant _INSUFFICIENT_BALANCE_LENGTH = 20;\\n\\n    // ---------- STATE ----------\\n\\n    /// @notice Metadata base URI\\n    string public baseURI;\\n\\n    /// @notice Metadata URI suffix\\n    string public uriSuffix;\\n\\n    // ---------- CONSTRUCTOR ----------\\n\\n    /// @param owner Contract owner\\n    constructor(address owner) Owned(owner) {}\\n\\n    // ---------- METADATA ----------\\n\\n    /// @notice Get metadata URI\\n    /// @param id Token ID\\n    /// @return Metadata URI of token ID `id`\\n    function uri(uint256 id) public view override returns (string memory) {\\n        require(bytes(baseURI).length > 0, \\\"NO_METADATA\\\");\\n\\t\\treturn string(abi.encodePacked(baseURI, Strings.toString(id), uriSuffix));\\n    }\\n\\n    /// @notice Set metadata base URI\\n    /// @param _baseURI New metadata base URI\\n    /// @dev Doesn't emit URI event, because `id` argument isn't used\\n    function setBaseURI(string calldata _baseURI) public onlyOwner {\\n        baseURI = _baseURI;\\n    }\\n\\n    /// @notice Set metadata URI suffix\\n    /// @param _uriSuffix New metadata URI suffix\\n    /// @dev Doesn't emit URI event, because `id` argument isn't used\\n    function setURISuffix(string calldata _uriSuffix) public onlyOwner {\\n        uriSuffix = _uriSuffix;\\n    }\\n\\n    // ---------- APPROVAL ----------\\n\\n    /// @notice Grants or revokes permission to `operator` to transfer tokens\\n    /// @dev Only callable by contract owner\\n    /// @param operator Operator address\\n    /// @param approved Whether to grant or revoke permission\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public virtual override onlyOwner {\\n        isApprovedForAll[address(0)][operator] = approved;\\n\\n        emit ApprovalForAll(address(0), operator, approved);\\n    }\\n\\n    // ---------- TRANSFER ----------\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual override {\\n        require(isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Use assembly to perform optimized balance updates\\n        // Same balance updates in unoptimized Solidity:\\n        //\\n        // balanceOf[from][id] -= amount;\\n        // balanceOf[to][id] += amount;\\n        //\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Calculate the storage slot of `balanceOf[from]`\\n            // by concatenating the `from` address and the\\n            // slot of `balanceOf` in the scratch space used\\n            // by hashing methods, i.e. the first two 32 bytes\\n            // of memory. The keccak256 hash of the concatenated\\n            // values is the storage slot we're looking for.\\n            mstore(0x00, from)\\n            mstore(0x20, balanceOf.slot)\\n            let balanceOfFromSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate storage slot of `balanceOf[to]`\\n            mstore(0x00, to)\\n            // 0x20 still contains `balanceOf.slot`\\n            let balanceOfToSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate storage slot of `balanceOf[from][id]`\\n            mstore(0x00, id)\\n            mstore(0x20, balanceOfFromSlot)\\n            let amountFromSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate storage slot of `balanceOf[to][id]`\\n            // 0x00 still contains current id\\n            mstore(0x20, balanceOfToSlot)\\n            let amountToSlot := keccak256(0x00, 0x40)\\n\\n            // Load amount currently stored in `balanceOf[from][id]`\\n            let currentAmountFrom := sload(amountFromSlot)\\n            // Revert with message \\\"INSUFFICIENT_BALANCE\\\" if the\\n            // transfer amount is greater than the current amount\\n            // of `from` to prevent an integer underflow\\n            if gt(amount, currentAmountFrom) {\\n                let freeMemory := mload(0x40)\\n                // Store \\\"Error(string)\\\" signature\\n                mstore(freeMemory, _ERROR_FUNCTION_SIGNATURE)\\n                // Store data offset\\n                mstore(add(freeMemory, 0x04), 0x20)\\n                // Store length of revert string\\n                mstore(add(freeMemory, 0x24), _INSUFFICIENT_BALANCE_LENGTH)\\n                // Store revert string\\n                mstore(add(freeMemory, 0x44), _INSUFFICIENT_BALANCE_MESSAGE)\\n                revert(freeMemory, 0x64)\\n            }\\n            // Subtract transfer amount from current amount of `from`\\n            let newAmountFrom := sub(currentAmountFrom, amount)\\n\\n            // Load amount currently stored in `balanceOf[to][id]`\\n            let currentAmountTo := sload(amountToSlot)\\n            // Add transfer amount to current amount of `to`\\n            // Realistically this will never overflow\\n            let newAmountTo := add(currentAmountTo, amount)\\n\\n            // Store new amount of `from` in `balanceOf[from][id]`\\n            sstore(amountFromSlot, newAmountFrom)\\n            // Store new amount of `to` in `balanceOf[to][id]`\\n            sstore(amountToSlot, newAmountTo)\\n        }\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual override {\\n        require(isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        // Use assembly to perform optimized balance updates\\n        // Same balance updates in unoptimized Solidity:\\n        //\\n        // for (uint256 i = 0; i < ids.length; ++i) {\\n        //     uint256 id = ids[i];\\n        //     uint256 amount = amounts[i];\\n        //\\n        //     balanceOf[from][id] -= amount;\\n        //     balanceOf[to][id] += amount;\\n        // }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Calculate the storage slot of `balanceOf[from]`\\n            // by concatenating the `from` address and the\\n            // slot of `balanceOf` in the scratch space used\\n            // by hashing methods, i.e. the first two 32 bytes\\n            // of memory. The keccak256 hash of the concatenated\\n            // values is the storage slot we're looking for.\\n            mstore(0x00, from)\\n            mstore(0x20, balanceOf.slot)\\n            let balanceOfFromSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate storage slot of `balanceOf[to]`\\n            mstore(0x00, to)\\n            // 0x20 still contains `balanceOf.slot`\\n            let balanceOfToSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate length of arrays `ids` and `amounts` in bytes\\n            let arrayLength := mul(ids.length, 0x20)\\n\\n            // Loop over all values in `ids` and `amounts` by starting\\n            // with an index offset of 0 to access the first array element\\n            // and incrementing this index by 32 after each iteration to\\n            // access the next array element until the offset reaches the end\\n            // of the arrays, at which point all values the arrays contain\\n            // have been accessed\\n            for\\n                { let indexOffset := 0x00 }\\n                lt(indexOffset, arrayLength)\\n                { indexOffset := add(indexOffset, 0x20) }\\n            {\\n                // Load current array elements by adding offset of current\\n                // array index to start of each array's data area inside calldata\\n                let amount := calldataload(add(amounts.offset, indexOffset))\\n\\n                // Calculate storage slot of `balanceOf[from][id]`\\n                // Load current id from calldata into the first 32 bytes of memory\\n                mstore(0x00, calldataload(add(ids.offset, indexOffset)))\\n                mstore(0x20, balanceOfFromSlot)\\n                let amountFromSlot := keccak256(0x00, 0x40)\\n\\n                // Calculate storage slot of `balanceOf[to][id]`\\n                // 0x00 still contains current id\\n                mstore(0x20, balanceOfToSlot)\\n                let amountToSlot := keccak256(0x00, 0x40)\\n\\n                // Load amount currently stored in `balanceOf[from][id]`\\n                let currentAmountFrom := sload(amountFromSlot)\\n                // Revert with message \\\"INSUFFICIENT_BALANCE\\\" if the\\n                // transfer amount is greater than the current amount\\n                // of `from` to prevent an integer underflow\\n                if gt(amount, currentAmountFrom) {\\n                    let freeMemory := mload(0x40)\\n                    // Store \\\"Error(string)\\\" signature: bytes32(bytes4(keccak256(\\\"Error(string)\\\")))\\n                    mstore(freeMemory, _ERROR_FUNCTION_SIGNATURE)\\n                    // Store data offset\\n                    mstore(add(freeMemory, 0x04), 0x20)\\n                    // Store length of revert string\\n                    mstore(add(freeMemory, 0x24), _INSUFFICIENT_BALANCE_LENGTH)\\n                    // Store revert string\\n                    mstore(add(freeMemory, 0x44), _INSUFFICIENT_BALANCE_MESSAGE)\\n                    revert(freeMemory, 0x64)\\n                }\\n                // Subtract transfer amount from current amount of `from`\\n                let newAmountFrom := sub(currentAmountFrom, amount)\\n\\n                // Load amount currently stored in `balanceOf[to][id]`\\n                let currentAmountTo := sload(amountToSlot)\\n                // Add transfer amount to current amount of `to`\\n                // Realistically this will never overflow\\n                let newAmountTo := add(currentAmountTo, amount)\\n\\n                // Store new amount of `from` in `balanceOf[from][id]`\\n                sstore(amountFromSlot, newAmountFrom)\\n                // Store new amount of `to` in `balanceOf[to][id]`\\n                sstore(amountToSlot, newAmountTo)\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    // ---------- MINT ----------\\n\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount\\n    ) public {\\n        require(isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Realistically this will never overflow\\n        unchecked {\\n            balanceOf[to][id] += amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n    }\\n\\n    function mint(\\n        address[] calldata addresses,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) public {\\n        require(addresses.length == ids.length && ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        // Calculate array length in bytes\\n        uint256 arrayLength;\\n        unchecked {\\n            arrayLength = addresses.length * 0x20;\\n        }\\n\\n        for (uint256 indexOffset = 0x00; indexOffset < arrayLength;) {\\n            address addr;\\n            uint256 id;\\n            uint256 amount;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Load current array elements by adding offset of current\\n                // array index to start of each array's data area inside calldata\\n                addr := calldataload(add(addresses.offset, indexOffset))\\n                id := calldataload(add(ids.offset, indexOffset))\\n                amount := calldataload(add(amounts.offset, indexOffset))\\n\\n                // Increment index offset by 32 for next iteration\\n                indexOffset := add(indexOffset, 0x20)\\n            }\\n\\n            mint(addr, id, amount);\\n        }\\n    }\\n\\n    function safeMint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public {\\n        mint(to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function batchMint(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) public {\\n        require(isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        // Use assembly to perform optimized balance updates\\n        // Same balance updates in unoptimized Solidity:\\n        //\\n        // for (uint256 i = 0; i < ids.length; ++i) {\\n        //     uint256 id = ids[i];\\n        //     uint256 amount = amounts[i];\\n        //\\n        //     balanceOf[to][id] += amount;\\n        // }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Calculate the storage slot of `balanceOf[to]`\\n            // by concatenating the `to` address and the\\n            // slot of `balanceOf` in the scratch space used\\n            // by hashing methods, i.e. the first two 32 bytes\\n            // of memory. The keccak256 hash of the concatenated\\n            // values is the storage slot we're looking for.\\n            mstore(0x00, to)\\n            mstore(0x20, balanceOf.slot)\\n            let balanceOfToSlot := keccak256(0x00, 0x40)\\n\\n            // Store storage slot of `balanceOf[to]` in the second\\n            // 32 bytes of scratch space to later calculate the storage\\n            // slot of `balanceOf[to][id]` inside the loop\\n            mstore(0x20, balanceOfToSlot)\\n\\n            // Calculate length of arrays `ids` and `amounts` in bytes\\n            let arrayLength := mul(ids.length, 0x20)\\n\\n            // Loop over all values in `ids` and `amounts` by starting\\n            // with an index offset of 0 to access the first array element\\n            // and incrementing this index by 32 after each iteration to\\n            // access the next array element until the offset reaches the end\\n            // of the arrays, at which point all values the arrays contain\\n            // have been accessed\\n            for\\n                { let indexOffset := 0x00 }\\n                lt(indexOffset, arrayLength)\\n                { indexOffset := add(indexOffset, 0x20) }\\n            {\\n                // Load current array elements by adding offset of current\\n                // array index to start of each array's data area inside calldata\\n                let id := calldataload(add(ids.offset, indexOffset))\\n                let amount := calldataload(add(amounts.offset, indexOffset))\\n\\n                // Calculate storage slot of `balanceOf[to][id]`\\n                mstore(0x00, id)\\n                // 0x20 still contains `balanceOfToSlot`\\n                let amountToSlot := keccak256(0x00, 0x40)\\n\\n                // Load amount currently stored in `balanceOf[to][id]`\\n                let currentAmountTo := sload(amountToSlot)\\n\\n                // Add mint amount to current amount of `to`\\n                // Realistically this will never overflow\\n                let newAmountTo := add(currentAmountTo, amount)\\n\\n                // Store new amount in `balanceOf[to][id]`\\n                sstore(amountToSlot, newAmountTo)\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n    }\\n\\n    function batchMint(\\n        address[] calldata addresses,\\n        uint256[][] calldata ids,\\n        uint256[][] calldata amounts\\n    ) public {\\n        require(addresses.length == ids.length && ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < addresses.length;) {\\n            address addr;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Load current array element by adding offset of current\\n                // array index to start of array's data area inside calldata\\n                let indexOffset := mul(i, 0x20)\\n                addr := calldataload(add(addresses.offset, indexOffset))\\n            }\\n\\n            batchMint(addr, ids[i], amounts[i]);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function safeBatchMint(\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public {\\n        batchMint(to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    // ---------- BURN ----------\\n\\n    function burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Use assembly to perform optimized balance update\\n        // Same balance update in unoptimized Solidity:\\n        //\\n        // balanceOf[from][id] -= amount;\\n        //\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Calculate the storage slot of `balanceOf[from]`\\n            // by concatenating the `from` address and the\\n            // slot of `balanceOf` in the scratch space used\\n            // by hashing methods, i.e. the first two 32 bytes\\n            // of memory. The keccak256 hash of the concatenated\\n            // values is the storage slot we're looking for.\\n            mstore(0x00, from)\\n            mstore(0x20, balanceOf.slot)\\n            let balanceOfFromSlot := keccak256(0x00, 0x40)\\n\\n            // Calculate storage slot of `balanceOf[from][id]`\\n            mstore(0x00, id)\\n            mstore(0x20, balanceOfFromSlot)\\n            let amountFromSlot := keccak256(0x00, 0x40)\\n\\n            // Load amount currently stored in `balanceOf[from][id]`\\n            let currentAmountFrom := sload(amountFromSlot)\\n            // Revert with message \\\"INSUFFICIENT_BALANCE\\\" if the burn\\n            // amount is greater than the current amount of `from` to\\n            // prevent an integer underflow\\n            if gt(amount, currentAmountFrom) {\\n                let freeMemory := mload(0x40)\\n                // Store \\\"Error(string)\\\" signature: bytes32(bytes4(keccak256(\\\"Error(string)\\\")))\\n                mstore(freeMemory, _ERROR_FUNCTION_SIGNATURE)\\n                // Store data offset\\n                mstore(add(freeMemory, 0x04), 0x20)\\n                // Store length of revert string\\n                mstore(add(freeMemory, 0x24), _INSUFFICIENT_BALANCE_LENGTH)\\n                // Store revert string\\n                mstore(add(freeMemory, 0x44), _INSUFFICIENT_BALANCE_MESSAGE)\\n                revert(freeMemory, 0x64)\\n            }\\n            // Subtract burn amount from current amount of `from`\\n            let newAmountFrom := sub(currentAmountFrom, amount)\\n\\n            // Store new amount of `from` in `balanceOf[from][id]`\\n            sstore(amountFromSlot, newAmountFrom)\\n        }\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n\\n    function batchBurn(\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[address(0)][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        // Use assembly to perform optimized balance updates\\n        // Same balance updates in unoptimized Solidity:\\n        //\\n        // for (uint256 i = 0; i < ids.length; ++i) {\\n        //     uint256 id = ids[i];\\n        //     uint256 amount = amounts[i];\\n        //\\n        //     balanceOf[from][id] -= amount;\\n        // }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Calculate the storage slot of `balanceOf[from]`\\n            // by concatenating the `from` address and the\\n            // slot of `balanceOf` in the scratch space used\\n            // by hashing methods, i.e. the first two 32 bytes\\n            // of memory. The keccak256 hash of the concatenated\\n            // values is the storage slot we're looking for.\\n            mstore(0x00, from)\\n            mstore(0x20, balanceOf.slot)\\n            let balanceOfFromSlot := keccak256(0x00, 0x40)\\n\\n            // Store storage slot of `balanceOf[from]` in the second\\n            // 32 bytes of scratch space to later calculate the storage\\n            // slot of `balanceOf[from][id]` inside the loop\\n            mstore(0x20, balanceOfFromSlot)\\n\\n            // Calculate length of arrays `ids` and `amounts` in bytes\\n            let arrayLength := mul(ids.length, 0x20)\\n\\n            // Loop over all values in `ids` and `amounts` by starting\\n            // with an index offset of 0 to access the first array element\\n            // and incrementing this index by 32 after each iteration to\\n            // access the next array element until the offset reaches the end\\n            // of the arrays, at which point all values the arrays contain\\n            // have been accessed\\n            for\\n                { let indexOffset := 0x00 }\\n                lt(indexOffset, arrayLength)\\n                { indexOffset := add(indexOffset, 0x20) }\\n            {\\n                // Load current array elements by adding offset of current\\n                // array index to start of each array's data area inside calldata\\n                let id := calldataload(add(ids.offset, indexOffset))\\n                let amount := calldataload(add(amounts.offset, indexOffset))\\n\\n                // Calculate storage slot of `balanceOf[from][id]`\\n                mstore(0x00, id)\\n                // 0x20 still contains `balanceOfFromSlot`\\n                let amountFromSlot := keccak256(0x00, 0x40)\\n\\n                // Load amount currently stored in `balanceOf[from][id]`\\n                let currentAmountFrom := sload(amountFromSlot)\\n                // Revert with message \\\"INSUFFICIENT_BALANCE\\\" if the burn\\n                // amount is greater than the current amount of `from` to\\n                // prevent an integer underflow\\n                if gt(amount, currentAmountFrom) {\\n                    let freeMemory := mload(0x40)\\n                    // Store \\\"Error(string)\\\" signature: bytes32(bytes4(keccak256(\\\"Error(string)\\\")))\\n                    mstore(freeMemory, _ERROR_FUNCTION_SIGNATURE)\\n                    // Store data offset\\n                    mstore(add(freeMemory, 0x04), 0x20)\\n                    // Store length of revert string\\n                    mstore(add(freeMemory, 0x24), _INSUFFICIENT_BALANCE_LENGTH)\\n                    // Store revert string\\n                    mstore(add(freeMemory, 0x44), _INSUFFICIENT_BALANCE_MESSAGE)\\n                    revert(freeMemory, 0x64)\\n                }\\n                // Subtract burn amount from current amount of `from`\\n                let newAmountFrom := sub(currentAmountFrom, amount)\\n\\n                // Store new amount of `from` in `balanceOf[from][id]`\\n                sstore(amountFromSlot, newAmountFrom)\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/// @notice Simple contract ownership module\\n/// @author Solarbots (https://solarbots.io)\\nabstract contract Owned {\\n    address public owner;\\n\\n    event OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"NOT_OWNER\\\");\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransfer(address(0), _owner);\\n    }\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"INVALID_OWNER\\\");\\n\\n        owner = newOwner;\\n\\n        emit OwnershipTransfer(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"script/=script/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchBurn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"ids\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256[][]\",\"name\":\"amounts\",\"type\":\"uint256[][]\"}],\"name\":\"batchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriSuffix\",\"type\":\"string\"}],\"name\":\"setURISuffix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriSuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Achievements", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000005a5fe90cd115d691ee99d90d3607f7005ea817e5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}