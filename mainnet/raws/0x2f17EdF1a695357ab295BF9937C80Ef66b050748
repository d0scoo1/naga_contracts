{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Base64.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides a set of functions to operate with Base64 strings.\\n *\\n * _Available since v4.5._\\n */\\nlibrary Base64 {\\n    /**\\n     * @dev Base64 Encoding/Decoding Table\\n     */\\n    string internal constant _TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /**\\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\\n     */\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        /**\\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\\n         */\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // Loads the table into memory\\n        string memory table = _TABLE;\\n\\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\\n        // and split into 4 numbers of 6 bits.\\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\\n        // - `data.length + 2`  -> Round up\\n        // - `/ 3`              -> Number of 3-bytes chunks\\n        // - `4 *`              -> 4 characters for each chunk\\n        string memory result = new string(4 * ((data.length + 2) / 3));\\n\\n        assembly {\\n            // Prepare the lookup table (skip the first \\\"length\\\" byte)\\n            let tablePtr := add(table, 1)\\n\\n            // Prepare result pointer, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // Run over the input, 3 bytes at a time\\n            for {\\n                let dataPtr := data\\n                let endPtr := add(data, mload(data))\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                // Advance 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // To write each character, shift the 3 bytes (18 bits) chunk\\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\\n                // and apply logical AND with 0x3F which is the number of\\n                // the previous character in the ASCII table prior to the Base64 Table\\n                // The result is then added to the table to get the character to write,\\n                // and finally write it in the result pointer but with a left shift\\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n\\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\\n                resultPtr := add(resultPtr, 1) // Advance\\n            }\\n\\n            // When data `bytes` is not exactly 3 bytes long\\n            // it is padded with `=` characters at the end\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n                mstore8(sub(resultPtr, 2), 0x3d)\\n            }\\n            case 2 {\\n                mstore8(sub(resultPtr, 1), 0x3d)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/interfaces/ISVGTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ISVG image library types interface\\n/// @dev Allows Solidity files to reference the library's input and return types without referencing the library itself\\ninterface ISVGTypes {\\n\\n\\t/// Represents a color in RGB format with alpha\\n\\tstruct Color {\\n\\t\\tuint8 red;\\n\\t\\tuint8 green;\\n\\t\\tuint8 blue;\\n\\t\\tuint8 alpha;\\n\\t}\\n\\n\\t/// Represents a color attribute in an SVG image file\\n\\tenum ColorAttribute {\\n\\t\\tFill, Stroke, Stop\\n\\t}\\n\\n\\t/// Represents the kind of color attribute in an SVG image file\\n\\tenum ColorAttributeKind {\\n\\t\\tRGB, URL\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/utils/OnChain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Base64.sol\\\";\\n\\n/// @title OnChain metadata support library\\n/**\\n* @dev These methods are best suited towards view/pure only function calls (ALL the way through the call stack).\\n* Do not waste gas using these methods in functions that also update state, unless your need requires it.\\n*/\\nlibrary OnChain {\\n\\n\\t/// Returns the prefix needed for a base64-encoded on chain svg image\\n\\tfunction baseSvgImageURI() internal pure returns (bytes memory) {\\n\\t\\treturn \\\"data:image/svg+xml;base64,\\\";\\n\\t}\\n\\n\\t/// Returns the prefix needed for a base64-encoded on chain nft metadata\\n\\tfunction baseURI() internal pure returns (bytes memory) {\\n\\t\\treturn \\\"data:application/json;base64,\\\";\\n\\t}\\n\\n\\t/// Returns the contents joined with a comma between them\\n\\t/// @param contents1 The first content to join\\n\\t/// @param contents2 The second content to join\\n\\t/// @return A collection of bytes that represent all contents joined with a comma\\n\\tfunction commaSeparated(bytes memory contents1, bytes memory contents2) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(contents1, continuesWith(contents2));\\n\\t}\\n\\n\\t/// Returns the contents joined with commas between them\\n\\t/// @param contents1 The first content to join\\n\\t/// @param contents2 The second content to join\\n\\t/// @param contents3 The third content to join\\n\\t/// @return A collection of bytes that represent all contents joined with commas\\n\\tfunction commaSeparated(bytes memory contents1, bytes memory contents2, bytes memory contents3) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(commaSeparated(contents1, contents2), continuesWith(contents3));\\n\\t}\\n\\n\\t/// Returns the contents joined with commas between them\\n\\t/// @param contents1 The first content to join\\n\\t/// @param contents2 The second content to join\\n\\t/// @param contents3 The third content to join\\n\\t/// @param contents4 The fourth content to join\\n\\t/// @return A collection of bytes that represent all contents joined with commas\\n\\tfunction commaSeparated(bytes memory contents1, bytes memory contents2, bytes memory contents3, bytes memory contents4) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(commaSeparated(contents1, contents2, contents3), continuesWith(contents4));\\n\\t}\\n\\n\\t/// Returns the contents joined with commas between them\\n\\t/// @param contents1 The first content to join\\n\\t/// @param contents2 The second content to join\\n\\t/// @param contents3 The third content to join\\n\\t/// @param contents4 The fourth content to join\\n\\t/// @param contents5 The fifth content to join\\n\\t/// @return A collection of bytes that represent all contents joined with commas\\n\\tfunction commaSeparated(bytes memory contents1, bytes memory contents2, bytes memory contents3, bytes memory contents4, bytes memory contents5) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(commaSeparated(contents1, contents2, contents3, contents4), continuesWith(contents5));\\n\\t}\\n\\n\\t/// Returns the contents joined with commas between them\\n\\t/// @param contents1 The first content to join\\n\\t/// @param contents2 The second content to join\\n\\t/// @param contents3 The third content to join\\n\\t/// @param contents4 The fourth content to join\\n\\t/// @param contents5 The fifth content to join\\n\\t/// @param contents6 The sixth content to join\\n\\t/// @return A collection of bytes that represent all contents joined with commas\\n\\tfunction commaSeparated(bytes memory contents1, bytes memory contents2, bytes memory contents3, bytes memory contents4, bytes memory contents5, bytes memory contents6) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(commaSeparated(contents1, contents2, contents3, contents4, contents5), continuesWith(contents6));\\n\\t}\\n\\n\\t/// Returns the contents prefixed by a comma\\n\\t/// @dev This is used to append multiple attributes into the json\\n\\t/// @param contents The contents with which to prefix\\n\\t/// @return A bytes collection of the contents prefixed with a comma\\n\\tfunction continuesWith(bytes memory contents) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\",\\\", contents);\\n\\t}\\n\\n\\t/// Returns the contents wrapped in a json dictionary\\n\\t/// @param contents The contents with which to wrap\\n\\t/// @return A bytes collection of the contents wrapped as a json dictionary\\n\\tfunction dictionary(bytes memory contents) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"{\\\", contents, \\\"}\\\");\\n\\t}\\n\\n\\t/// Returns an unwrapped key/value pair where the value is an array\\n\\t/// @param key The name of the key used in the pair\\n\\t/// @param value The value of pair, as an array\\n\\t/// @return A bytes collection that is suitable for inclusion in a larger dictionary\\n\\tfunction keyValueArray(string memory key, bytes memory value) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"\\\\\\\"\\\", key, \\\"\\\\\\\":[\\\", value, \\\"]\\\");\\n\\t}\\n\\n\\t/// Returns an unwrapped key/value pair where the value is a string\\n\\t/// @param key The name of the key used in the pair\\n\\t/// @param value The value of pair, as a string\\n\\t/// @return A bytes collection that is suitable for inclusion in a larger dictionary\\n\\tfunction keyValueString(string memory key, bytes memory value) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"\\\\\\\"\\\", key, \\\"\\\\\\\":\\\\\\\"\\\", value, \\\"\\\\\\\"\\\");\\n\\t}\\n\\n\\t/// Encodes an SVG as base64 and prefixes it with a URI scheme suitable for on-chain data\\n\\t/// @param svg The contents of the svg\\n\\t/// @return A bytes collection that may be added to the \\\"image\\\" key/value pair in ERC-721 or ERC-1155 metadata\\n\\tfunction svgImageURI(bytes memory svg) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(baseSvgImageURI(), Base64.encode(svg));\\n\\t}\\n\\n\\t/// Encodes json as base64 and prefixes it with a URI scheme suitable for on-chain data\\n\\t/// @param metadata The contents of the metadata\\n\\t/// @return A bytes collection that may be returned as the tokenURI in a ERC-721 or ERC-1155 contract\\n\\tfunction tokenURI(bytes memory metadata) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(baseURI(), Base64.encode(metadata));\\n\\t}\\n\\n\\t/// Returns the json dictionary of a single trait attribute for an ERC-721 or ERC-1155 NFT\\n\\t/// @param name The name of the trait\\n\\t/// @param value The value of the trait\\n\\t/// @return A collection of bytes that can be embedded within a larger array of attributes\\n\\tfunction traitAttribute(string memory name, bytes memory value) internal pure returns (bytes memory) {\\n\\t\\treturn dictionary(commaSeparated(\\n\\t\\t\\tkeyValueString(\\\"trait_type\\\", bytes(name)),\\n\\t\\t\\tkeyValueString(\\\"value\\\", value)\\n\\t\\t));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/utils/SVG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"../interfaces/ISVGTypes.sol\\\";\\nimport \\\"./OnChain.sol\\\";\\nimport \\\"./SVGErrors.sol\\\";\\n\\n/// @title SVG image library\\n/**\\n* @dev These methods are best suited towards view/pure only function calls (ALL the way through the call stack).\\n* Do not waste gas using these methods in functions that also update state, unless your need requires it.\\n*/\\nlibrary SVG {\\n\\n\\tusing Strings for uint256;\\n\\n\\t/// Returns a named element based on the supplied attributes and contents\\n\\t/// @dev attributes and contents is usually generated from abi.encodePacked, attributes is expecting a leading space\\n\\t/// @param name The name of the element\\n\\t/// @param attributes The attributes of the element, as bytes, with a leading space\\n\\t/// @param contents The contents of the element, as bytes\\n\\t/// @return a bytes collection representing the whole element\\n\\tfunction createElement(string memory name, bytes memory attributes, bytes memory contents) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\n\\t\\t\\t\\\"<\\\", attributes.length == 0 ? bytes(name) : abi.encodePacked(name, attributes),\\n\\t\\t\\tcontents.length == 0 ? bytes(\\\"/>\\\") : abi.encodePacked(\\\">\\\", contents, \\\"</\\\", name, \\\">\\\")\\n\\t\\t);\\n\\t}\\n\\n\\t/// Returns the root SVG attributes based on the supplied width and height\\n\\t/// @dev includes necessary leading space for createElement's `attributes` parameter\\n\\t/// @param width The width of the SVG view box\\n\\t/// @param height The height of the SVG view box\\n\\t/// @return a bytes collection representing the root SVG attributes, including a leading space\\n\\tfunction svgAttributes(uint256 width, uint256 height) internal pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\" viewBox='0 0 \\\", width.toString(), \\\" \\\", height.toString(), \\\"' xmlns='http://www.w3.org/2000/svg'\\\");\\n\\t}\\n\\n\\t/// Returns an RGB bytes collection suitable as an attribute for SVG elements based on the supplied Color and ColorType\\n\\t/// @dev includes necessary leading space for all types _except_ None\\n\\t/// @param attribute The `ISVGTypes.ColorAttribute` of the desired attribute\\n\\t/// @param value The converted color value as bytes\\n\\t/// @return a bytes collection representing a color attribute in an SVG element\\n\\tfunction colorAttribute(ISVGTypes.ColorAttribute attribute, bytes memory value) internal pure returns (bytes memory) {\\n\\t\\tif (attribute == ISVGTypes.ColorAttribute.Fill) return _attribute(\\\"fill\\\", value);\\n\\t\\tif (attribute == ISVGTypes.ColorAttribute.Stop) return _attribute(\\\"stop-color\\\", value);\\n\\t\\treturn  _attribute(\\\"stroke\\\", value); // Fallback to Stroke\\n\\t}\\n\\n\\t/// Returns an RGB color attribute value\\n\\t/// @param color The `ISVGTypes.Color` of the color\\n\\t/// @return a bytes collection representing the url attribute value\\n\\tfunction colorAttributeRGBValue(ISVGTypes.Color memory color) internal pure returns (bytes memory) {\\n\\t\\treturn _colorValue(ISVGTypes.ColorAttributeKind.RGB, OnChain.commaSeparated(\\n\\t\\t\\tbytes(uint256(color.red).toString()),\\n\\t\\t\\tbytes(uint256(color.green).toString()),\\n\\t\\t\\tbytes(uint256(color.blue).toString())\\n\\t\\t));\\n\\t}\\n\\n\\t/// Returns a URL color attribute value\\n\\t/// @param url The url to the color\\n\\t/// @return a bytes collection representing the url attribute value\\n\\tfunction colorAttributeURLValue(bytes memory url) internal pure returns (bytes memory) {\\n\\t\\treturn _colorValue(ISVGTypes.ColorAttributeKind.URL, url);\\n\\t}\\n\\n\\t/// Returns an `ISVGTypes.Color` that is brightened by the provided percentage\\n\\t/// @param source The `ISVGTypes.Color` to brighten\\n\\t/// @param percentage The percentage of brightness to apply\\n\\t/// @param minimumBump A minimum increase for each channel to ensure dark Colors also brighten\\n\\t/// @return color the brightened `ISVGTypes.Color`\\n\\tfunction brightenColor(ISVGTypes.Color memory source, uint32 percentage, uint8 minimumBump) internal pure returns (ISVGTypes.Color memory color) {\\n\\t\\tcolor.red = _brightenComponent(source.red, percentage, minimumBump);\\n\\t\\tcolor.green = _brightenComponent(source.green, percentage, minimumBump);\\n\\t\\tcolor.blue = _brightenComponent(source.blue, percentage, minimumBump);\\n\\t\\tcolor.alpha = source.alpha;\\n\\t}\\n\\n\\t/// Returns an `ISVGTypes.Color` based on a packed representation of r, g, and b\\n\\t/// @notice Useful for code where you want to utilize rgb hex values provided by a designer (e.g. #835525)\\n\\t/// @dev Alpha will be hard-coded to 100% opacity\\n\\t/// @param packedColor The `ISVGTypes.Color` to convert, e.g. 0x835525\\n\\t/// @return color representing the packed input\\n\\tfunction fromPackedColor(uint24 packedColor) internal pure returns (ISVGTypes.Color memory color) {\\n\\t\\tcolor.red = uint8(packedColor >> 16);\\n\\t\\tcolor.green = uint8(packedColor >> 8);\\n\\t\\tcolor.blue = uint8(packedColor);\\n\\t\\tcolor.alpha = 0xFF;\\n\\t}\\n\\n\\t/// Returns a mixed Color by balancing the ratio of `color1` over `color2`, with a total percentage (for overmixing and undermixing outside the source bounds)\\n\\t/// @dev Reverts with `RatioInvalid()` if `ratioPercentage` is > 100\\n\\t/// @param color1 The first `ISVGTypes.Color` to mix\\n\\t/// @param color2 The second `ISVGTypes.Color` to mix\\n\\t/// @param ratioPercentage The percentage ratio of `color1` over `color2` (e.g. 60 = 60% first, 40% second)\\n\\t/// @param totalPercentage The total percentage after mixing (for overmixing and undermixing outside the input colors)\\n\\t/// @return color representing the result of the mixture\\n\\tfunction mixColors(ISVGTypes.Color memory color1, ISVGTypes.Color memory color2, uint32 ratioPercentage, uint32 totalPercentage) internal pure returns (ISVGTypes.Color memory color) {\\n\\t\\tif (ratioPercentage > 100) revert RatioInvalid();\\n\\t\\tcolor.red = _mixComponents(color1.red, color2.red, ratioPercentage, totalPercentage);\\n\\t\\tcolor.green = _mixComponents(color1.green, color2.green, ratioPercentage, totalPercentage);\\n\\t\\tcolor.blue = _mixComponents(color1.blue, color2.blue, ratioPercentage, totalPercentage);\\n\\t\\tcolor.alpha = _mixComponents(color1.alpha, color2.alpha, ratioPercentage, totalPercentage);\\n\\t}\\n\\n\\t/// Returns a proportionally-randomized Color between the start and stop colors using a random Color seed\\n\\t/// @dev Each component (r,g,b) will move proportionally together in the direction from start to stop\\n\\t/// @param start The starting bound of the `ISVGTypes.Color` to randomize\\n\\t/// @param stop The stopping bound of the `ISVGTypes.Color` to randomize\\n\\t/// @param random An `ISVGTypes.Color` to use as a seed for randomization\\n\\t/// @return color representing the result of the randomization\\n\\tfunction randomizeColors(ISVGTypes.Color memory start, ISVGTypes.Color memory stop, ISVGTypes.Color memory random) internal pure returns (ISVGTypes.Color memory color) {\\n\\t\\tuint16 percent = uint16((1320 * (uint(random.red) + uint(random.green) + uint(random.blue)) / 10000) % 101); // Range is from 0-100\\n\\t\\tcolor.red = _randomizeComponent(start.red, stop.red, random.red, percent);\\n\\t\\tcolor.green = _randomizeComponent(start.green, stop.green, random.green, percent);\\n\\t\\tcolor.blue = _randomizeComponent(start.blue, stop.blue, random.blue, percent);\\n\\t\\tcolor.alpha = 0xFF;\\n\\t}\\n\\n\\tfunction _attribute(bytes memory name, bytes memory contents) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\" \\\", name, \\\"='\\\", contents, \\\"'\\\");\\n\\t}\\n\\n\\tfunction _brightenComponent(uint8 component, uint32 percentage, uint8 minimumBump) private pure returns (uint8 result) {\\n\\t\\tuint32 wideComponent = uint32(component);\\n\\t\\tuint32 brightenedComponent = wideComponent * (percentage + 100) / 100;\\n\\t\\tuint32 wideMinimumBump = uint32(minimumBump);\\n\\t\\tif (brightenedComponent - wideComponent < wideMinimumBump) {\\n\\t\\t\\tbrightenedComponent = wideComponent + wideMinimumBump;\\n\\t\\t}\\n\\t\\tif (brightenedComponent > 0xFF) {\\n\\t\\t\\tresult = 0xFF; // Clamp to 8 bits\\n\\t\\t} else {\\n\\t\\t\\tresult = uint8(brightenedComponent);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _colorValue(ISVGTypes.ColorAttributeKind attributeKind, bytes memory contents) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(attributeKind == ISVGTypes.ColorAttributeKind.RGB ? \\\"rgb(\\\" : \\\"url(#\\\", contents, \\\")\\\");\\n\\t}\\n\\n\\tfunction _mixComponents(uint8 component1, uint8 component2, uint32 ratioPercentage, uint32 totalPercentage) private pure returns (uint8 component) {\\n\\t\\tuint32 mixedComponent = (uint32(component1) * ratioPercentage + uint32(component2) * (100 - ratioPercentage)) * totalPercentage / 10000;\\n\\t\\tif (mixedComponent > 0xFF) {\\n\\t\\t\\tcomponent = 0xFF; // Clamp to 8 bits\\n\\t\\t} else {\\n\\t\\t\\tcomponent = uint8(mixedComponent);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _randomizeComponent(uint8 start, uint8 stop, uint8 random, uint16 percent) private pure returns (uint8 component) {\\n\\t\\tif (start == stop) {\\n\\t\\t\\tcomponent = start;\\n\\t\\t} else { // This is the standard case\\n\\t\\t\\t(uint8 floor, uint8 ceiling) = start < stop ? (start, stop) : (stop, start);\\n\\t\\t\\tcomponent = floor + uint8(uint16(ceiling - (random & 0x01) - floor) * percent / uint16(100));\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@theappstudio/solidity/contracts/utils/SVGErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @dev When the ratio percentage provided to a function is > 100\\nerror RatioInvalid();\\n\"\r\n    },\r\n    \"contracts/interfaces/IMetadataProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"./ITicTacToe.sol\\\";\\n\\n/// @title Provides the on-chain metadata (including svg image) to the contract\\n/// @dev Supports the ERC-721 contract\\ninterface IMetadataProvider is IERC165 {\\n\\n\\t/// Represents the utf-8 string of the contract's player in the output image\\n\\tfunction contractSymbol() external returns (string memory);\\n\\n\\t/// @dev Returns the on-chain ERC-721 metadata for a TicTacToe game given its GameUtils.GameInfo structure and tokenId\\n\\t/// @param game The game's state structure\\n\\t/// @param tokenId The game's Token Id\\n\\t/// @return The raw json uri as a string\\n\\tfunction metadata(ITicTacToe.Game memory game, uint256 tokenId) external view returns (string memory);\\n\\n\\t/// Represents the utf-8 string of the owner's player in the output image\\n\\tfunction ownerSymbol() external returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITicTacToe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title ITicTacToe interface\\ninterface ITicTacToe {\\n\\n\\t/// Represents the state of a Game\\n\\tenum GameState {\\n\\t\\tInPlay, OwnerWon, ContractWon, Tie\\n\\t}\\n\\n\\t/// Contains aggregated information about game results\\n\\tstruct GameHistory {\\n\\t\\tuint32 wins;\\n\\t\\tuint32 losses;\\n\\t\\tuint32 ties;\\n\\t\\tuint32 restarts;\\n\\t}\\n\\n\\t/// Contains information about a TicTacToe game\\n\\tstruct Game {\\n\\t\\tuint8[] moves;\\n\\t\\tGameState state;\\n\\t\\tGameHistory history;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GameConnector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/// @title GameConnector\\nabstract contract GameConnector is Ownable, IERC165 {\\n\\n\\t/// @dev Wen the caller is not allowed\\n\\terror CallerNotAllowed();\\n\\n\\t/// @dev The address to the game;\\n\\tmapping(address => bool) private _allowedCallers;\\n\\n\\t/// Assigns the address to the mapping of allowed callers\\n\\t/// @dev If assigning allowed to address(0), anyone may call the `onlyAllowedCallers` functions\\n\\t/// @param caller The address of the caller with which to assign allowed\\n\\t/// @param allowed Whether the `caller` will be allowed to call `onlyAllowedCallers` functions\\n\\tfunction assignAllowedCaller(address caller, bool allowed) external onlyOwner {\\n\\t\\tif (allowed) {\\n\\t\\t\\t_allowedCallers[caller] = allowed;\\n\\t\\t} else {\\n\\t\\t\\tdelete _allowedCallers[caller];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Prevents a function from executing if not called by an allowed caller\\n\\tmodifier onlyAllowedCallers() {\\n\\t\\tif (!_allowedCallers[_msgSender()] && !_allowedCallers[address(0)]) revert CallerNotAllowed();\\n\\t\\t_;\\n\\t}\\n\\n\\t/// @inheritdoc IERC165\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\\n\\t\\treturn interfaceId == type(IERC165).interfaceId;\\n\\t}\\n\\n\\t/// @inheritdoc Ownable\\n\\tfunction transferOwnership(address newOwner) public virtual override {\\n\\t\\tif (newOwner != owner()) {\\n\\t\\t\\tdelete _allowedCallers[owner()];\\n\\t\\t}\\n\\t\\tsuper.transferOwnership(newOwner);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/GameUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"../interfaces/ITicTacToe.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\n\\n/// @title GameUtils\\nlibrary GameUtils {\\n\\n\\t/// @dev When the player attempts a change that is not valid for the current GameState\\n\\terror InvalidGameState();\\n\\n\\t/// @dev When the player attempts to make an invalid move\\n\\terror InvalidMove();\\n\\n\\t/// @dev When a player attempts to make multiple moves within the same block for the same game\\n\\terror NoMagic();\\n\\n\\t/// Represents one of the game players\\n\\tenum GamePlayer {\\n\\t\\tContract, Owner\\n\\t}\\n\\n\\t/// Represents the storage of a game, suitable for the contract to make choices\\n\\tstruct GameInfo {\\n\\t\\tITicTacToe.GameState state;\\n\\t\\tuint8 moves;\\n\\t\\tuint8[9] board;\\n\\t\\tuint40 blockNumber; // The block number of the last move. To save gas, not updated on a win/lose/tie\\n\\t\\tITicTacToe.GameHistory history;\\n\\t}\\n\\n\\t/// @dev Constant for reporting an invalid index\\n\\tuint256 internal constant INVALID_MOVE_INDEX = 0xFF;\\n\\n\\t/// Returns whether the bits under test match the bits being tested for\\n\\t/// @param bits The bits to test\\n\\t/// @param matchBits The bits being tested for\\n\\t/// @return Whether the bits under test match the bits being tested for\\n\\tfunction bitsMatch(uint256 bits, uint256 matchBits) internal pure returns (bool) {\\n\\t\\treturn (bits & matchBits) == matchBits;\\n\\t}\\n\\n\\t/// Returns an ITicTacToe.Game from the supplied GameInfo\\n\\t/// @param gameInfo The GameInfo structure to convert\\n\\t/// @return game The converted Game structure\\n\\tfunction gameFromGameInfo(GameInfo memory gameInfo) internal pure returns (ITicTacToe.Game memory game) {\\n\\t\\tgame.state = gameInfo.state;\\n\\t\\tgame.history = gameInfo.history;\\n\\t\\tgame.moves = new uint8[](gameInfo.moves);\\n\\t\\tfor (uint256 move = 0; move < gameInfo.moves; move++) {\\n\\t\\t\\tgame.moves[move] = gameInfo.board[move];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Returns an GameInfo from the supplied ITicTacToe.Game\\n\\t/// @param game The ITicTacToe.Game structure to convert\\n\\t/// @return gameInfo The converted GameInfo structure\\n\\tfunction gameInfoFromGame(ITicTacToe.Game memory game) internal pure returns (GameInfo memory gameInfo) {\\n\\t\\tgameInfo.state = game.state;\\n\\t\\tgameInfo.history = game.history;\\n\\t\\tgameInfo.moves = uint8(game.moves.length);\\n\\t\\tfor (uint256 move = 0; move < game.moves.length; move++) {\\n\\t\\t\\tgameInfo.board[move] = game.moves[move];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Returns the index of the desired position in the GameInfo's board array\\n\\t/// @param gameInfo The GameInfo to examine\\n\\t/// @param position The position to search\\n\\t/// @return The index within the board array of the result, or `INVALID_MOVE_INDEX` if not found\\n\\tfunction indexOfPosition(GameInfo memory gameInfo, uint256 position) internal pure returns (uint256) {\\n\\t\\tfor (uint256 index = gameInfo.moves; index < gameInfo.board.length; index++) {\\n\\t\\t\\tif (position == gameInfo.board[index]) {\\n\\t\\t\\t\\treturn index;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn INVALID_MOVE_INDEX;\\n\\t}\\n\\n\\t/// Returns a new initialized GameUtils.GameInfo struct using the existing GameHistory\\n\\t/// @param history The history of games to attach to the new instance\\n\\t/// @param seed An initial seed for the contract's first move\\n\\t/// @param blockNumber A optional value to use as the initial block number, which will be collapsed to uint40\\n\\t/// @return A new intitialzed GameUtils.GameInfo struct\\n\\tfunction initializeGame(ITicTacToe.GameHistory memory history, uint256 seed, uint256 blockNumber) internal pure returns (GameUtils.GameInfo memory) {\\n\\t\\tuint8 firstMove = uint8(seed % 9);\\n\\t\\tuint8[9] memory board;\\n\\t\\tboard[0] = firstMove;\\n\\t\\tfor (uint256 i = 1; i < 9; i++) {\\n\\t\\t\\tboard[i] = i <= firstMove ? uint8(i-1) : uint8(i);\\n\\t\\t}\\n\\t\\treturn GameUtils.GameInfo(ITicTacToe.GameState.InPlay, 1, board, uint40(blockNumber), history);\\n\\t}\\n\\n\\t/// Returns the bits representing the player's moves\\n\\t/// @param gameInfo The GameInfo structure\\n\\t/// @param gamePlayer The GamePlayer for which to generate the map\\n\\t/// @return map A single integer value representing a bitmap of the player's moves\\n\\tfunction mapForPlayer(GameInfo memory gameInfo, GamePlayer gamePlayer) internal pure returns (uint256 map) {\\n\\t\\t// These are the bits for each board position\\n\\t\\tuint16[9] memory positionsToBits = [256, 128, 64, 32, 16, 8, 4, 2, 1];\\n\\t\\tfor (uint256 index = uint256(gamePlayer); index < gameInfo.moves; index += 2) {\\n\\t\\t\\tuint256 position = gameInfo.board[index];\\n\\t\\t\\tmap += positionsToBits[position];\\n\\t\\t}\\n\\t}\\n\\n\\t/// Updates the GameInfo structure based on the positionIndex being moved\\n\\t/// @param gameInfo The GameInfo structure\\n\\t/// @param positionIndex The index within the board array representing the desired move\\n\\tfunction performMove(GameInfo memory gameInfo, uint256 positionIndex) internal pure {\\n\\t\\tuint8 movePosition = gameInfo.moves & 0x0F;\\n\\t\\tuint8 nextPosition = gameInfo.board[positionIndex];\\n\\t\\tgameInfo.board[positionIndex] = gameInfo.board[movePosition];\\n\\t\\tgameInfo.board[movePosition] = nextPosition;\\n\\t\\tgameInfo.moves += 1;\\n\\t}\\n\\n\\t/// Returns whether the player has won based on its playerMap\\n\\t/// @param playerMap The bitmap of the player's moves\\n\\t/// @return Whether the bitmap represents a winning game\\n\\tfunction playerHasWon(uint256 playerMap) internal pure returns (bool) {\\n\\t\\t// These are winning boards when bits are combined\\n\\t\\tuint16[8] memory winningBits = [448, 292, 273, 146, 84, 73, 56, 7];\\n\\t\\tfor (uint256 index = 0; index < winningBits.length; index++) {\\n\\t\\t\\tif (bitsMatch(playerMap, winningBits[index])) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n\\t/// Processes a move on an incoming GameInfo structure and returns a resulting GameInfo structure\\n\\t/// @param gameInfo The incoming GameInfo structure\\n\\t/// @param position The player's attempted move\\n\\t/// @param seed A seed used for randomness\\n\\t/// @return A resulting GameInfo structure that may also include the contract's move if the game continues\\n\\tfunction processMove(GameUtils.GameInfo memory gameInfo, uint256 position, uint256 seed) internal view returns (GameUtils.GameInfo memory) {\\n\\t\\tif (gameInfo.state != ITicTacToe.GameState.InPlay) revert InvalidGameState();\\n\\t\\t// console.log(\\\"block number %d vs %d\\\", gameInfo.blockNumber, block.number);\\n\\t\\tif (gameInfo.blockNumber >= block.number) revert NoMagic();\\n\\t\\tuint256 positionIndex = indexOfPosition(gameInfo, position);\\n\\t\\tif (positionIndex == INVALID_MOVE_INDEX) revert InvalidMove();\\n\\t\\t// console.log(\\\"Playing position:\\\", position); //, positionIndex, gameInfo.moves);\\n\\t\\tperformMove(gameInfo, positionIndex);\\n\\n\\t\\tif (gameInfo.moves < 4) { // No chance of winning just yet\\n\\t\\t\\tuint256 openSlot = uint8(seed % (9 - gameInfo.moves));\\n\\t\\t\\t// console.log(\\\" - random move:\\\", gameInfo.board[openSlot + gameInfo.moves]);\\n\\t\\t\\tperformMove(gameInfo, openSlot + gameInfo.moves);\\n\\t\\t\\tgameInfo.blockNumber = uint40(block.number);\\n\\t\\t} else /* if (gameInfo.moves < 9) */ { // Owner or Contract may win\\n\\t\\t\\tuint256 ownerMap = mapForPlayer(gameInfo, GamePlayer.Owner);\\n\\t\\t\\tif (playerHasWon(ownerMap)) {\\n\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.OwnerWon;\\n\\t\\t\\t\\tgameInfo.history.wins += 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbool needsMove = true;\\n\\t\\t\\t\\tuint256 contractMap = mapForPlayer(gameInfo, GamePlayer.Contract);\\n\\t\\t\\t\\t// If the Contract has an imminent win, take it.\\n\\t\\t\\t\\tfor (uint256 openSlot = gameInfo.moves; openSlot < 9; openSlot++) {\\n\\t\\t\\t\\t\\tif (winableMove(contractMap, gameInfo.board[openSlot])) {\\n\\t\\t\\t\\t\\t\\t// console.log(\\\" - seizing move:\\\", gameInfo.board[openSlot]); //, gameInfo.moves);\\n\\t\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot);\\n\\t\\t\\t\\t\\t\\tneedsMove = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (needsMove) {\\n\\t\\t\\t\\t\\t// If the Owner has an imminent win, block it.\\n\\t\\t\\t\\t\\tfor (uint256 openSlot = gameInfo.moves; openSlot < 9; openSlot++) {\\n\\t\\t\\t\\t\\t\\tif (winableMove(ownerMap, gameInfo.board[openSlot])) {\\n\\t\\t\\t\\t\\t\\t\\t// console.log(\\\" - blocking move:\\\", gameInfo.board[openSlot]); //, gameInfo.moves);\\n\\t\\t\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot);\\n\\t\\t\\t\\t\\t\\t\\tneedsMove = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (needsMove) {\\n\\t\\t\\t\\t\\tuint256 openSlot = uint8(seed % (9 - gameInfo.moves));\\n\\t\\t\\t\\t\\t// console.log(\\\" - random move:\\\", gameInfo.board[openSlot + gameInfo.moves]);\\n\\t\\t\\t\\t\\tperformMove(gameInfo, openSlot + gameInfo.moves);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (playerHasWon(mapForPlayer(gameInfo, GamePlayer.Contract))) {\\n\\t\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.ContractWon;\\n\\t\\t\\t\\t\\tgameInfo.history.losses += 1;\\n\\t\\t\\t\\t} else if (gameInfo.moves > 8) {\\n\\t\\t\\t\\t\\tgameInfo.state = ITicTacToe.GameState.Tie;\\n\\t\\t\\t\\t\\tgameInfo.history.ties += 1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tgameInfo.blockNumber = uint40(block.number);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn gameInfo;\\n\\t}\\n\\n\\t/// Returns whether the next position would result in a winning board if applied\\n\\t/// @param playerMap The bitmap representing the player's current moves\\n\\t/// @param nextPosition The next move being considered\\n\\t/// @return Whether the next position would result in a winning board\\n\\tfunction winableMove(uint256 playerMap, uint256 nextPosition) internal pure returns (bool) {\\n\\t\\tif (nextPosition == 0) {\\n\\t\\t\\treturn bitsMatch(playerMap, 192) || bitsMatch(playerMap, 36) || bitsMatch(playerMap, 17);\\n\\t\\t} else if (nextPosition == 1) {\\n\\t\\t\\treturn bitsMatch(playerMap, 320) || bitsMatch(playerMap, 18);\\n\\t\\t} else if (nextPosition == 2) {\\n\\t\\t\\treturn bitsMatch(playerMap, 384) || bitsMatch(playerMap, 20) || bitsMatch(playerMap, 9);\\n\\t\\t} else if (nextPosition == 3) {\\n\\t\\t\\treturn bitsMatch(playerMap, 260) || bitsMatch(playerMap, 24);\\n\\t\\t} else if (nextPosition == 4) {\\n\\t\\t\\treturn bitsMatch(playerMap, 257) || bitsMatch(playerMap, 130) || bitsMatch(playerMap, 68) || bitsMatch(playerMap, 40);\\n\\t\\t} else if (nextPosition == 5) {\\n\\t\\t\\treturn bitsMatch(playerMap, 65) || bitsMatch(playerMap, 48);\\n\\t\\t} else if (nextPosition == 6) {\\n\\t\\t\\treturn bitsMatch(playerMap, 288) || bitsMatch(playerMap, 80) || bitsMatch(playerMap, 3);\\n\\t\\t} else if (nextPosition == 7) {\\n\\t\\t\\treturn bitsMatch(playerMap, 144) || bitsMatch(playerMap, 5);\\n\\t\\t} else /* if (nextPosition == 8) */ {\\n\\t\\t\\treturn bitsMatch(playerMap, 272) || bitsMatch(playerMap, 72) || bitsMatch(playerMap, 6);\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/utils/PaperScribble.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@theappstudio/solidity/contracts/utils/SVG.sol\\\";\\nimport \\\"../interfaces/IMetadataProvider.sol\\\";\\nimport \\\"../utils/GameUtils.sol\\\";\\nimport \\\"./GameConnector.sol\\\";\\n\\n/// @title PaperScribble\\ncontract PaperScribble is GameConnector, IMetadataProvider {\\n\\n\\tusing Strings for uint256;\\n\\n\\tstring private constant _CONTRACT_SYMBOL = \\\"X\\\";\\n\\tstring private constant _OWNER_SYMBOL = \\\"O\\\";\\n\\n\\t/// @inheritdoc IMetadataProvider\\n\\tfunction contractSymbol() external pure returns (string memory) {\\n\\t\\treturn _CONTRACT_SYMBOL;\\n\\t}\\n\\n\\t/// @inheritdoc IMetadataProvider\\n\\tfunction metadata(ITicTacToe.Game memory game, uint256 tokenId) external view onlyAllowedCallers returns (string memory) {\\n\\t\\treturn string(OnChain.tokenURI(OnChain.dictionary(OnChain.commaSeparated(\\n\\t\\t\\tOnChain.keyValueString(\\\"name\\\",  abi.encodePacked(\\\"Game \\\", tokenId.toString())),\\n\\t\\t\\tOnChain.keyValueArray(\\\"attributes\\\", _attributesFromGame(game)),\\n\\t\\t\\tOnChain.keyValueString(\\\"image\\\", OnChain.svgImageURI(_createSvg(game)))\\n\\t\\t))));\\n\\t}\\n\\n\\t/// @inheritdoc IMetadataProvider\\n\\tfunction ownerSymbol() external pure returns (string memory) {\\n\\t\\treturn _OWNER_SYMBOL;\\n\\t}\\n\\n\\t/// @inheritdoc IERC165\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure override(GameConnector, IERC165) returns (bool) {\\n\\t\\treturn interfaceId == type(IMetadataProvider).interfaceId || super.supportsInterface(interfaceId);\\n\\t}\\n\\n\\tfunction _attributesFromGame(ITicTacToe.Game memory game) private pure returns (bytes memory) {\\n\\t\\treturn OnChain.commaSeparated(\\n\\t\\t\\tOnChain.traitAttribute(\\\"Wins\\\", bytes(uint256(game.history.wins).toString())),\\n\\t\\t\\tOnChain.traitAttribute(\\\"Losses\\\", bytes(uint256(game.history.losses).toString())),\\n\\t\\t\\tOnChain.traitAttribute(\\\"Ties\\\", bytes(uint256(game.history.ties).toString())),\\n\\t\\t\\tOnChain.traitAttribute(\\\"Restarts\\\", bytes(uint256(game.history.restarts).toString())),\\n\\t\\t\\tOnChain.traitAttribute(\\\"Voting Power\\\", bytes(uint256(game.history.wins).toString()))\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _boardElements() private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\n\\t\\t\\t_rectElement(100, 100, \\\" filter='url(#roughpaper)'\\\"),\\n\\t\\t\\t_rectElement(100, 5, _boardElementAttributes(0, 30)),\\n\\t\\t\\t_rectElement(100, 5, _boardElementAttributes(0, 65)),\\n\\t\\t\\t_rectElement(5, 100, _boardElementAttributes(30, 0)),\\n\\t\\t\\t_rectElement(5, 100, _boardElementAttributes(65, 0)),\\n\\t\\t\\t_slotElements()\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _boardElementAttributes(uint256 xPercent, uint256 yPercent) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\" x='\\\", xPercent.toString(), \\\"%' y='\\\", yPercent.toString(), \\\"%' filter='url(#roughtext)'\\\");\\n\\t}\\n\\n\\tfunction _createSvg(ITicTacToe.Game memory game) private pure returns (bytes memory) {\\n\\t\\treturn SVG.createElement(\\\"svg\\\", SVG.svgAttributes(540, 540), abi.encodePacked(\\n\\t\\t\\t_defsForSvg(game),\\n\\t\\t\\tSVG.createElement(\\\"g\\\", \\\" clip-path='url(#clip)'\\\", abi.encodePacked(\\n\\t\\t\\t\\t_boardElements(),\\n\\t\\t\\t\\t_movesForGame(game),\\n\\t\\t\\t\\t_winningCrosses(game)\\n\\t\\t\\t))\\n\\t\\t));\\n\\t}\\n\\n\\tfunction _defsForSvg(ITicTacToe.Game memory game) private pure returns (bytes memory) {\\n\\t\\treturn SVG.createElement(\\\"defs\\\", \\\"\\\", abi.encodePacked(\\n\\t\\t\\tSVG.createElement(\\\"filter\\\", \\\" id='roughpaper'\\\", _paperFilterWithColor(\\\"white\\\")),\\n\\t\\t\\tSVG.createElement(\\\"filter\\\", \\\" id='roughtext' color-interpolation-filters='sRGB'\\\", _paperFilterWithColor(\\\"rgb(66,66,66)\\\")),\\n\\t\\t\\t_squigglyFilters((game.moves.length + 1) / 2),\\n\\t\\t\\t_winFilter(4),\\n\\t\\t\\t_winElements(),\\n\\t\\t\\tSVG.createElement(\\\"clipPath\\\", \\\" id='clip'\\\", _rectElement(100, 100, \\\"\\\"))\\n\\t\\t));\\n\\t}\\n\\n\\tfunction _movesForGame(ITicTacToe.Game memory game) private pure returns (bytes memory result) {\\n\\t\\tuint8[3] memory xPercentages = [15, 50, 85];\\n\\t\\tuint8[3] memory yPercentages = [19, 54, 89];\\n\\t\\tresult = \\\"\\\"; // <text x=\\\"15%\\\" y=\\\"19%\\\" dominant-baseline='middle' text-anchor='middle' font-size='22em'>X</text>\\n\\t\\tfor (uint256 move = 0; move < game.moves.length; move++) {\\n\\t\\t\\tuint256 position = game.moves[move];\\n\\t\\t\\tbytes memory attributes = abi.encodePacked(\\\" filter='url(#squiggly\\\", (move / 2).toString(), \\\")' font-size='11em' x='\\\", uint256(xPercentages[position % 3]).toString(), \\\"%' text-anchor='middle' y='\\\", uint256(yPercentages[position / 3]).toString(), \\\"%' dominant-baseline='middle'\\\");\\n\\t\\t\\tresult = abi.encodePacked(result, SVG.createElement(\\\"text\\\", attributes, move % 2 == 0 ? bytes(_CONTRACT_SYMBOL) : bytes(_OWNER_SYMBOL)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _paperFilterWithColor(bytes memory color) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\n\\t\\t\\t\\\"<feTurbulence type='fractalNoise' baseFrequency='0.04' result='noise' numOctaves='5'/>\\\",\\n\\t\\t\\tSVG.createElement(\\\"feDiffuseLighting\\\", abi.encodePacked(\\\" in='noise' lighting-color='\\\", color, \\\"' surfaceScale='2'\\\"), \\\"<feDistantLight azimuth='45' elevation='60'/>\\\"),\\n\\t\\t\\t\\\"<feComposite operator='in' in2='SourceGraphic' result='texture'/>\\\"\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _rectElement(uint256 widthPercentage, uint256 heightPercentage, bytes memory attributes) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"<rect width='\\\", widthPercentage.toString(), \\\"%' height='\\\", heightPercentage.toString(), \\\"%'\\\", attributes, \\\"/>\\\");\\n\\t}\\n\\n\\tfunction _slotElements() private pure returns (bytes memory result) {\\n\\t\\tuint8[3] memory percentages = [29, 64, 99];\\n\\t\\tresult = \\\"\\\"; // <text x='29%' y='29%' text-anchor='end' filter='url(#roughtext)' font-size='2em'>0</text>\\n\\t\\tfor (uint256 slot = 0; slot < 9; slot++) {\\n\\t\\t\\tbytes memory attributes = abi.encodePacked(\\\" font-size='1em' x='\\\", uint256(percentages[slot % 3]).toString(), \\\"%' text-anchor='end' y='\\\", uint256(percentages[slot / 3]).toString(), \\\"%' filter='url(#roughtext)'\\\");\\n\\t\\t\\tresult = abi.encodePacked(result, SVG.createElement(\\\"text\\\", attributes, bytes(slot.toString())));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _squigglyFilter(uint256 scale, uint256 index) private pure returns (bytes memory result) {\\n\\t\\treturn abi.encodePacked(\\n\\t\\t\\tabi.encodePacked(\\\"<feTurbulence baseFrequency='0.01' result='noise' numOctaves='3' seed='\\\", index.toString(), \\\"'/>\\\"),\\n\\t\\t\\tabi.encodePacked(\\\"<feDisplacementMap in='SourceGraphic' in2='noise' scale='\\\", scale.toString(), \\\"'/>\\\")\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _squigglyFilters(uint256 totalFilters) private pure returns (bytes memory result) {\\n\\t\\tresult = \\\"\\\";\\n\\t\\tfor (uint256 index = 0; index < totalFilters; index++) {\\n\\t\\t\\tbytes memory attributes = abi.encodePacked(\\\" id='squiggly\\\", index.toString() ,\\\"'\\\");\\n\\t\\t\\tresult = abi.encodePacked(result, SVG.createElement(\\\"filter\\\", attributes, _squigglyFilter(3, index)));\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _useElement(uint256 x, uint256 y, string memory name) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"<use stroke-linecap='round' x='\\\", x.toString(), \\\"%' y='\\\", y.toString(), \\\"%' filter='url(#win)' href='#\\\", name, \\\"' stroke='red'/>\\\");\\n\\t}\\n\\n\\tfunction _winElements() private pure returns (bytes memory) {\\n\\t\\t// 'M0 0 M90 90' works around a Chrome rendering issue\\n\\t\\treturn abi.encodePacked(\\n\\t\\t\\t_winPath(\\\"horizontal\\\", \\\"M0 0 M90 90 M81 81 L459 81\\\"),\\n\\t\\t\\t_winPath(\\\"vertical\\\", \\\"M0 0 M90 90 M81 81 L81 459\\\"),\\n\\t\\t\\t_winPath(\\\"criss\\\", \\\"M81 81 L459 459\\\"),\\n\\t\\t\\t_winPath(\\\"cross\\\", \\\"M459 81 L81 459\\\")\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _winFilter(uint256 scale) private pure returns (bytes memory) {\\n\\t\\treturn SVG.createElement(\\\"filter\\\", \\\" id='win'\\\",\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t_paperFilterWithColor(\\\"rgb(225,0,0)\\\"),\\n\\t\\t\\t\\t\\\"<feTurbulence baseFrequency='0.02' result='noise' numOctaves='3' seed='0'/>\\\",\\n\\t\\t\\t\\t\\\"<feDisplacementMap in='texture' in2='noise' scale='\\\", scale.toString(), \\\"'/>\\\"\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _winningCrosses(ITicTacToe.Game memory game) private pure returns (bytes memory) {\\n\\t\\tif (game.state == ITicTacToe.GameState.OwnerWon) {\\n\\t\\t\\tGameUtils.GameInfo memory gameInfo = GameUtils.gameInfoFromGame(game);\\n\\t\\t\\treturn _winningCrossesForMap(GameUtils.mapForPlayer(gameInfo, GameUtils.GamePlayer.Owner));\\n\\t\\t} else if (game.state == ITicTacToe.GameState.ContractWon) {\\n\\t\\t\\tGameUtils.GameInfo memory gameInfo = GameUtils.gameInfoFromGame(game);\\n\\t\\t\\treturn _winningCrossesForMap(GameUtils.mapForPlayer(gameInfo, GameUtils.GamePlayer.Contract));\\n\\t\\t}\\n\\t\\treturn \\\"\\\";\\n\\t}\\n\\n\\tfunction _winningCrossesForMap(uint256 map) private pure returns (bytes memory result) {\\n\\t\\tresult = \\\"\\\";\\n\\t\\tif (GameUtils.bitsMatch(map, 448)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 0, \\\"horizontal\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 292)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 0, \\\"vertical\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 273)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 0, \\\"criss\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 146)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(35, 0, \\\"vertical\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 84)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 0, \\\"cross\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 73)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(70, 0, \\\"vertical\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 56)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 35, \\\"horizontal\\\"));\\n\\t\\t}\\n\\t\\tif (GameUtils.bitsMatch(map, 7)) {\\n\\t\\t\\tresult = abi.encodePacked(result, _useElement(0, 70, \\\"horizontal\\\"));\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tfunction _winPath(string memory id, string memory path) private pure returns (bytes memory) {\\n\\t\\treturn abi.encodePacked(\\\"<path id='\\\", id, \\\"' d='\\\", path, \\\"' stroke-width='4%'/>\\\");\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"CallerNotAllowed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"assignAllowedCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8[]\",\"name\":\"moves\",\"type\":\"uint8[]\"},{\"internalType\":\"enum ITicTacToe.GameState\",\"name\":\"state\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"wins\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"losses\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ties\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"restarts\",\"type\":\"uint32\"}],\"internalType\":\"struct ITicTacToe.GameHistory\",\"name\":\"history\",\"type\":\"tuple\"}],\"internalType\":\"struct ITicTacToe.Game\",\"name\":\"game\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"metadata\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PaperScribble", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}