{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Sale/Sale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\n\\r\\nimport \\\"../Interface/ISpaceCows.sol\\\";\\r\\n\\r\\nimport \\\"./Modules/Whitelisted.sol\\\";\\r\\nimport \\\"./Modules/Random.sol\\\";\\r\\n\\r\\ncontract Sale is Ownable, Whitelisted {\\r\\n    using ECDSA for bytes32;\\r\\n    using Random for Random.Manifest;\\r\\n    Random.Manifest internal _manifest;\\r\\n\\r\\n    uint256 public whitelistSalePrice;\\r\\n    uint256 public publicSalePrice;\\r\\n    uint256 public maxMintsPerTxn;\\r\\n    uint256 public maxPresaleMintsPerWallet;\\r\\n    uint256 public reserved;\\r\\n    uint256 public maxTokenSupply;\\r\\n    \\r\\n    enum SaleState {\\r\\n        CLOSED,\\r\\n        PRESALE,\\r\\n        OPEN\\r\\n    }\\r\\n    SaleState public saleState;\\r\\n\\r\\n    ISpaceCows public spaceCows;\\r\\n\\r\\n    constructor(\\r\\n        uint256 _whitelistSalePrice,\\r\\n        uint256 _publicSalePrice,\\r\\n        uint256 _maxSupply,\\r\\n        uint256 _maxMintsPerTxn,\\r\\n        uint256 _maxPresaleMintsPerWallet,\\r\\n        uint256 _reserved\\r\\n    ) {\\r\\n        whitelistSalePrice = _whitelistSalePrice;\\r\\n        publicSalePrice = _publicSalePrice;\\r\\n        maxTokenSupply = _maxSupply;\\r\\n        maxMintsPerTxn = _maxMintsPerTxn;\\r\\n        maxPresaleMintsPerWallet = _maxPresaleMintsPerWallet;\\r\\n        reserved = _reserved;\\r\\n        _manifest.setup(_maxSupply);\\r\\n\\r\\n        saleState = SaleState(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    =========================================\\r\\n    Owner Functions\\r\\n    @dev these functions can only be called \\r\\n        by the owner of contract. some functions\\r\\n        here are meant only for backup cases.\\r\\n        separate maxpertxn and maxperwallet for\\r\\n        max flexibility\\r\\n    =========================================\\r\\n    */\\r\\n    function setWhitelistPrice(uint256 _newPrice) external onlyOwner {\\r\\n        whitelistSalePrice = _newPrice;\\r\\n    }\\r\\n\\r\\n    function setPublicPrice(uint256 _newPrice) external onlyOwner {\\r\\n        publicSalePrice = _newPrice;\\r\\n    }\\r\\n\\r\\n    function setMaxTokenSupply(uint256 _newMaxSupply) external onlyOwner {\\r\\n        maxTokenSupply = _newMaxSupply;\\r\\n    }\\r\\n\\r\\n    function setMaxMintsPerTxn(uint256 _newMaxMintsPerTxn) external onlyOwner {\\r\\n        maxMintsPerTxn = _newMaxMintsPerTxn;\\r\\n    }\\r\\n\\r\\n    function setMaxPresaleMintsPerWallet(uint256 _newLimit) external onlyOwner {\\r\\n        maxPresaleMintsPerWallet = _newLimit;\\r\\n    }\\r\\n\\r\\n    function setSpaceCowsAddress(address _newNftContract) external onlyOwner {\\r\\n        spaceCows = ISpaceCows(_newNftContract);\\r\\n    }\\r\\n\\r\\n    function setSaleState(uint256 _state) external onlyOwner {\\r\\n        saleState = SaleState(_state);\\r\\n    }\\r\\n\\r\\n    function setWhitelistRoot(bytes32 _newWhitelistRoot) external onlyOwner {\\r\\n        _setWhitelistRoot(_newWhitelistRoot);\\r\\n    }\\r\\n\\r\\n    function givewayReserved(address _user, uint256 _amount) external onlyOwner {\\r\\n        require(_amount < reserved + 1, \\\"Not enough tokens!\\\");\\r\\n        \\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](_amount);\\r\\n        while (index < _amount) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        unchecked {\\r\\n            reserved -= index;\\r\\n        }\\r\\n        spaceCows.cowMint(_user, tmpTokenIds);\\r\\n    }\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint256 payment = address(this).balance / 4;\\r\\n        require(payment > 0, \\\"Empty balance\\\");\\r\\n\\r\\n        sendValue(payable(0xced6ACCbEbF5cb8BD23e2B2E8B49C78471FaAe20), payment);\\r\\n        sendValue(payable(0x4386103c101ce063C668B304AD06621d6DEF59c9), payment);\\r\\n        sendValue(payable(0x19Bb04164f17FF2136A1768aA4ed22cb7f1dAa00), payment);\\r\\n        sendValue(payable(0x910040fA04518c7D166e783DB427Af74BE320Ac7), payment);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n    =========================================\\r\\n    Mint Functions\\r\\n    @dev these functions are relevant  \\r\\n        for minting purposes only\\r\\n    =========================================\\r\\n    */\\r\\n    function whitelistPurchase(uint256 numberOfTokens, bytes32[] calldata proof)\\r\\n    external\\r\\n    payable\\r\\n    onlyWhitelisted(msg.sender, address(this), proof) {\\r\\n        address user = msg.sender;\\r\\n        uint256 buyAmount = whitelistSalePrice * numberOfTokens;\\r\\n\\r\\n        require(saleState == SaleState.PRESALE, \\\"Presale is not started!\\\");\\r\\n        require(spaceCows.balanceOf(user) + numberOfTokens < maxPresaleMintsPerWallet + 1, \\\"You can only mint 10 token(s) on presale per wallet!\\\");\\r\\n        require(msg.value > buyAmount - 1, \\\"Not enough ETH!\\\");\\r\\n\\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](numberOfTokens);\\r\\n        while (index < numberOfTokens) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        spaceCows.cowMint(user, tmpTokenIds);\\r\\n    }\\r\\n\\r\\n    function publicPurchase(uint256 numberOfTokens)\\r\\n    external\\r\\n    payable {\\r\\n        address user = msg.sender;\\r\\n        uint256 totalSupply = spaceCows.totalSupply();\\r\\n        uint256 _reserved = reserved;\\r\\n        uint256 buyAmount = publicSalePrice * numberOfTokens;\\r\\n\\r\\n        require(saleState == SaleState.OPEN, \\\"Sale not started!\\\");\\r\\n        require(numberOfTokens < maxMintsPerTxn + 1, \\\"You can buy up to 10 per transaction\\\");\\r\\n        require(totalSupply + numberOfTokens < maxTokenSupply + 1 - _reserved, \\\"Not enough tokens!\\\");\\r\\n        require(msg.value > buyAmount - 1, \\\"Not enough ETH!\\\");\\r\\n\\r\\n        uint256 index = 0;\\r\\n        uint256[] memory tmpTokenIds = new uint256[](numberOfTokens);\\r\\n        while (index < numberOfTokens) {\\r\\n            uint256 tokenId = _manifest.draw();\\r\\n            bool doExists = spaceCows.exists(tokenId);\\r\\n\\r\\n            if (!doExists) {\\r\\n                tmpTokenIds[index] = tokenId;\\r\\n                index++;\\r\\n            } else {\\r\\n                continue;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        spaceCows.cowMint(user, tmpTokenIds);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    ============================================\\r\\n    Public & External Functions\\r\\n    @dev functions that can be called by anyone\\r\\n    ============================================\\r\\n    */\\r\\n    function remaining() public view returns (uint256) {\\r\\n        return _manifest.remaining();\\r\\n    }\\r\\n\\r\\n    function getSaleState() public view returns (uint256) {\\r\\n        return uint256(saleState);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    ============================================\\r\\n    Internal Functions\\r\\n    @dev functions that can be use inside the contract\\r\\n    ============================================\\r\\n    */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interface/ISpaceCows.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\ninterface ISpaceCows {\\n    function totalSupply() external view returns(uint256);\\n\\tfunction getMintingRate(address _address) external view returns(uint256);\\n    function cowMint(address _user, uint256[] memory _tokenId) external;\\n    function exists(uint256 _tokenId) external view returns(bool);\\n    function balanceOf(address owner) external returns(uint256);\\n}\"\r\n    },\r\n    \"contracts/Sale/Modules/Whitelisted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\\\";\\r\\n\\r\\nabstract contract Whitelisted {\\r\\n    bytes32 private _whitelistRoot;\\r\\n\\r\\n    modifier onlyWhitelisted(address _user, address _contract, bytes32[] calldata merkleProof) {\\r\\n        bytes32 node = keccak256(abi.encodePacked(_user, _contract));\\r\\n\\r\\n        require(MerkleProofUpgradeable.verify(merkleProof, _whitelistRoot, node), \\\"You are not whitelisted!\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _setWhitelistRoot(bytes32 root) internal {\\r\\n        _whitelistRoot = root;\\r\\n    }\\r\\n\\r\\n    function getWhitelistRoot() public view returns (bytes32) {\\r\\n        return _whitelistRoot;\\r\\n    }\\r\\n\\r\\n    function isWhitelisted(bytes32[] calldata merkleProof) public view returns (bool) {\\r\\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, address(this)));\\r\\n        if (MerkleProofUpgradeable.verify(merkleProof, _whitelistRoot, node)) {\\r\\n            return true;\\r\\n        } else {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/Sale/Modules/Random.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nlibrary Random {\\n    function random() internal view returns (bytes32) {\\n        return keccak256(abi.encodePacked(blockhash(block.number - 1), block.timestamp, msg.sender)) ;\\n    }\\n\\n    struct Manifest {\\n        uint256[] _data;\\n    }\\n\\n    function setup(Manifest storage self, uint256 length) internal {\\n        uint256[] storage data = self._data;\\n\\n        require(data.length == 0, \\\"Can't setup empty\\\");\\n        assembly { sstore(data.slot, length) }\\n    }\\n\\n    function draw(Manifest storage self) internal returns (uint256) {\\n        return draw(self, random());\\n    }\\n\\n    function draw(Manifest storage self, bytes32 seed) internal returns (uint256) {\\n        uint256[] storage data = self._data;\\n\\n        uint256 dl = data.length;\\n        uint256 di = uint256(seed) % dl;\\n        uint256 dx = data[di];\\n        uint256 dy = data[--dl];\\n        if (dx == 0) { dx = di + 1;   }\\n        if (dy == 0) { dy = dl + 1;   }\\n        if (di != dl) { data[di] = dy; }\\n        data.pop();\\n        return dx;\\n    }\\n\\n    function remaining(Manifest storage self) internal view returns (uint256) {\\n        return self._data.length;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 20000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_publicSalePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxMintsPerTxn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPresaleMintsPerWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_reserved\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"getSaleState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWhitelistRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"givewayReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerTxn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPresaleMintsPerWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"publicPurchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reserved\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleState\",\"outputs\":[{\"internalType\":\"enum Sale.SaleState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxMintsPerTxn\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerTxn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"setMaxPresaleMintsPerWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxTokenSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPublicPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_state\",\"type\":\"uint256\"}],\"name\":\"setSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newNftContract\",\"type\":\"address\"}],\"name\":\"setSpaceCowsAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setWhitelistPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newWhitelistRoot\",\"type\":\"bytes32\"}],\"name\":\"setWhitelistRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spaceCows\",\"outputs\":[{\"internalType\":\"contract ISpaceCows\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"whitelistPurchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistSalePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Sale", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000000000000000000000000000016345785d8a000000000000000000000000000000000000000000000000000001aa535d3d0c00000000000000000000000000000000000000000000000000000000000000002755000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000036", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}