{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7; \r\n\r\n\r\n\r\nabstract contract ReentrancyGuard { \r\n\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n\r\n\r\n    uint256 private _status;\r\n\r\n\r\n\r\n    constructor() {\r\n\r\n        _status = _NOT_ENTERED;\r\n\r\n    }\r\n\r\n    modifier nonReentrant() {\r\n\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n   _status = _ENTERED;\r\n\r\n\r\n\r\n        _;\r\n\r\n        _status = _NOT_ENTERED;\r\n\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nlibrary Strings {\r\n\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n \r\n\r\n    function toString(uint256 value) internal pure returns (string memory) { \r\n\r\n        if (value == 0) {\r\n\r\n            return \"0\";\r\n\r\n        }\r\n\r\n        uint256 temp = value;\r\n\r\n        uint256 digits;\r\n\r\n        while (temp != 0) {\r\n\r\n            digits++;\r\n\r\n            temp /= 10;\r\n\r\n        }\r\n\r\n        bytes memory buffer = new bytes(digits);\r\n\r\n        while (value != 0) {\r\n\r\n            digits -= 1;\r\n\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n\r\n            value /= 10;\r\n\r\n        }\r\n\r\n        return string(buffer);\r\n\r\n    }\r\n\r\n \r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n\r\n        if (value == 0) {\r\n\r\n            return \"0x00\";\r\n\r\n        }\r\n\r\n        uint256 temp = value;\r\n\r\n        uint256 length = 0;\r\n\r\n        while (temp != 0) {\r\n\r\n            length++;\r\n\r\n            temp >>= 8;\r\n\r\n        }\r\n\r\n        return toHexString(value, length);\r\n\r\n    }\r\n\r\n \r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n\r\n        buffer[0] = \"0\";\r\n\r\n        buffer[1] = \"x\";\r\n\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n\r\n            value >>= 4;\r\n\r\n        }\r\n\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n\r\n        return string(buffer);\r\n\r\n    }\r\n\r\n}\r\n\r\n \r\n\r\nabstract contract Context {\r\n\r\n    function _msgSender() internal view virtual returns (address) {\r\n\r\n        return msg.sender;\r\n\r\n    }\r\n\r\n\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n\r\n        return msg.data;\r\n\r\n    }\r\n\r\n}\r\n\r\n \r\n\r\nabstract contract Ownable is Context {\r\n\r\n    address private _owner;\r\n\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n \r\n\r\n    constructor() {\r\n\r\n        _transferOwnership(_msgSender());\r\n\r\n    }\r\n\r\n \r\n\r\n    function owner() public view virtual returns (address) {\r\n\r\n        return _owner;\r\n\r\n    } \r\n\r\n    modifier onlyOwner() {\r\n\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n\r\n        _;\r\n\r\n    }\r\n\r\n \r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n\r\n        _transferOwnership(address(0));\r\n\r\n    }\r\n\r\n \r\n\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n\r\n        _transferOwnership(newOwner);\r\n\r\n    }\r\n\r\n \r\n\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n\r\n        address oldOwner = _owner;\r\n\r\n        _owner = newOwner;\r\n\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n\r\n    }\r\n\r\n}\r\n\r\n \r\n\r\nlibrary Address { \r\n\r\n    function isContract(address account) internal view returns (bool) { \r\n\r\n        uint256 size;\r\n\r\n        assembly {\r\n\r\n            size := extcodesize(account)\r\n\r\n        }\r\n\r\n        return size > 0;\r\n\r\n    } \r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n\r\n    } \r\n\r\n    function functionCall(\r\n\r\n        address target,\r\n\r\n        bytes memory data,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal returns (bytes memory) {\r\n\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionCallWithValue(\r\n\r\n        address target,\r\n\r\n        bytes memory data,\r\n\r\n        uint256 value\r\n\r\n    ) internal returns (bytes memory) {\r\n\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionCallWithValue(\r\n\r\n        address target,\r\n\r\n        bytes memory data,\r\n\r\n        uint256 value,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal returns (bytes memory) {\r\n\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n\r\n    } \r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionStaticCall(\r\n\r\n        address target,\r\n\r\n        bytes memory data,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal view returns (bytes memory) {\r\n\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n\r\n    }\r\n\r\n \r\n\r\n    function functionDelegateCall(\r\n\r\n        address target,\r\n\r\n        bytes memory data,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal returns (bytes memory) {\r\n\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n\r\n    }\r\n\r\n \r\n\r\n    function verifyCallResult(\r\n\r\n        bool success,\r\n\r\n        bytes memory returndata,\r\n\r\n        string memory errorMessage\r\n\r\n    ) internal pure returns (bytes memory) {\r\n\r\n        if (success) {\r\n\r\n            return returndata;\r\n\r\n        } else { \r\n\r\n            if (returndata.length > 0) { \r\n\r\n\r\n\r\n                assembly {\r\n\r\n                    let returndata_size := mload(returndata)\r\n\r\n                    revert(add(32, returndata), returndata_size)\r\n\r\n                }\r\n\r\n            } else {\r\n\r\n                revert(errorMessage);\r\n\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n \r\n\r\ninterface IERC721Receiver { \r\n\r\n    function onERC721Received(\r\n\r\n        address operator,\r\n\r\n        address from,\r\n\r\n        uint256 tokenId,\r\n\r\n        bytes calldata data\r\n\r\n    ) external returns (bytes4);\r\n\r\n}\r\n\r\n \r\n\r\ninterface IERC165 { \r\n\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n\r\n}\r\n\r\n \r\n\r\nabstract contract ERC165 is IERC165 { \r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n\r\n        return interfaceId == type(IERC165).interfaceId;\r\n\r\n    }\r\n\r\n} \r\n\r\ninterface IERC721 is IERC165 { \r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); \r\n\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId); \r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved); \r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance); \r\n\r\n    function ownerOf(uint256 tokenId) external view returns (address owner); \r\n\r\n    function safeTransferFrom(\r\n\r\n        address from,\r\n\r\n        address to,\r\n\r\n        uint256 tokenId\r\n\r\n    ) external; \r\n\r\n    function transferFrom(\r\n\r\n        address from,\r\n\r\n        address to,\r\n\r\n        uint256 tokenId\r\n\r\n    ) external; \r\n\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n \r\n\r\n    function getApproved(uint256 tokenId) external view returns (address operator); \r\n\r\n    function setApprovalForAll(address operator, bool _approved) external; \r\n\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool); \r\n\r\n    function safeTransferFrom(\r\n\r\n        address from,\r\n\r\n        address to,\r\n\r\n        uint256 tokenId,\r\n\r\n        bytes calldata data\r\n\r\n    ) external;\r\n\r\n} \r\n\r\n\r\n\r\ninterface IERC721Enumerable is IERC721 { \r\n\r\n    function totalSupply() external view returns (uint256); \r\n\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId); \r\n\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n\r\n}  \r\n\r\n\r\n\r\ninterface IERC721Metadata is IERC721 { \r\n\r\n    function name() external view returns (string memory); \r\n\r\n    function symbol() external view returns (string memory); \r\n\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n\r\n} \r\n\r\n\r\n\r\ncontract ERC721A is\r\n\r\n  Context,\r\n\r\n  ERC165,\r\n\r\n  IERC721,\r\n\r\n  IERC721Metadata,\r\n\r\n  IERC721Enumerable\r\n\r\n{\r\n\r\n  using Address for address;\r\n\r\n  using Strings for uint256;\r\n\r\n\r\n\r\n  struct TokenOwnership {\r\n\r\n    address addr;\r\n\r\n    uint64 startTimestamp;\r\n\r\n  }\r\n\r\n\r\n\r\n  struct AddressData {\r\n\r\n    uint128 balance;\r\n\r\n    uint128 numberMinted;\r\n\r\n  }\r\n\r\n\r\n\r\n  uint256 private currentIndex = 1;\r\n\r\n  uint private totalMinted=0;\r\n\r\n  mapping(uint => bool) public tokenIdMinted;\r\n\r\n\r\n\r\n  uint256 internal immutable collectionSize;\r\n\r\n  uint256 internal immutable maxBatchSize; \r\n\r\n  string private _name; \r\n\r\n  string private _symbol; \r\n\r\n  mapping(uint256 => TokenOwnership) private _ownerships; \r\n\r\n  mapping(address => AddressData) private _addressData; \r\n\r\n  mapping(uint256 => address) private _tokenApprovals; \r\n\r\n  mapping(address => mapping(address => bool)) private _operatorApprovals; \r\n\r\n  constructor(\r\n\r\n    string memory name_,\r\n\r\n    string memory symbol_,\r\n\r\n    uint256 maxBatchSize_,\r\n\r\n    uint256 collectionSize_\r\n\r\n  ) {\r\n\r\n    require(\r\n\r\n      collectionSize_ > 0,\r\n\r\n      \"ERC721A: collection must have a nonzero supply\"\r\n\r\n    );\r\n\r\n    require(maxBatchSize_ > 0, \"ERC721A: max batch size must be nonzero\");\r\n\r\n    _name = name_;\r\n\r\n    _symbol = symbol_;\r\n\r\n    maxBatchSize = maxBatchSize_;\r\n\r\n    collectionSize = collectionSize_;\r\n\r\n  } \r\n\r\n  \r\n\r\n  function totalSupply() public view override returns (uint256) {\r\n\r\n    return totalMinted;\r\n\r\n  } \r\n\r\n  \r\n\r\n  function tokenByIndex(uint256 index) public view override returns (uint256) {\r\n\r\n    require(index < totalSupply(), \"ERC721A: global index out of bounds\");\r\n\r\n    return index;\r\n\r\n  } \r\n\r\n  \r\n\r\n  function tokenOfOwnerByIndex(address owner, uint256 index)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    override\r\n\r\n    returns (uint256)\r\n\r\n  {\r\n\r\n    require(index < balanceOf(owner), \"ERC721A: owner index out of bounds\");\r\n\r\n    uint256 numMintedSoFar = totalSupply();\r\n\r\n    uint256 tokenIdsIdx = 0;\r\n\r\n    address currOwnershipAddr = address(0);\r\n\r\n    for (uint256 i = 0; i < numMintedSoFar; i++) {\r\n\r\n      TokenOwnership memory ownership = _ownerships[i];\r\n\r\n      if (ownership.addr != address(0)) {\r\n\r\n        currOwnershipAddr = ownership.addr;\r\n\r\n      }\r\n\r\n      if (currOwnershipAddr == owner) {\r\n\r\n        if (tokenIdsIdx == index) {\r\n\r\n          return i;\r\n\r\n        }\r\n\r\n        tokenIdsIdx++;\r\n\r\n      }\r\n\r\n    }\r\n\r\n    revert(\"ERC721A: unable to get token of owner by index\");\r\n\r\n  } \r\n\r\n  function supportsInterface(bytes4 interfaceId)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    virtual\r\n\r\n    override(ERC165, IERC165)\r\n\r\n    returns (bool)\r\n\r\n  {\r\n\r\n    return\r\n\r\n      interfaceId == type(IERC721).interfaceId ||\r\n\r\n      interfaceId == type(IERC721Metadata).interfaceId ||\r\n\r\n      interfaceId == type(IERC721Enumerable).interfaceId ||\r\n\r\n      super.supportsInterface(interfaceId);\r\n\r\n  } \r\n\r\n  function balanceOf(address owner) public view override returns (uint256) {\r\n\r\n    require(owner != address(0), \"ERC721A: balance query for the zero address\");\r\n\r\n    return uint256(_addressData[owner].balance);\r\n\r\n  }\r\n\r\n\r\n\r\n  function _numberMinted(address owner) internal view returns (uint256) {\r\n\r\n    require(\r\n\r\n      owner != address(0),\r\n\r\n      \"ERC721A: number minted query for the zero address\"\r\n\r\n    );\r\n\r\n    return uint256(_addressData[owner].numberMinted);\r\n\r\n  }\r\n\r\n\r\n\r\n  function ownershipOf(uint256 tokenId)\r\n\r\n    internal\r\n\r\n    view\r\n\r\n    returns (TokenOwnership memory)\r\n\r\n  {\r\n\r\n    require(_exists(tokenId), \"ERC721A: owner query for nonexistent token\");\r\n\r\n\r\n\r\n    uint256 lowestTokenToCheck;\r\n\r\n    if (tokenId >= maxBatchSize) {\r\n\r\n      lowestTokenToCheck = tokenId - maxBatchSize + 1;\r\n\r\n    }\r\n\r\n\r\n\r\n    for (uint256 curr = tokenId; curr >= lowestTokenToCheck; curr--) {\r\n\r\n      TokenOwnership memory ownership = _ownerships[curr];\r\n\r\n      if (ownership.addr != address(0)) {\r\n\r\n        return ownership;\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n\r\n    revert(\"ERC721A: unable to determine the owner of token\");\r\n\r\n  } \r\n\r\n  function ownerOf(uint256 tokenId) public view override returns (address) {\r\n\r\n    return ownershipOf(tokenId).addr;\r\n\r\n  } \r\n\r\n  function name() public view virtual override returns (string memory) {\r\n\r\n    return _name;\r\n\r\n  } \r\n\r\n  function symbol() public view virtual override returns (string memory) {\r\n\r\n    return _symbol;\r\n\r\n  } \r\n\r\n  function tokenURI(uint256 tokenId)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    virtual\r\n\r\n    override\r\n\r\n    returns (string memory)\r\n\r\n  {\r\n\r\n    require(\r\n\r\n      _exists(tokenId),\r\n\r\n      \"ERC721Metadata: URI query for nonexistent token\"\r\n\r\n    );\r\n\r\n\r\n\r\n    string memory baseURI = _baseURI();\r\n\r\n    return\r\n\r\n      bytes(baseURI).length > 0\r\n\r\n        ? string(abi.encodePacked(baseURI, tokenId.toString(),_getUriExtension()))\r\n\r\n        : \"\";\r\n\r\n  } \r\n\r\n  function _baseURI() internal view virtual returns (string memory) {\r\n\r\n    return \"\";\r\n\r\n  }\r\n\r\n\r\n\r\n  function _getUriExtension() internal view virtual returns (string memory) {\r\n\r\n    return \"\";\r\n\r\n  }\r\n\r\n \r\n\r\n  function approve(address to, uint256 tokenId) public override {\r\n\r\n    address owner = ERC721A.ownerOf(tokenId);\r\n\r\n    require(to != owner, \"ERC721A: approval to current owner\");\r\n\r\n\r\n\r\n    require(\r\n\r\n      _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\r\n\r\n      \"ERC721A: approve caller is not owner nor approved for all\"\r\n\r\n    );\r\n\r\n\r\n\r\n    _approve(to, tokenId, owner);\r\n\r\n  } \r\n\r\n  function getApproved(uint256 tokenId) public view override returns (address) {\r\n\r\n    require(_exists(tokenId), \"ERC721A: approved query for nonexistent token\");\r\n\r\n\r\n\r\n    return _tokenApprovals[tokenId];\r\n\r\n  } \r\n\r\n  function setApprovalForAll(address operator, bool approved) public override {\r\n\r\n    require(operator != _msgSender(), \"ERC721A: approve to caller\");\r\n\r\n\r\n\r\n    _operatorApprovals[_msgSender()][operator] = approved;\r\n\r\n    emit ApprovalForAll(_msgSender(), operator, approved);\r\n\r\n  }\r\n\r\n \r\n\r\n  function isApprovedForAll(address owner, address operator)\r\n\r\n    public\r\n\r\n    view\r\n\r\n    virtual\r\n\r\n    override\r\n\r\n    returns (bool)\r\n\r\n  {\r\n\r\n    return _operatorApprovals[owner][operator];\r\n\r\n  }\r\n\r\n \r\n\r\n  function transferFrom(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 tokenId\r\n\r\n  ) public override {\r\n\r\n    _transfer(from, to, tokenId);\r\n\r\n  } \r\n\r\n  function safeTransferFrom(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 tokenId\r\n\r\n  ) public override {\r\n\r\n    safeTransferFrom(from, to, tokenId, \"\");\r\n\r\n  } \r\n\r\n  function safeTransferFrom(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 tokenId,\r\n\r\n    bytes memory _data\r\n\r\n  ) public override {\r\n\r\n    _transfer(from, to, tokenId);\r\n\r\n    require(\r\n\r\n      _checkOnERC721Received(from, to, tokenId, _data),\r\n\r\n      \"ERC721A: transfer to non ERC721Receiver implementer\"\r\n\r\n    );\r\n\r\n  } \r\n\r\n  function _exists(uint256 tokenId) internal view returns (bool) {\r\n\r\n    return tokenIdMinted[tokenId];\r\n\r\n    \r\n\r\n  }\r\n\r\n\r\n\r\n  function _safeMint(address to, uint256 quantity) internal {\r\n\r\n    _safeMint(to, quantity, \"\");\r\n\r\n    totalMinted+=quantity;\r\n\r\n  } \r\n\r\n  function _safeMintId(address to, uint256 _id) internal {\r\n\r\n    _safeMintId(to, _id, \"\");\r\n\r\n    totalMinted++;\r\n\r\n  } \r\n\r\n  function _safeMint(\r\n\r\n    address to,\r\n\r\n    uint256 quantity,\r\n\r\n    bytes memory _data\r\n\r\n  ) internal {\r\n\r\n    uint256 startTokenId = currentIndex;\r\n\r\n    require(to != address(0), \"ERC721A: mint to the zero address\"); \r\n\r\n    \r\n\r\n    while(_exists(startTokenId)){\r\n\r\n      startTokenId++;\r\n\r\n    } \r\n\r\n    require(quantity <= maxBatchSize, \"ERC721A: quantity to mint too high\");\r\n\r\n\r\n\r\n\r\n\r\n    _beforeTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n    AddressData memory addressData = _addressData[to];\r\n\r\n    _addressData[to] = AddressData(\r\n\r\n      addressData.balance + uint128(quantity),\r\n\r\n      addressData.numberMinted + uint128(quantity)\r\n\r\n    );\r\n\r\n    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\r\n\r\n\r\n\r\n    uint256 updatedIndex = startTokenId;   \r\n\r\n    for (uint256 i = 0; i < quantity; i++) {\r\n\r\n      while(_exists(updatedIndex)){\r\n\r\n        updatedIndex++;\r\n\r\n      } \r\n\r\n      emit Transfer(address(0), to, updatedIndex);\r\n\r\n      require(\r\n\r\n        _checkOnERC721Received(address(0), to, updatedIndex, _data),\r\n\r\n        \"ERC721A: transfer to non ERC721Receiver implementer\"\r\n\r\n      );\r\n\r\n      tokenIdMinted[updatedIndex]=true;\r\n\r\n      updatedIndex++;\r\n\r\n    }\r\n\r\n\r\n\r\n    currentIndex = updatedIndex;\r\n\r\n    _afterTokenTransfers(address(0), to, startTokenId, quantity);\r\n\r\n  } \r\n\r\n\r\n\r\n // mint specific id\r\n\r\n  function _safeMintId(\r\n\r\n    address to,\r\n\r\n    uint256 _id,\r\n\r\n    bytes memory _data\r\n\r\n  ) internal {\r\n\r\n    uint256 startTokenId = _id; \r\n\r\n    require(to != address(0), \"ERC721A: mint to the zero address\"); \r\n\r\n    require(!_exists(startTokenId), \"ERC721A: token already minted\");\r\n\r\n    \r\n\r\n\r\n\r\n    _beforeTokenTransfers(address(0), to, startTokenId, 1);\r\n\r\n\r\n\r\n    AddressData memory addressData = _addressData[to];\r\n\r\n    _addressData[to] = AddressData(\r\n\r\n      addressData.balance + uint128(1),\r\n\r\n      addressData.numberMinted + uint128(1)\r\n\r\n    );\r\n\r\n    _ownerships[startTokenId] = TokenOwnership(to, uint64(block.timestamp));\r\n\r\n\r\n\r\n\r\n\r\n      emit Transfer(address(0), to, startTokenId);\r\n\r\n      require(\r\n\r\n        _checkOnERC721Received(address(0), to, startTokenId, _data),\r\n\r\n        \"ERC721A: transfer to non ERC721Receiver implementer\"\r\n\r\n      );\r\n\r\n\r\n\r\n    _afterTokenTransfers(address(0), to, startTokenId, 1);\r\n\r\n  } \r\n\r\n\r\n\r\n\r\n\r\n  function _transfer(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 tokenId\r\n\r\n  ) private {\r\n\r\n    TokenOwnership memory prevOwnership = ownershipOf(tokenId);\r\n\r\n\r\n\r\n    bool isApprovedOrOwner = (_msgSender() == prevOwnership.addr ||\r\n\r\n      getApproved(tokenId) == _msgSender() ||\r\n\r\n      isApprovedForAll(prevOwnership.addr, _msgSender()));\r\n\r\n\r\n\r\n    require(\r\n\r\n      isApprovedOrOwner,\r\n\r\n      \"ERC721A: transfer caller is not owner nor approved\"\r\n\r\n    );\r\n\r\n\r\n\r\n    require(\r\n\r\n      prevOwnership.addr == from,\r\n\r\n      \"ERC721A: transfer from incorrect owner\"\r\n\r\n    );\r\n\r\n    require(to != address(0), \"ERC721A: transfer to the zero address\");\r\n\r\n\r\n\r\n    _beforeTokenTransfers(from, to, tokenId, 1); \r\n\r\n    _approve(address(0), tokenId, prevOwnership.addr);\r\n\r\n\r\n\r\n    _addressData[from].balance -= 1;\r\n\r\n    _addressData[to].balance += 1;\r\n\r\n    _ownerships[tokenId] = TokenOwnership(to, uint64(block.timestamp)); \r\n\r\n    uint256 nextTokenId = tokenId + 1;\r\n\r\n    if (_ownerships[nextTokenId].addr == address(0)) {\r\n\r\n      if (_exists(nextTokenId)) {\r\n\r\n        _ownerships[nextTokenId] = TokenOwnership(\r\n\r\n          prevOwnership.addr,\r\n\r\n          prevOwnership.startTimestamp\r\n\r\n        );\r\n\r\n      }\r\n\r\n    }\r\n\r\n\r\n\r\n    emit Transfer(from, to, tokenId);\r\n\r\n    _afterTokenTransfers(from, to, tokenId, 1);\r\n\r\n  } \r\n\r\n\r\n\r\n  function _approve(\r\n\r\n    address to,\r\n\r\n    uint256 tokenId,\r\n\r\n    address owner\r\n\r\n  ) private {\r\n\r\n    _tokenApprovals[tokenId] = to;\r\n\r\n    emit Approval(owner, to, tokenId);\r\n\r\n  }\r\n\r\n\r\n\r\n  uint256 public nextOwnerToExplicitlySet = 0; \r\n\r\n  function _setOwnersExplicit(uint256 quantity) internal {\r\n\r\n    uint256 oldNextOwnerToSet = nextOwnerToExplicitlySet;\r\n\r\n    require(quantity > 0, \"quantity must be nonzero\");\r\n\r\n    uint256 endIndex = oldNextOwnerToSet + quantity - 1;\r\n\r\n    if (endIndex > collectionSize - 1) {\r\n\r\n      endIndex = collectionSize - 1;\r\n\r\n    } \r\n\r\n    require(_exists(endIndex), \"not enough minted yet for this cleanup\");\r\n\r\n    for (uint256 i = oldNextOwnerToSet; i <= endIndex; i++) {\r\n\r\n      if (_ownerships[i].addr == address(0)) {\r\n\r\n        TokenOwnership memory ownership = ownershipOf(i);\r\n\r\n        _ownerships[i] = TokenOwnership(\r\n\r\n          ownership.addr,\r\n\r\n          ownership.startTimestamp\r\n\r\n        );\r\n\r\n      }\r\n\r\n    }\r\n\r\n    nextOwnerToExplicitlySet = endIndex + 1;\r\n\r\n  } \r\n\r\n  function _checkOnERC721Received(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 tokenId,\r\n\r\n    bytes memory _data\r\n\r\n  ) private returns (bool) {\r\n\r\n    if (to.isContract()) {\r\n\r\n      try\r\n\r\n        IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data)\r\n\r\n      returns (bytes4 retval) {\r\n\r\n        return retval == IERC721Receiver(to).onERC721Received.selector;\r\n\r\n      } catch (bytes memory reason) {\r\n\r\n        if (reason.length == 0) {\r\n\r\n          revert(\"ERC721A: transfer to non ERC721Receiver implementer\");\r\n\r\n        } else {\r\n\r\n          assembly {\r\n\r\n            revert(add(32, reason), mload(reason))\r\n\r\n          }\r\n\r\n        }\r\n\r\n      }\r\n\r\n    } else {\r\n\r\n      return true;\r\n\r\n    }\r\n\r\n  } \r\n\r\n  function _beforeTokenTransfers(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 startTokenId,\r\n\r\n    uint256 quantity\r\n\r\n  ) internal virtual {} \r\n\r\n  function _afterTokenTransfers(\r\n\r\n    address from,\r\n\r\n    address to,\r\n\r\n    uint256 startTokenId,\r\n\r\n    uint256 quantity\r\n\r\n  ) internal virtual {}\r\n\r\n}\r\n\r\n\r\n\r\ncontract NatashatiniNFT is Ownable, ERC721A, ReentrancyGuard {\r\n\r\n    using Strings for uint256;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  uint256 public  PRICE_A = 0.08 ether; //0.18 ether presale , 0.23 eth public \r\n\r\n  uint256 public  PRICE_B = 0.11 ether; //0.18 ether presale , 0.23 eth public \r\n\r\n  uint256 public  PRICE_C = 0.20 ether; //0.18 ether presale , 0.23 eth public \r\n\r\n\r\n\r\n  uint256 private constant TotalCollectionSize_ = 10000; // total number of nfts\r\n\r\n  uint256 private constant MaxMintPerBatch_ = 10000; //max mint per traction\r\n\r\n  uint256 nft_A = 0;\r\n\r\n  uint256 nft_B = 1;\r\n\r\n  uint256 nft_C = 2;\r\n\r\n\r\n\r\n\r\n\r\n  bool public _revealNFT = false;  \r\n\r\n\r\n\r\n  // metadata URI\r\n\r\n  string private _baseTokenURI;\r\n\r\n  string private _uriBeforeReveal;\r\n\r\n\r\n\r\n  uint public status = 0; //0-pause 1-whitelist 2-public\r\n\r\n\r\n\r\n  mapping(address => bool) private whitelistedAddresses;\r\n\r\n  mapping(address => string[]) public nftType;\r\n\r\n\r\n\r\n  constructor() ERC721A(\"Natashatini NFT\",\"Natashatini NFT\", MaxMintPerBatch_, TotalCollectionSize_) {\r\n\r\n    setURIbeforeReveal(\"https://ipfs.io/ipfs/Qmdg1Ad4SYZoRMN54APoXnR8g1efB5ccVuLWEdjswvMM7v\");\r\n\r\n    setBaseURI(\"https://ipfs.io/ipfs/QmRPDM5vBq5raekngxRKxemkyMkjCMHJCmCMfocx3rgDHn/\");\r\n\r\n  }\r\n\r\n\r\n\r\n  modifier callerIsUser() {\r\n\r\n    require(tx.origin == msg.sender, \"The caller is another contract\");\r\n\r\n    _;\r\n\r\n  }\r\n\r\n\r\n\r\n  // nfttype_number = 0: A, 1: B, 2: C\r\n\r\n  function mint(uint256 quantity, uint256 [] memory nfttype_numbers) external payable callerIsUser {\r\n\r\n    require((status == 1 && whitelistedAddresses[msg.sender]) || status == 2 , \"Sale is not Active or you are not Whitelisted\");\r\n\r\n    require(totalSupply() + quantity <= collectionSize, \"reached max supply\");    \r\n\r\n    uint256 total = 0;\r\n\r\n    for (uint256 i = 0; i < nfttype_numbers.length; i++) {\r\n\r\n      uint256 nfttype_number = nfttype_numbers[i];\r\n\r\n      require(nfttype_number == 0 || nfttype_number == 1 || nfttype_number == 2, \"nfttype_number must be 0, 1, or 2\");\r\n\r\n      if (nfttype_number==nft_A){\r\n\r\n        total += PRICE_A ;      \r\n\r\n        addNewNftOfType(msg.sender,'A',quantity);\r\n\r\n      } else if (nfttype_number==nft_B){\r\n\r\n        total += PRICE_B ;\r\n\r\n        addNewNftOfType(msg.sender,'B',quantity);\r\n\r\n      } else if (nfttype_number==nft_C){\r\n\r\n        total += PRICE_C ;\r\n\r\n        addNewNftOfType(msg.sender,'C',quantity);\r\n\r\n      }\r\n\r\n    }    \r\n\r\n    require(msg.value >= total, \"Need to send more ETH.\");\r\n\r\n    _safeMint(msg.sender, quantity);  \r\n\r\n       \r\n\r\n  }\r\n\r\n  \r\n\r\n  function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n\r\n    require(_exists(tokenId),\"ERC721Metadata: URI query for nonexistent token\");\r\n\r\n    if(_revealNFT){\r\n\r\n    string memory baseURI = _baseURI();\r\n\r\n    return\r\n\r\n      bytes(baseURI).length > 0\r\n\r\n        ? string(abi.encodePacked(baseURI, tokenId.toString(),  \".json\"))\r\n\r\n        : \"\";\r\n\r\n    } else{\r\n\r\n      return _uriBeforeReveal;\r\n\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  function isWhitelisted(address _user) public view returns (bool) {\r\n\r\n    return whitelistedAddresses[_user];\r\n\r\n  }\r\n\r\n  function nftOfType(address _user) public view returns (string [] memory) {\r\n\r\n    return nftType[_user];\r\n\r\n  }\r\n\r\n  \r\n\r\n  function addNewWhitelistUsers(address[] calldata _users) public onlyOwner {\r\n\r\n    // [\"\",\"\",\"\"]\r\n\r\n    for(uint i=0;i<_users.length;i++)\r\n\r\n        whitelistedAddresses[_users[i]] = true;\r\n\r\n  }\r\n\r\n   function addNewNftOfType(address  _user, string memory t, uint _quantity) internal {\r\n\r\n    // [\"\",\"\",\"\"]        \r\n\r\n        for(uint i=0;i<_quantity;i++){\r\n\r\n          nftType[_user].push(t);\r\n\r\n        }\r\n\r\n  }\r\n\r\n\r\n\r\n  function setURIbeforeReveal(string memory URI) public onlyOwner {\r\n\r\n    _uriBeforeReveal = URI;\r\n\r\n  }\r\n\r\n\r\n\r\n  function setBaseURI(string memory baseURI) public onlyOwner {\r\n\r\n    _baseTokenURI = baseURI;\r\n\r\n  }\r\n\r\n  function _baseURI() internal view virtual override returns (string memory) {\r\n\r\n    return _baseTokenURI;\r\n\r\n  }\r\n\r\n  function numberMinted(address owner) public view returns (uint256) {\r\n\r\n    return _numberMinted(owner);\r\n\r\n  }\r\n\r\n  function getOwnershipData(uint256 tokenId)\r\n\r\n    external\r\n\r\n    view\r\n\r\n    returns (TokenOwnership memory)\r\n\r\n  {\r\n\r\n    return ownershipOf(tokenId);\r\n\r\n  }\r\n\r\n  function withdrawMoney() external onlyOwner nonReentrant {\r\n\r\n    uint256 balance = address(this).balance;\r\n\r\n    (bool success, ) = msg.sender.call{value: balance}(\"\");\r\n\r\n    require(success, \"Transfer failed.\");\r\n\r\n  }\r\n\r\n  function changeRevealStatus() external onlyOwner {\r\n\r\n    _revealNFT = !_revealNFT;\r\n\r\n  }\r\n\r\n  \r\n\r\n  function changeMintPrice(uint256 _newPriceA,uint256 _newPriceB,uint256 _newPriceC ) external onlyOwner\r\n\r\n  {\r\n\r\n      PRICE_A = _newPriceA;\r\n\r\n      PRICE_B = _newPriceB;\r\n\r\n      PRICE_C = _newPriceC;\r\n\r\n  }\r\n\r\n \r\n\r\n  function setStatus(uint256 _status)external onlyOwner{\r\n\r\n      status = _status;\r\n\r\n  }\r\n\r\n  \r\n\r\n  function giveawaySpecificId(address _vipAddress, uint [] memory _tokenIds) public onlyOwner{\r\n\r\n    for (uint i = 0; i < _tokenIds.length; i++){\r\n\r\n      uint _tokenId = _tokenIds[i];\r\n\r\n      _safeMintId(_vipAddress, _tokenId);\r\n\r\n      tokenIdMinted[_tokenId]=true;\r\n\r\n    }   \r\n\r\n  }\r\n\r\n}", "ABI": "[]", "ContractName": "Address", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f27b872481ca9f6fed7de69855f311b1f30990e06fc12583face5073b1ffb9dd"}]}