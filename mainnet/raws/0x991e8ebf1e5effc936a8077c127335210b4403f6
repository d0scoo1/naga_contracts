{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionDelegateCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\nlibrary AddressUpgradeable {\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        return account.code.length \\u003e 0;\\r\\n    }\\r\\n\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value\\r\\n    ) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionCallWithValue(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        uint256 value,\\r\\n        string memory errorMessage\\r\\n    ) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\r\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\r\\n    }\\r\\n\\r\\n    function functionStaticCall(\\r\\n        address target,\\r\\n        bytes memory data,\\r\\n        string memory errorMessage\\r\\n    ) internal view returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\r\\n\\r\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\r\\n        return verifyCallResult(success, returndata, errorMessage);\\r\\n    }\\r\\n\\r\\n    function verifyCallResult(\\r\\n        bool success,\\r\\n        bytes memory returndata,\\r\\n        string memory errorMessage\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\"},\"ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\nimport \\\"./Initializable.sol\\\";\\r\\n\\r\\nabstract contract ContextUpgradeable is Initializable {\\r\\n    function __Context_init() internal onlyInitializing {\\r\\n    }\\r\\n\\r\\n    function __Context_init_unchained() internal onlyInitializing {\\r\\n    }\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n\\r\\n    uint256[50] private __gap;\\r\\n}\\r\\n\"},\"draft-IERC1822.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IERC1822Proxiable {\\r\\n    function proxiableUUID() external view returns (bytes32);\\r\\n}\\r\\n\"},\"ERC1967Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Proxy.sol\\\";\\r\\nimport \\\"./ERC1967Upgrade.sol\\\";\\r\\n\\r\\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\\r\\n\\r\\n    constructor(address _logic, bytes memory _data) payable {\\r\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.implementation\\\")) - 1));\\r\\n        _upgradeToAndCall(_logic, _data, false);\\r\\n    }\\r\\n\\r\\n    function _implementation() internal view virtual override returns (address impl) {\\r\\n        return ERC1967Upgrade._getImplementation();\\r\\n    }\\r\\n}\\r\\n\"},\"ERC1967Upgrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.2;\\r\\n\\r\\nimport \\\"./IBeacon.sol\\\";\\r\\nimport \\\"./draft-IERC1822.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./StorageSlot.sol\\\";\\r\\n\\r\\nabstract contract ERC1967Upgrade {\\r\\n\\r\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\r\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n    event Upgraded(address indexed implementation);\\r\\n\\r\\n    function _getImplementation() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\r\\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\r\\n    }\\r\\n\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    function _upgradeToAndCall(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _upgradeTo(newImplementation);\\r\\n        if (data.length \\u003e 0 || forceCall) {\\r\\n            Address.functionDelegateCall(newImplementation, data);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _upgradeToAndCallUUPS(\\r\\n        address newImplementation,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\\r\\n            _setImplementation(newImplementation);\\r\\n        } else {\\r\\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\r\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\r\\n            } catch {\\r\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\r\\n            }\\r\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\r\\n\\r\\n    event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n    function _getAdmin() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setAdmin(address newAdmin) private {\\r\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\r\\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\r\\n    }\\r\\n\\r\\n    function _changeAdmin(address newAdmin) internal {\\r\\n        emit AdminChanged(_getAdmin(), newAdmin);\\r\\n        _setAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\r\\n\\r\\n    event BeaconUpgraded(address indexed beacon);\\r\\n\\r\\n    function _getBeacon() internal view returns (address) {\\r\\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\\r\\n    }\\r\\n\\r\\n    function _setBeacon(address newBeacon) private {\\r\\n        require(Address.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\r\\n        require(Address.isContract(IBeacon(newBeacon).implementation()), \\\"ERC1967: beacon implementation is not a contract\\\");\\r\\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\r\\n    }\\r\\n\\r\\n    function _upgradeBeaconToAndCall(\\r\\n        address newBeacon,\\r\\n        bytes memory data,\\r\\n        bool forceCall\\r\\n    ) internal {\\r\\n        _setBeacon(newBeacon);\\r\\n        emit BeaconUpgraded(newBeacon);\\r\\n        if (data.length \\u003e 0 || forceCall) {\\r\\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IBeacon {\\r\\n    function implementation() external view returns (address);\\r\\n}\\r\\n\"},\"IMerchant.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IMerchant {\\r\\n\\r\\n    struct MerchantInfo {\\r\\n        address account;\\r\\n        address payable settleAccount;\\r\\n        address settleCurrency;\\r\\n        bool autoSettle;\\r\\n        address proxy;\\r\\n        uint256 rate;\\r\\n        address [] tokens;\\r\\n    }\\r\\n\\r\\n    function addMerchant(\\r\\n        address payable settleAccount,\\r\\n        address settleCurrency,\\r\\n        bool autoSettle,\\r\\n        address proxy,\\r\\n        uint256 rate,\\r\\n        address[] memory tokens\\r\\n    ) external;\\r\\n\\r\\n    function setMerchantRate(address _merchant, uint256 _rate) external;\\r\\n\\r\\n    function getMerchantInfo(address _merchant) external view returns(MerchantInfo memory);\\r\\n\\r\\n    function isMerchant(address _merchant) external view returns(bool);\\r\\n\\r\\n    function getMerchantTokens(address _merchant) external view returns(address[] memory);\\r\\n\\r\\n    function getAutoSettle(address _merchant) external view returns(bool);\\r\\n\\r\\n    function getSettleCurrency(address _merchant) external view returns(address);\\r\\n\\r\\n    function getSettleAccount(address _merchant) external view returns(address);\\r\\n\\r\\n    function getGlobalTokens() external view returns(address[] memory);\\r\\n\\r\\n    function validatorCurrency(address _merchant, address _currency) external view returns (bool);\\r\\n\\r\\n    function validatorGlobalToken(address _token) external view returns (bool);\\r\\n\\r\\n}\"},\"Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./AddressUpgradeable.sol\\\";\\r\\n\\r\\nabstract contract Initializable {\\r\\n\\r\\n    bool private _initialized;\\r\\n\\r\\n    bool private _initializing;\\r\\n\\r\\n    modifier initializer() {\\r\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\r\\n\\r\\n        bool isTopLevelCall = !_initializing;\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = true;\\r\\n            _initialized = true;\\r\\n        }\\r\\n\\r\\n        _;\\r\\n\\r\\n        if (isTopLevelCall) {\\r\\n            _initializing = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    modifier onlyInitializing() {\\r\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _isConstructor() private view returns (bool) {\\r\\n        return !AddressUpgradeable.isContract(address(this));\\r\\n    }\\r\\n}\\r\\n\"},\"Merchant.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IMerchant.sol\\\";\\r\\nimport \\\"./Initializable.sol\\\";\\r\\nimport \\\"./OwnableUpgradeable.sol\\\";\\r\\n\\r\\ncontract Merchant is IMerchant, Initializable, OwnableUpgradeable {\\r\\n\\r\\n    mapping(address =\\u003e MerchantInfo) public merchantMap;\\r\\n\\r\\n    address[] public globalTokens;\\r\\n\\r\\n    event AddMerchant(address merchant, address proxy);\\r\\n\\r\\n    event SetMerchantRate(address merchant, address proxy, uint256 newRate);\\r\\n\\r\\n    address public immutable SETTLE_TOKEN;\\r\\n\\r\\n    receive() payable external {}\\r\\n\\r\\n    constructor(address _settleToken){\\r\\n        SETTLE_TOKEN = _settleToken;\\r\\n    }\\r\\n\\r\\n    function initialize()public initializer{\\r\\n        __Context_init_unchained();\\r\\n        __Ownable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function addMerchant(\\r\\n        address payable _settleAccount,\\r\\n        address _settleCurrency,\\r\\n        bool _autoSettle,\\r\\n        address _proxy,\\r\\n        uint256 _rate,\\r\\n        address[] memory _tokens\\r\\n    ) external {\\r\\n\\r\\n        if(address(0) != _settleCurrency) {\\r\\n            require(SETTLE_TOKEN == _settleCurrency);\\r\\n        }\\r\\n\\r\\n        if(_tokens.length \\u003e 0) {\\r\\n            for(uint j = 0; j \\u003c _tokens.length; j++) {\\r\\n                require(validatorGlobalToken(_tokens[j]));\\r\\n            }\\r\\n        }\\r\\n\\r\\n        merchantMap[msg.sender] = MerchantInfo (msg.sender, _settleAccount, _settleCurrency, _autoSettle, _proxy, _rate, _tokens);\\r\\n\\r\\n        emit AddMerchant(msg.sender, _proxy);\\r\\n\\r\\n        emit SetMerchantRate(msg.sender, _proxy, _rate);\\r\\n\\r\\n    }\\r\\n\\r\\n    function setMerchantRate(address _merchant, uint256 _rate) external {\\r\\n\\r\\n        require(msg.sender == merchantMap[_merchant].proxy);\\r\\n\\r\\n        merchantMap[_merchant].rate = _rate;\\r\\n\\r\\n        emit SetMerchantRate(_merchant, msg.sender, _rate);\\r\\n\\r\\n    }\\r\\n\\r\\n    function getMerchantInfo(address _merchant) external view returns(MerchantInfo memory){\\r\\n        return merchantMap[_merchant];\\r\\n    }\\r\\n\\r\\n    function isMerchant(address _merchant) external view returns(bool) {\\r\\n        return _isMerchant(_merchant);\\r\\n    }\\r\\n\\r\\n    function _isMerchant(address _merchant) public view returns(bool) {\\r\\n        return merchantMap[_merchant].account != address(0);\\r\\n    }\\r\\n\\r\\n    function getMerchantTokens(address _merchant) external view returns(address[] memory) {\\r\\n        return merchantMap[_merchant].tokens;\\r\\n    }\\r\\n\\r\\n    function getAutoSettle(address _merchant) external view returns(bool){\\r\\n        return merchantMap[_merchant].autoSettle;\\r\\n    }\\r\\n\\r\\n    function getSettleCurrency(address _merchant) external view returns(address){\\r\\n        return merchantMap[_merchant].settleCurrency;\\r\\n    }\\r\\n\\r\\n    function getSettleAccount(address _merchant) external view returns(address){\\r\\n        return merchantMap[_merchant].settleAccount;\\r\\n    }\\r\\n\\r\\n    function getGlobalTokens() public view returns(address[] memory){\\r\\n        return globalTokens;\\r\\n    }\\r\\n\\r\\n    function setGlobalTokens(address[] memory _tokens) external onlyOwner{\\r\\n        globalTokens = _tokens;\\r\\n    }\\r\\n\\r\\n    function validatorCurrency(address _merchant, address _currency) public view returns (bool){\\r\\n        for(uint idx = 0; idx \\u003c merchantMap[_merchant].tokens.length; idx ++) {\\r\\n            if (_currency == merchantMap[_merchant].tokens[idx]) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function validatorGlobalToken(address _token) public view returns (bool){\\r\\n        for(uint idx = 0; idx \\u003c globalTokens.length; idx ++) {\\r\\n            if (_token == globalTokens[idx]) {\\r\\n                return true;\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n}\"},\"Migrations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity \\u003e=0.4.22 \\u003c0.9.0;\\r\\n\\r\\ncontract Migrations {\\r\\n  address public owner = msg.sender;\\r\\n  uint public last_completed_migration;\\r\\n\\r\\n  modifier restricted() {\\r\\n    require(\\r\\n      msg.sender == owner,\\r\\n      \\\"This function is restricted to the contract\\u0027s owner\\\"\\r\\n    );\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  function setCompleted(uint completed) public restricted {\\r\\n    last_completed_migration = completed;\\r\\n  }\\r\\n}\\r\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\\r\\n\"},\"OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ContextUpgradeable.sol\\\";\\r\\nimport \\\"./Initializable.sol\\\";\\r\\n\\r\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function __Ownable_init() internal onlyInitializing {\\r\\n        __Ownable_init_unchained();\\r\\n    }\\r\\n\\r\\n    function __Ownable_init_unchained() internal onlyInitializing {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    uint256[49] private __gap;\\r\\n}\\r\\n\"},\"Proxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nabstract contract Proxy {\\r\\n    function _delegate(address implementation) internal virtual {\\r\\n        assembly {\\r\\n            calldatacopy(0, 0, calldatasize())\\r\\n\\r\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\r\\n\\r\\n            returndatacopy(0, 0, returndatasize())\\r\\n\\r\\n            switch result\\r\\n            case 0 {\\r\\n                revert(0, returndatasize())\\r\\n            }\\r\\n            default {\\r\\n                return(0, returndatasize())\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _implementation() internal view virtual returns (address);\\r\\n\\r\\n    function _fallback() internal virtual {\\r\\n        _beforeFallback();\\r\\n        _delegate(_implementation());\\r\\n    }\\r\\n\\r\\n    fallback() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    receive() external payable virtual {\\r\\n        _fallback();\\r\\n    }\\r\\n\\r\\n    function _beforeFallback() internal virtual {}\\r\\n}\\r\\n\"},\"StorageSlot.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nlibrary StorageSlot {\\r\\n    struct AddressSlot {\\r\\n        address value;\\r\\n    }\\r\\n\\r\\n    struct BooleanSlot {\\r\\n        bool value;\\r\\n    }\\r\\n\\r\\n    struct Bytes32Slot {\\r\\n        bytes32 value;\\r\\n    }\\r\\n\\r\\n    struct Uint256Slot {\\r\\n        uint256 value;\\r\\n    }\\r\\n\\r\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\r\\n        assembly {\\r\\n            r.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"},\"TransparentUpgradeableProxy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./ERC1967Proxy.sol\\\";\\r\\n\\r\\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\\r\\n\\r\\n    constructor(\\r\\n        address _logic,\\r\\n        address admin_,\\r\\n        bytes memory _data\\r\\n    ) payable ERC1967Proxy(_logic, _data) {\\r\\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\\\"eip1967.proxy.admin\\\")) - 1));\\r\\n        _changeAdmin(admin_);\\r\\n    }\\r\\n\\r\\n    modifier ifAdmin() {\\r\\n        if (msg.sender == _getAdmin()) {\\r\\n            _;\\r\\n        } else {\\r\\n            _fallback();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function admin() external ifAdmin returns (address admin_) {\\r\\n        admin_ = _getAdmin();\\r\\n    }\\r\\n\\r\\n    function implementation() external ifAdmin returns (address implementation_) {\\r\\n        implementation_ = _implementation();\\r\\n    }\\r\\n\\r\\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\\r\\n        _changeAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    function upgradeTo(address newImplementation) external ifAdmin {\\r\\n        _upgradeToAndCall(newImplementation, bytes(\\\"\\\"), false);\\r\\n    }\\r\\n\\r\\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\\r\\n        _upgradeToAndCall(newImplementation, data, true);\\r\\n    }\\r\\n\\r\\n    function _admin() internal view virtual returns (address) {\\r\\n        return _getAdmin();\\r\\n    }\\r\\n\\r\\n    function _beforeFallback() internal virtual override {\\r\\n        require(msg.sender != _getAdmin(), \\\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\\\");\\r\\n        super._beforeFallback();\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_settleToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"AddMerchant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"merchant\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"SetMerchantRate\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SETTLE_TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"_isMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_settleAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_settleCurrency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_autoSettle\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"addMerchant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"getAutoSettle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"getMerchantInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"settleAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settleCurrency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"autoSettle\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct IMerchant.MerchantInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"getMerchantTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"getSettleAccount\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"getSettleCurrency\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"globalTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"}],\"name\":\"isMerchant\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"merchantMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"settleAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"settleCurrency\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"autoSettle\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"setGlobalTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setMerchantRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_merchant\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_currency\",\"type\":\"address\"}],\"name\":\"validatorCurrency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"validatorGlobalToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Merchant", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://010868370ea4710a2c1176b9e8f7366d7a1c67f278152b5a99adf27d8a9a213a"}]}