{"status": "1", "message": "OK", "result": [{"SourceCode": "//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.4;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\ninterface IUniswapFactory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IUniswapRouter01 {\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n    external\r\n    returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n    external\r\n    payable\r\n    returns (uint[] memory amounts);\r\n\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getamountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getamountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getamountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getamountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniswapRouter02 is IUniswapRouter01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n\r\ninterface IUniswapV2Pair {\r\n  event Approval(address indexed owner, address indexed spender, uint value);\r\n  event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n  function name() external pure returns (string memory);\r\n  function symbol() external pure returns (string memory);\r\n  function decimals() external pure returns (uint8);\r\n  function totalSupply() external view returns (uint);\r\n  function balanceOf(address owner) external view returns (uint);\r\n  function allowance(address owner, address spender) external view returns (uint);\r\n\r\n  function approve(address spender, uint value) external returns (bool);\r\n  function transfer(address to, uint value) external returns (bool);\r\n  function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n  function nonces(address owner) external view returns (uint);\r\n\r\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n  event Mint(address indexed sender, uint amount0, uint amount1);\r\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n  event Swap(\r\n      address indexed sender,\r\n      uint amount0In,\r\n      uint amount1In,\r\n      uint amount0Out,\r\n      uint amount1Out,\r\n      address indexed to\r\n  );\r\n  event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n  function factory() external view returns (address);\r\n  function token0() external view returns (address);\r\n  function token1() external view returns (address);\r\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n  function price0CumulativeLast() external view returns (uint);\r\n  function price1CumulativeLast() external view returns (uint);\r\n  function kLast() external view returns (uint);\r\n\r\n  function mint(address to) external returns (uint liquidity);\r\n  function burn(address to) external returns (uint amount0, uint amount1);\r\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n  function skim(address to) external;\r\n  function sync() external;\r\n}\r\n\r\ncontract smart {\r\n    address router_address = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    IUniswapRouter02 router = IUniswapRouter02(router_address);\r\n\r\n    function create_weth_pair(address token) private returns (address, IUniswapV2Pair) {\r\n       address pair_address = IUniswapFactory(router.factory()).createPair(token, router.WETH());\r\n       return (pair_address, IUniswapV2Pair(pair_address));\r\n    }\r\n\r\n    function get_weth_reserve(address pair_address) private  view returns(uint, uint) {\r\n        IUniswapV2Pair pair = IUniswapV2Pair(pair_address);\r\n        uint112 token_reserve;\r\n        uint112 native_reserve;\r\n        uint32 last_timestamp;\r\n        (token_reserve, native_reserve, last_timestamp) = pair.getReserves();\r\n        return (token_reserve, native_reserve);\r\n    }\r\n\r\n    function get_weth_price_impact(address token, uint amount, bool sell) private view returns(uint) {\r\n        address pair_address = IUniswapFactory(router.factory()).getPair(token, router.WETH());\r\n        (uint res_token, uint res_weth) = get_weth_reserve(pair_address);\r\n        uint impact;\r\n        if(sell) {\r\n            impact = (amount * 100) / res_token;\r\n        } else {\r\n            impact = (amount * 100) / res_weth;\r\n        }\r\n        return impact;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract protected {\r\n\r\n    mapping (address => bool) is_auth;\r\n\r\n    function authorized(address addy) public view returns(bool) {\r\n        return is_auth[addy];\r\n    }\r\n\r\n    function set_authorized(address addy, bool booly) public onlyAuth {\r\n        is_auth[addy] = booly;\r\n    }\r\n\r\n    modifier onlyAuth() {\r\n        require( is_auth[msg.sender] || msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    address owner;\r\n    modifier onlyOwner() {\r\n        require(msg.sender==owner, \"not owner\");\r\n        _;\r\n    }\r\n\r\n    bool locked;\r\n    modifier safe() {\r\n        require(!locked, \"reentrant\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    receive() external payable {}\r\n    fallback() external payable {}\r\n}\r\n\r\ncontract DLAND is protected, smart, ERC20 {\r\n\r\n    string public constant _name = 'DLAND';\r\n    string public constant _symbol = 'Democracy Land';\r\n    uint8 public constant _decimals = 18;\r\n    uint256 public constant InitialSupply= 7 * 10**9 * 10**_decimals;\r\n    uint256 public constant _circulatingSupply= InitialSupply;\r\n    address public constant UniswapRouter=0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n    address public constant Dead = 0x000000000000000000000000000000000000dEaD;\r\n\r\n    event error_on_swap(bytes32 info);\r\n\r\n    bool trade_enabled;\r\n\r\n    mapping (address => uint256) public _balances;\r\n    mapping (address => mapping (address => uint256)) public _allowances;\r\n\r\n    address public pair;\r\n    IUniswapV2Pair public pair_contract;\r\n    IUniswapRouter02 public router_contract;\r\n\r\n    /// Balances\r\n\r\n    uint president_balance;\r\n    uint coder_balance;\r\n    uint liquidity_balance;\r\n    uint marketing_balance;\r\n    uint development_balance;\r\n\r\n    uint public president_eth_balance;\r\n    uint public coder_eth_balance;\r\n    uint public liquidity_eth_balance;\r\n    uint public marketing_eth_balance;\r\n    uint public development_eth_balance;\r\n\r\n    /// Fees and limits\r\n\r\n    bool public anti_bot = true;\r\n    bool public bot_crash = true;\r\n\r\n    uint public max_supply = (_circulatingSupply * 2)/100;\r\n    uint public initial_max_tx = (_circulatingSupply * 1) / 100;\r\n    uint public max_tx = (_circulatingSupply * 1) / 200;\r\n\r\n    uint public swap_treshold = (_circulatingSupply * 2) / 1000; /// @notice 0.2%\r\n    \r\n    mapping(address => bool) public is_tax_free;\r\n\r\n    /// @dev To enable decimals, we use 10x values and then divide /1000\r\n    struct tax {\r\n        uint16 president;\r\n        uint16 coder;\r\n        uint16 liquidity;\r\n        uint16 marketing;\r\n        uint16 development;\r\n    }\r\n\r\n    mapping (bytes32 => tax) tax_on;\r\n\r\n    uint origin_time;\r\n\r\n    address president_wallet;\r\n    address marketing_wallet;\r\n    address coder_wallet;\r\n    address development_wallet;\r\n\r\n    constructor() {\r\n        owner = msg.sender;\r\n        is_auth[owner] = true;\r\n        origin_time = block.timestamp;\r\n\r\n        is_tax_free[owner] = true;\r\n        \r\n\r\n        tax_on[\"buy\"].president = 10;\r\n        tax_on[\"buy\"].coder = 5;\r\n        tax_on[\"buy\"].liquidity = 2;\r\n        tax_on[\"buy\"].marketing = 3;\r\n        tax_on[\"buy\"].development = 3;\r\n\r\n        tax_on[\"sell\"].president = 10;\r\n        tax_on[\"sell\"].coder = 5;\r\n        tax_on[\"sell\"].liquidity = 3;\r\n        tax_on[\"sell\"].marketing = 3;\r\n        tax_on[\"sell\"].development = 4;\r\n        \r\n        tax_on[\"sell_before_one_hour\"].president = 30;\r\n        tax_on[\"sell_before_one_hour\"].coder = 5;\r\n        tax_on[\"sell_before_one_hour\"].liquidity = 40;\r\n        tax_on[\"sell_before_one_hour\"].marketing = 80;\r\n        tax_on[\"sell_before_one_hour\"].development = 90;\r\n        \r\n        tax_on[\"sell_before_two_hours\"].president = 20;\r\n        tax_on[\"sell_before_two_hours\"].coder = 5;\r\n        tax_on[\"sell_before_two_hours\"].liquidity = 30;\r\n        tax_on[\"sell_before_two_hours\"].marketing = 50;\r\n        tax_on[\"sell_before_two_hours\"].development = 50;\r\n        \r\n        _balances[msg.sender] = InitialSupply;\r\n        emit Transfer(Dead, msg.sender, InitialSupply);\r\n\r\n    }\r\n\r\n\r\n    function _transfer(address sender, address recipient, uint amount) private {\r\n\r\n        bytes32 destination;\r\n        bool isBuy=sender== pair|| sender == router_address;\r\n        bool isSell=recipient== pair|| recipient == router_address;\r\n\r\n        uint current_time = block.timestamp;\r\n        uint time_diff = current_time - origin_time;\r\n\r\n        bool is_excluded = (is_tax_free[sender] || is_tax_free[recipient]) || is_auth[sender] || is_auth[recipient];\r\n\r\n        bool is_contract_transfer=(sender==address(this) || recipient==address(this));\r\n\r\n        bool is_liquidity_transfer = ((sender == pair && recipient == router_address)\r\n        || (recipient == pair && sender == router_address));\r\n\r\n\r\n        if(is_excluded || is_liquidity_transfer || is_contract_transfer) {\r\n            _balances[sender] -= amount;\r\n            _balances[recipient] += amount;\r\n            emit Transfer(sender, recipient, amount);\r\n            return;\r\n        }\r\n\r\n        /// @dev IMPORTANT: this function allows to block snipers without them noticing\r\n        ///      basically seizing the money they are using to cheat.\r\n        ///      Is fundamental to educate users and mods to avoid unexpected losses.\r\n        \r\n        if(!bot_crash) {\r\n            require(trade_enabled, \"Trade disabled\");\r\n        } else {\r\n            emit Transfer(sender, recipient, 0);\r\n            return;\r\n        }\r\n\r\n        if(isBuy) {\r\n            destination = \"buy\";\r\n        } else if (isSell) {\r\n            if (time_diff < 2 hours) {\r\n                if(time_diff < 1 hours) {\r\n                    destination = \"sell_before_one_hour\";\r\n                } else {\r\n                    destination = \"sell_before_two_hours\";\r\n                }\r\n            } else {\r\n                destination = \"sell\";\r\n            }\r\n        }\r\n\r\n        uint taxed_amount = apply_taxes(amount, destination);\r\n        uint tax_taken = amount - taxed_amount;\r\n\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += taxed_amount;\r\n        _balances[address(this)] += tax_taken;\r\n        emit Transfer(sender, recipient, taxed_amount);\r\n        emit Transfer(sender, address(this), tax_taken);\r\n\r\n        if((_balances[address(this)] >= swap_treshold) && isSell) {\r\n            swap_tokens(amount);\r\n        }\r\n        \r\n\r\n    }\r\n\r\n    function apply_taxes(uint amount, bytes32 destination) private returns(uint) {\r\n        \r\n        uint _taxed_;\r\n\r\n        (uint _president,\r\n         uint _coder,\r\n         uint _liquidity,\r\n         uint _marketing,\r\n         uint _development) = get_tax_on(destination);\r\n\r\n        /// @dev The /1000 calculation is done to counter the absence of floating numbers\r\n        uint president_tokens = (amount * _president) / 1000;\r\n        uint coder_tokens = (amount * _coder) / 1000;\r\n        uint liquidity_tokens = (amount * _liquidity) / 1000;\r\n        uint marketing_tokens = (amount * _marketing) / 1000;\r\n        uint development_tokens = (amount * _development) / 1000;\r\n\r\n        president_balance += president_tokens;\r\n        coder_balance += coder_tokens;\r\n        liquidity_balance += liquidity_tokens;\r\n        marketing_balance += marketing_tokens;\r\n        development_balance += development_tokens;\r\n\r\n        return _taxed_;\r\n\r\n    }\r\n\r\n    function swap_tokens(uint sell_size) private {\r\n\r\n        /// @dev avoid honeypotting if contract has no tokens\r\n        if(!(address(this).balance > 0)) {\r\n            emit error_on_swap(\"insufficient funds\");\r\n            return;\r\n        }\r\n\r\n        uint token_to_sell = _balances[address(this)];\r\n        if(token_to_sell > sell_size) {\r\n            token_to_sell = sell_size;\r\n        }\r\n\r\n        address[] memory path;\r\n        path[0] = (address(this));\r\n        path[1] = (router.WETH());\r\n\r\n        uint liquidity_to_sell = (liquidity_balance/2);\r\n        uint liquidity_to_add = (liquidity_balance - liquidity_to_sell);\r\n\r\n        uint president_share = (president_balance * 100) / token_to_sell;\r\n        uint coder_share = (coder_balance * 100) / token_to_sell;\r\n        uint liquidity_share = (liquidity_to_sell * 100) / token_to_sell;\r\n        uint marketing_share = (marketing_balance * 100) / token_to_sell;\r\n        uint development_share = (development_balance * 100) / token_to_sell;\r\n\r\n        uint total_shares = president_share + coder_share + liquidity_share +\r\n                            marketing_share + development_share;\r\n        \r\n        /// @dev solves the imprecision of rounded numbers in solidity\r\n        if(total_shares > 100) {\r\n            marketing_share -= (total_shares - 100);\r\n        } else if (total_shares < 100) {\r\n            marketing_share += (100 - total_shares);\r\n        }\r\n\r\n        uint previous_balance = address(this).balance;\r\n\r\n        router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            token_to_sell, \r\n            0, \r\n            path, \r\n            address(this), \r\n            block.timestamp\r\n            );\r\n\r\n        uint new_balance = address(this).balance;\r\n\r\n        uint earned = new_balance - previous_balance;\r\n\r\n        uint liquidity_earnings = (earned * liquidity_share) / 100;\r\n        uint marketing_earnings = (earned * marketing_share) / 100;\r\n        uint president_earnings = (earned * liquidity_share) / 100;\r\n        uint coder_earnings = (earned * liquidity_share) / 100;\r\n        uint development_earnings = (earned * liquidity_share) / 100;\r\n\r\n       add_liquidity(liquidity_to_add, liquidity_earnings);\r\n\r\n        marketing_eth_balance += marketing_earnings;\r\n        president_eth_balance += president_earnings;\r\n        coder_eth_balance += coder_earnings;\r\n        development_eth_balance += development_earnings;\r\n    }\r\n\r\n    function add_liquidity(uint liquidity_to_add, uint liquidity_earnings) private {\r\n         /// @dev adding liquidity\r\n        _approve(address(this), router_address, liquidity_to_add);\r\n        router.addLiquidityETH {value:liquidity_earnings} (\r\n            address(this), \r\n            liquidity_to_add, \r\n            0, \r\n            0, \r\n            address(this), \r\n            block.timestamp);\r\n    }\r\n\r\n\r\n    function set_president_wallet(address wallet) public onlyAuth {\r\n        president_wallet = wallet;\r\n    }\r\n\r\n    function set_coder_wallet(address wallet) public onlyAuth {\r\n        coder_wallet = wallet;\r\n    }\r\n\r\n    function set_marketing_wallet(address wallet) public onlyAuth {\r\n        marketing_wallet = wallet;\r\n    }\r\n    \r\n    function set_development_wallet(address wallet) public onlyAuth {\r\n        development_wallet = wallet;\r\n    }\r\n\r\n    function retrieve_president() public onlyAuth {\r\n        require(address(this).balance >= president_balance, \"Insufficient amount\");\r\n        (bool sent,) = president_wallet.call{value: president_balance}(\"\");\r\n        require(sent, \"Failed to transfer\");\r\n        president_balance = 0;\r\n    }\r\n\r\n    function retrieve_marketing() public onlyAuth {\r\n        require(address(this).balance >= marketing_balance, \"Insufficient amount\");\r\n        (bool sent,) = marketing_wallet.call{value: marketing_balance}(\"\");\r\n        require(sent, \"Failed to transfer\");\r\n        marketing_balance = 0;\r\n    }\r\n\r\n\r\n    function retrieve_development() public onlyAuth {\r\n        require(address(this).balance >= development_balance, \"Insufficient amount\");\r\n        (bool sent,) = development_wallet.call{value: development_balance}(\"\");\r\n        require(sent, \"Failed to transfer\");\r\n        development_balance = 0;\r\n    }\r\n\r\n\r\n    function retrieve_coder() public onlyAuth {\r\n        require(address(this).balance >= coder_balance, \"Insufficient amount\");\r\n        (bool sent,) = coder_wallet.call{value: coder_balance}(\"\");\r\n        require(sent, \"Failed to transfer\");\r\n        coder_balance = 0;\r\n    }\r\n\r\n    function avoid_locks() public onlyAuth {\r\n        (bool sent,) = msg.sender.call{value: address(this).balance}(\"\");\r\n        require(sent, \"Failed to transfer\");\r\n    }\r\n\r\n    function rescue(address tknAddress) public onlyAuth {\r\n        ERC20 token = ERC20(tknAddress);\r\n        uint256 ourBalance = token.balanceOf(address(this));\r\n        require(ourBalance>0, \"No tokens in our balance\");\r\n        token.transfer(msg.sender, ourBalance);\r\n    }\r\n\r\n    function set_tax_on(bytes32 destination, uint16 _president, uint16 _coder, uint16 _liquidity,\r\n                        uint16 _marketing, uint16 _development) public onlyAuth {\r\n        \r\n        tax_on[destination].president = _president;\r\n        tax_on[destination].coder = _coder;\r\n        tax_on[destination].liquidity = _liquidity;\r\n        tax_on[destination].marketing = _marketing;\r\n        tax_on[destination].development = _development;\r\n    }\r\n\r\n    function get_tax_on(bytes32 destination) public view returns(uint16, uint16, uint16,\r\n                                                                  uint16 ,uint16) {\r\n        return(\r\n            tax_on[destination].president,\r\n            tax_on[destination].coder,\r\n            tax_on[destination].liquidity,\r\n            tax_on[destination].marketing,\r\n            tax_on[destination].development\r\n        );\r\n    }\r\n\r\n    function set_tax_free(address actor, bool state) public onlyAuth {\r\n        is_tax_free[actor] = state;\r\n    }\r\n\r\n    function sell_tokens() public onlyAuth {\r\n        swap_tokens(_balances[address(this)]);\r\n    }\r\n\r\n    function enable_trading() public onlyAuth {\r\n        trade_enabled = true;\r\n    }\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() pure public override returns (uint256) {\r\n        return _circulatingSupply;\r\n    }\r\n\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address spender) external view override returns (uint256) {\r\n        return _allowances[_owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external override returns (bool) {\r\n        _approve(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n    function _approve(address _owner, address spender, uint256 amount) private {\r\n        require(_owner != address(0), \"Approve from zero\");\r\n        require(spender != address(0), \"Approve to zero\");\r\n\r\n        _allowances[_owner][spender] = amount;\r\n        emit Approval(_owner, spender, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n\r\n        uint256 currentAllowance = _allowances[sender][msg.sender];\r\n        require(currentAllowance >= amount, \"Transfer > allowance\");\r\n\r\n        _approve(sender, msg.sender, currentAllowance - amount);\r\n        return true;\r\n    }\r\n\r\n    \r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\r\n        uint256 currentAllowance = _allowances[msg.sender][spender];\r\n        require(currentAllowance >= subtractedValue, \"<0 allowance\");\r\n\r\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\r\n        return true;\r\n    }    \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"info\",\"type\":\"bytes32\"}],\"name\":\"error_on_swap\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"Dead\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"InitialSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UniswapRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_allowances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"_balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_circulatingSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"anti_bot\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"}],\"name\":\"authorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avoid_locks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bot_crash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coder_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"development_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enable_trading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"}],\"name\":\"get_tax_on\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initial_max_tx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"is_tax_free\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidity_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_tx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair_contract\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Pair\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"president_eth_balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tknAddress\",\"type\":\"address\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_coder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_development\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"retrieve_president\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router_contract\",\"outputs\":[{\"internalType\":\"contract IUniswapRouter02\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"booly\",\"type\":\"bool\"}],\"name\":\"set_authorized\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"set_coder_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"set_development_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"set_marketing_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"set_president_wallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"actor\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"set_tax_free\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"destination\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"_president\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_coder\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_liquidity\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_marketing\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_development\",\"type\":\"uint16\"}],\"name\":\"set_tax_on\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swap_treshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DLAND", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5daa961bc2d1774803a846c8d68227d5432f111168a08da75022c906099c645d"}]}