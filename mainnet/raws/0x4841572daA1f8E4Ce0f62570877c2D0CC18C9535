{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/insured-bridge/BridgePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/BridgeAdminInterface.sol\\\";\\r\\nimport \\\"./interfaces/BridgePoolInterface.sol\\\";\\r\\n\\r\\nimport \\\"../oracle/interfaces/SkinnyOptimisticOracleInterface.sol\\\";\\r\\nimport \\\"../oracle/interfaces/StoreInterface.sol\\\";\\r\\nimport \\\"../oracle/interfaces/FinderInterface.sol\\\";\\r\\nimport \\\"../oracle/implementation/Constants.sol\\\";\\r\\n\\r\\nimport \\\"../common/implementation/AncillaryData.sol\\\";\\r\\nimport \\\"../common/implementation/Testable.sol\\\";\\r\\nimport \\\"../common/implementation/FixedPoint.sol\\\";\\r\\nimport \\\"../common/implementation/Lockable.sol\\\";\\r\\nimport \\\"../common/implementation/MultiCaller.sol\\\";\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\r\\n\\r\\ninterface WETH9Like {\\r\\n    function withdraw(uint256 wad) external;\\r\\n\\r\\n    function deposit() external payable;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @notice Contract deployed on L1 that provides methods for \\\"Relayers\\\" to fulfill deposit orders that originated on L2.\\r\\n * The Relayers can either post capital to fulfill the deposit (instant relay), or request that the funds are taken out\\r\\n * of a passive liquidity provider pool following a challenge period (slow relay). This contract ingests liquidity from\\r\\n * passive liquidity providers and returns them claims to withdraw their funds. Liquidity providers are incentivized\\r\\n * to post collateral by earning a fee per fulfilled deposit order.\\r\\n * @dev A \\\"Deposit\\\" is an order to send capital from L2 to L1, and a \\\"Relay\\\" is a fulfillment attempt of that order.\\r\\n */\\r\\ncontract BridgePool is MultiCaller, Testable, BridgePoolInterface, ERC20, Lockable {\\r\\n    using SafeERC20 for IERC20;\\r\\n    using FixedPoint for FixedPoint.Unsigned;\\r\\n    using Address for address;\\r\\n\\r\\n    // Token that this contract receives as LP deposits.\\r\\n    IERC20 public override l1Token;\\r\\n\\r\\n    // Track the total number of relays and uniquely identifies relays.\\r\\n    uint32 public numberOfRelays;\\r\\n\\r\\n    // Reserves that are unutilized and withdrawable.\\r\\n    uint256 public liquidReserves;\\r\\n\\r\\n    // Reserves currently utilized due to L2-L1 transactions in flight.\\r\\n    int256 public utilizedReserves;\\r\\n\\r\\n    // Reserves that are not yet utilized but are pre-allocated for a pending relay.\\r\\n    uint256 public pendingReserves;\\r\\n\\r\\n    // True If this pool stores WETH. If the withdrawn token is WETH then unwrap and send ETH when finalizing\\r\\n    // relays. Also enable LPs to receive ETH, if they choose, when withdrawing liquidity.\\r\\n    bool public isWethPool;\\r\\n\\r\\n    // Enables the Bridge Admin to enable/disable relays in this pool. Disables relayDeposit and relayAndSpeedUp.\\r\\n    bool public relaysEnabled = true;\\r\\n\\r\\n    // Exponential decay exchange rate to accumulate fees to LPs over time. This can be changed via the BridgeAdmin.\\r\\n    uint64 public lpFeeRatePerSecond;\\r\\n\\r\\n    // Last timestamp that LP fees were updated.\\r\\n    uint32 public lastLpFeeUpdate;\\r\\n\\r\\n    // Store local instances of contract params to save gas relaying.\\r\\n    uint64 public proposerBondPct;\\r\\n    uint32 public optimisticOracleLiveness;\\r\\n\\r\\n    // Store local instance of the reserve currency final fee. This is a gas optimization to not re-call the store.\\r\\n    uint256 l1TokenFinalFee;\\r\\n\\r\\n    // Cumulative undistributed LP fees. As fees accumulate, they are subtracted from this number.\\r\\n    uint256 public undistributedLpFees;\\r\\n\\r\\n    // Total bond amount held for pending relays. Bonds are released following a successful relay or after a dispute.\\r\\n    uint256 public bonds;\\r\\n\\r\\n    // Administrative contract that deployed this contract and also houses all state variables needed to relay deposits.\\r\\n    BridgeAdminInterface public bridgeAdmin;\\r\\n\\r\\n    // Store local instances of the contract instances to save gas relaying. Can be sync with the Finder at any time via\\r\\n    // the syncUmaEcosystemParams() public function.\\r\\n    StoreInterface public store;\\r\\n    SkinnyOptimisticOracleInterface public optimisticOracle;\\r\\n\\r\\n    // DVM price request identifier that is resolved based on the validity of a relay attempt.\\r\\n    bytes32 public identifier;\\r\\n\\r\\n    // A Relay represents an attempt to finalize a cross-chain transfer that originated on an L2 DepositBox contract.\\r\\n    // The flow chart between states is as follows:\\r\\n    // - Begin at Uninitialized.\\r\\n    // - When relayDeposit() is called, a new relay is created with state Pending and mapped to the L2 deposit hash.\\r\\n    // - If the relay is disputed, the RelayData gets deleted and the L2 deposit hash has no relay mapped to it anymore.\\r\\n    // - The above statements enable state to transfer between the Uninitialized and Pending states.\\r\\n    // - When settleRelay() is successfully called, the relay state gets set to Finalized and cannot change from there.\\r\\n    // - It is impossible for a relay to be deleted when in Finalized state (and have its state set to Uninitialized)\\r\\n    //   because the only way for settleRelay() to succeed is if the price has resolved on the OptimisticOracle.\\r\\n    // - You cannot dispute an already resolved request on the OptimisticOracle. Moreover, the mapping from\\r\\n    //   a relay's ancillary data hash to its deposit hash is deleted after a successful settleRelay() call.\\r\\n    enum RelayState { Uninitialized, Pending, Finalized }\\r\\n\\r\\n    // Data from L2 deposit transaction.\\r\\n    struct DepositData {\\r\\n        uint256 chainId;\\r\\n        uint64 depositId;\\r\\n        address payable l1Recipient;\\r\\n        address l2Sender;\\r\\n        uint256 amount;\\r\\n        uint64 slowRelayFeePct;\\r\\n        uint64 instantRelayFeePct;\\r\\n        uint32 quoteTimestamp;\\r\\n    }\\r\\n\\r\\n    // Each L2 Deposit can have one Relay attempt at any one time. A Relay attempt is characterized by its RelayData.\\r\\n    struct RelayData {\\r\\n        RelayState relayState;\\r\\n        address slowRelayer;\\r\\n        uint32 relayId;\\r\\n        uint64 realizedLpFeePct;\\r\\n        uint32 priceRequestTime;\\r\\n        uint256 proposerBond;\\r\\n        uint256 finalFee;\\r\\n    }\\r\\n\\r\\n    // Associate deposits with pending relay data. When the mapped relay hash is empty, new relay attempts can be made\\r\\n    // for this deposit. The relay data contains information necessary to pay out relayers on successful relay.\\r\\n    // Relay hashes are deleted when they are disputed on the OptimisticOracle.\\r\\n    mapping(bytes32 => bytes32) public relays;\\r\\n\\r\\n    // Map hash of deposit and realized-relay fee to instant relayers. This mapping is checked at settlement time\\r\\n    // to determine if there was a valid instant relayer.\\r\\n    mapping(bytes32 => address) public instantRelays;\\r\\n\\r\\n    event LiquidityAdded(uint256 amount, uint256 lpTokensMinted, address indexed liquidityProvider);\\r\\n    event LiquidityRemoved(uint256 amount, uint256 lpTokensBurnt, address indexed liquidityProvider);\\r\\n    event DepositRelayed(\\r\\n        bytes32 indexed depositHash,\\r\\n        DepositData depositData,\\r\\n        RelayData relay,\\r\\n        bytes32 relayAncillaryDataHash\\r\\n    );\\r\\n    event RelaySpedUp(bytes32 indexed depositHash, address indexed instantRelayer, RelayData relay);\\r\\n\\r\\n    // Note: the difference between a dispute and a cancellation is that a cancellation happens in the case where\\r\\n    // something changes in the OO between request and dispute that causes calls to it to fail. The most common\\r\\n    // case would be an increase in final fee. However, things like whitelisting can also cause problems.\\r\\n    event RelayDisputed(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\\r\\n    event RelayCanceled(bytes32 indexed depositHash, bytes32 indexed relayHash, address indexed disputer);\\r\\n    event RelaySettled(bytes32 indexed depositHash, address indexed caller, RelayData relay);\\r\\n    event BridgePoolAdminTransferred(address oldAdmin, address newAdmin);\\r\\n    event RelaysEnabledSet(bool newRelaysEnabled);\\r\\n    event LpFeeRateSet(uint64 newLpFeeRatePerSecond);\\r\\n\\r\\n    modifier onlyBridgeAdmin() {\\r\\n        require(msg.sender == address(bridgeAdmin), \\\"Caller not bridge admin\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyIfRelaysEnabld() {\\r\\n        require(relaysEnabled, \\\"Relays are disabled\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Construct the Bridge Pool.\\r\\n     * @param _lpTokenName Name of the LP token to be deployed by this contract.\\r\\n     * @param _lpTokenSymbol Symbol of the LP token to be deployed by this contract.\\r\\n     * @param _bridgeAdmin Admin contract deployed alongside on L1. Stores global variables and has owner control.\\r\\n     * @param _l1Token Address of the L1 token that this bridgePool holds. This is the token LPs deposit and is bridged.\\r\\n     * @param _lpFeeRatePerSecond Interest rate payment that scales the amount of pending fees per second paid to LPs.\\r\\n     * @param _isWethPool Toggles if this is the WETH pool. If it is then can accept ETH and wrap to WETH for the user.\\r\\n     * @param _timer Timer used to synchronize contract time in testing. Set to 0x000... in production.\\r\\n     */\\r\\n    constructor(\\r\\n        string memory _lpTokenName,\\r\\n        string memory _lpTokenSymbol,\\r\\n        address _bridgeAdmin,\\r\\n        address _l1Token,\\r\\n        uint64 _lpFeeRatePerSecond,\\r\\n        bool _isWethPool,\\r\\n        address _timer\\r\\n    ) Testable(_timer) ERC20(_lpTokenName, _lpTokenSymbol) {\\r\\n        require(bytes(_lpTokenName).length != 0 && bytes(_lpTokenSymbol).length != 0, \\\"Bad LP token name or symbol\\\");\\r\\n        bridgeAdmin = BridgeAdminInterface(_bridgeAdmin);\\r\\n        l1Token = IERC20(_l1Token);\\r\\n        lastLpFeeUpdate = uint32(getCurrentTime());\\r\\n        lpFeeRatePerSecond = _lpFeeRatePerSecond;\\r\\n        isWethPool = _isWethPool;\\r\\n\\r\\n        syncUmaEcosystemParams(); // Fetch OptimisticOracle and Store addresses and L1Token finalFee.\\r\\n        syncWithBridgeAdminParams(); // Fetch ProposerBondPct OptimisticOracleLiveness, Identifier from the BridgeAdmin.\\r\\n\\r\\n        emit LpFeeRateSet(lpFeeRatePerSecond);\\r\\n    }\\r\\n\\r\\n    /*************************************************\\r\\n     *          LIQUIDITY PROVIDER FUNCTIONS         *\\r\\n     *************************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Add liquidity to the bridge pool. Pulls l1Token from the caller's wallet. The caller is sent back a\\r\\n     * commensurate number of LP tokens (minted to their address) at the prevailing exchange rate.\\r\\n     * @dev The caller must approve this contract to transfer `l1TokenAmount` amount of l1Token if depositing ERC20.\\r\\n     * @dev The caller can deposit ETH which is auto wrapped to WETH. This can only be done if: a) this is the Weth pool\\r\\n     * and b) the l1TokenAmount matches to the transaction msg.value.\\r\\n     * @dev Reentrancy guard not added to this function because this indirectly calls sync() which is guarded.\\r\\n     * @param l1TokenAmount Number of l1Token to add as liquidity.\\r\\n     */\\r\\n    function addLiquidity(uint256 l1TokenAmount) public payable nonReentrant() {\\r\\n        // If this is the weth pool and the caller sends msg.value then the msg.value must match the l1TokenAmount.\\r\\n        // Else, msg.value must be set to 0.\\r\\n        require((isWethPool && msg.value == l1TokenAmount) || msg.value == 0, \\\"Bad add liquidity Eth value\\\");\\r\\n\\r\\n        // Since `exchangeRateCurrent()` reads this contract's balance and updates contract state using it,\\r\\n        // we must call it first before transferring any tokens to this contract.\\r\\n        uint256 lpTokensToMint = (l1TokenAmount * 1e18) / _exchangeRateCurrent();\\r\\n        _mint(msg.sender, lpTokensToMint);\\r\\n        liquidReserves += l1TokenAmount;\\r\\n\\r\\n        if (msg.value > 0 && isWethPool) WETH9Like(address(l1Token)).deposit{ value: msg.value }();\\r\\n        else l1Token.safeTransferFrom(msg.sender, address(this), l1TokenAmount);\\r\\n\\r\\n        emit LiquidityAdded(l1TokenAmount, lpTokensToMint, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes liquidity from the bridge pool. Burns lpTokenAmount LP tokens from the caller's wallet. The caller\\r\\n     * is sent back a commensurate number of l1Tokens at the prevailing exchange rate.\\r\\n     * @dev The caller does not need to approve the spending of LP tokens as this method directly uses the burn logic.\\r\\n     * @dev Reentrancy guard not added to this function because this indirectly calls sync() which is guarded.\\r\\n     * @param lpTokenAmount Number of lpTokens to redeem for underlying.\\r\\n     * @param sendEth Enable the liquidity provider to remove liquidity in ETH, if this is the WETH pool.\\r\\n     */\\r\\n    function removeLiquidity(uint256 lpTokenAmount, bool sendEth) public nonReentrant() {\\r\\n        // Can only send eth on withdrawing liquidity iff this is the WETH pool.\\r\\n        require(!sendEth || isWethPool, \\\"Cant send eth\\\");\\r\\n        uint256 l1TokensToReturn = (lpTokenAmount * _exchangeRateCurrent()) / 1e18;\\r\\n\\r\\n        // Check that there is enough liquid reserves to withdraw the requested amount.\\r\\n        require(liquidReserves >= (pendingReserves + l1TokensToReturn), \\\"Utilization too high to remove\\\");\\r\\n\\r\\n        _burn(msg.sender, lpTokenAmount);\\r\\n        liquidReserves -= l1TokensToReturn;\\r\\n\\r\\n        if (sendEth) _unwrapWETHTo(payable(msg.sender), l1TokensToReturn);\\r\\n        else l1Token.safeTransfer(msg.sender, l1TokensToReturn);\\r\\n\\r\\n        emit LiquidityRemoved(l1TokensToReturn, lpTokenAmount, msg.sender);\\r\\n    }\\r\\n\\r\\n    /**************************************\\r\\n     *          RELAYER FUNCTIONS         *\\r\\n     **************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Called by Relayer to execute a slow + fast relay from L2 to L1, fulfilling a corresponding deposit order.\\r\\n     * @dev There can only be one pending relay for a deposit. This method is effectively the relayDeposit and\\r\\n     * speedUpRelay methods concatenated. This could be refactored to just call each method, but there\\r\\n     * are some gas savings in combining the transfers and hash computations.\\r\\n     * @dev Caller must have approved this contract to spend the total bond + amount - fees for `l1Token`.\\r\\n     * @dev This function can only be called if relays are enabled for this bridge pool.\\r\\n     * @param depositData the deposit data struct containing all the user's deposit information.\\r\\n     * @param realizedLpFeePct LP fee calculated off-chain considering the L1 pool liquidity at deposit time, before\\r\\n     *      quoteTimestamp. The OO acts to verify the correctness of this realized fee. Cannot exceed 50%.\\r\\n     */\\r\\n    function relayAndSpeedUp(DepositData memory depositData, uint64 realizedLpFeePct)\\r\\n        public\\r\\n        onlyIfRelaysEnabld()\\r\\n        nonReentrant()\\r\\n    {\\r\\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\\r\\n        uint32 priceRequestTime = uint32(getCurrentTime());\\r\\n\\r\\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\\r\\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\\r\\n        require(\\r\\n            depositData.slowRelayFeePct <= 0.25e18 &&\\r\\n                depositData.instantRelayFeePct <= 0.25e18 &&\\r\\n                realizedLpFeePct <= 0.5e18,\\r\\n            \\\"Invalid fees\\\"\\r\\n        );\\r\\n\\r\\n        // Check if there is a pending relay for this deposit.\\r\\n        bytes32 depositHash = _getDepositHash(depositData);\\r\\n\\r\\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\\r\\n        require(relays[depositHash] == bytes32(0), \\\"Pending relay exists\\\");\\r\\n\\r\\n        uint256 proposerBond = _getProposerBond(depositData.amount);\\r\\n\\r\\n        // Save hash of new relay attempt parameters.\\r\\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\\r\\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\\r\\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\\r\\n        RelayData memory relayData =\\r\\n            RelayData({\\r\\n                relayState: RelayState.Pending,\\r\\n                slowRelayer: msg.sender,\\r\\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\\r\\n                realizedLpFeePct: realizedLpFeePct,\\r\\n                priceRequestTime: priceRequestTime,\\r\\n                proposerBond: proposerBond,\\r\\n                finalFee: l1TokenFinalFee\\r\\n            });\\r\\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\\r\\n        relays[depositHash] = _getRelayDataHash(relayData);\\r\\n\\r\\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\\r\\n        require(\\r\\n            // Can only speed up a pending relay without an existing instant relay associated with it.\\r\\n            instantRelays[instantRelayHash] == address(0),\\r\\n            \\\"Relay cannot be sped up\\\"\\r\\n        );\\r\\n\\r\\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\\r\\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\\r\\n        // Note: liquidReserves should always be <= balance - bonds.\\r\\n        require(liquidReserves - pendingReserves >= depositData.amount, \\\"Insufficient pool balance\\\");\\r\\n\\r\\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\\r\\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\\r\\n\\r\\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\\r\\n        // of the LP fees, the relayer fees and the instant relay fee.\\r\\n        uint256 feesTotal =\\r\\n            _getAmountFromPct(\\r\\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\\r\\n                depositData.amount\\r\\n            );\\r\\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\\r\\n        uint256 recipientAmount = depositData.amount - feesTotal;\\r\\n\\r\\n        bonds += totalBond;\\r\\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\\r\\n\\r\\n        instantRelays[instantRelayHash] = msg.sender;\\r\\n\\r\\n        l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount + totalBond);\\r\\n\\r\\n        // If this is a weth pool then unwrap and send eth.\\r\\n        if (isWethPool) {\\r\\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\\r\\n            // Else, this is a normal ERC20 token. Send to recipient.\\r\\n        } else l1Token.safeTransfer(depositData.l1Recipient, recipientAmount);\\r\\n\\r\\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\\r\\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by Disputer to dispute an ongoing relay.\\r\\n     * @dev The result of this method is to always throw out the relay, providing an opportunity for another relay for\\r\\n     * the same deposit. Between the disputer and proposer, whoever is incorrect loses their bond. Whoever is correct\\r\\n     * gets it back + a payout.\\r\\n     * @dev Caller must have approved this contract to spend the total bond + amount - fees for `l1Token`.\\r\\n     * @param depositData the deposit data struct containing all the user's deposit information.\\r\\n     * @param relayData RelayData logged in the disputed relay.\\r\\n     */\\r\\n    function disputeRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\\r\\n        require(relayData.priceRequestTime + optimisticOracleLiveness > getCurrentTime(), \\\"Past liveness\\\");\\r\\n        require(relayData.relayState == RelayState.Pending, \\\"Not disputable\\\");\\r\\n        // Validate the input data.\\r\\n        bytes32 depositHash = _getDepositHash(depositData);\\r\\n        _validateRelayDataHash(depositHash, relayData);\\r\\n\\r\\n        // Submit the proposal and dispute to the OO.\\r\\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\\r\\n\\r\\n        // Note: in some cases this will fail due to changes in the OO and the method will refund the relayer.\\r\\n        bool success =\\r\\n            _requestProposeDispute(\\r\\n                relayData.slowRelayer,\\r\\n                msg.sender,\\r\\n                relayData.proposerBond,\\r\\n                relayData.finalFee,\\r\\n                _getRelayAncillaryData(relayHash)\\r\\n            );\\r\\n\\r\\n        // Drop the relay and remove the bond from the tracked bonds.\\r\\n        bonds -= relayData.finalFee + relayData.proposerBond;\\r\\n        pendingReserves -= depositData.amount;\\r\\n        delete relays[depositHash];\\r\\n        if (success) emit RelayDisputed(depositHash, _getRelayDataHash(relayData), msg.sender);\\r\\n        else emit RelayCanceled(depositHash, _getRelayDataHash(relayData), msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Called by Relayer to execute a slow relay from L2 to L1, fulfilling a corresponding deposit order.\\r\\n     * @dev There can only be one pending relay for a deposit.\\r\\n     * @dev Caller must have approved this contract to spend the total bond + amount - fees for `l1Token`.\\r\\n     * @dev This function can only be called if relays are enabled for this bridge pool.\\r\\n     * @param depositData the deposit data struct containing all the user's deposit information.\\r\\n     * @param realizedLpFeePct LP fee calculated off-chain considering the L1 pool liquidity at deposit time, before\\r\\n     *      quoteTimestamp. The OO acts to verify the correctness of this realized fee. Cannot exceed 50%.\\r\\n     */\\r\\n    function relayDeposit(DepositData memory depositData, uint64 realizedLpFeePct)\\r\\n        public\\r\\n        onlyIfRelaysEnabld()\\r\\n        nonReentrant()\\r\\n    {\\r\\n        // The realizedLPFeePct should never be greater than 0.5e18 and the slow and instant relay fees should never be\\r\\n        // more than 0.25e18 each. Therefore, the sum of all fee types can never exceed 1e18 (or 100%).\\r\\n        require(\\r\\n            depositData.slowRelayFeePct <= 0.25e18 &&\\r\\n                depositData.instantRelayFeePct <= 0.25e18 &&\\r\\n                realizedLpFeePct <= 0.5e18,\\r\\n            \\\"Invalid fees\\\"\\r\\n        );\\r\\n\\r\\n        // Check if there is a pending relay for this deposit.\\r\\n        bytes32 depositHash = _getDepositHash(depositData);\\r\\n\\r\\n        // Note: A disputed relay deletes the stored relay hash and enables this require statement to pass.\\r\\n        require(relays[depositHash] == bytes32(0), \\\"Pending relay exists\\\");\\r\\n\\r\\n        // If no pending relay for this deposit, then associate the caller's relay attempt with it.\\r\\n        uint32 priceRequestTime = uint32(getCurrentTime());\\r\\n\\r\\n        uint256 proposerBond = _getProposerBond(depositData.amount);\\r\\n\\r\\n        // Save hash of new relay attempt parameters.\\r\\n        // Note: The liveness for this relay can be changed in the BridgeAdmin, which means that each relay has a\\r\\n        // potentially variable liveness time. This should not provide any exploit opportunities, especially because\\r\\n        // the BridgeAdmin state (including the liveness value) is permissioned to the cross domained owner.\\r\\n        RelayData memory relayData =\\r\\n            RelayData({\\r\\n                relayState: RelayState.Pending,\\r\\n                slowRelayer: msg.sender,\\r\\n                relayId: numberOfRelays++, // Note: Increment numberOfRelays at the same time as setting relayId to its current value.\\r\\n                realizedLpFeePct: realizedLpFeePct,\\r\\n                priceRequestTime: priceRequestTime,\\r\\n                proposerBond: proposerBond,\\r\\n                finalFee: l1TokenFinalFee\\r\\n            });\\r\\n        relays[depositHash] = _getRelayDataHash(relayData);\\r\\n\\r\\n        bytes32 relayHash = _getRelayHash(depositData, relayData);\\r\\n\\r\\n        // Sanity check that pool has enough balance to cover relay amount + proposer reward. Reward amount will be\\r\\n        // paid on settlement after the OptimisticOracle price request has passed the challenge period.\\r\\n        // Note: liquidReserves should always be <= balance - bonds.\\r\\n        require(liquidReserves - pendingReserves >= depositData.amount, \\\"Insufficient pool balance\\\");\\r\\n\\r\\n        // Compute total proposal bond and pull from caller so that the OptimisticOracle can pull it from here.\\r\\n        uint256 totalBond = proposerBond + l1TokenFinalFee;\\r\\n        pendingReserves += depositData.amount; // Book off maximum liquidity used by this relay in the pending reserves.\\r\\n        bonds += totalBond;\\r\\n\\r\\n        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\\r\\n        emit DepositRelayed(depositHash, depositData, relayData, relayHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Instantly relay a deposit amount minus fees to the l1Recipient. Instant relayer earns a reward following\\r\\n     * the pending relay challenge period.\\r\\n     * @dev We assume that the caller has performed an off-chain check that the deposit data they are attempting to\\r\\n     * relay is valid. If the deposit data is invalid, then the instant relayer has no recourse to receive their funds\\r\\n     * back after the invalid deposit data is disputed. Moreover, no one will be able to resubmit a relay for the\\r\\n     * invalid deposit data because they know it will get disputed again. On the other hand, if the deposit data is\\r\\n     * valid, then even if it is falsely disputed, the instant relayer will eventually get reimbursed because someone\\r\\n     * else will be incentivized to resubmit the relay to earn slow relayer rewards. Once the valid relay is finalized,\\r\\n     * the instant relayer will be reimbursed. Therefore, the caller has the same responsibility as the disputer in\\r\\n     * validating the relay data.\\r\\n     * @dev Caller must have approved this contract to spend the deposit amount of L1 tokens to relay. There can only\\r\\n     * be one instant relayer per relay attempt. You cannot speed up a relay that is past liveness.\\r\\n     * @param depositData Unique set of L2 deposit data that caller is trying to instantly relay.\\r\\n     * @param relayData Parameters of Relay that caller is attempting to speedup. Must hash to the stored relay hash\\r\\n     * for this deposit or this method will revert.\\r\\n     */\\r\\n    function speedUpRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\\r\\n        bytes32 depositHash = _getDepositHash(depositData);\\r\\n        _validateRelayDataHash(depositHash, relayData);\\r\\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\\r\\n        require(\\r\\n            // Can only speed up a pending relay without an existing instant relay associated with it.\\r\\n            getCurrentTime() < relayData.priceRequestTime + optimisticOracleLiveness &&\\r\\n                relayData.relayState == RelayState.Pending &&\\r\\n                instantRelays[instantRelayHash] == address(0),\\r\\n            \\\"Relay cannot be sped up\\\"\\r\\n        );\\r\\n        instantRelays[instantRelayHash] = msg.sender;\\r\\n\\r\\n        // Pull relay amount minus fees from caller and send to the deposit l1Recipient. The total fees paid is the sum\\r\\n        // of the LP fees, the relayer fees and the instant relay fee.\\r\\n        uint256 feesTotal =\\r\\n            _getAmountFromPct(\\r\\n                relayData.realizedLpFeePct + depositData.slowRelayFeePct + depositData.instantRelayFeePct,\\r\\n                depositData.amount\\r\\n            );\\r\\n        // If the L1 token is WETH then: a) pull WETH from instant relayer b) unwrap WETH c) send ETH to recipient.\\r\\n        uint256 recipientAmount = depositData.amount - feesTotal;\\r\\n        if (isWethPool) {\\r\\n            l1Token.safeTransferFrom(msg.sender, address(this), recipientAmount);\\r\\n            _unwrapWETHTo(depositData.l1Recipient, recipientAmount);\\r\\n            // Else, this is a normal ERC20 token. Send to recipient.\\r\\n        } else l1Token.safeTransferFrom(msg.sender, depositData.l1Recipient, recipientAmount);\\r\\n\\r\\n        emit RelaySpedUp(depositHash, msg.sender, relayData);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reward relayers if a pending relay price request has a price available on the OptimisticOracle. Mark\\r\\n     * the relay as complete.\\r\\n     * @dev We use the relayData and depositData to compute the ancillary data that the relay price request is uniquely\\r\\n     * associated with on the OptimisticOracle. If the price request passed in does not match the pending relay price\\r\\n     * request, then this will revert.\\r\\n     * @param depositData Unique set of L2 deposit data that caller is trying to settle a relay for.\\r\\n     * @param relayData Parameters of Relay that caller is attempting to settle. Must hash to the stored relay hash\\r\\n     * for this deposit.\\r\\n     */\\r\\n    function settleRelay(DepositData memory depositData, RelayData memory relayData) public nonReentrant() {\\r\\n        bytes32 depositHash = _getDepositHash(depositData);\\r\\n        _validateRelayDataHash(depositHash, relayData);\\r\\n        require(relayData.relayState == RelayState.Pending, \\\"Already settled\\\");\\r\\n        uint32 expirationTime = relayData.priceRequestTime + optimisticOracleLiveness;\\r\\n        require(expirationTime <= getCurrentTime(), \\\"Not settleable yet\\\");\\r\\n\\r\\n        // Note: this check is to give the relayer a small, but reasonable amount of time to complete the relay before\\r\\n        // before it can be \\\"stolen\\\" by someone else. This is to ensure there is an incentive to settle relays quickly.\\r\\n        require(\\r\\n            msg.sender == relayData.slowRelayer || getCurrentTime() > expirationTime + 15 minutes,\\r\\n            \\\"Not slow relayer\\\"\\r\\n        );\\r\\n\\r\\n        // Update the relay state to Finalized. This prevents any re-settling of a relay.\\r\\n        relays[depositHash] = _getRelayDataHash(\\r\\n            RelayData({\\r\\n                relayState: RelayState.Finalized,\\r\\n                slowRelayer: relayData.slowRelayer,\\r\\n                relayId: relayData.relayId,\\r\\n                realizedLpFeePct: relayData.realizedLpFeePct,\\r\\n                priceRequestTime: relayData.priceRequestTime,\\r\\n                proposerBond: relayData.proposerBond,\\r\\n                finalFee: relayData.finalFee\\r\\n            })\\r\\n        );\\r\\n\\r\\n        // Reward relayers and pay out l1Recipient.\\r\\n        // At this point there are two possible cases:\\r\\n        // - This was a slow relay: In this case, a) pay the slow relayer their reward and b) pay the l1Recipient of the\\r\\n        //      amount minus the realized LP fee and the slow Relay fee. The transfer was not sped up so no instant fee.\\r\\n        // - This was an instant relay: In this case, a) pay the slow relayer their reward and b) pay the instant relayer\\r\\n        //      the full bridging amount, minus the realized LP fee and minus the slow relay fee. When the instant\\r\\n        //      relayer called speedUpRelay they were docked this same amount, minus the instant relayer fee. As a\\r\\n        //      result, they are effectively paid what they spent when speeding up the relay + the instantRelayFee.\\r\\n\\r\\n        uint256 instantRelayerOrRecipientAmount =\\r\\n            depositData.amount -\\r\\n                _getAmountFromPct(relayData.realizedLpFeePct + depositData.slowRelayFeePct, depositData.amount);\\r\\n\\r\\n        // Refund the instant relayer iff the instant relay params match the approved relay.\\r\\n        bytes32 instantRelayHash = _getInstantRelayHash(depositHash, relayData);\\r\\n        address instantRelayer = instantRelays[instantRelayHash];\\r\\n\\r\\n        // If this is the WETH pool and the instant relayer is is address 0x0 (i.e the relay was not sped up) then:\\r\\n        // a) withdraw WETH to ETH and b) send the ETH to the recipient.\\r\\n        if (isWethPool && instantRelayer == address(0)) {\\r\\n            _unwrapWETHTo(depositData.l1Recipient, instantRelayerOrRecipientAmount);\\r\\n            // Else, this is a normal slow relay being finalizes where the contract sends ERC20 to the recipient OR this\\r\\n            // is the finalization of an instant relay where we need to reimburse the instant relayer in WETH.\\r\\n        } else\\r\\n            l1Token.safeTransfer(\\r\\n                instantRelayer != address(0) ? instantRelayer : depositData.l1Recipient,\\r\\n                instantRelayerOrRecipientAmount\\r\\n            );\\r\\n\\r\\n        // There is a fee and a bond to pay out. The fee goes to whoever settles. The bond always goes back to the\\r\\n        // slow relayer.\\r\\n        // Note: for gas efficiency, we use an if so we can combine these transfers in the event that they are the same\\r\\n        // address.\\r\\n        uint256 slowRelayerReward = _getAmountFromPct(depositData.slowRelayFeePct, depositData.amount);\\r\\n        uint256 totalBond = relayData.finalFee + relayData.proposerBond;\\r\\n        if (relayData.slowRelayer == msg.sender)\\r\\n            l1Token.safeTransfer(relayData.slowRelayer, slowRelayerReward + totalBond);\\r\\n        else {\\r\\n            l1Token.safeTransfer(relayData.slowRelayer, totalBond);\\r\\n            l1Token.safeTransfer(msg.sender, slowRelayerReward);\\r\\n        }\\r\\n\\r\\n        uint256 totalReservesSent = instantRelayerOrRecipientAmount + slowRelayerReward;\\r\\n\\r\\n        // Update reserves by amounts changed and allocated LP fees.\\r\\n        pendingReserves -= depositData.amount;\\r\\n        liquidReserves -= totalReservesSent;\\r\\n        utilizedReserves += int256(totalReservesSent);\\r\\n        bonds -= totalBond;\\r\\n        _updateAccumulatedLpFees();\\r\\n        _allocateLpFees(_getAmountFromPct(relayData.realizedLpFeePct, depositData.amount));\\r\\n\\r\\n        emit RelaySettled(depositHash, msg.sender, relayData);\\r\\n\\r\\n        // Clean up state storage and receive gas refund. This also prevents `priceDisputed()` from being able to reset\\r\\n        // this newly Finalized relay state.\\r\\n        delete instantRelays[instantRelayHash];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Synchronize any balance changes in this contract with the utilized & liquid reserves. This would be done\\r\\n     * at the conclusion of an L2 -> L1 token transfer via the canonical token bridge.\\r\\n     */\\r\\n    function sync() public nonReentrant() {\\r\\n        _sync();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the exchange rate between LP tokens and L1Tokens. Used when adding/removing liquidity.\\r\\n     * @return The updated exchange rate between LP tokens and L1 tokens.\\r\\n     */\\r\\n    function exchangeRateCurrent() public nonReentrant() returns (uint256) {\\r\\n        return _exchangeRateCurrent();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the current liquidity utilization ratio.\\r\\n     * @dev Used in computing realizedLpFeePct off-chain.\\r\\n     * @return The current utilization ratio.\\r\\n     */\\r\\n    function liquidityUtilizationCurrent() public nonReentrant() returns (uint256) {\\r\\n        return _liquidityUtilizationPostRelay(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the liquidity utilization ratio post a relay of known size.\\r\\n     * @dev Used in computing realizedLpFeePct off-chain.\\r\\n     * @param relayedAmount Size of the relayed deposit to factor into the utilization calculation.\\r\\n     * @return The updated utilization ratio accounting for a new `relayedAmount`.\\r\\n     */\\r\\n    function liquidityUtilizationPostRelay(uint256 relayedAmount) public nonReentrant() returns (uint256) {\\r\\n        return _liquidityUtilizationPostRelay(relayedAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return both the current utilization value and liquidity utilization post the relay.\\r\\n     * @dev Used in computing realizedLpFeePct off-chain.\\r\\n     * @param relayedAmount Size of the relayed deposit to factor into the utilization calculation.\\r\\n     * @return utilizationCurrent The current utilization ratio.\\r\\n     * @return utilizationPostRelay The updated utilization ratio accounting for a new `relayedAmount`.\\r\\n     */\\r\\n    function getLiquidityUtilization(uint256 relayedAmount)\\r\\n        public\\r\\n        nonReentrant()\\r\\n        returns (uint256 utilizationCurrent, uint256 utilizationPostRelay)\\r\\n    {\\r\\n        return (_liquidityUtilizationPostRelay(0), _liquidityUtilizationPostRelay(relayedAmount));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the address stored in this contract for the OptimisticOracle and the Store to the latest versions\\r\\n     * set in the the Finder. Also pull finalFee Store these as local variables to make relay methods gas efficient.\\r\\n     * @dev There is no risk of leaving this function public for anyone to call as in all cases we want the addresses\\r\\n     * in this contract to map to the latest version in the Finder and store the latest final fee.\\r\\n     */\\r\\n    function syncUmaEcosystemParams() public nonReentrant() {\\r\\n        FinderInterface finder = FinderInterface(bridgeAdmin.finder());\\r\\n        optimisticOracle = SkinnyOptimisticOracleInterface(\\r\\n            finder.getImplementationAddress(OracleInterfaces.SkinnyOptimisticOracle)\\r\\n        );\\r\\n\\r\\n        store = StoreInterface(finder.getImplementationAddress(OracleInterfaces.Store));\\r\\n        l1TokenFinalFee = store.computeFinalFee(address(l1Token)).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates the values of stored constants for the proposerBondPct, optimisticOracleLiveness and identifier\\r\\n     * to that set in the bridge Admin. We store these as local variables to make the relay methods more gas efficient.\\r\\n     * @dev There is no risk of leaving this function public for anyone to call as in all cases we want these values\\r\\n     * in this contract to map to the latest version set in the BridgeAdmin.\\r\\n     */\\r\\n    function syncWithBridgeAdminParams() public nonReentrant() {\\r\\n        proposerBondPct = bridgeAdmin.proposerBondPct();\\r\\n        optimisticOracleLiveness = bridgeAdmin.optimisticOracleLiveness();\\r\\n        identifier = bridgeAdmin.identifier();\\r\\n    }\\r\\n\\r\\n    /************************************\\r\\n     *          ADMIN FUNCTIONS         *\\r\\n     ************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Enable the current bridge admin to transfer admin to to a new address.\\r\\n     * @dev Caller must be BridgeAdmin contract.\\r\\n     * @param _newAdmin Admin address of the new admin.\\r\\n     */\\r\\n    function changeAdmin(address _newAdmin) public override onlyBridgeAdmin() nonReentrant() {\\r\\n        bridgeAdmin = BridgeAdminInterface(_newAdmin);\\r\\n        emit BridgePoolAdminTransferred(msg.sender, _newAdmin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enable the bridge admin to change the decay rate at which LP shares accumulate fees. The higher this\\r\\n     * value, the faster LP shares realize pending fees.\\r\\n     * @dev Caller must be BridgeAdmin contract.\\r\\n     * @param _newLpFeeRatePerSecond The new rate to set.\\r\\n     */\\r\\n    function setLpFeeRatePerSecond(uint64 _newLpFeeRatePerSecond) public override onlyBridgeAdmin() nonReentrant() {\\r\\n        lpFeeRatePerSecond = _newLpFeeRatePerSecond;\\r\\n        emit LpFeeRateSet(lpFeeRatePerSecond);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enable the bridge admin to enable/disable relays for this pool. Acts as a pause. Only effects\\r\\n     * relayDeposit and relayAndSpeedUp methods. ALl other contract logic remains functional after a pause.\\r\\n     * @dev Caller must be BridgeAdmin contract.\\r\\n     * @param _relaysEnabled The new relaysEnabled state.\\r\\n     */\\r\\n    function setRelaysEnabled(bool _relaysEnabled) public override onlyBridgeAdmin() nonReentrant() {\\r\\n        relaysEnabled = _relaysEnabled;\\r\\n        emit RelaysEnabledSet(_relaysEnabled);\\r\\n    }\\r\\n\\r\\n    /************************************\\r\\n     *           VIEW FUNCTIONS         *\\r\\n     ************************************/\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the current amount of unallocated fees that have accumulated from the previous time this the\\r\\n     * contract was called.\\r\\n     */\\r\\n    function getAccumulatedFees() public view nonReentrantView() returns (uint256) {\\r\\n        return _getAccumulatedFees();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns ancillary data containing all relevant Relay data that voters can format into UTF8 and use to\\r\\n     * determine if the relay is valid.\\r\\n     * @dev Helpful method to test that ancillary data is constructed properly. We should consider removing if we don't\\r\\n     * anticipate off-chain bots or users to call this method.\\r\\n     * @param depositData Contains L2 deposit information used by off-chain validators to validate relay.\\r\\n     * @param relayData Contains relay information used by off-chain validators to validate relay.\\r\\n     * @return bytes New ancillary data that can be decoded into UTF8.\\r\\n     */\\r\\n    function getRelayAncillaryData(DepositData memory depositData, RelayData memory relayData)\\r\\n        public\\r\\n        view\\r\\n        nonReentrantView()\\r\\n        returns (bytes memory)\\r\\n    {\\r\\n        return _getRelayAncillaryData(_getRelayHash(depositData, relayData));\\r\\n    }\\r\\n\\r\\n    /**************************************\\r\\n     *    INTERNAL & PRIVATE FUNCTIONS    *\\r\\n     **************************************/\\r\\n\\r\\n    function _liquidityUtilizationPostRelay(uint256 relayedAmount) internal returns (uint256) {\\r\\n        _sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\\r\\n\\r\\n        // liquidityUtilizationRatio :=\\r\\n        // (relayedAmount + pendingReserves + max(utilizedReserves,0)) / (liquidReserves + max(utilizedReserves,0))\\r\\n        // UtilizedReserves has a dual meaning: if it's greater than zero then it represents funds pending in the bridge\\r\\n        // that will flow from L2 to L1. In this case, we can use it normally in the equation. However, if it is\\r\\n        // negative, then it is already counted in liquidReserves. This occurs if tokens are transferred directly to the\\r\\n        // contract. In this case, ignore it as it is captured in liquid reserves and has no meaning in the numerator.\\r\\n        uint256 flooredUtilizedReserves = utilizedReserves > 0 ? uint256(utilizedReserves) : 0;\\r\\n        uint256 numerator = relayedAmount + pendingReserves + flooredUtilizedReserves;\\r\\n        uint256 denominator = liquidReserves + flooredUtilizedReserves;\\r\\n\\r\\n        // If the denominator equals zero, return 1e18 (max utilization).\\r\\n        if (denominator == 0) return 1e18;\\r\\n\\r\\n        // In all other cases, return the utilization ratio.\\r\\n        return (numerator * 1e18) / denominator;\\r\\n    }\\r\\n\\r\\n    function _sync() internal {\\r\\n        // Check if the l1Token balance of the contract is greater than the liquidReserves. If it is then the bridging\\r\\n        // action from L2 -> L1 has concluded and the local accounting can be updated.\\r\\n        uint256 l1TokenBalance = l1Token.balanceOf(address(this)) - bonds;\\r\\n        if (l1TokenBalance > liquidReserves) {\\r\\n            // utilizedReserves can go to less than zero. This will happen if the accumulated fees exceeds the current\\r\\n            // outstanding utilization. In other words, if outstanding bridging transfers are 0 then utilizedReserves\\r\\n            // will equal the total LP fees accumulated over all time.\\r\\n            utilizedReserves -= int256(l1TokenBalance - liquidReserves);\\r\\n            liquidReserves = l1TokenBalance;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _exchangeRateCurrent() internal returns (uint256) {\\r\\n        if (totalSupply() == 0) return 1e18; // initial rate is 1 pre any mint action.\\r\\n\\r\\n        // First, update fee counters and local accounting of finalized transfers from L2 -> L1.\\r\\n        _updateAccumulatedLpFees(); // Accumulate all allocated fees from the last time this method was called.\\r\\n        _sync(); // Fetch any balance changes due to token bridging finalization and factor them in.\\r\\n\\r\\n        // ExchangeRate := (liquidReserves + utilizedReserves - undistributedLpFees) / lpTokenSupply\\r\\n        // Note that utilizedReserves can be negative. If this is the case, then liquidReserves is offset by an equal\\r\\n        // and opposite size. LiquidReserves + utilizedReserves will always be larger than undistributedLpFees so this\\r\\n        // int will always be positive so there is no risk in underflow in type casting in the return line.\\r\\n        int256 numerator = int256(liquidReserves) + utilizedReserves - int256(undistributedLpFees);\\r\\n        return (uint256(numerator) * 1e18) / totalSupply();\\r\\n    }\\r\\n\\r\\n    // Return UTF8-decodable ancillary data for relay price request associated with relay hash.\\r\\n    function _getRelayAncillaryData(bytes32 relayHash) private pure returns (bytes memory) {\\r\\n        return AncillaryData.appendKeyValueBytes32(\\\"\\\", \\\"relayHash\\\", relayHash);\\r\\n    }\\r\\n\\r\\n    // Returns hash of unique relay and deposit event. This is added to the relay request's ancillary data.\\r\\n    function _getRelayHash(DepositData memory depositData, RelayData memory relayData) private view returns (bytes32) {\\r\\n        return keccak256(abi.encode(depositData, relayData.relayId, relayData.realizedLpFeePct, address(l1Token)));\\r\\n    }\\r\\n\\r\\n    // Return hash of relay data, which is stored in state and mapped to a deposit hash.\\r\\n    function _getRelayDataHash(RelayData memory relayData) private pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(relayData));\\r\\n    }\\r\\n\\r\\n    // Reverts if the stored relay data hash for `depositHash` does not match `_relayData`.\\r\\n    function _validateRelayDataHash(bytes32 depositHash, RelayData memory relayData) private view {\\r\\n        require(\\r\\n            relays[depositHash] == _getRelayDataHash(relayData),\\r\\n            \\\"Hashed relay params do not match existing relay hash for deposit\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // Return hash of unique instant relay and deposit event. This is stored in state and mapped to a deposit hash.\\r\\n    function _getInstantRelayHash(bytes32 depositHash, RelayData memory relayData) private pure returns (bytes32) {\\r\\n        // Only include parameters that affect the \\\"correctness\\\" of an instant relay. For example, the realized LP fee\\r\\n        // % directly affects how many tokens the instant relayer needs to send to the user, whereas the address of the\\r\\n        // instant relayer does not matter for determining whether an instant relay is \\\"correct\\\".\\r\\n        return keccak256(abi.encode(depositHash, relayData.realizedLpFeePct));\\r\\n    }\\r\\n\\r\\n    function _getAccumulatedFees() internal view returns (uint256) {\\r\\n        // UnallocatedLpFees := min(undistributedLpFees*lpFeeRatePerSecond*timeFromLastInteraction,undistributedLpFees)\\r\\n        // The min acts to pay out all fees in the case the equation returns more than the remaining a fees.\\r\\n        uint256 possibleUnpaidFees =\\r\\n            (undistributedLpFees * lpFeeRatePerSecond * (getCurrentTime() - lastLpFeeUpdate)) / (1e18);\\r\\n        return possibleUnpaidFees < undistributedLpFees ? possibleUnpaidFees : undistributedLpFees;\\r\\n    }\\r\\n\\r\\n    // Update internal fee counters by adding in any accumulated fees from the last time this logic was called.\\r\\n    function _updateAccumulatedLpFees() internal {\\r\\n        // Calculate the unallocatedAccumulatedFees from the last time the contract was called.\\r\\n        uint256 unallocatedAccumulatedFees = _getAccumulatedFees();\\r\\n\\r\\n        // Decrement the undistributedLpFees by the amount of accumulated fees.\\r\\n        undistributedLpFees = undistributedLpFees - unallocatedAccumulatedFees;\\r\\n\\r\\n        lastLpFeeUpdate = uint32(getCurrentTime());\\r\\n    }\\r\\n\\r\\n    // Allocate fees to the LPs by incrementing counters.\\r\\n    function _allocateLpFees(uint256 allocatedLpFees) internal {\\r\\n        // Add to the total undistributed LP fees and the utilized reserves. Adding it to the utilized reserves acts to\\r\\n        // track the fees while they are in transit.\\r\\n        undistributedLpFees += allocatedLpFees;\\r\\n        utilizedReserves += int256(allocatedLpFees);\\r\\n    }\\r\\n\\r\\n    function _getAmountFromPct(uint64 percent, uint256 amount) private pure returns (uint256) {\\r\\n        return (percent * amount) / 1e18;\\r\\n    }\\r\\n\\r\\n    function _getProposerBond(uint256 amount) private view returns (uint256) {\\r\\n        return _getAmountFromPct(proposerBondPct, amount);\\r\\n    }\\r\\n\\r\\n    function _getDepositHash(DepositData memory depositData) private view returns (bytes32) {\\r\\n        return keccak256(abi.encode(depositData, address(l1Token)));\\r\\n    }\\r\\n\\r\\n    // Proposes new price of True for relay event associated with `customAncillaryData` to optimistic oracle. If anyone\\r\\n    // disagrees with the relay parameters and whether they map to an L2 deposit, they can dispute with the oracle.\\r\\n    function _requestProposeDispute(\\r\\n        address proposer,\\r\\n        address disputer,\\r\\n        uint256 proposerBond,\\r\\n        uint256 finalFee,\\r\\n        bytes memory customAncillaryData\\r\\n    ) private returns (bool) {\\r\\n        uint256 totalBond = finalFee + proposerBond;\\r\\n        l1Token.safeApprove(address(optimisticOracle), totalBond);\\r\\n        try\\r\\n            optimisticOracle.requestAndProposePriceFor(\\r\\n                identifier,\\r\\n                uint32(getCurrentTime()),\\r\\n                customAncillaryData,\\r\\n                IERC20(l1Token),\\r\\n                // Set reward to 0, since we'll settle proposer reward payouts directly from this contract after a relay\\r\\n                // proposal has passed the challenge period.\\r\\n                0,\\r\\n                // Set the Optimistic oracle proposer bond for the price request.\\r\\n                proposerBond,\\r\\n                // Set the Optimistic oracle liveness for the price request.\\r\\n                optimisticOracleLiveness,\\r\\n                proposer,\\r\\n                // Canonical value representing \\\"True\\\"; i.e. the proposed relay is valid.\\r\\n                int256(1e18)\\r\\n            )\\r\\n        returns (uint256 bondSpent) {\\r\\n            if (bondSpent < totalBond) {\\r\\n                // If the OO pulls less (due to a change in final fee), refund the proposer.\\r\\n                uint256 refund = totalBond - bondSpent;\\r\\n                l1Token.safeTransfer(proposer, refund);\\r\\n                l1Token.safeApprove(address(optimisticOracle), 0);\\r\\n                totalBond = bondSpent;\\r\\n            }\\r\\n        } catch {\\r\\n            // If there's an error in the OO, this means something has changed to make this request undisputable.\\r\\n            // To ensure the request does not go through by default, refund the proposer and return early, allowing\\r\\n            // the calling method to delete the request, but with no additional recourse by the OO.\\r\\n            l1Token.safeTransfer(proposer, totalBond);\\r\\n            l1Token.safeApprove(address(optimisticOracle), 0);\\r\\n\\r\\n            // Return early noting that the attempt at a proposal + dispute did not succeed.\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        SkinnyOptimisticOracleInterface.Request memory request =\\r\\n            SkinnyOptimisticOracleInterface.Request({\\r\\n                proposer: proposer,\\r\\n                disputer: address(0),\\r\\n                currency: IERC20(l1Token),\\r\\n                settled: false,\\r\\n                proposedPrice: int256(1e18),\\r\\n                resolvedPrice: 0,\\r\\n                expirationTime: getCurrentTime() + optimisticOracleLiveness,\\r\\n                reward: 0,\\r\\n                finalFee: totalBond - proposerBond,\\r\\n                bond: proposerBond,\\r\\n                customLiveness: uint256(optimisticOracleLiveness)\\r\\n            });\\r\\n\\r\\n        // Note: don't pull funds until here to avoid any transfers that aren't needed.\\r\\n        l1Token.safeTransferFrom(msg.sender, address(this), totalBond);\\r\\n        l1Token.safeApprove(address(optimisticOracle), totalBond);\\r\\n        // Dispute the request that we just sent.\\r\\n        optimisticOracle.disputePriceFor(\\r\\n            identifier,\\r\\n            uint32(getCurrentTime()),\\r\\n            customAncillaryData,\\r\\n            request,\\r\\n            disputer,\\r\\n            address(this)\\r\\n        );\\r\\n\\r\\n        // Return true to denote that the proposal + dispute calls succeeded.\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    // Unwraps ETH and does a transfer to a recipient address. If the recipient is a smart contract then sends WETH.\\r\\n    function _unwrapWETHTo(address payable to, uint256 amount) internal {\\r\\n        if (address(to).isContract()) {\\r\\n            l1Token.safeTransfer(to, amount);\\r\\n        } else {\\r\\n            WETH9Like(address(l1Token)).withdraw(amount);\\r\\n            to.transfer(amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Added to enable the BridgePool to receive ETH. used when unwrapping Weth.\\r\\n    receive() external payable {}\\r\\n}\\r\\n\\r\\n/**\\r\\n * @notice This is the BridgePool contract that should be deployed on live networks. It is exactly the same as the\\r\\n * regular BridgePool contract, but it overrides getCurrentTime to make the call a simply return block.timestamp with\\r\\n * no branching or storage queries. This is done to save gas.\\r\\n */\\r\\ncontract BridgePoolProd is BridgePool {\\r\\n    constructor(\\r\\n        string memory _lpTokenName,\\r\\n        string memory _lpTokenSymbol,\\r\\n        address _bridgeAdmin,\\r\\n        address _l1Token,\\r\\n        uint64 _lpFeeRatePerSecond,\\r\\n        bool _isWethPool,\\r\\n        address _timer\\r\\n    ) BridgePool(_lpTokenName, _lpTokenSymbol, _bridgeAdmin, _l1Token, _lpFeeRatePerSecond, _isWethPool, _timer) {}\\r\\n\\r\\n    function getCurrentTime() public view virtual override returns (uint256) {\\r\\n        return block.timestamp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/insured-bridge/interfaces/BridgeAdminInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @notice Helper view methods designed to be called by BridgePool contracts.\\r\\n */\\r\\ninterface BridgeAdminInterface {\\r\\n    event SetDepositContracts(\\r\\n        uint256 indexed chainId,\\r\\n        address indexed l2DepositContract,\\r\\n        address indexed l2MessengerContract\\r\\n    );\\r\\n    event SetCrossDomainAdmin(uint256 indexed chainId, address indexed newAdmin);\\r\\n    event SetRelayIdentifier(bytes32 indexed identifier);\\r\\n    event SetOptimisticOracleLiveness(uint32 indexed liveness);\\r\\n    event SetProposerBondPct(uint64 indexed proposerBondPct);\\r\\n    event WhitelistToken(uint256 chainId, address indexed l1Token, address indexed l2Token, address indexed bridgePool);\\r\\n    event SetMinimumBridgingDelay(uint256 indexed chainId, uint64 newMinimumBridgingDelay);\\r\\n    event DepositsEnabled(uint256 indexed chainId, address indexed l2Token, bool depositsEnabled);\\r\\n    event BridgePoolsAdminTransferred(address[] bridgePools, address indexed newAdmin);\\r\\n    event SetLpFeeRate(address indexed bridgePool, uint64 newLpFeeRatePerSecond);\\r\\n\\r\\n    function finder() external view returns (address);\\r\\n\\r\\n    struct DepositUtilityContracts {\\r\\n        address depositContract; // L2 deposit contract where cross-chain relays originate.\\r\\n        address messengerContract; // L1 helper contract that can send a message to the L2 with the mapped network ID.\\r\\n    }\\r\\n\\r\\n    function depositContracts(uint256) external view returns (DepositUtilityContracts memory);\\r\\n\\r\\n    struct L1TokenRelationships {\\r\\n        mapping(uint256 => address) l2Tokens; // L2 Chain Id to l2Token address.\\r\\n        address bridgePool;\\r\\n    }\\r\\n\\r\\n    function whitelistedTokens(address, uint256) external view returns (address l2Token, address bridgePool);\\r\\n\\r\\n    function optimisticOracleLiveness() external view returns (uint32);\\r\\n\\r\\n    function proposerBondPct() external view returns (uint64);\\r\\n\\r\\n    function identifier() external view returns (bytes32);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/insured-bridge/interfaces/BridgePoolInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\ninterface BridgePoolInterface {\\r\\n    function l1Token() external view returns (IERC20);\\r\\n\\r\\n    function changeAdmin(address newAdmin) external;\\r\\n\\r\\n    function setLpFeeRatePerSecond(uint64 _newLpFeeRatePerSecond) external;\\r\\n\\r\\n    function setRelaysEnabled(bool _relaysEnabled) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/SkinnyOptimisticOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../interfaces/OptimisticOracleInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interface for the gas-cost-reduced version of the OptimisticOracle.\\r\\n * @notice Differences from normal OptimisticOracle:\\r\\n * - refundOnDispute: flag is removed, by default there are no refunds on disputes.\\r\\n * - customizing request parameters: In the OptimisticOracle, parameters like `bond` and `customLiveness` can be reset\\r\\n *   after a request is already made via `requestPrice`. In the SkinnyOptimisticOracle, these parameters can only be\\r\\n *   set in `requestPrice`, which has an expanded input set.\\r\\n * - settleAndGetPrice: Replaced by `settle`, which can only be called once per settleable request. The resolved price\\r\\n *   can be fetched via the `Settle` event or the return value of `settle`.\\r\\n * - general changes to interface: Functions that interact with existing requests all require the parameters of the\\r\\n *   request to modify to be passed as input. These parameters must match with the existing request parameters or the\\r\\n *   function will revert. This change reflects the internal refactor to store hashed request parameters instead of the\\r\\n *   full request struct.\\r\\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\\r\\n */\\r\\nabstract contract SkinnyOptimisticOracleInterface {\\r\\n    // Struct representing a price request. Note that this differs from the OptimisticOracleInterface's Request struct\\r\\n    // in that refundOnDispute is removed.\\r\\n    struct Request {\\r\\n        address proposer; // Address of the proposer.\\r\\n        address disputer; // Address of the disputer.\\r\\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\\r\\n        bool settled; // True if the request is settled.\\r\\n        int256 proposedPrice; // Price that the proposer submitted.\\r\\n        int256 resolvedPrice; // Price resolved once the request is settled.\\r\\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\\r\\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\\r\\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\\r\\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\\r\\n        uint256 customLiveness; // Custom liveness value set by the requester.\\r\\n    }\\r\\n\\r\\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\\r\\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\\r\\n    // to accept a price request made with ancillary data length over a certain size.\\r\\n    uint256 public constant ancillaryBytesLimit = 8192;\\r\\n\\r\\n    /**\\r\\n     * @notice Requests a new price.\\r\\n     * @param identifier price identifier being requested.\\r\\n     * @param timestamp timestamp of the price being requested.\\r\\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\\r\\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\\r\\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\\r\\n     *               which could make sense if the contract requests and proposes the value in the same call or\\r\\n     *               provides its own reward system.\\r\\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\\r\\n     * @param customLiveness custom proposal liveness to set for request.\\r\\n     * @return totalBond default bond + final fee that the proposer and disputer will be required to pay.\\r\\n     */\\r\\n    function requestPrice(\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        IERC20 currency,\\r\\n        uint256 reward,\\r\\n        uint256 bond,\\r\\n        uint256 customLiveness\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\\r\\n     * from this proposal. However, any bonds are pulled from the caller.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters whose hash must match the request that the caller wants to\\r\\n     * propose a price for.\\r\\n     * @param proposer address to set as the proposer.\\r\\n     * @param proposedPrice price being proposed.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the proposer once settled if the proposal is correct.\\r\\n     */\\r\\n    function proposePriceFor(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request,\\r\\n        address proposer,\\r\\n        int256 proposedPrice\\r\\n    ) public virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Proposes a price value where caller is the proposer.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters whose hash must match the request that the caller wants to\\r\\n     * propose a price for.\\r\\n     * @param proposedPrice price being proposed.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the proposer once settled if the proposal is correct.\\r\\n     */\\r\\n    function proposePrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request,\\r\\n        int256 proposedPrice\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Combines logic of requestPrice and proposePrice while taking advantage of gas savings from not having to\\r\\n     * overwrite Request params that a normal requestPrice() => proposePrice() flow would entail. Note: The proposer\\r\\n     * will receive any rewards that come from this proposal. However, any bonds are pulled from the caller.\\r\\n     * @dev The caller is the requester, but the proposer can be customized.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\\r\\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\\r\\n     *               which could make sense if the contract requests and proposes the value in the same call or\\r\\n     *               provides its own reward system.\\r\\n     * @param bond custom proposal bond to set for request. If set to 0, defaults to the final fee.\\r\\n     * @param customLiveness custom proposal liveness to set for request.\\r\\n     * @param proposer address to set as the proposer.\\r\\n     * @param proposedPrice price being proposed.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the proposer once settled if the proposal is correct.\\r\\n     */\\r\\n    function requestAndProposePriceFor(\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        IERC20 currency,\\r\\n        uint256 reward,\\r\\n        uint256 bond,\\r\\n        uint256 customLiveness,\\r\\n        address proposer,\\r\\n        int256 proposedPrice\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\\r\\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters whose hash must match the request that the caller wants to\\r\\n     * dispute.\\r\\n     * @param disputer address to set as the disputer.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\\r\\n     */\\r\\n    function disputePriceFor(\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request,\\r\\n        address disputer,\\r\\n        address requester\\r\\n    ) public virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Disputes a price request with an active proposal where caller is the disputer.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters whose hash must match the request that the caller wants to\\r\\n     * dispute.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\\r\\n     */\\r\\n    function disputePrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters whose hash must match the request that the caller wants to\\r\\n     * settle.\\r\\n     * @return payout the amount that the \\\"winner\\\" (proposer or disputer) receives on settlement. This amount includes\\r\\n     * the returned bonds as well as additional rewards.\\r\\n     * @return resolvedPrice the price that the request settled to.\\r\\n     */\\r\\n    function settle(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request\\r\\n    ) external virtual returns (uint256 payout, int256 resolvedPrice);\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the current state of a price request. See the State enum for more details.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters.\\r\\n     * @return the State.\\r\\n     */\\r\\n    function getState(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request\\r\\n    ) external virtual returns (OptimisticOracleInterface.State);\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if a given request has resolved, expired or been settled (i.e the optimistic oracle has a price).\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param request price request parameters. The hash of these parameters must match with the request hash that is\\r\\n     * associated with the price request unique ID {requester, identifier, timestamp, ancillaryData}, or this method\\r\\n     * will revert.\\r\\n     * @return boolean indicating true if price exists and false if not.\\r\\n     */\\r\\n    function hasPrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint32 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        Request memory request\\r\\n    ) public virtual returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Generates stamped ancillary data in the format that it would be used in the case of a price dispute.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @return the stamped ancillary bytes.\\r\\n     */\\r\\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\\r\\n        public\\r\\n        pure\\r\\n        virtual\\r\\n        returns (bytes memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/StoreInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"../../common/implementation/FixedPoint.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Interface that allows financial contracts to pay oracle fees for their use of the system.\\r\\n */\\r\\ninterface StoreInterface {\\r\\n    /**\\r\\n     * @notice Pays Oracle fees in ETH to the store.\\r\\n     * @dev To be used by contracts whose margin currency is ETH.\\r\\n     */\\r\\n    function payOracleFees() external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Pays oracle fees in the margin currency, erc20Address, to the store.\\r\\n     * @dev To be used if the margin currency is an ERC20 token rather than ETH.\\r\\n     * @param erc20Address address of the ERC20 token used to pay the fee.\\r\\n     * @param amount number of tokens to transfer. An approval for at least this amount must exist.\\r\\n     */\\r\\n    function payOracleFeesErc20(address erc20Address, FixedPoint.Unsigned calldata amount) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the regular oracle fees that a contract should pay for a period.\\r\\n     * @param startTime defines the beginning time from which the fee is paid.\\r\\n     * @param endTime end time until which the fee is paid.\\r\\n     * @param pfc \\\"profit from corruption\\\", or the maximum amount of margin currency that a\\r\\n     * token sponsor could extract from the contract through corrupting the price feed in their favor.\\r\\n     * @return regularFee amount owed for the duration from start to end time for the given pfc.\\r\\n     * @return latePenalty for paying the fee after the deadline.\\r\\n     */\\r\\n    function computeRegularFee(\\r\\n        uint256 startTime,\\r\\n        uint256 endTime,\\r\\n        FixedPoint.Unsigned calldata pfc\\r\\n    ) external view returns (FixedPoint.Unsigned memory regularFee, FixedPoint.Unsigned memory latePenalty);\\r\\n\\r\\n    /**\\r\\n     * @notice Computes the final oracle fees that a contract should pay at settlement.\\r\\n     * @param currency token used to pay the final fee.\\r\\n     * @return finalFee amount due.\\r\\n     */\\r\\n    function computeFinalFee(address currency) external view returns (FixedPoint.Unsigned memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/FinderInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Provides addresses of the live contracts implementing certain interfaces.\\r\\n * @dev Examples are the Oracle or Store interfaces.\\r\\n */\\r\\ninterface FinderInterface {\\r\\n    /**\\r\\n     * @notice Updates the address of the contract that implements `interfaceName`.\\r\\n     * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\\r\\n     * @param implementationAddress address of the deployed contract that implements the interface.\\r\\n     */\\r\\n    function changeImplementationAddress(bytes32 interfaceName, address implementationAddress) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the address of the contract that implements the given `interfaceName`.\\r\\n     * @param interfaceName queried interface.\\r\\n     * @return implementationAddress address of the deployed contract that implements the interface.\\r\\n     */\\r\\n    function getImplementationAddress(bytes32 interfaceName) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/implementation/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Stores common interface names used throughout the DVM by registration in the Finder.\\r\\n */\\r\\nlibrary OracleInterfaces {\\r\\n    bytes32 public constant Oracle = \\\"Oracle\\\";\\r\\n    bytes32 public constant IdentifierWhitelist = \\\"IdentifierWhitelist\\\";\\r\\n    bytes32 public constant Store = \\\"Store\\\";\\r\\n    bytes32 public constant FinancialContractsAdmin = \\\"FinancialContractsAdmin\\\";\\r\\n    bytes32 public constant Registry = \\\"Registry\\\";\\r\\n    bytes32 public constant CollateralWhitelist = \\\"CollateralWhitelist\\\";\\r\\n    bytes32 public constant OptimisticOracle = \\\"OptimisticOracle\\\";\\r\\n    bytes32 public constant Bridge = \\\"Bridge\\\";\\r\\n    bytes32 public constant GenericHandler = \\\"GenericHandler\\\";\\r\\n    bytes32 public constant SkinnyOptimisticOracle = \\\"SkinnyOptimisticOracle\\\";\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Commonly re-used values for contracts associated with the OptimisticOracle.\\r\\n */\\r\\nlibrary OptimisticOracleConstraints {\\r\\n    // Any price request submitted to the OptimisticOracle must contain ancillary data no larger than this value.\\r\\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` constant value otherwise it is possible\\r\\n    // that a price can be requested to the OptimisticOracle successfully, but cannot be resolved by the DVM which\\r\\n    // refuses to accept a price request made with ancillary data length over a certain size.\\r\\n    uint256 public constant ancillaryBytesLimit = 8192;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/implementation/AncillaryData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Library for encoding and decoding ancillary data for DVM price requests.\\r\\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\\r\\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\\r\\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\\r\\n * smart contracts. More details on UMA's ancillary data guidelines below:\\r\\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\\r\\n */\\r\\nlibrary AncillaryData {\\r\\n    // This converts the bottom half of a bytes32 input to hex in a highly gas-optimized way.\\r\\n    // Source: the brilliant implementation at https://gitter.im/ethereum/solidity?at=5840d23416207f7b0ed08c9b.\\r\\n    function toUtf8Bytes32Bottom(bytes32 bytesIn) private pure returns (bytes32) {\\r\\n        unchecked {\\r\\n            uint256 x = uint256(bytesIn);\\r\\n\\r\\n            // Nibble interleave\\r\\n            x = x & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\r\\n            x = (x | (x * 2**64)) & 0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\r\\n            x = (x | (x * 2**32)) & 0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\r\\n            x = (x | (x * 2**16)) & 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\r\\n            x = (x | (x * 2**8)) & 0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\r\\n            x = (x | (x * 2**4)) & 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\r\\n\\r\\n            // Hex encode\\r\\n            uint256 h = (x & 0x0808080808080808080808080808080808080808080808080808080808080808) / 8;\\r\\n            uint256 i = (x & 0x0404040404040404040404040404040404040404040404040404040404040404) / 4;\\r\\n            uint256 j = (x & 0x0202020202020202020202020202020202020202020202020202020202020202) / 2;\\r\\n            x = x + (h & (i | j)) * 0x27 + 0x3030303030303030303030303030303030303030303030303030303030303030;\\r\\n\\r\\n            // Return the result.\\r\\n            return bytes32(x);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns utf8-encoded bytes32 string that can be read via web3.utils.hexToUtf8.\\r\\n     * @dev Will return bytes32 in all lower case hex characters and without the leading 0x.\\r\\n     * This has minor changes from the toUtf8BytesAddress to control for the size of the input.\\r\\n     * @param bytesIn bytes32 to encode.\\r\\n     * @return utf8 encoded bytes32.\\r\\n     */\\r\\n    function toUtf8Bytes(bytes32 bytesIn) internal pure returns (bytes memory) {\\r\\n        return abi.encodePacked(toUtf8Bytes32Bottom(bytesIn >> 128), toUtf8Bytes32Bottom(bytesIn));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\\r\\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\\r\\n     * @dev Will return address in all lower case characters and without the leading 0x.\\r\\n     * @param x address to encode.\\r\\n     * @return utf8 encoded address bytes.\\r\\n     */\\r\\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\\r\\n        return\\r\\n            abi.encodePacked(toUtf8Bytes32Bottom(bytes32(bytes20(x)) >> 128), bytes8(toUtf8Bytes32Bottom(bytes20(x))));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\\r\\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\\r\\n     */\\r\\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\\r\\n        if (x == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 j = x;\\r\\n        uint256 len;\\r\\n        while (j != 0) {\\r\\n            len++;\\r\\n            j /= 10;\\r\\n        }\\r\\n        bytes memory bstr = new bytes(len);\\r\\n        uint256 k = len;\\r\\n        while (x != 0) {\\r\\n            k = k - 1;\\r\\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\\r\\n            bytes1 b1 = bytes1(temp);\\r\\n            bstr[k] = b1;\\r\\n            x /= 10;\\r\\n        }\\r\\n        return bstr;\\r\\n    }\\r\\n\\r\\n    function appendKeyValueBytes32(\\r\\n        bytes memory currentAncillaryData,\\r\\n        bytes memory key,\\r\\n        bytes32 value\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\r\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8Bytes(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds \\\"key:value\\\" to `currentAncillaryData` where `value` is an address that first needs to be converted\\r\\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\\\"k1:v1\\\"`, then this function will return\\r\\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\\r\\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\\r\\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\\r\\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\\r\\n     * @return Newly appended ancillary data.\\r\\n     */\\r\\n    function appendKeyValueAddress(\\r\\n        bytes memory currentAncillaryData,\\r\\n        bytes memory key,\\r\\n        address value\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\r\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds \\\"key:value\\\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\\r\\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\\\"k1:v1\\\"`, then this function will return\\r\\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\\r\\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\\r\\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\\r\\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\\r\\n     * @return Newly appended ancillary data.\\r\\n     */\\r\\n    function appendKeyValueUint(\\r\\n        bytes memory currentAncillaryData,\\r\\n        bytes memory key,\\r\\n        uint256 value\\r\\n    ) internal pure returns (bytes memory) {\\r\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\r\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Helper method that returns the left hand side of a \\\"key:value\\\" pair plus the colon \\\":\\\" and a leading\\r\\n     * comma \\\",\\\" if the `currentAncillaryData` is not empty. The return value is intended to be prepended as a prefix to\\r\\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\\r\\n     */\\r\\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\\r\\n        if (currentAncillaryData.length > 0) {\\r\\n            return abi.encodePacked(\\\",\\\", key, \\\":\\\");\\r\\n        } else {\\r\\n            return abi.encodePacked(key, \\\":\\\");\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/implementation/Testable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Timer.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Base class that provides time overrides, but only if being run in test mode.\\r\\n */\\r\\nabstract contract Testable {\\r\\n    // If the contract is being run in production, then `timerAddress` will be the 0x0 address.\\r\\n    // Note: this variable should be set on construction and never modified.\\r\\n    address public timerAddress;\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs the Testable contract. Called by child contracts.\\r\\n     * @param _timerAddress Contract that stores the current time in a testing environment.\\r\\n     * Must be set to 0x0 for production environments that use live time.\\r\\n     */\\r\\n    constructor(address _timerAddress) {\\r\\n        timerAddress = _timerAddress;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if not running in test mode.\\r\\n     */\\r\\n    modifier onlyIfTest {\\r\\n        require(timerAddress != address(0x0));\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set current Testable time to.\\r\\n     */\\r\\n    function setCurrentTime(uint256 time) external onlyIfTest {\\r\\n        Timer(timerAddress).setCurrentTime(time);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current time. Will return the last time set in `setCurrentTime` if running in test mode.\\r\\n     * Otherwise, it will return the block timestamp.\\r\\n     * @return uint for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view virtual returns (uint256) {\\r\\n        if (timerAddress != address(0x0)) {\\r\\n            return Timer(timerAddress).getCurrentTime();\\r\\n        } else {\\r\\n            return block.timestamp; // solhint-disable-line not-rely-on-time\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Library for fixed point arithmetic on uints\\r\\n */\\r\\nlibrary FixedPoint {\\r\\n    using SafeMath for uint256;\\r\\n    using SignedSafeMath for int256;\\r\\n\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For unsigned values:\\r\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\r\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\r\\n    struct Unsigned {\\r\\n        uint256 rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a uint to convert into a FixedPoint.\\r\\n     * @return the converted FixedPoint.\\r\\n     */\\r\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return add(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return sub(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\r\\n     * @param a a uint256.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return sub(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as a uint256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\r\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a uint256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\r\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(mulFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(mulFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.\\r\\n     * @param b a FixedPoint.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Since b is an uint, there is no risk of truncation and we can just mul it normally\\r\\n        return Unsigned(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as a uint256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        return Unsigned(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a uint256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        return div(fromUnscaledUint(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\r\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\r\\n        uint256 divFloor = aScaled.div(b.rawValue);\\r\\n        uint256 mod = aScaled.mod(b.rawValue);\\r\\n        if (mod != 0) {\\r\\n            return Unsigned(divFloor.add(1));\\r\\n        } else {\\r\\n            return Unsigned(divFloor);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divCeil(a, fromUnscaledUint(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a uint256 denominator.\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\r\\n        output = fromUnscaledUint(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\r\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\r\\n    // For signed values:\\r\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\r\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\r\\n\\r\\n    struct Signed {\\r\\n        int256 rawValue;\\r\\n    }\\r\\n\\r\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\r\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\r\\n        return Unsigned(uint256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\r\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\r\\n        return Signed(int256(a.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\r\\n     * @param a int to convert into a FixedPoint.Signed.\\r\\n     * @return the converted FixedPoint.Signed.\\r\\n     */\\r\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\r\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a int256.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if equal, or False.\\r\\n     */\\r\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue == b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a > b`, or False.\\r\\n     */\\r\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is greater than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a >= b`, or False.\\r\\n     */\\r\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a < b`, or False.\\r\\n     */\\r\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\r\\n        return a.rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\r\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Whether `a` is less than or equal to `b`.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return True if `a <= b`, or False.\\r\\n     */\\r\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\r\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The minimum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the minimum of `a` and `b`.\\r\\n     */\\r\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue < b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The maximum of `a` and `b`.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the maximum of `a` and `b`.\\r\\n     */\\r\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return a.rawValue > b.rawValue ? a : b;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.add(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the sum of `a` and `b`.\\r\\n     */\\r\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return add(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.sub(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return sub(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\r\\n     * @param a an int256.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the difference of `a` and `b`.\\r\\n     */\\r\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return sub(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\r\\n        // stored internally as an int256 ~10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\r\\n        // would round to 3, but this computation produces the result 2.\\r\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\r\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\r\\n     * @dev This will \\\"floor\\\" the product.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b an int256.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\r\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(mulTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(mulTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a FixedPoint.Signed.\\r\\n     * @return the product of `a` and `b`.\\r\\n     */\\r\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\r\\n        return Signed(a.rawValue.mul(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        // There are two caveats with this computation:\\r\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\r\\n        // 10^41 is stored internally as an int256 10^59.\\r\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\r\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\r\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        return Signed(a.rawValue.div(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\r\\n     * @dev This will \\\"floor\\\" the quotient.\\r\\n     * @param a an int256 numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        return div(fromUnscaledInt(a), b);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b a FixedPoint denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\r\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\r\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\r\\n        // Manual mod because SignedSafeMath doesn't support it.\\r\\n        int256 mod = aScaled % b.rawValue;\\r\\n        if (mod != 0) {\\r\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\r\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\r\\n            return Signed(divTowardsZero.add(valueToAdd));\\r\\n        } else {\\r\\n            return Signed(divTowardsZero);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\r\\n     * @param a a FixedPoint numerator.\\r\\n     * @param b an int256 denominator.\\r\\n     * @return the quotient of `a` divided by `b`.\\r\\n     */\\r\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\r\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\r\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\r\\n        // This creates the possibility of overflow if b is very large.\\r\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\r\\n     * @dev This will \\\"floor\\\" the result.\\r\\n     * @param a a FixedPoint.Signed.\\r\\n     * @param b a uint256 (negative exponents are not allowed).\\r\\n     * @return output is `a` to the power of `b`.\\r\\n     */\\r\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\r\\n        output = fromUnscaledInt(1);\\r\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\r\\n            output = mul(output, a);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/implementation/Lockable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\r\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\r\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\r\\n */\\r\\ncontract Lockable {\\r\\n    bool private _notEntered;\\r\\n\\r\\n    constructor() {\\r\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\r\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\r\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\r\\n        // refund coming into effect.\\r\\n        _notEntered = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     * Calling a `nonReentrant` function from another `nonReentrant` function is not supported. It is possible to\\r\\n     * prevent this from happening by making the `nonReentrant` function external, and making it call a `private`\\r\\n     * function that does the actual state modification.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        _preEntranceCheck();\\r\\n        _preEntranceSet();\\r\\n        _;\\r\\n        _postEntranceReset();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a `nonReentrant()` state-changing method.\\r\\n     */\\r\\n    modifier nonReentrantView() {\\r\\n        _preEntranceCheck();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // Internal methods are used to avoid copying the require statement's bytecode to every `nonReentrant()` method.\\r\\n    // On entry into a function, `_preEntranceCheck()` should always be called to check if the function is being\\r\\n    // re-entered. Then, if the function modifies state, it should call `_postEntranceSet()`, perform its logic, and\\r\\n    // then call `_postEntranceReset()`.\\r\\n    // View-only methods can simply call `_preEntranceCheck()` to make sure that it is not being re-entered.\\r\\n    function _preEntranceCheck() internal view {\\r\\n        // On the first call to nonReentrant, _notEntered will be true\\r\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\r\\n    }\\r\\n\\r\\n    function _preEntranceSet() internal {\\r\\n        // Any calls to nonReentrant after this point will fail\\r\\n        _notEntered = false;\\r\\n    }\\r\\n\\r\\n    function _postEntranceReset() internal {\\r\\n        // By storing the original value once again, a refund is triggered (see\\r\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\r\\n        _notEntered = true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/common/implementation/MultiCaller.sol\": {\r\n      \"content\": \"// This contract is taken from Uniswaps's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\\r\\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\\r\\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/// @title MultiCaller\\r\\n/// @notice Enables calling multiple methods in a single call to the contract\\r\\ncontract MultiCaller {\\r\\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results) {\\r\\n        require(msg.value == 0, \\\"Only multicall with 0 value\\\");\\r\\n        results = new bytes[](data.length);\\r\\n        for (uint256 i = 0; i < data.length; i++) {\\r\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\r\\n\\r\\n            if (!success) {\\r\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\r\\n                if (result.length < 68) revert();\\r\\n                assembly {\\r\\n                    result := add(result, 0x04)\\r\\n                }\\r\\n                revert(abi.decode(result, (string)));\\r\\n            }\\r\\n\\r\\n            results[i] = result;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/OptimisticOracleInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Financial contract facing Oracle interface.\\r\\n * @dev Interface used by financial contracts to interact with the Oracle. Voters will use a different interface.\\r\\n */\\r\\nabstract contract OptimisticOracleInterface {\\r\\n    // Struct representing the state of a price request.\\r\\n    enum State {\\r\\n        Invalid, // Never requested.\\r\\n        Requested, // Requested, no other actions taken.\\r\\n        Proposed, // Proposed, but not expired or disputed yet.\\r\\n        Expired, // Proposed, not disputed, past liveness.\\r\\n        Disputed, // Disputed, but no DVM price returned yet.\\r\\n        Resolved, // Disputed and DVM price is available.\\r\\n        Settled // Final price has been set in the contract (can get here from Expired or Resolved).\\r\\n    }\\r\\n\\r\\n    // Struct representing a price request.\\r\\n    struct Request {\\r\\n        address proposer; // Address of the proposer.\\r\\n        address disputer; // Address of the disputer.\\r\\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\\r\\n        bool settled; // True if the request is settled.\\r\\n        bool refundOnDispute; // True if the requester should be refunded their reward on dispute.\\r\\n        int256 proposedPrice; // Price that the proposer submitted.\\r\\n        int256 resolvedPrice; // Price resolved once the request is settled.\\r\\n        uint256 expirationTime; // Time at which the request auto-settles without a dispute.\\r\\n        uint256 reward; // Amount of the currency to pay to the proposer on settlement.\\r\\n        uint256 finalFee; // Final fee to pay to the Store upon request to the DVM.\\r\\n        uint256 bond; // Bond that the proposer and disputer must pay on top of the final fee.\\r\\n        uint256 customLiveness; // Custom liveness value set by the requester.\\r\\n    }\\r\\n\\r\\n    // This value must be <= the Voting contract's `ancillaryBytesLimit` value otherwise it is possible\\r\\n    // that a price can be requested to this contract successfully, but cannot be disputed because the DVM refuses\\r\\n    // to accept a price request made with ancillary data length over a certain size.\\r\\n    uint256 public constant ancillaryBytesLimit = 8192;\\r\\n\\r\\n    /**\\r\\n     * @notice Requests a new price.\\r\\n     * @param identifier price identifier being requested.\\r\\n     * @param timestamp timestamp of the price being requested.\\r\\n     * @param ancillaryData ancillary data representing additional args being passed with the price request.\\r\\n     * @param currency ERC20 token used for payment of rewards and fees. Must be approved for use with the DVM.\\r\\n     * @param reward reward offered to a successful proposer. Will be pulled from the caller. Note: this can be 0,\\r\\n     *               which could make sense if the contract requests and proposes the value in the same call or\\r\\n     *               provides its own reward system.\\r\\n     * @return totalBond default bond (final fee) + final fee that the proposer and disputer will be required to pay.\\r\\n     * This can be changed with a subsequent call to setBond().\\r\\n     */\\r\\n    function requestPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        IERC20 currency,\\r\\n        uint256 reward\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Set the proposal bond associated with a price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param bond custom bond amount to set.\\r\\n     * @return totalBond new bond + final fee that the proposer and disputer will be required to pay. This can be\\r\\n     * changed again with a subsequent call to setBond().\\r\\n     */\\r\\n    function setBond(\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        uint256 bond\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the request to refund the reward if the proposal is disputed. This can help to \\\"hedge\\\" the caller\\r\\n     * in the event of a dispute-caused delay. Note: in the event of a dispute, the winner still receives the other's\\r\\n     * bond, so there is still profit to be made even if the reward is refunded.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     */\\r\\n    function setRefundOnDispute(\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a custom liveness value for the request. Liveness is the amount of time a proposal must wait before\\r\\n     * being auto-resolved.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param customLiveness new custom liveness.\\r\\n     */\\r\\n    function setCustomLiveness(\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        uint256 customLiveness\\r\\n    ) external virtual;\\r\\n\\r\\n    /**\\r\\n     * @notice Proposes a price value on another address' behalf. Note: this address will receive any rewards that come\\r\\n     * from this proposal. However, any bonds are pulled from the caller.\\r\\n     * @param proposer address to set as the proposer.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param proposedPrice price being proposed.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the proposer once settled if the proposal is correct.\\r\\n     */\\r\\n    function proposePriceFor(\\r\\n        address proposer,\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        int256 proposedPrice\\r\\n    ) public virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Proposes a price value for an existing price request.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @param proposedPrice price being proposed.\\r\\n     * @return totalBond the amount that's pulled from the proposer's wallet as a bond. The bond will be returned to\\r\\n     * the proposer once settled if the proposal is correct.\\r\\n     */\\r\\n    function proposePrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData,\\r\\n        int256 proposedPrice\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Disputes a price request with an active proposal on another address' behalf. Note: this address will\\r\\n     * receive any rewards that come from this dispute. However, any bonds are pulled from the caller.\\r\\n     * @param disputer address to set as the disputer.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return totalBond the amount that's pulled from the caller's wallet as a bond. The bond will be returned to\\r\\n     * the disputer once settled if the dispute was value (the proposal was incorrect).\\r\\n     */\\r\\n    function disputePriceFor(\\r\\n        address disputer,\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) public virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Disputes a price value for an existing price request with an active proposal.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return totalBond the amount that's pulled from the disputer's wallet as a bond. The bond will be returned to\\r\\n     * the disputer once settled if the dispute was valid (the proposal was incorrect).\\r\\n     */\\r\\n    function disputePrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) external virtual returns (uint256 totalBond);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves a price that was previously requested by a caller. Reverts if the request is not settled\\r\\n     * or settleable. Note: this method is not view so that this call may actually settle the price request if it\\r\\n     * hasn't been settled.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return resolved price.\\r\\n     */\\r\\n    function settleAndGetPrice(\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) external virtual returns (int256);\\r\\n\\r\\n    /**\\r\\n     * @notice Attempts to settle an outstanding price request. Will revert if it isn't settleable.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return payout the amount that the \\\"winner\\\" (proposer or disputer) receives on settlement. This amount includes\\r\\n     * the returned bonds as well as additional rewards.\\r\\n     */\\r\\n    function settle(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) external virtual returns (uint256 payout);\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the current data structure containing all information about a price request.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return the Request data structure.\\r\\n     */\\r\\n    function getRequest(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view virtual returns (Request memory);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the state of a price request.\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return the State enum value.\\r\\n     */\\r\\n    function getState(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view virtual returns (State);\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if a given request has resolved or been settled (i.e the optimistic oracle has a price).\\r\\n     * @param requester sender of the initial price request.\\r\\n     * @param identifier price identifier to identify the existing request.\\r\\n     * @param timestamp timestamp to identify the existing request.\\r\\n     * @param ancillaryData ancillary data of the price being requested.\\r\\n     * @return true if price has resolved or settled, false otherwise.\\r\\n     */\\r\\n    function hasPrice(\\r\\n        address requester,\\r\\n        bytes32 identifier,\\r\\n        uint256 timestamp,\\r\\n        bytes memory ancillaryData\\r\\n    ) public view virtual returns (bool);\\r\\n\\r\\n    function stampAncillaryData(bytes memory ancillaryData, address requester)\\r\\n        public\\r\\n        view\\r\\n        virtual\\r\\n        returns (bytes memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/implementation/Timer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @title Universal store of current contract time for testing environments.\\r\\n */\\r\\ncontract Timer {\\r\\n    uint256 private currentTime;\\r\\n\\r\\n    constructor() {\\r\\n        currentTime = block.timestamp; // solhint-disable-line not-rely-on-time\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the current time.\\r\\n     * @dev Will revert if not running in test mode.\\r\\n     * @param time timestamp to set `currentTime` to.\\r\\n     */\\r\\n    function setCurrentTime(uint256 time) external {\\r\\n        currentTime = time;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets the currentTime variable set in the Timer.\\r\\n     * @return uint256 for the current Testable timestamp.\\r\\n     */\\r\\n    function getCurrentTime() public view returns (uint256) {\\r\\n        return currentTime;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_lpTokenName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_lpTokenSymbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_bridgeAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_l1Token\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_lpFeeRatePerSecond\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"_isWethPool\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_timer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"BridgePoolAdminTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relay\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"relayAncillaryDataHash\",\"type\":\"bytes32\"}],\"name\":\"DepositRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"}],\"name\":\"LiquidityAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokensBurnt\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"newLpFeeRatePerSecond\",\"type\":\"uint64\"}],\"name\":\"LpFeeRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"}],\"name\":\"RelayCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"relayHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"disputer\",\"type\":\"address\"}],\"name\":\"RelayDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relay\",\"type\":\"tuple\"}],\"name\":\"RelaySettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"depositHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"instantRelayer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relay\",\"type\":\"tuple\"}],\"name\":\"RelaySpedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newRelaysEnabled\",\"type\":\"bool\"}],\"name\":\"RelaysEnabledSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"l1TokenAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeAdmin\",\"outputs\":[{\"internalType\":\"contract BridgeAdminInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"disputeRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRateCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"relayedAmount\",\"type\":\"uint256\"}],\"name\":\"getLiquidityUtilization\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"utilizationCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilizationPostRelay\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"getRelayAncillaryData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"identifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"instantRelays\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWethPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"l1Token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLpFeeUpdate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityUtilizationCurrent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"relayedAmount\",\"type\":\"uint256\"}],\"name\":\"liquidityUtilizationPostRelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpFeeRatePerSecond\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfRelays\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticOracle\",\"outputs\":[{\"internalType\":\"contract SkinnyOptimisticOracleInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"optimisticOracleLiveness\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposerBondPct\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"}],\"name\":\"relayAndSpeedUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"}],\"name\":\"relayDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"relays\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"relaysEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendEth\",\"type\":\"bool\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"setCurrentTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_newLpFeeRatePerSecond\",\"type\":\"uint64\"}],\"name\":\"setLpFeeRatePerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_relaysEnabled\",\"type\":\"bool\"}],\"name\":\"setRelaysEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"settleRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"depositId\",\"type\":\"uint64\"},{\"internalType\":\"address payable\",\"name\":\"l1Recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"l2Sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"slowRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"instantRelayFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"}],\"internalType\":\"struct BridgePool.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"enum BridgePool.RelayState\",\"name\":\"relayState\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"slowRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"relayId\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"priceRequestTime\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"proposerBond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finalFee\",\"type\":\"uint256\"}],\"internalType\":\"struct BridgePool.RelayData\",\"name\":\"relayData\",\"type\":\"tuple\"}],\"name\":\"speedUpRelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"store\",\"outputs\":[{\"internalType\":\"contract StoreInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncUmaEcosystemParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syncWithBridgeAdminParams\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"undistributedLpFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilizedReserves\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BridgePoolProd", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000030b44c676a05f1264d1de9cc31db5f2a945186b600000000000000000000000042bbfa2e77757c645eeaad1655e0911a7553efbc0000000000000000000000000000000000000000000000000000015d3ef7980000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e4163726f737320424f4241204c500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009412d424f42412d4c500000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}