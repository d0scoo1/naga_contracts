{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": false\r\n      },\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/FashionHatPunksData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.8.0 <0.9.0;\\npragma abicoder v2;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./StringUtilsLib.sol\\\";\\n\\ninterface PunkDataInterface {\\n    function punkImage(uint16 index) external view returns (bytes memory);\\n    function punkAttributes(uint16 index) external view returns (string memory);\\n}\\n\\ncontract FashionHatPunksData is Ownable {\\n    using StringUtils for string;\\n    using Strings for uint16;\\n    using Strings for uint8;\\n    using Strings for uint256;\\n    \\n    PunkDataInterface immutable punkDataContract;\\n    \\n    enum HatType { BASEBALL, BUCKET, COWBOY, VISOR }\\n    enum HatSize { REGULAR, SMALL }\\n    enum HatColor { BLACK, GREY, RED, WHITE, TAN, BROWN }\\n    enum HatPosition { REGULAR, FLIPPED }\\n    \\n    enum PunkAttributeType {SEX, HAIR, EYES, BEARD, EARS, LIPS, MOUTH,\\n                                FACE, EMOTION, NECK, NOSE, CHEEKS, TEETH}\\n    \\n    enum PunkAttributeValue {NONE, ALIEN, APE, BANDANA, BEANIE, BIG_BEARD, BIG_SHADES, BLACK_LIPSTICK, BLONDE_BOB, BLONDE_SHORT, BLUE_EYE_SHADOW, BUCK_TEETH, CAP, CAP_FORWARD, CHINSTRAP, CHOKER, CIGARETTE, CLASSIC_SHADES, CLOWN_EYES_BLUE, CLOWN_EYES_GREEN, CLOWN_HAIR_GREEN, CLOWN_NOSE, COWBOY_HAT, CRAZY_HAIR, DARK_HAIR, DO_RAG, EARRING, EYE_MASK, EYE_PATCH, FEDORA, FEMALE, FRONT_BEARD, FRONT_BEARD_DARK, FROWN, FRUMPY_HAIR, GOAT, GOLD_CHAIN, GREEN_EYE_SHADOW, HALF_SHAVED, HANDLEBARS, HEADBAND, HOODIE, HORNED_RIM_GLASSES, HOT_LIPSTICK, KNITTED_CAP, LUXURIOUS_BEARD, MALE, MEDICAL_MASK, MESSY_HAIR, MOHAWK, MOHAWK_DARK, MOHAWK_THIN, MOLE, MUSTACHE, MUTTONCHOPS, NERD_GLASSES, NORMAL_BEARD, NORMAL_BEARD_BLACK, ORANGE_SIDE, PEAK_SPIKE, PIGTAILS, PILOT_HELMET, PINK_WITH_HAT, PIPE, POLICE_CAP, PURPLE_EYE_SHADOW, PURPLE_HAIR, PURPLE_LIPSTICK, RED_MOHAWK, REGULAR_SHADES, ROSY_CHEEKS, SHADOW_BEARD, SHAVED_HEAD, SILVER_CHAIN, SMALL_SHADES, SMILE, SPOTS, STRAIGHT_HAIR, STRAIGHT_HAIR_BLONDE, STRAIGHT_HAIR_DARK, STRINGY_HAIR, TASSLE_HAT, THREE_D_GLASSES, TIARA, TOP_HAT, VAMPIRE_HAIR, VAPE, VR, WELDING_GOGGLES, WILD_BLONDE, WILD_HAIR, WILD_WHITE_HAIR, ZOMBIE}\\n    \\n    constructor(address punkDataContractAddress) {\\n        punkDataContract = PunkDataInterface(punkDataContractAddress);\\n    }\\n    \\n    function punkHatType(Punk memory punk) public view returns (HatType result) {\\n        uint[] memory choiceWeights = new uint[](4);\\n        \\n        for (uint i; i < 4; i++) {\\n            choiceWeights[i] = 25e8;\\n        }\\n        \\n        if (!visorLooksGood[punk.hair][punk.sex]) { \\n            choiceWeights[uint(HatType.VISOR)] = 5e8;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.COWBOY_HAT) {\\n            return HatType.COWBOY;\\n        }\\n        if (punk.hair == PunkAttributeValue.CAP ||\\n            punk.hair == PunkAttributeValue.BEANIE ||\\n            (punk.sex != PunkAttributeValue.FEMALE && originalEyePixelGap(punk) == 2)\\n        ) {\\n            return HatType.BASEBALL;\\n        }\\n        \\n        if ((punk.sex == PunkAttributeValue.FEMALE || originalEyePixelGap(punk) == 1) &&\\n            punk.mouth == PunkAttributeValue.CIGARETTE &&\\n            (canWearHat(punk, HatType.BUCKET) ||\\n            (canWearHat(punk, HatType.BASEBALL) && canFlipHat(punk)))\\n        ) {\\n            choiceWeights[uint(HatType.COWBOY)] /= 5;\\n            choiceWeights[uint(HatType.VISOR)] /= 5;\\n            \\n            if (!canFlipHat(punk)) {\\n                choiceWeights[uint(HatType.BASEBALL)] /= 5;\\n            }\\n        }\\n        \\n        if (punk.seed < 55 && canWearHat(punk, HatType.BASEBALL) &&\\n            punk.sex != PunkAttributeValue.FEMALE &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n            originalEyePixelGap(punk) != 1\\n        ) {\\n            return HatType.BASEBALL;\\n        }\\n        \\n        if (punk.seed < 75 &&\\n           punk.sex != PunkAttributeValue.FEMALE &&\\n           (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n           (canWearHat(punk, HatType.COWBOY) || canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.BASEBALL)] = 0;\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (!visibleHairAttribute(punk) && \\n            (canWearHat(punk, HatType.COWBOY) ||\\n             canWearHat(punk, HatType.BASEBALL) ||\\n             canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE &&\\n            punk.hair == PunkAttributeValue.CLOWN_HAIR_GREEN &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES)\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        if (punk.eyes == PunkAttributeValue.WELDING_GOGGLES && \\n            (canWearHat(punk, HatType.COWBOY) ||\\n             canWearHat(punk, HatType.BASEBALL) ||\\n             canWearHat(punk, HatType.BUCKET))\\n        ) {\\n            choiceWeights[uint(HatType.VISOR)] = 0;\\n        }\\n        \\n        for (uint i; i < 4; i++) {\\n            if (!canWearHat(punk, HatType(i))) {\\n                choiceWeights[i] = 0;\\n            }\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_type\\\");\\n        return HatType(choiceIndex);\\n    }\\n    \\n    function punkHatColor(Punk memory punk) public view returns (HatColor result) {\\n        HatType hatType = punkHatType(punk);\\n        \\n        uint[] memory choiceWeights = new uint[](6);\\n        \\n        if (hatType == HatType.BASEBALL) {\\n            choiceWeights[uint(HatColor.BLACK)] = 22.5e8;\\n            choiceWeights[uint(HatColor.GREY)] = 25e8;\\n            choiceWeights[uint(HatColor.RED)] = 20e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 25e8;\\n            choiceWeights[uint(HatColor.TAN)] = 20e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        } else if (hatType == HatType.BUCKET) {\\n            choiceWeights[uint(HatColor.BLACK)] = 50e8;\\n            choiceWeights[uint(HatColor.GREY)] = 0;\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n            choiceWeights[uint(HatColor.TAN)] = 50e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 50e8;\\n        } else if (hatType == HatType.COWBOY) {\\n            choiceWeights[uint(HatColor.BLACK)] = 60e8;\\n            choiceWeights[uint(HatColor.GREY)] = 20e8;\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n            choiceWeights[uint(HatColor.TAN)] = 40e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        } else if (hatType == HatType.VISOR) {\\n            choiceWeights[uint(HatColor.BLACK)] = 22.5e8;\\n            choiceWeights[uint(HatColor.GREY)] = 25e8;\\n            choiceWeights[uint(HatColor.RED)] = 20e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 25e8;\\n            choiceWeights[uint(HatColor.TAN)] = 20e8;\\n            choiceWeights[uint(HatColor.BROWN)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.HOODIE) {\\n            choiceWeights[uint(HatColor.BLACK)] = 0;\\n            choiceWeights[uint(HatColor.GREY)] = 0;\\n            choiceWeights[uint(HatColor.RED)] = 10e8;\\n            choiceWeights[uint(HatColor.WHITE)] = 30e8;\\n            choiceWeights[uint(HatColor.TAN)] = 30e8;\\n        }\\n        \\n        if (punk.eyes == PunkAttributeValue.THREE_D_GLASSES || punk.hair == PunkAttributeValue.WILD_WHITE_HAIR) {\\n            choiceWeights[uint(HatColor.WHITE)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.DARK_HAIR && hatType == HatType.BUCKET) {\\n            choiceWeights[uint(HatColor.BLACK)] /= 10;\\n        }\\n        \\n        if (hatType == HatType.VISOR) {\\n            if (punk.hair == PunkAttributeValue.WILD_HAIR || punk.hair == PunkAttributeValue.HALF_SHAVED ||\\n               ((punk.hair == PunkAttributeValue.HEADBAND && punk.sex == PunkAttributeValue.FEMALE))) {\\n                choiceWeights[uint(HatColor.BLACK)] = 0;\\n            }\\n            \\n            if (punk.hair == PunkAttributeValue.WILD_BLONDE) {\\n                choiceWeights[uint(HatColor.TAN)] = 0;\\n            }\\n        }\\n        \\n        if (hatType == HatType.COWBOY || hatType == HatType.BUCKET) {\\n            if (\\n                eyesWithBlackTop(punk) ||\\n                punk.hair == PunkAttributeValue.FRUMPY_HAIR ||\\n                punk.hair == PunkAttributeValue.WILD_HAIR ||\\n                punk.hair == PunkAttributeValue.HALF_SHAVED\\n            ) {\\n                choiceWeights[uint(HatColor.BLACK)] = 0;\\n            }\\n        }\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE && (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES)) {\\n            choiceWeights[uint(HatColor.BLACK)] = 0;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.CRAZY_HAIR && (punk.sex == PunkAttributeValue.FEMALE || hatType == HatType.VISOR)) {\\n            choiceWeights[uint(HatColor.RED)] = 0;\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_color\\\");\\n        return HatColor(choiceIndex);\\n    }\\n    \\n    function punkHatPosition(Punk memory punk) public view returns (HatPosition result) {\\n        HatType hatType = punkHatType(punk);\\n        \\n        if (hatType != HatType.BASEBALL) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        uint[] memory choiceWeights = new uint[](2);\\n        \\n        choiceWeights[uint(HatPosition.REGULAR)] = 50e8;\\n        choiceWeights[uint(HatPosition.FLIPPED)] = 50e8;\\n        \\n        if (punk.hair == PunkAttributeValue.HALF_SHAVED) {\\n            return HatPosition.FLIPPED;\\n        }\\n        \\n        if (!canFlipHat(punk)) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        if (\\n            punk.sex != PunkAttributeValue.FEMALE &&\\n            (punk.eyes == PunkAttributeValue.VR || punk.eyes == PunkAttributeValue.BIG_SHADES) &&\\n            hatEyePixelGap(punk) == 1\\n        ) {\\n            return (punk.eyes == PunkAttributeValue.BIG_SHADES ? HatPosition.REGULAR : HatPosition.FLIPPED);\\n        }\\n        \\n        if ((punk.sex == PunkAttributeValue.FEMALE || originalEyePixelGap(punk) == 1) &&\\n            punk.mouth == PunkAttributeValue.CIGARETTE\\n        ) {\\n            choiceWeights[uint(HatPosition.REGULAR)] /= 10;\\n        }\\n        \\n        if (\\n            punk.hair == PunkAttributeValue.HOODIE ||\\n            punk.hair == PunkAttributeValue.BEANIE ||\\n            originalEyePixelGap(punk) == 2\\n        ) {\\n            return HatPosition.REGULAR;\\n        }\\n        \\n        uint8 choiceIndex = weightedChoice(punk, choiceWeights, \\\"hat_position\\\");\\n        return HatPosition(choiceIndex);\\n    }\\n    \\n    function hatEyePixelGap(Punk memory punk) public view returns (uint8 gap) {\\n        HatType currentHat = punkHatType(punk);\\n        \\n        if (\\n            currentHat == HatType.VISOR ||\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.COWBOY\\n        ) {\\n            return 1;\\n        }\\n        \\n        if (punk.hair == PunkAttributeValue.BANDANA) {\\n            if (punk.sex == PunkAttributeValue.FEMALE) {\\n                return 1;\\n            } else {\\n                if (punk.eyes == PunkAttributeValue.BIG_SHADES || punk.eyes == PunkAttributeValue.VR) {\\n                    return 2;\\n                } else {\\n                    return 1;\\n                }\\n            }\\n        }\\n        \\n        uint8 originalGap = originalEyePixelGap(punk);\\n        \\n        if (punk.sex != PunkAttributeValue.FEMALE) {\\n            if (\\n                punk.hair == PunkAttributeValue.CLOWN_HAIR_GREEN ||\\n                punk.hair == PunkAttributeValue.HOODIE\\n            ) {\\n                return 1;\\n            } else {\\n                return (originalGap > 0 ? originalGap : 2);\\n            }\\n        }\\n        \\n        if (\\n            (currentHat == HatType.BASEBALL &&\\n            (punk.hair == PunkAttributeValue.DARK_HAIR || punk.hair == PunkAttributeValue.ORANGE_SIDE)) ||\\n            (punk.hair == PunkAttributeValue.PINK_WITH_HAT || punk.hair == PunkAttributeValue.STRAIGHT_HAIR ||\\n             punk.hair == PunkAttributeValue.STRAIGHT_HAIR_BLONDE || punk.hair == PunkAttributeValue.STRAIGHT_HAIR_DARK)\\n        ) {\\n            return 1;\\n        }\\n        \\n        return (originalGap > 0 ? originalGap : 2);\\n    }\\n    \\n    function punkHatSize(Punk memory punk) public view returns (HatSize result) {\\n        HatType currentHat = punkHatType(punk);\\n\\n        if (punk.sex != PunkAttributeValue.FEMALE) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (currentHat == HatType.BASEBALL && punk.hair == PunkAttributeValue.CRAZY_HAIR) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (currentHat == HatType.BUCKET && punk.hair == PunkAttributeValue.WILD_HAIR) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        if (\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.BASEBALL\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.BLONDE_BOB ||\\n                punk.hair == PunkAttributeValue.BLONDE_SHORT\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            currentHat == HatType.COWBOY ||\\n            currentHat == HatType.BUCKET ||\\n            currentHat == HatType.BASEBALL\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.FRUMPY_HAIR\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            currentHat == HatType.COWBOY ||\\n            currentHat == HatType.BUCKET\\n        ) {\\n            if (\\n                punk.hair == PunkAttributeValue.HALF_SHAVED ||\\n                punk.hair == PunkAttributeValue.WILD_BLONDE\\n            ) {\\n                return HatSize.REGULAR;\\n            }\\n        }\\n        \\n        if (\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR_BLONDE ||\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR ||\\n            punk.hair == PunkAttributeValue.STRAIGHT_HAIR_DARK\\n        ) {\\n            return HatSize.REGULAR;\\n        }\\n        \\n        return HatSize.SMALL;\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public canFlipHatMapping;\\n    \\n    function setcanFlipHatMapping(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            canFlipHatMapping[hair][sex] = true;\\n        }\\n    }\\n    \\n    function canFlipHat(Punk memory punk) public view returns (bool) {\\n        if (!canWearHat(punk, HatType.BASEBALL)) {\\n            return false;\\n        }\\n        \\n        return canFlipHatMapping[punk.hair][punk.sex];\\n    }\\n    \\n    function randomNumber(Punk memory punk, uint lessThanNumb, string memory seedAddition) public pure returns (uint) {\\n        uint16 seed = punk.seed;\\n        uint256 randomNum = uint256(\\n            keccak256(abi.encodePacked(punk.id.toString(), \\\":\\\", seed.toString(), seedAddition))\\n        );\\n        \\n        return uint(randomNum % lessThanNumb);\\n    }\\n    \\n    function weightedChoice(Punk memory punk, uint[] memory choiceWeights, string memory seedAddition) public pure returns (uint8) {\\n        uint sumOfWeights;\\n        uint numChoices = choiceWeights.length;\\n\\n        for (uint i; i < numChoices; i++) {\\n            sumOfWeights += choiceWeights[i];\\n        }\\n        \\n        uint randomNumberInstance = randomNumber(punk, sumOfWeights, seedAddition);\\n        \\n        for (uint8 i; i < numChoices; i++) {\\n            if (randomNumberInstance < choiceWeights[i]) {\\n                return i;\\n            } else {\\n                randomNumberInstance -= choiceWeights[i];\\n            }\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public visorLooksGood;\\n    \\n    function setVisorLooksGood(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            visorLooksGood[hair][sex] = true;\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => bool)) public lacksVisibleHairAttribute;\\n    \\n    function setLacksVisibleHairAttribute(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            lacksVisibleHairAttribute[hair][sex] = true;\\n        }\\n    }\\n    \\n    function visibleHairAttribute(Punk memory punk) public view returns (bool) {\\n        return !lacksVisibleHairAttribute[punk.hair][punk.sex];\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => uint8)) public originalEyePixelGapMapping;\\n    \\n    function setOriginalEyePixelGap(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes, uint8[] memory gaps) external onlyOwner {\\n        for (uint i = 0; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            \\n            originalEyePixelGapMapping[hair][sex] = gaps[i];\\n        }\\n    }\\n    \\n    function originalEyePixelGap(Punk memory punk) public view returns (uint8 gap) {\\n        return originalEyePixelGapMapping[punk.hair][punk.sex];\\n    }\\n    \\n    function eyesWithBlackTop(Punk memory punk) public pure returns (bool) {\\n        if (punk.sex == PunkAttributeValue.FEMALE && punk.eyes == PunkAttributeValue.REGULAR_SHADES) {\\n            return true;\\n        }\\n        \\n        return (\\n            punk.eyes == PunkAttributeValue.NERD_GLASSES ||\\n            punk.eyes == PunkAttributeValue.HORNED_RIM_GLASSES ||\\n            punk.eyes == PunkAttributeValue.EYE_PATCH ||\\n            punk.eyes == PunkAttributeValue.EYE_MASK ||\\n            punk.eyes == PunkAttributeValue.CLASSIC_SHADES ||\\n            punk.eyes == PunkAttributeValue.BIG_SHADES ||\\n            punk.eyes == PunkAttributeValue.VR\\n        );\\n    }\\n    \\n    struct Punk {\\n        uint16 id;\\n        uint16 seed;\\n        PunkAttributeValue sex;\\n        PunkAttributeValue hair;\\n        PunkAttributeValue eyes;\\n        PunkAttributeValue beard;\\n        PunkAttributeValue ears;\\n        PunkAttributeValue lips;\\n        PunkAttributeValue mouth;\\n        PunkAttributeValue face;\\n        PunkAttributeValue emotion;\\n        PunkAttributeValue neck;\\n        PunkAttributeValue nose;\\n        PunkAttributeValue cheeks;\\n        PunkAttributeValue teeth;\\n    }\\n    \\n    function initializePunk(uint16 punkId, uint16 punkSeed) public view returns (Punk memory) {\\n        Punk memory punk = Punk({\\n            id: punkId,\\n            seed: punkSeed,\\n            sex: PunkAttributeValue.NONE,\\n            hair: PunkAttributeValue.NONE,\\n            eyes: PunkAttributeValue.NONE,\\n            beard: PunkAttributeValue.NONE,\\n            ears: PunkAttributeValue.NONE,\\n            lips: PunkAttributeValue.NONE,\\n            mouth: PunkAttributeValue.NONE,\\n            face: PunkAttributeValue.NONE,\\n            emotion: PunkAttributeValue.NONE,\\n            neck: PunkAttributeValue.NONE,\\n            nose: PunkAttributeValue.NONE,\\n            cheeks: PunkAttributeValue.NONE,\\n            teeth: PunkAttributeValue.NONE\\n        });\\n        \\n        string memory attributes = punkDataContract.punkAttributes(punk.id);\\n\\n        string[] memory attributeArray = attributes.split(\\\",\\\");\\n        \\n        for (uint i = 0; i < attributeArray.length; i++) {\\n            string memory untrimmedAttribute = attributeArray[i];\\n            string memory trimmedAttribute;\\n            \\n            if (i < 1) {\\n                trimmedAttribute = untrimmedAttribute.split(' ')[0];\\n            } else {\\n                trimmedAttribute = untrimmedAttribute._substring(int(bytes(untrimmedAttribute).length - 1), 1);\\n            }\\n            \\n            PunkAttributeValue attrValue = attrStringToEnumMapping[trimmedAttribute];\\n            PunkAttributeType attrType = attrValueToTypeEnumMapping[attrValue];\\n            \\n            if (attrType == PunkAttributeType.SEX) {\\n                punk.sex = attrValue;\\n            } else if (attrType == PunkAttributeType.HAIR) {\\n                punk.hair = attrValue;\\n            } else if (attrType == PunkAttributeType.EYES) {\\n                punk.eyes = attrValue;\\n            } else if (attrType == PunkAttributeType.BEARD) {\\n                punk.beard = attrValue;\\n            } else if (attrType == PunkAttributeType.EARS) {\\n                punk.ears = attrValue;\\n            } else if (attrType == PunkAttributeType.LIPS) {\\n                punk.lips = attrValue;\\n            } else if (attrType == PunkAttributeType.MOUTH) {\\n                punk.mouth = attrValue;\\n            } else if (attrType == PunkAttributeType.FACE) {\\n                punk.face = attrValue;\\n            } else if (attrType == PunkAttributeType.EMOTION) {\\n                punk.emotion = attrValue;\\n            } else if (attrType == PunkAttributeType.NECK) {\\n                punk.neck = attrValue;\\n            } else if (attrType == PunkAttributeType.NOSE) {\\n                punk.nose = attrValue;\\n            } else if (attrType == PunkAttributeType.CHEEKS) {\\n                punk.cheeks = attrValue;\\n            } else if (attrType == PunkAttributeType.TEETH) {\\n                punk.teeth = attrValue;\\n            }\\n        }\\n        \\n        return punk;\\n    }\\n    \\n    function punkAttributesAsJSON(uint16 punkId, uint16 punkSeed) public view returns (string memory json) {\\n        Punk memory punk = initializePunk(punkId, punkSeed);\\n        \\n        PunkAttributeValue none = PunkAttributeValue.NONE;\\n        bytes memory output = \\\"[\\\";\\n        \\n        HatType hat = punkHatType(punk);\\n        HatColor hatColor = punkHatColor(punk);\\n        HatPosition hatPosition = punkHatPosition(punk);\\n        \\n        PunkAttributeValue[13] memory attrArray = [\\n            punk.sex,\\n            (visibleHair(punk) ? punk.hair : none),\\n            punk.eyes,\\n            punk.beard,\\n            punk.ears,\\n            punk.lips,\\n            punk.mouth,\\n            punk.face,\\n            punk.emotion,\\n            punk.neck,\\n            punk.nose,\\n            punk.cheeks,\\n            punk.teeth\\n        ];\\n        \\n        bytes memory hatColorBytes;\\n        \\n        if (hatColor == HatColor.BLACK) {\\n            hatColorBytes = \\\"Black\\\";\\n        } else if (hatColor == HatColor.GREY) {\\n            hatColorBytes = \\\"Grey\\\";\\n        } else if (hatColor == HatColor.RED) {\\n            hatColorBytes = \\\"Red\\\";\\n        } else if (hatColor == HatColor.WHITE) {\\n            hatColorBytes = \\\"White\\\";\\n        } else if (hatColor == HatColor.TAN) {\\n            hatColorBytes = \\\"Tan\\\";\\n        } else if (hatColor == HatColor.BROWN) {\\n            hatColorBytes = \\\"Brown\\\";\\n        }\\n        \\n        bytes memory hatTypeBytes;\\n        \\n        if (hat == HatType.BASEBALL) {\\n            hatTypeBytes = \\\"Baseball Cap\\\";\\n        } else if (hat == HatType.BUCKET) {\\n            hatTypeBytes = \\\"Bucket Hat\\\";\\n        } else if (hat == HatType.COWBOY) {\\n            hatTypeBytes = \\\"Cowboy Hat\\\";\\n        } else if (hat == HatType.VISOR) {\\n            hatTypeBytes = \\\"Visor\\\";\\n        }\\n        \\n        for (uint i = 0; i < 13; ++i) {\\n            PunkAttributeValue attrVal = attrArray[i];\\n            \\n            if (attrVal != none) {\\n                output = abi.encodePacked(output, punkAttributeAsJSON(attrVal), \\\",\\\");\\n            }\\n        }\\n        \\n        bytes memory hatName = abi.encodePacked(hatColorBytes, \\\" \\\", hatTypeBytes);\\n        \\n        if (hatPosition == HatPosition.FLIPPED) {\\n            hatName = abi.encodePacked(\\\"Backwards \\\", hatName);\\n        }\\n        \\n        bytes memory hatTrait = abi.encodePacked(\\n            '{\\\"trait_type\\\":\\\"Fashion Hat\\\", \\\"value\\\":\\\"', hatName, '\\\"}'\\n        );\\n        \\n        return string(abi.encodePacked(output, hatTrait, \\\"]\\\"));\\n    }\\n    \\n    function punkAttributeAsJSON(PunkAttributeValue attribute) internal view returns (string memory json) {\\n        require(attribute != PunkAttributeValue.NONE);\\n        \\n        string memory attributeAsString = attrEnumToStringMapping[attribute];\\n        string memory attributeTypeAsString;\\n        \\n        PunkAttributeType attrType = attrValueToTypeEnumMapping[attribute];\\n        \\n        if (attrType == PunkAttributeType.SEX) {\\n            attributeTypeAsString = \\\"Sex\\\";\\n        } else if (attrType == PunkAttributeType.HAIR) {\\n            attributeTypeAsString = \\\"Hair\\\";\\n        } else if (attrType == PunkAttributeType.EYES) {\\n            attributeTypeAsString = \\\"Eyes\\\";\\n        } else if (attrType == PunkAttributeType.BEARD) {\\n            attributeTypeAsString = \\\"Beard\\\";\\n        } else if (attrType == PunkAttributeType.EARS) {\\n            attributeTypeAsString = \\\"Ears\\\";\\n        } else if (attrType == PunkAttributeType.LIPS) {\\n            attributeTypeAsString = \\\"Lips\\\";\\n        } else if (attrType == PunkAttributeType.MOUTH) {\\n            attributeTypeAsString = \\\"Mouth\\\";\\n        } else if (attrType == PunkAttributeType.FACE) {\\n            attributeTypeAsString = \\\"Face\\\";\\n        } else if (attrType == PunkAttributeType.EMOTION) {\\n            attributeTypeAsString = \\\"Emotion\\\";\\n        } else if (attrType == PunkAttributeType.NECK) {\\n            attributeTypeAsString = \\\"Neck\\\";\\n        } else if (attrType == PunkAttributeType.NOSE) {\\n            attributeTypeAsString = \\\"Nose\\\";\\n        } else if (attrType == PunkAttributeType.CHEEKS) {\\n            attributeTypeAsString = \\\"Cheeks\\\";\\n        } else if (attrType == PunkAttributeType.TEETH) {\\n            attributeTypeAsString = \\\"Teeth\\\";\\n        }\\n        \\n        return string(abi.encodePacked('{\\\"trait_type\\\":\\\"', attributeTypeAsString, '\\\", \\\"value\\\":\\\"', attributeAsString, '\\\"}'));\\n    }\\n    \\n    function visibleHair(Punk memory punk) public view returns (bool) {\\n        HatType hat = punkHatType(punk);\\n\\n        if (visibleHairAttribute(punk)) { return true; }\\n        \\n        if (punk.hair == PunkAttributeValue.BEANIE && hat == HatType.BASEBALL) {\\n            return true;\\n        }\\n        \\n        bool tiaraBlocked = punk.eyes == PunkAttributeValue.REGULAR_SHADES ||\\n                            punk.eyes == PunkAttributeValue.CLASSIC_SHADES ||\\n                            punk.eyes == PunkAttributeValue.HORNED_RIM_GLASSES ||\\n                            punk.eyes == PunkAttributeValue.THREE_D_GLASSES ||\\n                            punk.eyes == PunkAttributeValue.EYE_PATCH ||\\n                            punk.eyes == PunkAttributeValue.EYE_MASK;\\n                             \\n        if (punk.hair == PunkAttributeValue.TIARA && (!tiaraBlocked || hatEyePixelGap(punk) == 2)) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    mapping(PunkAttributeValue => PunkAttributeType) public attrValueToTypeEnumMapping;\\n    \\n    function setAttrValueToTypeEnumMapping(uint8[][] memory attrValuesAndTypes) external onlyOwner {\\n        for (uint i; i < attrValuesAndTypes.length; i++) {\\n            PunkAttributeValue attrVal = PunkAttributeValue(attrValuesAndTypes[i][0]);\\n            PunkAttributeType attrType = PunkAttributeType(attrValuesAndTypes[i][1]);\\n            \\n            attrValueToTypeEnumMapping[attrVal] = attrType;\\n        }\\n    }\\n    \\n    mapping(string => PunkAttributeValue) public attrStringToEnumMapping;\\n    mapping(PunkAttributeValue => string) public attrEnumToStringMapping;\\n    \\n    function setAttrStringToEnumMapping(string[] memory attrStrs, PunkAttributeValue[] memory attrEnums) external onlyOwner {\\n        for (uint i; i < attrStrs.length; i++) {\\n            string memory attrString = attrStrs[i];\\n            PunkAttributeValue attrEnum = attrEnums[i];\\n            \\n            attrStringToEnumMapping[attrString] = attrEnum;\\n            attrEnumToStringMapping[attrEnum] = attrString;\\n        }\\n    }\\n    \\n    mapping(PunkAttributeValue => mapping(PunkAttributeValue => mapping(HatType => bool))) public hatAvailableBySexAndHair;\\n    \\n    function canWearHat(Punk memory punk, HatType hat) public view returns (bool) {\\n        return hatAvailableBySexAndHair[punk.hair][punk.sex][hat];\\n    }\\n    \\n    function setAvailableHats(PunkAttributeValue[] memory hairs, PunkAttributeValue[] memory sexes, HatType[] memory hats) external onlyOwner {\\n        for (uint i; i < hairs.length; i++) {\\n            PunkAttributeValue hair = hairs[i];\\n            PunkAttributeValue sex = sexes[i];\\n            HatType hat = hats[i];\\n            \\n            hatAvailableBySexAndHair[hair][sex][hat] = true;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/StringUtilsLib.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n/**\\n * Strings Library\\n * \\n * In summary this is a simple library of string functions which make simple \\n * string operations less tedious in solidity.\\n * \\n * Please be aware these functions can be quite gas heavy so use them only when\\n * necessary not to clog the blockchain with expensive transactions.\\n * \\n * @author James Lockhart <james@n3tw0rk.co.uk>\\n */\\nlibrary StringUtils {\\n\\n    /**\\n     * Concat (High gas cost)\\n     * \\n     * Appends two strings together and returns a new value\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string which will be the concatenated\\n     *              prefix\\n     * @param _value The value to be the concatenated suffix\\n     * @return string The resulting string from combinging the base and value\\n     */\\n    function concat(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        assert(_valueBytes.length > 0);\\n\\n        string memory _tmpValue = new string(_baseBytes.length +\\n            _valueBytes.length);\\n        bytes memory _newValue = bytes(_tmpValue);\\n\\n        uint i;\\n        uint j;\\n\\n        for (i = 0; i < _baseBytes.length; i++) {\\n            _newValue[j++] = _baseBytes[i];\\n        }\\n\\n        for (i = 0; i < _valueBytes.length; i++) {\\n            _newValue[j++] = _valueBytes[i];\\n        }\\n\\n        return string(_newValue);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function indexOf(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (int) {\\n        return _indexOf(_base, _value, 0);\\n    }\\n\\n    /**\\n     * Index Of\\n     *\\n     * Locates and returns the position of a character within a string starting\\n     * from a defined offset\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string acting as the haystack to be\\n     *              searched\\n     * @param _value The needle to search for, at present this is currently\\n     *               limited to one character\\n     * @param _offset The starting point to start searching from which can start\\n     *                from 0, but must not exceed the length of the string\\n     * @return int The position of the needle starting from 0 and returning -1\\n     *             in the case of no matches found\\n     */\\n    function _indexOf(string memory _base, string memory _value, uint _offset)\\n        internal\\n        pure\\n        returns (int) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        assert(_valueBytes.length == 1);\\n\\n        for (uint i = _offset; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] == _valueBytes[0]) {\\n                return int(i);\\n            }\\n        }\\n\\n        return -1;\\n    }\\n\\n    /**\\n     * Length\\n     * \\n     * Returns the length of the specified string\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string to be measured\\n     * @return uint The length of the passed string\\n     */\\n    function length(string memory _base)\\n        internal\\n        pure\\n        returns (uint) {\\n        bytes memory _baseBytes = bytes(_base);\\n        return _baseBytes.length;\\n    }\\n\\n    /**\\n     * Sub String\\n     * \\n     * Extracts the beginning part of a string based on the desired length\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for \\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @return string The extracted sub string\\n     */\\n    function substring(string memory _base, int _length)\\n        internal\\n        pure\\n        returns (string memory) {\\n        return _substring(_base, _length, 0);\\n    }\\n\\n    /**\\n     * Sub String\\n     * \\n     * Extracts the part of a string based on the desired length and offset. The\\n     * offset and length must not exceed the lenth of the base string.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string that will be used for \\n     *              extracting the sub string from\\n     * @param _length The length of the sub string to be extracted from the base\\n     * @param _offset The starting point to extract the sub string from\\n     * @return string The extracted sub string\\n     */\\n    function _substring(string memory _base, int _length, int _offset)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        assert(uint(_offset + _length) <= _baseBytes.length);\\n\\n        string memory _tmp = new string(uint(_length));\\n        bytes memory _tmpBytes = bytes(_tmp);\\n\\n        uint j = 0;\\n        for (uint i = uint(_offset); i < uint(_offset + _length); i++) {\\n            _tmpBytes[j++] = _baseBytes[i];\\n        }\\n\\n        return string(_tmpBytes);\\n    }\\n\\n\\n    function split(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (string[] memory splitArr) {\\n        bytes memory _baseBytes = bytes(_base);\\n\\n        uint _offset = 0;\\n        uint _splitsCount = 1;\\n        while (_offset < _baseBytes.length - 1) {\\n            int _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == -1)\\n                break;\\n            else {\\n                _splitsCount++;\\n                _offset = uint(_limit) + 1;\\n            }\\n        }\\n\\n        splitArr = new string[](_splitsCount);\\n\\n        _offset = 0;\\n        _splitsCount = 0;\\n        while (_offset < _baseBytes.length - 1) {\\n\\n            int _limit = _indexOf(_base, _value, _offset);\\n            if (_limit == - 1) {\\n                _limit = int(_baseBytes.length);\\n            }\\n\\n            string memory _tmp = new string(uint(_limit) - _offset);\\n            bytes memory _tmpBytes = bytes(_tmp);\\n\\n            uint j = 0;\\n            for (uint i = _offset; i < uint(_limit); i++) {\\n                _tmpBytes[j++] = _baseBytes[i];\\n            }\\n            _offset = uint(_limit) + 1;\\n            splitArr[_splitsCount++] = string(_tmpBytes);\\n        }\\n        return splitArr;\\n    }\\n\\n    /**\\n     * Compare To\\n     * \\n     * Compares the characters of two strings, to ensure that they have an \\n     * identical footprint\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent\\n     */\\n    function compareTo(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] != _valueBytes[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Compare To Ignore Case (High gas cost)\\n     * \\n     * Compares the characters of two strings, converting them to the same case\\n     * where applicable to alphabetic characters to distinguish if the values\\n     * match.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *               otherwise this is the string base to compare against\\n     * @param _value The string the base is being compared to\\n     * @return bool Simply notates if the two string have an equivalent value\\n     *              discarding case\\n     */\\n    function compareToIgnoreCase(string memory _base, string memory _value)\\n        internal\\n        pure\\n        returns (bool) {\\n        bytes memory _baseBytes = bytes(_base);\\n        bytes memory _valueBytes = bytes(_value);\\n\\n        if (_baseBytes.length != _valueBytes.length) {\\n            return false;\\n        }\\n\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            if (_baseBytes[i] != _valueBytes[i] &&\\n            _upper(_baseBytes[i]) != _upper(_valueBytes[i])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * Upper\\n     * \\n     * Converts all the values of a string to their corresponding upper case\\n     * value.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to upper case\\n     * @return string \\n     */\\n    function upper(string memory _base)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _upper(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Lower\\n     * \\n     * Converts all the values of a string to their corresponding lower case\\n     * value.\\n     * \\n     * @param _base When being used for a data type this is the extended object\\n     *              otherwise this is the string base to convert to lower case\\n     * @return string \\n     */\\n    function lower(string memory _base)\\n        internal\\n        pure\\n        returns (string memory) {\\n        bytes memory _baseBytes = bytes(_base);\\n        for (uint i = 0; i < _baseBytes.length; i++) {\\n            _baseBytes[i] = _lower(_baseBytes[i]);\\n        }\\n        return string(_baseBytes);\\n    }\\n\\n    /**\\n     * Upper\\n     * \\n     * Convert an alphabetic character to upper case and return the original\\n     * value when not alphabetic\\n     * \\n     * @param _b1 The byte to be converted to upper case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a lower case otherwise returns the original value\\n     */\\n    function _upper(bytes1 _b1)\\n        private\\n        pure\\n        returns (bytes1) {\\n\\n        if (_b1 >= 0x61 && _b1 <= 0x7A) {\\n            return bytes1(uint8(_b1) - 32);\\n        }\\n\\n        return _b1;\\n    }\\n\\n    /**\\n     * Lower\\n     * \\n     * Convert an alphabetic character to lower case and return the original\\n     * value when not alphabetic\\n     * \\n     * @param _b1 The byte to be converted to lower case\\n     * @return bytes1 The converted value if the passed value was alphabetic\\n     *                and in a upper case otherwise returns the original value\\n     */\\n    function _lower(bytes1 _b1)\\n        private\\n        pure\\n        returns (bytes1) {\\n\\n        if (_b1 >= 0x41 && _b1 <= 0x5A) {\\n            return bytes1(uint8(_b1) + 32);\\n        }\\n\\n        return _b1;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"punkDataContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"attrEnumToStringMapping\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"attrStringToEnumMapping\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"attrValueToTypeEnumMapping\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeType\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"canFlipHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"canFlipHatMapping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"},{\"internalType\":\"enum FashionHatPunksData.HatType\",\"name\":\"hat\",\"type\":\"uint8\"}],\"name\":\"canWearHat\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"eyesWithBlackTop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.HatType\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"hatAvailableBySexAndHair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"hatEyePixelGap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"gap\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"punkSeed\",\"type\":\"uint16\"}],\"name\":\"initializePunk\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"lacksVisibleHairAttribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"originalEyePixelGap\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"gap\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"originalEyePixelGapMapping\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"punkId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"punkSeed\",\"type\":\"uint16\"}],\"name\":\"punkAttributesAsJSON\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"json\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"punkHatColor\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.HatColor\",\"name\":\"result\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"punkHatPosition\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.HatPosition\",\"name\":\"result\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"punkHatSize\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.HatSize\",\"name\":\"result\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"punkHatType\",\"outputs\":[{\"internalType\":\"enum FashionHatPunksData.HatType\",\"name\":\"result\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"lessThanNumb\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"seedAddition\",\"type\":\"string\"}],\"name\":\"randomNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"attrStrs\",\"type\":\"string[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"attrEnums\",\"type\":\"uint8[]\"}],\"name\":\"setAttrStringToEnumMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[][]\",\"name\":\"attrValuesAndTypes\",\"type\":\"uint8[][]\"}],\"name\":\"setAttrValueToTypeEnumMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"hairs\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"sexes\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.HatType[]\",\"name\":\"hats\",\"type\":\"uint8[]\"}],\"name\":\"setAvailableHats\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"hairs\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"sexes\",\"type\":\"uint8[]\"}],\"name\":\"setLacksVisibleHairAttribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"hairs\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"sexes\",\"type\":\"uint8[]\"},{\"internalType\":\"uint8[]\",\"name\":\"gaps\",\"type\":\"uint8[]\"}],\"name\":\"setOriginalEyePixelGap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"hairs\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"sexes\",\"type\":\"uint8[]\"}],\"name\":\"setVisorLooksGood\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"hairs\",\"type\":\"uint8[]\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue[]\",\"name\":\"sexes\",\"type\":\"uint8[]\"}],\"name\":\"setcanFlipHatMapping\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"visibleHair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"}],\"name\":\"visibleHairAttribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"visorLooksGood\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"id\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"seed\",\"type\":\"uint16\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"sex\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"hair\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"eyes\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"beard\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"ears\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"lips\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"mouth\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"face\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"emotion\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"neck\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"cheeks\",\"type\":\"uint8\"},{\"internalType\":\"enum FashionHatPunksData.PunkAttributeValue\",\"name\":\"teeth\",\"type\":\"uint8\"}],\"internalType\":\"struct FashionHatPunksData.Punk\",\"name\":\"punk\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"choiceWeights\",\"type\":\"uint256[]\"},{\"internalType\":\"string\",\"name\":\"seedAddition\",\"type\":\"string\"}],\"name\":\"weightedChoice\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "FashionHatPunksData", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000016f5a35647d6f03d5d3da7b35409d65ba03af3b2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}