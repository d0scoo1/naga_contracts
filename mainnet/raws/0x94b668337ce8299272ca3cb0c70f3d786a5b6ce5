{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.8.7;\r\n\r\n// @TODO: Formatting\r\nlibrary LibBytes {\r\n  // @TODO: see if we can just set .length = \r\n  function trimToSize(bytes memory b, uint newLen)\r\n    internal\r\n    pure\r\n  {\r\n    require(b.length > newLen, \"BytesLib: only shrinking\");\r\n    assembly {\r\n      mstore(b, newLen)\r\n    }\r\n  }\r\n\r\n\r\n  /***********************************|\r\n  |        Read Bytes Functions       |\r\n  |__________________________________*/\r\n\r\n  /**\r\n   * @dev Reads a bytes32 value from a position in a byte array.\r\n   * @param b Byte array containing a bytes32 value.\r\n   * @param index Index in byte array of bytes32 value.\r\n   * @return result bytes32 value from byte array.\r\n   */\r\n  function readBytes32(\r\n    bytes memory b,\r\n    uint256 index\r\n  )\r\n    internal\r\n    pure\r\n    returns (bytes32 result)\r\n  {\r\n    // Arrays are prefixed by a 256 bit length parameter\r\n    index += 32;\r\n\r\n    require(b.length >= index, \"BytesLib: length\");\r\n\r\n    // Read the bytes32 from array memory\r\n    assembly {\r\n      result := mload(add(b, index))\r\n    }\r\n    return result;\r\n  }\r\n}\r\n\r\n\r\n\r\ninterface IERC1271Wallet {\r\n\tfunction isValidSignature(bytes32 hash, bytes calldata signature) external view returns (bytes4 magicValue);\r\n}\r\n\r\nlibrary SignatureValidator {\r\n\tusing LibBytes for bytes;\r\n\r\n\tenum SignatureMode {\r\n\t\tEIP712,\r\n\t\tEthSign,\r\n\t\tSmartWallet,\r\n\t\tSpoof\r\n\t}\r\n\r\n\t// bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))\r\n\tbytes4 constant internal ERC1271_MAGICVALUE_BYTES32 = 0x1626ba7e;\r\n\r\n\tfunction recoverAddr(bytes32 hash, bytes memory sig) internal view returns (address) {\r\n\t\treturn recoverAddrImpl(hash, sig, false);\r\n\t}\r\n\r\n\tfunction recoverAddrImpl(bytes32 hash, bytes memory sig, bool allowSpoofing) internal view returns (address) {\r\n\t\trequire(sig.length >= 1, \"SV_SIGLEN\");\r\n\t\tuint8 modeRaw;\r\n\t\tunchecked { modeRaw = uint8(sig[sig.length - 1]); }\r\n\t\tSignatureMode mode = SignatureMode(modeRaw);\r\n\r\n\t\t// {r}{s}{v}{mode}\r\n\t\tif (mode == SignatureMode.EIP712 || mode == SignatureMode.EthSign) {\r\n\t\t\trequire(sig.length == 66, \"SV_LEN\");\r\n\t\t\tbytes32 r = sig.readBytes32(0);\r\n\t\t\tbytes32 s = sig.readBytes32(32);\r\n\t\t\tuint8 v = uint8(sig[64]);\r\n\t\t\t// Hesitant about this check: seems like this is something that has no business being checked on-chain\r\n\t\t\trequire(v == 27 || v == 28, \"SV_INVALID_V\");\r\n\t\t\tif (mode == SignatureMode.EthSign) hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n\t\t\taddress signer = ecrecover(hash, v, r, s);\r\n\t\t\trequire(signer != address(0), \"SV_ZERO_SIG\");\r\n\t\t\treturn signer;\r\n\t\t// {sig}{verifier}{mode}\r\n\t\t} else if (mode == SignatureMode.SmartWallet) {\r\n\t\t\t// 32 bytes for the addr, 1 byte for the type = 33\r\n\t\t\trequire(sig.length > 33, \"SV_LEN_WALLET\");\r\n\t\t\tuint newLen;\r\n\t\t\tunchecked {\r\n\t\t\t\tnewLen = sig.length - 33;\r\n\t\t\t}\r\n\t\t\tIERC1271Wallet wallet = IERC1271Wallet(address(uint160(uint256(sig.readBytes32(newLen)))));\r\n\t\t\tsig.trimToSize(newLen);\r\n\t\t\trequire(ERC1271_MAGICVALUE_BYTES32 == wallet.isValidSignature(hash, sig), \"SV_WALLET_INVALID\");\r\n\t\t\treturn address(wallet);\r\n\t\t// {address}{mode}; the spoof mode is used when simulating calls\r\n\t\t} else if (mode == SignatureMode.Spoof && allowSpoofing) {\r\n\t\t\t// This is safe cause it's specifically intended for spoofing sigs in simulation conditions, where tx.origin can be controlled\r\n\t\t\t// slither-disable-next-line tx-origin\r\n\t\t\trequire(tx.origin == address(1), \"SV_SPOOF_ORIGIN\");\r\n\t\t\trequire(sig.length == 33, \"SV_SPOOF_LEN\");\r\n\t\t\tsig.trimToSize(32);\r\n\t\t\treturn abi.decode(sig, (address));\r\n\t\t} else revert(\"SV_SIGMODE\");\r\n\t}\r\n}\r\n\r\nlibrary MerkleProof {\r\n\tfunction isContained(bytes32 valueHash, bytes32[] memory proof, bytes32 root) internal pure returns (bool) {\r\n\t\tbytes32 cursor = valueHash;\r\n\r\n\t\tuint256 proofLen = proof.length;\r\n\t\tfor (uint256 i = 0; i < proofLen; i++) {\r\n\t\t\tif (cursor < proof[i]) {\r\n\t\t\t\tcursor = keccak256(abi.encodePacked(cursor, proof[i]));\r\n\t\t\t} else {\r\n\t\t\t\tcursor = keccak256(abi.encodePacked(proof[i], cursor));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn cursor == root;\r\n\t}\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract WALLETToken {\r\n\t// Constants\r\n\tstring public constant name = \"Ambire Wallet\";\r\n\tstring public constant symbol = \"WALLET\";\r\n\tuint8 public constant decimals = 18;\r\n\tuint public constant MAX_SUPPLY = 1_000_000_000 * 1e18;\r\n\r\n\t// Mutable variables\r\n\tuint public totalSupply;\r\n\tmapping(address => uint) balances;\r\n\tmapping(address => mapping(address => uint)) allowed;\r\n\r\n\tevent Approval(address indexed owner, address indexed spender, uint amount);\r\n\tevent Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n\tevent SupplyControllerChanged(address indexed prev, address indexed current);\r\n\r\n\taddress public supplyController;\r\n\tconstructor(address _supplyController) {\r\n\t\tsupplyController = _supplyController;\r\n\t\temit SupplyControllerChanged(address(0), _supplyController);\r\n\t}\r\n\r\n\tfunction balanceOf(address owner) external view returns (uint balance) {\r\n\t\treturn balances[owner];\r\n\t}\r\n\r\n\tfunction transfer(address to, uint amount) external returns (bool success) {\r\n\t\tbalances[msg.sender] = balances[msg.sender] - amount;\r\n\t\tbalances[to] = balances[to] + amount;\r\n\t\temit Transfer(msg.sender, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction transferFrom(address from, address to, uint amount) external returns (bool success) {\r\n\t\tbalances[from] = balances[from] - amount;\r\n\t\tallowed[from][msg.sender] = allowed[from][msg.sender] - amount;\r\n\t\tbalances[to] = balances[to] + amount;\r\n\t\temit Transfer(from, to, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction approve(address spender, uint amount) external returns (bool success) {\r\n\t\tallowed[msg.sender][spender] = amount;\r\n\t\temit Approval(msg.sender, spender, amount);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction allowance(address owner, address spender) external view returns (uint remaining) {\r\n\t\treturn allowed[owner][spender];\r\n\t}\r\n\r\n\t// Supply control\r\n\tfunction innerMint(address owner, uint amount) internal {\r\n\t\ttotalSupply = totalSupply + amount;\r\n\t\trequire(totalSupply < MAX_SUPPLY, 'MAX_SUPPLY');\r\n\t\tbalances[owner] = balances[owner] + amount;\r\n\t\t// Because of https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#transfer-1\r\n\t\temit Transfer(address(0), owner, amount);\r\n\t}\r\n\r\n\tfunction mint(address owner, uint amount) external {\r\n\t\trequire(msg.sender == supplyController, 'NOT_SUPPLYCONTROLLER');\r\n\t\tinnerMint(owner, amount);\r\n\t}\r\n\r\n\tfunction changeSupplyController(address newSupplyController) external {\r\n\t\trequire(msg.sender == supplyController, 'NOT_SUPPLYCONTROLLER');\r\n\t\t// Emitting here does not follow checks-effects-interactions-logs, but it's safe anyway cause there are no external calls\r\n\t\temit SupplyControllerChanged(supplyController, newSupplyController);\r\n\t\tsupplyController = newSupplyController;\r\n\t}\r\n}\r\n\r\n\r\ninterface IStakingPool {\r\n\tfunction enterTo(address recipient, uint amount) external;\r\n}\r\n\r\ncontract WALLETSupplyController {\r\n\tevent LogNewVesting(address indexed recipient, uint start, uint end, uint amountPerSec);\r\n\tevent LogVestingUnset(address indexed recipient, uint end, uint amountPerSec);\r\n\tevent LogMintVesting(address indexed recipient, uint amount);\r\n\r\n\t// solhint-disable-next-line var-name-mixedcase\r\n\tWALLETToken public immutable WALLET;\r\n\tmapping (address => bool) public hasGovernance;\r\n\r\n\tconstructor(WALLETToken token, address initialGovernance) {\r\n\t\thasGovernance[initialGovernance] = true;\r\n\t\tWALLET = token;\r\n\t}\r\n\r\n\t// Governance and supply controller\r\n\tfunction changeSupplyController(address newSupplyController) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\tWALLET.changeSupplyController(newSupplyController);\r\n\t}\r\n\r\n\tfunction setGovernance(address addr, bool level) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\t// Sometimes we need to get someone to de-auth themselves, but \r\n\t\t// it's better to protect against bricking rather than have this functionality\r\n\t\t// we can burn conrtol by transferring control over to a contract that can't mint or by ypgrading the supply controller\r\n\t\trequire(msg.sender != addr, \"CANNOT_MODIFY_SELF\");\r\n\t\thasGovernance[addr] = level;\r\n\t}\r\n\r\n\t// Vesting\r\n\t// Some addresses (eg StakingPools) are incentivized with a certain allowance of WALLET per year\r\n\t// Also used for linear vesting of early supporters, team, etc.\r\n\t// mapping of (addr => end => rate) => lastMintTime;\r\n\tmapping (address => mapping(uint => mapping(uint => uint))) public vestingLastMint;\r\n\tfunction setVesting(address recipient, uint start, uint end, uint amountPerSecond) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\t// no more than 10 WALLET per second; theoretical emission max should be ~8 WALLET\r\n\t\trequire(amountPerSecond <= 10e18, \"AMOUNT_TOO_LARGE\");\r\n\t\trequire(start >= 1643695200, \"START_TOO_LOW\");\r\n\t\trequire(vestingLastMint[recipient][end][amountPerSecond] == 0, \"VESTING_ALREADY_SET\");\r\n\t\tvestingLastMint[recipient][end][amountPerSecond] = start;\r\n\t\temit LogNewVesting(recipient, start, end, amountPerSecond);\r\n\t}\r\n\tfunction unsetVesting(address recipient, uint end, uint amountPerSecond) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\t// AUDIT: Pending (unclaimed) vesting is lost here - this is intentional\r\n\t\tvestingLastMint[recipient][end][amountPerSecond] = 0;\r\n\t\temit LogVestingUnset(recipient, end, amountPerSecond);\r\n\t}\r\n\r\n\t// vesting mechanism\r\n\tfunction mintableVesting(address addr, uint end, uint amountPerSecond) public view returns (uint) {\r\n\t\tuint lastMinted = vestingLastMint[addr][end][amountPerSecond];\r\n\t\tif (lastMinted == 0) return 0;\r\n\t\t// solhint-disable-next-line not-rely-on-time\r\n\t\tif (block.timestamp > end) {\r\n\t\t\trequire(end > lastMinted, \"VESTING_OVER\");\r\n\t\t\treturn (end - lastMinted) * amountPerSecond;\r\n\t\t} else {\r\n\t\t\t// this means we have not started yet\r\n\t\t\t// solhint-disable-next-line not-rely-on-time\r\n\t\t\tif (lastMinted > block.timestamp) return 0;\r\n\t\t\t// solhint-disable-next-line not-rely-on-time\r\n\t\t\treturn (block.timestamp - lastMinted) * amountPerSecond;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction mintVesting(address recipient, uint end, uint amountPerSecond) external {\r\n\t\tuint amount = mintableVesting(recipient, end, amountPerSecond);\r\n\t\t// solhint-disable-next-line not-rely-on-time\r\n\t\tvestingLastMint[recipient][end][amountPerSecond] = block.timestamp;\r\n\t\tWALLET.mint(recipient, amount);\r\n\t\temit LogMintVesting(recipient, amount);\r\n\t}\r\n\r\n\t//\r\n\t// Rewards distribution\r\n\t//\r\n\tevent LogUpdatePenaltyBps(uint newPenaltyBps);\r\n\tevent LogClaimStaked(address indexed recipient, uint claimed);\r\n\tevent LogClaimWithPenalty(address indexed recipient, uint received, uint burned);\r\n\r\n\tuint public immutable MAX_CLAIM_NODE = 80_000_000e18;\r\n\r\n\tbytes32 public lastRoot;\r\n\tmapping (address => uint) public claimed;\r\n\tuint public penaltyBps = 0;\r\n\r\n\tfunction setPenaltyBps(uint _penaltyBps) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\trequire(penaltyBps <= 10000, \"BPS_IN_RANGE\");\r\n\t\tpenaltyBps = _penaltyBps;\r\n\t\temit LogUpdatePenaltyBps(_penaltyBps);\r\n\t}\r\n\r\n\tfunction setRoot(bytes32 newRoot) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\tlastRoot = newRoot;\r\n\t}\r\n\r\n\tfunction claimWithRootUpdate(\r\n\t\t// claim() args\r\n\t\taddress recipient, uint totalRewardInTree, bytes32[] calldata proof, uint toBurnBps, IStakingPool stakingPool,\r\n\t\t// args for updating the root\r\n\t\tbytes32 newRoot, bytes calldata signature\r\n\t) external {\r\n\t\taddress signer = SignatureValidator.recoverAddrImpl(newRoot, signature, false);\r\n\t\trequire(hasGovernance[signer], \"NOT_GOVERNANCE\");\r\n\t\tlastRoot = newRoot;\r\n\t\tclaim(recipient, totalRewardInTree, proof, toBurnBps, stakingPool);\r\n\t}\r\n\r\n\t// claim() has two modes, either receive the full amount as xWALLET (staked WALLET) or burn some (penaltyBps) and receive the rest immediately in $WALLET\r\n\t// toBurnBps is a safety parameter that serves two purposes:\r\n\t// 1) prevents griefing attacks/frontrunning where governance sets penalties higher before someone's claim() gets mined\r\n\t// 2) ensures that the sender really does have the intention to burn some of their tokens but receive the rest immediatey\r\n\t// set toBurnBps to 0 to receive the tokens as xWALLET, set it to the current penaltyBps to receive immediately\r\n\t// There is an edge case: when penaltyBps is set to 0, you pass 0 to receive everything immediately; this is intended\r\n\tfunction claim(address recipient, uint totalRewardInTree, bytes32[] memory proof, uint toBurnBps, IStakingPool stakingPool) public {\r\n\t\trequire(totalRewardInTree <= MAX_CLAIM_NODE, \"MAX_CLAIM_NODE\");\r\n\t\trequire(lastRoot != bytes32(0), \"EMPTY_ROOT\");\r\n\r\n\t\t// Check the merkle proof\r\n\t\tbytes32 leaf = keccak256(abi.encode(address(this), recipient, totalRewardInTree));\r\n\t\trequire(MerkleProof.isContained(leaf, proof, lastRoot), \"LEAF_NOT_FOUND\");\r\n\r\n\t\tuint toClaim = totalRewardInTree - claimed[recipient];\r\n\t\tclaimed[recipient] = totalRewardInTree;\r\n\r\n\t\tif (toBurnBps == penaltyBps) {\r\n\t\t\t// Claiming in $WALLET directly: some tokens get burned immediately, but the rest go to you\r\n\t\t\tuint toBurn = (toClaim * penaltyBps) / 10000;\r\n\t\t\tuint toReceive = toClaim - toBurn;\r\n\t\t\t// AUDIT: We can check toReceive > 0 or toBurn > 0, but there's no point since in the most common path both will be non-zero\r\n\t\t\tWALLET.mint(recipient, toReceive);\r\n\t\t\tWALLET.mint(address(0), toBurn);\r\n      emit LogClaimWithPenalty(recipient, toReceive, toBurn);\r\n\t\t} else if (toBurnBps == 0) {\r\n\t\t\tWALLET.mint(address(this), toClaim);\r\n\t\t\tif (WALLET.allowance(address(this), address(stakingPool)) < toClaim) {\r\n\t\t\t\tWALLET.approve(address(stakingPool), type(uint256).max);\r\n\t\t\t}\r\n\t\t\tstakingPool.enterTo(recipient, toClaim);\r\n\t\t\temit LogClaimStaked(recipient, toClaim);\r\n\t\t} else {\r\n\t\t\trevert(\"INVALID_TOBURNBPS\");\r\n\t\t}\r\n\t}\r\n\r\n\t// In case funds get stuck\r\n\tfunction withdraw(IERC20 token, address to, uint256 tokenAmount) external {\r\n\t\trequire(hasGovernance[msg.sender], \"NOT_GOVERNANCE\");\r\n\t\t// AUDIT: SafeERC20 or similar not needed; this is a trusted (governance only) method that doesn't modify internal accounting\r\n\t\t// so sucess/fail does not matter\r\n\t\ttoken.transfer(to, tokenAmount);\r\n\t}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract WALLETToken\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"initialGovernance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"name\":\"LogClaimStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"burned\",\"type\":\"uint256\"}],\"name\":\"LogClaimWithPenalty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogMintVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPerSec\",\"type\":\"uint256\"}],\"name\":\"LogNewVesting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPenaltyBps\",\"type\":\"uint256\"}],\"name\":\"LogUpdatePenaltyBps\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPerSec\",\"type\":\"uint256\"}],\"name\":\"LogVestingUnset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_CLAIM_NODE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WALLET\",\"outputs\":[{\"internalType\":\"contract WALLETToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newSupplyController\",\"type\":\"address\"}],\"name\":\"changeSupplyController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardInTree\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"toBurnBps\",\"type\":\"uint256\"},{\"internalType\":\"contract IStakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalRewardInTree\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"toBurnBps\",\"type\":\"uint256\"},{\"internalType\":\"contract IStakingPool\",\"name\":\"stakingPool\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimWithRootUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerSecond\",\"type\":\"uint256\"}],\"name\":\"mintVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerSecond\",\"type\":\"uint256\"}],\"name\":\"mintableVesting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"penaltyBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"level\",\"type\":\"bool\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_penaltyBps\",\"type\":\"uint256\"}],\"name\":\"setPenaltyBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"newRoot\",\"type\":\"bytes32\"}],\"name\":\"setRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerSecond\",\"type\":\"uint256\"}],\"name\":\"setVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountPerSecond\",\"type\":\"uint256\"}],\"name\":\"unsetVesting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingLastMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "WALLETSupplyController", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000088800092fF476844f74dC2FC427974BBee2794Ae0000000000000000000000000604f2b0dc1d8eac3b7b15fa74fcab7d2bceaee7", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ca367012a18819fdeafec97badabbc5d78f070580e40afeacd3c697be88b7915"}]}