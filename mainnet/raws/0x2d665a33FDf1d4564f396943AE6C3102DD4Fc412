{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/RQDQURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n////   //////////          //////////////        /////////////////          //////////////\\n////          /////      /////        /////      ////          /////      /////        /////\\n////            ///     ////            ////     ////            ////    ////            ////\\n////           ////     ////            ////     ////            ////    ////            ////\\n//////////////////      ////            ////     ////            ////    ////            ////\\n////                    ////     ///    ////     ////            ////    ////     ///    ////\\n////      ////          ////     /////  ////     ////            ////    ////     /////  ////\\n////        ////        ////       /////////     ////            ////    ////       /////////\\n////         /////       /////       //////      ////          /////      /////       //////\\n////           /////       ////////    ////      ////   //////////          ////////    ////\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Base64.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"./IERC721Dispatcher.sol\\\";\\nimport \\\"./IERC721Delegable.sol\\\";\\n\\n/**\\n * @title RQDQURI\\n * @dev Render library for tokenURI of RQDQ sDQ tokens.\\n * @author 0xAnimist (kanon.art)\\n */\\nlibrary RQDQURI {\\n\\n  function packSVG(uint256 _tokenId) public pure returns(string memory) {\\n    string[9] memory parts;\\n        parts[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" preserveAspectRatio=\\\"xMinYMin meet\\\" viewBox=\\\"0 0 350 350\\\"><style>.base {fill: rgb(40,40,40); font-family: \\\"Helvetica\\\", Arial, sans-serif;} .firstLevel { font-size: 14px;} .secondLevel {font-size: 8px; line-height: 10px;}</style><rect width=\\\"100%\\\" height=\\\"100%\\\" fill=\\\"WhiteSmoke\\\" /><text x=\\\"10\\\" y=\\\"25\\\" class=\\\"base firstLevel\\\">RQDQ token # ';\\n\\n        parts[1] = Strings.toString(_tokenId);\\n\\n        parts[2] = '</text><text x=\\\"10\\\" y=\\\"40\\\" class=\\\"base secondLevel\\\">';\\n\\n        parts[3] = 'See description for redemption chain';\\n\\n        parts[4] = '</text></svg>';\\n\\n        return string(abi.encodePacked(parts[0], parts[1], parts[2], parts[3], parts[4]));\\n  }\\n\\n  function packName(uint256 _tokenId) public pure returns(string memory) {\\n    return string(abi.encodePacked('\\\"name\\\": \\\"RQDQ token #', Strings.toString(_tokenId), '\\\",'));\\n  }\\n\\n  function packDescription(address _RQContract, address _DQContract, uint256 _RQTokenId, uint256 _DQTokenId, uint256 _tokenId) public pure returns(string memory) {\\n    string[8] memory description;\\n    description[0] = '\\\"description\\\": \\\"This RQDQ token is redeemable for token #';\\n    description[1] = Strings.toString(_DQTokenId);\\n    description[2] = ' of the NFT contract at ';\\n    description[3] = toString(_DQContract);\\n    description[4] = ' which is the delegate token for ERC721Delegable token #';\\n    description[5] = Strings.toString(_RQTokenId);\\n    description[6] = ' of the NFT contract at ';\\n    description[7] = toString(_RQContract);\\n\\n    string memory desc = string(abi.encodePacked(\\n      description[0],\\n      description[1],\\n      description[2],\\n      description[3],\\n      description[4],\\n      description[5],\\n      description[6],\\n      description[7]\\n    ));\\n\\n    return string(abi.encodePacked(desc, '.\\\",'));\\n  }\\n\\n  function tokenURI(uint256 _tokenId) public view returns(string memory) {\\n    (address RQContract, uint256 RQTokenId) = IERC721Dispatcher(msg.sender).getDepositByTokenId(_tokenId);\\n    (address DQContract, uint256 DQTokenId) = IERC721Delegable(RQContract).getDelegateToken(RQTokenId);\\n\\n    string memory name = packName(_tokenId);\\n    string memory description = packDescription(RQContract, DQContract, RQTokenId, DQTokenId, _tokenId);\\n    string memory svg = packSVG(_tokenId);\\n\\n    string memory metadata = string(abi.encodePacked(\\n      '{',\\n      name,\\n      description\\n    ));\\n\\n    string memory json = Base64.encode(bytes(string(abi.encodePacked(\\n      metadata,\\n      '\\\"image\\\": \\\"data:image/svg+xml;base64,',\\n      Base64.encode(bytes(svg)),\\n      '\\\"}'))));\\n\\n    return string(abi.encodePacked('data:application/json;base64,', json));\\n  }\\n\\n\\n  //Address to string encodeing by k06a\\n  //see: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\\n  function toString(address account) internal pure returns(string memory) {\\n    return toString(abi.encodePacked(account));\\n  }\\n\\n  function toString(bytes32 value) internal pure returns(string memory) {\\n    return toString(abi.encodePacked(value));\\n  }\\n\\n  function toString(bytes memory data) internal pure returns(string memory) {\\n    bytes memory alphabet = \\\"0123456789abcdef\\\";\\n\\n    bytes memory str = new bytes(2 + data.length * 2);\\n    str[0] = \\\"0\\\";\\n    str[1] = \\\"x\\\";\\n    for (uint i = 0; i < data.length; i++) {\\n        str[2+i*2] = alphabet[uint(uint8(data[i] >> 4))];\\n        str[3+i*2] = alphabet[uint(uint8(data[i] & 0x0f))];\\n    }\\n    return string(str);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/IERC721Dispatcher.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n\\n/**\\n * @title IERC721Dispatcher\\n * @dev Interface for an ERC721Delegable token dispatcher.\\n * @author 0xAnimist (kanon.art)\\n */\\ninterface IERC721Dispatcher {\\n\\n  /**\\n   * @dev Emitted when a delegate token has been deposited.\\n   */\\n  event Deposited(address indexed sourceTokenContract, uint256 indexed sourceTokenId, uint256 tokenId, address depositedBy, bytes[] terms, bytes data);\\n\\n  /**\\n   * @dev Emitted when a delegate token has been withdrawn.\\n   */\\n  event Withdrawn(address indexed sourceTokenContract, uint256 indexed sourceTokenId, uint256 tokenId, address withdrawnBy, bytes data);\\n\\n  /**\\n   * @dev Emitted when an approval request has been granted.\\n   */\\n  event ApprovalGranted(address indexed sourceTokenContract, uint256 indexed sourceTokenId, address indexed to, address payee, bytes terms, bytes data);\\n\\n  /**\\n   * @dev Emitted when terms are set for a token.\\n   */\\n  event TermsSet(address indexed owner, bytes[] terms, uint256 tokenId, bytes data);\\n\\n  /**\\n   * @dev Deposits an array of delegate tokens of their corresponding delegable Tokens\\n   * in exchange for sDQ receipt tokens.\\n   *\\n   * Requirements:\\n   *\\n   * - must be the owner of the delegate token\\n   *\\n   * Emits a {Deposited} event.\\n   */\\n  function deposit(address[] memory _ERC721DelegableContract, uint256[] memory _ERC721DelegableTokenId, bytes[][] memory _terms, bytes calldata _data) external returns (uint256[] memory tokenIds);\\n\\n  /**\\n   * @dev Withdraws a staked delegate token in exchange for `_tokenId` sDQ token receipt.\\n   *\\n   * Emits a {Withdrawn} event.\\n   */\\n  function withdraw(uint256 _tokenId, bytes calldata _data) external;\\n\\n  /**\\n   * @dev Sets the terms by which an approval request will be granted.\\n   *\\n   * Emits a {TermsSet} event.\\n   */\\n  function setTerms(bytes[] memory _terms, uint256 _tokenId, bytes calldata _data) external;\\n\\n  /**\\n   * @dev Gets the terms by which an approval request will be granted.\\n   */\\n  function getTerms(uint256 _tokenId) external view returns (bytes[] memory terms);\\n\\n  /**\\n   * @dev Gets array of methodIds served by the dispatcher.\\n   */\\n  function getServedMethodIds() external view returns (bytes4[] memory methodIds);\\n\\n  /**\\n   * @dev Gets source ERC721Delegable token for a given `_tokenId` token.\\n   */\\n  function getDepositByTokenId(uint256 _tokenId) external view returns (address contractAddress, uint256 tokenId);\\n\\n  /**\\n   * @dev Gets tokenId` token ID for a given source ERC721Delegable token.\\n   */\\n  function getTokenIdByDeposit(address _ERC721DelegableContract, uint256 _ERC721DelegableTokenId) external view returns (bool success, uint256 tokenId);\\n\\n  /**\\n   * @dev Requests dispatcher call approveByDelegate() on the source ERC721Delegable\\n   * token corresponding to `_tokenId` token for `_to` address with `_terms` terms.\\n   */\\n  function requestApproval(address _payee, address _to, address _ERC721DelegableContract, uint256 _ERC721DelegableTokenId, bytes memory _terms, bytes calldata _data) external payable;\\n\\n  /**\\n   * @dev Withdraws fees accrued to all eligible recipients for `_tokenId` token without withdrawing the token itself.\\n   *\\n   * Requirements:\\n   *\\n   * - token must exist.\\n   *\\n   */\\n  function claimFeesAccrued(uint256 _tokenId) external returns (bool success, address currency);\\n}\\n\"\r\n    },\r\n    \"/contracts/IERC721Delegable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\n/**\\n * @title IERC721Delegable\\n * @dev Interface for a delegable ERC721 token contract\\n * @author 0xAnimist (kanon.art)\\n */\\ninterface IERC721Delegable is IERC721 {\\n  /**\\n   * @dev Emitted when the delegate token is set for `tokenId` token.\\n   */\\n  event DelegateTokenSet(address indexed delegateContract, uint256 indexed delegateTokenId, uint256 indexed tokenId, address operator, bytes data);\\n\\n  /**\\n   * @dev Sets the delegate NFT for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   *\\n   * Emits a {DelegateTokenSet} event.\\n   */\\n  function setDelegateToken(address _delegateContract, uint256 _delegateTokenId, uint256 _tokenId) external;\\n\\n  /**\\n   * @dev Sets the delegate NFT for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   *\\n   * Emits a {DelegateTokenSet} event.\\n   */\\n  function setDelegateToken(address _delegateContract, uint256 _delegateTokenId, uint256 _tokenId, bytes calldata _data) external;\\n\\n  /**\\n   * @dev Gets the delegate NFT for `tokenId` token.\\n   *\\n   * Requirements:\\n   *\\n   * - `tokenId` must exist.\\n   */\\n  function getDelegateToken(uint256 _tokenId) external view returns (address contractAddress, uint256 tokenId);\\n\\n  /**\\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n   * The approval is cleared when the token is transferred.\\n   *\\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n   *\\n   * Requirements:\\n   *\\n   * - The caller must own the delegate token.\\n   * - `tokenId` must exist.\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approveByDelegate(address to, uint256 tokenId) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// https://kanon.art\\n//\\n//\\n//                                   $@@@@@@@@@@@$$$\\n//                               $$@@@@@@$$$$$$$$$$$$$$##\\n//                           $$$$$$$$$$$$$$$$$#########***\\n//                        $$$$$$$$$$$$$$$#######**!!!!!!\\n//                     ##$$$$$$$$$$$$#######****!!!!=========\\n//                   ##$$$$$$$$$#$#######*#***!!!=!===;;;;;\\n//                 *#################*#***!*!!======;;;:::\\n//                ################********!!!!====;;;:::~~~~~\\n//              **###########******!!!!!!==;;;;::~~~--,,,-~\\n//             ***########*#*******!*!!!!====;;;::::~~-,,......,-\\n//            ******#**********!*!!!!=!===;;::~~~-,........\\n//           ***************!*!!!!====;;:::~~-,,..........\\n//         !************!!!!!!===;;::~~--,............\\n//         !!!*****!!*!!!!!===;;:::~~--,,..........\\n//        =!!!!!!!!!=!==;;;::~~-,,...........\\n//        =!!!!!!!!!====;;;;:::~~--,........\\n//       ==!!!!!!=!==;=;;:::~~--,...:~~--,,,..\\n//       ===!!!!!=====;;;;;:::~~~--,,..#*=;;:::~--,.\\n//       ;=============;;;;;;::::~~~-,,...$$###==;;:~--.\\n//      :;;==========;;;;;;::::~~~--,,....@@$$##*!=;:~-.\\n//      :;;;;;===;;;;;;;::::~~~--,,...$$$$#*!!=;~-\\n//       :;;;;;;;;;;:::::~~~~---,,...!*##**!==;~,\\n//       :::;:;;;;:::~~~~---,,,...~;=!!!!=;;:~.\\n//       ~:::::::::::::~~~~~---,,,....-:;;=;;;~,\\n//        ~~::::::::~~~~~~~-----,,,......,~~::::~-.\\n//         -~~~~~~~~~~~~~-----------,,,.......,-~~~~~,.\\n//          ---~~~-----,,,,,........,---,.\\n//           ,,--------,,,,,,.........\\n//             .,,,,,,,,,,,,......\\n//                ...............\\n//                    .........\\n\\n\\npragma solidity ^0.8.0;\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n\\n  bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n  /// @notice Encodes some bytes to the base64 representation\\n  function encode(bytes memory data) internal pure returns (string memory) {\\n      uint256 len = data.length;\\n      if (len == 0) return \\\"\\\";\\n\\n      // multiply by 4/3 rounded up\\n      uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n      // Add some extra buffer at the end\\n      bytes memory result = new bytes(encodedLen + 32);\\n\\n      bytes memory table = TABLE;\\n\\n      assembly {\\n          let tablePtr := add(table, 1)\\n          let resultPtr := add(result, 32)\\n\\n          for {\\n              let i := 0\\n          } lt(i, len) {\\n\\n          } {\\n              i := add(i, 3)\\n              let input := and(mload(add(data, i)), 0xffffff)\\n\\n              let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n              out := shl(8, out)\\n              out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n              out := shl(8, out)\\n              out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n              out := shl(8, out)\\n              out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n              out := shl(224, out)\\n\\n              mstore(resultPtr, out)\\n\\n              resultPtr := add(resultPtr, 4)\\n          }\\n\\n          switch mod(len, 3)\\n          case 1 {\\n              mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n          }\\n          case 2 {\\n              mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n          }\\n\\n          mstore(result, encodedLen)\\n      }\\n\\n      return string(result);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RQContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_DQContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_RQTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_DQTokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"packDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"packName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"packSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RQDQURI", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}