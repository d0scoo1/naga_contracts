{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/MonaGallery/MonaArtClubGallery.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"../ECDSA.sol\\\";\\r\\nimport \\\"../Ownable.sol\\\";\\r\\nimport \\\"../IERC721.sol\\\";\\r\\n\\r\\ncontract MonaGallery is Ownable {\\r\\n\\r\\n    struct OnChainListing {\\r\\n        uint expirationTimestamp;\\r\\n        uint artistId;\\r\\n        uint tokenId;\\r\\n        uint price;\\r\\n        // uint nonce;\\r\\n    }\\r\\n\\r\\n    struct Artist {\\r\\n        address tokenContract;\\r\\n        address addr;\\r\\n        uint percentage;\\r\\n    }\\r\\n\\r\\n    struct OnChainExternalNFTListing {\\r\\n        address tokenContract;\\r\\n        address artistAddr;\\r\\n        uint tokenId;\\r\\n        uint price;\\r\\n        uint expirationTimestamp;\\r\\n    }\\r\\n\\r\\n    mapping(bytes => bool) usedSigs;\\r\\n    mapping(uint => bool) _onChainListingsCompleted;\\r\\n    mapping(uint => bool) _ExternalOnChainListingsCompleted;\\r\\n\\r\\n\\r\\n    Artist[] public artists;\\r\\n    OnChainListing[] public onChainListings;\\r\\n    OnChainExternalNFTListing[] public onChainExternalNFTListings;\\r\\n\\r\\n    uint public activeOnChainListings;\\r\\n    uint public activeExternalOnChainListings;\\r\\n\\r\\n\\r\\n    event NewArtist(address tokenContract, address addr, uint percentage, uint artistId);\\r\\n    event NewOnChainListing(uint expirationTimestamp, uint artistId, uint tokenId, uint price, uint listingId);\\r\\n    event NewExternalOnChainListing(address tokenContract, address artistAddr, uint tokenId, uint price, uint expirationTimestamp, uint externalListingId);\\r\\n\\r\\n    function buyNFT(uint onChainListingId) external payable {\\r\\n        require(!_onChainListingsCompleted[onChainListingId], \\\"Listing was completed or canceled!\\\");\\r\\n        OnChainListing memory listing = onChainListings[onChainListingId];\\r\\n        require(uint(listing.expirationTimestamp) >= block.timestamp, \\\"Listing expired!\\\");\\r\\n        require(listing.price == msg.value, \\\"Ether amount incorrect!\\\");\\r\\n\\r\\n        Artist memory artist = artists[listing.artistId];\\r\\n\\r\\n        // split payments\\r\\n        uint eth = msg.value - ((msg.value * 25) / 1000);\\r\\n        uint artistAmount = (eth * artist.percentage) / 10_000;\\r\\n        bool success;\\r\\n\\r\\n        (success, ) = payable(artist.addr).call{value: artistAmount, gas: 2600}(\\\"\\\"); // artist\\r\\n        require(success, \\\"Failed To Send Ether to artist! User has reverted!\\\");\\r\\n\\r\\n        eth = msg.value - artistAmount;\\r\\n        (success, ) = payable(0xAF2992d490E78B94113D44d63E10D1E668b69984).call{value: eth / 4, gas: 2600}(\\\"\\\"); // F5\\r\\n        require(success, \\\"Failed To Send Ether to F5! User has reverted!\\\");\\r\\n        (success, ) = payable(0x077b813889659Ad54E1538A380584E7a9399ff8F).call{value: (eth / 4) * 3, gas: 2600}(\\\"\\\"); // Mona\\r\\n        require(success, \\\"Failed To Send Ether to Mona! User has reverted!\\\");\\r\\n\\r\\n        // complete listing and transfer token\\r\\n        _onChainListingsCompleted[onChainListingId] = true;\\r\\n        activeOnChainListings--;\\r\\n        IERC721(artist.tokenContract).safeTransferFrom(address(this), msg.sender, listing.tokenId);\\r\\n    }\\r\\n\\r\\n    function buyExternalNFT(uint externalOnChainListingId) external payable {\\r\\n        require(!_ExternalOnChainListingsCompleted[externalOnChainListingId], \\\"Listing was completed or canceled!\\\");\\r\\n        OnChainExternalNFTListing memory listing = onChainExternalNFTListings[externalOnChainListingId];\\r\\n        require(listing.expirationTimestamp >= block.timestamp, \\\"Listing expired!\\\");\\r\\n        require(listing.price == msg.value, \\\"Ether amount incorrect!\\\");\\r\\n\\r\\n        // split payments\\r\\n        uint eth = msg.value - ((msg.value * 25) / 1000);\\r\\n        uint artistAmount = (eth * 85) / 100;\\r\\n        bool success;\\r\\n\\r\\n        (success, ) = payable(listing.artistAddr).call{value: artistAmount, gas: 2600}(\\\"\\\"); // artist\\r\\n        require(success, \\\"Failed To Send Ether to artist! User has reverted!\\\");\\r\\n\\r\\n        eth = msg.value - artistAmount;\\r\\n        (success, ) = payable(0xAF2992d490E78B94113D44d63E10D1E668b69984).call{value: eth / 4, gas: 2600}(\\\"\\\"); // F5\\r\\n        require(success, \\\"Failed To Send Ether to F5! User has reverted!\\\");\\r\\n        (success, ) = payable(0x077b813889659Ad54E1538A380584E7a9399ff8F).call{value: (eth / 4) * 3, gas: 2600}(\\\"\\\"); // Mona\\r\\n        require(success, \\\"Failed To Send Ether to Mona! User has reverted!\\\");\\r\\n\\r\\n        // complete listing and transfer token\\r\\n        _ExternalOnChainListingsCompleted[externalOnChainListingId] = true;\\r\\n        activeExternalOnChainListings--;\\r\\n        IERC721(listing.tokenContract).safeTransferFrom(address(this), msg.sender, listing.tokenId);\\r\\n    }\\r\\n\\r\\n    function cancelOnChainListing(uint onChainListingId) external onlyOwner {\\r\\n        require(onChainListingId < onChainListings.length, \\\"On chain listing does not exist!\\\");\\r\\n        require(!_onChainListingsCompleted[onChainListingId], \\\"Already Completed Or Canceled!\\\");\\r\\n        _onChainListingsCompleted[onChainListingId] = true;\\r\\n        activeOnChainListings--;\\r\\n    }\\r\\n\\r\\n    function cancelOnChainExternalListing(uint onChainExternalListingId) external onlyOwner {\\r\\n        require(onChainExternalListingId < onChainListings.length, \\\"On chain listing does not exist!\\\");\\r\\n        require(!_ExternalOnChainListingsCompleted[onChainExternalListingId], \\\"Already Completed Or Canceled!\\\");\\r\\n        _ExternalOnChainListingsCompleted[onChainExternalListingId] = true;\\r\\n        activeExternalOnChainListings--;\\r\\n    }\\r\\n\\r\\n    function onChainListNFT(uint expirationTimestamp, uint artistId, uint tokenId, uint price) external onlyOwner {\\r\\n        onChainListings.push(OnChainListing(expirationTimestamp, artistId, tokenId, price));\\r\\n        activeOnChainListings++;\\r\\n        emit NewOnChainListing(expirationTimestamp, artistId, tokenId, price, onChainListings.length - 1);\\r\\n    }\\r\\n\\r\\n    function onChainListExternalNFT(address tokenContract, address artistAddr, uint tokenId, uint price, uint expirationTimestamp) external onlyOwner {\\r\\n        onChainExternalNFTListings.push(OnChainExternalNFTListing(tokenContract, artistAddr, tokenId, price, expirationTimestamp));\\r\\n        activeExternalOnChainListings++;\\r\\n        emit NewExternalOnChainListing(tokenContract, artistAddr, tokenId, price, expirationTimestamp, onChainExternalNFTListings.length - 1);\\r\\n    }\\r\\n\\r\\n    function addArtist(address tokenContract, address addr, uint percentage) external onlyOwner {\\r\\n        artists.push(Artist(tokenContract, addr, percentage));\\r\\n        emit NewArtist(tokenContract, addr, percentage, artists.length - 1);\\r\\n    }\\r\\n\\r\\n    function getArtist(uint id) external view returns (address tokenContract, address addr, uint percentage) {\\r\\n        Artist memory artist = artists[id];\\r\\n        return (artist.tokenContract, artist.addr, artist.percentage);\\r\\n    }\\r\\n\\r\\n    function getOnChainListing(uint id) external view returns(uint expirationTimestamp, uint artistId, uint tokenId, uint price) {\\r\\n        OnChainListing memory listing = onChainListings[id];\\r\\n        return (listing.expirationTimestamp, listing.artistId, listing.tokenId, listing.price);\\r\\n    }\\r\\n\\r\\n    function getOnChainExternalNFTListing(uint id) external view returns(address tokenContract, address artistAddr, uint tokenId, uint price, uint expirationTimestamp) {\\r\\n        OnChainExternalNFTListing memory listing = onChainExternalNFTListings[id];\\r\\n        return (listing.tokenContract, listing.artistAddr, listing.tokenId, listing.price, listing.expirationTimestamp);\\r\\n    }\\r\\n\\r\\n    function getAllActiveOnChainListingIds() external view returns(uint[] memory) {\\r\\n        uint[] memory listings = new uint[](activeOnChainListings);\\r\\n        uint x;\\r\\n\\r\\n        for (uint i; i < onChainListings.length; i++) {\\r\\n            if (!_onChainListingsCompleted[i]) {\\r\\n                listings[x] = i;\\r\\n                x++;\\r\\n            }\\r\\n        }\\r\\n        return listings;\\r\\n    }\\r\\n\\r\\n    function getAllActiveOnChainExternalListingIds() external view returns(uint[] memory) {\\r\\n        uint[] memory listings = new uint[](activeExternalOnChainListings);\\r\\n        uint x;\\r\\n\\r\\n        for (uint i; i < onChainExternalNFTListings.length; i++) {\\r\\n            if (!_ExternalOnChainListingsCompleted[i]) {\\r\\n                listings[x] = i;\\r\\n                x++;\\r\\n            }\\r\\n        }\\r\\n        return listings;\\r\\n    }\\r\\n    \\r\\n    // function hashStruct(Order memory order) private pure returns (bytes32 hash) {\\r\\n    //     return keccak256(abi.encode(\\r\\n    //         /* ORDER_TYPEHASH */ keccak256(\\\"Order(address tokenContract,uint expirationTimestamp,uint tokenId,uint price)\\\"),\\r\\n    //         order.tokenContract,\\r\\n    //         order.expirationTimestamp,\\r\\n    //         order.tokenId,\\r\\n    //         order.price\\r\\n    //     ));\\r\\n    // }\\r\\n\\r\\n    function transferNFT(address tokenContract, uint id, address to) external onlyOwner {\\r\\n        IERC721(tokenContract).safeTransferFrom(address(this), to, id);\\r\\n    }\\r\\n\\r\\n/*\\r\\n    function getMsgOrderHash(Order calldata order) external pure returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(order.tokenContract, order.expirationTimestamp, order.tokenId, order.price, order.nonce));\\r\\n    }\\r\\n*/\\r\\n\\r\\n    function withdraw() external onlyOwner {\\r\\n        uint bal = address(this).balance;\\r\\n        (bool success, ) = payable(msg.sender).call{value: bal, gas: 2600}(\\\"\\\");\\r\\n        require(success, \\\"Failed To Send Ether! User has reverted!\\\");\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * Source: Openzeppelin\\r\\n */\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/IERC721.sol\": {\r\n      \"content\": \"// https://eips.ethereum.org/EIPS/eip-721, http://erc721.org/ \\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\r\\ninterface IERC721 is IERC165 {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory data) external;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`'s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"/contracts/IERC165.sol\": {\r\n      \"content\": \"// https://eips.ethereum.org/EIPS/eip-165 \\r\\n// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceID The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\"\r\n    },\r\n    \"/contracts/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.0 (utils/cryptography/ECDSA.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n */\\r\\nlibrary ECDSA {\\r\\n    enum RecoverError {\\r\\n        NoError,\\r\\n        InvalidSignature,\\r\\n        InvalidSignatureLength,\\r\\n        InvalidSignatureS,\\r\\n        InvalidSignatureV\\r\\n    }\\r\\n\\r\\n    function _throwError(RecoverError error) private pure {\\r\\n        if (error == RecoverError.NoError) {\\r\\n            return; // no error: do nothing\\r\\n        } else if (error == RecoverError.InvalidSignature) {\\r\\n            revert(\\\"ECDSA: invalid signature\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureS) {\\r\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\r\\n        } else if (error == RecoverError.InvalidSignatureV) {\\r\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature` or error string. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     *\\r\\n     * Documentation for signature generation:\\r\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\r\\n        // Check the signature length\\r\\n        // - case 65: r,s,v signature (standard)\\r\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\r\\n        if (signature.length == 65) {\\r\\n            bytes32 r;\\r\\n            bytes32 s;\\r\\n            uint8 v;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                s := mload(add(signature, 0x40))\\r\\n                v := byte(0, mload(add(signature, 0x60)))\\r\\n            }\\r\\n            return tryRecover(hash, v, r, s);\\r\\n        } else if (signature.length == 64) {\\r\\n            bytes32 r;\\r\\n            bytes32 vs;\\r\\n            // ecrecover takes the signature parameters, and the only way to get them\\r\\n            // currently is to use assembly.\\r\\n            assembly {\\r\\n                r := mload(add(signature, 0x20))\\r\\n                vs := mload(add(signature, 0x40))\\r\\n            }\\r\\n            return tryRecover(hash, r, vs);\\r\\n        } else {\\r\\n            return (address(0), RecoverError.InvalidSignatureLength);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n     * `signature`. This address can then be used for verification purposes.\\r\\n     *\\r\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n     * this function rejects them by requiring the `s` value to be in the lower\\r\\n     * half order, and the `v` value to be either 27 or 28.\\r\\n     *\\r\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n     * verification to be secure: it is possible to craft signatures that\\r\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n     * this is by receiving a hash of the original message (which may otherwise\\r\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n     */\\r\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\r\\n        _throwError(error);\\r\\n        return recovered;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\r\\n     *\\r\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        bytes32 r,\\r\\n        bytes32 vs\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n        assembly {\\r\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\r\\n            v := add(shr(255, vs), 27)\\r\\n        }\\r\\n        return tryRecover(hash, v, r, s);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\r\\n     * `r` and `s` signature fields separately.\\r\\n     *\\r\\n     * _Available since v4.3._\\r\\n     */\\r\\n    function tryRecover(\\r\\n        bytes32 hash,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) internal pure returns (address, RecoverError) {\\r\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\r\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n        //\\r\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n        // these malleable signatures as well.\\r\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\r\\n            return (address(0), RecoverError.InvalidSignatureS);\\r\\n        }\\r\\n        if (v != 27 && v != 28) {\\r\\n            return (address(0), RecoverError.InvalidSignatureV);\\r\\n        }\\r\\n\\r\\n        // If the signature is valid (and not malleable), return the signer address\\r\\n        address signer = ecrecover(hash, v, r, s);\\r\\n        if (signer == address(0)) {\\r\\n            return (address(0), RecoverError.InvalidSignature);\\r\\n        }\\r\\n\\r\\n        return (signer, RecoverError.NoError);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\r\\n     * produces hash corresponding to the one signed with the\\r\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\r\\n     * JSON-RPC method as part of EIP-191.\\r\\n     *\\r\\n     * See {recover}.\\r\\n     */\\r\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\r\\n        // 32 is the length in bytes of hash,\\r\\n        // enforced by the type signature above\\r\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\r\\n    }\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artistId\",\"type\":\"uint256\"}],\"name\":\"NewArtist\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"artistAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"externalListingId\",\"type\":\"uint256\"}],\"name\":\"NewExternalOnChainListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"artistId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"}],\"name\":\"NewOnChainListing\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeExternalOnChainListings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOnChainListings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"addArtist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"artists\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"externalOnChainListingId\",\"type\":\"uint256\"}],\"name\":\"buyExternalNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"onChainListingId\",\"type\":\"uint256\"}],\"name\":\"buyNFT\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"onChainExternalListingId\",\"type\":\"uint256\"}],\"name\":\"cancelOnChainExternalListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"onChainListingId\",\"type\":\"uint256\"}],\"name\":\"cancelOnChainListing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllActiveOnChainExternalListingIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllActiveOnChainListingIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getArtist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOnChainExternalNFTListing\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"artistAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getOnChainListing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artistId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onChainExternalNFTListings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"artistAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"artistAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"}],\"name\":\"onChainListExternalNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artistId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"onChainListNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"onChainListings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"expirationTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"artistId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MonaGallery", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}