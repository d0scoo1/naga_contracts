{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@solidstate/contracts/access/IERC173Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC173 interface needed by internal functions\\n */\\ninterface IERC173Internal {\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/IOwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC173Internal } from '../IERC173Internal.sol';\\n\\ninterface IOwnableInternal is IERC173Internal {}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOwnableInternal } from './IOwnableInternal.sol';\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal is IOwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n\\n    function _owner() internal view virtual returns (address) {\\n        return OwnableStorage.layout().owner;\\n    }\\n\\n    function _transferOwnership(address account) internal virtual {\\n        OwnableStorage.layout().setOwner(account);\\n        emit OwnershipTransferred(msg.sender, account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/ownable/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC1155MetadataInternal } from './IERC1155MetadataInternal.sol';\\nimport { ERC1155MetadataStorage } from './ERC1155MetadataStorage.sol';\\n\\n/**\\n * @title ERC1155Metadata internal functions\\n */\\nabstract contract ERC1155MetadataInternal is IERC1155MetadataInternal {\\n    /**\\n     * @notice set base metadata URI\\n     * @dev base URI is a non-standard feature adapted from the ERC721 specification\\n     * @param baseURI base URI\\n     */\\n    function _setBaseURI(string memory baseURI) internal {\\n        ERC1155MetadataStorage.layout().baseURI = baseURI;\\n    }\\n\\n    /**\\n     * @notice set per-token metadata URI\\n     * @param tokenId token whose metadata URI to set\\n     * @param tokenURI per-token URI\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory tokenURI) internal {\\n        ERC1155MetadataStorage.layout().tokenURIs[tokenId] = tokenURI;\\n        emit URI(tokenURI, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC1155 metadata extensions\\n */\\nlibrary ERC1155MetadataStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC1155Metadata');\\n\\n    struct Layout {\\n        string baseURI;\\n        mapping(uint256 => string) tokenURIs;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC1155/metadata/IERC1155MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Partial ERC1155Metadata interface needed by internal functions\\n */\\ninterface IERC1155MetadataInternal {\\n    event URI(string value, uint256 indexed tokenId);\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandAdmin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableInternal, OwnableStorage } from \\\"@solidstate/contracts/access/ownable/OwnableInternal.sol\\\";\\nimport { ERC1155MetadataInternal } from \\\"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataInternal.sol\\\";\\nimport { ERC1155MetadataStorage } from \\\"@solidstate/contracts/token/ERC1155/metadata/ERC1155MetadataStorage.sol\\\";\\n\\nimport { ERC2981Admin } from \\\"../vendor/ERC2981/ERC2981Admin.sol\\\";\\n\\nimport { OpenSeaCompatibleInternal } from \\\"../vendor/OpenSea/OpenSeaCompatible.sol\\\";\\nimport { OpenSeaProxyStorage } from \\\"../vendor/OpenSea/OpenSeaProxyStorage.sol\\\";\\n\\nimport { LandStorage, MintState, Zone } from \\\"./LandStorage.sol\\\";\\n\\ncontract LandAdmin is\\n\\tOwnableInternal,\\n\\tERC1155MetadataInternal,\\n\\tOpenSeaCompatibleInternal,\\n\\tERC2981Admin\\n{\\n\\t// event fired when a proxy is updated\\n\\tevent SetProxy(address proxy, bool enabled);\\n\\n\\t// event fired when a signer is updated\\n\\tevent SetSigner(address old, address newAddress);\\n\\n\\tfunction addInventory(uint16 zoneId, uint16 count) external onlyOwner {\\n\\t\\tZone storage zone = LandStorage._getZone(zoneId);\\n\\t\\trequire(\\n\\t\\t\\tcount <= zone.endIndex - zone.startIndex - zone.max - zone.count,\\n\\t\\t\\t\\\"_addInventory: too much\\\"\\n\\t\\t);\\n\\t\\tLandStorage._addInventory(zone, count);\\n\\t}\\n\\n\\tfunction removeInventory(uint16 zoneId, uint16 count) external onlyOwner {\\n\\t\\tZone storage zone = LandStorage._getZone(zoneId);\\n\\t\\trequire(count <= zone.max - zone.count, \\\"_removeInventory: too much\\\");\\n\\t\\tLandStorage._removeInventory(zone, count);\\n\\t}\\n\\n\\t/**\\n\\t * ability to add a zone.\\n\\t * can be disabled by adding a zone with zero available inventory.\\n\\t */\\n\\tfunction addZone(Zone memory zone) external onlyOwner {\\n\\t\\tuint16 index = LandStorage._getIndex();\\n\\t\\tZone memory last = LandStorage._getZone(index);\\n\\n\\t\\trequire(zone.count == 0, \\\"_addZone: wrong count\\\");\\n\\t\\trequire(zone.startIndex == last.endIndex, \\\"_addZone: wrong start\\\");\\n\\t\\trequire(zone.startIndex <= zone.endIndex, \\\"_addZone: wrong end\\\");\\n\\t\\trequire(zone.max <= zone.endIndex - zone.startIndex, \\\"_addZone: wrong max\\\");\\n\\t\\trequire(\\n\\t\\t\\tzone.endIndex - zone.startIndex <= last.endIndex - last.startIndex,\\n\\t\\t\\t\\\"_addZone: too much\\\"\\n\\t\\t);\\n\\n\\t\\tLandStorage._addZone(zone);\\n\\t}\\n\\n\\tfunction setAvatars(address avatars) external onlyOwner {\\n\\t\\tLandStorage._setAvatars(avatars);\\n\\t}\\n\\n\\tfunction setBaseURI(string memory baseURI) external onlyOwner {\\n\\t\\t_setBaseURI(baseURI);\\n\\t}\\n\\n\\t// can be used to effectively deny claims by setting them to already claimed\\n\\tfunction setClaimedAvatar(uint256 tokenId, address claimedBy) external onlyOwner {\\n\\t\\tLandStorage._setClaimedAvatar(tokenId, claimedBy);\\n\\t}\\n\\n\\tfunction setContractURI(string memory contractURI) external onlyOwner {\\n\\t\\t_setContractURI(contractURI);\\n\\t}\\n\\n\\tfunction setIndex(uint16 index) external onlyOwner {\\n\\t\\tLandStorage._setIndex(index);\\n\\t}\\n\\n\\tfunction setInventory(uint16 zoneId, uint16 maxCount) external onlyOwner {\\n\\t\\tZone storage zone = LandStorage._getZone(zoneId);\\n\\t\\trequire(maxCount >= zone.count, \\\"_setInventory: invalid\\\");\\n\\t\\trequire(maxCount <= zone.endIndex - zone.startIndex - zone.count, \\\"_setInventory: too much\\\");\\n\\t\\tLandStorage._setInventory(zone, maxCount);\\n\\t}\\n\\n\\tfunction setMintState(MintState mintState) external onlyOwner {\\n\\t\\tLandStorage.layout().mintState = uint8(mintState);\\n\\t}\\n\\n\\tfunction setPrice(uint64 price) external onlyOwner {\\n\\t\\tLandStorage._setPrice(price);\\n\\t}\\n\\n\\tfunction setProxy(address proxy, bool enabled) external onlyOwner {\\n\\t\\tLandStorage._setProxy(proxy, enabled);\\n\\t\\temit SetProxy(proxy, enabled);\\n\\t}\\n\\n\\tfunction setOSProxies(address os721Proxy, address os1155Proxy) external onlyOwner {\\n\\t\\tOpenSeaProxyStorage._setProxies(os721Proxy, os1155Proxy);\\n\\t}\\n\\n\\tfunction setSigner(address signer) external onlyOwner {\\n\\t\\taddress old = LandStorage._getSigner();\\n\\t\\tLandStorage._setSigner(signer);\\n\\t\\temit SetSigner(old, signer);\\n\\t}\\n\\n\\tfunction setTokenURI(uint256 tokenId, string memory tokenURI) external onlyOwner {\\n\\t\\t_setTokenURI(tokenId, tokenURI);\\n\\t}\\n\\n\\tfunction withdraw() external onlyOwner {\\n\\t\\tpayable(OwnableStorage.layout().owner).transfer(address(this).balance);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { MintState, Zone } from \\\"./LandTypes.sol\\\";\\n\\nlibrary LandStorage {\\n\\tstruct Layout {\\n\\t\\tuint8 mintState;\\n\\t\\tuint16 index; // current incremental index of zone id's\\n\\t\\tuint64 price;\\n\\t\\taddress signer;\\n\\t\\taddress avatars;\\n\\t\\tZone avatarClaim; // zoneId is zero\\n\\t\\tmapping(uint256 => address) claimedAvatars;\\n\\t\\tmapping(uint16 => Zone) zones;\\n\\t\\tmapping(address => bool) proxies;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"io.frogland.contracts.storage.LandStorage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n\\n\\t// Adders\\n\\n\\tfunction _addClaimCount(uint16 count) internal {\\n\\t\\tlayout().avatarClaim.count += count;\\n\\t}\\n\\n\\tfunction _addCount(uint16 index, uint16 count) internal {\\n\\t\\tZone storage zone = _getZone(index);\\n\\t\\t_addCount(zone, count);\\n\\t}\\n\\n\\tfunction _addCount(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.count += count;\\n\\t}\\n\\n\\tfunction _addInventory(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.max += count;\\n\\t}\\n\\n\\tfunction _removeInventory(Zone storage zone, uint16 count) internal {\\n\\t\\tzone.max -= count;\\n\\t}\\n\\n\\tfunction _addZone(Zone memory zone) internal {\\n\\t\\tuint16 index = _getIndex();\\n\\t\\tindex += 1;\\n\\t\\tlayout().zones[index] = zone;\\n\\t\\t_setIndex(index);\\n\\t}\\n\\n\\t// Getters\\n\\n\\tfunction _getClaimedAvatar(uint256 tokenId) internal view returns (address) {\\n\\t\\treturn layout().claimedAvatars[tokenId];\\n\\t}\\n\\n\\tfunction _getIndex() internal view returns (uint16 index) {\\n\\t\\treturn layout().index;\\n\\t}\\n\\n\\tfunction _getPrice() internal view returns (uint64) {\\n\\t\\treturn layout().price;\\n\\t}\\n\\n\\tfunction _getSigner() internal view returns (address) {\\n\\t\\treturn layout().signer;\\n\\t}\\n\\n\\tfunction _getZone(uint16 index) internal view returns (Zone storage) {\\n\\t\\tif (index == 0) {\\n\\t\\t\\treturn layout().avatarClaim;\\n\\t\\t}\\n\\t\\treturn layout().zones[index];\\n\\t}\\n\\n\\t// Setters\\n\\n\\tfunction _setAvatars(address avatars) internal {\\n\\t\\tlayout().avatars = avatars;\\n\\t}\\n\\n\\tfunction _setClaimedAvatar(uint256 tokenId, address claimedBy) internal {\\n\\t\\tlayout().claimedAvatars[tokenId] = claimedBy;\\n\\t}\\n\\n\\tfunction _setClaimedAvatars(uint256[] memory tokenIds, address claimedBy) internal {\\n\\t\\tfor (uint256 index = 0; index < tokenIds.length; index++) {\\n\\t\\t\\tuint256 tokenId = tokenIds[index];\\n\\t\\t\\t_setClaimedAvatar(tokenId, claimedBy);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setIndex(uint16 index) internal {\\n\\t\\tlayout().index = index;\\n\\t}\\n\\n\\tfunction _setInventory(Zone storage zone, uint16 maxCount) internal {\\n\\t\\tzone.max = maxCount;\\n\\t}\\n\\n\\tfunction _setPrice(uint64 price) internal {\\n\\t\\tlayout().price = price;\\n\\t}\\n\\n\\tfunction _setProxy(address proxy, bool enabled) internal {\\n\\t\\tlayout().proxies[proxy] = enabled;\\n\\t}\\n\\n\\tfunction _setSigner(address signer) internal {\\n\\t\\tlayout().signer = signer;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/land/LandTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// Enums\\n\\nenum MintState {\\n\\tCLOSED,\\n\\tCLAIM,\\n\\tPRESALE,\\n\\tPUBLIC\\n}\\n\\n// Init Args\\n\\nstruct LandInitArgs {\\n\\taddress signer;\\n\\taddress avatars;\\n\\tuint64 price;\\n\\tZone avatarClaim;\\n\\tZone[] zones;\\n}\\n\\n// Structs\\n\\n// waves for sale\\n// each tranche is mapped to a zone by Id\\n// except zone 0 which is the claim\\n// the first 10k are the claim\\nstruct Zone {\\n\\tuint8 zoneId;\\n\\tuint16 count;\\n\\tuint16 max;\\n\\tuint24 startIndex;\\n\\tuint24 endIndex;\\n}\\n\\n// requests\\n\\nstruct ClaimRequest {\\n\\taddress to;\\n\\tuint64 deadline; // block.timestamp\\n\\tuint256[] tokenIds;\\n}\\n\\nstruct MintRequest {\\n\\taddress to;\\n\\tuint64 deadline; // block.timestamp\\n\\tuint8 zoneId;\\n\\tuint16 count;\\n}\\n\\nstruct MintManyRequest {\\n\\taddress to;\\n\\tuint64 deadline;\\n\\tuint16[] count; // array by zone index\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ERC2981/ERC2981Admin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { OwnableInternal, OwnableStorage } from \\\"@solidstate/contracts/access/ownable/OwnableInternal.sol\\\";\\n\\nimport \\\"./ERC2981Storage.sol\\\";\\n\\n/// @dev This is a contract used to add ERC2981 support to ERC721 and 1155\\n/// @dev This implementation has the same royalties for each and every tokens\\nabstract contract ERC2981Admin is OwnableInternal {\\n\\t/// @dev Sets token royalties\\n\\t/// @param recipient recipient of the royalties\\n\\t/// @param value percentage (using 2 decimals - 10000 = 100, 0 = 0)\\n\\tfunction setRoyalties(address recipient, uint256 value) external onlyOwner {\\n\\t\\trequire(value <= 10000, \\\"ERC2981Royalties: Too high\\\");\\n\\t\\tERC2981Storage.layout().royalties = RoyaltyInfo(recipient, uint24(value));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/ERC2981/ERC2981Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nstruct RoyaltyInfo {\\n\\taddress recipient;\\n\\tuint24 amount;\\n}\\n\\nlibrary ERC2981Storage {\\n\\tstruct Layout {\\n\\t\\tRoyaltyInfo royalties;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT =\\n\\t\\tkeccak256(\\\"IERC2981Royalties.contracts.storage.ERC2981Storage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/IOpenSeaCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOpenSeaCompatible {\\n\\t/**\\n\\t * Get the contract metadata\\n\\t */\\n\\tfunction contractURI() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/OpenSeaCompatible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IOpenSeaCompatible } from \\\"./IOpenSeaCompatible.sol\\\";\\n\\nlibrary OpenSeaCompatibleStorage {\\n\\tstruct Layout {\\n\\t\\tstring contractURI;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT =\\n\\t\\tkeccak256(\\\"com.opensea.contracts.storage.OpenSeaCompatibleStorage\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\t// slither-disable-next-line timestamp\\n\\t\\t// solhint-disable no-inline-assembly\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n}\\n\\nabstract contract OpenSeaCompatibleInternal {\\n\\tfunction _setContractURI(string memory contractURI) internal virtual {\\n\\t\\tOpenSeaCompatibleStorage.layout().contractURI = contractURI;\\n\\t}\\n}\\n\\nabstract contract OpenSeaCompatible is OpenSeaCompatibleInternal, IOpenSeaCompatible {\\n\\tfunction contractURI() external view returns (string memory) {\\n\\t\\treturn OpenSeaCompatibleStorage.layout().contractURI;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/vendor/OpenSea/OpenSeaProxyStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nstruct OpenSeaProxyInitArgs {\\n\\taddress os721Proxy;\\n\\taddress os1155Proxy;\\n}\\n\\nlibrary OpenSeaProxyStorage {\\n\\tstruct Layout {\\n\\t\\taddress os721Proxy;\\n\\t\\taddress os1155Proxy;\\n\\t}\\n\\n\\tbytes32 internal constant STORAGE_SLOT = keccak256(\\\"com.opensea.contracts.storage.proxy\\\");\\n\\n\\tfunction layout() internal pure returns (Layout storage l) {\\n\\t\\tbytes32 slot = STORAGE_SLOT;\\n\\t\\tassembly {\\n\\t\\t\\tl.slot := slot\\n\\t\\t}\\n\\t}\\n\\n\\tfunction _setProxies(OpenSeaProxyInitArgs memory init) internal {\\n\\t\\t_setProxies(init.os721Proxy, init.os1155Proxy);\\n\\t}\\n\\n\\tfunction _setProxies(address os721Proxy, address os1155Proxy) internal {\\n\\t\\tlayout().os721Proxy = os721Proxy;\\n\\t\\tlayout().os1155Proxy = os1155Proxy;\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"SetProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SetSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"zoneId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"addInventory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"zoneId\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"max\",\"type\":\"uint16\"},{\"internalType\":\"uint24\",\"name\":\"startIndex\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"endIndex\",\"type\":\"uint24\"}],\"internalType\":\"struct Zone\",\"name\":\"zone\",\"type\":\"tuple\"}],\"name\":\"addZone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"zoneId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"count\",\"type\":\"uint16\"}],\"name\":\"removeInventory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"avatars\",\"type\":\"address\"}],\"name\":\"setAvatars\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"claimedBy\",\"type\":\"address\"}],\"name\":\"setClaimedAvatar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"contractURI\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"setIndex\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"zoneId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxCount\",\"type\":\"uint16\"}],\"name\":\"setInventory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MintState\",\"name\":\"mintState\",\"type\":\"uint8\"}],\"name\":\"setMintState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"os721Proxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"os1155Proxy\",\"type\":\"address\"}],\"name\":\"setOSProxies\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setRoyalties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LandAdmin", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}