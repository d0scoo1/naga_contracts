{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proxy/VTableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '@openzeppelin/contracts/proxy/Proxy.sol';\\n\\nimport './VTable.sol';\\nimport './modules/VTableUpdateModule.sol';\\n\\n/**\\n * @title VTableProxy\\n */\\ncontract VTableProxy is Proxy {\\n    using VTable for VTable.VTableStore;\\n\\n    bytes4 private constant _FALLBACK_SIGN = 0xffffffff;\\n\\n    constructor(address updatemodule) {\\n        VTable.VTableStore storage vtable = VTable.instance();\\n\\n        vtable.setOwner(msg.sender);\\n        vtable.setFunction(VTableUpdateModule(updatemodule).updateVTable.selector, updatemodule);\\n    }\\n\\n    function _implementation() internal view virtual override returns (address module) {\\n        VTable.VTableStore storage vtable = VTable.instance();\\n\\n        module = vtable.getFunction(msg.sig);\\n        if (module != address(0)) return module;\\n\\n        module = vtable.getFunction(_FALLBACK_SIGN);\\n        if (module != address(0)) return module;\\n\\n        revert('VTableProxy: No implementation found');\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize()) }\\n            default { return(0, returndatasize()) }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive () external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/VTable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n/**\\n * @title VTable\\n */\\nlibrary VTable {\\n    // bytes32 private constant _VTABLE_SLOT = bytes32(uint256(keccak256(\\\"openzeppelin.vtable.location\\\")) - 1);\\n    bytes32 private constant _VTABLE_SLOT = 0x13f1d5ea37b1d7aca82fcc2879c3bddc731555698dfc87ad6057b416547bc657;\\n\\n    struct VTableStore {\\n        address _owner;\\n        mapping(bytes4 => address) _delegates;\\n    }\\n\\n    /**\\n     * @dev Get singleton instance\\n     */\\n    function instance() internal pure returns (VTableStore storage vtable) {\\n        bytes32 position = _VTABLE_SLOT;\\n        assembly {\\n            vtable.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Ownership management\\n     */\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function getOwner(VTableStore storage vtable) internal view returns (address) {\\n        return vtable._owner;\\n    }\\n\\n    function setOwner(VTableStore storage vtable, address newOwner) internal {\\n        emit OwnershipTransferred(vtable._owner, newOwner);\\n        vtable._owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev VTableManagement\\n     */\\n    event VTableUpdate(bytes4 indexed selector, address oldImplementation, address newImplementation);\\n\\n    function getFunction(VTableStore storage vtable, bytes4 selector) internal view returns (address) {\\n        return vtable._delegates[selector];\\n    }\\n\\n    function setFunction(\\n        VTableStore storage vtable,\\n        bytes4 selector,\\n        address module\\n    ) internal {\\n        emit VTableUpdate(selector, vtable._delegates[selector], module);\\n        vtable._delegates[selector] = module;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/proxy/modules/VTableUpdateModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport '../VTable.sol';\\n\\ncontract VTableUpdateModule {\\n    using VTable for VTable.VTableStore;\\n\\n    event VTableUpdate(bytes4 indexed selector, address oldImplementation, address newImplementation);\\n\\n    struct ModuleDefinition {\\n        address implementation;\\n        bytes4[] selectors;\\n    }\\n\\n    /**\\n     * @dev Updates the vtable\\n     */\\n    function updateVTable(ModuleDefinition[] calldata modules) public {\\n        VTable.VTableStore storage vtable = VTable.instance();\\n        require(VTable.instance().getOwner() == msg.sender, 'VTableOwnership: caller is not the owner');\\n\\n        for (uint256 i = 0; i < modules.length; ++i) {\\n            ModuleDefinition memory module = modules[i];\\n            for (uint256 j = 0; j < module.selectors.length; ++j) {\\n                vtable.setFunction(module.selectors[j], module.implementation);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999,\r\n      \"details\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updatemodule\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VTableProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "000000000000000000000000a78e81cce96bac0e00c081e599806bcea2dd5917", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}