{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Bridge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"./utils/Pausable.sol\\\";\\r\\nimport \\\"./utils/SafeMath.sol\\\";\\r\\nimport \\\"./utils/UpgradableOwnable.sol\\\";\\r\\nimport \\\"./interfaces/IDepositExecute.sol\\\";\\r\\nimport \\\"./interfaces/IBridge.sol\\\";\\r\\nimport \\\"./interfaces/IERCHandler.sol\\\";\\r\\n\\r\\n/**\\r\\n    @title Facilitates deposits, creation and votiing of deposit proposals, and deposit executions.\\r\\n */\\r\\ncontract Bridge is Pausable, SafeMathContract, UpgradableOwnable {\\r\\n    bytes8 public _chainID;\\r\\n    uint256 public _fee;\\r\\n    address public _backendSrvAddress;\\r\\n\\r\\n    enum ProposalStatus {\\r\\n        Inactive,\\r\\n        Active,\\r\\n        Passed,\\r\\n        Executed,\\r\\n        Cancelled\\r\\n    }\\r\\n\\r\\n    bytes32 public _nativeResourceID;\\r\\n\\r\\n    // destinationChainID => number of deposits\\r\\n    mapping(bytes8 => uint64) public _depositCounts;\\r\\n    // resourceID => handler address\\r\\n    mapping(bytes32 => address) public _resourceIDToHandlerAddress;\\r\\n    // depositNonce => destinationChainID => bytes\\r\\n    mapping(uint64 => mapping(bytes8 => bytes)) public _depositRecords;\\r\\n    // destinationChainID + depositNonce => dataHash => bool\\r\\n    mapping(bytes32 => mapping(bytes32 => bool)) public _executedProposals;\\r\\n\\r\\n    mapping(address => bool) public handlers;\\r\\n\\r\\n    event Deposit(\\r\\n        bytes8 originChainID,\\r\\n        bytes8 indexed destinationChainID,\\r\\n        bytes32 indexed resourceID,\\r\\n        uint64 indexed depositNonce,\\r\\n        address depositor,\\r\\n        address recipientAddress,\\r\\n        address tokenAddress,\\r\\n        uint256 amount,\\r\\n        bytes32 dataHash\\r\\n    );\\r\\n    event ProposalEvent(\\r\\n        bytes8 indexed originChainID,\\r\\n        bytes8 indexed destinationChainID,\\r\\n        address indexed recipientAddress,\\r\\n        uint256 amount,\\r\\n        uint64 depositNonce,\\r\\n        ProposalStatus status,\\r\\n        bytes32 resourceID,\\r\\n        bytes32 dataHash\\r\\n    );\\r\\n    event ExtraFeeSupplied(\\r\\n        bytes8 originChainID,\\r\\n        bytes8 destinationChainID,\\r\\n        uint64 depositNonce,\\r\\n        bytes32 resourceID,\\r\\n        address recipientAddress,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    modifier onlyBackendSrv() {\\r\\n        _onlyBackendSrv();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _onlyBackendSrv() private view {\\r\\n        require(\\r\\n            _backendSrvAddress == msg.sender,\\r\\n            \\\"sender is not a backend service\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    modifier onlyHandler() {\\r\\n        require(handlers[msg.sender], \\\"sender is not a handler\\\" );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setHandler(address _handler, bool value) external onlyOwner {\\r\\n        handlers[_handler] = value;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Initializes Bridge, creates and grants {msg.sender} the admin role,\\r\\n        Sets deposit fee\\r\\n        @param chainID ID of chain the Bridge contract exists on.\\r\\n     */\\r\\n    function initialize(\\r\\n        bytes8 chainID,\\r\\n        uint256 fee,\\r\\n        address initBackendSrvAddress\\r\\n    ) public {\\r\\n        _chainID = chainID;\\r\\n        _fee = fee;\\r\\n        _backendSrvAddress = initBackendSrvAddress;\\r\\n        ownableInit(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice sets new backend srv.\\r\\n        @notice Only callable by an address that currently has the admin role.\\r\\n        @param newBackendSrv Address of new backend srv.\\r\\n     */\\r\\n    function adminSetBackendSrv(address newBackendSrv) external onlyOwner {\\r\\n        _backendSrvAddress = newBackendSrv;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Pauses deposits, proposal creation and voting, and deposit executions.\\r\\n        @notice Only callable by an address that currently has the admin role.\\r\\n     */\\r\\n    function adminPauseTransfers() external onlyOwner {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Unpauses deposits, proposal creation and voting, and deposit executions.\\r\\n        @notice Only callable by an address that currently has the admin role.\\r\\n     */\\r\\n    function adminUnpauseTransfers() external onlyOwner {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Sets a new resource for handler contracts that use the IERCHandler interface,\\r\\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\\r\\n        @notice Only callable by an address that currently has the admin role.\\r\\n        @param handlerAddress Address of handler resource will be set for.\\r\\n        @param resourceID ResourceID to be used when making deposits.\\r\\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\\r\\n     */\\r\\n    function adminSetResource(\\r\\n        address handlerAddress,\\r\\n        bytes32 resourceID,\\r\\n        address tokenAddress\\r\\n    ) external onlyOwner {\\r\\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\\r\\n        IERCHandler handler = IERCHandler(handlerAddress);\\r\\n        handler.setResource(resourceID, tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice sets resourceID for native token\\r\\n        @dev can only be called through admin address\\r\\n        @param resourceID resourceID for native token\\r\\n     */\\r\\n    function adminSetNativeResourceID(bytes32 resourceID) external onlyOwner {\\r\\n        _nativeResourceID = resourceID;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Sets a resource as burnable for handler contracts that use the IERCHandler interface.\\r\\n        @notice Only callable by an address that currently has the admin role.\\r\\n        @param handlerAddress Address of handler resource will be set for.\\r\\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\\r\\n     */\\r\\n    function adminSetBurnable(address handlerAddress, address tokenAddress)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        IERCHandler handler = IERCHandler(handlerAddress);\\r\\n        handler.setBurnable(tokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Changes deposit fee.\\r\\n        @notice Only callable by admin.\\r\\n        @param newFee Value {_fee} will be updated to.\\r\\n     */\\r\\n    function adminChangeFee(uint256 newFee) external onlyOwner {\\r\\n        require(_fee != newFee, \\\"Current fee is equal to new fee\\\");\\r\\n        _fee = newFee;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Used to manually withdraw funds from ERC safes.\\r\\n        @param handlerAddress Address of handler to withdraw from.\\r\\n        @param tokenAddress Address of token to withdraw.\\r\\n        @param recipient Address to withdraw tokens to.\\r\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to withdraw.\\r\\n     */\\r\\n    function adminWithdraw(\\r\\n        address handlerAddress,\\r\\n        address tokenAddress,\\r\\n        address recipient,\\r\\n        uint256 amountOrTokenID\\r\\n    ) external onlyOwner {\\r\\n        IERCHandler handler = IERCHandler(handlerAddress);\\r\\n        handler.withdraw(tokenAddress, recipient, amountOrTokenID);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Used to approve spending tokens by another handler.\\r\\n        @param resourceIDOwner ID of owner handler.\\r\\n        @param resourceIDSpender ID of spender handler.\\r\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to approve.\\r\\n     */\\r\\n    function adminApprove(\\r\\n        bytes32 resourceIDOwner,\\r\\n        bytes32 resourceIDSpender,\\r\\n        uint256 amountOrTokenID\\r\\n    ) external onlyOwner {\\r\\n        address handlerOwner = _resourceIDToHandlerAddress[resourceIDOwner];\\r\\n        require(handlerOwner != address(0), \\\"resourceIDOwner not mapped to handler\\\");\\r\\n\\r\\n        address handlerSpender = _resourceIDToHandlerAddress[resourceIDSpender];\\r\\n        require(handlerSpender != address(0), \\\"resourceIDSpender not mapped to handler\\\");\\r\\n\\r\\n        IERCHandler handler = IERCHandler(handlerOwner);\\r\\n        handler.approve(resourceIDOwner, handlerSpender, amountOrTokenID);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Initiates a transfer using a specified handler contract.\\r\\n        @notice Only callable when Bridge is not paused.\\r\\n        @param destinationChainID ID of chain deposit will be bridged to.\\r\\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\\r\\n        @param amountToLA to be converted to LA with bridge swap.\\r\\n        @notice Emits {Deposit} event.\\r\\n     */\\r\\n    function deposit(\\r\\n        bytes8 destinationChainID,\\r\\n        bytes32 resourceID,\\r\\n        uint256 amount,\\r\\n        address recipientAddress,\\r\\n        uint256 amountToLA,\\r\\n        bytes calldata params\\r\\n    ) external payable whenNotPaused {\\r\\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\\r\\n        bytes memory data = abi.encode(amount, recipientAddress);\\r\\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\\r\\n        _depositRecords[depositNonce][destinationChainID] = data;\\r\\n\\r\\n        address tokenAddress;\\r\\n        uint256 totalAmount = amount + amountToLA;\\r\\n        if (resourceID == _nativeResourceID) {\\r\\n            require(\\r\\n                msg.value >= (totalAmount + _fee),\\r\\n                \\\"Incorrect fee/amount supplied\\\"\\r\\n            );\\r\\n\\r\\n            tokenAddress = address(0);\\r\\n\\r\\n        } else {\\r\\n            require(msg.value >= _fee, \\\"Incorrect fee supplied\\\");\\r\\n\\r\\n            address handler = _resourceIDToHandlerAddress[resourceID];\\r\\n            require(handler != address(0), \\\"resourceID not mapped to handler\\\");\\r\\n\\r\\n            tokenAddress = IDepositExecute(handler).deposit(\\r\\n                resourceID,\\r\\n                destinationChainID,\\r\\n                depositNonce,\\r\\n                msg.sender,\\r\\n                recipientAddress,\\r\\n                totalAmount,\\r\\n                params\\r\\n            );\\r\\n        }\\r\\n            if (amountToLA > 0) {\\r\\n                emit ExtraFeeSupplied(\\r\\n                    _chainID,\\r\\n                    destinationChainID,\\r\\n                    depositNonce,\\r\\n                    resourceID,\\r\\n                    recipientAddress,\\r\\n                    amountToLA\\r\\n                );\\r\\n            }\\r\\n\\r\\n        uint256 stackAmount = amount;\\r\\n\\r\\n        emit Deposit(\\r\\n            _chainID,\\r\\n            destinationChainID,\\r\\n            resourceID,\\r\\n            depositNonce,\\r\\n            msg.sender,\\r\\n            recipientAddress,\\r\\n            tokenAddress,\\r\\n            stackAmount,\\r\\n            dataHash\\r\\n        );\\r\\n    }\\r\\n    \\r\\n    // Deposit for AAVE amTokens\\r\\n    function internalDeposit(\\r\\n        bytes8 destinationChainID,\\r\\n        bytes32 resourceID,\\r\\n        uint256 amount,\\r\\n        address recipientAddress\\r\\n    ) public whenNotPaused onlyHandler {\\r\\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\\r\\n        bytes memory data = abi.encode(amount, recipientAddress);\\r\\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\\r\\n        _depositRecords[depositNonce][destinationChainID] = data;\\r\\n\\r\\n        address handler = _resourceIDToHandlerAddress[resourceID];\\r\\n        address tokenAddress = IDepositExecute(handler).getAddressFromResourceId(resourceID);\\r\\n        \\r\\n        emit Deposit(\\r\\n            _chainID,\\r\\n            destinationChainID,\\r\\n            resourceID,\\r\\n            depositNonce,\\r\\n            msg.sender,\\r\\n            recipientAddress,\\r\\n            tokenAddress,\\r\\n            amount,\\r\\n            dataHash\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\\r\\n        @notice Only callable by relayers when Bridge is not paused.\\r\\n        @param destinationChainID ID of chain where proposal is executed.\\r\\n        @param resourceID ResourceID to be used when making deposits.\\r\\n        @param depositNonce ID of deposited generated by origin Bridge contract.\\r\\n        @notice Proposal must not have executed before.\\r\\n        @notice Emits {ProposalEvent} event with status {Executed}.\\r\\n     */\\r\\n    function executeProposal(\\r\\n        bytes8 originChainID,\\r\\n        bytes8 destinationChainID,\\r\\n        uint64 depositNonce,\\r\\n        bytes32 resourceID,\\r\\n        address payable recipientAddress,\\r\\n        uint256 amount,\\r\\n        bytes calldata params\\r\\n    ) external onlyBackendSrv whenNotPaused {\\r\\n        bytes memory data = abi.encode(amount, recipientAddress);\\r\\n        bytes32 nonceAndID = keccak256(\\r\\n            abi.encode(depositNonce, originChainID, destinationChainID)\\r\\n        );\\r\\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\\r\\n\\r\\n        require(\\r\\n            !_executedProposals[nonceAndID][dataHash],\\r\\n            \\\"proposal already executed\\\"\\r\\n        );\\r\\n        require(destinationChainID == _chainID, \\\"ChainID Incorrect\\\");\\r\\n\\r\\n        _executedProposals[nonceAndID][dataHash] = true;\\r\\n\\r\\n        if (resourceID == _nativeResourceID) {\\r\\n            recipientAddress.transfer(amount);\\r\\n        } else {\\r\\n            address handler = _resourceIDToHandlerAddress[resourceID];\\r\\n            require(handler != address(0), \\\"resourceID not mapped to handler\\\");\\r\\n\\r\\n            IDepositExecute depositHandler = IDepositExecute(handler);\\r\\n            depositHandler.executeProposal(\\r\\n                resourceID,\\r\\n                recipientAddress,\\r\\n                amount,\\r\\n                params\\r\\n            );\\r\\n        }\\r\\n\\r\\n        emit ProposalEvent(\\r\\n            originChainID,\\r\\n            destinationChainID,\\r\\n            recipientAddress,\\r\\n            amount,\\r\\n            depositNonce,\\r\\n            ProposalStatus.Executed,\\r\\n            resourceID,\\r\\n            dataHash\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n        @notice to be called if owner wants to collect fees\\r\\n        @dev can only be called by owner\\r\\n        @param amount will be trasnfered to owner if contract balace is higher or equal to amount\\r\\n    */\\r\\n    function adminCollectFees(address payable recipient, uint256 amount) external onlyOwner {\\r\\n        uint256 amountToTransfer = amount < address(this).balance\\r\\n            ? amount\\r\\n            : address(this).balance;\\r\\n        recipient.transfer(amountToTransfer);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n        @notice to deposit native token to the contract\\r\\n        @dev to be called by admin\\r\\n    */\\r\\n    function depositFunds() external payable onlyOwner {}\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/UpgradableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity >=0.6.0 <0.8.0;\\r\\n\\r\\nimport \\\"../utils/Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract UpgradableOwnable is Context {\\r\\n    address private _owner;\\r\\n    bool private _isInitialised;\\r\\n\\r\\n    event OwnershipTransferred(\\r\\n        address indexed previousOwner,\\r\\n        address indexed newOwner\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n     function ownableInit(address owner) public {\\r\\n       require(!_isInitialised);\\r\\n        _owner = owner;\\r\\n        _isInitialised = true;\\r\\n        emit OwnershipTransferred(address(0), owner);\\r\\n     }\\r\\n\\r\\n     modifier isInitisalised() {\\r\\n       require(_isInitialised);\\r\\n       _;\\r\\n     }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"sender should be owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        emit OwnershipTransferred(_owner, address(0));\\r\\n        _owner = address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner)\\r\\n        public\\r\\n        virtual\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(newOwner != address(0));\\r\\n        emit OwnershipTransferred(_owner, newOwner);\\r\\n        _owner = newOwner;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n/**\\r\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\r\\n * checks.\\r\\n *\\r\\n * note that this is a stripped down version of open zeppelin's safemath\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\r\\n */\\r\\n\\r\\ncontract SafeMathContract {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) public pure returns (uint256) {\\r\\n        return _sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity's `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b <= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.6.0;\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which allows children to implement an emergency stop\\r\\n * mechanism that can be triggered by an authorized account.\\r\\n *\\r\\n * This is a stripped down version of Open zeppelin's Pausable contract.\\r\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\\r\\n *\\r\\n */\\r\\ncontract Pausable {\\r\\n    /**\\r\\n     * @dev Emitted when the pause is triggered by `account`.\\r\\n     */\\r\\n    event Paused(address account);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the pause is lifted by `account`.\\r\\n     */\\r\\n    event Unpaused(address account);\\r\\n\\r\\n    bool private _paused;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if the contract is paused, and false otherwise.\\r\\n     */\\r\\n    function paused() public view returns (bool) {\\r\\n        return _paused;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenNotPaused() {\\r\\n        _whenNotPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _whenNotPaused() private view {\\r\\n        require(!_paused, \\\"Pausable: paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    modifier whenPaused() {\\r\\n        _whenPaused();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function _whenPaused() private view {\\r\\n        require(_paused, \\\"Pausable: not paused\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Triggers stopped state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must not be paused.\\r\\n     */\\r\\n    function _pause() internal virtual whenNotPaused {\\r\\n        _paused = true;\\r\\n        emit Paused(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns to normal state.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The contract must be paused.\\r\\n     */\\r\\n    function _unpause() internal virtual whenPaused {\\r\\n        _paused = false;\\r\\n        emit Unpaused(msg.sender);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERCHandler.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\r\\n\\r\\n/**\\r\\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\\r\\n */\\r\\ninterface IERCHandler {\\r\\n    /**\\r\\n        @notice Correlates {resourceID} with {contractAddress}.\\r\\n        @param resourceID ResourceID to be used when making deposits.\\r\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\r\\n     */\\r\\n    function setResource(bytes32 resourceID, address contractAddress) external;\\r\\n    /**\\r\\n        @notice Marks {contractAddress} as mintable/burnable.\\r\\n        @param contractAddress Address of contract to be used when making or executing deposits.\\r\\n     */\\r\\n    function setBurnable(address contractAddress) external;\\r\\n    /**\\r\\n        @notice Used to manually release funds from ERC safes.\\r\\n        @param tokenAddress Address of token contract to release.\\r\\n        @param recipient Address to release tokens to.\\r\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\\r\\n     */\\r\\n    function withdraw(address tokenAddress, address recipient, uint256 amountOrTokenID) external;\\r\\n\\r\\n    /**\\r\\n        @notice Used to approve spending tokens.\\r\\n        @param resourceID ResourceID to be used for approval.\\r\\n        @param spender Spender address.\\r\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to approve.\\r\\n     */\\r\\n    function approve(bytes32 resourceID, address spender, uint256 amountOrTokenID) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IDepositExecute.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\r\\n\\r\\n/**\\r\\n    @title Interface for handler contracts that support deposits and deposit executions.\\r\\n    @author ChainSafe Systems.\\r\\n */\\r\\ninterface IDepositExecute {\\r\\n    /**\\r\\n        @notice It is intended that deposit are made using the Bridge contract.\\r\\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\\r\\n        @param depositNonce This value is generated as an ID by the Bridge contract.\\r\\n        @param depositer Address of account making the deposit in the Bridge contract.\\r\\n     */\\r\\n    function deposit(\\r\\n        bytes32 resourceID,\\r\\n        bytes8 destinationChainID,\\r\\n        uint64 depositNonce,\\r\\n        address depositer,\\r\\n        address recipientAddress,\\r\\n        uint256 amount,\\r\\n        bytes calldata params\\r\\n    ) external returns (address);\\r\\n\\r\\n    /**\\r\\n        @notice It is intended that proposals are executed by the Bridge contract.\\r\\n     */\\r\\n    function executeProposal(bytes32 resourceID, address recipientAddress, uint256 amount, bytes calldata params) external;\\r\\n    function getAddressFromResourceId(bytes32 resourceID) external view returns(address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/interfaces/IBridge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\r\\n\\r\\n/**\\r\\n    @title Interface for Bridge contract.\\r\\n    @author ChainSafe Systems.\\r\\n */\\r\\ninterface IBridge {\\r\\n    /**\\r\\n        @notice Exposing getter for {_chainID} instead of forcing the use of call.\\r\\n        @return uint8 The {_chainID} that is currently set for the Bridge contract.\\r\\n     */\\r\\n    function _chainID() external returns (uint8);\\r\\n\\r\\n    function internalDeposit(bytes8 destinationChainID,bytes32 resourceID,uint256 amount,address recipientAddress) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExtraFeeSupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum Bridge.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_backendSrvAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_chainID\",\"outputs\":[{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"name\":\"_depositCounts\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"name\":\"_depositRecords\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_executedProposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nativeResourceID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_resourceIDToHandlerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceIDOwner\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"resourceIDSpender\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"}],\"name\":\"adminApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"adminChangeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminCollectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminPauseTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBackendSrv\",\"type\":\"address\"}],\"name\":\"adminSetBackendSrv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"adminSetBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"}],\"name\":\"adminSetNativeResourceID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"adminSetResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminUnpauseTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToLA\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"params\",\"type\":\"bytes\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"handlers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"chainID\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initBackendSrvAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"}],\"name\":\"internalDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"ownableInit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"value\",\"type\":\"bool\"}],\"name\":\"setHandler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"sub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bridge", "CompilerVersion": "v0.6.4+commit.1dca32f3", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}