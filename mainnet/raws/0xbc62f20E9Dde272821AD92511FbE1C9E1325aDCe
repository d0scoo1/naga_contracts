{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"PandemicWarhols.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport \\\"@openzeppelin/contracts@3.4.0/token/ERC721/ERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/token/ERC721/IERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/utils/Arrays.sol\\\";\\nimport \\\"@openzeppelin/contracts@3.4.0/utils/ReentrancyGuard.sol\\\";\\nimport \\\"./CryptopunksData.sol\\\";\\nimport \\\"./BleachBackground.sol\\\";\\n\\ncontract PandemicWarhols is ERC721, Ownable, ReentrancyGuard {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 public constant MAX_TOKENS = 10000;\\n\\n    uint256 public constant MAX_TOKENS_PER_PURCHASE = 20;\\n\\n    uint256 private price = 80000000000000000; // 0.08 Ether\\n\\n    address public renderingContractAddress;\\n    address public backgroundContractAddress;\\n\\n    constructor() ERC721(\\\"Pandemic Warhols\\\", \\\"PWAR\\\") Ownable() {}\\n\\n    function setRenderingContractAddress(address _renderingContractAddress) public onlyOwner {\\n        renderingContractAddress = _renderingContractAddress;\\n    }\\n\\n    function setBackgroundContractAddress(address _backgroundContractAddress) public onlyOwner {\\n        backgroundContractAddress = _backgroundContractAddress;\\n    }\\n\\n    // Mint functionality\\n\\n    function mint(uint256 _count) public payable nonReentrant {\\n        uint256 totalSupply = totalSupply();\\n        require(_count > 0 && _count < MAX_TOKENS_PER_PURCHASE + 1);\\n        require(totalSupply + _count < MAX_TOKENS + 1);\\n        require(msg.value >= price.mul(_count));\\n        for(uint256 i = 0; i < _count; i++){\\n            _safeMint(msg.sender, totalSupply + i);\\n        }\\n    }\\n\\n    function setPrice(uint256 _newPrice) public onlyOwner() {\\n        price = _newPrice;\\n    }\\n\\n    function getPrice() public view returns (uint256){\\n        return price;\\n    }\\n\\n    function withdraw() public onlyOwner {\\n        uint256 balance = address(this).balance;\\n        payable(owner()).transfer(balance);\\n    }\\n\\n    function tokensByOwner(address _owner) external view returns(uint256[] memory ) {\\n        uint256 tokenCount = balanceOf(_owner);\\n        if (tokenCount == 0) {\\n            return new uint256[](0);\\n        } else {\\n            uint256[] memory result = new uint256[](tokenCount);\\n            uint256 index;\\n            for (index = 0; index < tokenCount; index++) {\\n                result[index] = tokenOfOwnerByIndex(_owner, index);\\n            }\\n            return result;\\n        }\\n    }\\n\\n    // Random function\\n\\n    function random(string memory input) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(input)));\\n    }\\n\\n    // Random punk\\n\\n    function randomPunk(uint256 tokenId) public view returns (uint16) {\\n        uint256 v = uint(keccak256(abi.encodePacked(\\\"a0867ed705a0\\\", block.timestamp, block.difficulty, toString(tokenId)))) % 10000;\\n        uint16 original = uint16(v);\\n        return original;\\n    }\\n\\n    // Background color\\n\\n    function backgroundColor(uint256 tokenId) private view returns (string memory) {\\n\\n      string[32] memory r;\\n      string[32] memory s = [\\\"1\\\", \\\"6\\\", \\\"3\\\", \\\"9\\\", \\\"c\\\", \\\"4\\\", \\\"b\\\", \\\"d\\\", \\\"e\\\", \\\"8\\\", \\\"5\\\", \\\"0\\\", \\\"a\\\", \\\"f\\\", \\\"2\\\", \\\"7\\\", \\\"b\\\", \\\"7\\\", \\\"5\\\", \\\"1\\\", \\\"8\\\", \\\"d\\\", \\\"2\\\", \\\"a\\\", \\\"6\\\", \\\"c\\\", \\\"4\\\", \\\"f\\\", \\\"9\\\", \\\"0\\\", \\\"e\\\", \\\"3\\\"];\\n\\n      uint l = s.length;\\n      uint i;\\n      string memory t;\\n\\n      while (l > 0) {\\n          uint256 v = random(string(abi.encodePacked(\\\"f09ceaa019e6\\\", block.timestamp, block.difficulty, toString(tokenId))));\\n          i = v % l--;\\n          t = s[l];\\n          s[l] = s[i];\\n          s[i] = t;\\n      }\\n\\n      r = s;\\n\\n      string memory m = r[16];\\n      string memory f = \\\"f\\\";\\n      string memory o = \\\"0\\\";\\n      string memory j;\\n\\n      if (keccak256(bytes(m)) == keccak256(bytes(f))) {\\n          j = \\\"ffffff\\\";\\n      } else if (keccak256(bytes(m)) == keccak256(bytes(o))) {\\n          j = \\\"000000\\\";\\n      } else {\\n          j = string(abi.encodePacked(r[5],r[11],r[7],r[4],r[10],r[15]));\\n      }\\n\\n      return j;\\n\\n    }\\n\\n    // Make Attributes\\n\\n    function makeAttributes(uint256 tokenId) private view returns (string memory) {\\n\\n        string[2] memory traits;\\n        string memory originalPunk = toString(randomPunk(tokenId));\\n\\n        traits[0] = string(abi.encodePacked('{\\\"trait_type\\\":\\\"Background Color: #\\\",\\\"value\\\":\\\"', backgroundColor(tokenId), '\\\"}'));\\n        traits[1] = string(abi.encodePacked('{\\\"trait_type\\\":\\\"Original Punk: #\\\",\\\"value\\\":\\\"', originalPunk, '\\\"}'));\\n\\n        string memory attributes = string(abi.encodePacked(traits[0], ',', traits[1]));\\n\\n        return attributes;\\n    }\\n\\n    function replaceValue(string memory svg,uint256 position, string memory replace) internal pure returns (string memory) {\\n        string memory t = _stringReplace(svg,position,replace);\\n        return t;\\n    }\\n\\n    function getBleach(uint256 tokenId) public view returns (string memory) {\\n\\n        BleachBackground bleachBackground = BleachBackground(backgroundContractAddress);\\n\\n        uint16 t = uint16(tokenId);\\n\\n        string memory b = bleachBackground.getBleach(t);\\n        return b;\\n    }\\n\\n\\n    function getPlain(uint256 tokenId) public view returns (string memory) {\\n\\n        CryptopunksData cryptopunksData = CryptopunksData(renderingContractAddress); // Running\\n\\n        uint16 t = randomPunk(tokenId);\\n\\n        string memory punkSvg = cryptopunksData.punkImageSvg(t); // Running\\n\\n        // Add replacement values\\n        string[24] memory r = [\\\"<\\\",\\\"s\\\",\\\"v\\\",\\\"g\\\",\\\">\\\",\\\"<\\\",\\\"r\\\",\\\"e\\\",\\\"c\\\",\\\"t\\\",\\\">\\\",\\\"<\\\",\\\"/\\\",\\\"r\\\",\\\"e\\\",\\\"c\\\",\\\"t\\\",\\\">\\\",\\\"<\\\",\\\"/\\\",\\\"s\\\",\\\"v\\\",\\\"g\\\",\\\">\\\"];\\n\\n        string memory a = replaceValue(punkSvg,0,r[0]);\\n        a = replaceValue(a,1,r[1]);\\n        a = replaceValue(a,2,r[2]);\\n        a = replaceValue(a,3,r[3]);\\n        a = replaceValue(a,4,r[4]);\\n        a = replaceValue(a,5,r[5]);\\n        a = replaceValue(a,6,r[6]);\\n        a = replaceValue(a,7,r[7]);\\n        a = replaceValue(a,8,r[8]);\\n        a = replaceValue(a,9,r[9]);\\n        a = replaceValue(a,10,r[10]);\\n        a = replaceValue(a,11,r[11]);\\n        a = replaceValue(a,12,r[12]);\\n        a = replaceValue(a,13,r[13]);\\n        a = replaceValue(a,14,r[14]);\\n        a = replaceValue(a,15,r[15]);\\n        a = replaceValue(a,16,r[16]);\\n        a = replaceValue(a,17,r[17]);\\n        a = replaceValue(a,18,r[18]);\\n        a = replaceValue(a,19,r[19]);\\n        a = replaceValue(a,20,r[20]);\\n        a = replaceValue(a,21,r[21]);\\n        a = replaceValue(a,22,r[22]);\\n        a = replaceValue(a,23,r[23]);\\n\\n        return a;\\n\\n    }\\n\\n    function getDescription(uint256 tokenId) public view returns (string memory) {\\n\\n        string memory description;\\n        string memory a = \\\"We create and perceive our world simultaneously. And our mind does this so well that we don't even know that it's happening.\\\";\\n        string memory b = \\\"You create the world of the dream. We bring the subject into that dream and they fill it with their subconcious.\\\";\\n        string memory c = \\\"Well, dreams they feel real while we're in them, right? It's only when we wake up that we realize something was actually strange?\\\";\\n        string memory d = \\\"You never really remember the beginning of a dream, do you? You always wind up right in the middle of what's going on.\\\";\\n\\n        uint256 v = uint(keccak256(abi.encodePacked(\\\"a70c1946af4f\\\", block.timestamp, block.difficulty, toString(tokenId)))) % 4;\\n\\n        if (v == 0) {\\n            description = a;\\n        } else if (v == 1) {\\n            description = b;\\n        } else if (v == 2) {\\n            description = c;\\n        } else {\\n            description = d;\\n        }\\n\\n        return description;\\n\\n    }\\n\\n    function tokenURI(uint256 tokenId) override public view returns (string memory) {\\n\\n        string[12] memory p;\\n\\n        p[0] = '<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 600 600\\\"><defs><pattern id=\\\"bleach\\\" x=\\\"0\\\" y=\\\"0\\\" width=\\\"0.125\\\" height=\\\"0.125\\\"><image x=\\\"0\\\" y=\\\"0\\\" width=\\\"75\\\" height=\\\"75\\\" xlink:href=\\\"';\\n        \\n        p[1] = getBleach(tokenId);\\n\\n        p[2] = '\\\" /></pattern></defs><rect viewBox=\\\"0 0 600 600\\\" width=\\\"600\\\" height=\\\"600\\\" fill=\\\"#';\\n\\n        p[3] = backgroundColor(tokenId);\\n\\n        p[4] = '\\\" /><rect viewBox=\\\"0 0 600 600\\\" width=\\\"600\\\" height=\\\"600\\\" fill=\\\"url(#bleach)\\\" /><svg x=\\\"60\\\" y=\\\"0\\\" width=\\\"600\\\" height=\\\"600\\\" viewBox=\\\"0 0 600 600\\\">';\\n\\n        p[5] = getPlain(tokenId);\\n\\n        p[6] = '</svg>';\\n\\n        p[7] = getPlain(tokenId);\\n\\n        p[8] = '<svg x=\\\"-60\\\" y=\\\"0\\\" width=\\\"600\\\" height=\\\"600\\\" viewBox=\\\"0 0 600 600\\\">';\\n\\n        p[9] = getPlain(tokenId);\\n\\n        p[10] = '</svg></svg>';\\n\\n        string memory o = string(abi.encodePacked(p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]));\\n        o = string(abi.encodePacked(o, p[9], p[10]));\\n\\n        string memory json = Base64.encode(bytes(string(abi.encodePacked('{\\\"name\\\": \\\"Pandemic Warhol #', toString(tokenId), '\\\", \\\"description\\\": \\\"', getDescription(tokenId), '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,', Base64.encode(bytes(o)), '\\\", \\\"attributes\\\": \\\\x5B ', makeAttributes(tokenId), ' \\\\x5D}'))));\\n        o = string(abi.encodePacked('data:application/json;base64,', json));\\n\\n        return o;\\n    }\\n\\n    // to String utility\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT license\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    // Replace string utility\\n\\n    function _stringReplace(string memory _string, uint256 _pos, string memory _letter) internal pure returns (string memory) {\\n        bytes memory _stringBytes = bytes(_string);\\n        bytes memory result = new bytes(_stringBytes.length);\\n\\n        for(uint i = 0; i < _stringBytes.length; i++) {\\n                result[i] = _stringBytes[i];\\n                if(i==_pos)\\n                result[i]=bytes(_letter)[0];\\n            }\\n            return  string(result);\\n    }\\n\\n}\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE = \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\\n                out := shl(8, out)\\n                out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\"\r\n    },\r\n    \"BleachBackground.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\n\\ncontract BleachBackground {\\n\\n    function getBleach(uint16 index) external pure returns (string memory bleach) {\\n\\n        // 400px\\n\\n        bleach = string(abi.encodePacked('data:image/png;base64,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')); \\n\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"CryptopunksData.sol\": {\r\n      \"content\": \"/**\\n *Submitted for verification at Etherscan.io on 2021-08-18\\n*/\\n\\npragma solidity 0.7.6;\\n\\n/**\\n *   ____                  _                          _          ____        _\\n *  / ___|_ __ _   _ _ __ | |_ ___  _ __  _   _ _ __ | | _____  |  _ \\\\  __ _| |_ __ _\\n * | |   | '__| | | | '_ \\\\| __/ _ \\\\| '_ \\\\| | | | '_ \\\\| |/ / __| | | | |/ _` | __/ _` |\\n * | |___| |  | |_| | |_) | || (_) | |_) | |_| | | | |   <\\\\__ \\\\ | |_| | (_| | || (_| |\\n *  \\\\____|_|   \\\\__, | .__/ \\\\__\\\\___/| .__/ \\\\__,_|_| |_|_|\\\\_\\\\___/ |____/ \\\\__,_|\\\\__\\\\__,_|\\n *             |___/|_|            |_|\\n *\\n * On-chain Cryptopunk images and attributes, by Larva Labs.\\n *\\n * This contract holds the image and attribute data for the Cryptopunks on-chain.\\n * The Cryptopunk images are available as raw RGBA pixels, or in SVG format.\\n * The punk attributes are available as a comma-separated list.\\n * Included in the attribute list is the head type (various color male and female heads,\\n * plus the rare zombie, ape, and alien types).\\n *\\n * This contract was motivated by community members snowfro and 0xdeafbeef, including a proof-of-concept contract created by 0xdeafbeef.\\n * Without their involvement, the project would not have come to fruition.\\n */\\ncontract CryptopunksData {\\n\\n    string internal constant SVG_HEADER = 'data:image/svg+xml;utf8,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" version=\\\"1.2\\\" viewBox=\\\"0 0 24 24\\\">';\\n    string internal constant SVG_FOOTER = '</svg>';\\n\\n    bytes private palette;\\n    mapping(uint8 => bytes) private assets;\\n    mapping(uint8 => string) private assetNames;\\n    mapping(uint64 => uint32) private composites;\\n    mapping(uint8 => bytes) private punks;\\n\\n    address payable internal deployer;\\n    bool private contractSealed = false;\\n\\n    modifier onlyDeployer() {\\n        require(msg.sender == deployer, \\\"Only deployer.\\\");\\n        _;\\n    }\\n\\n    modifier unsealed() {\\n        require(!contractSealed, \\\"Contract sealed.\\\");\\n        _;\\n    }\\n\\n    constructor() {\\n        deployer = msg.sender;\\n    }\\n\\n    function setPalette(bytes memory _palette) external onlyDeployer unsealed {\\n        palette = _palette;\\n    }\\n\\n    function addAsset(uint8 index, bytes memory encoding, string memory name) external onlyDeployer unsealed {\\n        assets[index] = encoding;\\n        assetNames[index] = name;\\n    }\\n\\n    function addComposites(uint64 key1, uint32 value1, uint64 key2, uint32 value2, uint64 key3, uint32 value3, uint64 key4, uint32 value4) external onlyDeployer unsealed {\\n        composites[key1] = value1;\\n        composites[key2] = value2;\\n        composites[key3] = value3;\\n        composites[key4] = value4;\\n    }\\n\\n    function addPunks(uint8 index, bytes memory _punks) external onlyDeployer unsealed {\\n        punks[index] = _punks;\\n    }\\n\\n    function sealContract() external onlyDeployer unsealed {\\n        contractSealed = true;\\n    }\\n\\n    /**\\n     * The Cryptopunk image for the given index.\\n     * The image is represented in a row-major byte array where each set of 4 bytes is a pixel in RGBA format.\\n     * @param index the punk index, 0 <= index < 10000\\n     */\\n    function punkImage(uint16 index) public view returns (bytes memory) {\\n        require(index >= 0 && index < 10000);\\n        bytes memory pixels = new bytes(2304);\\n        for (uint j = 0; j < 8; j++) {\\n            uint8 asset = uint8(punks[uint8(index / 100)][(index % 100) * 8 + j]);\\n            if (asset > 0) {\\n                bytes storage a = assets[asset];\\n                uint n = a.length / 3;\\n                for (uint i = 0; i < n; i++) {\\n                    uint[4] memory v = [\\n                        uint(uint8(a[i * 3]) & 0xF0) >> 4,\\n                        uint(uint8(a[i * 3]) & 0xF),\\n                        uint(uint8(a[i * 3 + 2]) & 0xF0) >> 4,\\n                        uint(uint8(a[i * 3 + 2]) & 0xF)\\n                    ];\\n                    for (uint dx = 0; dx < 2; dx++) {\\n                        for (uint dy = 0; dy < 2; dy++) {\\n                            uint p = ((2 * v[1] + dy) * 24 + (2 * v[0] + dx)) * 4;\\n                            if (v[2] & (1 << (dx * 2 + dy)) != 0) {\\n                                bytes4 c = composite(a[i * 3 + 1],\\n                                        pixels[p],\\n                                        pixels[p + 1],\\n                                        pixels[p + 2],\\n                                        pixels[p + 3]\\n                                    );\\n                                pixels[p] = c[0];\\n                                pixels[p+1] = c[1];\\n                                pixels[p+2] = c[2];\\n                                pixels[p+3] = c[3];\\n                            } else if (v[3] & (1 << (dx * 2 + dy)) != 0) {\\n                                pixels[p] = 0;\\n                                pixels[p+1] = 0;\\n                                pixels[p+2] = 0;\\n                                pixels[p+3] = 0xFF;\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return pixels;\\n    }\\n\\n    /**\\n     * The Cryptopunk image for the given index, in SVG format.\\n     * In the SVG, each \\\"pixel\\\" is represented as a 1x1 rectangle.\\n     * @param index the punk index, 0 <= index < 10000\\n     */\\n    function punkImageSvg(uint16 index) external view returns (string memory svg) {\\n        bytes memory pixels = punkImage(index);\\n        svg = string(abi.encodePacked(SVG_HEADER));\\n        bytes memory buffer = new bytes(8);\\n        for (uint y = 0; y < 24; y++) {\\n            for (uint x = 0; x < 24; x++) {\\n                uint p = (y * 24 + x) * 4;\\n                if (uint8(pixels[p + 3]) > 0) {\\n                    for (uint i = 0; i < 4; i++) {\\n                        uint8 value = uint8(pixels[p + i]);\\n                        buffer[i * 2 + 1] = _HEX_SYMBOLS[value & 0xf];\\n                        value >>= 4;\\n                        buffer[i * 2] = _HEX_SYMBOLS[value & 0xf];\\n                    }\\n                    svg = string(abi.encodePacked(svg,\\n                        '<rect x=\\\"', toString(x), '\\\" y=\\\"', toString(y),'\\\" width=\\\"1\\\" height=\\\"1\\\" shape-rendering=\\\"crispEdges\\\" fill=\\\"#', string(buffer),'\\\"/>'));\\n                }\\n            }\\n        }\\n        svg = string(abi.encodePacked(svg, SVG_FOOTER));\\n    }\\n\\n    /**\\n     * The Cryptopunk attributes for the given index.\\n     * The attributes are a comma-separated list in UTF-8 string format.\\n     * The first entry listed is not technically an attribute, but the \\\"head type\\\" of the Cryptopunk.\\n     * @param index the punk index, 0 <= index < 10000\\n     */\\n    function punkAttributes(uint16 index) external view returns (string memory text) {\\n        require(index >= 0 && index < 10000);\\n        uint8 cell = uint8(index / 100);\\n        uint offset = (index % 100) * 8;\\n        for (uint j = 0; j < 8; j++) {\\n            uint8 asset = uint8(punks[cell][offset + j]);\\n            if (asset > 0) {\\n                if (j > 0) {\\n                    text = string(abi.encodePacked(text, \\\", \\\", assetNames[asset]));\\n                } else {\\n                    text = assetNames[asset];\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    function composite(byte index, byte yr, byte yg, byte yb, byte ya) internal view returns (bytes4 rgba) {\\n        uint x = uint(uint8(index)) * 4;\\n        uint8 xAlpha = uint8(palette[x + 3]);\\n        if (xAlpha == 0xFF) {\\n            rgba = bytes4(uint32(\\n                    (uint(uint8(palette[x])) << 24) |\\n                    (uint(uint8(palette[x+1])) << 16) |\\n                    (uint(uint8(palette[x+2])) << 8) |\\n                    xAlpha\\n                ));\\n        } else {\\n            uint64 key =\\n                (uint64(uint8(palette[x])) << 56) |\\n                (uint64(uint8(palette[x + 1])) << 48) |\\n                (uint64(uint8(palette[x + 2])) << 40) |\\n                (uint64(xAlpha) << 32) |\\n                (uint64(uint8(yr)) << 24) |\\n                (uint64(uint8(yg)) << 16) |\\n                (uint64(uint8(yb)) << 8) |\\n                (uint64(uint8(ya)));\\n            rgba = bytes4(composites[key]);\\n        }\\n    }\\n\\n    //// String stuff from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/Arrays.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../math/Math.sol\\\";\\n\\n/**\\n * @dev Collection of functions related to array types.\\n */\\nlibrary Arrays {\\n   /**\\n     * @dev Searches a sorted `array` and returns the first index that contains\\n     * a value greater or equal to `element`. If no such index exists (i.e. all\\n     * values in the array are strictly less than `element`), the array length is\\n     * returned. Time complexity O(log n).\\n     *\\n     * `array` is expected to be sorted in ascending order, and to contain no\\n     * repeated elements.\\n     */\\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\\n        if (array.length == 0) {\\n            return 0;\\n        }\\n\\n        uint256 low = 0;\\n        uint256 high = array.length;\\n\\n        while (low < high) {\\n            uint256 mid = Math.average(low, high);\\n\\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\\n            // because Math.average rounds down (it does integer division with truncation).\\n            if (array[mid] > element) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\\n        if (low > 0 && array[low - 1] == element) {\\n            return low - 1;\\n        } else {\\n            return low;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow, so we distribute\\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/token/ERC721/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Metadata.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"../../introspection/ERC165.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/EnumerableSet.sol\\\";\\nimport \\\"../../utils/EnumerableMap.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\n\\n/**\\n * @title ERC721 Non-Fungible Token Standard basic implementation\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using Strings for uint256;\\n\\n    // Equals to `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\\n\\n    // Mapping from holder address to their (enumerable) set of owned tokens\\n    mapping (address => EnumerableSet.UintSet) private _holderTokens;\\n\\n    // Enumerable mapping from token ids to their owners\\n    EnumerableMap.UintToAddressMap private _tokenOwners;\\n\\n    // Mapping from token ID to approved address\\n    mapping (uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Optional mapping for token URIs\\n    mapping (uint256 => string) private _tokenURIs;\\n\\n    // Base URI\\n    string private _baseURI;\\n\\n    /*\\n     *     bytes4(keccak256('balanceOf(address)')) == 0x70a08231\\n     *     bytes4(keccak256('ownerOf(uint256)')) == 0x6352211e\\n     *     bytes4(keccak256('approve(address,uint256)')) == 0x095ea7b3\\n     *     bytes4(keccak256('getApproved(uint256)')) == 0x081812fc\\n     *     bytes4(keccak256('setApprovalForAll(address,bool)')) == 0xa22cb465\\n     *     bytes4(keccak256('isApprovedForAll(address,address)')) == 0xe985e9c5\\n     *     bytes4(keccak256('transferFrom(address,address,uint256)')) == 0x23b872dd\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256)')) == 0x42842e0e\\n     *     bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) == 0xb88d4fde\\n     *\\n     *     => 0x70a08231 ^ 0x6352211e ^ 0x095ea7b3 ^ 0x081812fc ^\\n     *        0xa22cb465 ^ 0xe985e9c5 ^ 0x23b872dd ^ 0x42842e0e ^ 0xb88d4fde == 0x80ac58cd\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\\n\\n    /*\\n     *     bytes4(keccak256('name()')) == 0x06fdde03\\n     *     bytes4(keccak256('symbol()')) == 0x95d89b41\\n     *     bytes4(keccak256('tokenURI(uint256)')) == 0xc87b56dd\\n     *\\n     *     => 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd == 0x5b5e139f\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\\n\\n    /*\\n     *     bytes4(keccak256('totalSupply()')) == 0x18160ddd\\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) == 0x2f745c59\\n     *     bytes4(keccak256('tokenByIndex(uint256)')) == 0x4f6ccce7\\n     *\\n     *     => 0x18160ddd ^ 0x2f745c59 ^ 0x4f6ccce7 == 0x780e9d63\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n\\n        // register the supported interfaces to conform to ERC721 via ERC165\\n        _registerInterface(_INTERFACE_ID_ERC721);\\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _holderTokens[owner].length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        return _tokenOwners.get(tokenId, \\\"ERC721: owner query for nonexistent token\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory _tokenURI = _tokenURIs[tokenId];\\n        string memory base = baseURI();\\n\\n        // If there is no base URI, return the token URI.\\n        if (bytes(base).length == 0) {\\n            return _tokenURI;\\n        }\\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\\n        if (bytes(_tokenURI).length > 0) {\\n            return string(abi.encodePacked(base, _tokenURI));\\n        }\\n        // If there is a baseURI but no tokenURI, concatenate the tokenID to the baseURI.\\n        return string(abi.encodePacked(base, tokenId.toString()));\\n    }\\n\\n    /**\\n    * @dev Returns the base URI set via {_setBaseURI}. This will be\\n    * automatically added as a prefix in {tokenURI} to each token's URI, or\\n    * to the token ID if no specific URI is set for that token ID.\\n    */\\n    function baseURI() public view virtual returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        return _holderTokens[owner].at(index);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        // _tokenOwners are indexed by tokenIds, so .length() returns the number of tokenIds\\n        return _tokenOwners.length();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        (uint256 tokenId, ) = _tokenOwners.at(index);\\n        return tokenId;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(_msgSender() == owner || ERC721.isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenOwners.contains(tokenId);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || ERC721.isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     d*\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(address to, uint256 tokenId, bytes memory _data) internal virtual {\\n        _mint(to, tokenId);\\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId); // internal owner\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        // Clear metadata (if any)\\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\\n            delete _tokenURIs[tokenId];\\n        }\\n\\n        _holderTokens[owner].remove(tokenId);\\n\\n        _tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\"); // internal owner\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _holderTokens[from].remove(tokenId);\\n        _holderTokens[to].add(tokenId);\\n\\n        _tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI set of nonexistent token\\\");\\n        _tokenURIs[tokenId] = _tokenURI;\\n    }\\n\\n    /**\\n     * @dev Internal function to set the base URI for all token IDs. It is\\n     * automatically added as a prefix to the value returned in {tokenURI},\\n     * or to the token ID if {tokenURI} is empty.\\n     */\\n    function _setBaseURI(string memory baseURI_) internal virtual {\\n        _baseURI = baseURI_;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\\n        private returns (bool)\\n    {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n        bytes memory returndata = to.functionCall(abi.encodeWithSelector(\\n            IERC721Receiver(to).onERC721Received.selector,\\n            _msgSender(),\\n            from,\\n            tokenId,\\n            _data\\n        ), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n        bytes4 retval = abi.decode(returndata, (bytes4));\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) private {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId); // internal owner\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"../../introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\\n      *\\n      * Requirements:\\n      *\\n      * - `from` cannot be the zero address.\\n      * - `to` cannot be the zero address.\\n      * - `tokenId` token must exist and be owned by `from`.\\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n      *\\n      * Emits a {Transfer} event.\\n      */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        uint256 index = digits - 1;\\n        temp = value;\\n        while (temp != 0) {\\n            buffer[index--] = bytes1(uint8(48 + temp % 10));\\n            temp /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        // Storage of map keys and values\\n        MapEntry[] _entries;\\n\\n        // Position of the entry defined by a key in the `entries` array, plus 1\\n        // because index 0 means a key is not in the map.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(Map storage map, bytes32 key, bytes32 value) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) { // Equivalent to !contains(map, key)\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            // The entry is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        // We read and store the key's index to prevent multiple reads from the same storage slot\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) { // Equivalent to contains(map, key)\\n            // To delete a key-value pair from the _entries array in O(1), we swap the entry to delete with the last one\\n            // in the array, and then remove the last entry (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = keyIndex - 1;\\n            uint256 lastIndex = map._entries.length - 1;\\n\\n            // When the entry to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            MapEntry storage lastEntry = map._entries[lastIndex];\\n\\n            // Move the last entry to the index where the entry to delete is\\n            map._entries[toDeleteIndex] = lastEntry;\\n            // Update the index for the moved entry\\n            map._indexes[lastEntry._key] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved entry was stored\\n            map._entries.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n   /**\\n    * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of entries inside the\\n    * array, and it may change when more entries are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        require(map._entries.length > index, \\\"EnumerableMap: index out of bounds\\\");\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        if (keyIndex == 0) return (false, 0); // Equivalent to contains(map, key)\\n        return (true, map._entries[keyIndex - 1]._value); // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, \\\"EnumerableMap: nonexistent key\\\"); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(Map storage map, bytes32 key, string memory errorMessage) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, errorMessage); // Equivalent to contains(map, key)\\n        return map._entries[keyIndex - 1]._value; // All indexes are 1-based\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the element stored at position `index` in the set. O(1).\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key, string memory errorMessage) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping (bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) { // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            // When the value to delete is the last one, the swap operation is unnecessary. However, since this occurs\\n            // so rarely, we still do the swap anyway to avoid the gas cost of adding an 'if' statement.\\n\\n            bytes32 lastvalue = set._values[lastIndex];\\n\\n            // Move the last value to the index where the value to delete is\\n            set._values[toDeleteIndex] = lastvalue;\\n            // Update the index for the moved value\\n            set._indexes[lastvalue] = toDeleteIndex + 1; // All indexes are 1-based\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        require(set._values.length > index, \\\"EnumerableSet: index out of bounds\\\");\\n        return set._values[index];\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n   /**\\n    * @dev Returns the value stored at position `index` in the set. O(1).\\n    *\\n    * Note that there are no guarantees on the ordering of values inside the\\n    * array, and it may change when more values are added or removed.\\n    *\\n    * Requirements:\\n    *\\n    * - `index` must be strictly less than {length}.\\n    */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /*\\n     * bytes4(keccak256('supportsInterface(bytes4)')) == 0x01ffc9a7\\n     */\\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\\n\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    constructor () internal {\\n        // Derived contracts need only register support for their own interfaces,\\n        // we register support for ERC165 itself here\\n        _registerInterface(_INTERFACE_ID_ERC165);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     *\\n     * Time complexity O(1), guaranteed to always use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/token/ERC721/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts@3.4.0/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TOKENS_PER_PURCHASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"backgroundContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getBleach\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPlain\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"randomPunk\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renderingContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_backgroundContractAddress\",\"type\":\"address\"}],\"name\":\"setBackgroundContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_renderingContractAddress\",\"type\":\"address\"}],\"name\":\"setRenderingContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PandemicWarhols", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}