{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface for checking active staked balance of a user.\r\n */\r\ninterface IBlubSource {\r\n  function getAccumulatedAmount(address staker) external view returns (uint256);\r\n}\r\n\r\n/**\r\n * @dev Interface for ERC-20 $BLUB functions that are required for in-game BLUB.\r\n */\r\ninterface ITradableBlub is IERC20 {\r\n  function _authorisedMint(address sender, uint256 amount) external;\r\n  function _authorisedBurn(address sender, uint256 amount) external;\r\n}\r\n\r\n/**\r\n * @dev Implementation of in-game BLUB.\r\n */\r\ncontract InGameBlub is ReentrancyGuard, Ownable {\r\n    IBlubSource public BlubSource;\r\n    ITradableBlub public tradableBlub;\r\n\r\n    uint256 public MAX_SUPPLY;\r\n    uint256 public constant MAX_TAX_VALUE = 100;\r\n\r\n    uint256 public spendTaxAmount;\r\n    uint256 public withdrawTaxAmount;\r\n\r\n    uint256 public taxesDistributed;\r\n    uint256 public activeTaxCollectedAmount;\r\n\r\n    bool public tokenCapSet;\r\n\r\n    bool public withdrawTaxCollectionStopped;\r\n    bool public spendTaxCollectionStopped;\r\n\r\n    bool public isPaused;\r\n    bool public isDepositPaused;\r\n    bool public isWithdrawPaused;\r\n    bool public isTransferPaused;\r\n\r\n    mapping (address => bool) private _isAuthorised;\r\n    address[] public authorisedLog;\r\n\r\n    mapping(address => uint256) public depositedAmount;\r\n    mapping(address => uint256) public spentAmount;\r\n\r\n    modifier onlyAuthorised {\r\n      require(_isAuthorised[_msgSender()], \"Not Authorised\");\r\n      _;\r\n    }\r\n\r\n    modifier whenNotPaused {\r\n      require(!isPaused, \"Transfers paused!\");\r\n      _;\r\n    }\r\n\r\n    event Withdraw(address indexed userAddress, uint256 amount, uint256 tax);\r\n    event Deposit(address indexed userAddress, uint256 amount);\r\n    event DepositFor(address indexed caller, address indexed userAddress, uint256 amount);\r\n    event Spend(address indexed caller, address indexed userAddress, uint256 amount, uint256 tax);\r\n    event ClaimTax(address indexed caller, address indexed userAddress, uint256 amount);\r\n    event InternalTransfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    constructor(address _source) {\r\n      _isAuthorised[_msgSender()] = true;\r\n      isPaused = true;\r\n      isTransferPaused = true;\r\n      isDepositPaused = true;\r\n      isWithdrawPaused = true;\r\n\r\n      withdrawTaxAmount = 25;\r\n      spendTaxAmount = 25;\r\n\r\n      BlubSource = IBlubSource(_source);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns current spendable balance of a specific user. This balance can be spent by user for other collections without\r\n    *      withdrawal to ERC-20 Blub OR can be withdrawn to ERC-20 Blub.\r\n    */\r\n    function getUserBalance(address user) public view returns (uint256) {\r\n      return (BlubSource.getAccumulatedAmount(user) + depositedAmount[user] - spentAmount[user]);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to deposit ERC-20 Blub to the game balance.\r\n    */\r\n    function depositBlub(uint256 amount) public nonReentrant whenNotPaused {\r\n      require(!isDepositPaused, \"Deposit Paused\");\r\n      require(tradableBlub.balanceOf(_msgSender()) >= amount, \"Insufficient balance\");\r\n\r\n      tradableBlub._authorisedBurn(_msgSender(), amount);\r\n      depositedAmount[_msgSender()] += amount;\r\n\r\n      emit Deposit(\r\n        _msgSender(),\r\n        amount\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function to withdraw game Blub to ERC-20 Blub.\r\n    */\r\n    function withdrawBlub(uint256 amount) public nonReentrant whenNotPaused {\r\n      require(!isWithdrawPaused, \"Withdraw Paused\");\r\n      require(getUserBalance(_msgSender()) >= amount, \"Insufficient balance\");\r\n      uint256 tax = withdrawTaxCollectionStopped ? 0 : (amount * withdrawTaxAmount) / 100;\r\n\r\n      spentAmount[_msgSender()] += amount;\r\n      activeTaxCollectedAmount += tax;\r\n      tradableBlub._authorisedMint(_msgSender(), (amount - tax));\r\n\r\n      emit Withdraw(\r\n        _msgSender(),\r\n        amount,\r\n        tax\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function to transfer game Blub from one account to another.\r\n    */\r\n    function transferBlub(address to, uint256 amount) public nonReentrant whenNotPaused {\r\n      require(!isTransferPaused, \"Transfer Paused\");\r\n      require(getUserBalance(_msgSender()) >= amount, \"Insufficient balance\");\r\n\r\n      spentAmount[_msgSender()] += amount;\r\n      depositedAmount[to] += amount;\r\n\r\n      emit InternalTransfer(\r\n        _msgSender(),\r\n        to,\r\n        amount\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function to spend user balance. Can be called by other authorised contracts. To be used for internal purchases of other NFTs, etc.\r\n    */\r\n    function spendBlub(address user, uint256 amount) external onlyAuthorised nonReentrant {\r\n      require(getUserBalance(user) >= amount, \"Insufficient balance\");\r\n      uint256 tax = spendTaxCollectionStopped ? 0 : (amount * spendTaxAmount) / 100;\r\n\r\n      spentAmount[user] += amount;\r\n      activeTaxCollectedAmount += tax;\r\n\r\n      emit Spend(\r\n        _msgSender(),\r\n        user,\r\n        amount,\r\n        tax\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function to deposit tokens to a user balance. Can be only called by an authorised contracts.\r\n    */\r\n    function depositBlubFor(address user, uint256 amount) public onlyAuthorised nonReentrant {\r\n      _depositBlubFor(user, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to distribute tokens to the user balances. Can be only called by an authorised users.\r\n    */\r\n    function distributeBlub(address[] memory user, uint256[] memory amount) public onlyAuthorised nonReentrant {\r\n      require(user.length == amount.length, \"Wrong arrays passed\");\r\n\r\n      for (uint256 i; i < user.length; i++) {\r\n        _depositBlubFor(user[i], amount[i]);\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @dev Function to distribute a constant amount of tokens to the user balances. Can be only called by an authorised users.\r\n    */\r\n    function distributeBlubConstant(address[] memory user, uint256 amount) public onlyAuthorised nonReentrant {\r\n      for (uint256 i; i < user.length; i++) {\r\n        _depositBlubFor(user[i], amount);\r\n      }\r\n    }\r\n\r\n    function _depositBlubFor(address user, uint256 amount) internal {\r\n      require(user != address(0), \"Deposit to 0 address\");\r\n      depositedAmount[user] += amount;\r\n\r\n      emit DepositFor(\r\n        _msgSender(),\r\n        user,\r\n        amount\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function to mint tokens to a user balance. Can be only called by an authorised contracts.\r\n    */\r\n    function mintFor(address user, uint256 amount) external onlyAuthorised nonReentrant {\r\n      if (tokenCapSet) require(tradableBlub.totalSupply() + amount <= MAX_SUPPLY, \"You try to mint more than max supply\");\r\n      tradableBlub._authorisedMint(user, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Function to claim tokens from the tax accumulated pot. Can be only called by an authorised contracts.\r\n    */\r\n    function claimBlubTax(address user, uint256 amount) public onlyAuthorised nonReentrant {\r\n      require(activeTaxCollectedAmount >= amount, \"Insufficiend tax balance\");\r\n\r\n      activeTaxCollectedAmount -= amount;\r\n      depositedAmount[user] += amount;\r\n      taxesDistributed += amount;\r\n\r\n      emit ClaimTax(\r\n        _msgSender(),\r\n        user,\r\n        amount\r\n      );\r\n    }\r\n\r\n    /**\r\n    * @dev Function returns maxSupply set by admin. By default returns error (Max supply is not set).\r\n    */\r\n    function getMaxSupply() public view returns (uint256) {\r\n      require(tokenCapSet, \"Max supply is not set\");\r\n      return MAX_SUPPLY;\r\n    }\r\n\r\n    /*\r\n      ADMIN FUNCTIONS\r\n    */\r\n\r\n    /**\r\n    * @dev Function allows admin to set total supply of Blub token.\r\n    */\r\n    function setTokenCap(uint256 newTokenCap) public onlyOwner {\r\n      require(tradableBlub.totalSupply() < newTokenCap, \"Value is smaller than the number of existing tokens\");\r\n      require(!tokenCapSet, \"Token cap has been already set\");\r\n\r\n      MAX_SUPPLY = newTokenCap;\r\n    }\r\n\r\n    /**\r\n    * @dev Function stops any further minting of Blub.\r\n    */\r\n    function lockTokenCapForever(bool _lock) public onlyOwner {\r\n      require(!tokenCapSet, \"Token cap has been locked\");\r\n      tokenCapSet = _lock;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin add authorised address. The function also logs what addresses were authorised for transparancy.\r\n    */\r\n    function authorise(address addressToAuth) public onlyOwner {\r\n      _isAuthorised[addressToAuth] = true;\r\n      authorisedLog.push(addressToAuth);\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin add unauthorised address.\r\n    */\r\n    function unauthorise(address addressToUnAuth) public onlyOwner {\r\n      _isAuthorised[addressToUnAuth] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin update the address of staking address.\r\n    */\r\n    function changeBlubSourceContract(address _source) public onlyOwner {\r\n      BlubSource = IBlubSource(_source);\r\n      authorise(_source);\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin update the address of staking address.\r\n    */\r\n    function changeTradableBlubContract(address _newTradableBlub) public onlyOwner {\r\n      tradableBlub = ITradableBlub(_newTradableBlub);\r\n      authorise(_newTradableBlub);\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to update limit of tax on withdraw.\r\n    */\r\n    function updateWithdrawTaxAmount(uint256 _taxAmount) public onlyOwner {\r\n      require(_taxAmount < MAX_TAX_VALUE, \"Wrong value passed\");\r\n      withdrawTaxAmount = _taxAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to update tax amount on spend.\r\n    */\r\n    function updateSpendTaxAmount(uint256 _taxAmount) public onlyOwner {\r\n      require(_taxAmount < MAX_TAX_VALUE, \"Wrong value passed\");\r\n      spendTaxAmount = _taxAmount;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to stop tax collection on withdraw.\r\n    */\r\n    function stopTaxCollectionOnWithdraw(bool _stop) public onlyOwner {\r\n      withdrawTaxCollectionStopped = _stop;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to stop tax collection on spend.\r\n    */\r\n    function stopTaxCollectionOnSpend(bool _stop) public onlyOwner {\r\n      spendTaxCollectionStopped = _stop;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to pause all in game Blub transfactions.\r\n    */\r\n    function pauseGameBlub(bool _pause) public onlyOwner {\r\n      isPaused = _pause;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to pause in game Blub transfers.\r\n    */\r\n    function pauseTransfers(bool _pause) public onlyOwner {\r\n      isTransferPaused = _pause;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to pause in game Blub withdraw.\r\n    */\r\n    function pauseWithdraw(bool _pause) public onlyOwner {\r\n      isWithdrawPaused = _pause;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to pause in game Blub deposit.\r\n    */\r\n    function pauseDeposits(bool _pause) public onlyOwner {\r\n      isDepositPaused = _pause;\r\n    }\r\n\r\n    /**\r\n    * @dev Function allows admin to withdraw ETH accidentally dropped to the contract.\r\n    */\r\n    function rescue() external onlyOwner {\r\n      payable(owner()).transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DepositFor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"InternalTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"Spend\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BlubSource\",\"outputs\":[{\"internalType\":\"contract IBlubSource\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TAX_VALUE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeTaxCollectedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToAuth\",\"type\":\"address\"}],\"name\":\"authorise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authorisedLog\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_source\",\"type\":\"address\"}],\"name\":\"changeBlubSourceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newTradableBlub\",\"type\":\"address\"}],\"name\":\"changeTradableBlubContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimBlubTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositBlubFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amount\",\"type\":\"uint256[]\"}],\"name\":\"distributeBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"user\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeBlubConstant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDepositPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTransferPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isWithdrawPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_lock\",\"type\":\"bool\"}],\"name\":\"lockTokenCapForever\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseDeposits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseGameBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"pauseWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenCap\",\"type\":\"uint256\"}],\"name\":\"setTokenCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spendBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spendTaxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spendTaxCollectionStopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"spentAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stop\",\"type\":\"bool\"}],\"name\":\"stopTaxCollectionOnSpend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_stop\",\"type\":\"bool\"}],\"name\":\"stopTaxCollectionOnWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxesDistributed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenCapSet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradableBlub\",\"outputs\":[{\"internalType\":\"contract ITradableBlub\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addressToUnAuth\",\"type\":\"address\"}],\"name\":\"unauthorise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxAmount\",\"type\":\"uint256\"}],\"name\":\"updateSpendTaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxAmount\",\"type\":\"uint256\"}],\"name\":\"updateWithdrawTaxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBlub\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTaxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTaxCollectionStopped\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InGameBlub", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d665215893ce709b72951a816d157be616899cd2", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cbe2100812bd05b0288e1beb16347b05de5075c37ad243d8be2d345b578dc8c6"}]}