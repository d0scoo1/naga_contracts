{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// Sources flattened with hardhat v2.6.2 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/security/ReentrancyGuard.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/structs/EnumerableSet.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/risk/ICoverageDataProviderV2.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title ICoverageDataProviderV2\r\n * @author solace.fi\r\n * @notice Holds underwriting pool amounts in `USD`. Provides information to the [**Risk Manager**](./RiskManager.sol) that is the maximum amount of cover that `Solace` protocol can sell as a coverage.\r\n*/\r\ninterface ICoverageDataProviderV2 {\r\n  \r\n    /***************************************\r\n     EVENTS\r\n    ***************************************/\r\n\r\n    /// @notice Emitted when the underwriting pool is set.\r\n    event UnderwritingPoolSet(string uwpName, uint256 amount);\r\n\r\n    /// @notice Emitted when underwriting pool is removed.\r\n    event UnderwritingPoolRemoved(string uwpName);\r\n\r\n    /// @notice Emitted when underwriting pool updater is set.\r\n    event UwpUpdaterSet(address uwpUpdater);\r\n\r\n    /// @notice Emitted when underwriting pool updater is removed.\r\n    event UwpUpdaterRemoved(address uwpUpdater);\r\n\r\n    /***************************************\r\n     MUTUATOR FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n      * @notice Resets the underwriting pool balances.\r\n      * @param uwpNames The underwriting pool values to set.\r\n      * @param amounts The underwriting pool balances.\r\n    */\r\n    function set(string[] calldata uwpNames, uint256[] calldata amounts) external;\r\n\r\n    /**\r\n     * @notice Removes the given underwriting pool.\r\n     * @param uwpNames The underwriting pool names to remove.\r\n    */\r\n    function remove(string[] calldata uwpNames) external;\r\n\r\n    /***************************************\r\n     VIEW FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Returns the balance of the underwriting pool in `USD`.\r\n     * @param uwpName The underwriting pool name to get balance.\r\n     * @return amount The balance of the underwriting pool in `USD`.\r\n    */\r\n    function balanceOf(string memory uwpName) external view returns (uint256 amount); \r\n\r\n    /**\r\n     * @notice Returns underwriting pool name for given index.\r\n     * @param index The underwriting pool index to get.\r\n     * @return uwpName The underwriting pool name.\r\n    */\r\n    function poolOf(uint256 index) external view returns (string memory uwpName);\r\n\r\n    /**\r\n     * @notice Returns if given address is a valid underwriting pool updater.\r\n     * @param updater The address to check.\r\n     * @return status True if the address is valid updater.\r\n    */\r\n    function isUpdater(address updater) external view returns (bool status);\r\n\r\n    /**\r\n     * @notice Returns updater for given index.\r\n     * @param index The index to get updater.\r\n     * @return updater The updater address.\r\n    */\r\n    function updaterAt(uint256 index) external view returns (address updater);\r\n\r\n    /**\r\n     * @notice Returns the length of the updaters.\r\n     * @return count The updater count.\r\n    */\r\n    function numsOfUpdater() external view returns (uint256 count);\r\n    \r\n    /***************************************\r\n     GOVERNANCE FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Sets the underwriting pool bot updater.\r\n     * @param updater The bot address to set.\r\n    */\r\n    function addUpdater(address updater) external;\r\n\r\n    /**\r\n     * @notice Sets the underwriting pool bot updater.\r\n     * @param updater The bot address to set.\r\n    */\r\n    function removeUpdater(address updater) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/utils/IRegistry.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n/**\r\n * @title IRegistry\r\n * @author solace.fi\r\n * @notice Tracks the contracts of the Solaverse.\r\n *\r\n * [**Governance**](/docs/protocol/governance) can set the contract addresses and anyone can look them up.\r\n *\r\n * A key is a unique identifier for each contract. Use [`get(key)`](#get) or [`tryGet(key)`](#tryget) to get the address of the contract. Enumerate the keys with [`length()`](#length) and [`getKey(index)`](#getkey).\r\n */\r\ninterface IRegistry {\r\n\r\n    /***************************************\r\n    EVENTS\r\n    ***************************************/\r\n\r\n    /// @notice Emitted when a record is set.\r\n    event RecordSet(string indexed key, address indexed value);\r\n\r\n    /***************************************\r\n    VIEW FUNCTIONS\r\n    ***************************************/\r\n\r\n    /// @notice The number of unique keys.\r\n    function length() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Gets the `value` of a given `key`.\r\n     * Reverts if the key is not in the mapping.\r\n     * @param key The key to query.\r\n     * @param value The value of the key.\r\n     */\r\n    function get(string calldata key) external view returns (address value);\r\n\r\n    /**\r\n     * @notice Gets the `value` of a given `key`.\r\n     * Fails gracefully if the key is not in the mapping.\r\n     * @param key The key to query.\r\n     * @param success True if the key was found, false otherwise.\r\n     * @param value The value of the key or zero if it was not found.\r\n     */\r\n    function tryGet(string calldata key) external view returns (bool success, address value);\r\n\r\n    /**\r\n     * @notice Gets the `key` of a given `index`.\r\n     * @dev Iterable [1,length].\r\n     * @param index The index to query.\r\n     * @return key The key at that index.\r\n     */\r\n    function getKey(uint256 index) external view returns (string memory key);\r\n\r\n    /***************************************\r\n    GOVERNANCE FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Sets keys and values.\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     * @param keys The keys to set.\r\n     * @param values The values to set.\r\n     */\r\n    function set(string[] calldata keys, address[] calldata values) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.3.2\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File contracts/interfaces/ISOLACE.sol\r\n\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title Solace Token (SOLACE)\r\n * @author solace.fi\r\n * @notice The native governance token of the Solace Coverage Protocol.\r\n */\r\ninterface ISOLACE is IERC20Metadata {\r\n\r\n    /***************************************\r\n    EVENTS\r\n    ***************************************/\r\n\r\n    /// @notice Emitted when a minter is added.\r\n    event MinterAdded(address indexed minter);\r\n    /// @notice Emitted when a minter is removed.\r\n    event MinterRemoved(address indexed minter);\r\n\r\n    /***************************************\r\n    MINT FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Returns true if `account` is authorized to mint [**SOLACE**](../SOLACE).\r\n     * @param account Account to query.\r\n     * @return status True if `account` can mint, false otherwise.\r\n     */\r\n    function isMinter(address account) external view returns (bool status);\r\n\r\n    /**\r\n     * @notice Mints new [**SOLACE**](../SOLACE) to the receiver account.\r\n     * Can only be called by authorized minters.\r\n     * @param account The receiver of new tokens.\r\n     * @param amount The number of new tokens.\r\n     */\r\n    function mint(address account, uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Burns [**SOLACE**](../SOLACE) from msg.sender.\r\n     * @param amount Amount to burn.\r\n     */\r\n    function burn(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Adds a new minter.\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     * @param minter The new minter.\r\n     */\r\n    function addMinter(address minter) external;\r\n\r\n    /**\r\n     * @notice Removes a minter.\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     * @param minter The minter to remove.\r\n     */\r\n    function removeMinter(address minter) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/utils/IGovernable.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title IGovernable\r\n * @author solace.fi\r\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\r\n *\r\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\r\n * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\r\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./ISingletonFactory).\r\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\r\n */\r\ninterface IGovernable {\r\n\r\n    /***************************************\r\n    EVENTS\r\n    ***************************************/\r\n\r\n    /// @notice Emitted when pending Governance is set.\r\n    event GovernancePending(address pendingGovernance);\r\n    /// @notice Emitted when Governance is set.\r\n    event GovernanceTransferred(address oldGovernance, address newGovernance);\r\n    /// @notice Emitted when Governance is locked.\r\n    event GovernanceLocked();\r\n\r\n    /***************************************\r\n    VIEW FUNCTIONS\r\n    ***************************************/\r\n\r\n    /// @notice Address of the current governor.\r\n    function governance() external view returns (address);\r\n\r\n    /// @notice Address of the governor to take over.\r\n    function pendingGovernance() external view returns (address);\r\n\r\n    /// @notice Returns true if governance is locked.\r\n    function governanceIsLocked() external view returns (bool);\r\n\r\n    /***************************************\r\n    MUTATORS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Initiates transfer of the governance role to a new governor.\r\n     * Transfer is not complete until the new governor accepts the role.\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     * @param pendingGovernance_ The new governor.\r\n     */\r\n    function setPendingGovernance(address pendingGovernance_) external;\r\n\r\n    /**\r\n     * @notice Accepts the governance role.\r\n     * Can only be called by the new governor.\r\n     */\r\n    function acceptGovernance() external;\r\n\r\n    /**\r\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\r\n     * This action cannot be reversed.\r\n     * Before you call it, ask yourself:\r\n     *   - Is the contract self-sustaining?\r\n     *   - Is there a chance you will need governance privileges in the future?\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     */\r\n    function lockGovernance() external;\r\n}\r\n\r\n\r\n// File contracts/utils/Governable.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * @title Governable\r\n * @author solace.fi\r\n * @notice Enforces access control for important functions to [**governor**](/docs/protocol/governance).\r\n *\r\n * Many contracts contain functionality that should only be accessible to a privileged user. The most common access control pattern is [OpenZeppelin's `Ownable`](https://docs.openzeppelin.com/contracts/4.x/access-control#ownership-and-ownable). We instead use `Governable` with a few key differences:\r\n   * - Transferring the governance role is a two step process. The current governance must [`setPendingGovernance(pendingGovernance_)`](#setpendinggovernance) then the new governance must [`acceptGovernance()`](#acceptgovernance). This is to safeguard against accidentally setting ownership to the wrong address and locking yourself out of your contract.\r\n * - `governance` is a constructor argument instead of `msg.sender`. This is especially useful when deploying contracts via a [`SingletonFactory`](./../interfaces/utils/ISingletonFactory).\r\n * - We use `lockGovernance()` instead of `renounceOwnership()`. `renounceOwnership()` is a prerequisite for the reinitialization bug because it sets `owner = address(0x0)`. We also use the `governanceIsLocked()` flag.\r\n */\r\ncontract Governable is IGovernable {\r\n\r\n    /***************************************\r\n    GLOBAL VARIABLES\r\n    ***************************************/\r\n\r\n    // Governor.\r\n    address private _governance;\r\n\r\n    // governance to take over.\r\n    address private _pendingGovernance;\r\n\r\n    bool private _locked;\r\n\r\n    /**\r\n     * @notice Constructs the governable contract.\r\n     * @param governance_ The address of the [governor](/docs/protocol/governance).\r\n     */\r\n    constructor(address governance_) {\r\n        require(governance_ != address(0x0), \"zero address governance\");\r\n        _governance = governance_;\r\n        _pendingGovernance = address(0x0);\r\n        _locked = false;\r\n    }\r\n\r\n    /***************************************\r\n    MODIFIERS\r\n    ***************************************/\r\n\r\n    // can only be called by governor\r\n    // can only be called while unlocked\r\n    modifier onlyGovernance() {\r\n        require(!_locked, \"governance locked\");\r\n        require(msg.sender == _governance, \"!governance\");\r\n        _;\r\n    }\r\n\r\n    // can only be called by pending governor\r\n    // can only be called while unlocked\r\n    modifier onlyPendingGovernance() {\r\n        require(!_locked, \"governance locked\");\r\n        require(msg.sender == _pendingGovernance, \"!pending governance\");\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n    VIEW FUNCTIONS\r\n    ***************************************/\r\n\r\n    /// @notice Address of the current governor.\r\n    function governance() public view override returns (address) {\r\n        return _governance;\r\n    }\r\n\r\n    /// @notice Address of the governor to take over.\r\n    function pendingGovernance() external view override returns (address) {\r\n        return _pendingGovernance;\r\n    }\r\n\r\n    /// @notice Returns true if governance is locked.\r\n    function governanceIsLocked() external view override returns (bool) {\r\n        return _locked;\r\n    }\r\n\r\n    /***************************************\r\n    MUTATOR FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n     * @notice Initiates transfer of the governance role to a new governor.\r\n     * Transfer is not complete until the new governor accepts the role.\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     * @param pendingGovernance_ The new governor.\r\n     */\r\n    function setPendingGovernance(address pendingGovernance_) external override onlyGovernance {\r\n        _pendingGovernance = pendingGovernance_;\r\n        emit GovernancePending(pendingGovernance_);\r\n    }\r\n\r\n    /**\r\n     * @notice Accepts the governance role.\r\n     * Can only be called by the pending governor.\r\n     */\r\n    function acceptGovernance() external override onlyPendingGovernance {\r\n        // sanity check against transferring governance to the zero address\r\n        // if someone figures out how to sign transactions from the zero address\r\n        // consider the entirety of ethereum to be rekt\r\n        require(_pendingGovernance != address(0x0), \"zero governance\");\r\n        address oldGovernance = _governance;\r\n        _governance = _pendingGovernance;\r\n        _pendingGovernance = address(0x0);\r\n        emit GovernanceTransferred(oldGovernance, _governance);\r\n    }\r\n\r\n    /**\r\n     * @notice Permanently locks this contract's governance role and any of its functions that require the role.\r\n     * This action cannot be reversed.\r\n     * Before you call it, ask yourself:\r\n     *   - Is the contract self-sustaining?\r\n     *   - Is there a chance you will need governance privileges in the future?\r\n     * Can only be called by the current [**governor**](/docs/protocol/governance).\r\n     */\r\n    function lockGovernance() external override onlyGovernance {\r\n        _locked = true;\r\n        // intentionally not using address(0x0), see re-initialization exploit\r\n        _governance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\r\n        _pendingGovernance = address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF);\r\n        emit GovernanceTransferred(msg.sender, address(0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF));\r\n        emit GovernanceLocked();\r\n    }\r\n}\r\n\r\n\r\n// File contracts/risk/CoverageDataProviderV2.sol\r\n\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title  CoverageDataProviderV2\r\n * @author solace.fi\r\n * @notice Holds underwriting pool amounts in `USD`. Provides information to the [**Risk Manager**](./RiskManager.sol) that is the maximum amount of cover that `Solace` protocol can sell as a coverage.\r\n*/\r\ncontract CoverageDataProviderV2 is ICoverageDataProviderV2, Governable, ReentrancyGuard {\r\n    using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n    /***************************************\r\n     STATE VARIABLES\r\n    ***************************************/\r\n\r\n    /// @notice The balance of underwriting pool in usd.\r\n    mapping(string => uint256) private _uwpBalanceOf;\r\n\r\n    /// @notice The index to underwriting pool.\r\n    mapping(uint256 => string) private _indexToUwp;\r\n\r\n    /// @notice The underwriting pool to index.\r\n    mapping(string => uint256) private _uwpToIndex;\r\n\r\n    /// @notice The underwriting pool updaters.\r\n    EnumerableSet.AddressSet private _updaters;\r\n\r\n    /// @notice The underwriting pool count\r\n    uint256 public numOfPools;\r\n\r\n    /// @notice The max. coverage amount.\r\n    uint256 public maxCover;\r\n\r\n    /***************************************\r\n     MODIFIERS FUNCTIONS\r\n    ***************************************/\r\n    \r\n    modifier canUpdate() {\r\n      require(msg.sender == super.governance() || isUpdater(msg.sender), \"!governance\");\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * @notice Constructs the `CoverageDataProviderV2` contract.\r\n     * @param _governance The address of the [governor](/docs/protocol/governance).\r\n    */\r\n    // solhint-disable-next-line no-empty-blocks\r\n    constructor(address _governance) Governable(_governance) {}\r\n\r\n    /***************************************\r\n     MUTUATOR FUNCTIONS\r\n    ***************************************/\r\n   \r\n    /**\r\n      * @notice Resets the underwriting pool balances.\r\n      * @param _uwpNames The underwriting pool values to set.\r\n      * @param _amounts The underwriting pool balances in `USD`.\r\n    */\r\n    function set(string[] calldata _uwpNames, uint256[] calldata _amounts) external override nonReentrant canUpdate {\r\n      require(_uwpNames.length == _amounts.length, \"length mismatch\");\r\n      _set(_uwpNames, _amounts);\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the given underwriting pool.\r\n     * @param uwpNames The underwriting pool names to remove.\r\n    */\r\n    function remove(string[] calldata uwpNames) external override canUpdate {\r\n      _remove(uwpNames);\r\n    }\r\n\r\n    /***************************************\r\n     VIEW FUNCTIONS\r\n    ***************************************/\r\n   \r\n    /**\r\n     * @notice Returns the balance of the underwriting pool in `USD`.\r\n     * @param uwpName The underwriting pool name to get balance.\r\n     * @return amount The balance of the underwriting pool in `USD`.\r\n    */\r\n    function balanceOf(string memory uwpName) public view override returns (uint256 amount) {\r\n      return _uwpBalanceOf[uwpName];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns underwriting pool name for given index.\r\n     * @param index The underwriting pool index to get.\r\n     * @return uwpName The underwriting pool name.\r\n    */\r\n    function poolOf(uint256 index) external view override returns (string memory uwpName) {\r\n      return _indexToUwp[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns if given address is a valid underwriting pool updater.\r\n     * @param updater The address to check.\r\n     * @return status True if the address is valid updater.\r\n    */\r\n    function isUpdater(address updater) public view override returns (bool status) {\r\n      return _updaters.contains(updater);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns updater for given index.\r\n     * @param index The index to get updater.\r\n     * @return updater The updater address.\r\n    */\r\n    function updaterAt(uint256 index) external view override returns (address updater) {\r\n        return _updaters.at(index);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the length of the updaters.\r\n     * @return count The updater count.\r\n    */\r\n    function numsOfUpdater() external view override returns (uint256 count) {\r\n        return _updaters.length();\r\n    }\r\n\r\n    /***************************************\r\n     INTERNAL FUNCTIONS\r\n    ***************************************/\r\n\r\n    /**\r\n      * @notice Resets the underwriting pool balances.\r\n      * @param uwpNames The underwriting pool values to set.\r\n      * @param amounts The underwriting pool balances in `USD`.\r\n    */\r\n    function _set(string[] memory uwpNames, uint256[] memory amounts) internal {\r\n      // delete current underwriting pools\r\n      uint256 poolCount = numOfPools;\r\n      string memory uwpName;\r\n\r\n      for (uint256 i = poolCount; i > 0; i--) {\r\n        uwpName = _indexToUwp[i];\r\n        delete _uwpToIndex[uwpName];\r\n        delete _indexToUwp[i];\r\n        delete _uwpBalanceOf[uwpName];\r\n        emit UnderwritingPoolRemoved(uwpName);\r\n      }\r\n\r\n      // set new underwriting pools\r\n      uint256 cover = 0;\r\n      numOfPools = 0;\r\n      uint256 amount;\r\n      for (uint256 i = 0; i < uwpNames.length; i++) {\r\n        uwpName = uwpNames[i];\r\n        amount = amounts[i];\r\n        cover += amount;\r\n        require(bytes(uwpName).length > 0, \"empty underwriting pool name\");\r\n        \r\n        _uwpBalanceOf[uwpName] = amount;\r\n        if (_uwpToIndex[uwpName] == 0) {\r\n          uint256 index = numOfPools;\r\n          _uwpToIndex[uwpName] = ++index;\r\n          _indexToUwp[index] = uwpName;\r\n          numOfPools = index;\r\n        }\r\n        emit UnderwritingPoolSet(uwpName, amount);\r\n      }\r\n      maxCover = cover;\r\n    }\r\n\r\n    /**\r\n     * @notice Removes the given underwriting pool.\r\n     * @param uwpNames The underwriting pool names to remove.\r\n    */\r\n    function _remove(string[] memory uwpNames) internal {\r\n      string memory uwpName;\r\n      uint256 cover = maxCover;\r\n\r\n      for (uint256 i = 0; i < uwpNames.length; i++) {\r\n        uwpName = uwpNames[i];\r\n        uint256 index = _uwpToIndex[uwpName];\r\n        if (index == 0) return;\r\n\r\n        uint256 poolCount = numOfPools;\r\n        if (poolCount == 0) return;\r\n\r\n        if (index != poolCount) {\r\n          string memory lastPool = _indexToUwp[poolCount];\r\n          _uwpToIndex[lastPool] = index;\r\n          _indexToUwp[index] = lastPool;\r\n        }\r\n\r\n        cover -= _uwpBalanceOf[uwpName];\r\n        delete _uwpToIndex[uwpName];\r\n        delete _indexToUwp[poolCount];\r\n        delete _uwpBalanceOf[uwpName];\r\n        numOfPools -= 1;\r\n        emit UnderwritingPoolRemoved(uwpName);\r\n      }\r\n      maxCover = cover;\r\n    }\r\n\r\n    /***************************************\r\n     GOVERNANCE FUNCTIONS\r\n    ***************************************/\r\n    \r\n    /**\r\n     * @notice Sets the underwriting pool bot updater.\r\n     * @param updater The bot address to set.\r\n    */\r\n    function addUpdater(address updater) external override onlyGovernance {\r\n      require(updater != address(0x0), \"zero address uwp updater\");\r\n      _updaters.add(updater);\r\n      emit UwpUpdaterSet(updater);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the underwriting pool bot updater.\r\n     * @param updater The bot address to set.\r\n    */\r\n    function removeUpdater(address updater) external override onlyGovernance {\r\n      if (!isUpdater(updater)) return;\r\n      _updaters.remove(updater);\r\n      emit UwpUpdaterRemoved(updater);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GovernanceLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernancePending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldGovernance\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uwpName\",\"type\":\"string\"}],\"name\":\"UnderwritingPoolRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uwpName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnderwritingPoolSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uwpUpdater\",\"type\":\"address\"}],\"name\":\"UwpUpdaterRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"uwpUpdater\",\"type\":\"address\"}],\"name\":\"UwpUpdaterSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"addUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uwpName\",\"type\":\"string\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governanceIsLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"isUpdater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxCover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOfPools\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numsOfUpdater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"poolOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"uwpName\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"uwpNames\",\"type\":\"string[]\"}],\"name\":\"remove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"name\":\"removeUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"_uwpNames\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingGovernance_\",\"type\":\"address\"}],\"name\":\"setPendingGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"updaterAt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"updater\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CoverageDataProviderV2", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000501ace0e8d16b92236763e2ded7ae3bc2dffa276", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e84658a9f97caca17dac6ba8e229911b6275af52568ade3d602a273d7e6ac626"}]}