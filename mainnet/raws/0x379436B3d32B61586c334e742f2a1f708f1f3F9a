{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Elysian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./interfaces/ISystemStatus.sol\\\";\\nimport \\\"./ExternStateToken.sol\\\";\\nimport \\\"./MixinResolver.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ninterface IRewardEscrow {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n    function numVestingEntries(address account) external view returns (uint);\\n    function totalEscrowedAccountBalance(address account) external view returns (uint);\\n    function totalVestedAccountBalance(address account) external view returns (uint);\\n    // Mutative functions\\n    function appendVestingEntry(address account, uint quantity) external;\\n    function vest() external;\\n}\\n\\ninterface IHasBalance {\\n    // Views\\n    function balanceOf(address account) external view returns (uint);\\n}\\n\\ninterface IVault {\\n\\n}\\n\\ncontract Elysian is  ExternStateToken, MixinResolver {\\n    using SafeMath for uint256;\\n    \\n    // ========== STATE VARIABLES ==========\\n    string public constant TOKEN_NAME = \\\"Elysian Network Token\\\";\\n    string public constant TOKEN_SYMBOL = \\\"LYS\\\";\\n    uint8  public constant DECIMALS = 9;\\n\\n    /* ========== ADDRESS RESOLVER CONFIGURATION ========== */\\n    bytes32 private constant CONTRACT_EXRATES = \\\"ExchangeRates\\\";\\n    bytes32 private constant CONTRACT_TREASURY = \\\"Treasury\\\";\\n    bytes32 private constant CONTRACT_ELYSIANESCROW = \\\"ElysianEscrow\\\";\\n    bytes32 private constant CONTRACT_REWARDESCROW = \\\"RewardEscrow\\\";\\n    bytes32 private constant CONTRACT_VAULT = \\\"ElysianVault\\\";\\n    bytes32 private constant CONTRACT_SYSTEMSTATUS = \\\"SystemStatus\\\";\\n\\n     // ========== CONSTRUCTOR ==========\\n    constructor(\\n        address payable _proxy,\\n        TokenState _tokenState,\\n        address _owner,\\n        uint _totalSupply,\\n        address _resolver\\n    )\\n        public\\n        ExternStateToken(\\n            _proxy, \\n            _tokenState, \\n            TOKEN_NAME, \\n            TOKEN_SYMBOL, \\n            _totalSupply, \\n            DECIMALS, \\n            _owner\\n        )\\n        MixinResolver(_resolver) {}\\n\\n\\n    function totalBalance(address account) external view returns (uint) {\\n        uint balance = tokenState.balanceOf(account);\\n        if (address(elysianEscrow()) != address(0)) {\\n            balance = balance.add(elysianEscrow().balanceOf(account));\\n        }\\n        if (address(rewardEscrow()) != address(0)) {\\n            balance = balance.add(rewardEscrow().balanceOf(account));\\n        }\\n        return balance;\\n    }\\n\\n    function mint(uint _amount, address _recipient, bool _isEscrowed) external onlyInternalContracts issuanceActive returns (bool) {\\n        require(_amount > 0, \\\"Cannot mint 0 tokens\\\");\\n        bool result = _internalIssue(_recipient, _amount, _isEscrowed);\\n        return result;\\n    }\\n\\n    function _internalIssue(address account, uint amount, bool _isEscrowed) internal returns (bool) {\\n        if (_isEscrowed) {\\n            tokenState.setBalanceOf(address(this), tokenState.balanceOf(address(this)).add(amount));\\n            _transfer(address(rewardEscrow()), amount);\\n            rewardEscrow().appendVestingEntry(account, amount);\\n            emitTransfer(address(0), address(rewardEscrow()), amount);\\n        } else {\\n            tokenState.setBalanceOf(account, tokenState.balanceOf(account).add(amount));\\n            emitTransfer(address(0), account, amount);\\n        }\\n        totalSupply = totalSupply.add(amount);\\n        emitIssued(account, amount);\\n        return true;\\n    }\\n\\n    function burn(uint _amount, address _account) external onlyInternalContracts returns (bool) {\\n        bool result = _internalBurn(_account, _amount);\\n        return result;\\n    }\\n\\n    function _internalBurn(address account, uint amount) internal returns (bool) {\\n        tokenState.setBalanceOf(account, tokenState.balanceOf(account).sub(amount));\\n        totalSupply = totalSupply.sub(amount, \\\"internal error during burn\\\");\\n\\n        emitTransfer(account, address(0), amount);\\n        emitBurned(account, amount);\\n        return true;\\n    }\\n\\n    function _transfer(address to, uint value) internal returns (bool) {\\n        // Perform the transfer: if there is a problem an exception will be thrown in this call.\\n        _transferByProxy(address(this), to, value);\\n        return true;\\n    }\\n\\n    function transfer(address to, uint value) external optionalProxy systemActive returns (bool) {\\n        // Perform the transfer: if there is a problem an exception will be thrown in this call.\\n        _transferByProxy(messageSender, to, value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint value\\n    ) external optionalProxy systemActive returns (bool) {\\n        // Perform the transfer: if there is a problem,\\n        // an exception will be thrown in this call.\\n        return _transferFromByProxy(messageSender, from, to, value);\\n    }\\n\\n    modifier onlyInternalContracts() {\\n        bool isVault = messageSender == address(vault());\\n        require(\\n            isVault,\\n            \\\"Only authorized contracts allowed\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier issuanceActive() {\\n        systemStatus().requireIssuanceActive();\\n        _;\\n    }\\n\\n    modifier systemActive() {\\n        systemStatus().requireSystemActive();\\n        _;\\n    }\\n\\n    function systemStatus() internal view returns (ISystemStatus) {\\n        return ISystemStatus(resolver.requireAndGetAddress(\\\"SystemStatus\\\", \\\"Missing SystemStatus address\\\"));\\n    }\\n\\n    function vault() public view returns (IVault) {\\n        return IVault(resolver.requireAndGetAddress(CONTRACT_VAULT, \\\"Missing Vault address\\\"));\\n    }\\n\\n    function rewardEscrow() internal view returns (IRewardEscrow) {\\n        return IRewardEscrow(resolver.requireAndGetAddress(CONTRACT_REWARDESCROW, \\\"Missing reward escrow address\\\"));\\n    }\\n\\n    function elysianEscrow() internal view returns (IHasBalance) {\\n        return IHasBalance(resolver.requireAndGetAddress(CONTRACT_ELYSIANESCROW, \\\"Missing Elysian escrow address\\\"));\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    event Issued(address indexed account, uint value);\\n    bytes32 private constant ISSUED_SIG = keccak256(\\\"Issued(address,uint256)\\\");\\n\\n    function emitIssued(address account, uint value) internal {\\n        proxy._emit(abi.encode(value), 2, ISSUED_SIG, addressToBytes32(account), 0, 0);\\n    }\\n\\n    event Burned(address indexed account, uint value);\\n    bytes32 private constant BURNED_SIG = keccak256(\\\"Burned(address,uint256)\\\");\\n\\n    function emitBurned(address account, uint value) internal {\\n        proxy._emit(abi.encode(value), 2, BURNED_SIG, addressToBytes32(account), 0, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nlibrary SafeMath {\\n\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    // Only used in the  BondingCalculator.sol\\n    function sqrrt(uint256 a) internal pure returns (uint c) {\\n        if (a > 3) {\\n            c = a;\\n            uint b = add( div( a, 2), 1 );\\n            while (b < c) {\\n                c = b;\\n                b = div( add( div( a, b ), b), 2 );\\n            }\\n        } else if (a != 0) {\\n            c = 1;\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ISystemStatus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\\ninterface ISystemStatus {\\n    struct Status {\\n        bool canSuspend;\\n        bool canResume;\\n    }\\n\\n    struct Suspension {\\n        bool suspended;\\n        // reason is an integer code,\\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\\n        uint248 reason;\\n    }\\n\\n    // Views\\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\\n\\n    function requireSystemActive() external view;\\n\\n    function requireIssuanceActive() external view;\\n\\n    function requireExchangeActive() external view;\\n\\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function requireSynthActive(bytes32 currencyKey) external view;\\n\\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\\n\\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\\n\\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\\n\\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\\n\\n    function getSynthSuspensions(bytes32[] calldata synths)\\n        external\\n        view\\n        returns (bool[] memory suspensions, uint256[] memory reasons);\\n\\n    // Restricted functions\\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\\n\\n    function updateAccessControl(\\n        bytes32 section,\\n        address account,\\n        bool canSuspend,\\n        bool canResume\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IAddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\\ninterface IAddressResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getSynth(bytes32 key) external view returns (address);\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/contracts/TokenState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\nimport \\\"./State.sol\\\";\\n\\n\\n// https://docs.elysian.cash/contracts/TokenState\\ncontract TokenState is OwnedwManager, State {\\n    /* ERC20 fields. */\\n    mapping(address => uint) public balanceOf;\\n    mapping(address => mapping(address => uint)) public allowance;\\n\\n    constructor(address _owner, address _associatedContract) public OwnedwManager(_owner, _owner) State(_associatedContract) {}\\n\\n    /* ========== SETTERS ========== */\\n\\n    /**\\n     * @notice Set ERC20 allowance.\\n     * @dev Only the associated contract may call this.\\n     * @param tokenOwner The authorising party.\\n     * @param spender The authorised party.\\n     * @param value The total value the authorised party may spend on the\\n     * authorising party's behalf.\\n     */\\n    function setAllowance(\\n        address tokenOwner,\\n        address spender,\\n        uint value\\n    ) external onlyAssociatedContract {\\n        allowance[tokenOwner][spender] = value;\\n    }\\n\\n    /**\\n     * @notice Set the balance in a given account\\n     * @dev Only the associated contract may call this.\\n     * @param account The account whose value to set.\\n     * @param value The new balance of the given account.\\n     */\\n    function setBalanceOf(address account, uint value) external onlyAssociatedContract {\\n        balanceOf[account] = value;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/State.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\nabstract contract State is OwnedwManager {\\n    // the address of the contract that can modify variables\\n    // this can only be changed by the owner of this contract\\n    address public associatedContract;\\n\\n    constructor(address _associatedContract) internal {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    }\\n\\n    /* ========== SETTERS ========== */\\n\\n    // Change the associated contract to a new address\\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\\n        associatedContract = _associatedContract;\\n        emit AssociatedContractUpdated(_associatedContract);\\n    } \\n \\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyAssociatedContract {\\n        require(msg.sender == associatedContract, \\\"Only the associated contract can perform this action\\\");\\n        _;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AssociatedContractUpdated(address associatedContract);\\n}\\n \"\r\n    },\r\n    \"/contracts/SelfDestructible.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n\\n// https://docs.elysian.cash/contracts/SelfDestructible\\nabstract contract SelfDestructible is OwnedwManager {\\n    uint public constant SELFDESTRUCT_DELAY = 4 weeks; \\n\\n    uint public initiationTime;\\n    bool public selfDestructInitiated;\\n\\n    address public selfDestructBeneficiary;\\n\\n    constructor() {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n        selfDestructBeneficiary = owner;\\n        emit SelfDestructBeneficiaryUpdated(owner);\\n    }\\n\\n    /**\\n     * @notice Set the beneficiary address of this contract.\\n     * @dev Only the contract owner may call this. The provided beneficiary must be non-null.\\n     * @param _beneficiary The address to pay any eth contained in this contract to upon self-destruction.\\n     */\\n    function setSelfDestructBeneficiary(address payable _beneficiary) external onlyOwner {\\n        require(_beneficiary != address(0), \\\"Beneficiary must not be zero\\\");\\n        selfDestructBeneficiary = _beneficiary;\\n        emit SelfDestructBeneficiaryUpdated(_beneficiary);\\n    }\\n\\n    /**\\n     * @notice Begin the self-destruction counter of this contract.\\n     * Once the delay has elapsed, the contract may be self-destructed.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function initiateSelfDestruct() external onlyOwner {\\n        initiationTime = block.timestamp;\\n        selfDestructInitiated = true;\\n        emit SelfDestructInitiated(SELFDESTRUCT_DELAY);\\n    }  \\n\\n    /**\\n     * @notice Terminate and reset the self-destruction timer.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function terminateSelfDestruct() external onlyOwner {\\n        initiationTime = 0;\\n        selfDestructInitiated = false;\\n        emit SelfDestructTerminated();\\n    }\\n\\n    /**\\n     * @notice If the self-destruction delay has elapsed, destroy this contract and\\n     * remit any ether it owns to the beneficiary address.\\n     * @dev Only the contract owner may call this.\\n     */\\n    function selfDestruct() external onlyOwner {\\n        require(selfDestructInitiated, \\\"Self Destruct not yet initiated\\\");\\n        require(initiationTime + SELFDESTRUCT_DELAY < block.timestamp, \\\"Self destruct delay not met\\\");\\n        emit SelfDestructed(selfDestructBeneficiary);\\n        selfdestruct(address(uint160(selfDestructBeneficiary)));\\n    }\\n\\n    event SelfDestructTerminated();\\n    event SelfDestructed(address beneficiary);\\n    event SelfDestructInitiated(uint selfDestructDelay);\\n    event SelfDestructBeneficiaryUpdated(address newBeneficiary);\\n}\\n\"\r\n    },\r\n    \"/contracts/SafeDecimalMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Libraries\\n// TODO(zx): Replace all instances of SafeMath with OZ implementation\\nimport \\\"./libraries/SafeMath.sol\\\";  \\n    \\nlibrary SafeDecimalMath {\\n    using SafeMath for uint;\\n\\n    /* Number of decimal places in the representations. */\\n    uint8 public constant decimals = 9;\\n    uint8 public constant highPrecisionDecimals = 27;\\n\\n    /* The number representing 1.0. */\\n    uint public constant UNIT = 10**uint(decimals);\\n\\n    /* The number representing 1.0 for higher fidelity numbers. */\\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\\n\\n    /**\\n     * @return Provides an interface to UNIT.\\n     */\\n    function unit() external pure returns (uint) {\\n        return UNIT;\\n    }\\n\\n    /**\\n     * @return Provides an interface to PRECISE_UNIT.\\n     */\\n    function preciseUnit() external pure returns (uint) {\\n        return PRECISE_UNIT;\\n    }\\n\\n    /**\\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\\n     * decimals.\\n     *\\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\\n     * so that product must be less than 2**256. As this is an integer division,\\n     * the internal division always rounds down. This helps save on gas. Rounding\\n     * is more expensive on gas.\\n     */\\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        return x.mul(y) / UNIT;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of the specified precision unit.\\n     *\\n     * @dev The operands should be in the form of a the specified unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function _multiplyDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a precise unit.\\n     *\\n     * @dev The operands should be in the precise unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely multiplying x and y, interpreting the operands\\n     * as fixed-point decimals of a standard unit.\\n     *\\n     * @dev The operands should be in the standard unit factor which will be\\n     * divided out after the product of x and y is evaluated, so that product must be\\n     * less than 2**256.\\n     *\\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\\n     * (eg. small fractions or percentages).\\n     */\\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _multiplyDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is a high\\n     * precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\\n     * this is an integer division, the result is always rounded down.\\n     * This helps save on gas. Rounding is more expensive on gas.\\n     */\\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\\n        /* Reintroduce the UNIT factor that will be divided out by y. */\\n        return x.mul(UNIT).div(y);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * decimal in the precision unit specified in the parameter.\\n     *\\n     * @dev y is divided after the product of x and the specified precision unit\\n     * is evaluated, so the product of x and the specified precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function _divideDecimalRound(\\n        uint x,\\n        uint y,\\n        uint precisionUnit\\n    ) private pure returns (uint) {\\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\\n\\n        if (resultTimesTen % 10 >= 5) {\\n            resultTimesTen += 10;\\n        }\\n\\n        return resultTimesTen / 10;\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * standard precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the standard precision unit\\n     * is evaluated, so the product of x and the standard precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, UNIT);\\n    }\\n\\n    /**\\n     * @return The result of safely dividing x and y. The return value is as a rounded\\n     * high precision decimal.\\n     *\\n     * @dev y is divided after the product of x and the high precision unit\\n     * is evaluated, so the product of x and the high precision unit must\\n     * be less than 2**256. The result is rounded to the nearest increment.\\n     */\\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\\n    }\\n\\n    /**\\n     * @dev Convert a standard decimal representation to a high precision one.\\n     */\\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\\n    }\\n\\n    /**\\n     * @dev Convert a high precision decimal to a standard decimal representation.\\n     */\\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\\n\\n        if (quotientTimesTen % 10 >= 5) {\\n            quotientTimesTen += 10;\\n        }\\n\\n        return quotientTimesTen / 10;\\n    }\\n\\n    // Computes `a - b`, setting the value to 0 if b > a.\\n    function floorsub(uint a, uint b) internal pure returns (uint) {\\n        return b >= a ? 0 : a - b;\\n    }\\n\\n    /* ---------- Utilities ---------- */\\n    /*\\n     * Absolute value of the input, returned as a signed number.\\n     */\\n    function signedAbs(int x) internal pure returns (int) {\\n        return x < 0 ? -x : x;\\n    }\\n\\n    /*\\n     * Absolute value of the input, returned as an unsigned number.\\n     */\\n    function abs(int x) internal pure returns (uint) {\\n        return uint(signedAbs(x));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/Proxyable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n// Internal references\\nimport \\\"./Proxy.sol\\\";\\n\\n// https://docs.synthetix.io/contracts/source/contracts/proxyable\\nabstract contract Proxyable is OwnedwManager {\\n    // This contract should be treated like an abstract contract\\n\\n    /* The proxy this contract exists behind. */\\n    Proxy public proxy;\\n\\n    /* The caller of the proxy, passed through to this contract.\\n     * Note that every function using this member must apply the onlyProxy or\\n     * optionalProxy modifiers, otherwise their invocations can use stale values. */\\n    address public messageSender;\\n\\n    constructor(address payable _proxy) {\\n        // This contract is abstract, and thus cannot be instantiated directly\\n        require(owner != address(0), \\\"Owner must be set\\\");\\n\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    } \\n\\n    function setProxy(address payable _proxy) external onlyOwner {\\n        proxy = Proxy(_proxy);\\n        emit ProxyUpdated(_proxy);\\n    }\\n\\n    function setMessageSender(address sender) external onlyProxy {\\n        messageSender = sender;\\n    }\\n\\n    modifier onlyProxy {\\n        _onlyProxy();\\n        _;  \\n    }\\n\\n    function _onlyProxy() private view {\\n        require(Proxy(msg.sender) == proxy, \\\"Only the proxy can call\\\");\\n    }\\n\\n    modifier optionalProxy {\\n        _optionalProxy();\\n        _;\\n    }\\n\\n    function _optionalProxy() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n    }\\n\\n    modifier optionalProxy_onlyOwner {\\n        _optionalProxy_onlyOwner();\\n        _;\\n    }\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function _optionalProxy_onlyOwner() private {\\n        if (Proxy(msg.sender) != proxy && messageSender != msg.sender) {\\n            messageSender = msg.sender;\\n        }\\n        require(messageSender == owner, \\\"Owner only function\\\");\\n    }\\n\\n    event ProxyUpdated(address proxyAddress);\\n}\\n\"\r\n    },\r\n    \"/contracts/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\";\\n\\n// Internal references\\nimport \\\"./Proxyable.sol\\\";\\n\\ncontract Proxy is OwnedwManager {\\n    Proxyable public target;\\n\\n    constructor(address _owner) OwnedwManager(_owner, _owner) {}\\n\\n    function setTarget(Proxyable _target) external onlyOwner {\\n        target = _target;\\n        emit TargetUpdated(_target);\\n    }\\n\\n    function _emit(\\n        bytes calldata callData,\\n        uint numTopics,\\n        bytes32 topic1,\\n        bytes32 topic2,\\n        bytes32 topic3,\\n        bytes32 topic4\\n    ) external onlyTarget {\\n        uint size = callData.length;\\n        bytes memory _callData = callData;\\n\\n        assembly {\\n            /* The first 32 bytes of callData contain its length (as specified by the abi).\\n             * Length is assumed to be a uint256 and therefore maximum of 32 bytes\\n             * in length. It is also leftpadded to be a multiple of 32 bytes.\\n             * This means moving call_data across 32 bytes guarantees we correctly access\\n             * the data itself. */\\n            switch numTopics\\n                case 0 {\\n                    log0(add(_callData, 32), size)\\n                }\\n                case 1 {\\n                    log1(add(_callData, 32), size, topic1)\\n                }\\n                case 2 {\\n                    log2(add(_callData, 32), size, topic1, topic2)\\n                }\\n                case 3 {\\n                    log3(add(_callData, 32), size, topic1, topic2, topic3)\\n                }\\n                case 4 {\\n                    log4(add(_callData, 32), size, topic1, topic2, topic3, topic4)\\n                }\\n        }\\n    }\\n\\n    // solhint-disable no-complex-fallback\\n    fallback() external payable {\\n        // Mutable call setting Proxyable.messageSender as this is using call not delegatecall\\n        target.setMessageSender(msg.sender);\\n\\n        assembly {\\n            let free_ptr := mload(0x40)\\n            calldatacopy(free_ptr, 0, calldatasize())\\n\\n            /* We must explicitly forward ether to the underlying contract as well. */\\n            let result := call(gas(), sload(target.slot), callvalue(), free_ptr, calldatasize(), 0, 0)\\n            let size := returndatasize()\\n\\n            returndatacopy(free_ptr, 0, size)\\n\\n            if iszero(result) {\\n                revert(free_ptr, size)\\n            }\\n            return(free_ptr, size)\\n        }\\n    }\\n\\n    modifier onlyTarget {\\n        require(Proxyable(msg.sender) == target, \\\"Must be proxy target\\\");\\n        _;\\n    }\\n\\n    event TargetUpdated(Proxyable newTarget);\\n}\\n\"\r\n    },\r\n    \"/contracts/OwnedwManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\ncontract OwnedwManager {\\n    address public owner;\\n    address public manager;\\n\\n    address public nominatedOwner;\\n\\n    constructor(address _owner, address _manager) {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        manager = _manager;\\n        emit OwnerChanged(address(0), _owner);\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        _onlyOwner();\\n        _;\\n    }\\n\\n    modifier onlyManager {\\n        _onlyManager();\\n        _;\\n    }\\n    \\n    function _onlyOwner() private view {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function _onlyManager() private view {\\n        require(msg.sender == manager, \\\"Only the contract owner may perform this action\\\");\\n    }\\n\\n    function setManager(address _manager) external onlyOwner {\\n        manager = _manager;\\n        emit ManagerChanged(_manager);\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n    event ManagerChanged(address newManager);\\n}\\n\"\r\n    },\r\n    \"/contracts/MixinResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n     \\n// Internal references\\nimport \\\"./AddressResolver.sol\\\";             \\n       \\n   abstract contract MixinResolver {\\n    AddressResolver public resolver;   \\n  \\n    mapping(bytes32 => address) private addressCache;\\n\\n    constructor(address _resolver)  {\\n        resolver = AddressResolver(_resolver);\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ====== ==== */\\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\\n        internal\\n        pure\\n        returns (bytes32[] memory combination)  \\n    {\\n        combination = new bytes32[](first.length + second.length); \\n\\n        for (uint i = 0; i < first.length; i++) {\\n            combination[i] = first[i];\\n        }\\n\\n        for (uint j = 0; j < second.length; j++) {\\n            combination[first.length + j] = second[j];\\n        }\\n    }      \\n \\n    /* ========== PUBLIC FUNCTIONS ========== */\\n\\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\\n    function resolverAddressesRequired() public view virtual returns (bytes32[] memory addresses) {}\\n\\n    function rebuildCache() public {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        // The resolver must call this function whenver it updates its state\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // Note: can only be invoked once the resolver has all the targets needed added\\n            address destination =\\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\\\"Resolver missing target: \\\", name)));\\n            addressCache[name] = destination;\\n            emit CacheUpdated(name, destination);\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function isResolverCached() external view returns (bool) {\\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\\n        for (uint i = 0; i < requiredAddresses.length; i++) {\\n            bytes32 name = requiredAddresses[i];\\n            // false if our cache is invalid or if the resolver doesn't have the required address\\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /* ========== INTERNAL FUNCTIONS ========== */\\n\\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\\n        address _foundAddress = addressCache[name];\\n        require(_foundAddress != address(0), string(abi.encodePacked(\\\"Missing address: \\\", name)));\\n        return _foundAddress;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event CacheUpdated(bytes32 name, address destination);\\n}\\n\"\r\n    },\r\n    \"/contracts/ExternStateToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\"; \\nimport \\\"./SelfDestructible.sol\\\";\\nimport \\\"./Proxyable.sol\\\";\\n\\n// Libraries\\nimport \\\"./SafeDecimalMath.sol\\\";\\n\\n// Internal references\\nimport \\\"./TokenState.sol\\\";\\n\\ncontract ExternStateToken is  OwnedwManager, SelfDestructible, Proxyable {\\n    using SafeMath for uint;\\n    using SafeDecimalMath for uint;\\n\\n    /* ========== STATE VARIABLES ========== */\\n    /* Stores balances and allowances. */\\n    TokenState public tokenState;\\n\\n    /* Other ERC20 fields. */\\n    string public  name;\\n    string public  symbol;\\n    uint   public  totalSupply;\\n    uint8  public  decimals;\\n\\n    constructor(\\n        address payable _proxy,\\n        TokenState _tokenState,\\n        string memory _name,\\n        string memory _symbol,\\n        uint _totalSupply,\\n        uint8 _decimals,\\n        address _owner\\n    ) public OwnedwManager(_owner, _owner) SelfDestructible() Proxyable(_proxy) {\\n        tokenState = _tokenState;\\n\\n        name = _name;\\n        symbol = _symbol;\\n        totalSupply = _totalSupply;\\n        decimals = _decimals;\\n    }\\n    /* ========== VIEWS ========== */\\n\\n    /**\\n     * @notice Returns the ERC20 allowance of one party to spend on behalf of another.\\n     * @param owner The party authorising spending of their funds.\\n     * @param spender The party spending tokenOwner's funds.\\n     */\\n    function allowance(address owner, address spender) public view returns (uint) {\\n        return tokenState.allowance(owner, spender);\\n    }\\n\\n    /**\\n     * @notice Returns the ERC20 token balance of a given account.\\n     */ \\n    function balanceOf(address account) external view returns (uint) {\\n        return tokenState.balanceOf(account);\\n    }\\n\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice Set the address of the TokenState contract.\\n     * @dev This can be used to \\\"pause\\\" transfer functionality, by pointing the tokenState at 0x000..\\n     * as balances would be unreachable.\\n     */\\n    function setTokenState(TokenState _tokenState) external optionalProxy_onlyOwner {\\n        tokenState = _tokenState;\\n        emitTokenStateUpdated(address(_tokenState));\\n    }\\n\\n    function _internalTransfer(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        /* Disallow transfers to irretrievable-addresses. */\\n        require(to != address(0) && to != address(this) && to != address(proxy), \\\"Cannot transfer to this address\\\");\\n        require(tokenState.balanceOf(from) >= value, \\\"Not enough balance\\\");\\n\\n        // Insufficient balance will be handled by the safe subtraction.\\n        tokenState.setBalanceOf(from, tokenState.balanceOf(from).sub(value, \\\"Not enough balance\\\"));\\n        tokenState.setBalanceOf(to, tokenState.balanceOf(to).add(value));\\n\\n        // Emit a standard ERC20 transfer event*/\\n        emitTransfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Perform an ERC20 token transfer. Designed to be called by transfer functions possessing\\n     * the onlyProxy or optionalProxy modifiers.\\n     */\\n    function _transferByProxy(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        return _internalTransfer(from, to, value);\\n    }\\n\\n    /*\\n     * @dev Perform an ERC20 token transferFrom. Designed to be called by transferFrom functions\\n     * possessing the optionalProxy or optionalProxy modifiers.\\n     */\\n    function _transferFromByProxy(\\n        address sender,\\n        address from,\\n        address to,\\n        uint value\\n    ) internal returns (bool) {\\n        /* Insufficient allowance will be handled by the safe subtraction. */\\n        tokenState.setAllowance(from, sender, tokenState.allowance(from, sender).sub(value));\\n        return _internalTransfer(from, to, value);\\n    }\\n\\n    /**\\n     * @notice Approves spender to transfer on the message sender's behalf.\\n     */\\n    function approve(address spender, uint value) public optionalProxy returns (bool) {\\n        address sender = messageSender;\\n\\n        tokenState.setAllowance(sender, spender, value);\\n        emitApproval(sender, spender, value);\\n        return true;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n    function addressToBytes32(address input) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(input)));\\n    }\\n\\n    event Transfer(address indexed from, address indexed to, uint value);\\n    bytes32 internal constant TRANSFER_SIG = keccak256(\\\"Transfer(address,address,uint256)\\\");\\n\\n    function emitTransfer(\\n        address from,\\n        address to,\\n        uint value\\n    ) internal {\\n        proxy._emit(abi.encode(value), 3, TRANSFER_SIG, addressToBytes32(from), addressToBytes32(to), 0);\\n    }\\n\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    bytes32 internal constant APPROVAL_SIG = keccak256(\\\"Approval(address,address,uint256)\\\");\\n\\n    function emitApproval(\\n        address owner,\\n        address spender,\\n        uint value\\n    ) internal {\\n        proxy._emit(abi.encode(value), 3, APPROVAL_SIG, addressToBytes32(owner), addressToBytes32(spender), 0);\\n    }\\n\\n    event TokenStateUpdated(address newTokenState);\\n    bytes32 internal constant TOKENSTATEUPDATED_SIG = keccak256(\\\"TokenStateUpdated(address)\\\");\\n\\n    function emitTokenStateUpdated(address newTokenState) internal {\\n        proxy._emit(abi.encode(newTokenState), 1, TOKENSTATEUPDATED_SIG, 0, 0, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/AddressResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.7.5;\\n\\n// Inheritance\\nimport \\\"./OwnedwManager.sol\\\"; \\n// Internal references\\n//import \\\"./interfaces/IIssuer.sol\\\";\\nimport \\\"./MixinResolver.sol\\\";\\nimport \\\"./interfaces/IAddressResolver.sol\\\";\\n \\ninterface IMixinResolver_ {\\n    function rebuildCache() external;\\n}  \\n\\ncontract AddressResolver is   OwnedwManager, IAddressResolver {     \\n    mapping(bytes32 => address) public repository;\\n\\n    constructor(address _owner) OwnedwManager(_owner, _owner)  {}\\n \\n    /* ========== RESTRICTED FUNCTIONS ========== */\\n\\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\\n        require(names.length == destinations.length, \\\"Input lengths must match\\\");\\n\\n        for (uint i = 0; i < names.length; i++) {\\n            bytes32 name = names[i];\\n            address destination = destinations[i];\\n            repository[name] = destination;\\n            emit AddressImported(name, destination);\\n        }\\n    }\\n\\n    /* ========= PUBLIC FUNCTIONS ========== */\\n\\n    function rebuildCaches(address[] calldata destinations) external {\\n        for (uint i = 0; i < destinations.length; i++) {\\n            IMixinResolver_(destinations[i]).rebuildCache();\\n        }\\n    }\\n\\n    /* ========== VIEWS ========== */\\n\\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\\n        for (uint i = 0; i < names.length; i++) {\\n            if (repository[names[i]] != destinations[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function getAddress(bytes32 name) external override view returns (address) {\\n        return repository[name];\\n    }\\n\\n    function requireAndGetAddress(bytes32 name, string calldata reason) external override view returns (address) {\\n        address _foundAddress = repository[name];\\n        require(_foundAddress != address(0), reason);\\n        return _foundAddress;\\n    }\\n\\n    function getSynth(bytes32 key) external override view returns (address) {\\n        //IIssuer issuer = IIssuer(repository[\\\"Issuer\\\"]);\\n        //require(address(issuer) != address(0), \\\"Cannot find Issuer address\\\");\\n        //return address(issuer.synths(key));\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event AddressImported(bytes32 name, address destination);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"contract TokenState\",\"name\":\"_tokenState\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_resolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"CacheUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Issued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyAddress\",\"type\":\"address\"}],\"name\":\"ProxyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBeneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructBeneficiaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"selfDestructDelay\",\"type\":\"uint256\"}],\"name\":\"SelfDestructInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"SelfDestructTerminated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"SelfDestructed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTokenState\",\"type\":\"address\"}],\"name\":\"TokenStateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SELFDESTRUCT_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN_SYMBOL\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiateSelfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initiationTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isResolverCached\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isEscrowed\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"internalType\":\"contract Proxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rebuildCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolverAddressesRequired\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"addresses\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestructBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"selfDestructInitiated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"setMessageSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setSelfDestructBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"_tokenState\",\"type\":\"address\"}],\"name\":\"setTokenState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"terminateSelfDestruct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenState\",\"outputs\":[{\"internalType\":\"contract TokenState\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Elysian", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000094193e064cf800d5abfa66ad61840dd216b48c5a0000000000000000000000001f14b16de1f6a3155c95f02659efb5d181e97ba0000000000000000000000000d02522de79947c76add6d324f27f816b70230e850000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ee0c644374c41f3443c01a8ec5bb952cb85352f5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}