{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/ProtocolUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {DSMath} from \\\"../library/DSMath.sol\\\";\\nimport {ProtocolWETH, WethInterface} from \\\"./ProtocolWETH.sol\\\";\\n\\ncontract ProtocolUniswapV2 is DSMath, ProtocolWETH {\\n    address public immutable  router;\\n\\n    address public constant ethAddr =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    constructor(address _wethAddress, address _uniswapV2RouterAddress)\\n        ProtocolWETH(_wethAddress)\\n    {\\n        router = _uniswapV2RouterAddress;\\n    }\\n\\n    event Buy(\\n        address indexed buyToken,\\n        address indexed sellToken,\\n        uint256 buyAmt,\\n        uint256 sellAmt,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event Sell(\\n        address indexed buyToken,\\n        address indexed sellToken,\\n        uint256 buyAmt,\\n        uint256 sellAmt,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event AddLiquidity(\\n        address indexed tokenA,\\n        address indexed tokenB,\\n        uint256 amtA,\\n        uint256 amtB,\\n        uint256 uniAmount,\\n        uint256 getId,\\n        uint256 setId\\n    );\\n\\n    event RemoveLiquidity(\\n        address indexed tokenA,\\n        address indexed tokenB,\\n        uint256 amountA,\\n        uint256 amountB,\\n        uint256 uniAmount,\\n        uint256 getId,\\n        uint256[] setId\\n    );\\n\\n    function buyToken(\\n        address buyAddr,\\n        address sellAddr,\\n        uint256 buyAmt,\\n        uint256 unitAmt\\n    ) public payable returns (uint256 _sellAmt) {\\n        uint256 _buyAmt = buyAmt;\\n\\n        (WethInterface _buyAddr, WethInterface _sellAddr) = changeEthAddress(\\n            buyAddr,\\n            sellAddr\\n        );\\n\\n        address[] memory paths = getPaths(\\n            address(_buyAddr),\\n            address(_sellAddr)\\n        );\\n\\n        uint256 _slippageAmt = convert18ToDec(\\n            _sellAddr.decimals(),\\n            wmul(unitAmt, convertTo18(_buyAddr.decimals(), _buyAmt))\\n        );\\n\\n        checkPair(paths);\\n\\n        uint256 _expectedAmt = getExpectedSellAmt(paths, _buyAmt);\\n\\n        require(_slippageAmt >= _expectedAmt, \\\"Too much slippage\\\");\\n\\n        bool isEth = address(_sellAddr) == wethAddr;\\n\\n        convertEthToWeth(isEth, _sellAddr, _expectedAmt);\\n\\n        approve(_sellAddr, address(router), _expectedAmt);\\n\\n        _sellAmt = IUniswapV2Router02(router).swapTokensForExactTokens(\\n            _buyAmt,\\n            _expectedAmt,\\n            paths,\\n            address(this),\\n            block.timestamp + 1\\n        )[0];\\n\\n        isEth = address(_buyAddr) == wethAddr;\\n\\n        convertWethToEth(isEth, _buyAddr, _buyAmt);\\n    }\\n\\n    function sellToken(\\n        address buyAddr,\\n        address sellAddr,\\n        uint256 sellAmt,\\n        uint256 unitAmt\\n    ) public payable returns (uint256 _buyAmt) {\\n        uint256 _sellAmt = sellAmt;\\n        (WethInterface _buyAddr, WethInterface _sellAddr) = changeEthAddress(\\n            buyAddr,\\n            sellAddr\\n        );\\n        address[] memory paths = getPaths(\\n            address(_buyAddr),\\n            address(_sellAddr)\\n        );\\n\\n        if (_sellAmt == type(uint256).max) {\\n            _sellAmt = sellAddr == ethAddr\\n                ? address(this).balance\\n                : _sellAddr.balanceOf(address(this));\\n        }\\n\\n        uint256 _slippageAmt = convert18ToDec(\\n            _buyAddr.decimals(),\\n            wmul(unitAmt, convertTo18(_sellAddr.decimals(), _sellAmt))\\n        );\\n\\n        checkPair(paths);\\n        uint256 _expectedAmt = getExpectedBuyAmt(paths, _sellAmt);\\n        require(_slippageAmt <= _expectedAmt, \\\"Too much slippage\\\");\\n\\n        bool isEth = address(_sellAddr) == wethAddr;\\n        convertEthToWeth(isEth, _sellAddr, _sellAmt);\\n        approve(_sellAddr, address(router), _sellAmt);\\n\\n        _buyAmt = IUniswapV2Router02(router).swapExactTokensForTokens(\\n            _sellAmt,\\n            _expectedAmt,\\n            paths,\\n            address(this),\\n            block.timestamp + 1\\n        )[1];\\n\\n        isEth = address(_buyAddr) == wethAddr;\\n        convertWethToEth(isEth, _buyAddr, _buyAmt);\\n    }\\n\\n    function addTokenLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amtA,\\n        uint256 unitAmt,\\n        uint256 slippage\\n    )\\n        public\\n        payable\\n        returns (\\n            uint256 _amtA,\\n            uint256 _amtB,\\n            uint256 _uniAmt\\n        )\\n    {\\n        (_amtA, _amtB, _uniAmt) = _addLiquidity(\\n            tokenA,\\n            tokenB,\\n            amtA,\\n            unitAmt,\\n            slippage\\n        );\\n    }\\n\\n    function removeTokenLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 uniAmt,\\n        uint256 unitAmtA,\\n        uint256 unitAmtB\\n    )\\n        public\\n        payable\\n        returns (\\n            uint256 _amtA,\\n            uint256 _amtB,\\n            uint256 _uniAmt\\n        )\\n    {\\n        (_amtA, _amtB, _uniAmt) = _removeLiquidity(\\n            tokenA,\\n            tokenB,\\n            uniAmt,\\n            unitAmtA,\\n            unitAmtB\\n        );\\n    }\\n\\n    function getExpectedBuyAmt(address[] memory paths, uint256 sellAmt)\\n        internal\\n        view\\n        returns (uint256 buyAmt)\\n    {\\n        uint256[] memory amts = IUniswapV2Router02(router).getAmountsOut(sellAmt, paths);\\n        buyAmt = amts[1];\\n    }\\n\\n    function getExpectedSellAmt(address[] memory paths, uint256 buyAmt)\\n        internal\\n        view\\n        returns (uint256 sellAmt)\\n    {\\n        uint256[] memory amts = IUniswapV2Router02(router).getAmountsIn(buyAmt, paths);\\n        sellAmt = amts[0];\\n    }\\n\\n    function checkPair(address[] memory paths) internal view {\\n        address pair = IUniswapV2Factory(IUniswapV2Router02(router).factory()).getPair(\\n            paths[0],\\n            paths[1]\\n        );\\n        require(pair != address(0), \\\"No-exchange-address\\\");\\n    }\\n\\n    function getPaths(address buyAddr, address sellAddr)\\n        internal\\n        pure\\n        returns (address[] memory paths)\\n    {\\n        paths = new address[](2);\\n        paths[0] = address(sellAddr);\\n        paths[1] = address(buyAddr);\\n    }\\n\\n    function getMinAmount(\\n        WethInterface token,\\n        uint256 amt,\\n        uint256 slippage\\n    ) internal view returns (uint256 minAmt) {\\n        uint256 _amt18 = convertTo18(token.decimals(), amt);\\n        minAmt = wmul(_amt18, sub(WAD, slippage));\\n        minAmt = convert18ToDec(token.decimals(), minAmt);\\n    }\\n\\n    function _addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 _amt,\\n        uint256 unitAmt,\\n        uint256 slippage\\n    )\\n        internal\\n        returns (\\n            uint256 _amtA,\\n            uint256 _amtB,\\n            uint256 _liquidity\\n        )\\n    {\\n        (WethInterface _tokenA, WethInterface _tokenB) = changeEthAddress(\\n            tokenA,\\n            tokenB\\n        );\\n\\n        _amtA = _amt == type(uint256).max\\n            ? getTokenBal(WethInterface(tokenA))\\n            : _amt;\\n        _amtB = convert18ToDec(\\n            _tokenB.decimals(),\\n            wmul(unitAmt, convertTo18(_tokenA.decimals(), _amtA))\\n        );\\n\\n        bool isEth = address(_tokenA) == wethAddr;\\n        convertEthToWeth(isEth, _tokenA, _amtA);\\n\\n        isEth = address(_tokenB) == wethAddr;\\n        convertEthToWeth(isEth, _tokenB, _amtB);\\n\\n        approve(_tokenA, address(router), _amtA);\\n        approve(_tokenB, address(router), _amtB);\\n\\n        uint256 minAmtA = getMinAmount(_tokenA, _amtA, slippage);\\n        uint256 minAmtB = getMinAmount(_tokenB, _amtB, slippage);\\n        (_amtA, _amtB, _liquidity) = IUniswapV2Router02(router).addLiquidity(\\n            address(_tokenA),\\n            address(_tokenB),\\n            _amtA,\\n            _amtB,\\n            minAmtA,\\n            minAmtB,\\n            address(this),\\n            block.timestamp + 1\\n        );\\n    }\\n\\n    function _removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 _amt,\\n        uint256 unitAmtA,\\n        uint256 unitAmtB\\n    )\\n        internal\\n        returns (\\n            uint256 _amtA,\\n            uint256 _amtB,\\n            uint256 _uniAmt\\n        )\\n    {\\n        WethInterface _tokenA;\\n        WethInterface _tokenB;\\n        (_tokenA, _tokenB, _uniAmt) = _getRemoveLiquidityData(\\n            tokenA,\\n            tokenB,\\n            _amt\\n        );\\n        {\\n            uint256 minAmtA = convert18ToDec(\\n                _tokenA.decimals(),\\n                wmul(unitAmtA, _uniAmt)\\n            );\\n            uint256 minAmtB = convert18ToDec(\\n                _tokenB.decimals(),\\n                wmul(unitAmtB, _uniAmt)\\n            );\\n            (_amtA, _amtB) = IUniswapV2Router02(router).removeLiquidity(\\n                address(_tokenA),\\n                address(_tokenB),\\n                _uniAmt,\\n                minAmtA,\\n                minAmtB,\\n                address(this),\\n                block.timestamp + 1\\n            );\\n        }\\n\\n        bool isEth = address(_tokenA) == wethAddr;\\n        convertWethToEth(isEth, _tokenA, _amtA);\\n\\n        isEth = address(_tokenB) == wethAddr;\\n        convertWethToEth(isEth, _tokenB, _amtB);\\n    }\\n\\n    function _getRemoveLiquidityData(\\n        address tokenA,\\n        address tokenB,\\n        uint256 _amt\\n    )\\n        internal\\n        returns (\\n            WethInterface _tokenA,\\n            WethInterface _tokenB,\\n            uint256 _uniAmt\\n        )\\n    {\\n        (_tokenA, _tokenB) = changeEthAddress(tokenA, tokenB);\\n        address exchangeAddr = IUniswapV2Factory(IUniswapV2Router02(router).factory()).getPair(\\n            address(_tokenA),\\n            address(_tokenB)\\n        );\\n        require(exchangeAddr != address(0), \\\"pair-not-found.\\\");\\n\\n        WethInterface uniToken = WethInterface(exchangeAddr);\\n        _uniAmt = _amt == type(uint256).max\\n            ? uniToken.balanceOf(address(this))\\n            : _amt;\\n        approve(uniToken, address(router), _uniAmt);\\n    }\\n\\n    function changeEthAddress(address buyAddress, address sellAddress)\\n        internal\\n        view\\n        returns (WethInterface _buy, WethInterface _sell)\\n    {\\n        _buy = buyAddress == ethAddr\\n            ? WethInterface(wethAddr)\\n            : WethInterface(buyAddress);\\n        _sell = sellAddress == ethAddr\\n            ? WethInterface(wethAddr)\\n            : WethInterface(sellAddress);\\n    }\\n\\n    function getTokenBal(WethInterface token)\\n        internal\\n        view\\n        returns (uint256 _amt)\\n    {\\n        _amt = address(token) == ethAddr\\n            ? address(this).balance\\n            : token.balanceOf(address(this));\\n    }\\n\\n    function getSellAmount(\\n        address buyAddr,\\n        address sellAddr,\\n        uint256 buyAmt\\n    ) external view returns (uint256 amounts) {\\n        uint256 _buyAmt = buyAmt;\\n        (WethInterface _buyAddr, WethInterface _sellAddr) = changeEthAddress(\\n            buyAddr,\\n            sellAddr\\n        );\\n        address[] memory paths = getPaths(\\n            address(_buyAddr),\\n            address(_sellAddr)\\n        );\\n\\n        checkPair(paths);\\n        amounts = getExpectedSellAmt(paths, _buyAmt);\\n    }\\n}\\n\\ninterface IUniswapV2Router02 {\\n    function factory() external pure returns (address);\\n\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    )\\n        external\\n        returns (\\n            uint256 amountA,\\n            uint256 amountB,\\n            uint256 liquidity\\n        );\\n\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint256 liquidity,\\n        uint256 amountAMin,\\n        uint256 amountBMin,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256 amountA, uint256 amountB);\\n\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function swapTokensForExactTokens(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external returns (uint256[] memory amounts);\\n\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) external pure returns (uint256 amountB);\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountOut);\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) external pure returns (uint256 amountIn);\\n\\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n\\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\\n        external\\n        view\\n        returns (uint256[] memory amounts);\\n}\\n\\ninterface IUniswapV2Factory {\\n    function getPair(address tokenA, address tokenB)\\n        external\\n        view\\n        returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function feeTo() external view returns (address);\\n\\n    function feeToSetter() external view returns (address);\\n\\n    function createPair(address tokenA, address tokenB)\\n        external\\n        returns (address pair);\\n}\\n\"\r\n    },\r\n    \"contracts/library/DSMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\ncontract DSMath {\\n\\n    uint256 constant WAD = 10**18;\\n    \\n    uint256 constant RAY = 10**27;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.add(x, y);\\n    }\\n\\n    function sub(uint256 x, uint256 y)\\n        internal\\n        pure\\n        virtual\\n        returns (uint256 z)\\n    {\\n        z = SafeMath.sub(x, y);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.mul(x, y);\\n    }\\n\\n    function div(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.div(x, y);\\n    }\\n\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.add(SafeMath.mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.add(SafeMath.mul(x, WAD), y / 2) / y;\\n    }\\n\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.add(SafeMath.mul(x, RAY), y / 2) / y;\\n    }\\n\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = SafeMath.add(SafeMath.mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    function toInt(uint256 x) internal pure returns (int256 y) {\\n        y = int256(x);\\n        require(y >= 0, \\\"int-overflow\\\");\\n    }\\n\\n    function toRad(uint256 wad) internal pure returns (uint256 rad) {\\n        rad = mul(wad, 10**27);\\n    }\\n\\n    function convert18ToDec(uint256 _dec, uint256 _amt)\\n        internal\\n        pure\\n        returns (uint256 amt)\\n    {\\n        amt = (_amt / 10**(18 - _dec));\\n    }\\n\\n    function convertTo18(uint256 _dec, uint256 _amt)\\n        internal\\n        pure\\n        returns (uint256 amt)\\n    {\\n        amt = mul(_amt, 10**(18 - _dec));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/ProtocolWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface WethInterface {\\n    function approve(address, uint256) external;\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n    function decimals() external view returns (uint);\\n    function balanceOf(address) external view returns (uint);\\n}\\n\\nabstract contract ProtocolWETH {\\n\\n    address public immutable wethAddr;\\n\\n    constructor(address _wethAddr) {\\n        wethAddr = _wethAddr;\\n    }\\n\\n    function convertEthToWeth(\\n        bool isEth,\\n        WethInterface token,\\n        uint256 amount\\n    ) internal {\\n        if (isEth) token.deposit{value: amount}();\\n    }\\n\\n    function convertWethToEth(\\n        bool isEth,\\n        WethInterface token,\\n        uint256 amount\\n    ) internal {\\n        if (isEth) {\\n            approve(token, address(token), amount);\\n            token.withdraw(amount);\\n        }\\n    }\\n\\n    function approve(\\n        WethInterface token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        try token.approve(spender, amount) {} catch {\\n            token.approve(spender, 0);\\n            token.approve(spender, amount);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wethAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV2RouterAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amtB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uniAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"AddLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"uniAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"setId\",\"type\":\"uint256[]\"}],\"name\":\"RemoveLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sellToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sellAmt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"getId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"setId\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amtA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippage\",\"type\":\"uint256\"}],\"name\":\"addTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amtA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amtB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_uniAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitAmt\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_sellAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"buyAmt\",\"type\":\"uint256\"}],\"name\":\"getSellAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amounts\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"uniAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitAmtA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitAmtB\",\"type\":\"uint256\"}],\"name\":\"removeTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amtA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amtB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_uniAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sellAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sellAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unitAmt\",\"type\":\"uint256\"}],\"name\":\"sellToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyAmt\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wethAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ProtocolUniswapV2", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc20000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}