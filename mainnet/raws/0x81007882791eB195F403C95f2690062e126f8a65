{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/PolysPlay.sol\": {\r\n      \"content\": \"//\\\"SPDX-License-Identifier: GPL-3.0\\n\\n/*******************************************\\n              _                       _\\n             | |                     | |\\n  _ __   ___ | |_   _ ___   __ _ _ __| |_\\n | '_ \\\\ / _ \\\\| | | | / __| / _` | '__| __|\\n | |_) | (_) | | |_| \\\\__ \\\\| (_| | |  | |_\\n | .__/ \\\\___/|_|\\\\__, |___(_)__,_|_|   \\\\__|\\n | |             __/ |\\n |_|            |___/\\n\\n a homage to math, geometry and cryptography.\\n\\n********************************************/\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IPolys.sol\\\";\\n\\ncontract PolysPlay is Ownable {\\n\\n    struct Game {\\n        uint16 playNumber;\\n        uint16 lastPolyPlayed;\\n        uint8 compositionStreak;\\n        uint8 paletteStreak;\\n        uint8 doublingStreak;\\n        bool isWildcard;\\n    }\\n\\n    // Parameters\\n    // -------------------------------------------\\n    // The duration of a game\\n    uint public gameDuration = 1 days;\\n\\n    // The minimum amount of time left in the game after a play is made\\n    uint public timeBuffer;\\n\\n    // Percentage that goes to charity from 0 to 100\\n    uint public charityShare;\\n\\n    // Percentage that goes to development from 0 to 100\\n    uint public devShare;\\n\\n    // Minimum amount to play a card\\n    uint public minEntry = 0.015 ether;\\n\\n    // When the contract is paused the current game can end, but you can't start a new one.\\n    // We will probably pause the contract if we release a new version of the game.\\n    bool public isPaused = true;\\n\\n    // If set to true this contract will create wildcard games where the rules have two changes:\\n    // 1) Polys with joker as the composition can always be played (jokers are the wildcard)\\n    // 2) Placing a circled Poly forces the next poly to match the *palette* (instead of forcing a composition match)\\n    bool public spawnWildcardGames;\\n\\n    // Entry fee doubles every time the streak increases by \u00b4streakDoubling\u00b4\\n    uint8 public spawnDoublingStreak;\\n\\n    // State Variables\\n    // -------------------------------------------\\n    // The end time for the current game. If endTime = 0, no game is being played.\\n    uint public endTime;\\n\\n    uint public currentGameId;\\n\\n    mapping (uint => Game) public gameIdToGame;\\n    mapping (uint => mapping(uint16 => uint16)) public gameIdToBoard;\\n\\n    // Constants and Immutables\\n    // -------------------------------------------\\n    IPolys immutable private _polys;\\n    address constant private _charityWallet = 0xE00327f0f5f5F55d01C2FC6a87ddA1B8E292Ac79;\\n\\n    // Events\\n    // -------------------------------------------\\n    event GameStarted(uint gameId, address player, uint16 polyId, uint minEntry);\\n    event GameEnded(uint gameId, address winner, uint prize, uint charityDonation);\\n    event PolyPlayed(uint gameId, uint16 playNumber, address player, uint16 polyId, bool extended);\\n    event GameExtended(uint gameId, uint endTime);\\n\\n    event NewDoublingStreak(uint8 doublingStreak);\\n    event NewWildcardFlag(bool isWildCardGame);\\n\\n    constructor(address polys, uint _timeBuffer, uint _charityShare, uint _devShare, uint8 _doublingStreak) {\\n        _polys = IPolys(polys);\\n        timeBuffer = _timeBuffer;\\n        charityShare = _charityShare;\\n        devShare = _devShare;\\n        spawnDoublingStreak = _doublingStreak;\\n    }\\n\\n    function newGame(uint16 polyId) payable external {\\n        require(endTime == 0, \\\"1\\\");\\n        require(msg.value >= minEntry, \\\"2\\\");\\n        require(_polys.ownerOf(polyId) == msg.sender, \\\"3\\\");\\n        require(!isPaused, \\\"11\\\");\\n        _newGame(polyId);\\n    }\\n\\n    function playPoly(uint16 polyId) payable external {\\n        require(block.timestamp < endTime, \\\"4\\\");\\n        require(_polys.ownerOf(polyId) == msg.sender, \\\"3\\\");\\n        require(gameIdToBoard[currentGameId][polyId] == 0, \\\"5\\\");\\n        require(tx.origin == msg.sender, \\\"10\\\");\\n        Game memory game = gameIdToGame[currentGameId];\\n        require(msg.value == _getEntryFee(game), \\\"2\\\");\\n\\n        uint compositionId = _propertyOf(polyId, true);\\n        bool sameComposition = compositionId == _propertyOf(game.lastPolyPlayed, true);\\n        bool samePalette = _propertyOf(polyId, false) == _propertyOf(game.lastPolyPlayed, false);\\n\\n        if (game.isWildcard) {\\n            if (compositionId != 38) { // if it doesn't have the composition of the joker\\n                if (game.lastPolyPlayed < 101) {\\n                    require(sameComposition, \\\"8\\\");\\n                } else if (game.lastPolyPlayed < 201) {\\n                    require(samePalette, \\\"8\\\");\\n                } else {\\n                    require(sameComposition || samePalette, \\\"8\\\");\\n                }\\n            }\\n        } else {\\n            if (game.lastPolyPlayed < 201) {\\n                require(sameComposition, \\\"8\\\");\\n            } else {\\n                require(sameComposition || samePalette, \\\"8\\\");\\n            }\\n        }\\n\\n        // Extend the game if the play was received within `timeBuffer` of the game endTime\\n        bool extended = endTime - block.timestamp < timeBuffer;\\n        if (extended) {\\n            endTime = block.timestamp + timeBuffer;\\n            emit GameExtended(currentGameId, endTime);\\n        }\\n\\n        gameIdToBoard[currentGameId][polyId] = game.lastPolyPlayed;\\n        game.compositionStreak = sameComposition ? game.compositionStreak + 1 : 1;\\n        game.paletteStreak = samePalette ? game.paletteStreak + 1 : 1;\\n        game.lastPolyPlayed = polyId;\\n        game.playNumber++;\\n        gameIdToGame[currentGameId] = game;\\n\\n        emit PolyPlayed(currentGameId, game.playNumber, msg.sender, polyId, extended);\\n    }\\n\\n    function endGame() external {\\n        require(endTime != 0, \\\"6\\\");\\n        require(block.timestamp > endTime, \\\"7\\\");\\n        require(tx.origin == msg.sender, \\\"10\\\");\\n\\n        endTime = 0;\\n        bool startNewGame = !isPaused && address(this).balance > 3 * minEntry;\\n\\n        Game memory currentGame = gameIdToGame[currentGameId];\\n        address payable winner = payable(_polys.ownerOf(currentGame.lastPolyPlayed));\\n\\n        uint prize = getPrize();\\n        uint charityDonation = prize * charityShare / (100 - charityShare - devShare);\\n        uint devPayment = prize * devShare / (100 - charityShare - devShare);\\n\\n        // Make payments\\n        (bool success1,) = winner.call{value: prize}('');\\n        (bool success2,) = _charityWallet.call{value: charityDonation}('');\\n        (bool success3,) = owner().call{value: devPayment}('');\\n        require(success1 && success2 && success3, \\\"9\\\");\\n\\n        emit GameEnded(currentGameId, winner, prize, charityDonation);\\n        if (startNewGame) {\\n            _newGame(currentGame.lastPolyPlayed);\\n        }\\n    }\\n\\n    // Getters functions\\n    // -------------------------------------------\\n    function getPrize() public view returns (uint) {\\n        return _getPrize(address(this).balance);\\n    }\\n\\n    function getPrizeForNextPlay() public view returns (uint) {\\n        return _getPrize(address(this).balance + getEntryFeeCurrentGame());\\n    }\\n\\n    function getCharityDonation() public view returns (uint) {\\n        return getPrize() * charityShare / (100 - charityShare - devShare);\\n    }\\n\\n    function getEntryFeeCurrentGame() public view returns (uint) {\\n        if (endTime == 0)\\n            return minEntry;\\n        Game memory currentGame = gameIdToGame[currentGameId];\\n        return _getEntryFee(currentGame);\\n    }\\n\\n    // Internal functions\\n    // -------------------------------------------\\n    function _getPrize(uint balance) internal view returns (uint) {\\n        if (!isPaused && balance > 3 * minEntry) {\\n            // reserve fee entry to start the next game\\n            balance -= minEntry;\\n        }\\n        return balance * (100 - charityShare - devShare)/100;\\n    }\\n\\n    function _newGame(uint16 polyId) internal {\\n        endTime = block.timestamp + gameDuration;\\n\\n        currentGameId++;\\n        gameIdToGame[currentGameId] = Game(1, polyId, 1, 1, spawnDoublingStreak, spawnWildcardGames);\\n        gameIdToBoard[currentGameId][polyId] = 2000;\\n\\n        emit GameStarted(currentGameId, _polys.ownerOf(polyId), polyId, minEntry);\\n    }\\n\\n    function _getEntryFee(Game memory game) internal view returns (uint) {\\n        uint maxStreak = game.paletteStreak > game.compositionStreak\\n        ? game.paletteStreak : game.compositionStreak;\\n        return minEntry << (maxStreak / game.doublingStreak);\\n    }\\n\\n    function _propertyOf(uint16 polyId, bool isComposition) internal view returns (uint8) {\\n        // If poly is Original\\n        if (polyId < 101) {\\n            return uint8(polyId);\\n        } else if (polyId < 201) { // If poly is Circle\\n            return uint8(polyId - 100);\\n        } else { // If poly is Mixed\\n            (uint polyA, uint polyB) = _polys.parentsOfMix(polyId);\\n            if (isComposition){\\n                return uint8(polyA);\\n            } else{\\n                return uint8(polyB);\\n            }\\n        }\\n    }\\n\\n    // Setter functions\\n    // -------------------------------------------\\n    function setWildCardFlag(bool _isWildCardGame) external onlyOwner {\\n        spawnWildcardGames = _isWildCardGame;\\n        emit NewWildcardFlag(_isWildCardGame);\\n    }\\n\\n    function setStreakDoubling(uint8 _doublingStreak) external onlyOwner {\\n        spawnDoublingStreak = _doublingStreak;\\n        emit NewDoublingStreak(spawnDoublingStreak);\\n    }\\n\\n    function setMinEntry(uint _minEntry) external onlyOwner {\\n        require(endTime == 0); // The game rules can't change in the middle of a game\\n        minEntry = _minEntry;\\n    }\\n\\n    function setGameDuration(uint _gameDuration) external onlyOwner {\\n        gameDuration = _gameDuration;\\n    }\\n\\n    function setTimeBuffer(uint _timeBuffer) external onlyOwner {\\n        timeBuffer = _timeBuffer;\\n    }\\n\\n    function setCharityWalletShare(uint _charityShare) external onlyOwner {\\n        require(endTime == 0); // The game rules can't change in the middle of a game\\n        charityShare = _charityShare;\\n    }\\n\\n    function setDevShare(uint _devShare) external onlyOwner {\\n        require(endTime == 0); // The game rules can't change in the middle of a game\\n        devShare = _devShare;\\n    }\\n\\n    function setPause(bool _pause) external onlyOwner {\\n        isPaused = _pause;\\n    }\\n}\\n\\n// Errors:\\n// 1: You can't start a new game before ending the previous\\n// 2: The eth amount is not correct\\n// 3: You don't own that polys\\n// 4: This game is over\\n// 5: That polys was already played\\n// 6: Game hasn't started\\n// 7: Game hasn't finished\\n// 8: This is not a valid play\\n// 9: Payment failed\\n// 10: Only users can play\\n// 11: Can't start a new game when the contract is paused\"\r\n    },\r\n    \"/contracts/interfaces/IPolys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.10;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\ninterface IPolys is IERC721 {\\n    function tokenNameOf(uint polyId) external view returns (string memory);\\n    function parentsOfMix(uint256 mixId) external view returns (uint256, uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"polys\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_timeBuffer\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_charityShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_devShare\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_doublingStreak\",\"type\":\"uint8\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"charityDonation\",\"type\":\"uint256\"}],\"name\":\"GameEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"GameExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"polyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minEntry\",\"type\":\"uint256\"}],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"doublingStreak\",\"type\":\"uint8\"}],\"name\":\"NewDoublingStreak\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isWildCardGame\",\"type\":\"bool\"}],\"name\":\"NewWildcardFlag\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"playNumber\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"polyId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"extended\",\"type\":\"bool\"}],\"name\":\"PolyPlayed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"charityShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentGameId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"gameIdToBoard\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameIdToGame\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"playNumber\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastPolyPlayed\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"compositionStreak\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"paletteStreak\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"doublingStreak\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"isWildcard\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCharityDonation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntryFeeCurrentGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrizeForNextPlay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"polyId\",\"type\":\"uint16\"}],\"name\":\"newGame\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"polyId\",\"type\":\"uint16\"}],\"name\":\"playPoly\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_charityShare\",\"type\":\"uint256\"}],\"name\":\"setCharityWalletShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_devShare\",\"type\":\"uint256\"}],\"name\":\"setDevShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gameDuration\",\"type\":\"uint256\"}],\"name\":\"setGameDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minEntry\",\"type\":\"uint256\"}],\"name\":\"setMinEntry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_pause\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_doublingStreak\",\"type\":\"uint8\"}],\"name\":\"setStreakDoubling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeBuffer\",\"type\":\"uint256\"}],\"name\":\"setTimeBuffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isWildCardGame\",\"type\":\"bool\"}],\"name\":\"setWildCardFlag\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spawnDoublingStreak\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spawnWildcardGames\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeBuffer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PolysPlay", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000007effbc54d8066e3717230fff5d245d7c11ad4d22000000000000000000000000000000000000000000000000000000000000012c000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000000050000000000000000000000000000000000000000000000000000000000000004", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}