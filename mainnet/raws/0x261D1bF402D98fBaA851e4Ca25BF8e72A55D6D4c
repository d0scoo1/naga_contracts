{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// Open0x Ownable Minified (by 0xInuarashi)\r\nabstract contract Ownable {\r\n    address public owner; \r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner { require(owner == msg.sender, \"Not Owner!\"); _; }\r\n    function transferOwnership(address new_) external onlyOwner { owner = new_; }\r\n}\r\n\r\n// Open0x Royalties Governance by 0xInuarashi\r\n// This is basically PayableGovernance but deployed as a standalone contract\r\n// Also, we modified withdraw function so that anyone from the governance\r\n// is able to withdraw the funds for everyone. However, emergency is still\r\n// onlyOwner.\r\n\r\ncontract RoyaltiesGovernance is Ownable {\r\n    // Special Access\r\n    address public payableGovernanceSetter;\r\n    constructor() payable { payableGovernanceSetter = msg.sender; }\r\n    modifier onlyPayableGovernanceSetter {\r\n        require(msg.sender == payableGovernanceSetter, \r\n            \"PayableGovernance: Caller is not Setter!\"); _; }\r\n    function reouncePayableGovernancePermissions() public onlyPayableGovernanceSetter {\r\n        payableGovernanceSetter = address(0x0); }\r\n\r\n    // Receivable Fallback\r\n    event Received(address from, uint amount);\r\n    receive() external payable { emit Received(msg.sender, msg.value); }\r\n\r\n    // Required Variables\r\n    address payable[] internal _payableGovernanceAddresses;\r\n    uint256[] internal _payableGovernanceShares;    \r\n    mapping(address => bool) public addressToEmergencyUnlocked;\r\n\r\n    // Withdraw Functionality\r\n    function _withdraw(address payable address_, uint256 amount_) internal {\r\n        (bool success, ) = payable(address_).call{value: amount_}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    // Governance Functions\r\n    function setPayableGovernanceShareholders(address payable[] memory addresses_,\r\n    uint256[] memory shares_) public onlyPayableGovernanceSetter {\r\n        require(_payableGovernanceAddresses.length == 0 \r\n            && _payableGovernanceShares.length == 0, \r\n            \"Payable Governance already set! To set again, reset first!\");\r\n        require(addresses_.length == shares_.length, \r\n            \"Address and Shares length mismatch!\");\r\n\r\n        uint256 _totalShares;\r\n        \r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            _totalShares += shares_[i];\r\n            _payableGovernanceAddresses.push(addresses_[i]);\r\n            _payableGovernanceShares.push(shares_[i]);\r\n        }\r\n        require(_totalShares == 1000, \"Total Shares is not 1000!\");\r\n    }\r\n    function resetPayableGovernanceShareholders() public onlyPayableGovernanceSetter {\r\n        while (_payableGovernanceAddresses.length != 0) {\r\n            _payableGovernanceAddresses.pop(); }\r\n        while (_payableGovernanceShares.length != 0) {\r\n            _payableGovernanceShares.pop(); }\r\n    }\r\n\r\n    // Governance View Functions\r\n    function balance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    function payableGovernanceAddresses() public view \r\n    returns (address payable[] memory) {\r\n        return _payableGovernanceAddresses;\r\n    }\r\n    function payableGovernanceShares() public view returns (uint256[] memory) {\r\n        return _payableGovernanceShares;\r\n    }\r\n\r\n    // Withdraw Functions\r\n    function withdrawEther() public onlyShareholder {\r\n        // require that there has been payable governance set.\r\n        require(_payableGovernanceAddresses.length > 0 \r\n            && _payableGovernanceShares.length > 0, \r\n            \"Payable governance not set yet!\");\r\n         // this should never happen\r\n        require(_payableGovernanceAddresses.length \r\n            == _payableGovernanceShares.length, \r\n            \"Payable governance length mismatch!\");\r\n        \r\n        // now, we check that the governance shares equal to 1000.\r\n        uint256 _totalPayableShares;\r\n        for (uint256 i = 0; i < _payableGovernanceShares.length; i++) {\r\n            _totalPayableShares += _payableGovernanceShares[i]; }\r\n        require(_totalPayableShares == 1000, \"Payable Governance Shares is not 1000!\");\r\n        \r\n        // // now, we start the withdrawal process if all conditionals pass\r\n        // store current balance in local memory\r\n        uint256 _totalETH = address(this).balance; \r\n\r\n        // withdraw loop for payable governance\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            uint256 _ethToWithdraw = ((_totalETH * _payableGovernanceShares[i]) / 1000);\r\n            _withdraw(_payableGovernanceAddresses[i], _ethToWithdraw);\r\n        }\r\n    }\r\n\r\n    function viewWithdrawAmounts() public view onlyShareholder returns (uint256[] memory) {\r\n        // require that there has been payable governance set.\r\n        require(_payableGovernanceAddresses.length > 0 \r\n            && _payableGovernanceShares.length > 0, \r\n            \"Payable governance not set yet!\");\r\n         // this should never happen\r\n        require(_payableGovernanceAddresses.length \r\n            == _payableGovernanceShares.length, \r\n            \"Payable governance length mismatch!\");\r\n        \r\n        // now, we check that the governance shares equal to 1000.\r\n        uint256 _totalPayableShares;\r\n        for (uint256 i = 0; i < _payableGovernanceShares.length; i++) {\r\n            _totalPayableShares += _payableGovernanceShares[i]; }\r\n        require(_totalPayableShares == 1000, \"Payable Governance Shares is not 1000!\");\r\n        \r\n        // // now, we start the array creation process if all conditionals pass\r\n        // store current balance in local memory and instantiate array for input\r\n        uint256 _totalETH = address(this).balance; \r\n        uint256[] memory _withdrawals = new uint256[] \r\n            (_payableGovernanceAddresses.length + 2);\r\n\r\n        // array creation loop for payable governance values \r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            _withdrawals[i] = ( (_totalETH * _payableGovernanceShares[i]) / 1000 );\r\n        }\r\n        \r\n        // push two last array spots as total eth and added eths of withdrawals\r\n        _withdrawals[_payableGovernanceAddresses.length] = _totalETH;\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            _withdrawals[_payableGovernanceAddresses.length + 1] += _withdrawals[i]; }\r\n\r\n        // return the final array data\r\n        return _withdrawals;\r\n    }\r\n\r\n    // Shareholder Governance\r\n    modifier onlyShareholder {\r\n        bool _isShareholder;\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            if (msg.sender == _payableGovernanceAddresses[i]) {\r\n                _isShareholder = true;\r\n            }\r\n        }\r\n        require(_isShareholder, \"You are not a shareholder!\");\r\n        _;\r\n    }\r\n    function unlockEmergencyFunctionsAsShareholder() public onlyShareholder {\r\n        addressToEmergencyUnlocked[msg.sender] = true;\r\n    }\r\n\r\n    // Emergency Functions\r\n    modifier onlyEmergency {\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            require(addressToEmergencyUnlocked[_payableGovernanceAddresses[i]],\r\n                \"Emergency Functions are not unlocked!\");\r\n        }\r\n        _;\r\n    }\r\n    function emergencyWithdrawEther() public onlyOwner onlyEmergency {\r\n        _withdraw(payable(msg.sender), address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToEmergencyUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableGovernanceAddresses\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableGovernanceSetter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableGovernanceShares\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reouncePayableGovernancePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetPayableGovernanceShareholders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"}],\"name\":\"setPayableGovernanceShareholders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"new_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockEmergencyFunctionsAsShareholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewWithdrawAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "RoyaltiesGovernance", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e0f541e1b111e2046dba57332881aba6ab95336ed1688ce9e24533c29c29618c"}]}