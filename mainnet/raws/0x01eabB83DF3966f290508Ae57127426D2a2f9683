{"status": "1", "message": "OK", "result": [{"SourceCode": "// Verified using https://dapp.tools\n\n// hevm: flattened sources of /nix/store/n0zrh7hav4swn38ckv0y2panmrlaxy1s-geb-fsm/dapp/geb-fsm/src/DSM.sol\npragma solidity =0.6.7;\n\n////// /nix/store/3d3msxain9q01swpn63dsh9wl2hsal24-geb-treasury-reimbursement/dapp/geb-treasury-reimbursement/src/math/GebMath.sol\n/* pragma solidity 0.6.7; */\n\ncontract GebMath {\n    uint256 public constant RAY = 10 ** 27;\n    uint256 public constant WAD = 10 ** 18;\n\n    function ray(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 9);\n    }\n    function rad(uint x) public pure returns (uint z) {\n        z = multiply(x, 10 ** 27);\n    }\n    function minimum(uint x, uint y) public pure returns (uint z) {\n        z = (x <= y) ? x : y;\n    }\n    function addition(uint x, uint y) public pure returns (uint z) {\n        z = x + y;\n        require(z >= x, \"uint-uint-add-overflow\");\n    }\n    function subtract(uint x, uint y) public pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function multiply(uint x, uint y) public pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function rmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / RAY;\n    }\n    function rdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, RAY) / y;\n    }\n    function wdivide(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, WAD) / y;\n    }\n    function wmultiply(uint x, uint y) public pure returns (uint z) {\n        z = multiply(x, y) / WAD;\n    }\n    function rpower(uint x, uint n, uint base) public pure returns (uint z) {\n        assembly {\n            switch x case 0 {switch n case 0 {z := base} default {z := 0}}\n            default {\n                switch mod(n, 2) case 0 { z := base } default { z := x }\n                let half := div(base, 2)  // for rounding.\n                for { n := div(n, 2) } n { n := div(n,2) } {\n                    let xx := mul(x, x)\n                    if iszero(eq(div(xx, x), x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    x := div(xxRound, base)\n                    if mod(n,2) {\n                        let zx := mul(z, x)\n                        if and(iszero(iszero(x)), iszero(eq(div(zx, x), z))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z := div(zxRound, base)\n                    }\n                }\n            }\n        }\n    }\n}\n\n////// /nix/store/3d3msxain9q01swpn63dsh9wl2hsal24-geb-treasury-reimbursement/dapp/geb-treasury-reimbursement/src/reimbursement/NoSetupNoAuthIncreasingTreasuryReimbursement.sol\n/* pragma solidity 0.6.7; */\n\n/* import \"../math/GebMath.sol\"; */\n\nabstract contract StabilityFeeTreasuryLike_2 {\n    function getAllowance(address) virtual external view returns (uint, uint);\n    function systemCoin() virtual external view returns (address);\n    function pullFunds(address, address, uint) virtual external;\n}\n\ncontract NoSetupNoAuthIncreasingTreasuryReimbursement is GebMath {\n    // --- Variables ---\n    // Starting reward for the fee receiver/keeper\n    uint256 public baseUpdateCallerReward;          // [wad]\n    // Max possible reward for the fee receiver/keeper\n    uint256 public maxUpdateCallerReward;           // [wad]\n    // Max delay taken into consideration when calculating the adjusted reward\n    uint256 public maxRewardIncreaseDelay;          // [seconds]\n    // Rate applied to baseUpdateCallerReward every extra second passed beyond a certain point (e.g next time when a specific function needs to be called)\n    uint256 public perSecondCallerRewardIncrease;   // [ray]\n\n    // SF treasury\n    StabilityFeeTreasuryLike_2  public treasury;\n\n    // --- Events ---\n    event ModifyParameters(\n      bytes32 parameter,\n      address addr\n    );\n    event ModifyParameters(\n      bytes32 parameter,\n      uint256 val\n    );\n    event FailRewardCaller(bytes revertReason, address feeReceiver, uint256 amount);\n\n    constructor() public {\n        maxRewardIncreaseDelay = uint(-1);\n    }\n\n    // --- Boolean Logic ---\n    function either(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := or(x, y)}\n    }\n    function both(bool x, bool y) internal pure returns (bool z) {\n        assembly{ z := and(x, y)}\n    }\n\n    // --- Treasury ---\n    /**\n    * @notice This returns the stability fee treasury allowance for this contract by taking the minimum between the per block and the total allowances\n    **/\n    function treasuryAllowance() public view returns (uint256) {\n        (uint total, uint perBlock) = treasury.getAllowance(address(this));\n        return minimum(total, perBlock);\n    }\n    /*\n    * @notice Get the SF reward that can be sent to a function caller right now\n    * @param timeOfLastUpdate The last time when the function that the treasury pays for has been updated\n    * @param defaultDelayBetweenCalls Enforced delay between calls to the function for which the treasury reimburses callers\n    */\n    function getCallerReward(uint256 timeOfLastUpdate, uint256 defaultDelayBetweenCalls) public view returns (uint256) {\n        // If the rewards are null or if the time of the last update is in the future or present, return 0\n        bool nullRewards = (baseUpdateCallerReward == 0 && maxUpdateCallerReward == 0);\n        if (either(timeOfLastUpdate >= now, nullRewards)) return 0;\n\n        // If the time elapsed is smaller than defaultDelayBetweenCalls or if the base reward is zero, return 0\n        uint256 timeElapsed = (timeOfLastUpdate == 0) ? defaultDelayBetweenCalls : subtract(now, timeOfLastUpdate);\n        if (either(timeElapsed < defaultDelayBetweenCalls, baseUpdateCallerReward == 0)) {\n            return 0;\n        }\n\n        // If too much time elapsed, return the max reward\n        uint256 adjustedTime      = subtract(timeElapsed, defaultDelayBetweenCalls);\n        uint256 maxPossibleReward = minimum(maxUpdateCallerReward, treasuryAllowance() / RAY);\n        if (adjustedTime > maxRewardIncreaseDelay) {\n            return maxPossibleReward;\n        }\n\n        // Calculate the reward\n        uint256 calculatedReward = baseUpdateCallerReward;\n        if (adjustedTime > 0) {\n            calculatedReward = rmultiply(rpower(perSecondCallerRewardIncrease, adjustedTime, RAY), calculatedReward);\n        }\n\n        // If the reward is higher than max, set it to max\n        if (calculatedReward > maxPossibleReward) {\n            calculatedReward = maxPossibleReward;\n        }\n        return calculatedReward;\n    }\n    /**\n    * @notice Send a stability fee reward to an address\n    * @param proposedFeeReceiver The SF receiver\n    * @param reward The system coin amount to send\n    **/\n    function rewardCaller(address proposedFeeReceiver, uint256 reward) internal {\n        // If the receiver is the treasury itself or if the treasury is null or if the reward is zero, return\n        if (address(treasury) == proposedFeeReceiver) return;\n        if (either(address(treasury) == address(0), reward == 0)) return;\n\n        // Determine the actual receiver and send funds\n        address finalFeeReceiver = (proposedFeeReceiver == address(0)) ? msg.sender : proposedFeeReceiver;\n        try treasury.pullFunds(finalFeeReceiver, treasury.systemCoin(), reward) {}\n        catch(bytes memory revertReason) {\n            emit FailRewardCaller(revertReason, finalFeeReceiver, reward);\n        }\n    }\n}\n\n////// /nix/store/n0zrh7hav4swn38ckv0y2panmrlaxy1s-geb-fsm/dapp/geb-fsm/src/DSM.sol\n/* pragma solidity 0.6.7; */\n\n/* import \"geb-treasury-reimbursement/reimbursement/NoSetupNoAuthIncreasingTreasuryReimbursement.sol\"; */\n\nabstract contract DSValueLike_1 {\n    function getResultWithValidity() virtual external view returns (uint256, bool);\n}\nabstract contract FSMWrapperLike_1 {\n    function renumerateCaller(address) virtual external;\n}\n\ncontract DSM {\n    // --- Auth ---\n    mapping (address => uint) public authorizedAccounts;\n    /**\n     * @notice Add auth to an account\n     * @param account Account to add auth to\n     */\n    function addAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 1;\n        emit AddAuthorization(account);\n    }\n    /**\n     * @notice Remove auth from an account\n     * @param account Account to remove auth from\n     */\n    function removeAuthorization(address account) virtual external isAuthorized {\n        authorizedAccounts[account] = 0;\n        emit RemoveAuthorization(account);\n    }\n    /**\n    * @notice Checks whether msg.sender can call an authed function\n    **/\n    modifier isAuthorized {\n        require(authorizedAccounts[msg.sender] == 1, \"DSM/account-not-authorized\");\n        _;\n    }\n\n    // --- Stop ---\n    uint256 public stopped;\n    modifier stoppable { require(stopped == 0, \"DSM/is-stopped\"); _; }\n\n    // --- Variables ---\n    address public priceSource;\n    uint16  public updateDelay = ONE_HOUR;      // [seconds]\n    uint64  public lastUpdateTime;              // [timestamp]\n    uint256 public newPriceDeviation;           // [wad]\n\n    uint16  constant ONE_HOUR = uint16(3600);   // [seconds]\n\n    // --- Structs ---\n    struct Feed {\n        uint128 value;\n        uint128 isValid;\n    }\n\n    Feed currentFeed;\n    Feed nextFeed;\n\n    // --- Events ---\n    event AddAuthorization(address account);\n    event RemoveAuthorization(address account);\n    event ModifyParameters(bytes32 parameter, uint256 val);\n    event ModifyParameters(bytes32 parameter, address val);\n    event Start();\n    event Stop();\n    event ChangePriceSource(address priceSource);\n    event ChangeDeviation(uint deviation);\n    event ChangeDelay(uint16 delay);\n    event RestartValue();\n    event UpdateResult(uint256 newMedian, uint256 lastUpdateTime);\n\n    constructor (address priceSource_, uint256 deviation) public {\n        require(deviation > 0 && deviation < WAD, \"DSM/invalid-deviation\");\n\n        authorizedAccounts[msg.sender] = 1;\n\n        priceSource       = priceSource_;\n        newPriceDeviation = deviation;\n\n        if (priceSource != address(0)) {\n          // Read from the median\n          (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n          // If the price is valid, update state\n          if (hasValidValue) {\n            nextFeed = Feed(uint128(uint(priceFeedValue)), 1);\n            currentFeed = nextFeed;\n            lastUpdateTime = latestUpdateTime(currentTime());\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n          }\n        }\n\n        emit AddAuthorization(msg.sender);\n        emit ChangePriceSource(priceSource);\n        emit ChangeDeviation(deviation);\n    }\n\n    // --- DSM Specific Math ---\n    uint256 private constant WAD = 10 ** 18;\n\n    function add(uint64 x, uint64 y) internal pure returns (uint64 z) {\n        z = x + y;\n        require(z >= x);\n    }\n    function sub(uint x, uint y) private pure returns (uint z) {\n        z = x - y;\n        require(z <= x, \"uint-uint-sub-underflow\");\n    }\n    function mul(uint x, uint y) private pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, \"uint-uint-mul-overflow\");\n    }\n    function wmul(uint x, uint y) private pure returns (uint z) {\n        z = mul(x, y) / WAD;\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Stop the DSM\n    */\n    function stop() external isAuthorized {\n        stopped = 1;\n        emit Stop();\n    }\n    /*\n    * @notify Start the DSM\n    */\n    function start() external isAuthorized {\n        stopped = 0;\n        emit Start();\n    }\n\n    /*\n    * @notify Change the oracle from which the DSM reads\n    * @param priceSource_ The address of the oracle from which the DSM reads\n    */\n    function changePriceSource(address priceSource_) external isAuthorized {\n        priceSource = priceSource_;\n        emit ChangePriceSource(priceSource);\n    }\n\n    /*\n    * @notify Helper that returns the current block timestamp\n    */\n    function currentTime() internal view returns (uint) {\n        return block.timestamp;\n    }\n\n    /*\n    * @notify Return the latest update time\n    * @param timestamp Custom reference timestamp to determine the latest update time from\n    */\n    function latestUpdateTime(uint timestamp) internal view returns (uint64) {\n        require(updateDelay != 0, \"DSM/update-delay-is-zero\");\n        return uint64(timestamp - (timestamp % updateDelay));\n    }\n\n    /*\n    * @notify Change the deviation supported for the next price\n    * @param deviation Allowed deviation for the next price compared to the current one\n    */\n    function changeNextPriceDeviation(uint deviation) external isAuthorized {\n        require(deviation > 0 && deviation < WAD, \"DSM/invalid-deviation\");\n        newPriceDeviation = deviation;\n        emit ChangeDeviation(deviation);\n    }\n\n    /*\n    * @notify Change the delay between updates\n    * @param delay The new delay\n    */\n    function changeDelay(uint16 delay) external isAuthorized {\n        require(delay > 0, \"DSM/delay-is-zero\");\n        updateDelay = delay;\n        emit ChangeDelay(updateDelay);\n    }\n\n    /*\n    * @notify Restart/set to zero the feeds stored in the DSM\n    */\n    function restartValue() external isAuthorized {\n        currentFeed = nextFeed = Feed(0, 0);\n        stopped = 1;\n        emit RestartValue();\n    }\n\n    /*\n    * @notify View function that returns whether the delay between calls has been passed\n    */\n    function passedDelay() public view returns (bool ok) {\n        return currentTime() >= uint(add(lastUpdateTime, uint64(updateDelay)));\n    }\n\n    /*\n    * @notify Update the price feeds inside the DSM\n    */\n    function updateResult() virtual external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"DSM/not-passed\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Update state\n            currentFeed.isValid = nextFeed.isValid;\n            currentFeed.value   = getNextBoundedPrice();\n            nextFeed            = Feed(uint128(priceFeedValue), 1);\n            lastUpdateTime      = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n        }\n    }\n\n    // --- Getters ---\n    /*\n    * @notify Internal helper that reads a price and its validity from the priceSource\n    */\n    function getPriceSourceUpdate() internal view returns (uint256, bool) {\n        try DSValueLike_1(priceSource).getResultWithValidity() returns (uint256 priceFeedValue, bool hasValidValue) {\n          return (priceFeedValue, hasValidValue);\n        }\n        catch(bytes memory) {\n          return (0, false);\n        }\n    }\n\n    /*\n    * @notify View function that returns what the next bounded price would be (taking into account the deviation set in this contract)\n    */\n    function getNextBoundedPrice() public view returns (uint128 boundedPrice) {\n        boundedPrice = nextFeed.value;\n        if (currentFeed.value == 0) return boundedPrice;\n\n        uint128 lowerBound = uint128(wmul(uint(currentFeed.value), newPriceDeviation));\n        uint128 upperBound = uint128(wmul(uint(currentFeed.value), sub(mul(uint(2), WAD), newPriceDeviation)));\n\n        if (nextFeed.value < lowerBound) {\n          boundedPrice = lowerBound;\n        } else if (nextFeed.value > upperBound) {\n          boundedPrice = upperBound;\n        }\n    }\n\n    /*\n    * @notify Returns the lower bound for the upcoming price (taking into account the deviation var)\n    */\n    function getNextPriceLowerBound() public view returns (uint128) {\n        return uint128(wmul(uint(currentFeed.value), newPriceDeviation));\n    }\n\n    /*\n    * @notify Returns the upper bound for the upcoming price (taking into account the deviation var)\n    */\n    function getNextPriceUpperBound() public view returns (uint128) {\n        return uint128(wmul(uint(currentFeed.value), sub(mul(uint(2), WAD), newPriceDeviation)));\n    }\n\n    /*\n    * @notify Return the current feed value and its validity\n    */\n    function getResultWithValidity() external view returns (uint256, bool) {\n        return (uint(currentFeed.value), currentFeed.isValid == 1);\n    }\n    /*\n    * @notify Return the next feed's value and its validity\n    */\n    function getNextResultWithValidity() external view returns (uint256, bool) {\n        return (nextFeed.value, nextFeed.isValid == 1);\n    }\n    /*\n    * @notify Return the current feed's value only if it's valid, otherwise revert\n    */\n    function read() external view returns (uint256) {\n        require(currentFeed.isValid == 1, \"DSM/no-current-value\");\n        return currentFeed.value;\n    }\n}\n\ncontract SelfFundedDSM is DSM, NoSetupNoAuthIncreasingTreasuryReimbursement {\n    constructor (address priceSource_, uint256 deviation) public DSM(priceSource_, deviation) {}\n\n    // --- Administration ---\n    /*\n    * @notify Modify a uint256 parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, uint256 val) external isAuthorized {\n        if (parameter == \"baseUpdateCallerReward\") {\n          require(val < maxUpdateCallerReward, \"SelfFundedDSM/invalid-base-caller-reward\");\n          baseUpdateCallerReward = val;\n        }\n        else if (parameter == \"maxUpdateCallerReward\") {\n          require(val >= baseUpdateCallerReward, \"SelfFundedDSM/invalid-max-reward\");\n          maxUpdateCallerReward = val;\n        }\n        else if (parameter == \"perSecondCallerRewardIncrease\") {\n          require(val >= RAY, \"SelfFundedDSM/invalid-reward-increase\");\n          perSecondCallerRewardIncrease = val;\n        }\n        else if (parameter == \"maxRewardIncreaseDelay\") {\n          require(val > 0, \"SelfFundedDSM/invalid-max-increase-delay\");\n          maxRewardIncreaseDelay = val;\n        }\n        else revert(\"SelfFundedDSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\n        if (parameter == \"treasury\") {\n          require(val != address(0), \"SelfFundedDSM/invalid-treasury\");\n          treasury = StabilityFeeTreasuryLike_2(val);\n        }\n        else revert(\"SelfFundedDSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Update the price feeds inside the DSM\n    */\n    function updateResult() override external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"SelfFundedDSM/not-passed\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Get the caller's reward\n            uint256 callerReward = getCallerReward(lastUpdateTime, updateDelay);\n            // Update state\n            currentFeed.isValid = nextFeed.isValid;\n            currentFeed.value   = getNextBoundedPrice();\n            nextFeed            = Feed(uint128(priceFeedValue), 1);\n            lastUpdateTime      = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n            // Pay the caller\n            rewardCaller(msg.sender, callerReward);\n        }\n    }\n}\n\ncontract ExternallyFundedDSM is DSM {\n    // --- Variables ---\n    // The wrapper for this DSM. It can relay treasury rewards\n    FSMWrapperLike_1 public fsmWrapper;\n\n    // --- Evemts ---\n    event FailRenumerateCaller(address wrapper, address caller);\n\n    constructor (address priceSource_, uint256 deviation) public DSM(priceSource_, deviation) {}\n\n    // --- Administration ---\n    /*\n    * @notify Modify an address parameter\n    * @param parameter The parameter name\n    * @param val The new value for the parameter\n    */\n    function modifyParameters(bytes32 parameter, address val) external isAuthorized {\n        if (parameter == \"fsmWrapper\") {\n          require(val != address(0), \"ExternallyFundedDSM/invalid-fsm-wrapper\");\n          fsmWrapper = FSMWrapperLike_1(val);\n        }\n        else revert(\"ExternallyFundedDSM/modify-unrecognized-param\");\n        emit ModifyParameters(parameter, val);\n    }\n\n    // --- Core Logic ---\n    /*\n    * @notify Update the price feeds inside the DSM\n    */\n    function updateResult() override external stoppable {\n        // Check if the delay passed\n        require(passedDelay(), \"ExternallyFundedDSM/not-passed\");\n        // Check that the wrapper is set\n        require(address(fsmWrapper) != address(0), \"ExternallyFundedDSM/null-wrapper\");\n        // Read the price from the median\n        (uint256 priceFeedValue, bool hasValidValue) = getPriceSourceUpdate();\n        // If the value is valid, update storage\n        if (hasValidValue) {\n            // Update state\n            currentFeed.isValid = nextFeed.isValid;\n            currentFeed.value   = getNextBoundedPrice();\n            nextFeed            = Feed(uint128(priceFeedValue), 1);\n            lastUpdateTime      = latestUpdateTime(currentTime());\n            // Emit event\n            emit UpdateResult(uint(currentFeed.value), lastUpdateTime);\n            // Pay the caller\n            try fsmWrapper.renumerateCaller(msg.sender) {}\n            catch(bytes memory revertReason) {\n              emit FailRenumerateCaller(address(fsmWrapper), msg.sender);\n            }\n        }\n    }\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceSource_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"delay\",\"type\":\"uint16\"}],\"name\":\"ChangeDelay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"}],\"name\":\"ChangeDeviation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"priceSource\",\"type\":\"address\"}],\"name\":\"ChangePriceSource\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wrapper\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"FailRenumerateCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"ModifyParameters\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"RemoveAuthorization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RestartValue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Stop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMedian\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastUpdateTime\",\"type\":\"uint256\"}],\"name\":\"UpdateResult\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorizedAccounts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"delay\",\"type\":\"uint16\"}],\"name\":\"changeDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deviation\",\"type\":\"uint256\"}],\"name\":\"changeNextPriceDeviation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"priceSource_\",\"type\":\"address\"}],\"name\":\"changePriceSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fsmWrapper\",\"outputs\":[{\"internalType\":\"contract FSMWrapperLike_1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextBoundedPrice\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"boundedPrice\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextPriceLowerBound\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextPriceUpperBound\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextResultWithValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getResultWithValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"parameter\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"val\",\"type\":\"address\"}],\"name\":\"modifyParameters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"newPriceDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedDelay\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"ok\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceSource\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"read\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"removeAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"restartValue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateDelay\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ExternallyFundedDSM", "CompilerVersion": "v0.6.7+commit.b8d736ae", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000b7863264684f84fdc9d0bf77b1f339edd19d530e00000000000000000000000000000000000000000000000009b6e64a8ec60000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}