{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity 0.8.13;\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n/// @notice An error used to indicate that an argument passed to a function is illegal or\n///         inappropriate.\n///\n/// @param message The error message.\nerror IllegalArgument(string message);\n\n/// @notice An error used to indicate that a function has encountered an unrecoverable state.\n///\n/// @param message The error message.\nerror IllegalState(string message);\n\n/// @notice An error used to indicate that an operation is unsupported.\n///\n/// @param message The error message.\nerror UnsupportedOperation(string message);\n\n/// @notice An error used to indicate that a message sender tried to execute a privileged function.\n///\n/// @param message The error message.\nerror Unauthorized(string message);/// @title  Mutex\n/// @author Alchemix Finance\n///\n/// @notice Provides a mutual exclusion lock for implementing contracts.\nabstract contract Mutex {\n    enum State {\n        RESERVED,\n        UNLOCKED,\n        LOCKED\n    }\n\n    /// @notice The lock state.\n    State private _lockState = State.UNLOCKED;\n\n    /// @dev A modifier which acquires the mutex.\n    modifier lock() {\n        _claimLock();\n\n        _;\n\n        _freeLock();\n    }\n\n    /// @dev Gets if the mutex is locked.\n    ///\n    /// @return if the mutex is locked.\n    function _isLocked() internal view returns (bool) {\n        return _lockState == State.LOCKED;\n    }\n\n    /// @dev Claims the lock. If the lock is already claimed, then this will revert.\n    function _claimLock() internal {\n        // Check that the lock has not been claimed yet.\n        if (_lockState != State.UNLOCKED) {\n            revert IllegalState(\"Lock already claimed\");\n        }\n\n        // Claim the lock.\n        _lockState = State.LOCKED;\n    }\n\n    /// @dev Frees the lock.\n    function _freeLock() internal {\n        _lockState = State.UNLOCKED;\n    }\n}\n/// @title  IERC20Metadata\n/// @author Alchemix Finance\ninterface IERC20Metadata {\n    /// @notice Gets the name of the token.\n    ///\n    /// @return The name.\n    function name() external view returns (string memory);\n\n    /// @notice Gets the symbol of the token.\n    ///\n    /// @return The symbol.\n    function symbol() external view returns (string memory);\n\n    /// @notice Gets the number of decimals that the token has.\n    ///\n    /// @return The number of decimals.\n    function decimals() external view returns (uint8);\n}\n/// @title  SafeERC20\n/// @author Alchemix Finance\nlibrary SafeERC20 {\n    /// @notice An error used to indicate that a call to an ERC20 contract failed.\n    ///\n    /// @param target  The target address.\n    /// @param success If the call to the token was a success.\n    /// @param data    The resulting data from the call. This is error data when the call was not a\n    ///                success. Otherwise, this is malformed data when the call was a success.\n    error ERC20CallFailed(address target, bool success, bytes data);\n\n    /// @dev A safe function to get the decimals of an ERC20 token.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the query fails or returns an\n    ///      unexpected value.\n    ///\n    /// @param token The target token.\n    ///\n    /// @return The amount of decimals of the token.\n    function expectDecimals(address token) internal view returns (uint8) {\n        (bool success, bytes memory data) = token.staticcall(\n            abi.encodeWithSelector(IERC20Metadata.decimals.selector)\n        );\n\n        if (!success || data.length < 32) {\n            revert ERC20CallFailed(token, success, data);\n        }\n\n        return abi.decode(data, (uint8));\n    }\n\n    /// @dev Transfers tokens to another address.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer failed or returns an\n    ///      unexpected value.\n    ///\n    /// @param token     The token to transfer.\n    /// @param recipient The address of the recipient.\n    /// @param amount    The amount of tokens to transfer.\n    function safeTransfer(address token, address recipient, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Approves tokens for the smart contract.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the approval fails or returns an\n    ///      unexpected value.\n    ///\n    /// @param token   The token to approve.\n    /// @param spender The contract to spend the tokens.\n    /// @param value   The amount of tokens to approve.\n    function safeApprove(address token, address spender, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.approve.selector, spender, value)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n\n    /// @dev Transfer tokens from one address to another address.\n    ///\n    /// @dev Reverts with a {CallFailed} error if execution of the transfer fails or returns an\n    ///      unexpected value.\n    ///\n    /// @param token     The token to transfer.\n    /// @param owner     The address of the owner.\n    /// @param recipient The address of the recipient.\n    /// @param amount    The amount of tokens to transfer.\n    function safeTransferFrom(address token, address owner, address recipient, uint256 amount) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transferFrom.selector, owner, recipient, amount)\n        );\n\n        if (!success || (data.length != 0 && !abi.decode(data, (bool)))) {\n            revert ERC20CallFailed(token, success, data);\n        }\n    }\n}\n/// @title  ITokenAdapter\n/// @author Alchemix Finance\ninterface ITokenAdapter {\n    /// @notice Gets the current version.\n    ///\n    /// @return The version.\n    function version() external view returns (string memory);\n\n    /// @notice Gets the address of the yield token that this adapter supports.\n    ///\n    /// @return The address of the yield token.\n    function token() external view returns (address);\n\n    /// @notice Gets the address of the underlying token that the yield token wraps.\n    ///\n    /// @return The address of the underlying token.\n    function underlyingToken() external view returns (address);\n\n    /// @notice Gets the number of underlying tokens that a single whole yield token is redeemable\n    ///         for.\n    ///\n    /// @return The price.\n    function price() external view returns (uint256);\n\n    /// @notice Wraps `amount` underlying tokens into the yield token.\n    ///\n    /// @param amount    The amount of the underlying token to wrap.\n    /// @param recipient The address which will receive the yield tokens.\n    ///\n    /// @return amountYieldTokens The amount of yield tokens minted to `recipient`.\n    function wrap(uint256 amount, address recipient)\n        external\n        returns (uint256 amountYieldTokens);\n\n    /// @notice Unwraps `amount` yield tokens into the underlying token.\n    ///\n    /// @param amount    The amount of yield-tokens to redeem.\n    /// @param recipient The recipient of the resulting underlying-tokens.\n    ///\n    /// @return amountUnderlyingTokens The amount of underlying tokens unwrapped to `recipient`.\n    function unwrap(uint256 amount, address recipient)\n        external\n        returns (uint256 amountUnderlyingTokens);\n}/// @title IWETH9\ninterface IWETH9 is IERC20, IERC20Metadata {\n  /// @notice Deposits `msg.value` ethereum into the contract and mints `msg.value` tokens.\n  function deposit() external payable;\n\n  /// @notice Burns `amount` tokens to retrieve `amount` ethereum from the contract.\n  ///\n  /// @dev This version of WETH utilizes the `transfer` function which hard codes the amount of gas\n  ///      that is allowed to be utilized to be exactly 2300 when receiving ethereum.\n  ///\n  /// @param amount The amount of tokens to burn.\n  function withdraw(uint256 amount) external;\n}uint256 constant N_COINS = 2;\n\ninterface IStableSwap2Pool {\n    function coins(uint256 index) external view returns (address);\n\n    function A() external view returns (uint256);\n\n    function get_virtual_price() external view returns (uint256);\n\n    function calc_token_amount(\n        uint256[N_COINS] calldata amounts,\n        bool deposit\n    ) external view returns (uint256 amount);\n\n    function add_liquidity(uint256[N_COINS] calldata amounts, uint256 minimumMintAmount) external;\n\n    function get_dy(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n\n    function get_dy_underlying(int128 i, int128 j, uint256 dx) external view returns (uint256 dy);\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 minimumDy\n    ) external payable returns (uint256);\n\n    function remove_liquidity(uint256 amount, uint256[N_COINS] calldata minimumAmounts) external;\n\n    function remove_liquidity_imbalance(\n        uint256[N_COINS] calldata amounts,\n        uint256 maximumBurnAmount\n    ) external;\n\n    function calc_withdraw_one_coin(uint256 tokenAmount, int128 i) external view returns (uint256);\n\n    function remove_liquidity_one_coin(\n        uint256 tokenAmount,\n        int128 i,\n        uint256 minimumAmount\n    ) external;\n}interface IStETH is IERC20 {\n    function sharesOf(address account) external view returns (uint256);\n    function getPooledEthByShares(uint256 sharesAmount) external view returns (uint256);\n    function submit(address referral) external payable returns (uint256);\n}interface IWstETH is IERC20 {\n    function getWstETHByStETH(uint256 amount) external view returns (uint256);\n    function getStETHByWstETH(uint256 amount) external view returns (uint256);\n    function wrap(uint256 amount) external returns (uint256);\n    function unwrap(uint256 amount) external returns (uint256);\n}\nstruct InitializationParams {\n    address alchemist;\n    address token;\n    address parentToken;\n    address underlyingToken;\n    address curvePool;\n    uint256 ethPoolIndex;\n    uint256 stEthPoolIndex;\n    address referral;\n}\n\ncontract WstETHAdapterV1 is ITokenAdapter, Mutex {\n    string public override version = \"1.1.0\";\n\n    address public immutable alchemist;\n    address public immutable override token;\n    address public immutable parentToken;\n    address public immutable override underlyingToken;\n    address public immutable curvePool;\n    uint256 public immutable ethPoolIndex;\n    uint256 public immutable stEthPoolIndex;\n    address public immutable referral;\n\n    constructor(InitializationParams memory params) {\n        alchemist       = params.alchemist;\n        token           = params.token;\n        parentToken     = params.parentToken;\n        underlyingToken = params.underlyingToken;\n        curvePool       = params.curvePool;\n        ethPoolIndex    = params.ethPoolIndex;\n        stEthPoolIndex  = params.stEthPoolIndex;\n        referral        = params.referral;\n        // Verify and make sure that the provided ETH matches the curve pool ETH.\n        if (\n            IStableSwap2Pool(curvePool).coins(ethPoolIndex) !=\n            0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n        ) {\n            revert IllegalArgument(\"Curve pool ETH token mismatch\");\n        }\n\n        // Verify and make sure that the provided stETH matches the curve pool stETH.\n        if (\n            IStableSwap2Pool(curvePool).coins(stEthPoolIndex) !=\n            parentToken\n        ) {\n            revert IllegalArgument(\"Curve pool stETH token mismatch\");\n        }\n    }\n\n    /// @dev Checks that the message sender is the alchemist that the adapter is bound to.\n    modifier onlyAlchemist() {\n        if (msg.sender != alchemist) {\n            revert Unauthorized(\"Not alchemist\");\n        }\n        _;\n    }\n\n    receive() external payable {\n        if (msg.sender != underlyingToken && msg.sender != curvePool) {\n            revert Unauthorized(\"Payments only permitted from WETH or curve pool\");\n        }\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function price() external view returns (uint256) {\n        return IWstETH(token).getStETHByWstETH(10**SafeERC20.expectDecimals(token));\n    }\n\n    /// @inheritdoc ITokenAdapter\n    function wrap(\n        uint256 amount,\n        address recipient\n    ) external lock onlyAlchemist returns (uint256) {\n        // Transfer the tokens from the message sender.\n        SafeERC20.safeTransferFrom(underlyingToken, msg.sender, address(this), amount);\n\n        // Unwrap the WETH into ETH.\n        IWETH9(underlyingToken).withdraw(amount);\n\n        // Wrap the ETH into stETH.\n        uint256 startingStEthBalance = IERC20(parentToken).balanceOf(address(this));\n\n        IStETH(parentToken).submit{value: amount}(referral);\n\n        uint256 mintedStEth = IERC20(parentToken).balanceOf(address(this)) - startingStEthBalance;\n\n        // Wrap the stETH into wstETH.\n        SafeERC20.safeApprove(parentToken, address(token), mintedStEth);\n        uint256 mintedWstEth = IWstETH(token).wrap(mintedStEth);\n\n        // Transfer the minted wstETH to the recipient.\n        SafeERC20.safeTransfer(token, recipient, mintedWstEth);\n\n        return mintedWstEth;\n    }\n\n    // @inheritdoc ITokenAdapter\n    function unwrap(\n        uint256 amount,\n        address recipient\n    ) external lock onlyAlchemist returns (uint256) {\n        // Transfer the tokens from the message sender.\n        SafeERC20.safeTransferFrom(token, msg.sender, address(this), amount);\n\n        // Unwrap the wstETH into stETH.\n        uint256 startingStEthBalance = IStETH(parentToken).balanceOf(address(this));\n        IWstETH(token).unwrap(amount);\n        uint256 endingStEthBalance = IStETH(parentToken).balanceOf(address(this));\n\n        // Approve the curve pool to transfer the tokens.\n        uint256 unwrappedStEth = endingStEthBalance - startingStEthBalance;\n        SafeERC20.safeApprove(parentToken, curvePool, unwrappedStEth);\n\n        // Exchange the stETH for ETH. We do not check the curve pool because it is an immutable\n        // contract and we expect that its output is reliable.\n        uint256 received = IStableSwap2Pool(curvePool).exchange(\n            int128(uint128(stEthPoolIndex)), // Why are we here, just to suffer?\n            int128(uint128(ethPoolIndex)),   //                       (\u2565\ufe4f\u2565)\n            unwrappedStEth,\n            0                                // <- Slippage is handled upstream\n        );\n\n        // Wrap the ETH that we received from the exchange.\n        IWETH9(underlyingToken).deposit{value: received}();\n\n        // Transfer the tokens to the recipient.\n        SafeERC20.safeTransfer(underlyingToken, recipient, received);\n\n        return received;\n    }\n}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"alchemist\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"parentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"curvePool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ethPoolIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stEthPoolIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"internalType\":\"struct InitializationParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"ERC20CallFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalArgument\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"IllegalState\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"alchemist\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"curvePool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stEthPoolIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"underlyingToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"wrap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WstETHAdapterV1", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000062bf725dc4cdf947aa79ca2aaccd4f385b13b5c0000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000ae7ab96520de3a18e5e111b5eaab095312d7fe84000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000dc24316b9ae028f1497c275eb9192a3ea0f67022000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000009e2b6378ee8ad2a4a95fe481d63caba8fb0ebbf9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}