{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/VoSpoolRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./external/spool-core/SpoolOwnable.sol\\\";\\nimport \\\"./interfaces/IVoSpoolRewards.sol\\\";\\n\\nimport \\\"./interfaces/IVoSPOOL.sol\\\";\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice Defines amount of emitted rewards per tranche for a range of tranches\\n * @member fromTranche marks first tranche the reward rate is valid for\\n * @member toTranche marks tranche index when the reward becomes invalid (when `toTranche` is reached, the configuration is no more valid)\\n * @member rewardPerTranche amount of emitted rewards per tranche\\n */\\nstruct VoSpoolRewardRate {\\n\\tuint8 fromTranche;\\n\\tuint8 toTranche;\\n\\tuint112 rewardPerTranche; // rewards per tranche\\n}\\n\\n/**\\n * @notice struct solding two VoSpoolRewardRate structs\\n * @dev made to pack multiple structs in one word\\n * @member zero VoSpoolRewardRate at position 0\\n * @member one VoSpoolRewardRate at position 1\\n */\\nstruct VoSpoolRewardRates {\\n\\tVoSpoolRewardRate zero;\\n\\tVoSpoolRewardRate one;\\n}\\n\\n/**\\n * @notice voSPOOL reward state for user\\n * @member lastRewardRateIndex last reward rate index user has used (refers to VoSpoolRewardConfiguration.voSpoolRewardRates mapping and VoSpoolRewardRates index)\\n * @member earned total rewards user has accumulated\\n */\\nstruct VoSpoolRewardUser {\\n\\tuint8 lastRewardRateIndex;\\n\\tuint248 earned;\\n}\\n\\n/**\\n * @notice voSPOOL reward configuration\\n * @member rewardRatesIndex last set reward rate index for voSpoolRewardRates mapping (acts similar to an array length parameter)\\n * @member hasRewards flag marking if the contract is emitting rewards for new tranches\\n * @member lastSetRewardTranche last reward tranche index we've set the congiguration for\\n */\\nstruct VoSpoolRewardConfiguration {\\n\\tuint240 rewardRatesIndex;\\n\\tbool hasRewards;\\n\\tuint8 lastSetRewardTranche;\\n}\\n\\n/**\\n * @notice Implementation of the {IVoSpoolRewards} interface.\\n *\\n * @dev\\n * This contract implements the logic to calculate and distribute\\n * SPOOL token rewards to according to users gradual voSPOOL balance.\\n * Spool DAO Voting Token (voSPOOL) is an inflationary token as it\\n * increases power over the period of 3 years.\\n *\\n * This contract assumes only SPOOL Staking is updating gradual mint, as\\n * well as that the voSPOOL state has not been updated prior calling\\n * the updateRewards function.\\n *\\n * Only Spool DAO can add, update and end rewards.\\n * Only SPOOL Staking contract can update this contract.\\n */\\ncontract VoSpoolRewards is SpoolOwnable, IVoSpoolRewards {\\n\\t/* ========== CONSTANTS ========== */\\n\\n\\t/// @notice amount of tranches to mature to full power\\n\\tuint256 private constant FULL_POWER_TRANCHES_COUNT = 52 * 3;\\n\\n\\t/// @notice number of tranche amounts stored in one 256bit word\\n\\tuint256 private constant TRANCHES_PER_WORD = 5;\\n\\n\\t/* ========== STATE VARIABLES ========== */\\n\\n\\t/// @notice Spool staking contract\\n\\t/// @dev Controller of this contract\\n\\taddress public immutable spoolStaking;\\n\\n\\t/// @notice Spool DAO Voting Token (voSPOOL) implementation\\n\\tIVoSPOOL public immutable voSpool;\\n\\n\\t/// @notice Vault reward token incentive configuration\\n\\tVoSpoolRewardConfiguration public voSpoolRewardConfig;\\n\\n\\t/// @notice Reward of SPOOL token distribution per tranche\\n\\t/// @dev We save all reward updates so we can apply it to a user even if the configuration changes after\\n\\tmapping(uint256 => VoSpoolRewardRates) public voSpoolRewardRates;\\n\\n\\t/// @notice Stores values for user rewards\\n\\tmapping(address => VoSpoolRewardUser) public userRewards;\\n\\n\\t/// @notice Stores values for global gradual voSPOOL power for every tranche\\n\\t/// @dev Only stores if the reward is active. We store 5 values per word.\\n\\tmapping(uint256 => uint256) private _tranchePowers;\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\n\\t/**\\n\\t * @notice Sets the immutable values\\n\\t *\\n\\t * @param _spoolStaking Spool staking contract\\n\\t * @param _voSpool voSPOOL contract\\n\\t * @param _spoolOwner Spool DAO owner contract\\n\\t */\\n\\tconstructor(\\n\\t\\taddress _spoolStaking,\\n\\t\\tIVoSPOOL _voSpool,\\n\\t\\tISpoolOwner _spoolOwner\\n\\t) SpoolOwnable(_spoolOwner) {\\n\\t\\tspoolStaking = _spoolStaking;\\n\\t\\tvoSpool = _voSpool;\\n\\t}\\n\\n\\t/* ========== REWARD CONFIGURATION ========== */\\n\\n\\t/**\\n\\t * @notice Update SPOOL rewards distributed relative to voSPOOL power\\n\\t * @dev We distribute `rewardPerTranche` rewards every tranche up to `toTranche` index\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the Spool DAO\\n\\t * - reward per tranche must be more than 0\\n\\t * - last reward shouldn't be set after first gradual power starts maturing\\n\\t * - reward must be set for the future tranches\\n\\t *\\n\\t * @param toTranche update to `toTranche` index\\n\\t * @param rewardPerTranche amount of SPOOL token rewards distributed every tranche\\n\\t */\\n\\tfunction updateVoSpoolRewardRate(uint8 toTranche, uint112 rewardPerTranche) external onlyOwner {\\n\\t\\trequire(rewardPerTranche > 0, \\\"VoSpoolRewards::updateVoSpoolRewardRate: Cannot update reward rate to 0\\\");\\n\\t\\t// cannot add rewards after first tranche is fully-matured (3 years)\\n\\t\\trequire(\\n\\t\\t\\ttoTranche <= FULL_POWER_TRANCHES_COUNT,\\n\\t\\t\\t\\\"VoSpoolRewards::updateVoSpoolRewardRate: Cannot set rewards after power starts maturing\\\"\\n\\t\\t);\\n\\n\\t\\tuint8 currentTrancheIndex = uint8(voSpool.getCurrentTrancheIndex());\\n\\t\\trequire(\\n\\t\\t\\ttoTranche > currentTrancheIndex,\\n\\t\\t\\t\\\"VoSpoolRewards::updateVoSpoolRewardRate: Cannot set rewards for finished tranches\\\"\\n\\t\\t);\\n\\n\\t\\tuint256 rewardRatesIndex = voSpoolRewardConfig.rewardRatesIndex;\\n\\n\\t\\tVoSpoolRewardRate memory voSpoolRewardRate = VoSpoolRewardRate(\\n\\t\\t\\tcurrentTrancheIndex,\\n\\t\\t\\ttoTranche,\\n\\t\\t\\trewardPerTranche\\n\\t\\t);\\n\\n\\t\\tif (rewardRatesIndex == 0) {\\n\\t\\t\\tvoSpoolRewardRates[0].one = voSpoolRewardRate;\\n\\t\\t\\trewardRatesIndex = 1;\\n\\t\\t} else {\\n\\t\\t\\tVoSpoolRewardRate storage previousRewardRate = _getRewardRate(rewardRatesIndex);\\n\\n\\t\\t\\t// update previous reward rate if still active to end at current index\\n\\t\\t\\tif (previousRewardRate.toTranche > currentTrancheIndex) {\\n\\t\\t\\t\\t// if current rewards did not start yet, overwrite them and return\\n\\t\\t\\t\\tif (previousRewardRate.fromTranche == currentTrancheIndex) {\\n\\t\\t\\t\\t\\t_setRewardRate(voSpoolRewardRate, rewardRatesIndex);\\n\\t\\t\\t\\t\\tvoSpoolRewardConfig = VoSpoolRewardConfiguration(uint240(rewardRatesIndex), true, toTranche);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpreviousRewardRate.toTranche = currentTrancheIndex;\\n\\t\\t\\t}\\n\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\trewardRatesIndex++;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// set the new reward rate\\n\\t\\t\\t_setRewardRate(voSpoolRewardRate, rewardRatesIndex);\\n\\t\\t}\\n\\n\\t\\t// store update to reward configuration\\n\\t\\tvoSpoolRewardConfig = VoSpoolRewardConfiguration(uint240(rewardRatesIndex), true, toTranche);\\n\\n\\t\\temit RewardRateUpdated(\\n\\t\\t\\tvoSpoolRewardRate.fromTranche,\\n\\t\\t\\tvoSpoolRewardRate.toTranche,\\n\\t\\t\\tvoSpoolRewardRate.rewardPerTranche\\n\\t\\t);\\n\\t}\\n\\n\\t/**\\n\\t * @notice End SPOOL rewards at current index\\n\\t * @dev\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the Spool DAO\\n\\t * - reward must be active\\n\\t */\\n\\tfunction endVoSpoolReward() external onlyOwner {\\n\\t\\tuint8 currentTrancheIndex = uint8(voSpool.getCurrentTrancheIndex());\\n\\t\\tuint256 rewardRatesIndex = voSpoolRewardConfig.rewardRatesIndex;\\n\\n\\t\\trequire(rewardRatesIndex > 0, \\\"VoSpoolRewards::endVoSpoolReward: No rewards configured\\\");\\n\\n\\t\\tVoSpoolRewardRate storage currentRewardRate = _getRewardRate(rewardRatesIndex);\\n\\n\\t\\trequire(\\n\\t\\t\\tcurrentRewardRate.toTranche > currentTrancheIndex,\\n\\t\\t\\t\\\"VoSpoolRewards::endVoSpoolReward: Rewards already ended\\\"\\n\\t\\t);\\n\\n\\t\\temit RewardEnded(\\n\\t\\t\\trewardRatesIndex,\\n\\t\\t\\tcurrentRewardRate.fromTranche,\\n\\t\\t\\tcurrentRewardRate.toTranche,\\n\\t\\t\\tcurrentTrancheIndex\\n\\t\\t);\\n\\n\\t\\t// if current rewards did not start yet, remove them\\n\\t\\tif (currentRewardRate.fromTranche == currentTrancheIndex) {\\n\\t\\t\\t_resetRewardRate(rewardRatesIndex);\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\trewardRatesIndex--;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (rewardRatesIndex == 0) {\\n\\t\\t\\t\\tvoSpoolRewardConfig = VoSpoolRewardConfiguration(0, false, 0);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tcurrentRewardRate.toTranche = currentTrancheIndex;\\n\\t\\t}\\n\\n\\t\\tvoSpoolRewardConfig = VoSpoolRewardConfiguration(uint240(rewardRatesIndex), false, currentTrancheIndex);\\n\\t}\\n\\n\\t/* ========== REWARD UPDATES ========== */\\n\\n\\t/**\\n\\t * @notice Return user rewards earned value and reset it to 0.\\n\\t * @dev\\n\\t * The rewards are then processed by the Spool staking contract.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the Spool staking contract\\n\\t *\\n\\t * @param user User to flush\\n\\t */\\n\\tfunction flushRewards(address user) external override onlySpoolStaking returns (uint256) {\\n\\t\\tuint256 userEarned = userRewards[user].earned;\\n\\t\\tif (userEarned > 0) {\\n\\t\\t\\tuserRewards[user].earned = 0;\\n\\t\\t}\\n\\n\\t\\treturn userEarned;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Update rewards for a user.\\n\\t * @dev\\n\\t * This has to be called before we update the gradual power storage in\\n\\t * the voSPOOL contract for the contract to work as indended.\\n\\t * We update the global values if new indexes have passed between our last call.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the Spool staking contract\\n\\t *\\n\\t * @param user User to update\\n\\t */\\n\\tfunction updateRewards(address user) external override onlySpoolStaking returns (uint256) {\\n\\t\\tif (voSpoolRewardConfig.rewardRatesIndex == 0) return 0;\\n\\n\\t\\t// if rewards are not active do not the gradual amounts\\n\\t\\tif (voSpoolRewardConfig.hasRewards) {\\n\\t\\t\\t_storeVoSpoolForNewIndexes();\\n\\t\\t}\\n\\n\\t\\t_updateUserVoSpoolRewards(user);\\n\\n\\t\\treturn userRewards[user].earned;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Store total gradual voSPOOL amount for every new tranche index since last call.\\n\\t * @dev\\n\\t * This function assumes that the voSPOOL state has not been\\n\\t * updated prior to calling this function.\\n\\t *\\n\\t * We retrieve the not updated state from voSPOOL contract, simulate\\n\\t * gradual increase of shares for every new tranche and store the\\n\\t * value for later use.\\n\\t */\\n\\tfunction _storeVoSpoolForNewIndexes() private {\\n\\t\\t// check if there are any active rewards\\n\\t\\tuint256 lastFinishedTrancheIndex = voSpool.getLastFinishedTrancheIndex();\\n\\t\\tGlobalGradual memory global = voSpool.getNotUpdatedGlobalGradual();\\n\\n\\t\\t// return if no new indexes passed\\n\\t\\tif (global.lastUpdatedTrancheIndex >= lastFinishedTrancheIndex) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 lastSetRewardTranche = voSpoolRewardConfig.lastSetRewardTranche;\\n\\t\\tuint256 trancheIndex = global.lastUpdatedTrancheIndex;\\n\\t\\tdo {\\n\\t\\t\\t// if there are no more rewards return as we don't need to store anything\\n\\t\\t\\tif (trancheIndex >= lastSetRewardTranche) {\\n\\t\\t\\t\\t// update config hasRewards to false if rewards are not active\\n\\t\\t\\t\\tvoSpoolRewardConfig.hasRewards = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\ttrancheIndex++;\\n\\n\\t\\t\\tglobal.totalRawUnmaturedVotingPower += global.totalMaturingAmount;\\n\\n\\t\\t\\t// store gradual power for `trancheIndex` to `_tranchePowers`\\n\\t\\t\\t_storeTranchePowerForIndex(\\n\\t\\t\\t\\t_getMaturingVotingPowerFromRaw(global.totalRawUnmaturedVotingPower),\\n\\t\\t\\t\\ttrancheIndex\\n\\t\\t\\t);\\n\\t\\t} while (trancheIndex < lastFinishedTrancheIndex);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Update user reward earnings for every new tranche index since the last update\\n\\t * @dev\\n\\t * This function assumes that the voSPOOL state has not been\\n\\t * updated prior to calling this function.\\n\\t *\\n\\t * _storeVoSpoolForNewIndexes function should be called before\\n\\t * to store the global state.\\n\\t *\\n\\t * We use very similar techniques as voSPOOL to calculate\\n\\t * user gradual voting power for every index\\n\\t */\\n\\tfunction _updateUserVoSpoolRewards(address user) private {\\n\\t\\tUserGradual memory userGradual = voSpool.getNotUpdatedUserGradual(user);\\n\\t\\tif (userGradual.maturingAmount == 0) {\\n\\t\\t\\tuserRewards[user].lastRewardRateIndex = uint8(voSpoolRewardConfig.rewardRatesIndex);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tuint256 lastFinishedTrancheIndex = voSpool.getLastFinishedTrancheIndex();\\n\\t\\tuint256 trancheIndex = userGradual.lastUpdatedTrancheIndex;\\n\\n\\t\\t// update user if tranche indexes have passed since last user update\\n\\t\\tif (trancheIndex < lastFinishedTrancheIndex) {\\n\\t\\t\\tVoSpoolRewardUser memory voSpoolRewardUser = userRewards[user];\\n\\n\\t\\t\\t// map the configured reward rates since last time we used it\\n\\t\\t\\tVoSpoolRewardRate[] memory voSpoolRewardRatesArray = _getRewardRatesForIndex(\\n\\t\\t\\t\\tvoSpoolRewardUser.lastRewardRateIndex\\n\\t\\t\\t);\\n\\n\\t\\t\\t// `voSpoolRewardRatesArray` array index we're currently using\\n\\t\\t\\t// to retrieve the reward rate belonging to `trancheIndex`\\n\\t\\t\\t// when we reach `rewardRate.toTranche`, we increment `vsrrI`,\\n\\t\\t\\t// and use the updated reward rate to store the reward for\\n\\t\\t\\t// the corresponding index.\\n\\t\\t\\tuint256 vsrrI = 0;\\n\\t\\t\\tVoSpoolRewardRate memory rewardRate = voSpoolRewardRatesArray[0];\\n\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\ttrancheIndex++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// if current reward rate is not valid anymore try getting the next one\\n\\t\\t\\t\\tif (trancheIndex >= rewardRate.toTranche) {\\n\\t\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\t\\tvsrrI++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// check if we reached last element in the array\\n\\t\\t\\t\\t\\tif (vsrrI < voSpoolRewardRatesArray.length) {\\n\\t\\t\\t\\t\\t\\trewardRate = voSpoolRewardRatesArray[vsrrI];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// if last tranche in an array, there are no more configured rewards\\n\\t\\t\\t\\t\\t\\t// break the loop to save on gas\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// add user maturingAmount for every index\\n\\t\\t\\t\\tuserGradual.rawUnmaturedVotingPower += userGradual.maturingAmount;\\n\\n\\t\\t\\t\\tif (trancheIndex >= rewardRate.fromTranche) {\\n\\t\\t\\t\\t\\t// get actual voting power from raw unmatured voting power\\n\\t\\t\\t\\t\\tuint256 userPower = _getMaturingVotingPowerFromRaw(userGradual.rawUnmaturedVotingPower);\\n\\n\\t\\t\\t\\t\\t// get tranche power for `trancheIndex`\\n\\t\\t\\t\\t\\t// we stored it when callint _storeVoSpoolForNewIndexes function\\n\\t\\t\\t\\t\\tuint256 tranchePowerAtIndex = getTranchePower(trancheIndex);\\n\\n\\t\\t\\t\\t\\t// calculate users earned rewards for index based on\\n\\t\\t\\t\\t\\t// 1. reward rate for `trancheIndex`\\n\\t\\t\\t\\t\\t// 2. user power for `trancheIndex`\\n\\t\\t\\t\\t\\t// 3. global tranche power for `trancheIndex`\\n\\t\\t\\t\\t\\tif (tranchePowerAtIndex > 0) {\\n\\t\\t\\t\\t\\t\\tvoSpoolRewardUser.earned += uint248(\\n\\t\\t\\t\\t\\t\\t\\t(rewardRate.rewardPerTranche * userPower) / tranchePowerAtIndex\\n\\t\\t\\t\\t\\t\\t);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// update rewards until we reach last finished tranche index\\n\\t\\t\\t} while (trancheIndex < lastFinishedTrancheIndex);\\n\\n\\t\\t\\t// store the updated user value\\n\\t\\t\\tvoSpoolRewardUser.lastRewardRateIndex = uint8(voSpoolRewardConfig.rewardRatesIndex);\\n\\t\\t\\tuserRewards[user] = voSpoolRewardUser;\\n\\n\\t\\t\\temit UserRewardUpdated(user, voSpoolRewardUser.lastRewardRateIndex, voSpoolRewardUser.earned);\\n\\t\\t}\\n\\t}\\n\\n\\t/* ========== HELPERS ========== */\\n\\n\\t/**\\n\\t * @notice Store the new reward rate to `voSpoolRewardRates` mapping\\n\\t *\\n\\t * @param voSpoolRewardRate struct to store\\n\\t * @param rewardRatesIndex reward rates intex to use when storing the `voSpoolRewardRate`\\n\\t */\\n\\tfunction _setRewardRate(VoSpoolRewardRate memory voSpoolRewardRate, uint256 rewardRatesIndex) private {\\n\\t\\tuint256 arrayIndex = rewardRatesIndex / 2;\\n\\t\\tuint256 position = rewardRatesIndex % 2;\\n\\n\\t\\tif (position == 0) {\\n\\t\\t\\tvoSpoolRewardRates[arrayIndex].zero = voSpoolRewardRate;\\n\\t\\t} else {\\n\\t\\t\\tvoSpoolRewardRates[arrayIndex].one = voSpoolRewardRate;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Reset the storage the `voSpoolRewardRates` for `rewardRatesIndex` index\\n\\t *\\n\\t * @param rewardRatesIndex index to reset the storage for\\n\\t */\\n\\tfunction _resetRewardRate(uint256 rewardRatesIndex) private {\\n\\t\\t_setRewardRate(VoSpoolRewardRate(0, 0, 0), rewardRatesIndex);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieve the reward rate for index from storage\\n\\t *\\n\\t * @param rewardRatesIndex index to retrieve for\\n\\t * @return voSpoolRewardRate storage pointer to the desired reward rate struct\\n\\t */\\n\\tfunction _getRewardRate(uint256 rewardRatesIndex) private view returns (VoSpoolRewardRate storage) {\\n\\t\\tuint256 arrayIndex = rewardRatesIndex / 2;\\n\\t\\tuint256 position = rewardRatesIndex % 2;\\n\\n\\t\\tif (position == 0) {\\n\\t\\t\\treturn voSpoolRewardRates[arrayIndex].zero;\\n\\t\\t} else {\\n\\t\\t\\treturn voSpoolRewardRates[arrayIndex].one;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns all reward rates in an array between last user update and now\\n\\t * @dev Returns an array for simpler access when updating user reward rates for indexes\\n\\t *\\n\\t * @param userLastRewardRateIndex last index user updated\\n\\t * @return voSpoolRewardRatesArray memory array of reward rates\\n\\t */\\n\\tfunction _getRewardRatesForIndex(uint256 userLastRewardRateIndex)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (VoSpoolRewardRate[] memory)\\n\\t{\\n\\t\\tif (userLastRewardRateIndex == 0) userLastRewardRateIndex = 1;\\n\\n\\t\\tuint256 lastRewardRateIndex = voSpoolRewardConfig.rewardRatesIndex;\\n\\t\\tuint256 newRewardRatesCount = lastRewardRateIndex - userLastRewardRateIndex + 1;\\n\\t\\tVoSpoolRewardRate[] memory voSpoolRewardRatesArray = new VoSpoolRewardRate[](newRewardRatesCount);\\n\\n\\t\\tuint256 j = 0;\\n\\t\\tfor (uint256 i = userLastRewardRateIndex; i <= lastRewardRateIndex; i++) {\\n\\t\\t\\tvoSpoolRewardRatesArray[j] = _getRewardRate(i);\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn voSpoolRewardRatesArray;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Store global gradual tranche `power` at tranche `index`\\n\\t * @dev\\n\\t * We know the `power` is always represented with 48bits or less.\\n\\t * We use this information to store 5 `power` values of consecutive\\n\\t * indexes per word.\\n\\t *\\n\\t * @param power global gradual tranche power at `index`\\n\\t * @param index tranche index at which to store\\n\\t */\\n\\tfunction _storeTranchePowerForIndex(uint256 power, uint256 index) private {\\n\\t\\tuint256 arrayindex = index / TRANCHES_PER_WORD;\\n\\n\\t\\tuint256 globalTranchesPosition = index % TRANCHES_PER_WORD;\\n\\n\\t\\tif (globalTranchesPosition == 1) {\\n\\t\\t\\tpower = power << 48;\\n\\t\\t} else if (globalTranchesPosition == 2) {\\n\\t\\t\\tpower = power << 96;\\n\\t\\t} else if (globalTranchesPosition == 3) {\\n\\t\\t\\tpower = power << 144;\\n\\t\\t} else if (globalTranchesPosition == 4) {\\n\\t\\t\\tpower = power << 192;\\n\\t\\t}\\n\\n\\t\\tunchecked {\\n\\t\\t\\t_tranchePowers[arrayindex] += power;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieve global gradual tranche power at `index`\\n\\t * @dev Same, but reversed, mechanism is used to retrieve the power at index\\n\\t *\\n\\t * @param index tranche index at which to retrieve the power value\\n\\t * @return power global gradual tranche power at `index`\\n\\t */\\n\\tfunction getTranchePower(uint256 index) public view returns (uint256) {\\n\\t\\tuint256 arrayindex = index / TRANCHES_PER_WORD;\\n\\n\\t\\tuint256 powers = _tranchePowers[arrayindex];\\n\\n\\t\\tuint256 globalTranchesPosition = index % TRANCHES_PER_WORD;\\n\\n\\t\\tif (globalTranchesPosition == 0) {\\n\\t\\t\\treturn (powers << 208) >> 208;\\n\\t\\t} else if (globalTranchesPosition == 1) {\\n\\t\\t\\treturn (powers << 160) >> 208;\\n\\t\\t} else if (globalTranchesPosition == 2) {\\n\\t\\t\\treturn (powers << 112) >> 208;\\n\\t\\t} else if (globalTranchesPosition == 3) {\\n\\t\\t\\treturn (powers << 64) >> 208;\\n\\t\\t} else {\\n\\t\\t\\treturn (powers << 16) >> 208;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice calculates voting power from raw unmatured\\n\\t *\\n\\t * @param rawMaturingVotingPower raw maturing voting power amount\\n\\t * @return maturingVotingPower actual maturing power amount\\n\\t */\\n\\tfunction _getMaturingVotingPowerFromRaw(uint256 rawMaturingVotingPower) private pure returns (uint256) {\\n\\t\\treturn rawMaturingVotingPower / FULL_POWER_TRANCHES_COUNT;\\n\\t}\\n\\n\\t/* ========== RESTRICTION FUNCTIONS ========== */\\n\\n\\t/**\\n\\t * @dev Ensures the caller is the SPOOL Staking contract\\n\\t */\\n\\tfunction _onlySpoolStaking() private view {\\n\\t\\trequire(msg.sender == spoolStaking, \\\"VoSpoolRewards::_onlySpoolStaking: Insufficient Privileges\\\");\\n\\t}\\n\\n\\t/* ========== MODIFIERS ========== */\\n\\n\\t/**\\n\\t * @dev Throws if the caller is not the SPOOL Staking contract\\n\\t */\\n\\tmodifier onlySpoolStaking() {\\n\\t\\t_onlySpoolStaking();\\n\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/external/spool-core/SpoolOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/ISpoolOwner.sol\\\";\\n\\nabstract contract SpoolOwnable {\\n    ISpoolOwner internal immutable spoolOwner;\\n    \\n    constructor(ISpoolOwner _spoolOwner) {\\n        require(\\n            address(_spoolOwner) != address(0),\\n            \\\"SpoolOwnable::constructor: Spool owner contract address cannot be 0\\\"\\n        );\\n\\n        spoolOwner = _spoolOwner;\\n    }\\n\\n    function isSpoolOwner() internal view returns(bool) {\\n        return spoolOwner.isSpoolOwner(msg.sender);\\n    }\\n\\n    function _onlyOwner() internal view {\\n        require(isSpoolOwner(), \\\"SpoolOwnable::onlyOwner: Caller is not the Spool owner\\\");\\n    }\\n\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/spool-core/interfaces/ISpoolOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface ISpoolOwner {\\n    function isSpoolOwner(address user) external view returns(bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVoSPOOL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice global gradual struct\\n * @member totalMaturedVotingPower total fully-matured voting power amount\\n * @member totalMaturingAmount total maturing amount (amount of power that is accumulating every week for 1/156 of the amount)\\n * @member totalRawUnmaturedVotingPower total raw voting power still maturing every tranche (totalRawUnmaturedVotingPower/156 is its voting power)\\n * @member lastUpdatedTrancheIndex last (finished) tranche index global gradual has updated\\n */\\nstruct GlobalGradual {\\n\\tuint48 totalMaturedVotingPower;\\n\\tuint48 totalMaturingAmount;\\n\\tuint56 totalRawUnmaturedVotingPower;\\n\\tuint16 lastUpdatedTrancheIndex;\\n}\\n\\n/**\\n * @notice user tranche position struct, pointing at user tranche\\n * @dev points at `userTranches` mapping\\n * @member arrayIndex points at `userTranches`\\n * @member position points at UserTranches position from zero to three (zero, one, two, or three)\\n */\\nstruct UserTranchePosition {\\n\\tuint16 arrayIndex;\\n\\tuint8 position;\\n}\\n\\n/**\\n * @notice user gradual struct, similar to global gradual holds user gragual voting power values\\n * @dev points at `userTranches` mapping\\n * @member maturedVotingPower users fully-matured voting power amount\\n * @member maturingAmount users maturing amount\\n * @member rawUnmaturedVotingPower users raw voting power still maturing every tranche\\n * @member oldestTranchePosition UserTranchePosition pointing at the oldest unmatured UserTranche\\n * @member latestTranchePosition UserTranchePosition pointing at the latest unmatured UserTranche\\n * @member lastUpdatedTrancheIndex last (finished) tranche index user gradual has updated\\n */\\nstruct UserGradual {\\n\\tuint48 maturedVotingPower; // matured voting amount, power accumulated and older than FULL_POWER_TIME, not accumulating anymore\\n\\tuint48 maturingAmount; // total maturing amount (also maximum matured)\\n\\tuint56 rawUnmaturedVotingPower; // current user raw unmatured voting power (increases every new tranche), actual unmatured voting power can be calculated as unmaturedVotingPower / FULL_POWER_TRANCHES_COUNT\\n\\tUserTranchePosition oldestTranchePosition; // if arrayIndex is 0, user has no tranches (even if `latestTranchePosition` is not empty)\\n\\tUserTranchePosition latestTranchePosition; // can only increment, in case of tranche removal, next time user gradually mints we point at tranche at next position\\n\\tuint16 lastUpdatedTrancheIndex;\\n}\\n\\n/**\\n * @title Spool DAO Voting Token interface\\n */\\ninterface IVoSPOOL {\\n\\t/* ========== FUNCTIONS ========== */\\n\\n\\tfunction mint(address, uint256) external;\\n\\n\\tfunction burn(address, uint256) external;\\n\\n\\tfunction mintGradual(address, uint256) external;\\n\\n\\tfunction burnGradual(\\n\\t\\taddress,\\n\\t\\tuint256,\\n\\t\\tbool\\n\\t) external;\\n\\n\\tfunction updateVotingPower() external;\\n\\n\\tfunction updateUserVotingPower(address user) external;\\n\\n\\tfunction getTotalGradualVotingPower() external returns (uint256);\\n\\n\\tfunction getUserGradualVotingPower(address user) external returns (uint256);\\n\\n\\tfunction getNotUpdatedUserGradual(address user) external view returns (UserGradual memory);\\n\\n\\tfunction getNotUpdatedGlobalGradual() external view returns (GlobalGradual memory);\\n\\n\\tfunction getCurrentTrancheIndex() external view returns (uint16);\\n\\n\\tfunction getLastFinishedTrancheIndex() external view returns (uint16);\\n\\n\\t/* ========== EVENTS ========== */\\n\\n\\tevent Minted(address indexed recipient, uint256 amount);\\n\\n\\tevent Burned(address indexed source, uint256 amount);\\n\\n\\tevent GradualMinted(address indexed recipient, uint256 amount);\\n\\n\\tevent GradualBurned(address indexed source, uint256 amount, bool burnAll);\\n\\n\\tevent GlobalGradualUpdated(\\n\\t\\tuint16 indexed lastUpdatedTrancheIndex,\\n\\t\\tuint48 totalMaturedVotingPower,\\n\\t\\tuint48 totalMaturingAmount,\\n\\t\\tuint56 totalRawUnmaturedVotingPower\\n\\t);\\n\\n\\tevent UserGradualUpdated(\\n\\t\\taddress indexed user,\\n\\t\\tuint16 indexed lastUpdatedTrancheIndex,\\n\\t\\tuint48 maturedVotingPower,\\n\\t\\tuint48 maturingAmount,\\n\\t\\tuint56 rawUnmaturedVotingPower\\n\\t);\\n\\n\\tevent MinterSet(address indexed minter, bool set);\\n\\n\\tevent GradualMinterSet(address indexed minter, bool set);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVoSpoolRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface IVoSpoolRewards {\\n\\t/* ========== FUNCTIONS ========== */\\n\\n\\tfunction updateRewards(address user) external returns (uint256);\\n\\n\\tfunction flushRewards(address user) external returns (uint256);\\n\\n\\t/* ========== EVENTS ========== */\\n\\n\\tevent RewardRateUpdated(uint8 indexed fromTranche, uint8 indexed toTranche, uint112 rewardPerTranche);\\n\\n\\tevent RewardEnded(\\n\\t\\tuint256 indexed rewardRatesIndex,\\n\\t\\tuint8 indexed fromTranche,\\n\\t\\tuint8 indexed toTranche,\\n\\t\\tuint8 currentTrancheIndex\\n\\t);\\n\\n\\tevent UserRewardUpdated(address indexed user, uint8 lastRewardRateIndex, uint248 earned);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spoolStaking\",\"type\":\"address\"},{\"internalType\":\"contract IVoSPOOL\",\"name\":\"_voSpool\",\"type\":\"address\"},{\"internalType\":\"contract ISpoolOwner\",\"name\":\"_spoolOwner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardRatesIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"fromTranche\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"toTranche\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"currentTrancheIndex\",\"type\":\"uint8\"}],\"name\":\"RewardEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"fromTranche\",\"type\":\"uint8\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"toTranche\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"rewardPerTranche\",\"type\":\"uint112\"}],\"name\":\"RewardRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"lastRewardRateIndex\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint248\",\"name\":\"earned\",\"type\":\"uint248\"}],\"name\":\"UserRewardUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"endVoSpoolReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"flushRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getTranchePower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spoolStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"toTranche\",\"type\":\"uint8\"},{\"internalType\":\"uint112\",\"name\":\"rewardPerTranche\",\"type\":\"uint112\"}],\"name\":\"updateVoSpoolRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRewards\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"lastRewardRateIndex\",\"type\":\"uint8\"},{\"internalType\":\"uint248\",\"name\":\"earned\",\"type\":\"uint248\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voSpool\",\"outputs\":[{\"internalType\":\"contract IVoSPOOL\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voSpoolRewardConfig\",\"outputs\":[{\"internalType\":\"uint240\",\"name\":\"rewardRatesIndex\",\"type\":\"uint240\"},{\"internalType\":\"bool\",\"name\":\"hasRewards\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"lastSetRewardTranche\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voSpoolRewardRates\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"fromTranche\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"toTranche\",\"type\":\"uint8\"},{\"internalType\":\"uint112\",\"name\":\"rewardPerTranche\",\"type\":\"uint112\"}],\"internalType\":\"struct VoSpoolRewardRate\",\"name\":\"zero\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"fromTranche\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"toTranche\",\"type\":\"uint8\"},{\"internalType\":\"uint112\",\"name\":\"rewardPerTranche\",\"type\":\"uint112\"}],\"internalType\":\"struct VoSpoolRewardRate\",\"name\":\"one\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VoSpoolRewards", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "000000000000000000000000fc56e91885d857dccd052dbdd7ace83bdfdbd04c00000000000000000000000014199a3ceeeade52220425918ad2a2cc4b5cb1690000000000000000000000004f03f70a99e5c3b49d733ddd7458f80fa9b5a5b5", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}