{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.7.4;\r\npragma experimental ABIEncoderV2;\r\n\r\n// -- DydxFlashloanBase -- //\r\n\r\ncontract DydxFlashloanBase {\r\n    using SafeMath for uint256;\r\n\r\n    function _getMarketIdFromTokenAddress(address _solo, address token)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        ISoloMargin solo = ISoloMargin(_solo);\r\n        uint256 numMarkets = solo.getNumMarkets();\r\n        address curToken;\r\n        for (uint256 i = 0; i < numMarkets; i++) {\r\n            curToken = solo.getMarketTokenAddress(i);\r\n            if (curToken == token) {\r\n                return i;\r\n            }\r\n        }\r\n        revert(\"No marketId found for provided token\");\r\n    }\r\n\r\n    function _getRepaymentAmountInternal(uint256 amount)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return amount.add(2);\r\n    }\r\n\r\n    function _getAccountInfo() internal returns (Account.Info memory) {\r\n        return Account.Info({owner: address(this), number: 1});\r\n    }\r\n\r\n    function _getWithdrawAction(uint marketId, uint256 amount)\r\n        internal\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Withdraw,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n\r\n    function _getCallAction(bytes memory data)\r\n        internal\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Call,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: false,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: 0\r\n                }),\r\n                primaryMarketId: 0,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: data\r\n            });\r\n    }\r\n\r\n    function _getDepositAction(uint marketId, uint256 amount)\r\n        internal\r\n        returns (Actions.ActionArgs memory)\r\n    {\r\n        return\r\n            Actions.ActionArgs({\r\n                actionType: Actions.ActionType.Deposit,\r\n                accountId: 0,\r\n                amount: Types.AssetAmount({\r\n                    sign: true,\r\n                    denomination: Types.AssetDenomination.Wei,\r\n                    ref: Types.AssetReference.Delta,\r\n                    value: amount\r\n                }),\r\n                primaryMarketId: marketId,\r\n                secondaryMarketId: 0,\r\n                otherAddress: address(this),\r\n                otherAccountId: 0,\r\n                data: \"\"\r\n            });\r\n    }\r\n}\r\n\r\n// -- WyArbiV2 -- //\r\ncontract WyArbiV2 is DydxFlashloanBase{\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n    using address_make_payable for address;\r\n\r\n    struct MyCustomData {       // \u8fd8\u6b3e\u4fe1\u606f\r\n        address token;          // token\r\n        uint256 repayAmount;    // \u8fd8\u6b3e\u6570\u91cf\r\n    }\r\n\r\n    struct StrategyData {       // \u7b56\u7565\u4fe1\u606f\r\n        address token_want;     // \u9700\u8981\u7684token\r\n        address token_media;    // \u4e2d\u8f6ctoken\r\n        address protocol1;      // \u534f\u8bae1\u5730\u5740\r\n        address protocol2;      // \u534f\u8bae2\u5730\u5740\r\n        uint256 in_amount;      // \u8f93\u5165\u6570\u91cf\r\n    }\r\n\r\n    address superMan;\r\n    address dydxAddress;\r\n    address liquidityPoolAddress;\r\n    address uniswapAddress;\r\n    address WETHAddress;\r\n    address USDTAddress;\r\n    address GasTokenV2;\r\n\r\n    mapping (address => mapping (address => int128)) public tokenId;  //protocol\u5730\u5740->token\u5730\u5740->tokenId\r\n    mapping (address => uint256) public functionId;                   //protocol\u5730\u5740->functionId\r\n\r\n    bool if_turnout = true;             // \u76c8\u5229\u662f\u5426\u8f6c\u51fa\r\n    bool if_gastoken = true;            // \u662f\u5426\u4f7f\u7528GasToken\r\n    MyCustomData dydx_mcd;              // dydx\u8fd8\u6b3e\u4fe1\u606f\r\n    MyCustomData liquidity_mcd;         // liquidity\u8fd8\u6b3e\u4fe1\u606f\r\n    StrategyData strategy_data;         // \u7b56\u7565\u4fe1\u606f\r\n    uint256 profit;                     // \u76c8\u5229\u6570\u91cf\r\n\r\n    constructor () public {\r\n        superMan = address(tx.origin);\r\n        dydxAddress = 0x1E0447b19BB6EcFdAe1e4AE1694b0C3659614e4e;\r\n        liquidityPoolAddress = 0x35fFd6E268610E764fF6944d07760D0EFe5E40E5;\r\n        uniswapAddress = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        WETHAddress = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n        USDTAddress = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n        GasTokenV2 = 0x0000000000b3F879cb30FE243b4Dfee438691c04;\r\n\r\n        // curve3pool tokenId DAI USDC USDT\r\n        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 0;\r\n        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\r\n        tokenId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 2;\r\n\r\n        // curveYpool tokenId DAI USDC USDT\r\n        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 0;\r\n        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\r\n        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 2;\r\n        tokenId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)][address(0x0000000000085d4780B73119b644AE5ecd22b376)] = 3;\r\n\r\n        // stableswap tokenId USDP DAI USDC USDT\r\n        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0x1456688345527bE1f37E9e627DA0837D6f08C925)] = 0;\r\n        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0x6B175474E89094C44Da98b954EedeAC495271d0F)] = 1;\r\n        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 2;\r\n        tokenId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 3;\r\n\r\n        // dodo tokenId USDT USDC\r\n        tokenId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)][address(0xdAC17F958D2ee523a2206206994597C13D831ec7)] = 0;\r\n        tokenId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)][address(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48)] = 1;\r\n\r\n        // btcswap tokenId TBTC WBTC renBTC sBTC\r\n        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0x8dAEBADE922dF735c38C80C7eBD708Af50815fAa)] = 0;\r\n        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599)] = 1;\r\n        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0xEB4C2781e4ebA804CE9a9803C67d0893436bB27D)] = 2;\r\n        tokenId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)][address(0xfE18be6b3Bd88A2D2A7f928d00292E7a9963CfC6)] = 3;\r\n\r\n        // curve3Pool functionId\r\n        functionId[address(0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7)] = 1;\r\n        // curveYPool functionId\r\n        functionId[address(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51)] = 2;\r\n        // stableswap functionId\r\n        functionId[address(0x42d7025938bEc20B69cBae5A77421082407f053A)] = 3;\r\n        // component functionId\r\n        functionId[address(0x49519631B404E06ca79C9C7b0dC91648D86F08db)] = 4;\r\n        functionId[address(0x6477960dd932d29518D7e8087d5Ea3D11E606068)] = 4;\r\n        // dodo functionId\r\n        functionId[address(0xC9f93163c99695c6526b799EbcA2207Fdf7D61aD)] = 5;\r\n        // btcswap functionId\r\n        functionId[address(0x4f6A43Ad7cba042606dECaCA730d4CE0A57ac62e)] = 6;\r\n        // uniswapv2 functionId\r\n        functionId[0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D] = 7;\r\n        // sushiswap functionId\r\n        functionId[address(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F)] = 7;\r\n        // balancer functionId\r\n        functionId[address(0x3E66B66Fd1d0b02fDa6C811Da9E0547970DB2f21)] = 8;\r\n    }\r\n\r\n    // \u53d1\u8d77dydx\u95ea\u7535\u8d37\r\n    function initiateFlashLoanDydx(address _token, uint256 _amount) public {\r\n\r\n        ISoloMargin solo = ISoloMargin(dydxAddress);\r\n        uint256 marketId = _getMarketIdFromTokenAddress(dydxAddress, _token);\r\n        uint256 repayAmount = _getRepaymentAmountInternal(_amount);\r\n        IERC20(_token).approve(dydxAddress, repayAmount);\r\n\r\n        Actions.ActionArgs[] memory operations = new Actions.ActionArgs[](3);\r\n        operations[0] = _getWithdrawAction(marketId, _amount);\r\n        operations[1] = _getCallAction(\r\n            abi.encode(MyCustomData({token: _token, repayAmount: repayAmount}))\r\n        );\r\n        operations[2] = _getDepositAction(marketId, repayAmount);\r\n\r\n        Account.Info[] memory accountInfos = new Account.Info[](1);\r\n        accountInfos[0] = _getAccountInfo();\r\n\r\n        solo.operate(accountInfos, operations);\r\n\r\n        // \u76c8\u5229\u8f6c\u51fa\r\n        if (if_turnout) {\r\n            if (_token == WETHAddress) {\r\n                WETHToETH(profit);\r\n                turnOutETH(profit);\r\n            } else {\r\n                uint256 eth_out = uniswapTokensForETH(_token, profit);\r\n                turnOutETH(eth_out);\r\n            }\r\n        }\r\n    }\r\n\r\n    //  dydx\u95ea\u7535\u8d37\u5b9e\u73b0\u64cd\u4f5c\r\n    function callFunction(address sender, Account.Info memory account, bytes memory data) public {\r\n        // \u8fd8\u6b3e\u4fe1\u606f\r\n        dydx_mcd = abi.decode(data, (MyCustomData));\r\n\r\n        // \u64cd\u4f5c\r\n        uint256 output_amount = operation();\r\n\r\n        // \u68c0\u67e5\u76c8\u5229\r\n        require(output_amount > dydx_mcd.repayAmount, \"no profit!\");\r\n        profit = output_amount - dydx_mcd.repayAmount;\r\n    }\r\n\r\n    // \u64cd\u4f5c\r\n    function operation() public returns (uint256) {\r\n        uint256 media_amount = ExchangeBase(\r\n            strategy_data.protocol1,\r\n            strategy_data.token_want,\r\n            strategy_data.token_media,\r\n            strategy_data.in_amount\r\n        );\r\n        if (media_amount == 0) {\r\n            return strategy_data.in_amount;\r\n        }\r\n        uint256 output_amount = ExchangeBase(\r\n            strategy_data.protocol2,\r\n            strategy_data.token_media,\r\n            strategy_data.token_want,\r\n            media_amount\r\n        );\r\n        return output_amount;\r\n    }\r\n\r\n    // \u5165\u53e3\r\n    function execute(address token_want, address token_media, address protocol1, address protocol2,\r\n        uint256 in_amount, uint256 free_value) public {\r\n\r\n        if (if_gastoken) {\r\n            freeGas(free_value);\r\n        }\r\n\r\n        strategy_data.in_amount = in_amount;\r\n        strategy_data.token_want = token_want;\r\n        strategy_data.token_media = token_media;\r\n        strategy_data.protocol1 = protocol1;\r\n        strategy_data.protocol2 = protocol2;\r\n\r\n        initiateFlashLoanDydx(token_want, in_amount);\r\n    }\r\n\r\n    // ExchangeBase\r\n    function ExchangeBase(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 function_id = functionId[protocol];\r\n        uint256 output_amount = 0;\r\n\r\n        if (token_in == USDTAddress) {\r\n            IERC20(token_in).safeApprove(protocol, 0);\r\n            IERC20(token_in).safeApprove(protocol, in_amount);\r\n        } else {\r\n            IERC20(token_in).approve(protocol, in_amount);\r\n        }\r\n\r\n        if (function_id == 1) {\r\n            output_amount = ICurveFiExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 2) {\r\n            output_amount = ICurveFiExchangeUnderlying(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 3) {\r\n            output_amount = IStableSwapExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 4) {\r\n            output_amount = IComponentExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 5) {\r\n            output_amount = IDODOExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 6) {\r\n            output_amount = IBTCSwapExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 7) {\r\n            output_amount = IUniswapExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        if (function_id == 8) {\r\n            output_amount = IBalancerExchange(protocol, token_in, token_out, in_amount);\r\n        }\r\n        return output_amount;\r\n    }\r\n\r\n    // ICurveFiExchange functionId=1\r\n    function ICurveFiExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 balance = IERC20(token_out).balanceOf(address(this));\r\n        ICurveFi(protocol).exchange(tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\r\n\r\n        return IERC20(token_out).balanceOf(address(this)).sub(balance);\r\n    }\r\n\r\n    // ICurveFiExchangeUnderlying functionId=2\r\n    function ICurveFiExchangeUnderlying(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 balance = IERC20(token_out).balanceOf(address(this));\r\n        ICurveFi(protocol).exchange_underlying(tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\r\n\r\n        return IERC20(token_out).balanceOf(address(this)).sub(balance);\r\n    }\r\n\r\n    // IStableSwapExchange functionId=3\r\n    function IStableSwapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 out_amount = IStableSwap(protocol).exchange_underlying(\r\n            tokenId[protocol][token_in], tokenId[protocol][token_out], in_amount, 0);\r\n\r\n        return out_amount;\r\n    }\r\n\r\n    // IComponentExchange functionId=4\r\n    function IComponentExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 out_amount = IComponent(protocol).originSwap(token_in, token_out, in_amount, 0, uint256(block.timestamp).add(100));\r\n\r\n        return out_amount;\r\n    }\r\n\r\n    // IDODOExchange functionId=5  Base=0 Quote=1 \u53ea\u652f\u6301token_in=base token_out=quote\r\n    function IDODOExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        int128 token_in_id = tokenId[protocol][token_in];\r\n        int128 token_out_id = tokenId[protocol][token_out];\r\n        uint256 out_amount;\r\n        if (token_in_id == 0 && token_out_id == 1) {\r\n            out_amount = IDODO(protocol).sellBaseToken(in_amount, 0, '');\r\n        } else {\r\n            revert(\"token_id wrong for dodo!\");\r\n        }\r\n        return out_amount;\r\n    }\r\n\r\n    // IBTCSwapExchange functionId=6\r\n    function IBTCSwapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint8 token_in_id = uint8(tokenId[protocol][token_in]);\r\n        uint8 token_out_id = uint8(tokenId[protocol][token_out]);\r\n\r\n        uint256 out_amount = IBTCswap(protocol).swap(token_in_id, token_out_id, in_amount, 0, uint256(block.timestamp).add(100));\r\n        return out_amount;\r\n    }\r\n\r\n    // IUniswapExchange functionId=7\r\n    function IUniswapExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        address[] memory uniData = new address[](2);\r\n        uniData[0] = token_in;\r\n        uniData[1] = token_out;\r\n        uint[] memory amounts = UniswapV2Router(protocol).swapExactTokensForTokens(in_amount, 0, uniData, address(this),\r\n            uint256(block.timestamp).add(100));\r\n        return uint256(amounts[amounts.length - 1]);\r\n    }\r\n\r\n    // IBalancerExchange functionId=8\r\n    function IBalancerExchange(address protocol, address token_in, address token_out, uint256 in_amount) public returns(uint256) {\r\n        uint256 out_amount = IBalancerRouter(protocol).smartSwapExactIn(TokenInterface(token_in),\r\n                                                                        TokenInterface(token_out), in_amount, 0, 1);\r\n        return out_amount;\r\n    }\r\n\r\n    // Uniswap\r\n    function uniswapTokensForETH(address token, uint256 amount) public returns(uint256) {\r\n        IERC20(token).safeApprove(uniswapAddress, 0);\r\n        IERC20(token).safeApprove(uniswapAddress, amount);\r\n        address[] memory uniData = new address[](2);\r\n        uniData[0] = token;\r\n        uniData[1] = WETHAddress;\r\n        uint[] memory amounts = UniswapV2Router(uniswapAddress).swapExactTokensForETH(amount, 0, uniData, address(this),\r\n                        uint256(block.timestamp).add(100));\r\n        return uint256(amounts[amounts.length - 1]);\r\n    }\r\n\r\n    // get\r\n    function getSuperMan() public view returns(address) {\r\n        return superMan;\r\n    }\r\n\r\n    function getDydxAddress() public view returns(address) {\r\n        return dydxAddress;\r\n    }\r\n\r\n    function getUniswapAddress() public view returns(address) {\r\n        return uniswapAddress;\r\n    }\r\n\r\n    function getGasTokenV2Address() public view returns(address) {\r\n        return GasTokenV2;\r\n    }\r\n\r\n    function getTokenId(address protocol, address token) public view returns(int128) {\r\n        return tokenId[protocol][token];\r\n    }\r\n\r\n    function getFunctionId(address protocol) public view returns(uint256) {\r\n        return functionId[protocol];\r\n    }\r\n\r\n    function getTokenBalance(address token) public view returns(uint256) {\r\n        return IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    // set\r\n    function transferOwnership(address new_owner) public onlyOwner {\r\n        superMan = new_owner;\r\n    }\r\n\r\n    function setTokenID(address protocol, address token, int128 id) public onlyOwner {\r\n        tokenId[protocol][token] = id;\r\n    }\r\n\r\n    function setFunctionId(address protocol, uint256 id) public onlyOwner {\r\n        functionId[protocol] = id;\r\n    }\r\n\r\n    function setIfTurnout(bool tof) public onlyOwner {\r\n        if_turnout = tof;\r\n    }\r\n\r\n    function setIfGastoken(bool tof) public onlyOwner {\r\n        if_gastoken = tof;\r\n    }\r\n\r\n    function setDydxAddress(address new_address) public onlyOwner {\r\n        dydxAddress = new_address;\r\n    }\r\n\r\n    function setUniswapAddress(address new_address) public onlyOwner {\r\n        uniswapAddress = new_address;\r\n    }\r\n\r\n    function setGasTokenV2Address(address new_address) public onlyOwner {\r\n        GasTokenV2 = new_address;\r\n    }\r\n\r\n    function turnOutToken(address token, uint256 amount) public onlyOwner {\r\n        IERC20(token).safeTransfer(superMan, amount);\r\n    }\r\n\r\n    function transferToken(address token, address recipient, uint256 amount) public onlyOwner {\r\n        IERC20(token).safeTransfer(recipient, amount);\r\n    }\r\n\r\n    function turnOutETH(uint256 amount) public onlyOwner {\r\n        address payable addr = superMan.make_payable();\r\n        addr.transfer(amount);\r\n    }\r\n\r\n    function transferETH(address recipient, uint256 amount) public onlyOwner {\r\n        address payable addr = recipient.make_payable();\r\n        addr.transfer(amount);\r\n    }\r\n\r\n    function WETHToETH(uint256 amount) public onlyOwner {\r\n        WETH9(WETHAddress).withdraw(amount);\r\n    }\r\n\r\n    function storeGas(uint256 value) public onlyOwner {\r\n        IGasToken(GasTokenV2).mint(value);\r\n    }\r\n\r\n    function freeGas(uint256 value) public onlyOwner {\r\n        IGasToken(GasTokenV2).freeUpTo(value);\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(address(msg.sender) == superMan, \"No authority\");\r\n        _;\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\n// -- interface -- //\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// Component\r\ninterface IComponent {\r\n    function originSwap (\r\n        address _origin,\r\n        address _target,\r\n        uint _originAmount,\r\n        uint _minTargetAmount,\r\n        uint _deadline\r\n    ) external returns(uint);\r\n}\r\n\r\n// Curve.finance\r\ninterface ICurveFi {\r\n    function exchange(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\r\n    function exchange_underlying(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external;\r\n}\r\n\r\ninterface IStableSwap {\r\n    function exchange_underlying(int128 from, int128 to, uint256 _from_amount, uint256 _min_to_amount) external returns (uint256);\r\n}\r\n\r\n// DODO\r\ninterface IDODO {\r\n    function sellBaseToken(uint256 amount, uint256 minReceiveQuote, bytes calldata data) external returns (uint256);\r\n}\r\n\r\n// BTCswap\r\ninterface IBTCswap{\r\n    function swap(uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 dx, uint256 minDy, uint256 deadline) external returns (uint256);\r\n}\r\n\r\n// Balancer\r\ninterface TokenInterface {\r\n    function balanceOf(address) external view returns (uint);\r\n    function allowance(address, address) external view returns (uint);\r\n    function approve(address, uint) external returns (bool);\r\n    function transfer(address, uint) external returns (bool);\r\n    function transferFrom(address, address, uint) external returns (bool);\r\n    function deposit() external payable;\r\n    function withdraw(uint) external;\r\n}\r\ninterface IBalancerRouter {\r\n    function smartSwapExactIn(TokenInterface tokenIn, TokenInterface tokenOut, uint totalAmountIn,\r\n                              uint minTotalAmountOut, uint nPools)   external returns (uint);\r\n}\r\n\r\n// Uniswap\r\ninterface UniswapV2Router {\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n     function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n}\r\n\r\n// dydx solomargin\r\ninterface ISoloMargin {\r\n    function getNumMarkets() external returns (uint256);\r\n    function getMarketTokenAddress(uint256 marketId) external returns (address);\r\n    function operate(Account.Info[] memory accounts, Actions.ActionArgs[] memory actions) external;\r\n}\r\n\r\n// WETH\r\ninterface WETH9 {\r\n    function deposit() external payable;\r\n    function withdraw(uint wad) external;\r\n}\r\n\r\n// GasToken\r\ninterface IGasToken {\r\n    function mint(uint256 value) external;\r\n    function freeUpTo(uint256 value) external returns (uint256);\r\n}\r\n\r\n// -- library -- //\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value:amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary address_make_payable {\r\n   function make_payable(address x) internal pure returns (address payable) {\r\n      return address(uint160(x));\r\n   }\r\n}\r\n\r\nlibrary Account {\r\n    enum Status {Normal, Liquid, Vapor}\r\n    struct Info {\r\n        address owner; // The address that owns the account\r\n        uint256 number; // A nonce that allows a single address to control many accounts\r\n    }\r\n    struct Storage {\r\n        mapping(uint256 => Types.Par) balances; // Mapping from marketId to principal\r\n        Status status;\r\n    }\r\n}\r\n\r\nlibrary Actions {\r\n    enum ActionType {\r\n        Deposit, // supply tokens\r\n        Withdraw, // borrow tokens\r\n        Transfer, // transfer balance between accounts\r\n        Buy, // buy an amount of some token (publicly)\r\n        Sell, // sell an amount of some token (publicly)\r\n        Trade, // trade tokens against another account\r\n        Liquidate, // liquidate an undercollateralized or expiring account\r\n        Vaporize, // use excess tokens to zero-out a completely negative account\r\n        Call // send arbitrary data to an address\r\n    }\r\n\r\n    enum AccountLayout {OnePrimary, TwoPrimary, PrimaryAndSecondary}\r\n\r\n    enum MarketLayout {ZeroMarkets, OneMarket, TwoMarkets}\r\n\r\n    struct ActionArgs {\r\n        ActionType actionType;\r\n        uint256 accountId;\r\n        Types.AssetAmount amount;\r\n        uint256 primaryMarketId;\r\n        uint256 secondaryMarketId;\r\n        address otherAddress;\r\n        uint256 otherAccountId;\r\n        bytes data;\r\n    }\r\n\r\n    struct DepositArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address from;\r\n    }\r\n\r\n    struct WithdrawArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 market;\r\n        address to;\r\n    }\r\n\r\n    struct TransferArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info accountOne;\r\n        Account.Info accountTwo;\r\n        uint256 market;\r\n    }\r\n\r\n    struct BuyArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 makerMarket;\r\n        uint256 takerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct SellArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info account;\r\n        uint256 takerMarket;\r\n        uint256 makerMarket;\r\n        address exchangeWrapper;\r\n        bytes orderData;\r\n    }\r\n\r\n    struct TradeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info takerAccount;\r\n        Account.Info makerAccount;\r\n        uint256 inputMarket;\r\n        uint256 outputMarket;\r\n        address autoTrader;\r\n        bytes tradeData;\r\n    }\r\n\r\n    struct LiquidateArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info liquidAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct VaporizeArgs {\r\n        Types.AssetAmount amount;\r\n        Account.Info solidAccount;\r\n        Account.Info vaporAccount;\r\n        uint256 owedMarket;\r\n        uint256 heldMarket;\r\n    }\r\n\r\n    struct CallArgs {\r\n        Account.Info account;\r\n        address callee;\r\n        bytes data;\r\n    }\r\n}\r\n\r\nlibrary Decimal {\r\n    struct D256 {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Interest {\r\n    struct Rate {\r\n        uint256 value;\r\n    }\r\n\r\n    struct Index {\r\n        uint96 borrow;\r\n        uint96 supply;\r\n        uint32 lastUpdate;\r\n    }\r\n}\r\n\r\nlibrary Monetary {\r\n    struct Price {\r\n        uint256 value;\r\n    }\r\n    struct Value {\r\n        uint256 value;\r\n    }\r\n}\r\n\r\nlibrary Storage {\r\n    // All information necessary for tracking a market\r\n    struct Market {\r\n        // Contract address of the associated ERC20 token\r\n        address token;\r\n        // Total aggregated supply and borrow amount of the entire market\r\n        Types.TotalPar totalPar;\r\n        // Interest index of the market\r\n        Interest.Index index;\r\n        // Contract address of the price oracle for this market\r\n        address priceOracle;\r\n        // Contract address of the interest setter for this market\r\n        address interestSetter;\r\n        // Multiplier on the marginRatio for this market\r\n        Decimal.D256 marginPremium;\r\n        // Multiplier on the liquidationSpread for this market\r\n        Decimal.D256 spreadPremium;\r\n        // Whether additional borrows are allowed for this market\r\n        bool isClosing;\r\n    }\r\n\r\n    // The global risk parameters that govern the health and security of the system\r\n    struct RiskParams {\r\n        // Required ratio of over-collateralization\r\n        Decimal.D256 marginRatio;\r\n        // Percentage penalty incurred by liquidated accounts\r\n        Decimal.D256 liquidationSpread;\r\n        // Percentage of the borrower's interest fee that gets passed to the suppliers\r\n        Decimal.D256 earningsRate;\r\n        // The minimum absolute borrow value of an account\r\n        // There must be sufficient incentivize to liquidate undercollateralized accounts\r\n        Monetary.Value minBorrowedValue;\r\n    }\r\n\r\n    // The maximum RiskParam values that can be set\r\n    struct RiskLimits {\r\n        uint64 marginRatioMax;\r\n        uint64 liquidationSpreadMax;\r\n        uint64 earningsRateMax;\r\n        uint64 marginPremiumMax;\r\n        uint64 spreadPremiumMax;\r\n        uint128 minBorrowedValueMax;\r\n    }\r\n\r\n    // The entire storage state of Solo\r\n    struct State {\r\n        // number of markets\r\n        uint256 numMarkets;\r\n        // marketId => Market\r\n        mapping(uint256 => Market) markets;\r\n        // owner => account number => Account\r\n        mapping(address => mapping(uint256 => Account.Storage)) accounts;\r\n        // Addresses that can control other users accounts\r\n        mapping(address => mapping(address => bool)) operators;\r\n        // Addresses that can control all users accounts\r\n        mapping(address => bool) globalOperators;\r\n        // mutable risk parameters of the system\r\n        RiskParams riskParams;\r\n        // immutable risk limits of the system\r\n        RiskLimits riskLimits;\r\n    }\r\n}\r\n\r\nlibrary Types {\r\n    enum AssetDenomination {\r\n        Wei, // the amount is denominated in wei\r\n        Par // the amount is denominated in par\r\n    }\r\n\r\n    enum AssetReference {\r\n        Delta, // the amount is given as a delta from the current value\r\n        Target // the amount is given as an exact number to end up at\r\n    }\r\n\r\n    struct AssetAmount {\r\n        bool sign; // true if positive\r\n        AssetDenomination denomination;\r\n        AssetReference ref;\r\n        uint256 value;\r\n    }\r\n\r\n    struct TotalPar {\r\n        uint128 borrow;\r\n        uint128 supply;\r\n    }\r\n\r\n    struct Par {\r\n        bool sign; // true if positive\r\n        uint128 value;\r\n    }\r\n\r\n    struct Wei {\r\n        bool sign; // true if positive\r\n        uint256 value;\r\n    }\r\n}", "ABI": "[]", "ContractName": "Account", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1eb41b6ad5b57dd3cefb1c9b1e15cc63877c4cc4b0ebea1bb74fe017d2aa8c98"}]}