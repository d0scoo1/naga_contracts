{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.3;\r\n\r\n/**\r\n * @title Represents an ownable resource.\r\n */\r\ncontract Ownable {\r\n    address internal _owner;\r\n\r\n    event OwnershipTransferred(address previousOwner, address newOwner);\r\n\r\n    /**\r\n     * Constructor\r\n     * @param addr The owner of the smart contract\r\n     */\r\n    constructor (address addr) {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        require(addr != address(1), \"ecrecover address not allowed\");\r\n        _owner = addr;\r\n        emit OwnershipTransferred(address(0), addr);\r\n    }\r\n\r\n    /**\r\n     * @notice This modifier indicates that the function can only be called by the owner.\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"Only owner requirement\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ownership to the address specified.\r\n     * @param addr Specifies the address of the new owner.\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    function transferOwnership (address addr) public onlyOwner {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        emit OwnershipTransferred(_owner, addr);\r\n        _owner = addr;\r\n    }\r\n\r\n    /**\r\n     * @notice Destroys the smart contract.\r\n     * @param addr The payable address of the recipient.\r\n     */\r\n    function destroy(address payable addr) public virtual onlyOwner {\r\n        require(addr != address(0), \"non-zero address required\");\r\n        require(addr != address(1), \"ecrecover address not allowed\");\r\n        selfdestruct(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the owner.\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates if the address specified is the owner of the resource.\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner(address addr) public view returns (bool) {\r\n        return addr == _owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n    /**\r\n    * Transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Transfer tokens from one address to another.\r\n     * Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Returns the total number of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function decimals() external view returns (uint8);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n    * Gets the balance of the address specified.\r\n    * @param addr The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address addr) external view returns (uint256);\r\n\r\n    /**\r\n     * Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * This event is triggered when a given amount of tokens is sent to an address.\r\n     * @param from The address of the sender\r\n     * @param to The address of the receiver\r\n     * @param value The amount transferred\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * This event is triggered when a given address is approved to spend a specific amount of tokens\r\n     * on behalf of the sender.\r\n     * @param owner The owner of the token\r\n     * @param spender The spender\r\n     * @param value The amount to transfer\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Represents an ERC-20\r\n */\r\ncontract ERC20 is IERC20 {\r\n    // Basic ERC-20 data\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n    uint256 internal _totalSupply;\r\n\r\n    // The balance of each owner\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    // The allowance set by each owner\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param tokenName The name of the token\r\n     * @param tokenSymbol The symbol of the token\r\n     * @param tokenDecimals The decimals of the token\r\n     * @param initialSupply The initial supply\r\n     */\r\n    constructor (string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals, uint256 initialSupply) {\r\n        _name = tokenName;\r\n        _symbol = tokenSymbol;\r\n        _decimals = tokenDecimals;\r\n        _totalSupply = initialSupply;\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers a given amount tokens to the address specified.\r\n    * @param from The address of the sender.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return Returns true in case of success.\r\n    */\r\n    function executeErc20Transfer (address from, address to, uint256 value) private returns (bool) {\r\n        // Checks\r\n        require(to != address(0), \"non-zero address required\");\r\n        require(from != address(0), \"non-zero sender required\");\r\n        require(value > 0, \"Amount cannot be zero\");\r\n        require(_balances[from] >= value, \"Amount exceeds sender balance\");\r\n\r\n        // State changes\r\n        _balances[from] = _balances[from] - value;\r\n        _balances[to] = _balances[to] + value;\r\n\r\n        // Emit the event per ERC-20\r\n        emit Transfer(from, to, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param ownerAddr The address of the owner.\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function approveSpender(address ownerAddr, address spender, uint256 value) private returns (bool) {\r\n        require(spender != address(0), \"non-zero spender required\");\r\n        require(ownerAddr != address(0), \"non-zero owner required\");\r\n\r\n        // State changes\r\n        _allowances[ownerAddr][spender] = value;\r\n\r\n        // Emit the event\r\n        emit Approval(ownerAddr, spender, value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers a given amount tokens to the address specified.\r\n    * @param to The address to transfer to.\r\n    * @param value The amount to be transferred.\r\n    * @return Returns true in case of success.\r\n    */\r\n    function transfer(address to, uint256 value) public override returns (bool) {\r\n        require (executeErc20Transfer(msg.sender, to, value), \"Failed to execute ERC20 transfer\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer tokens from one address to another.\r\n     * @dev Note that while this function emits an Approval event, this is not required as per the specification,\r\n     * and other compliant implementations may not emit the event.\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     * @return Returns true in case of success.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) public override returns (bool) {\r\n        require (executeErc20Transfer(from, to, value), \"Failed to execute transferFrom\");\r\n\r\n        uint256 currentAllowance = _allowances[from][msg.sender];\r\n        require(currentAllowance >= value, \"Amount exceeds allowance\");\r\n\r\n        require(approveSpender(from, msg.sender, currentAllowance - value), \"ERC20: Approval failed\");\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * @dev Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering.\r\n     * One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0\r\n     * and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param spender The address which will spend the funds.\r\n     * @param value The amount of tokens to be spent.\r\n     * @return Returns true in case of success.\r\n     */\r\n    function approve(address spender, uint256 value) public override returns (bool) {\r\n        require(approveSpender(msg.sender, spender, value), \"ERC20: Approval failed\");\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Gets the total supply of tokens\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the name of the token.\r\n     */\r\n    function name() public view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the symbol of the token.\r\n     */\r\n    function symbol() public view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the decimals of the token.\r\n     */\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /**\r\n    * Gets the balance of the address specified.\r\n    * @param addr The address to query the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address addr) public view override returns (uint256) {\r\n        return _balances[addr];\r\n    }\r\n\r\n    /**\r\n     * Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param owner address The address which owns the funds.\r\n     * @param spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address owner, address spender) public view override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n}\r\n\r\n/**\r\n * @notice Represents an ERC20 that can be minted and/or burnt by multiple parties.\r\n */\r\ncontract Mintable is ERC20, Ownable {\r\n    /**\r\n     * @notice The maximum circulating supply of tokens\r\n     */\r\n    uint256 public maxSupply;\r\n\r\n    // Keeps track of the authorized minters\r\n    mapping (address => bool) internal _authorizedMinters;\r\n\r\n    // Keeps track of the authorized burners\r\n    mapping (address => bool) internal _authorizedBurners;\r\n\r\n    // ---------------------------------------\r\n    // Events\r\n    // ---------------------------------------\r\n    /**\r\n     * This event is triggered whenever an address is added as a valid minter.\r\n     * @param addr The address that became a valid minter\r\n     */\r\n    event OnMinterGranted(address addr);\r\n\r\n    /**\r\n     * This event is triggered when a minter is revoked.\r\n     * @param addr The address that was revoked\r\n     */\r\n    event OnMinterRevoked(address addr);\r\n\r\n    /**\r\n     * This event is triggered whenever an address is added as a valid burner.\r\n     * @param addr The address that became a valid burner\r\n     */\r\n    event OnBurnerGranted(address addr);\r\n\r\n    /**\r\n     * This event is triggered when a burner is revoked.\r\n     * @param addr The address that was revoked\r\n     */\r\n    event OnBurnerRevoked(address addr);\r\n\r\n    /**\r\n     * This event is triggered when the maximum limit for minting tokens is updated.\r\n     * @param prevValue The previous limit\r\n     * @param newValue The new limit\r\n     */\r\n    event OnMaxSupplyChanged(uint256 prevValue, uint256 newValue);\r\n\r\n    // ---------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------\r\n    /**\r\n     * @notice Constructor\r\n     * @param newOwner The contract owner\r\n     * @param tokenName The name of the token\r\n     * @param tokenSymbol The symbol of the token\r\n     * @param tokenDecimals The decimals of the token\r\n     * @param initialSupply The initial supply\r\n     */\r\n    constructor (address newOwner, string memory tokenName, string memory tokenSymbol, uint8 tokenDecimals, uint256 initialSupply)\r\n    ERC20(tokenName, tokenSymbol, tokenDecimals, initialSupply)\r\n    Ownable(newOwner) { // solhint-disable-line no-empty-blocks\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if the sender is not a valid minter\r\n     */\r\n    modifier onlyMinter() {\r\n        require(_authorizedMinters[msg.sender], \"Unauthorized minter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if the sender is not a valid burner\r\n     */\r\n    modifier onlyBurner() {\r\n        require(_authorizedBurners[msg.sender], \"Unauthorized burner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Grants the right to issue new tokens to the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function grantMinter (address addr) public onlyOwner {\r\n        require(!_authorizedMinters[addr], \"Address authorized already\");\r\n        _authorizedMinters[addr] = true;\r\n        emit OnMinterGranted(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the right to issue new tokens from the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function revokeMinter (address addr) public onlyOwner {\r\n        require(_authorizedMinters[addr], \"Address was never authorized\");\r\n        _authorizedMinters[addr] = false;\r\n        emit OnMinterRevoked(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Grants the right to burn tokens to the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function grantBurner (address addr) public onlyOwner {\r\n        require(!_authorizedBurners[addr], \"Address authorized already\");\r\n        _authorizedBurners[addr] = true;\r\n        emit OnBurnerGranted(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the right to burn tokens from the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param addr The destination address\r\n     */\r\n    function revokeBurner (address addr) public onlyOwner {\r\n        require(_authorizedBurners[addr], \"Address was never authorized\");\r\n        _authorizedBurners[addr] = false;\r\n        emit OnBurnerRevoked(addr);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the maximum limit for minting tokens.\r\n     * @param newValue The new limit\r\n     */\r\n    function changeMaxSupply (uint256 newValue) public onlyOwner {\r\n        require(newValue == 0 || newValue > _totalSupply, \"Invalid max supply\");\r\n        emit OnMaxSupplyChanged(maxSupply, newValue);\r\n        maxSupply = newValue;\r\n    }\r\n\r\n    /**\r\n     * @notice Issues a given number of tokens to the address specified.\r\n     * @dev This function throws if the sender is not a whitelisted minter.\r\n     * @param addr The destination address\r\n     * @param amount The number of tokens\r\n     */\r\n    function mint (address addr, uint256 amount) public onlyMinter {\r\n        require(addr != address(0) && addr != address(this), \"Invalid address\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(canMint(amount), \"Max token supply exceeded\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[addr] += amount;\r\n        emit Transfer(address(0), addr, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burns a given number of tokens from the address specified.\r\n     * @dev This function throws if the sender is not a whitelisted minter. In this context, minters and burners have the same privileges.\r\n     * @param addr The destination address\r\n     * @param amount The number of tokens\r\n     */\r\n    function burn (address addr, uint256 amount) public onlyBurner {\r\n        require(addr != address(0) && addr != address(this), \"Invalid address\");\r\n        require(amount > 0, \"Invalid amount\");\r\n        require(_totalSupply > 0, \"No token supply\");\r\n\r\n        uint256 accountBalance = _balances[addr];\r\n        require(accountBalance >= amount, \"Burn amount exceeds balance\");\r\n\r\n        _balances[addr] = accountBalance - amount;\r\n        _totalSupply -= amount;\r\n        emit Transfer(addr, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Indicates if we can issue/mint the number of tokens specified.\r\n     * @param amount The number of tokens to issue/mint\r\n     */\r\n    function canMint (uint256 amount) public view returns (bool) {\r\n        return (maxSupply == 0) || (_totalSupply + amount <= maxSupply);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Represents a controllable resource.\r\n */\r\ncontract Controllable is Ownable {\r\n    // The address of the controller\r\n    address internal _controllerAddress;\r\n\r\n    /**\r\n     * @notice Constructor\r\n     * @param ownerAddr The owner of the smart contract\r\n     * @param controllerAddr The address of the controller\r\n     */\r\n    constructor (address ownerAddr, address controllerAddr) Ownable (ownerAddr) {\r\n        require(controllerAddr != address(0), \"Controller address required\");\r\n        require(controllerAddr != ownerAddr, \"Owner cannot be the Controller\");\r\n        _controllerAddress = controllerAddr;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if the sender is not the controller\r\n     */\r\n    modifier onlyController() {\r\n        require(msg.sender == _controllerAddress, \"Unauthorized controller\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Makes sure the sender is either the owner of the contract or the controller\r\n     */\r\n    modifier onlyOwnerOrController() {\r\n        require(msg.sender == _controllerAddress || msg.sender == _owner, \"Only owner or controller\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the controller\r\n     * @dev This function can be called by the owner only\r\n     * @param controllerAddr The address of the controller\r\n     */\r\n    function setController (address controllerAddr) public onlyOwner {\r\n        // Checks\r\n        require(controllerAddr != address(0), \"Controller address required\");\r\n        require(controllerAddr != _owner, \"Owner cannot be the Controller\");\r\n        require(controllerAddr != _controllerAddress, \"Controller already set\");\r\n\r\n        // State changes\r\n        _controllerAddress = controllerAddr;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the address of the controller\r\n     * @return Returns an address\r\n     */\r\n    function getControllerAddress () public view returns (address) {\r\n        return _controllerAddress;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a receipt token. The token is fully compliant with the ERC20 interface.\r\n * @dev The token can be minted or burnt by whitelisted addresses only. Only the owner is allowed to enable/disable addresses.\r\n */\r\ncontract ReceiptToken is Mintable {\r\n    /**\r\n     * @notice Constructor.\r\n     * @param newOwner The owner of the smart contract.\r\n     */\r\n    constructor (address newOwner, uint256 initialMaxSupply) Mintable(newOwner, \"Fractal Protocol Vault Token\", \"USDF\", 6, 0) {\r\n        maxSupply = initialMaxSupply;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @notice This library provides stateless, general purpose functions.\r\n */\r\nlibrary Utils {\r\n    /**\r\n     * @notice Indicates if the address specified represents a smart contract.\r\n     * @dev Notice that this method returns TRUE if the address is a contract under construction\r\n     * @param addr The address to evaluate\r\n     * @return Returns true if the address represents a smart contract\r\n     */\r\n    function isContract (address addr) internal view returns (bool) {\r\n        bytes32 eoaHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n        bytes32 codeHash;\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codeHash := extcodehash(addr) }\r\n\r\n        return (codeHash != eoaHash && codeHash != 0x0);\r\n    }\r\n}\r\n\r\n\r\nlibrary DateUtils {\r\n    // The number of seconds per day\r\n    uint256 internal constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n\r\n    // The number of seconds per hour\r\n    uint256 internal constant SECONDS_PER_HOUR = 60 * 60;\r\n\r\n    // The number of seconds per minute\r\n    uint256 internal constant SECONDS_PER_MINUTE = 60;\r\n\r\n    // The offset from 01/01/1970\r\n    int256 internal constant OFFSET19700101 = 2440588;\r\n\r\n    /**\r\n     * @notice Gets the year of the timestamp specified.\r\n     * @param timestamp The timestamp\r\n     * @return year The year\r\n     */\r\n    function getYear (uint256 timestamp) internal pure returns (uint256 year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the timestamp of the date specified.\r\n     * @param year The year\r\n     * @param month The month\r\n     * @param day The day\r\n     * @param hour The hour\r\n     * @param minute The minute\r\n     * @param second The seconds\r\n     * @return timestamp The timestamp\r\n     */\r\n    function timestampFromDateTime(uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) internal pure returns (uint256 timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the number of days elapsed between the two timestamps specified.\r\n     * @param fromTimestamp The source date\r\n     * @param toTimestamp The target date\r\n     * @return Returns the difference, in days\r\n     */\r\n    function diffDays (uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256) {\r\n        require(fromTimestamp <= toTimestamp, \"Invalid order for timestamps\");\r\n        return (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate year/month/day from the number of days since 1970/01/01 using the date conversion algorithm from http://aa.usno.navy.mil/faq/docs/JD_Formula.php and adding the offset 2440588 so that 1970/01/01 is day 0\r\n     * @dev Taken from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\r\n     * @param _days The year\r\n     * @return year The year\r\n     * @return month The month\r\n     * @return day The day\r\n     */\r\n    function _daysToDate (uint256 _days) internal pure returns (uint256 year, uint256 month, uint256 day) {\r\n        int256 __days = int256(_days);\r\n\r\n        int256 x = __days + 68569 + OFFSET19700101;\r\n        int256 n = 4 * x / 146097;\r\n        x = x - (146097 * n + 3) / 4;\r\n        int256 _year = 4000 * (x + 1) / 1461001;\r\n        x = x - 1461 * _year / 4 + 31;\r\n        int256 _month = 80 * x / 2447;\r\n        int256 _day = x - 2447 * _month / 80;\r\n        x = _month / 11;\r\n        _month = _month + 2 - 12 * x;\r\n        _year = 100 * (n - 49) + _year + x;\r\n\r\n        year = uint256(_year);\r\n        month = uint256(_month);\r\n        day = uint256(_day);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the number of days from 1970/01/01 to year/month/day using the date conversion algorithm from http://aa.usno.navy.mil/faq/docs/JD_Formula.php and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n     * @dev Taken from https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary/blob/master/contracts/BokkyPooBahsDateTimeLibrary.sol\r\n     * @param year The year\r\n     * @param month The month\r\n     * @param day The day\r\n     * @return _days Returns the number of days\r\n     */\r\n    function _daysFromDate (uint256 year, uint256 month, uint256 day) internal pure returns (uint256 _days) {\r\n        require(year >= 1970, \"Error\");\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint256(__days);\r\n    }\r\n}\r\n\r\ninterface IDeployable {\r\n    function deployCapital (uint256 deploymentAmount, bytes32 foreignNetwork) external;\r\n    function claim (uint256 dailyInterestAmount) external;\r\n}\r\n\r\n\r\n/**\r\n * @title Represents a vault.\r\n */\r\ncontract Vault is Controllable {\r\n    // The decimal multiplier of the receipt token\r\n    uint256 private constant USDF_DECIMAL_MULTIPLIER = uint256(10) ** uint256(6);\r\n\r\n    // Represents a record\r\n    struct Record {\r\n        uint8 apr;\r\n        uint256 tokenPrice;\r\n        uint256 totalDeposited;\r\n        uint256 dailyInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice The timestamp that defines the start of the current year\r\n     * @dev This is the unix epoch of January 1st of the current block's timestamp.\r\n     */\r\n    uint256 public startOfYearTimestamp;\r\n\r\n    /**\r\n     * @notice The current period. It is the zero-based day of the year, ranging from [0..364]\r\n     * @dev Day zero represents January 1st (first day of the year) whereas day 364 represents December 31st (last day of the day)\r\n     */\r\n    uint256 public currentPeriod;\r\n\r\n    /**\r\n     * @notice The minimum amount you can deposit in the vault.\r\n     */\r\n    uint256 public minDepositAmount;\r\n\r\n    /**\r\n     * @notice The flat fee to apply to vault withdrawals.\r\n     */\r\n    uint256 public flatFeePercent;\r\n\r\n    // The decimals multiplier of the underlying ERC20\r\n    uint256 immutable private _decimalsMultiplier;\r\n\r\n    // The decimals multiplier of the receipt token\r\n    uint256 immutable private _decimalsMultiplierOfReceiptToken;\r\n\r\n    /**\r\n     * @notice The percentage of capital that needs to be invested. It ranges from [1..99]\r\n     * @dev The investment percent is set to 90% by default\r\n     */\r\n    uint8 public investmentPercent = 90;\r\n\r\n    // The reentrancy guard for deposits\r\n    uint8 private _reentrancyMutexForDeposits;\r\n\r\n    // The reentrancy guard for withdrawals\r\n    uint8 private _reentrancyMutexForWithdrawals;\r\n\r\n    /**\r\n     * @notice The address of the yield reserve\r\n     */\r\n    address public yieldReserveAddress;\r\n\r\n    /**\r\n     * @notice The address that collects the applicable fees\r\n     */\r\n    address public feesAddress;\r\n\r\n    /**\r\n     * @notice The interface of the underlying token\r\n     */\r\n    IERC20 public immutable tokenInterface;\r\n\r\n    // The receipt token. This is immutable so it cannot be altered after deployment.\r\n    ReceiptToken private immutable _receiptToken;\r\n\r\n    // The snapshots history\r\n    mapping (uint256 => Record) private _records;\r\n\r\n    // ---------------------------------------\r\n    // Events\r\n    // ---------------------------------------\r\n    /**\r\n     * @notice This event is fired when the vault receives a deposit.\r\n     * @param tokenAddress Specifies the token address\r\n     * @param fromAddress Specifies the address of the sender\r\n     * @param depositAmount Specifies the deposit amount in USDC or the ERC20 handled by this contract\r\n     * @param receiptTokensAmount Specifies the amount of receipt tokens issued to the user\r\n     */\r\n    event OnVaultDeposit (address tokenAddress, address fromAddress, uint256 depositAmount, uint256 receiptTokensAmount);\r\n\r\n    /**\r\n     * @notice This event is fired when a user withdraws funds from the vault.\r\n     * @param tokenAddress Specifies the token address\r\n     * @param toAddress Specifies the address of the recipient\r\n     * @param erc20Amount Specifies the amount in USDC or the ERC20 handled by this contract\r\n     * @param receiptTokensAmount Specifies the amount of receipt tokens withdrawn by the user\r\n     * @param fee Specifies the withdrawal fee\r\n     */\r\n    event OnVaultWithdrawal (address tokenAddress, address toAddress, uint256 erc20Amount, uint256 receiptTokensAmount, uint256 fee);\r\n\r\n    // ---------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------\r\n    constructor (\r\n        address ownerAddr, \r\n        address controllerAddr, \r\n        ReceiptToken receiptTokenInterface, \r\n        IERC20 eip20Interface, \r\n        uint8 initialApr, \r\n        uint256 initialTokenPrice, \r\n        uint256 initialMinDepositAmount,\r\n        uint256 flatFeePerc,\r\n        address feesAddr) \r\n    Controllable (ownerAddr, controllerAddr) {\r\n        // Checks\r\n        require(initialMinDepositAmount > 0, \"Invalid min deposit amount\");\r\n        require(feesAddr != address(0), \"Invalid address for fees\");\r\n\r\n        // State changes\r\n        tokenInterface = eip20Interface;\r\n        _receiptToken = receiptTokenInterface;\r\n        minDepositAmount = initialMinDepositAmount;\r\n        _decimalsMultiplier = uint256(10) ** uint256(eip20Interface.decimals());\r\n        _decimalsMultiplierOfReceiptToken = uint256(10) ** uint256(receiptTokenInterface.decimals());\r\n\r\n        uint256 currentTimestamp = block.timestamp; // solhint-disable-line not-rely-on-time\r\n\r\n        // Get the current year\r\n        uint256 currentYear = DateUtils.getYear(currentTimestamp);\r\n\r\n        // Set the timestamp of January 1st of the current year (the year starts at this unix epoch)\r\n        startOfYearTimestamp = DateUtils.timestampFromDateTime(currentYear, 1, 1, 0, 0, 0);\r\n\r\n        // Create the first record\r\n        currentPeriod = DateUtils.diffDays(startOfYearTimestamp, currentTimestamp);\r\n        \r\n        _records[currentPeriod] = Record(initialApr, initialTokenPrice, 0, 0);\r\n\r\n        flatFeePercent = flatFeePerc;\r\n        feesAddress = feesAddr;\r\n    }\r\n\r\n    // ---------------------------------------\r\n    // Modifiers\r\n    // ---------------------------------------\r\n    /**\r\n     * @notice Throws if there is a deposit in progress\r\n     */\r\n    modifier ifNotReentrantDeposit() {\r\n        require(_reentrancyMutexForDeposits == 0, \"Reentrant deposit rejected\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Throws if there is a withdrawal in progress\r\n     */\r\n    modifier ifNotReentrantWithdrawal() {\r\n        require(_reentrancyMutexForWithdrawals == 0, \"Reentrant withdrawal rejected\");\r\n        _;\r\n    }\r\n\r\n    // ---------------------------------------\r\n    // Functions\r\n    // ---------------------------------------\r\n    /**\r\n     * @notice Sets the address of the bridge\r\n     * @dev This function can be called by the owner or the controller.\r\n     * @param addr The address of the bridge\r\n     */\r\n    function setYieldReserveAddress (address addr) public onlyOwnerOrController {\r\n        require(addr != address(0) && addr != address(this), \"Invalid address\");\r\n        require(Utils.isContract(addr), \"The address must be a contract\");\r\n\r\n        yieldReserveAddress = addr;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the minimum amount for deposits.\r\n     * @dev This function can be called by the owner or the controller.\r\n     * @param minAmount The minimum deposit amount\r\n     */\r\n    function setMinDepositAmount (uint256 minAmount) public onlyOwnerOrController {\r\n        // Checks\r\n        require(minAmount > 0, \"Invalid minimum deposit amount\");\r\n\r\n        // State changes\r\n        minDepositAmount = minAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets a new flat fee for withdrawals.\r\n     * @dev The new fee is allowed to be zero (aka: no fees).\r\n     * @param newFeeWithMultiplier The new fee, which is expressed per decimals precision of the underlying token (say USDC for example)\r\n     */\r\n    function setFlatWithdrawalFee (uint256 newFeeWithMultiplier) public onlyOwnerOrController {\r\n        // Example for USDC (6 decimal places):\r\n        // Say the fee is: 0.03%\r\n        // Thus the fee amount is: 0.03 * _decimalsMultiplier = 30000 = 0.03 * (10 to the power of 6)\r\n        flatFeePercent = newFeeWithMultiplier;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address for collecting fees.\r\n     * @param addr The address\r\n     */\r\n    function setFeeAddress (address addr) public onlyOwnerOrController {\r\n        require(addr != address(0) && addr != feesAddress, \"Invalid address for fees\");\r\n        feesAddress = addr;\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits funds in the vault. The caller gets the respective amount of receipt tokens in exchange for their deposit.\r\n     * @dev The number of receipt tokens is calculated based on the current token price.\r\n     * @param depositAmount Specifies the deposit amount\r\n     */\r\n    function deposit (uint256 depositAmount) public ifNotReentrantDeposit {\r\n        // Make sure the deposit amount falls within the expected range\r\n        require(depositAmount >= minDepositAmount, \"Minimum deposit amount not met\");\r\n\r\n        // Wake up the reentrancy guard\r\n        _reentrancyMutexForDeposits = 1;\r\n\r\n        // Refresh the current timelime, if needed\r\n        compute();\r\n\r\n        // The transaction sender. Presumably it is also the legitimate depositor. Otherwise it is a relayer.\r\n        address senderAddr = msg.sender;\r\n\r\n        // Make sure the sender can cover the deposit (aka: has enough USDC/ERC20 on their wallet)\r\n        require(tokenInterface.balanceOf(senderAddr) >= depositAmount, \"Insufficient funds\");\r\n\r\n        // Make sure the user approved this contract to spend the amount specified\r\n        require(tokenInterface.allowance(senderAddr, address(this)) >= depositAmount, \"Insufficient allowance\");\r\n\r\n        // Determine how many tokens can be issued/minted to the destination address\r\n        uint256 numberOfReceiptTokens = depositAmount * _decimalsMultiplierOfReceiptToken / _records[currentPeriod].tokenPrice;\r\n\r\n        // Make sure we can issue the number of tokens specified, per limits\r\n        require(_receiptToken.canMint(numberOfReceiptTokens), \"Token supply limit exceeded\");\r\n\r\n        _records[currentPeriod].totalDeposited += depositAmount;\r\n\r\n        // Get the current balance of this contract in USDC (or whatever the ERC20 is, which defined at deployment time)\r\n        uint256 balanceBeforeTransfer = tokenInterface.balanceOf(address(this));\r\n\r\n        // Make sure the ERC20 transfer succeeded\r\n        require(tokenInterface.transferFrom(senderAddr, address(this), depositAmount), \"Token transfer failed\");\r\n\r\n        // The new balance of this contract, after the transfer\r\n        uint256 newBalance = tokenInterface.balanceOf(address(this));\r\n\r\n        // At the very least, the new balance should be the previous balance + the deposit.\r\n        require(newBalance >= balanceBeforeTransfer + depositAmount, \"Balance verification failed\");\r\n\r\n        // Issue/mint the respective number of tokens. Users get a receipt token in exchange for their deposit in USDC/ERC20.\r\n        _receiptToken.mint(senderAddr, numberOfReceiptTokens);\r\n\r\n        // Emit a new \"deposit\" event\r\n        emit OnVaultDeposit(address(tokenInterface), senderAddr, depositAmount, numberOfReceiptTokens);\r\n\r\n        // Reset the reentrancy guard\r\n        _reentrancyMutexForDeposits = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraws a specific amount of tokens from the Vault.\r\n     * @param receiptTokenAmount The number of tokens to withdraw from the vault\r\n     */\r\n    function withdraw (uint256 receiptTokenAmount) public ifNotReentrantWithdrawal {\r\n        // Checks\r\n        require(receiptTokenAmount > 0, \"Invalid withdrawal amount\");\r\n\r\n        // Wake up the reentrancy guard\r\n        _reentrancyMutexForWithdrawals = 1;\r\n\r\n        address senderAddr = msg.sender;\r\n\r\n        // Refresh the current timelime, if needed\r\n        compute();\r\n\r\n        // Make sure the sender has enough receipt tokens to burn\r\n        require(_receiptToken.balanceOf(senderAddr) >= receiptTokenAmount, \"Insufficient balance of tokens\");\r\n\r\n        // The amount of USDC you get in exchange, at the current token price\r\n        uint256 withdrawalAmount = toErc20Amount(receiptTokenAmount);\r\n        require(withdrawalAmount <= _records[currentPeriod].totalDeposited, \"Invalid withdrawal amount\");\r\n\r\n        uint256 maxWithdrawalAmount = getMaxWithdrawalAmount();\r\n        require(withdrawalAmount <= maxWithdrawalAmount, \"Max withdrawal amount exceeded\");\r\n\r\n        uint256 currentBalance = tokenInterface.balanceOf(address(this));\r\n        require(currentBalance > withdrawalAmount, \"Insufficient funds in the buffer\");\r\n\r\n        // Notice that the fee is applied in the underlying currency instead of receipt tokens.\r\n        // The amount applicable to the fee\r\n        uint256 feeAmount = (flatFeePercent > 0) ? withdrawalAmount * flatFeePercent / uint256(100) / _decimalsMultiplier : 0;\r\n        require(feeAmount < withdrawalAmount, \"Invalid fee\");\r\n\r\n        // The amount to send to the destination address (recipient), after applying the fee\r\n        uint256 withdrawalAmountAfterFees = withdrawalAmount - feeAmount;\r\n\r\n        // Update the record per amount withdrawn, with no applicable fees.\r\n        // A common mistake would be update the metric below with fees included. DONT DO THAT.\r\n        _records[currentPeriod].totalDeposited -= withdrawalAmount;\r\n\r\n        // Burn the number of receipt tokens specified\r\n        _receiptToken.burn(senderAddr, receiptTokenAmount);\r\n\r\n        // Transfer the respective amount of underlying tokens to the sender (after applying the fee)\r\n        require(tokenInterface.transfer(senderAddr, withdrawalAmountAfterFees), \"Token transfer failed\");\r\n\r\n        if (feeAmount > 0) {\r\n            // Transfer the applicable fee, if any\r\n            require(tokenInterface.transfer(feesAddress, feeAmount), \"Fee transfer failed\");\r\n        }\r\n\r\n        // Emit a new \"withdrawal\" event\r\n        emit OnVaultWithdrawal(address(tokenInterface), senderAddr, withdrawalAmount, receiptTokenAmount, feeAmount);\r\n\r\n        // Reset the reentrancy guard\r\n        _reentrancyMutexForWithdrawals = 0; // solhint-disable-line reentrancy\r\n    }\r\n\r\n    /**\r\n     * @notice Runs an emergency withdrawal. Sends the whole balance to the address specified.\r\n     * @dev This function can be called by the owner only.\r\n     * @param destinationAddr The destination address\r\n     */\r\n    function emergencyWithdraw (address destinationAddr) public onlyOwner ifNotReentrantWithdrawal {\r\n        require(destinationAddr != address(0) && destinationAddr != address(this), \"Invalid address\");\r\n\r\n        // Wake up the reentrancy guard\r\n        _reentrancyMutexForWithdrawals = 1;\r\n\r\n        uint256 currentBalance = tokenInterface.balanceOf(address(this));\r\n        require(currentBalance > 0, \"The vault has no funds\");\r\n\r\n        // Transfer all funds to the address specified\r\n        require(tokenInterface.transfer(destinationAddr, currentBalance), \"Token transfer failed\");\r\n\r\n        // Reset the reentrancy guard\r\n        _reentrancyMutexForWithdrawals = 0; // solhint-disable-line reentrancy\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the APR\r\n     * @param newApr The new APR\r\n     */\r\n    function changeApr (uint8 newApr) public onlyOwner {\r\n        require(newApr > 0, \"Invalid APR\");\r\n\r\n        compute();\r\n        _records[currentPeriod].apr = newApr;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the token price, arbitrarily.\r\n     * @param newTokenPrice The new price of the receipt token\r\n     */\r\n    function setTokenPrice (uint256 newTokenPrice) public onlyOwner {\r\n        require(newTokenPrice > 0, \"Invalid token price\");\r\n\r\n        compute();\r\n        _records[currentPeriod].tokenPrice = newTokenPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the investment percent.\r\n     * @param newPercent The new investment percent\r\n     */\r\n    function setInvestmentPercent (uint8 newPercent) public onlyOwnerOrController {\r\n        require(newPercent > 0 && newPercent < 100, \"Invalid investment percent\");\r\n        investmentPercent = newPercent;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the metrics (token price, daily interest) for the current day of year\r\n     */\r\n    function compute () public {\r\n        uint256 currentTimestamp = block.timestamp; // solhint-disable-line not-rely-on-time\r\n\r\n        uint256 newPeriod = DateUtils.diffDays(startOfYearTimestamp, currentTimestamp);\r\n        if (newPeriod <= currentPeriod) return;\r\n\r\n        uint256 x = 0;\r\n\r\n        for (uint256 i = currentPeriod + 1; i <= newPeriod; i++) {\r\n            x++;\r\n            _records[i].apr = _records[i - 1].apr;\r\n            _records[i].totalDeposited = _records[i - 1].totalDeposited;\r\n\r\n            uint256 diff = uint256(_records[i - 1].apr) * USDF_DECIMAL_MULTIPLIER * uint256(100) / uint256(365);\r\n            _records[i].tokenPrice = _records[i - 1].tokenPrice + (diff / uint256(10000));\r\n            _records[i].dailyInterest = _records[i - 1].totalDeposited * uint256(_records[i - 1].apr) / uint256(365) / uint256(100);\r\n            if (x >= 30) break;\r\n        }\r\n\r\n        currentPeriod += x;\r\n    }\r\n\r\n    /**\r\n     * @notice Moves the deployable capital from the vault to the yield reserve\r\n     */\r\n    function lockCapital () public onlyOwnerOrController {\r\n        compute();\r\n\r\n        // Get the maximum amount of capital that can be deployed at this point in time\r\n        uint256 maxDeployableAmount = getDeployableCapital();\r\n        require(maxDeployableAmount > 0, \"Invalid deployable capital\");\r\n\r\n        require(tokenInterface.transfer(yieldReserveAddress, maxDeployableAmount), \"Transfer failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Claims the daily interest promised per APR.\r\n     */\r\n    function claimDailyInterest () public onlyOwnerOrController {\r\n        compute();\r\n\r\n        // Get the daily interest that need to be claimed at this point in time\r\n        uint256 dailyInterestAmount = getDailyInterest();\r\n\r\n        uint256 balanceBefore = tokenInterface.balanceOf(address(this));\r\n\r\n        IDeployable(yieldReserveAddress).claim(dailyInterestAmount);\r\n\r\n        uint256 balanceAfter = tokenInterface.balanceOf(address(this));\r\n\r\n        require(balanceAfter >= balanceBefore + dailyInterestAmount, \"Balance verification failed\");\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the period of the current unix epoch.\r\n     * @dev The period is the zero-based day of the current year. It is the number of days that elapsed since January 1st of the current year.\r\n     * @return Returns a number between [0..364]\r\n     */\r\n    function getPeriodOfCurrentEpoch () public view returns (uint256) {\r\n        return DateUtils.diffDays(startOfYearTimestamp, block.timestamp); // solhint-disable-line not-rely-on-time\r\n    }\r\n\r\n    function getSnapshot (uint256 i) public view returns (uint8 apr, uint256 tokenPrice, uint256 totalDeposited, uint256 dailyInterest) {\r\n        apr = _records[i].apr;\r\n        tokenPrice = _records[i].tokenPrice;\r\n        totalDeposited = _records[i].totalDeposited;\r\n        dailyInterest = _records[i].dailyInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the total amount deposited in the vault\r\n     * @return The total amount deposited\r\n     */\r\n    function getTotalDeposited () public view returns (uint256) {\r\n        return _records[currentPeriod].totalDeposited;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the daily interest\r\n     * @return The daily interest\r\n     */\r\n    function getDailyInterest () public view returns (uint256) {\r\n        return _records[currentPeriod].dailyInterest;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the current token price\r\n     * @return The price of the token\r\n     */\r\n    function getTokenPrice () public view returns (uint256) {\r\n        return _records[currentPeriod].tokenPrice;\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the maximum amount of USDC/ERC20 you can withdraw from the vault\r\n     * @return The maximum withdrawal amount\r\n     */\r\n    function getMaxWithdrawalAmount () public view returns (uint256) {\r\n        // X% of the current balance instead of X% of the total deposited\r\n        //return _records[currentPeriod].totalDeposited * (uint256(100) - uint256(investmentPercent)) / uint256(100);\r\n        return tokenInterface.balanceOf(address(this)) * (uint256(100) - uint256(investmentPercent)) / uint256(100);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets the amount of capital that can be deployed.\r\n     * @return The amount of deployable capital\r\n     */\r\n    function getDeployableCapital () public view returns (uint256) {\r\n        return tokenInterface.balanceOf(address(this)) * uint256(investmentPercent) / uint256(100);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of USDC you would get by burning the number of receipt tokens specified, at the current price.\r\n     * @return The amount of USDC you get in exchange, at the current token price\r\n     */\r\n    function toErc20Amount (uint256 receiptTokenAmount) public view returns (uint256) {\r\n        return receiptTokenAmount * _records[currentPeriod].tokenPrice / _decimalsMultiplierOfReceiptToken;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controllerAddr\",\"type\":\"address\"},{\"internalType\":\"contract ReceiptToken\",\"name\":\"receiptTokenInterface\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"eip20Interface\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"initialApr\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"initialTokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialMinDepositAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flatFeePerc\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feesAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiptTokensAmount\",\"type\":\"uint256\"}],\"name\":\"OnVaultDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"erc20Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receiptTokensAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"OnVaultWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newApr\",\"type\":\"uint8\"}],\"name\":\"changeApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDailyInterest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"depositAmount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"destroy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"destinationAddr\",\"type\":\"address\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flatFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getControllerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDailyInterest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDeployableCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMaxWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPeriodOfCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getSnapshot\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"apr\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dailyInterest\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investmentPercent\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minDepositAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controllerAddr\",\"type\":\"address\"}],\"name\":\"setController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFeeWithMultiplier\",\"type\":\"uint256\"}],\"name\":\"setFlatWithdrawalFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newPercent\",\"type\":\"uint8\"}],\"name\":\"setInvestmentPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"setMinDepositAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTokenPrice\",\"type\":\"uint256\"}],\"name\":\"setTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setYieldReserveAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startOfYearTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receiptTokenAmount\",\"type\":\"uint256\"}],\"name\":\"toErc20Amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInterface\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"receiptTokenAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldReserveAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Vault", "CompilerVersion": "v0.8.3+commit.8d00100c", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c692d583567cda0fde14cd3d6136c2623202ed68000000000000000000000000ca8d52bd76a0b09a2df5ccf49ab4fcab7611bbcc00000000000000000000000051acb1ea45c1ec2512ae4202b9076c13016dc8aa000000000000000000000000a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000000000000000000000000000000000000000000000000000000000000000f00000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000c692d583567cda0fde14cd3d6136c2623202ed68", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0501fa8d7ecc2953141eb4fdf28e194ee0a4d5bcd5478d3c0630568e6e6b121f"}]}