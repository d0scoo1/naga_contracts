{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DABridgeProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract DABridgeProxy {\\n    bytes32 private constant implementationPosition =\\n        keccak256(\\\"implementation.contract.diamond-alpha-bridge:2022\\\");\\n    bytes32 private constant proxyOwnerPosition =\\n        keccak256(\\\"owner.contract.diamond-alpha-bridge:2022\\\");\\n\\n    event Upgraded(address indexed implementation);\\n    event ProxyOwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    constructor() {\\n        _setUpgradeabilityOwner(msg.sender);\\n    }\\n\\n    modifier onlyProxyOwner() {\\n        require(msg.sender == proxyOwner());\\n        _;\\n    }\\n\\n    /**\\n     * @dev To get the address of the proxy contract's owner\\n     */\\n    function proxyOwner() public view returns (address owner) {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            owner := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev To get the address of the proxy contract\\n     */\\n    function implementation() public view returns (address impl) {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            impl := sload(position)\\n        }\\n    }\\n\\n    /**\\n     * @dev  To get the address of the proxy contract\\n     */\\n    function transferProxyOwnership(address _newOwner) public onlyProxyOwner {\\n        require(\\n            _newOwner != address(0),\\n            \\\"Implementation: Transfer proxy ownership to zero address\\\"\\n        );\\n        require(\\n            _newOwner != proxyOwner(),\\n            \\\"Implementation: Transfer proxy ownership to current owner\\\"\\n        );\\n        emit ProxyOwnershipTransferred(proxyOwner(), _newOwner);\\n        _setUpgradeabilityOwner(_newOwner);\\n    }\\n\\n    /**\\n     * @dev To upgrade the logic contract to new one\\n     */\\n    function upgradeTo(address _newImplementation) public onlyProxyOwner {\\n        address currentImplementation = implementation();\\n        require(currentImplementation != _newImplementation);\\n        _setImplementation(_newImplementation);\\n        emit Upgraded(_newImplementation);\\n    }\\n\\n    /**\\n     * @dev Update the value of implementationPosition slot in storage\\n     */\\n    function _setImplementation(address _newImplementation) internal {\\n        bytes32 position = implementationPosition;\\n        assembly {\\n            sstore(position, _newImplementation)\\n        }\\n    }\\n\\n    /**\\n     * @dev Update the value of proxyOwnerPosition slot in storage\\n     */\\n    function _setUpgradeabilityOwner(address _newProxyOwner) internal {\\n        bytes32 position = proxyOwnerPosition;\\n        assembly {\\n            sstore(position, _newProxyOwner)\\n        }\\n    }\\n\\n    function _delegatecall() internal {\\n        address _impl = implementation();\\n        require(_impl != address(0), \\\"Impl address is 0\\\");\\n\\n        assembly {\\n            let ptr := mload(0x40)\\n            calldatacopy(ptr, 0, calldatasize())\\n            let result := delegatecall(\\n                sub(gas(), 10000),\\n                _impl,\\n                ptr,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n            let size := returndatasize()\\n            returndatacopy(ptr, 0, size)\\n\\n            switch result\\n            case 0 {\\n                revert(ptr, size)\\n            }\\n            default {\\n                return(ptr, size)\\n            }\\n        }\\n    }\\n\\n    fallback() external payable {\\n        _delegatecall();\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ProxyOwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"impl\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferProxyOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DABridgeProxy", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0xc7395f3328ff1d1f6b5b19ed5e58911fa828e7f8", "SwarmSource": ""}]}