{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/DNAChipDescriptor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/* solhint-disable quotes */\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\nimport \\\"./AnonymiceLibrary.sol\\\";\\nimport \\\"./RedactedLibrary.sol\\\";\\n\\ncontract DNAChipDescriptor is Ownable {\\n    address public dnaChipAddress;\\n    address public evolutionTraitsAddress;\\n\\n    constructor() {}\\n\\n    function setAddresses(address _dnaChipAddress, address _evolutionTraitsAddress) external onlyOwner {\\n        dnaChipAddress = _dnaChipAddress;\\n        evolutionTraitsAddress = _evolutionTraitsAddress;\\n    }\\n\\n    function tokenURI(uint256 _tokenId) public view returns (string memory) {\\n        uint8[8] memory traits = RedactedLibrary.representationToTraitsArray(\\n            IDNAChip(dnaChipAddress).tokenIdToTraits(_tokenId)\\n        );\\n        bool isEvolutionPod = IDNAChip(dnaChipAddress).isEvolutionPod(_tokenId);\\n        string memory name;\\n        string memory image;\\n        if (!isEvolutionPod) {\\n            name = string(abi.encodePacked('{\\\"name\\\": \\\"DNA Chip #', AnonymiceLibrary.toString(_tokenId)));\\n            image = AnonymiceLibrary.encode(bytes(getChipSVG(traits)));\\n        } else {\\n            name = string(abi.encodePacked('{\\\"name\\\": \\\"Evolution Pod #', AnonymiceLibrary.toString(_tokenId)));\\n            image = AnonymiceLibrary.encode(bytes(getEvolutionPodSVG(traits)));\\n        }\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    AnonymiceLibrary.encode(\\n                        bytes(\\n                            string(\\n                                abi.encodePacked(\\n                                    name,\\n                                    '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                                    image,\\n                                    '\\\",\\\"attributes\\\":',\\n                                    IEvolutionTraits(evolutionTraitsAddress).getMetadata(traits),\\n                                    ', \\\"description\\\": \\\"DNA Chips is a collection of 3,550 DNA Chips. All the metadata and images are generated and stored 100% on-chain. No IPFS, no API. Just the Ethereum blockchain.\\\"',\\n                                    \\\"}\\\"\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function tokenBreedingURI(uint256 _tokenId, uint256 _breedingId) public view returns (string memory) {\\n        uint256 traitsRepresentation = IDNAChip(dnaChipAddress).tokenIdToTraits(_tokenId);\\n        uint8[8] memory traits = RedactedLibrary.representationToTraitsArray(traitsRepresentation);\\n        string memory name = string(abi.encodePacked('{\\\"name\\\": \\\"Baby Mouse #', AnonymiceLibrary.toString(_breedingId)));\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    AnonymiceLibrary.encode(\\n                        bytes(\\n                            string(\\n                                abi.encodePacked(\\n                                    name,\\n                                    '\\\", \\\"image\\\": \\\"data:image/svg+xml;base64,',\\n                                    AnonymiceLibrary.encode(bytes(getBreedingSVG(traits))),\\n                                    '\\\",\\\"attributes\\\":',\\n                                    IEvolutionTraits(evolutionTraitsAddress).getMetadata(traits),\\n                                    ', \\\"description\\\": \\\"Anonymice Breeding is a collection of 3,550 baby mice. All the metadata and images are generated and stored 100% on-chain. No IPFS, no API. Just the Ethereum blockchain.\\\"',\\n                                    \\\"}\\\"\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function getChipSVG(uint8[8] memory traits) internal view returns (string memory) {\\n        string memory imageTag = IEvolutionTraits(evolutionTraitsAddress).getDNAChipSVG(traits[0]);\\n        return\\n            string(\\n                abi.encodePacked(\\n                    '<svg id=\\\"dna-chip\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 120 120\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">',\\n                    imageTag,\\n                    '<g transform=\\\"translate(43, 33) scale(1.5)\\\">',\\n                    IEvolutionTraits(evolutionTraitsAddress).getTraitsImageTags(traits),\\n                    \\\"</g>\\\",\\n                    \\\"</svg>\\\"\\n                )\\n            );\\n    }\\n\\n    function getEvolutionPodSVG(uint8[8] memory traits) public view returns (string memory) {\\n        uint8 base = traits[0];\\n        string memory preview;\\n        if (base == 0) {\\n            // FREAK\\n            preview = '<g transform=\\\"translate(75,69)\\\">';\\n        } else if (base == 1) {\\n            // ROBOT\\n            preview = '<g transform=\\\"translate(85,74)\\\">';\\n        } else if (base == 2) {\\n            // DRUID\\n            preview = '<g transform=\\\"translate(70,80)\\\">';\\n        } else if (base == 3) {\\n            // SKELE\\n            preview = '<g transform=\\\"translate(19,56)\\\">';\\n        } else if (base == 4) {\\n            // ALIEN\\n            preview = '<g transform=\\\"translate(75,58)\\\">';\\n        }\\n        preview = string(\\n            abi.encodePacked(preview, IEvolutionTraits(evolutionTraitsAddress).getTraitsImageTags(traits), \\\"</g>\\\")\\n        );\\n\\n        string\\n            memory result = '<svg id=\\\"evolution-pod\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 125 125\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">';\\n\\n        result = string(\\n            abi.encodePacked(\\n                result,\\n                IEvolutionTraits(evolutionTraitsAddress).getEvolutionPodImageTag(base),\\n                preview,\\n                \\\"</svg>\\\"\\n            )\\n        );\\n        return result;\\n    }\\n\\n    function getBreedingSVG(uint8[8] memory traits) public view returns (string memory) {\\n        string\\n            memory result = '<svg id=\\\"ebaby\\\" width=\\\"100%\\\" height=\\\"100%\\\" version=\\\"1.1\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\">';\\n\\n        result = string(\\n            abi.encodePacked(result, IEvolutionTraits(evolutionTraitsAddress).getTraitsImageTags(traits), \\\"</svg>\\\")\\n        );\\n        return result;\\n    }\\n}\\n\\n/* solhint-enable quotes */\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.7;\\n\\ninterface RewardLike {\\n    function mintMany(address to, uint256 amount) external;\\n}\\n\\ninterface IDNAChip is RewardLike {\\n    function tokenIdToTraits(uint256 tokenId) external view returns (uint256);\\n\\n    function isEvolutionPod(uint256 tokenId) external view returns (bool);\\n\\n    function breedingIdToEvolutionPod(uint256 tokenId) external view returns (uint256);\\n}\\n\\ninterface IDescriptor {\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n\\n    function tokenBreedingURI(uint256 _tokenId, uint256 _breedingId) external view returns (string memory);\\n}\\n\\ninterface IEvolutionTraits {\\n    function getDNAChipSVG(uint256 base) external view returns (string memory);\\n\\n    function getEvolutionPodImageTag(uint256 base) external view returns (string memory);\\n\\n    function getTraitsImageTags(uint8[8] memory traits) external view returns (string memory);\\n\\n    function getMetadata(uint8[8] memory traits) external view returns (string memory);\\n}\\n\\ninterface IERC721Like {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external;\\n\\n    function transfer(address to, uint256 id) external;\\n\\n    function ownerOf(uint256 id) external returns (address owner);\\n\\n    function mint(address to, uint256 tokenid) external;\\n}\\n\"\r\n    },\r\n    \"contracts/AnonymiceLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary AnonymiceLibrary {\\n    string internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return \\\"\\\";\\n\\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {\\n\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n\\n                // read 3 bytes\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    function parseInt(string memory _a)\\n        internal\\n        pure\\n        returns (uint8 _parsedInt)\\n    {\\n        bytes memory bresult = bytes(_a);\\n        uint8 mint = 0;\\n        for (uint8 i = 0; i < bresult.length; i++) {\\n            if (\\n                (uint8(uint8(bresult[i])) >= 48) &&\\n                (uint8(uint8(bresult[i])) <= 57)\\n            ) {\\n                mint *= 10;\\n                mint += uint8(bresult[i]) - 48;\\n            }\\n        }\\n        return mint;\\n    }\\n\\n    function substring(\\n        string memory str,\\n        uint256 startIndex,\\n        uint256 endIndex\\n    ) internal pure returns (string memory) {\\n        bytes memory strBytes = bytes(str);\\n        bytes memory result = new bytes(endIndex - startIndex);\\n        for (uint256 i = startIndex; i < endIndex; i++) {\\n            result[i - startIndex] = strBytes[i];\\n        }\\n        return string(result);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RedactedLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nlibrary RedactedLibrary {\\n    struct Traits {\\n        uint256 base;\\n        uint256 earrings;\\n        uint256 eyes;\\n        uint256 hats;\\n        uint256 mouths;\\n        uint256 necks;\\n        uint256 noses;\\n        uint256 whiskers;\\n    }\\n\\n    struct TightTraits {\\n        uint8 base;\\n        uint8 earrings;\\n        uint8 eyes;\\n        uint8 hats;\\n        uint8 mouths;\\n        uint8 necks;\\n        uint8 noses;\\n        uint8 whiskers;\\n    }\\n\\n    function traitsToRepresentation(Traits memory traits) internal pure returns (uint256) {\\n        uint256 representation = uint256(traits.base);\\n        representation |= traits.earrings << 8;\\n        representation |= traits.eyes << 16;\\n        representation |= traits.hats << 24;\\n        representation |= traits.mouths << 32;\\n        representation |= traits.necks << 40;\\n        representation |= traits.noses << 48;\\n        representation |= traits.whiskers << 56;\\n\\n        return representation;\\n    }\\n\\n    function representationToTraits(uint256 representation) internal pure returns (Traits memory traits) {\\n        traits.base = uint8(representation);\\n        traits.earrings = uint8(representation >> 8);\\n        traits.eyes = uint8(representation >> 16);\\n        traits.hats = uint8(representation >> 24);\\n        traits.mouths = uint8(representation >> 32);\\n        traits.necks = uint8(representation >> 40);\\n        traits.noses = uint8(representation >> 48);\\n        traits.whiskers = uint8(representation >> 56);\\n    }\\n\\n    function representationToTraitsArray(uint256 representation) internal pure returns (uint8[8] memory traitsArray) {\\n        traitsArray[0] = uint8(representation); // base\\n        traitsArray[1] = uint8(representation >> 8); // earrings\\n        traitsArray[2] = uint8(representation >> 16); // eyes\\n        traitsArray[3] = uint8(representation >> 24); // hats\\n        traitsArray[4] = uint8(representation >> 32); // mouths\\n        traitsArray[5] = uint8(representation >> 40); // necks\\n        traitsArray[6] = uint8(representation >> 48); // noses\\n        traitsArray[7] = uint8(representation >> 56); // whiskers\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"dnaChipAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"evolutionTraitsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[8]\",\"name\":\"traits\",\"type\":\"uint8[8]\"}],\"name\":\"getBreedingSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[8]\",\"name\":\"traits\",\"type\":\"uint8[8]\"}],\"name\":\"getEvolutionPodSVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dnaChipAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_evolutionTraitsAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_breedingId\",\"type\":\"uint256\"}],\"name\":\"tokenBreedingURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DNAChipDescriptor", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}