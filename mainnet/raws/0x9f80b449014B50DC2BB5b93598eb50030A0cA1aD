{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/bridge/SequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IInbox.sol\\\";\\nimport \\\"./ISequencerInbox.sol\\\";\\nimport \\\"../rollup/IRollupLogic.sol\\\";\\nimport \\\"./Messages.sol\\\";\\n\\nimport {L1MessageType_batchPostingReport} from \\\"../libraries/MessageTypes.sol\\\";\\nimport {GasRefundEnabled, IGasRefunder} from \\\"../libraries/IGasRefunder.sol\\\";\\nimport \\\"../libraries/DelegateCallAware.sol\\\";\\nimport {MAX_DATA_SIZE} from \\\"../libraries/Constants.sol\\\";\\n\\n/**\\n * @title Accepts batches from the sequencer and adds them to the rollup inbox.\\n * @notice Contains the inbox accumulator which is the ordering of all data and transactions to be processed by the rollup.\\n * As part of submitting a batch the sequencer is also expected to include items enqueued\\n * in the delayed inbox (Bridge.sol). If items in the delayed inbox are not included by a\\n * sequencer within a time limit they can be force included into the rollup inbox by anyone.\\n */\\ncontract SequencerInbox is DelegateCallAware, GasRefundEnabled, ISequencerInbox {\\n    uint256 public totalDelayedMessagesRead;\\n\\n    IBridge public bridge;\\n\\n    /// @dev The size of the batch header\\n    uint256 public constant HEADER_LENGTH = 40;\\n    /// @dev If the first batch data byte after the header has this bit set,\\n    /// the sequencer inbox has authenticated the data. Currently not used.\\n    bytes1 public constant DATA_AUTHENTICATED_FLAG = 0x40;\\n\\n    IOwnable public rollup;\\n    mapping(address => bool) public isBatchPoster;\\n    ISequencerInbox.MaxTimeVariation public maxTimeVariation;\\n\\n    struct DasKeySetInfo {\\n        bool isValidKeyset;\\n        uint64 creationBlock;\\n    }\\n    mapping(bytes32 => DasKeySetInfo) public dasKeySetInfo;\\n\\n    modifier onlyRollupOwner() {\\n        if (msg.sender != rollup.owner()) revert NotOwner(msg.sender, address(rollup));\\n        _;\\n    }\\n\\n    function initialize(\\n        IBridge bridge_,\\n        ISequencerInbox.MaxTimeVariation calldata maxTimeVariation_\\n    ) external onlyDelegated {\\n        if (bridge != IBridge(address(0))) revert AlreadyInit();\\n        if (bridge_ == IBridge(address(0))) revert HadZeroInit();\\n        bridge = bridge_;\\n        rollup = bridge_.rollup();\\n        maxTimeVariation = maxTimeVariation_;\\n    }\\n\\n    function getTimeBounds() internal view virtual returns (TimeBounds memory) {\\n        TimeBounds memory bounds;\\n        if (block.timestamp > maxTimeVariation.delaySeconds) {\\n            bounds.minTimestamp = uint64(block.timestamp - maxTimeVariation.delaySeconds);\\n        }\\n        bounds.maxTimestamp = uint64(block.timestamp + maxTimeVariation.futureSeconds);\\n        if (block.number > maxTimeVariation.delayBlocks) {\\n            bounds.minBlockNumber = uint64(block.number - maxTimeVariation.delayBlocks);\\n        }\\n        bounds.maxBlockNumber = uint64(block.number + maxTimeVariation.futureBlocks);\\n        return bounds;\\n    }\\n\\n    /// @notice Force messages from the delayed inbox to be included in the chain\\n    /// Callable by any address, but message can only be force-included after maxTimeVariation.delayBlocks and maxTimeVariation.delaySeconds\\n    /// has elapsed. As part of normal behaviour the sequencer will include these messages\\n    /// so it's only necessary to call this if the sequencer is down, or not including\\n    /// any delayed messages.\\n    /// @param _totalDelayedMessagesRead The total number of messages to read up to\\n    /// @param kind The kind of the last message to be included\\n    /// @param l1BlockAndTime The l1 block and the l1 timestamp of the last message to be included\\n    /// @param baseFeeL1 The l1 gas price of the last message to be included\\n    /// @param sender The sender of the last message to be included\\n    /// @param messageDataHash The messageDataHash of the last message to be included\\n    function forceInclusion(\\n        uint256 _totalDelayedMessagesRead,\\n        uint8 kind,\\n        uint64[2] calldata l1BlockAndTime,\\n        uint256 baseFeeL1,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external {\\n        if (_totalDelayedMessagesRead <= totalDelayedMessagesRead) revert DelayedBackwards();\\n        bytes32 messageHash = Messages.messageHash(\\n            kind,\\n            sender,\\n            l1BlockAndTime[0],\\n            l1BlockAndTime[1],\\n            _totalDelayedMessagesRead - 1,\\n            baseFeeL1,\\n            messageDataHash\\n        );\\n        // Can only force-include after the Sequencer-only window has expired.\\n        if (l1BlockAndTime[0] + maxTimeVariation.delayBlocks >= block.number)\\n            revert ForceIncludeBlockTooSoon();\\n        if (l1BlockAndTime[1] + maxTimeVariation.delaySeconds >= block.timestamp)\\n            revert ForceIncludeTimeTooSoon();\\n\\n        // Verify that message hash represents the last message sequence of delayed message to be included\\n        bytes32 prevDelayedAcc = 0;\\n        if (_totalDelayedMessagesRead > 1) {\\n            prevDelayedAcc = bridge.delayedInboxAccs(_totalDelayedMessagesRead - 2);\\n        }\\n        if (\\n            bridge.delayedInboxAccs(_totalDelayedMessagesRead - 1) !=\\n            Messages.accumulateInboxMessage(prevDelayedAcc, messageHash)\\n        ) revert IncorrectMessagePreimage();\\n\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formEmptyDataHash(\\n            _totalDelayedMessagesRead\\n        );\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, _totalDelayedMessagesRead, 0);\\n        emit SequencerBatchDelivered(\\n            seqMessageIndex,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.NoData\\n        );\\n    }\\n\\n    function addSequencerL2BatchFromOrigin(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external refundsGas(gasRefunder) {\\n        // solhint-disable-next-line avoid-tx-origin\\n        if (msg.sender != tx.origin) revert NotOrigin();\\n        if (!isBatchPoster[msg.sender]) revert NotBatchPoster();\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, afterDelayedMessagesRead, data.length);\\n        if (seqMessageIndex != sequenceNumber)\\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\\n        emit SequencerBatchDelivered(\\n            sequenceNumber,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            totalDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.TxInput\\n        );\\n    }\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external override refundsGas(gasRefunder) {\\n        if (!isBatchPoster[msg.sender] && msg.sender != address(rollup)) revert NotBatchPoster();\\n\\n        (bytes32 dataHash, TimeBounds memory timeBounds) = formDataHash(\\n            data,\\n            afterDelayedMessagesRead\\n        );\\n        // we set the calldata length posted to 0 here since the caller isn't the origin\\n        // of the tx, so they might have not paid tx input cost for the calldata\\n        (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 afterAcc\\n        ) = addSequencerL2BatchImpl(dataHash, afterDelayedMessagesRead, 0);\\n        if (seqMessageIndex != sequenceNumber)\\n            revert BadSequencerNumber(seqMessageIndex, sequenceNumber);\\n        emit SequencerBatchDelivered(\\n            sequenceNumber,\\n            beforeAcc,\\n            afterAcc,\\n            delayedAcc,\\n            afterDelayedMessagesRead,\\n            timeBounds,\\n            BatchDataLocation.SeparateBatchEvent\\n        );\\n        emit SequencerBatchData(sequenceNumber, data);\\n    }\\n\\n    modifier validateBatchData(bytes calldata data) {\\n        uint256 fullDataLen = HEADER_LENGTH + data.length;\\n        if (fullDataLen > MAX_DATA_SIZE) revert DataTooLarge(fullDataLen, MAX_DATA_SIZE);\\n        if (data.length > 0 && (data[0] & DATA_AUTHENTICATED_FLAG) == DATA_AUTHENTICATED_FLAG) {\\n            revert DataNotAuthenticated();\\n        }\\n        // the first byte is used to identify the type of batch data\\n        // das batches expect to have the type byte set, followed by the keyset (so they should have at least 33 bytes)\\n        if (data.length >= 33 && data[0] & 0x80 != 0) {\\n            // we skip the first byte, then read the next 32 bytes for the keyset\\n            bytes32 dasKeysetHash = bytes32(data[1:33]);\\n            if (!dasKeySetInfo[dasKeysetHash].isValidKeyset) revert NoSuchKeyset(dasKeysetHash);\\n        }\\n        _;\\n    }\\n\\n    function packHeader(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes memory, TimeBounds memory)\\n    {\\n        TimeBounds memory timeBounds = getTimeBounds();\\n        bytes memory header = abi.encodePacked(\\n            timeBounds.minTimestamp,\\n            timeBounds.maxTimestamp,\\n            timeBounds.minBlockNumber,\\n            timeBounds.maxBlockNumber,\\n            uint64(afterDelayedMessagesRead)\\n        );\\n        // This must always be true from the packed encoding\\n        assert(header.length == HEADER_LENGTH);\\n        return (header, timeBounds);\\n    }\\n\\n    function formDataHash(bytes calldata data, uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        validateBatchData(data)\\n        returns (bytes32, TimeBounds memory)\\n    {\\n        (bytes memory header, TimeBounds memory timeBounds) = packHeader(afterDelayedMessagesRead);\\n        bytes32 dataHash = keccak256(bytes.concat(header, data));\\n        return (dataHash, timeBounds);\\n    }\\n\\n    function formEmptyDataHash(uint256 afterDelayedMessagesRead)\\n        internal\\n        view\\n        returns (bytes32, TimeBounds memory)\\n    {\\n        (bytes memory header, TimeBounds memory timeBounds) = packHeader(afterDelayedMessagesRead);\\n        return (keccak256(header), timeBounds);\\n    }\\n\\n    function addSequencerL2BatchImpl(\\n        bytes32 dataHash,\\n        uint256 afterDelayedMessagesRead,\\n        uint256 calldataLengthPosted\\n    )\\n        internal\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        )\\n    {\\n        if (afterDelayedMessagesRead < totalDelayedMessagesRead) revert DelayedBackwards();\\n        if (afterDelayedMessagesRead > bridge.delayedMessageCount()) revert DelayedTooFar();\\n\\n        (seqMessageIndex, beforeAcc, delayedAcc, acc) = bridge.enqueueSequencerMessage(\\n            dataHash,\\n            afterDelayedMessagesRead\\n        );\\n\\n        totalDelayedMessagesRead = afterDelayedMessagesRead;\\n\\n        if (calldataLengthPosted > 0) {\\n            // this msg isn't included in the current sequencer batch, but instead added to\\n            // the delayed messages queue that is yet to be included\\n            address batchPoster = msg.sender;\\n            bytes memory spendingReportMsg = abi.encodePacked(\\n                block.timestamp,\\n                batchPoster,\\n                dataHash,\\n                seqMessageIndex,\\n                block.basefee\\n            );\\n            uint256 msgNum = bridge.submitBatchSpendingReport(\\n                batchPoster,\\n                keccak256(spendingReportMsg)\\n            );\\n            // this is the same event used by Inbox.sol after including a message to the delayed message accumulator\\n            emit InboxMessageDelivered(msgNum, spendingReportMsg);\\n        }\\n    }\\n\\n    function inboxAccs(uint256 index) external view override returns (bytes32) {\\n        return bridge.sequencerInboxAccs(index);\\n    }\\n\\n    function batchCount() external view override returns (uint256) {\\n        return bridge.sequencerMessageCount();\\n    }\\n\\n    /**\\n     * @notice Set max delay for sequencer inbox\\n     * @param maxTimeVariation_ the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(ISequencerInbox.MaxTimeVariation memory maxTimeVariation_)\\n        external\\n        override\\n        onlyRollupOwner\\n    {\\n        maxTimeVariation = maxTimeVariation_;\\n        emit OwnerFunctionCalled(0);\\n    }\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster_ if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster_) external override onlyRollupOwner {\\n        isBatchPoster[addr] = isBatchPoster_;\\n        emit OwnerFunctionCalled(1);\\n    }\\n\\n    /**\\n     * @notice Makes Data Availability Service keyset valid\\n     * @param keysetBytes bytes of the serialized keyset\\n     */\\n    function setValidKeyset(bytes calldata keysetBytes) external override onlyRollupOwner {\\n        bytes32 ksHash = keccak256(keysetBytes);\\n        if (dasKeySetInfo[ksHash].isValidKeyset) revert AlreadyValidDASKeyset(ksHash);\\n        dasKeySetInfo[ksHash] = DasKeySetInfo({\\n            isValidKeyset: true,\\n            creationBlock: uint64(block.number)\\n        });\\n        emit SetValidKeyset(ksHash, keysetBytes);\\n        emit OwnerFunctionCalled(2);\\n    }\\n\\n    /**\\n     * @notice Invalidates a Data Availability Service keyset\\n     * @param ksHash hash of the keyset\\n     */\\n    function invalidateKeysetHash(bytes32 ksHash) external override onlyRollupOwner {\\n        if (!dasKeySetInfo[ksHash].isValidKeyset) revert NoSuchKeyset(ksHash);\\n        // we don't delete the block creation value since its used to fetch the SetValidKeyset\\n        // event efficiently. The event provides the hash preimage of the key.\\n        // this is still needed when syncing the chain after a keyset is invalidated.\\n        dasKeySetInfo[ksHash].isValidKeyset = false;\\n        emit InvalidateKeyset(ksHash);\\n        emit OwnerFunctionCalled(3);\\n    }\\n\\n    function isValidKeysetHash(bytes32 ksHash) external view returns (bool) {\\n        return dasKeySetInfo[ksHash].isValidKeyset;\\n    }\\n\\n    /// @notice the creation block is intended to still be available after a keyset is deleted\\n    function getKeysetCreationBlock(bytes32 ksHash) external view returns (uint256) {\\n        DasKeySetInfo memory ksInfo = dasKeySetInfo[ksHash];\\n        if (ksInfo.creationBlock == 0) revert NoSuchKeyset(ksHash);\\n        return uint256(ksInfo.creationBlock);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/bridge/IBridge.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {NotContract, NotRollupOrOwner} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-inbox function\\n/// @param sender The un-authorized sender\\nerror NotDelayedInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-sequencer-inbox function\\n/// @param sender The un-authorized sender\\nerror NotSequencerInbox(address sender);\\n\\n/// @dev Thrown when an un-authorized address tries to access an only-outbox function\\n/// @param sender The un-authorized sender\\nerror NotOutbox(address sender);\\n\\n/// @dev the provided outbox address isn't valid\\n/// @param outbox address of outbox being set\\nerror InvalidOutboxSet(address outbox);\\n\\ninterface IBridge {\\n    event MessageDelivered(\\n        uint256 indexed messageIndex,\\n        bytes32 indexed beforeInboxAcc,\\n        address inbox,\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash,\\n        uint256 baseFeeL1,\\n        uint64 timestamp\\n    );\\n\\n    event BridgeCallTriggered(\\n        address indexed outbox,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    event InboxToggle(address indexed inbox, bool enabled);\\n\\n    event OutboxToggle(address indexed outbox, bool enabled);\\n\\n    event SequencerInboxUpdated(address newSequencerInbox);\\n\\n    function enqueueDelayedMessage(\\n        uint8 kind,\\n        address sender,\\n        bytes32 messageDataHash\\n    ) external payable returns (uint256);\\n\\n    function enqueueSequencerMessage(bytes32 dataHash, uint256 afterDelayedMessagesRead)\\n        external\\n        returns (\\n            uint256 seqMessageIndex,\\n            bytes32 beforeAcc,\\n            bytes32 delayedAcc,\\n            bytes32 acc\\n        );\\n\\n    function submitBatchSpendingReport(address batchPoster, bytes32 dataHash)\\n        external\\n        returns (uint256 msgNum);\\n\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    // These are only callable by the admin\\n    function setDelayedInbox(address inbox, bool enabled) external;\\n\\n    function setOutbox(address inbox, bool enabled) external;\\n\\n    function setSequencerInbox(address _sequencerInbox) external;\\n\\n    // View functions\\n\\n    function sequencerInbox() external view returns (address);\\n\\n    function activeOutbox() external view returns (address);\\n\\n    function allowedDelayedInboxes(address inbox) external view returns (bool);\\n\\n    function allowedOutboxes(address outbox) external view returns (bool);\\n\\n    function delayedInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function sequencerInboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function delayedMessageCount() external view returns (uint256);\\n\\n    function sequencerMessageCount() external view returns (uint256);\\n\\n    function rollup() external view returns (IOwnable);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"./IBridge.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\nimport {AlreadyInit, NotOrigin, DataTooLarge} from \\\"../libraries/Error.sol\\\";\\n\\n/// @dev The contract is paused, so cannot be paused\\nerror AlreadyPaused();\\n\\n/// @dev The contract is unpaused, so cannot be unpaused\\nerror AlreadyUnpaused();\\n\\n/// @dev The contract is paused\\nerror Paused();\\n\\n/// @dev msg.value sent to the inbox isn't high enough\\nerror InsufficientValue(uint256 expected, uint256 actual);\\n\\n/// @dev submission cost provided isn't enough to create retryable ticket\\nerror InsufficientSubmissionCost(uint256 expected, uint256 actual);\\n\\n/// @dev address not allowed to interact with the given contract\\nerror NotAllowedOrigin(address origin);\\n\\n/// @dev used to convey retryable tx data in eth calls without requiring a tx trace\\n/// this follows a pattern similar to EIP-3668 where reverts surface call information\\nerror RetryableData(\\n    address from,\\n    address to,\\n    uint256 l2CallValue,\\n    uint256 deposit,\\n    uint256 maxSubmissionCost,\\n    address excessFeeRefundAddress,\\n    address callValueRefundAddress,\\n    uint256 gasLimit,\\n    uint256 maxFeePerGas,\\n    bytes data\\n);\\n\\ninterface IInbox is IDelayedMessageProvider {\\n    function sendL2Message(bytes calldata messageData) external returns (uint256);\\n\\n    function sendUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    function sendL1FundedUnsignedTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        uint256 nonce,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function sendL1FundedContractTransaction(\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        address to,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /// @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n    function createRetryableTicket(\\n        address to,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    /// @notice TEMPORARILY DISABLED as exact mechanics are being worked out\\n    /// @dev Gas limit and maxFeePerGas should not be set to 1 as that is used to trigger the RetryableData error\\n    function unsafeCreateRetryableTicket(\\n        address to,\\n        uint256 arbTxCallValue,\\n        uint256 maxSubmissionCost,\\n        address submissionRefundAddress,\\n        address valueRefundAddress,\\n        uint256 gasLimit,\\n        uint256 maxFeePerGas,\\n        bytes calldata data\\n    ) external payable returns (uint256);\\n\\n    function depositEth() external payable returns (uint256);\\n\\n    /// @notice deprecated in favour of depositEth with no parameters\\n    function depositEth(uint256 maxSubmissionCost) external payable returns (uint256);\\n\\n    function bridge() external view returns (IBridge);\\n}\\n\"\r\n    },\r\n    \"src/bridge/ISequencerInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../libraries/IGasRefunder.sol\\\";\\nimport {AlreadyInit, HadZeroInit, NotOrigin, DataTooLarge, NotRollup} from \\\"../libraries/Error.sol\\\";\\nimport \\\"./IDelayedMessageProvider.sol\\\";\\n\\ninterface ISequencerInbox is IDelayedMessageProvider {\\n    struct MaxTimeVariation {\\n        uint256 delayBlocks;\\n        uint256 futureBlocks;\\n        uint256 delaySeconds;\\n        uint256 futureSeconds;\\n    }\\n\\n    struct TimeBounds {\\n        uint64 minTimestamp;\\n        uint64 maxTimestamp;\\n        uint64 minBlockNumber;\\n        uint64 maxBlockNumber;\\n    }\\n\\n    enum BatchDataLocation {\\n        TxInput,\\n        SeparateBatchEvent,\\n        NoData\\n    }\\n\\n    event SequencerBatchDelivered(\\n        uint256 indexed batchSequenceNumber,\\n        bytes32 indexed beforeAcc,\\n        bytes32 indexed afterAcc,\\n        bytes32 delayedAcc,\\n        uint256 afterDelayedMessagesRead,\\n        TimeBounds timeBounds,\\n        BatchDataLocation dataLocation\\n    );\\n\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    /// @dev a separate event that emits batch data when this isn't easily accessible in the tx.input\\n    event SequencerBatchData(uint256 indexed batchSequenceNumber, bytes data);\\n\\n    /// @dev a valid keyset was added\\n    event SetValidKeyset(bytes32 indexed keysetHash, bytes keysetBytes);\\n\\n    /// @dev a keyset was invalidated\\n    event InvalidateKeyset(bytes32 indexed keysetHash);\\n\\n    /// @dev Thrown when someone attempts to read fewer messages than have already been read\\n    error DelayedBackwards();\\n\\n    /// @dev Thrown when someone attempts to read more messages than exist\\n    error DelayedTooFar();\\n\\n    /// @dev Force include can only read messages more blocks old than the delay period\\n    error ForceIncludeBlockTooSoon();\\n\\n    /// @dev Force include can only read messages more seconds old than the delay period\\n    error ForceIncludeTimeTooSoon();\\n\\n    /// @dev The message provided did not match the hash in the delayed inbox\\n    error IncorrectMessagePreimage();\\n\\n    /// @dev This can only be called by the batch poster\\n    error NotBatchPoster();\\n\\n    /// @dev The sequence number provided to this message was inconsistent with the number of batches already included\\n    error BadSequencerNumber(uint256 stored, uint256 received);\\n\\n    /// @dev The batch data has the inbox authenticated bit set, but the batch data was not authenticated by the inbox\\n    error DataNotAuthenticated();\\n\\n    /// @dev Tried to create an already valid Data Availability Service keyset\\n    error AlreadyValidDASKeyset(bytes32);\\n\\n    /// @dev Tried to use or invalidate an already invalid Data Availability Service keyset\\n    error NoSuchKeyset(bytes32);\\n\\n    function inboxAccs(uint256 index) external view returns (bytes32);\\n\\n    function batchCount() external view returns (uint256);\\n\\n    function addSequencerL2Batch(\\n        uint256 sequenceNumber,\\n        bytes calldata data,\\n        uint256 afterDelayedMessagesRead,\\n        IGasRefunder gasRefunder\\n    ) external;\\n\\n    // Methods only callable by rollup owner\\n\\n    /**\\n     * @notice Set max time variation from actual time for sequencer inbox\\n     * @param timeVariation the maximum time variation parameters\\n     */\\n    function setMaxTimeVariation(MaxTimeVariation memory timeVariation) external;\\n\\n    /**\\n     * @notice Updates whether an address is authorized to be a batch poster at the sequencer inbox\\n     * @param addr the address\\n     * @param isBatchPoster if the specified address should be authorized as a batch poster\\n     */\\n    function setIsBatchPoster(address addr, bool isBatchPoster) external;\\n\\n    function setValidKeyset(bytes calldata keysetBytes) external;\\n\\n    function invalidateKeysetHash(bytes32 ksHash) external;\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupLogic.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./RollupLib.sol\\\";\\nimport \\\"./IRollupCore.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IOwnable.sol\\\";\\n\\ninterface IRollupUserAbs is IRollupCore, IOwnable {\\n    /// @dev the user logic just validated configuration and shouldn't write to state during init\\n    /// this allows the admin logic to ensure consistency on parameters.\\n    function initialize(address stakeToken) external view;\\n\\n    function isERC20Enabled() external view returns (bool);\\n\\n    function rejectNextNode(address stakerAddress) external;\\n\\n    function confirmNextNode(bytes32 blockHash, bytes32 sendRoot) external;\\n\\n    function stakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external;\\n\\n    function stakeOnNewNode(\\n        RollupLib.Assertion memory assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function returnOldDeposit(address stakerAddress) external;\\n\\n    function reduceDeposit(uint256 target) external;\\n\\n    function removeZombie(uint256 zombieNum, uint256 maxNodes) external;\\n\\n    function removeOldZombies(uint256 startIndex) external;\\n\\n    function requiredStake(\\n        uint256 blockNumber,\\n        uint64 firstUnresolvedNodeNum,\\n        uint64 latestCreatedNode\\n    ) external view returns (uint256);\\n\\n    function currentRequiredStake() external view returns (uint256);\\n\\n    function countStakedZombies(uint64 nodeNum) external view returns (uint256);\\n\\n    function countZombiesStakedOnChildren(uint64 nodeNum) external view returns (uint256);\\n\\n    function requireUnresolvedExists() external view;\\n\\n    function requireUnresolved(uint256 nodeNum) external view;\\n\\n    function withdrawStakerFunds() external returns (uint256);\\n\\n    function createChallenge(\\n        address[2] calldata stakers,\\n        uint64[2] calldata nodeNums,\\n        MachineStatus[2] calldata machineStatuses,\\n        GlobalState[2] calldata globalStates,\\n        uint64 numBlocks,\\n        bytes32 secondExecutionHash,\\n        uint256[2] calldata proposedTimes,\\n        bytes32[2] calldata wasmModuleRoots\\n    ) external;\\n}\\n\\ninterface IRollupUser is IRollupUserAbs {\\n    function newStakeOnExistingNode(uint64 nodeNum, bytes32 nodeHash) external payable;\\n\\n    function newStakeOnNewNode(\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external payable;\\n\\n    function addToDeposit(address stakerAddress) external payable;\\n}\\n\\ninterface IRollupUserERC20 is IRollupUserAbs {\\n    function newStakeOnExistingNode(\\n        uint256 tokenAmount,\\n        uint64 nodeNum,\\n        bytes32 nodeHash\\n    ) external;\\n\\n    function newStakeOnNewNode(\\n        uint256 tokenAmount,\\n        RollupLib.Assertion calldata assertion,\\n        bytes32 expectedNodeHash,\\n        uint256 prevNodeInboxMaxCount\\n    ) external;\\n\\n    function addToDeposit(address stakerAddress, uint256 tokenAmount) external;\\n}\\n\\ninterface IRollupAdmin {\\n    event OwnerFunctionCalled(uint256 indexed id);\\n\\n    function initialize(Config calldata config, ContractDependencies calldata connectedContracts)\\n        external;\\n\\n    /**\\n     * @notice Add a contract authorized to put messages into this rollup's inbox\\n     * @param _outbox Outbox contract to add\\n     */\\n    function setOutbox(IOutbox _outbox) external;\\n\\n    /**\\n     * @notice Disable an old outbox from interacting with the bridge\\n     * @param _outbox Outbox contract to remove\\n     */\\n    function removeOldOutbox(address _outbox) external;\\n\\n    /**\\n     * @notice Enable or disable an inbox contract\\n     * @param _inbox Inbox contract to add or remove\\n     * @param _enabled New status of inbox\\n     */\\n    function setDelayedInbox(address _inbox, bool _enabled) external;\\n\\n    /**\\n     * @notice Pause interaction with the rollup contract\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @notice Resume interaction with the rollup contract\\n     */\\n    function resume() external;\\n\\n    /**\\n     * @notice Set the addresses of the validator whitelist\\n     * @dev It is expected that both arrays are same length, and validator at\\n     * position i corresponds to the value at position i\\n     * @param _validator addresses to set in the whitelist\\n     * @param _val value to set in the whitelist for corresponding address\\n     */\\n    function setValidator(address[] memory _validator, bool[] memory _val) external;\\n\\n    /**\\n     * @notice Set a new owner address for the rollup proxy\\n     * @param newOwner address of new rollup owner\\n     */\\n    function setOwner(address newOwner) external;\\n\\n    /**\\n     * @notice Set minimum assertion period for the rollup\\n     * @param newPeriod new minimum period for assertions\\n     */\\n    function setMinimumAssertionPeriod(uint256 newPeriod) external;\\n\\n    /**\\n     * @notice Set number of blocks until a node is considered confirmed\\n     * @param newConfirmPeriod new number of blocks until a node is confirmed\\n     */\\n    function setConfirmPeriodBlocks(uint64 newConfirmPeriod) external;\\n\\n    /**\\n     * @notice Set number of extra blocks after a challenge\\n     * @param newExtraTimeBlocks new number of blocks\\n     */\\n    function setExtraChallengeTimeBlocks(uint64 newExtraTimeBlocks) external;\\n\\n    /**\\n     * @notice Set base stake required for an assertion\\n     * @param newBaseStake maximum avmgas to be used per block\\n     */\\n    function setBaseStake(uint256 newBaseStake) external;\\n\\n    /**\\n     * @notice Set the token used for stake, where address(0) == eth\\n     * @dev Before changing the base stake token, you might need to change the\\n     * implementation of the Rollup User logic!\\n     * @param newStakeToken address of token used for staking\\n     */\\n    function setStakeToken(address newStakeToken) external;\\n\\n    /**\\n     * @notice Upgrades the implementation of a beacon controlled by the rollup\\n     * @param beacon address of beacon to be upgraded\\n     * @param newImplementation new address of implementation\\n     */\\n    function upgradeBeacon(address beacon, address newImplementation) external;\\n\\n    function forceResolveChallenge(address[] memory stackerA, address[] memory stackerB) external;\\n\\n    function forceRefundStaker(address[] memory stacker) external;\\n\\n    function forceCreateNode(\\n        uint64 prevNode,\\n        uint256 prevNodeInboxMaxCount,\\n        RollupLib.Assertion memory assertion,\\n        bytes32 expectedNodeHash\\n    ) external;\\n\\n    function forceConfirmNode(\\n        uint64 nodeNum,\\n        bytes32 blockHash,\\n        bytes32 sendRoot\\n    ) external;\\n\\n    function setLoserStakeEscrow(address newLoserStakerEscrow) external;\\n\\n    /**\\n     * @notice Set the proving WASM module root\\n     * @param newWasmModuleRoot new module root\\n     */\\n    function setWasmModuleRoot(bytes32 newWasmModuleRoot) external;\\n\\n    /**\\n     * @notice set a new sequencer inbox contract\\n     * @param _sequencerInbox new address of sequencer inbox\\n     */\\n    function setSequencerInbox(address _sequencerInbox) external;\\n}\\n\"\r\n    },\r\n    \"src/bridge/Messages.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Messages {\\n    function messageHash(\\n        uint8 kind,\\n        address sender,\\n        uint64 blockNumber,\\n        uint64 timestamp,\\n        uint256 inboxSeqNum,\\n        uint256 baseFeeL1,\\n        bytes32 messageDataHash\\n    ) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    kind,\\n                    sender,\\n                    blockNumber,\\n                    timestamp,\\n                    inboxSeqNum,\\n                    baseFeeL1,\\n                    messageDataHash\\n                )\\n            );\\n    }\\n\\n    function accumulateInboxMessage(bytes32 prevAcc, bytes32 message)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(abi.encodePacked(prevAcc, message));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/MessageTypes.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nuint8 constant L2_MSG = 3;\\nuint8 constant L1MessageType_L2FundedByL1 = 7;\\nuint8 constant L1MessageType_submitRetryableTx = 9;\\nuint8 constant L1MessageType_ethDeposit = 12;\\nuint8 constant L1MessageType_batchPostingReport = 13;\\nuint8 constant L2MessageType_unsignedEOATx = 0;\\nuint8 constant L2MessageType_unsignedContractTx = 1;\\n\\nuint8 constant ROLLUP_PROTOCOL_EVENT_TYPE = 8;\\nuint8 constant INITIALIZATION_MSG_TYPE = 11;\\n\"\r\n    },\r\n    \"src/libraries/IGasRefunder.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity >=0.6.11 <0.9.0;\\n\\ninterface IGasRefunder {\\n    function onGasSpent(\\n        address payable spender,\\n        uint256 gasUsed,\\n        uint256 calldataSize\\n    ) external returns (bool success);\\n}\\n\\nabstract contract GasRefundEnabled {\\n    /// @dev this refunds the sender for execution costs of the tx\\n    /// calldata costs are only refunded if `msg.sender == tx.origin` to guarantee the value refunded relates to charging\\n    /// for the `tx.input`. this avoids a possible attack where you generate large calldata from a contract and get over-refunded\\n    modifier refundsGas(IGasRefunder gasRefunder) {\\n        uint256 startGasLeft = gasleft();\\n        _;\\n        if (address(gasRefunder) != address(0)) {\\n            uint256 calldataSize = 0;\\n            // if triggered in a contract call, the spender may be overrefunded by appending dummy data to the call\\n            // so we check if it is a top level call, which would mean the sender paid calldata as part of tx.input\\n            if (msg.sender == tx.origin) {\\n                assembly {\\n                    calldataSize := calldatasize()\\n                }\\n            }\\n            gasRefunder.onGasSpent(payable(msg.sender), startGasLeft - gasleft(), calldataSize);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/DelegateCallAware.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport {NotOwner} from \\\"./Error.sol\\\";\\n\\n/// @dev A stateless contract that allows you to infer if the current call has been delegated or not\\n/// Pattern used here is from UUPS implementation by the OpenZeppelin team\\nabstract contract DelegateCallAware {\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegate call. This allows a function to be\\n     * callable on the proxy contract but not on the logic contract.\\n     */\\n    modifier onlyDelegated() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"Function must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /// @dev Check that msg.sender is the current EIP 1967 proxy admin\\n    modifier onlyProxyOwner() {\\n        // Storage slot with the admin of the proxy contract\\n        // This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1\\n        bytes32 slot = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n        address admin;\\n        assembly {\\n            admin := sload(slot)\\n        }\\n        if (msg.sender != admin) revert NotOwner(msg.sender, admin);\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Constants.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n// 90% of Geth's 128KB tx size limit, leaving ~13KB for proving\\nuint256 constant MAX_DATA_SIZE = 117964;\\n\\nuint64 constant NO_CHAL_INDEX = 0;\\n\"\r\n    },\r\n    \"src/libraries/Error.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\n/// @dev Init was already called\\nerror AlreadyInit();\\n\\n/// Init was called with param set to zero that must be nonzero\\nerror HadZeroInit();\\n\\n/// @dev Thrown when non owner tries to access an only-owner function\\n/// @param sender The msg.sender who is not the owner\\n/// @param owner The owner address\\nerror NotOwner(address sender, address owner);\\n\\n/// @dev Thrown when an address that is not the rollup tries to call an only-rollup function\\n/// @param sender The sender who is not the rollup\\n/// @param rollup The rollup address authorized to call this function\\nerror NotRollup(address sender, address rollup);\\n\\n/// @dev Thrown when the contract was not called directly from the origin ie msg.sender != tx.origin\\nerror NotOrigin();\\n\\n/// @dev Provided data was too large\\n/// @param dataLength The length of the data that is too large\\n/// @param maxDataLength The max length the data can be\\nerror DataTooLarge(uint256 dataLength, uint256 maxDataLength);\\n\\n/// @dev The provided is not a contract and was expected to be\\n/// @param addr The adddress in question\\nerror NotContract(address addr);\\n\\n/// @dev The merkle proof provided was too long\\n/// @param actualLength The length of the merkle proof provided\\n/// @param maxProofLength The max length a merkle proof can have\\nerror MerkleProofTooLong(uint256 actualLength, uint256 maxProofLength);\\n\\n/// @dev Thrown when an un-authorized address tries to access an admin function\\n/// @param sender The un-authorized sender\\n/// @param rollup The rollup, which would be authorized\\n/// @param owner The rollup's owner, which would be authorized\\nerror NotRollupOrOwner(address sender, address rollup, address owner);\\n\"\r\n    },\r\n    \"src/bridge/IOwnable.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IDelayedMessageProvider.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IDelayedMessageProvider {\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    event InboxMessageDelivered(uint256 indexed messageNum, bytes data);\\n\\n    /// @dev event emitted when a inbox message is added to the Bridge's delayed accumulator\\n    /// same as InboxMessageDelivered but the batch data is available in tx.input\\n    event InboxMessageDeliveredFromOrigin(uint256 indexed messageNum);\\n}\\n\"\r\n    },\r\n    \"src/rollup/RollupLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../challenge/IChallengeManager.sol\\\";\\nimport \\\"../challenge/ChallengeLib.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/IOutbox.sol\\\";\\nimport \\\"../bridge/IInbox.sol\\\";\\nimport \\\"./IRollupEventInbox.sol\\\";\\nimport \\\"./IRollupLogic.sol\\\";\\n\\nstruct Config {\\n    uint64 confirmPeriodBlocks;\\n    uint64 extraChallengeTimeBlocks;\\n    address stakeToken;\\n    uint256 baseStake;\\n    bytes32 wasmModuleRoot;\\n    address owner;\\n    address loserStakeEscrow;\\n    uint256 chainId;\\n    ISequencerInbox.MaxTimeVariation sequencerInboxMaxTimeVariation;\\n}\\n\\nstruct ContractDependencies {\\n    IBridge bridge;\\n    ISequencerInbox sequencerInbox;\\n    IInbox inbox;\\n    IOutbox outbox;\\n    IRollupEventInbox rollupEventInbox;\\n    IChallengeManager challengeManager;\\n    IRollupAdmin rollupAdminLogic;\\n    IRollupUser rollupUserLogic;\\n    // misc contracts that are useful when interacting with the rollup\\n    address validatorUtils;\\n    address validatorWalletCreator;\\n}\\n\\nlibrary RollupLib {\\n    using GlobalStateLib for GlobalState;\\n\\n    struct ExecutionState {\\n        GlobalState globalState;\\n        MachineStatus machineStatus;\\n    }\\n\\n    function stateHash(ExecutionState calldata execState, uint256 inboxMaxCount)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    execState.globalState.hash(),\\n                    inboxMaxCount,\\n                    execState.machineStatus\\n                )\\n            );\\n    }\\n\\n    /// @dev same as stateHash but expects execState in memory instead of calldata\\n    function stateHashMem(ExecutionState memory execState, uint256 inboxMaxCount)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    execState.globalState.hash(),\\n                    inboxMaxCount,\\n                    execState.machineStatus\\n                )\\n            );\\n    }\\n\\n    struct Assertion {\\n        ExecutionState beforeState;\\n        ExecutionState afterState;\\n        uint64 numBlocks;\\n    }\\n\\n    function executionHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        MachineStatus[2] memory statuses;\\n        statuses[0] = assertion.beforeState.machineStatus;\\n        statuses[1] = assertion.afterState.machineStatus;\\n        GlobalState[2] memory globalStates;\\n        globalStates[0] = assertion.beforeState.globalState;\\n        globalStates[1] = assertion.afterState.globalState;\\n        // TODO: benchmark how much this abstraction adds of gas overhead\\n        return executionHash(statuses, globalStates, assertion.numBlocks);\\n    }\\n\\n    function executionHash(\\n        MachineStatus[2] memory statuses,\\n        GlobalState[2] memory globalStates,\\n        uint64 numBlocks\\n    ) internal pure returns (bytes32) {\\n        bytes32[] memory segments = new bytes32[](2);\\n        segments[0] = ChallengeLib.blockStateHash(statuses[0], globalStates[0].hash());\\n        segments[1] = ChallengeLib.blockStateHash(statuses[1], globalStates[1].hash());\\n        return ChallengeLib.hashChallengeState(0, numBlocks, segments);\\n    }\\n\\n    function challengeRootHash(\\n        bytes32 execution,\\n        uint256 proposedTime,\\n        bytes32 wasmModuleRoot\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(execution, proposedTime, wasmModuleRoot));\\n    }\\n\\n    function confirmHash(Assertion memory assertion) internal pure returns (bytes32) {\\n        return\\n            confirmHash(\\n                assertion.afterState.globalState.getBlockHash(),\\n                assertion.afterState.globalState.getSendRoot()\\n            );\\n    }\\n\\n    function confirmHash(bytes32 blockHash, bytes32 sendRoot) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(blockHash, sendRoot));\\n    }\\n\\n    function nodeHash(\\n        bool hasSibling,\\n        bytes32 lastHash,\\n        bytes32 assertionExecHash,\\n        bytes32 inboxAcc,\\n        bytes32 wasmModuleRoot\\n    ) internal pure returns (bytes32) {\\n        uint8 hasSiblingInt = hasSibling ? 1 : 0;\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    hasSiblingInt,\\n                    lastHash,\\n                    assertionExecHash,\\n                    inboxAcc,\\n                    wasmModuleRoot\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupCore.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Node.sol\\\";\\nimport \\\"./RollupLib.sol\\\";\\n\\ninterface IRollupCore {\\n    struct Staker {\\n        uint256 amountStaked;\\n        uint64 index;\\n        uint64 latestStakedNode;\\n        // currentChallenge is 0 if staker is not in a challenge\\n        uint64 currentChallenge;\\n        bool isStaked;\\n    }\\n\\n    event RollupInitialized(bytes32 machineHash, uint256 chainId);\\n\\n    event NodeCreated(\\n        uint64 indexed nodeNum,\\n        bytes32 indexed parentNodeHash,\\n        bytes32 indexed nodeHash,\\n        bytes32 executionHash,\\n        RollupLib.Assertion assertion,\\n        bytes32 afterInboxBatchAcc,\\n        bytes32 wasmModuleRoot,\\n        uint256 inboxMaxCount\\n    );\\n\\n    event NodeConfirmed(uint64 indexed nodeNum, bytes32 blockHash, bytes32 sendRoot);\\n\\n    event NodeRejected(uint64 indexed nodeNum);\\n\\n    event RollupChallengeStarted(\\n        uint64 indexed challengeIndex,\\n        address asserter,\\n        address challenger,\\n        uint64 challengedNode\\n    );\\n\\n    event UserStakeUpdated(address indexed user, uint256 initialBalance, uint256 finalBalance);\\n\\n    event UserWithdrawableFundsUpdated(\\n        address indexed user,\\n        uint256 initialBalance,\\n        uint256 finalBalance\\n    );\\n\\n    function confirmPeriodBlocks() external view returns (uint64);\\n\\n    function extraChallengeTimeBlocks() external view returns (uint64);\\n\\n    function chainId() external view returns (uint256);\\n\\n    function baseStake() external view returns (uint256);\\n\\n    function wasmModuleRoot() external view returns (bytes32);\\n\\n    function bridge() external view returns (IBridge);\\n\\n    function sequencerInbox() external view returns (ISequencerInbox);\\n\\n    function outbox() external view returns (IOutbox);\\n\\n    function rollupEventInbox() external view returns (IRollupEventInbox);\\n\\n    function challengeManager() external view returns (IChallengeManager);\\n\\n    function loserStakeEscrow() external view returns (address);\\n\\n    function stakeToken() external view returns (address);\\n\\n    function minimumAssertionPeriod() external view returns (uint256);\\n\\n    function isValidator(address) external view returns (bool);\\n\\n    /**\\n     * @notice Get the Node for the given index.\\n     */\\n    function getNode(uint64 nodeNum) external view returns (Node memory);\\n\\n    /**\\n     * @notice Check if the specified node has been staked on by the provided staker.\\n     * Only accurate at the latest confirmed node and afterwards.\\n     */\\n    function nodeHasStaker(uint64 nodeNum, address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the address of the staker at the given index\\n     * @param stakerNum Index of the staker\\n     * @return Address of the staker\\n     */\\n    function getStakerAddress(uint64 stakerNum) external view returns (address);\\n\\n    /**\\n     * @notice Check whether the given staker is staked\\n     * @param staker Staker address to check\\n     * @return True or False for whether the staker was staked\\n     */\\n    function isStaked(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the latest staked node of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Latest node staked of the staker\\n     */\\n    function latestStakedNode(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the current challenge of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Current challenge of the staker\\n     */\\n    function currentChallenge(address staker) external view returns (uint64);\\n\\n    /**\\n     * @notice Get the amount staked of the given staker\\n     * @param staker Staker address to lookup\\n     * @return Amount staked of the staker\\n     */\\n    function amountStaked(address staker) external view returns (uint256);\\n\\n    /**\\n     * @notice Retrieves stored information about a requested staker\\n     * @param staker Staker address to retrieve\\n     * @return A structure with information about the requested staker\\n     */\\n    function getStaker(address staker) external view returns (Staker memory);\\n\\n    /**\\n     * @notice Get the original staker address of the zombie at the given index\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Original staker address of the zombie\\n     */\\n    function zombieAddress(uint256 zombieNum) external view returns (address);\\n\\n    /**\\n     * @notice Get Latest node that the given zombie at the given index is staked on\\n     * @param zombieNum Index of the zombie to lookup\\n     * @return Latest node that the given zombie is staked on\\n     */\\n    function zombieLatestStakedNode(uint256 zombieNum) external view returns (uint64);\\n\\n    /// @return Current number of un-removed zombies\\n    function zombieCount() external view returns (uint256);\\n\\n    function isZombie(address staker) external view returns (bool);\\n\\n    /**\\n     * @notice Get the amount of funds withdrawable by the given address\\n     * @param owner Address to check the funds of\\n     * @return Amount of funds withdrawable by owner\\n     */\\n    function withdrawableFunds(address owner) external view returns (uint256);\\n\\n    /**\\n     * @return Index of the first unresolved node\\n     * @dev If all nodes have been resolved, this will be latestNodeCreated + 1\\n     */\\n    function firstUnresolvedNode() external view returns (uint64);\\n\\n    /// @return Index of the latest confirmed node\\n    function latestConfirmed() external view returns (uint64);\\n\\n    /// @return Index of the latest rollup node created\\n    function latestNodeCreated() external view returns (uint64);\\n\\n    /// @return Ethereum block that the most recent stake was created\\n    function lastStakeBlock() external view returns (uint64);\\n\\n    /// @return Number of active stakers currently staked\\n    function stakerCount() external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"src/bridge/IOutbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.4;\\n\\nimport {AlreadyInit, NotRollup} from \\\"../libraries/Error.sol\\\";\\n\\n/// @dev The provided proof was too long\\n/// @param proofLength The length of the too-long proof\\nerror ProofTooLong(uint256 proofLength);\\n\\n/// @dev The output index was greater than the maximum\\n/// @param index The output index\\n/// @param maxIndex The max the index could be\\nerror PathNotMinimal(uint256 index, uint256 maxIndex);\\n\\n/// @dev The calculated root does not exist\\n/// @param root The calculated root\\nerror UnknownRoot(bytes32 root);\\n\\n/// @dev The record has already been spent\\n/// @param index The index of the spent record\\nerror AlreadySpent(uint256 index);\\n\\n/// @dev A call to the bridge failed with no return data\\nerror BridgeCallFailed();\\n\\ninterface IOutbox {\\n    event SendRootUpdated(bytes32 indexed blockHash, bytes32 indexed outputRoot);\\n    event OutBoxTransactionExecuted(\\n        address indexed to,\\n        address indexed l2Sender,\\n        uint256 indexed zero,\\n        uint256 transactionIndex\\n    );\\n\\n    function l2ToL1Sender() external view returns (address);\\n\\n    function l2ToL1Block() external view returns (uint256);\\n\\n    function l2ToL1EthBlock() external view returns (uint256);\\n\\n    function l2ToL1Timestamp() external view returns (uint256);\\n\\n    // @deprecated batch number is now always 0\\n    function l2ToL1BatchNum() external view returns (uint256);\\n\\n    function l2ToL1OutputId() external view returns (bytes32);\\n\\n    function updateSendRoot(bytes32 sendRoot, bytes32 l2BlockHash) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeManager.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../osp/IOneStepProofEntry.sol\\\";\\n\\nimport \\\"./IChallengeResultReceiver.sol\\\";\\n\\nimport \\\"./ChallengeLib.sol\\\";\\n\\ninterface IChallengeManager {\\n    enum ChallengeTerminationType {\\n        TIMEOUT,\\n        BLOCK_PROOF,\\n        EXECUTION_PROOF,\\n        CLEARED\\n    }\\n\\n    event InitiatedChallenge(\\n        uint64 indexed challengeIndex,\\n        GlobalState startState,\\n        GlobalState endState\\n    );\\n\\n    event Bisected(\\n        uint64 indexed challengeIndex,\\n        bytes32 indexed challengeRoot,\\n        uint256 challengedSegmentStart,\\n        uint256 challengedSegmentLength,\\n        bytes32[] chainHashes\\n    );\\n\\n    event ExecutionChallengeBegun(uint64 indexed challengeIndex, uint256 blockSteps);\\n    event OneStepProofCompleted(uint64 indexed challengeIndex);\\n\\n    event ChallengeEnded(uint64 indexed challengeIndex, ChallengeTerminationType kind);\\n\\n    function initialize(\\n        IChallengeResultReceiver resultReceiver_,\\n        ISequencerInbox sequencerInbox_,\\n        IBridge bridge_,\\n        IOneStepProofEntry osp_\\n    ) external;\\n\\n    function createChallenge(\\n        bytes32 wasmModuleRoot_,\\n        MachineStatus[2] calldata startAndEndMachineStatuses_,\\n        GlobalState[2] calldata startAndEndGlobalStates_,\\n        uint64 numBlocks,\\n        address asserter_,\\n        address challenger_,\\n        uint256 asserterTimeLeft_,\\n        uint256 challengerTimeLeft_\\n    ) external returns (uint64);\\n\\n    function challengeInfo(uint64 challengeIndex_)\\n        external\\n        view\\n        returns (ChallengeLib.Challenge memory);\\n\\n    function currentResponder(uint64 challengeIndex) external view returns (address);\\n\\n    function isTimedOut(uint64 challengeIndex) external view returns (bool);\\n\\n    function currentResponderTimeLeft(uint64 challengeIndex_) external view returns (uint256);\\n\\n    function clearChallenge(uint64 challengeIndex_) external;\\n\\n    function timeout(uint64 challengeIndex_) external;\\n}\\n\"\r\n    },\r\n    \"src/challenge/ChallengeLib.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/GlobalState.sol\\\";\\n\\nlibrary ChallengeLib {\\n    using MachineLib for Machine;\\n    using ChallengeLib for Challenge;\\n\\n    /// @dev It's assumed that that uninitialzed challenges have mode NONE\\n    enum ChallengeMode {\\n        NONE,\\n        BLOCK,\\n        EXECUTION\\n    }\\n\\n    struct Participant {\\n        address addr;\\n        uint256 timeLeft;\\n    }\\n\\n    struct Challenge {\\n        Participant current;\\n        Participant next;\\n        uint256 lastMoveTimestamp;\\n        bytes32 wasmModuleRoot;\\n        bytes32 challengeStateHash;\\n        uint64 maxInboxMessages;\\n        ChallengeMode mode;\\n    }\\n\\n    struct SegmentSelection {\\n        uint256 oldSegmentsStart;\\n        uint256 oldSegmentsLength;\\n        bytes32[] oldSegments;\\n        uint256 challengePosition;\\n    }\\n\\n    function timeUsedSinceLastMove(Challenge storage challenge) internal view returns (uint256) {\\n        return block.timestamp - challenge.lastMoveTimestamp;\\n    }\\n\\n    function isTimedOut(Challenge storage challenge) internal view returns (bool) {\\n        return challenge.timeUsedSinceLastMove() > challenge.current.timeLeft;\\n    }\\n\\n    function getStartMachineHash(bytes32 globalStateHash, bytes32 wasmModuleRoot)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        // Start the value stack with the function call ABI for the entrypoint\\n        Value[] memory startingValues = new Value[](3);\\n        startingValues[0] = ValueLib.newRefNull();\\n        startingValues[1] = ValueLib.newI32(0);\\n        startingValues[2] = ValueLib.newI32(0);\\n        ValueArray memory valuesArray = ValueArray({inner: startingValues});\\n        ValueStack memory values = ValueStack({proved: valuesArray, remainingHash: 0});\\n        ValueStack memory internalStack;\\n        StackFrameWindow memory frameStack;\\n\\n        Machine memory mach = Machine({\\n            status: MachineStatus.RUNNING,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: 0,\\n            functionIdx: 0,\\n            functionPc: 0,\\n            modulesRoot: wasmModuleRoot\\n        });\\n        return mach.hash();\\n    }\\n\\n    function getEndMachineHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n\\n    function extractChallengeSegment(SegmentSelection calldata selection)\\n        internal\\n        pure\\n        returns (uint256 segmentStart, uint256 segmentLength)\\n    {\\n        uint256 oldChallengeDegree = selection.oldSegments.length - 1;\\n        segmentLength = selection.oldSegmentsLength / oldChallengeDegree;\\n        // Intentionally done before challengeLength is potentially added to for the final segment\\n        segmentStart = selection.oldSegmentsStart + segmentLength * selection.challengePosition;\\n        if (selection.challengePosition == selection.oldSegments.length - 2) {\\n            segmentLength += selection.oldSegmentsLength % oldChallengeDegree;\\n        }\\n    }\\n\\n    function hashChallengeState(\\n        uint256 segmentsStart,\\n        uint256 segmentsLength,\\n        bytes32[] memory segments\\n    ) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(segmentsStart, segmentsLength, segments));\\n    }\\n\\n    function blockStateHash(MachineStatus status, bytes32 globalStateHash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Block state:\\\", globalStateHash));\\n        } else if (status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Block state, errored:\\\", globalStateHash));\\n        } else if (status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Block state, too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_BLOCK_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/GlobalState.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct GlobalState {\\n    bytes32[2] bytes32Vals;\\n    uint64[2] u64Vals;\\n}\\n\\nlibrary GlobalStateLib {\\n    uint16 internal constant BYTES32_VALS_NUM = 2;\\n    uint16 internal constant U64_VALS_NUM = 2;\\n\\n    function hash(GlobalState memory state) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Global state:\\\",\\n                    state.bytes32Vals[0],\\n                    state.bytes32Vals[1],\\n                    state.u64Vals[0],\\n                    state.u64Vals[1]\\n                )\\n            );\\n    }\\n\\n    function getBlockHash(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[0];\\n    }\\n\\n    function getSendRoot(GlobalState memory state) internal pure returns (bytes32) {\\n        return state.bytes32Vals[1];\\n    }\\n\\n    function getInboxPosition(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[0];\\n    }\\n\\n    function getPositionInMessage(GlobalState memory state) internal pure returns (uint64) {\\n        return state.u64Vals[1];\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/IRollupEventInbox.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\ninterface IRollupEventInbox {\\n    function bridge() external view returns (IBridge);\\n\\n    function initialize(IBridge _bridge) external;\\n\\n    function rollup() external view returns (address);\\n\\n    function rollupInitialized(uint256 chainId) external;\\n}\\n\"\r\n    },\r\n    \"src/state/Machine.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\n\\nenum MachineStatus {\\n    RUNNING,\\n    FINISHED,\\n    ERRORED,\\n    TOO_FAR\\n}\\n\\nstruct Machine {\\n    MachineStatus status;\\n    ValueStack valueStack;\\n    ValueStack internalStack;\\n    StackFrameWindow frameStack;\\n    bytes32 globalStateHash;\\n    uint32 moduleIdx;\\n    uint32 functionIdx;\\n    uint32 functionPc;\\n    bytes32 modulesRoot;\\n}\\n\\nlibrary MachineLib {\\n    using StackFrameLib for StackFrameWindow;\\n    using ValueStackLib for ValueStack;\\n\\n    function hash(Machine memory mach) internal pure returns (bytes32) {\\n        // Warning: the non-running hashes are replicated in Challenge\\n        if (mach.status == MachineStatus.RUNNING) {\\n            return\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"Machine running:\\\",\\n                        mach.valueStack.hash(),\\n                        mach.internalStack.hash(),\\n                        mach.frameStack.hash(),\\n                        mach.globalStateHash,\\n                        mach.moduleIdx,\\n                        mach.functionIdx,\\n                        mach.functionPc,\\n                        mach.modulesRoot\\n                    )\\n                );\\n        } else if (mach.status == MachineStatus.FINISHED) {\\n            return keccak256(abi.encodePacked(\\\"Machine finished:\\\", mach.globalStateHash));\\n        } else if (mach.status == MachineStatus.ERRORED) {\\n            return keccak256(abi.encodePacked(\\\"Machine errored:\\\"));\\n        } else if (mach.status == MachineStatus.TOO_FAR) {\\n            return keccak256(abi.encodePacked(\\\"Machine too far:\\\"));\\n        } else {\\n            revert(\\\"BAD_MACH_STATUS\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProofEntry.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IOneStepProver.sol\\\";\\n\\nlibrary OneStepProofEntryLib {\\n    uint256 internal constant MAX_STEPS = 1 << 43;\\n}\\n\\ninterface IOneStepProofEntry {\\n    function proveOneStep(\\n        ExecutionContext calldata execCtx,\\n        uint256 machineStep,\\n        bytes32 beforeHash,\\n        bytes calldata proof\\n    ) external view returns (bytes32 afterHash);\\n}\\n\"\r\n    },\r\n    \"src/challenge/IChallengeResultReceiver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChallengeResultReceiver {\\n    function completeChallenge(\\n        uint256 challengeIndex,\\n        address winner,\\n        address loser\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/state/ValueStack.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueArray.sol\\\";\\n\\nstruct ValueStack {\\n    ValueArray proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary ValueStackLib {\\n    using ValueLib for Value;\\n    using ValueArrayLib for ValueArray;\\n\\n    function hash(ValueStack memory stack) internal pure returns (bytes32 h) {\\n        h = stack.remainingHash;\\n        uint256 len = stack.proved.length();\\n        for (uint256 i = 0; i < len; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Value stack:\\\", stack.proved.get(i).hash(), h));\\n        }\\n    }\\n\\n    function peek(ValueStack memory stack) internal pure returns (Value memory) {\\n        uint256 len = stack.proved.length();\\n        return stack.proved.get(len - 1);\\n    }\\n\\n    function pop(ValueStack memory stack) internal pure returns (Value memory) {\\n        return stack.proved.pop();\\n    }\\n\\n    function push(ValueStack memory stack, Value memory val) internal pure {\\n        return stack.proved.push(val);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Instructions.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Instruction {\\n    uint16 opcode;\\n    uint256 argumentData;\\n}\\n\\nlibrary Instructions {\\n    uint16 internal constant UNREACHABLE = 0x00;\\n    uint16 internal constant NOP = 0x01;\\n    uint16 internal constant RETURN = 0x0F;\\n    uint16 internal constant CALL = 0x10;\\n    uint16 internal constant CALL_INDIRECT = 0x11;\\n    uint16 internal constant LOCAL_GET = 0x20;\\n    uint16 internal constant LOCAL_SET = 0x21;\\n    uint16 internal constant GLOBAL_GET = 0x23;\\n    uint16 internal constant GLOBAL_SET = 0x24;\\n\\n    uint16 internal constant I32_LOAD = 0x28;\\n    uint16 internal constant I64_LOAD = 0x29;\\n    uint16 internal constant F32_LOAD = 0x2A;\\n    uint16 internal constant F64_LOAD = 0x2B;\\n    uint16 internal constant I32_LOAD8_S = 0x2C;\\n    uint16 internal constant I32_LOAD8_U = 0x2D;\\n    uint16 internal constant I32_LOAD16_S = 0x2E;\\n    uint16 internal constant I32_LOAD16_U = 0x2F;\\n    uint16 internal constant I64_LOAD8_S = 0x30;\\n    uint16 internal constant I64_LOAD8_U = 0x31;\\n    uint16 internal constant I64_LOAD16_S = 0x32;\\n    uint16 internal constant I64_LOAD16_U = 0x33;\\n    uint16 internal constant I64_LOAD32_S = 0x34;\\n    uint16 internal constant I64_LOAD32_U = 0x35;\\n\\n    uint16 internal constant I32_STORE = 0x36;\\n    uint16 internal constant I64_STORE = 0x37;\\n    uint16 internal constant F32_STORE = 0x38;\\n    uint16 internal constant F64_STORE = 0x39;\\n    uint16 internal constant I32_STORE8 = 0x3A;\\n    uint16 internal constant I32_STORE16 = 0x3B;\\n    uint16 internal constant I64_STORE8 = 0x3C;\\n    uint16 internal constant I64_STORE16 = 0x3D;\\n    uint16 internal constant I64_STORE32 = 0x3E;\\n\\n    uint16 internal constant MEMORY_SIZE = 0x3F;\\n    uint16 internal constant MEMORY_GROW = 0x40;\\n\\n    uint16 internal constant DROP = 0x1A;\\n    uint16 internal constant SELECT = 0x1B;\\n    uint16 internal constant I32_CONST = 0x41;\\n    uint16 internal constant I64_CONST = 0x42;\\n    uint16 internal constant F32_CONST = 0x43;\\n    uint16 internal constant F64_CONST = 0x44;\\n    uint16 internal constant I32_EQZ = 0x45;\\n    uint16 internal constant I32_RELOP_BASE = 0x46;\\n    uint16 internal constant IRELOP_EQ = 0;\\n    uint16 internal constant IRELOP_NE = 1;\\n    uint16 internal constant IRELOP_LT_S = 2;\\n    uint16 internal constant IRELOP_LT_U = 3;\\n    uint16 internal constant IRELOP_GT_S = 4;\\n    uint16 internal constant IRELOP_GT_U = 5;\\n    uint16 internal constant IRELOP_LE_S = 6;\\n    uint16 internal constant IRELOP_LE_U = 7;\\n    uint16 internal constant IRELOP_GE_S = 8;\\n    uint16 internal constant IRELOP_GE_U = 9;\\n    uint16 internal constant IRELOP_LAST = IRELOP_GE_U;\\n\\n    uint16 internal constant I64_EQZ = 0x50;\\n    uint16 internal constant I64_RELOP_BASE = 0x51;\\n\\n    uint16 internal constant I32_UNOP_BASE = 0x67;\\n    uint16 internal constant IUNOP_CLZ = 0;\\n    uint16 internal constant IUNOP_CTZ = 1;\\n    uint16 internal constant IUNOP_POPCNT = 2;\\n    uint16 internal constant IUNOP_LAST = IUNOP_POPCNT;\\n\\n    uint16 internal constant I32_ADD = 0x6A;\\n    uint16 internal constant I32_SUB = 0x6B;\\n    uint16 internal constant I32_MUL = 0x6C;\\n    uint16 internal constant I32_DIV_S = 0x6D;\\n    uint16 internal constant I32_DIV_U = 0x6E;\\n    uint16 internal constant I32_REM_S = 0x6F;\\n    uint16 internal constant I32_REM_U = 0x70;\\n    uint16 internal constant I32_AND = 0x71;\\n    uint16 internal constant I32_OR = 0x72;\\n    uint16 internal constant I32_XOR = 0x73;\\n    uint16 internal constant I32_SHL = 0x74;\\n    uint16 internal constant I32_SHR_S = 0x75;\\n    uint16 internal constant I32_SHR_U = 0x76;\\n    uint16 internal constant I32_ROTL = 0x77;\\n    uint16 internal constant I32_ROTR = 0x78;\\n\\n    uint16 internal constant I64_UNOP_BASE = 0x79;\\n\\n    uint16 internal constant I64_ADD = 0x7C;\\n    uint16 internal constant I64_SUB = 0x7D;\\n    uint16 internal constant I64_MUL = 0x7E;\\n    uint16 internal constant I64_DIV_S = 0x7F;\\n    uint16 internal constant I64_DIV_U = 0x80;\\n    uint16 internal constant I64_REM_S = 0x81;\\n    uint16 internal constant I64_REM_U = 0x82;\\n    uint16 internal constant I64_AND = 0x83;\\n    uint16 internal constant I64_OR = 0x84;\\n    uint16 internal constant I64_XOR = 0x85;\\n    uint16 internal constant I64_SHL = 0x86;\\n    uint16 internal constant I64_SHR_S = 0x87;\\n    uint16 internal constant I64_SHR_U = 0x88;\\n    uint16 internal constant I64_ROTL = 0x89;\\n    uint16 internal constant I64_ROTR = 0x8A;\\n\\n    uint16 internal constant I32_WRAP_I64 = 0xA7;\\n    uint16 internal constant I64_EXTEND_I32_S = 0xAC;\\n    uint16 internal constant I64_EXTEND_I32_U = 0xAD;\\n\\n    uint16 internal constant I32_REINTERPRET_F32 = 0xBC;\\n    uint16 internal constant I64_REINTERPRET_F64 = 0xBD;\\n    uint16 internal constant F32_REINTERPRET_I32 = 0xBE;\\n    uint16 internal constant F64_REINTERPRET_I64 = 0xBF;\\n\\n    uint16 internal constant I32_EXTEND_8S = 0xC0;\\n    uint16 internal constant I32_EXTEND_16S = 0xC1;\\n    uint16 internal constant I64_EXTEND_8S = 0xC2;\\n    uint16 internal constant I64_EXTEND_16S = 0xC3;\\n    uint16 internal constant I64_EXTEND_32S = 0xC4;\\n\\n    uint16 internal constant INIT_FRAME = 0x8002;\\n    uint16 internal constant ARBITRARY_JUMP = 0x8003;\\n    uint16 internal constant ARBITRARY_JUMP_IF = 0x8004;\\n    uint16 internal constant MOVE_FROM_STACK_TO_INTERNAL = 0x8005;\\n    uint16 internal constant MOVE_FROM_INTERNAL_TO_STACK = 0x8006;\\n    uint16 internal constant DUP = 0x8008;\\n    uint16 internal constant CROSS_MODULE_CALL = 0x8009;\\n    uint16 internal constant CALLER_MODULE_INTERNAL_CALL = 0x800A;\\n\\n    uint16 internal constant GET_GLOBAL_STATE_BYTES32 = 0x8010;\\n    uint16 internal constant SET_GLOBAL_STATE_BYTES32 = 0x8011;\\n    uint16 internal constant GET_GLOBAL_STATE_U64 = 0x8012;\\n    uint16 internal constant SET_GLOBAL_STATE_U64 = 0x8013;\\n\\n    uint16 internal constant READ_PRE_IMAGE = 0x8020;\\n    uint16 internal constant READ_INBOX_MESSAGE = 0x8021;\\n    uint16 internal constant HALT_AND_SET_FINISHED = 0x8022;\\n\\n    uint256 internal constant INBOX_INDEX_SEQUENCER = 0;\\n    uint256 internal constant INBOX_INDEX_DELAYED = 1;\\n\\n    function hash(Instruction memory inst) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Instruction:\\\", inst.opcode, inst.argumentData));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/StackFrame.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct StackFrame {\\n    Value returnPc;\\n    bytes32 localsMerkleRoot;\\n    uint32 callerModule;\\n    uint32 callerModuleInternals;\\n}\\n\\nstruct StackFrameWindow {\\n    StackFrame[] proved;\\n    bytes32 remainingHash;\\n}\\n\\nlibrary StackFrameLib {\\n    using ValueLib for Value;\\n\\n    function hash(StackFrame memory frame) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Stack frame:\\\",\\n                    frame.returnPc.hash(),\\n                    frame.localsMerkleRoot,\\n                    frame.callerModule,\\n                    frame.callerModuleInternals\\n                )\\n            );\\n    }\\n\\n    function hash(StackFrameWindow memory window) internal pure returns (bytes32 h) {\\n        h = window.remainingHash;\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            h = keccak256(abi.encodePacked(\\\"Stack frame stack:\\\", hash(window.proved[i]), h));\\n        }\\n    }\\n\\n    function peek(StackFrameWindow memory window) internal pure returns (StackFrame memory) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        return window.proved[0];\\n    }\\n\\n    function pop(StackFrameWindow memory window) internal pure returns (StackFrame memory frame) {\\n        require(window.proved.length == 1, \\\"BAD_WINDOW_LENGTH\\\");\\n        frame = window.proved[0];\\n        window.proved = new StackFrame[](0);\\n    }\\n\\n    function push(StackFrameWindow memory window, StackFrame memory frame) internal pure {\\n        StackFrame[] memory newProved = new StackFrame[](window.proved.length + 1);\\n        for (uint256 i = 0; i < window.proved.length; i++) {\\n            newProved[i] = window.proved[i];\\n        }\\n        newProved[window.proved.length] = frame;\\n        window.proved = newProved;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Value.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nenum ValueType {\\n    I32,\\n    I64,\\n    F32,\\n    F64,\\n    REF_NULL,\\n    FUNC_REF,\\n    INTERNAL_REF\\n}\\n\\nstruct Value {\\n    ValueType valueType;\\n    uint256 contents;\\n}\\n\\nlibrary ValueLib {\\n    function hash(Value memory val) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Value:\\\", val.valueType, val.contents));\\n    }\\n\\n    function maxValueType() internal pure returns (ValueType) {\\n        return ValueType.INTERNAL_REF;\\n    }\\n\\n    function assumeI32(Value memory val) internal pure returns (uint32) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I32, \\\"NOT_I32\\\");\\n        require(uintval < (1 << 32), \\\"BAD_I32\\\");\\n        return uint32(uintval);\\n    }\\n\\n    function assumeI64(Value memory val) internal pure returns (uint64) {\\n        uint256 uintval = uint256(val.contents);\\n        require(val.valueType == ValueType.I64, \\\"NOT_I64\\\");\\n        require(uintval < (1 << 64), \\\"BAD_I64\\\");\\n        return uint64(uintval);\\n    }\\n\\n    function newRefNull() internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.REF_NULL, contents: 0});\\n    }\\n\\n    function newI32(uint32 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I32, contents: uint256(x)});\\n    }\\n\\n    function newI64(uint64 x) internal pure returns (Value memory) {\\n        return Value({valueType: ValueType.I64, contents: uint256(x)});\\n    }\\n\\n    function newBoolean(bool x) internal pure returns (Value memory) {\\n        if (x) {\\n            return newI32(uint32(1));\\n        } else {\\n            return newI32(uint32(0));\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ValueArray.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\n\\nstruct ValueArray {\\n    Value[] inner;\\n}\\n\\nlibrary ValueArrayLib {\\n    function get(ValueArray memory arr, uint256 index) internal pure returns (Value memory) {\\n        return arr.inner[index];\\n    }\\n\\n    function set(\\n        ValueArray memory arr,\\n        uint256 index,\\n        Value memory val\\n    ) internal pure {\\n        arr.inner[index] = val;\\n    }\\n\\n    function length(ValueArray memory arr) internal pure returns (uint256) {\\n        return arr.inner.length;\\n    }\\n\\n    function push(ValueArray memory arr, Value memory val) internal pure {\\n        Value[] memory newInner = new Value[](arr.inner.length + 1);\\n        for (uint256 i = 0; i < arr.inner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        newInner[arr.inner.length] = val;\\n        arr.inner = newInner;\\n    }\\n\\n    function pop(ValueArray memory arr) internal pure returns (Value memory popped) {\\n        popped = arr.inner[arr.inner.length - 1];\\n        Value[] memory newInner = new Value[](arr.inner.length - 1);\\n        for (uint256 i = 0; i < newInner.length; i++) {\\n            newInner[i] = arr.inner[i];\\n        }\\n        arr.inner = newInner;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/osp/IOneStepProver.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../state/Machine.sol\\\";\\nimport \\\"../state/Module.sol\\\";\\nimport \\\"../state/Instructions.sol\\\";\\nimport \\\"../bridge/ISequencerInbox.sol\\\";\\nimport \\\"../bridge/IBridge.sol\\\";\\n\\nstruct ExecutionContext {\\n    uint256 maxInboxMessagesRead;\\n    IBridge bridge;\\n}\\n\\nabstract contract IOneStepProver {\\n    function executeOneStep(\\n        ExecutionContext memory execCtx,\\n        Machine calldata mach,\\n        Module calldata mod,\\n        Instruction calldata instruction,\\n        bytes calldata proof\\n    ) external view virtual returns (Machine memory result, Module memory resultMod);\\n}\\n\"\r\n    },\r\n    \"src/state/Module.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ModuleMemory.sol\\\";\\n\\nstruct Module {\\n    bytes32 globalsMerkleRoot;\\n    ModuleMemory moduleMemory;\\n    bytes32 tablesMerkleRoot;\\n    bytes32 functionsMerkleRoot;\\n    uint32 internalsOffset;\\n}\\n\\nlibrary ModuleLib {\\n    using ModuleMemoryLib for ModuleMemory;\\n\\n    function hash(Module memory mod) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"Module:\\\",\\n                    mod.globalsMerkleRoot,\\n                    mod.moduleMemory.hash(),\\n                    mod.tablesMerkleRoot,\\n                    mod.functionsMerkleRoot,\\n                    mod.internalsOffset\\n                )\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/ModuleMemory.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./Deserialize.sol\\\";\\n\\nstruct ModuleMemory {\\n    uint64 size;\\n    uint64 maxSize;\\n    bytes32 merkleRoot;\\n}\\n\\nlibrary ModuleMemoryLib {\\n    using MerkleProofLib for MerkleProof;\\n\\n    function hash(ModuleMemory memory mem) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"Memory:\\\", mem.size, mem.maxSize, mem.merkleRoot));\\n    }\\n\\n    function proveLeaf(\\n        ModuleMemory memory mem,\\n        uint256 leafIdx,\\n        bytes calldata proof,\\n        uint256 startOffset\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 contents,\\n            uint256 offset,\\n            MerkleProof memory merkle\\n        )\\n    {\\n        offset = startOffset;\\n        (contents, offset) = Deserialize.b32(proof, offset);\\n        (merkle, offset) = Deserialize.merkleProof(proof, offset);\\n        bytes32 recomputedRoot = merkle.computeRootFromMemory(leafIdx, contents);\\n        require(recomputedRoot == mem.merkleRoot, \\\"WRONG_MEM_ROOT\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/MerkleProof.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./Module.sol\\\";\\n\\nstruct MerkleProof {\\n    bytes32[] counterparts;\\n}\\n\\nlibrary MerkleProofLib {\\n    using ModuleLib for Module;\\n    using ValueLib for Value;\\n\\n    function computeRootFromValue(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Value memory leaf\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, leaf.hash(), \\\"Value merkle tree:\\\");\\n    }\\n\\n    function computeRootFromInstruction(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Instruction memory inst\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, Instructions.hash(inst), \\\"Instruction merkle tree:\\\");\\n    }\\n\\n    function computeRootFromFunction(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 codeRoot\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Function:\\\", codeRoot));\\n        return computeRootUnsafe(proof, index, h, \\\"Function merkle tree:\\\");\\n    }\\n\\n    function computeRootFromMemory(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 contents\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Memory leaf:\\\", contents));\\n        return computeRootUnsafe(proof, index, h, \\\"Memory merkle tree:\\\");\\n    }\\n\\n    function computeRootFromElement(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 funcTypeHash,\\n        Value memory val\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Table element:\\\", funcTypeHash, val.hash()));\\n        return computeRootUnsafe(proof, index, h, \\\"Table element merkle tree:\\\");\\n    }\\n\\n    function computeRootFromTable(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        uint8 tableType,\\n        uint64 tableSize,\\n        bytes32 elementsRoot\\n    ) internal pure returns (bytes32) {\\n        bytes32 h = keccak256(abi.encodePacked(\\\"Table:\\\", tableType, tableSize, elementsRoot));\\n        return computeRootUnsafe(proof, index, h, \\\"Table merkle tree:\\\");\\n    }\\n\\n    function computeRootFromModule(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        Module memory mod\\n    ) internal pure returns (bytes32) {\\n        return computeRootUnsafe(proof, index, mod.hash(), \\\"Module merkle tree:\\\");\\n    }\\n\\n    // WARNING: leafHash must be computed in such a way that it cannot be a non-leaf hash.\\n    function computeRootUnsafe(\\n        MerkleProof memory proof,\\n        uint256 index,\\n        bytes32 leafHash,\\n        string memory prefix\\n    ) internal pure returns (bytes32 h) {\\n        h = leafHash;\\n        for (uint256 layer = 0; layer < proof.counterparts.length; layer++) {\\n            if (index & 1 == 0) {\\n                h = keccak256(abi.encodePacked(prefix, h, proof.counterparts[layer]));\\n            } else {\\n                h = keccak256(abi.encodePacked(prefix, proof.counterparts[layer], h));\\n            }\\n            index >>= 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/state/Deserialize.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Value.sol\\\";\\nimport \\\"./ValueStack.sol\\\";\\nimport \\\"./Machine.sol\\\";\\nimport \\\"./Instructions.sol\\\";\\nimport \\\"./StackFrame.sol\\\";\\nimport \\\"./MerkleProof.sol\\\";\\nimport \\\"./ModuleMemory.sol\\\";\\nimport \\\"./Module.sol\\\";\\nimport \\\"./GlobalState.sol\\\";\\n\\nlibrary Deserialize {\\n    function u8(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint8 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        ret = uint8(proof[offset]);\\n        offset++;\\n    }\\n\\n    function u16(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint16 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 16 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u32(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint32 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 32 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u64(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint64 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 64 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function u256(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (uint256 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        for (uint256 i = 0; i < 256 / 8; i++) {\\n            ret <<= 8;\\n            ret |= uint8(proof[offset]);\\n            offset++;\\n        }\\n    }\\n\\n    function b32(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (bytes32 ret, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint256 retInt;\\n        (retInt, offset) = u256(proof, offset);\\n        ret = bytes32(retInt);\\n    }\\n\\n    function value(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Value memory val, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint8 typeInt = uint8(proof[offset]);\\n        offset++;\\n        require(typeInt <= uint8(ValueLib.maxValueType()), \\\"BAD_VALUE_TYPE\\\");\\n        uint256 contents;\\n        (contents, offset) = u256(proof, offset);\\n        val = Value({valueType: ValueType(typeInt), contents: contents});\\n    }\\n\\n    function valueStack(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (ValueStack memory stack, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 remainingHash;\\n        (remainingHash, offset) = b32(proof, offset);\\n        uint256 provedLength;\\n        (provedLength, offset) = u256(proof, offset);\\n        Value[] memory proved = new Value[](provedLength);\\n        for (uint256 i = 0; i < proved.length; i++) {\\n            (proved[i], offset) = value(proof, offset);\\n        }\\n        stack = ValueStack({proved: ValueArray(proved), remainingHash: remainingHash});\\n    }\\n\\n    function instruction(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Instruction memory inst, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint16 opcode;\\n        uint256 data;\\n        (opcode, offset) = u16(proof, offset);\\n        (data, offset) = u256(proof, offset);\\n        inst = Instruction({opcode: opcode, argumentData: data});\\n    }\\n\\n    function stackFrame(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (StackFrame memory window, uint256 offset)\\n    {\\n        offset = startOffset;\\n        Value memory returnPc;\\n        bytes32 localsMerkleRoot;\\n        uint32 callerModule;\\n        uint32 callerModuleInternals;\\n        (returnPc, offset) = value(proof, offset);\\n        (localsMerkleRoot, offset) = b32(proof, offset);\\n        (callerModule, offset) = u32(proof, offset);\\n        (callerModuleInternals, offset) = u32(proof, offset);\\n        window = StackFrame({\\n            returnPc: returnPc,\\n            localsMerkleRoot: localsMerkleRoot,\\n            callerModule: callerModule,\\n            callerModuleInternals: callerModuleInternals\\n        });\\n    }\\n\\n    function stackFrameWindow(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (StackFrameWindow memory window, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 remainingHash;\\n        (remainingHash, offset) = b32(proof, offset);\\n        StackFrame[] memory proved;\\n        if (proof[offset] != 0) {\\n            offset++;\\n            proved = new StackFrame[](1);\\n            (proved[0], offset) = stackFrame(proof, offset);\\n        } else {\\n            offset++;\\n            proved = new StackFrame[](0);\\n        }\\n        window = StackFrameWindow({proved: proved, remainingHash: remainingHash});\\n    }\\n\\n    function moduleMemory(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (ModuleMemory memory mem, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint64 size;\\n        uint64 maxSize;\\n        bytes32 root;\\n        (size, offset) = u64(proof, offset);\\n        (maxSize, offset) = u64(proof, offset);\\n        (root, offset) = b32(proof, offset);\\n        mem = ModuleMemory({size: size, maxSize: maxSize, merkleRoot: root});\\n    }\\n\\n    function module(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Module memory mod, uint256 offset)\\n    {\\n        offset = startOffset;\\n        bytes32 globalsMerkleRoot;\\n        ModuleMemory memory mem;\\n        bytes32 tablesMerkleRoot;\\n        bytes32 functionsMerkleRoot;\\n        uint32 internalsOffset;\\n        (globalsMerkleRoot, offset) = b32(proof, offset);\\n        (mem, offset) = moduleMemory(proof, offset);\\n        (tablesMerkleRoot, offset) = b32(proof, offset);\\n        (functionsMerkleRoot, offset) = b32(proof, offset);\\n        (internalsOffset, offset) = u32(proof, offset);\\n        mod = Module({\\n            globalsMerkleRoot: globalsMerkleRoot,\\n            moduleMemory: mem,\\n            tablesMerkleRoot: tablesMerkleRoot,\\n            functionsMerkleRoot: functionsMerkleRoot,\\n            internalsOffset: internalsOffset\\n        });\\n    }\\n\\n    function globalState(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (GlobalState memory state, uint256 offset)\\n    {\\n        offset = startOffset;\\n\\n        // using constant ints for array size requires newer solidity\\n        bytes32[2] memory bytes32Vals;\\n        uint64[2] memory u64Vals;\\n\\n        for (uint8 i = 0; i < GlobalStateLib.BYTES32_VALS_NUM; i++) {\\n            (bytes32Vals[i], offset) = b32(proof, offset);\\n        }\\n        for (uint8 i = 0; i < GlobalStateLib.U64_VALS_NUM; i++) {\\n            (u64Vals[i], offset) = u64(proof, offset);\\n        }\\n        state = GlobalState({bytes32Vals: bytes32Vals, u64Vals: u64Vals});\\n    }\\n\\n    function machine(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (Machine memory mach, uint256 offset)\\n    {\\n        offset = startOffset;\\n        MachineStatus status;\\n        {\\n            uint8 statusU8;\\n            (statusU8, offset) = u8(proof, offset);\\n            if (statusU8 == 0) {\\n                status = MachineStatus.RUNNING;\\n            } else if (statusU8 == 1) {\\n                status = MachineStatus.FINISHED;\\n            } else if (statusU8 == 2) {\\n                status = MachineStatus.ERRORED;\\n            } else if (statusU8 == 3) {\\n                status = MachineStatus.TOO_FAR;\\n            } else {\\n                revert(\\\"UNKNOWN_MACH_STATUS\\\");\\n            }\\n        }\\n        ValueStack memory values;\\n        ValueStack memory internalStack;\\n        bytes32 globalStateHash;\\n        uint32 moduleIdx;\\n        uint32 functionIdx;\\n        uint32 functionPc;\\n        StackFrameWindow memory frameStack;\\n        bytes32 modulesRoot;\\n        (values, offset) = valueStack(proof, offset);\\n        (internalStack, offset) = valueStack(proof, offset);\\n        (frameStack, offset) = stackFrameWindow(proof, offset);\\n        (globalStateHash, offset) = b32(proof, offset);\\n        (moduleIdx, offset) = u32(proof, offset);\\n        (functionIdx, offset) = u32(proof, offset);\\n        (functionPc, offset) = u32(proof, offset);\\n        (modulesRoot, offset) = b32(proof, offset);\\n        mach = Machine({\\n            status: status,\\n            valueStack: values,\\n            internalStack: internalStack,\\n            frameStack: frameStack,\\n            globalStateHash: globalStateHash,\\n            moduleIdx: moduleIdx,\\n            functionIdx: functionIdx,\\n            functionPc: functionPc,\\n            modulesRoot: modulesRoot\\n        });\\n    }\\n\\n    function merkleProof(bytes calldata proof, uint256 startOffset)\\n        internal\\n        pure\\n        returns (MerkleProof memory merkle, uint256 offset)\\n    {\\n        offset = startOffset;\\n        uint8 length;\\n        (length, offset) = u8(proof, offset);\\n        bytes32[] memory counterparts = new bytes32[](length);\\n        for (uint8 i = 0; i < length; i++) {\\n            (counterparts[i], offset) = b32(proof, offset);\\n        }\\n        merkle = MerkleProof(counterparts);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/rollup/Node.sol\": {\r\n      \"content\": \"// Copyright 2021-2022, Offchain Labs, Inc.\\n// For license information, see https://github.com/nitro/blob/master/LICENSE\\n// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.0;\\n\\nstruct Node {\\n    // Hash of the state of the chain as of this node\\n    bytes32 stateHash;\\n    // Hash of the data that can be challenged\\n    bytes32 challengeHash;\\n    // Hash of the data that will be committed if this node is confirmed\\n    bytes32 confirmData;\\n    // Index of the node previous to this one\\n    uint64 prevNum;\\n    // Deadline at which this node can be confirmed\\n    uint64 deadlineBlock;\\n    // Deadline at which a child of this node can be confirmed\\n    uint64 noChildConfirmedBeforeBlock;\\n    // Number of stakers staked on this node. This includes real stakers and zombies\\n    uint64 stakerCount;\\n    // Number of stakers staked on a child node. This includes real stakers and zombies\\n    uint64 childStakerCount;\\n    // This value starts at zero and is set to a value when the first child is created. After that it is constant until the node is destroyed or the owner destroys pending nodes\\n    uint64 firstChildBlock;\\n    // The number of the latest child of this node to be created\\n    uint64 latestChildNumber;\\n    // The block number when this node was created\\n    uint64 createdAtBlock;\\n    // A hash of all the data needed to determine this node's validity, to protect against reorgs\\n    bytes32 nodeHash;\\n}\\n\\n/**\\n * @notice Utility functions for Node\\n */\\nlibrary NodeLib {\\n    /**\\n     * @notice Initialize a Node\\n     * @param _stateHash Initial value of stateHash\\n     * @param _challengeHash Initial value of challengeHash\\n     * @param _confirmData Initial value of confirmData\\n     * @param _prevNum Initial value of prevNum\\n     * @param _deadlineBlock Initial value of deadlineBlock\\n     * @param _nodeHash Initial value of nodeHash\\n     */\\n    function createNode(\\n        bytes32 _stateHash,\\n        bytes32 _challengeHash,\\n        bytes32 _confirmData,\\n        uint64 _prevNum,\\n        uint64 _deadlineBlock,\\n        bytes32 _nodeHash\\n    ) internal view returns (Node memory) {\\n        Node memory node;\\n        node.stateHash = _stateHash;\\n        node.challengeHash = _challengeHash;\\n        node.confirmData = _confirmData;\\n        node.prevNum = _prevNum;\\n        node.deadlineBlock = _deadlineBlock;\\n        node.noChildConfirmedBeforeBlock = _deadlineBlock;\\n        node.createdAtBlock = uint64(block.number);\\n        node.nodeHash = _nodeHash;\\n        return node;\\n    }\\n\\n    /**\\n     * @notice Update child properties\\n     * @param number The child number to set\\n     */\\n    function childCreated(Node storage self, uint64 number) internal {\\n        if (self.firstChildBlock == 0) {\\n            self.firstChildBlock = uint64(block.number);\\n        }\\n        self.latestChildNumber = number;\\n    }\\n\\n    /**\\n     * @notice Update the child confirmed deadline\\n     * @param deadline The new deadline to set\\n     */\\n    function newChildConfirmDeadline(Node storage self, uint64 deadline) internal {\\n        self.noChildConfirmedBeforeBlock = deadline;\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed the node's deadline\\n     */\\n    function requirePastDeadline(Node memory self) internal view {\\n        require(block.number >= self.deadlineBlock, \\\"BEFORE_DEADLINE\\\");\\n    }\\n\\n    /**\\n     * @notice Check whether the current block number has met or passed deadline for children of this node to be confirmed\\n     */\\n    function requirePastChildConfirmDeadline(Node memory self) internal view {\\n        require(block.number >= self.noChildConfirmedBeforeBlock, \\\"CHILD_TOO_RECENT\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInit\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"AlreadyValidDASKeyset\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stored\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"received\",\"type\":\"uint256\"}],\"name\":\"BadSequencerNumber\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DataNotAuthenticated\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dataLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDataLength\",\"type\":\"uint256\"}],\"name\":\"DataTooLarge\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelayedBackwards\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DelayedTooFar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceIncludeBlockTooSoon\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForceIncludeTimeTooSoon\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HadZeroInit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectMessagePreimage\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NoSuchKeyset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotBatchPoster\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOrigin\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"InboxMessageDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"messageNum\",\"type\":\"uint256\"}],\"name\":\"InboxMessageDeliveredFromOrigin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"}],\"name\":\"InvalidateKeyset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"OwnerFunctionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"SequencerBatchData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"batchSequenceNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"beforeAcc\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"afterAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"delayedAcc\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint64\",\"name\":\"minTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"minBlockNumber\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"maxBlockNumber\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct ISequencerInbox.TimeBounds\",\"name\":\"timeBounds\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enum ISequencerInbox.BatchDataLocation\",\"name\":\"dataLocation\",\"type\":\"uint8\"}],\"name\":\"SequencerBatchDelivered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"keysetHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"SetValidKeyset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DATA_AUTHENTICATED_FLAG\",\"outputs\":[{\"internalType\":\"bytes1\",\"name\":\"\",\"type\":\"bytes1\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HEADER_LENGTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contract IGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"}],\"name\":\"addSequencerL2Batch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"sequenceNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"afterDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"contract IGasRefunder\",\"name\":\"gasRefunder\",\"type\":\"address\"}],\"name\":\"addSequencerL2BatchFromOrigin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"batchCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridge\",\"outputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"dasKeySetInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isValidKeyset\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"creationBlock\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalDelayedMessagesRead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"kind\",\"type\":\"uint8\"},{\"internalType\":\"uint64[2]\",\"name\":\"l1BlockAndTime\",\"type\":\"uint64[2]\"},{\"internalType\":\"uint256\",\"name\":\"baseFeeL1\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"messageDataHash\",\"type\":\"bytes32\"}],\"name\":\"forceInclusion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"getKeysetCreationBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"inboxAccs\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridge\",\"name\":\"bridge_\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"invalidateKeysetHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBatchPoster\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"ksHash\",\"type\":\"bytes32\"}],\"name\":\"isValidKeysetHash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimeVariation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rollup\",\"outputs\":[{\"internalType\":\"contract IOwnable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isBatchPoster_\",\"type\":\"bool\"}],\"name\":\"setIsBatchPoster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"delayBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureBlocks\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"delaySeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"futureSeconds\",\"type\":\"uint256\"}],\"internalType\":\"struct ISequencerInbox.MaxTimeVariation\",\"name\":\"maxTimeVariation_\",\"type\":\"tuple\"}],\"name\":\"setMaxTimeVariation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"keysetBytes\",\"type\":\"bytes\"}],\"name\":\"setValidKeyset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalDelayedMessagesRead\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SequencerInbox", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}