{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/CircuitOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ITraitOracle.sol\\\";\\n\\ncontract CircuitOracle is ITraitOracle {\\n    uint256 internal constant OP_STOP = 0x00;\\n    uint256 internal constant OP_NOT = 0x01;\\n    uint256 internal constant OP_OR = 0x02;\\n    uint256 internal constant OP_AND = 0x03;\\n\\n    string internal constant ERR_OVERRUN_BASE_TRAIT =\\n        \\\"CircuitOracle: base trait buffer overrun\\\";\\n    string internal constant ERR_OVERRUN_ARG =\\n        \\\"CircuitOracle: arg buffer overrun\\\";\\n\\n    /// Checks if the given token satisfies the circuit specified by `_buf`.\\n    ///\\n    /// `_buf` should be at least 96 bytes long, with the following format:\\n    ///\\n    ///   - Bytes 0 through 31 specify the address of an underlying trait\\n    ///     oracle (zero-padded per Solidity ABI conventions).\\n    ///   - Bytes 32 through 63 specify a `uint256` that encodes the lengths of\\n    ///     between 0 and 16 (inclusive) base traits, each 16 bits long.\\n    ///   - Bytes 64 through 95 specify between 0 and 128 (inclusive) circuit\\n    ///     opcodes, each 2 bits long.\\n    ///   - The remaining bytes consist of two parts: first, all the base\\n    ///     traits, concatenated together without delimeters; second, one byte\\n    ///     per operand to the ops in the circuit up to and excluding the first\\n    ///     STOP op, totaling one byte per NOT op plus two bytes per OR or AND\\n    ///     op.\\n    ///\\n    /// Details of base trait lengths: There are at most 16 base traits, and\\n    /// each must be at most 65534 (0xfffe) bytes long. The length of each base\\n    /// trait is incremented by one to form a `uint16`, and the `_i`th such\\n    /// value is stored in  `(_encodedLengths >> (16 * _i)) & 0xffff`. There\\n    /// are no more base traits once this evaluates to `0` (because `0` is not\\n    /// `_len + 1` for any `_len`).\\n    ///\\n    /// Details of opcodes: There are at most 128 ops in the circuit. Each\\n    /// opcode is encoded as a 2-bit value: STOP is 0, NOT is 1, OR is 2, AND\\n    /// is 3. Opcode `_i` is stored in `(_ops >> (2 * _i)) & 0x03`. Once this\\n    /// evaluates to 0, circuit evaluation stops and returns the most recently\\n    /// computed value, or `false` if there were no base traits and no ops\\n    /// other than STOP.\\n    ///\\n    /// Details of evaluation: There is a bank of 256 boolean variables, all\\n    /// initially false. First, the base traits (if any) are read from `_buf`.\\n    /// The underlying trait oracle is invoked for each, and the result for the\\n    /// `_i`th trait is stored into variable `_i`. Next, the ops are processed\\n    /// sequentially. A STOP op immediately stops evaluation. A NOT, OR, or AND\\n    /// op consumes either 1 or 2 argument indices from `_buf`, reads the\\n    /// argument variable(s) from the 256-cell bank, and applies the operation.\\n    /// Each argument index is a single byte from `_buf` and corresponds to one\\n    /// of the 256 boolean variables. Once the op is evaluated, it is written\\n    /// into the next free variable. Thus, if there were `_n` base traits, the\\n    /// `_i`th op's result is stored into variable `_n + _i`.\\n    ///\\n    /// When evaluation stops, the result is the most recently written\\n    /// variable, or `false` if no variables were written. That is: the result\\n    /// is the result of the last op, or the last base trait if there were no\\n    /// ops, or `false` if there were no ops and no base traits.\\n    function hasTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes calldata _buf\\n    ) external view override returns (bool) {\\n        // Decode the static part of the header (the first 96 bytes), then\\n        // advance to the dynamic part.\\n        (ITraitOracle _delegate, uint256 _traitLengths, uint256 _ops) = abi\\n            .decode(_buf, (ITraitOracle, uint256, uint256));\\n        uint256 _bufIdx = 96; // read-offset into dynamic part of `_buf`\\n\\n        uint256 _mem = 0; // `_mem & (1 << _i)` stores variable `_i`\\n        uint256 _v = 0; // next variable to assign\\n        //\\n        // INVARIANT: `_v` is always at most 144, because it's only ever\\n        // changed by incrementing it by 1 once per loop iteration, and the two\\n        // loops run at most 16 and 128 times, respectively. In particular,\\n        // it's always safe to increment `_v`.\\n\\n        // Read and initialize base trait variables.\\n        //\\n        // NOTE: This loop runs at most 16 times, because it shifts\\n        // `_traitLengths` right by 16 bits each iteration and stops once\\n        // that reaches zero.\\n        while (true) {\\n            // `_traitLength` is zero if we're out of traits, else it's one\\n            // more than the length of the next trait.\\n            uint256 _traitLength = _traitLengths & 0xffff;\\n            _traitLengths >>= 16;\\n            if (_traitLength == 0) break;\\n            // SAFETY: We've just checked that `_traitLength != 0`, so this\\n            // can't underflow.\\n            _traitLength = uncheckedSub(_traitLength, 1);\\n\\n            if (_bufIdx + _traitLength > _buf.length)\\n                revert(ERR_OVERRUN_BASE_TRAIT);\\n            bool _hasTrait = _delegate.hasTrait(\\n                _tokenContract,\\n                _tokenId,\\n                _buf[_bufIdx:_bufIdx + _traitLength]\\n            );\\n            _bufIdx += _traitLength;\\n            _mem |= boolToUint256(_hasTrait) << _v;\\n            // SAFETY: `_v` is at most 144, so incrementing it can't overflow.\\n            _v = uncheckedAdd(_v, 1);\\n        }\\n\\n        // Evaluate operations. Henceforth, `_buf` represents the full array of\\n        // arguments.\\n        //\\n        // NOTE: This loop runs at most 128 times, because it shifts `_ops`\\n        // right by 2 bits each iteration and stops once that reaches zero.\\n        //\\n        // NOTE: Before this loop, `_bufIdx <= _buf.length`, and during this\\n        // loop, `_bufIdx` advances by at most 2 per iteration. Thus, it always\\n        // holds that `_bufIdx <= _buf.length + 256`, so these increments to\\n        // `_bufIdx` can't overflow unless `_buf` is order-of 2^256 bytes long.\\n        while (true) {\\n            uint256 _op = _ops & 0x03;\\n            _ops >>= 2;\\n            if (_op == OP_STOP) break;\\n\\n            // This is a unary or binary operation; compute its output.\\n            bool _output;\\n            if (_op == OP_NOT) {\\n                uint256 _idx0 = _bufIdx;\\n                // SAFETY: `_bufIdx <= _buf.length + 256`, so this shouldn't\\n                // overflow.\\n                _bufIdx = uncheckedAdd(_bufIdx, 1);\\n\\n                if (_buf.length < _bufIdx) revert(ERR_OVERRUN_ARG);\\n                bool _v0 = (_mem & (1 << uint256(uint8(_buf[_idx0])))) != 0;\\n                _output = !_v0;\\n            } else {\\n                // It's a binary operation, either `OP_OR` or `OP_AND`.\\n                uint256 _idx0 = _bufIdx;\\n                // SAFETY: `_bufIdx <= _buf.length + 256`, so this shouldn't\\n                // overflow.\\n                uint256 _idx1 = uncheckedAdd(_bufIdx, 1);\\n                _bufIdx = uncheckedAdd(_bufIdx, 2);\\n\\n                if (_buf.length < _bufIdx) revert(ERR_OVERRUN_ARG);\\n                bool _v0 = (_mem & (1 << uint256(uint8(_buf[_idx0])))) != 0;\\n                bool _v1 = (_mem & (1 << uint256(uint8(_buf[_idx1])))) != 0;\\n                if (_op == OP_OR) {\\n                    _output = _v0 || _v1;\\n                } else {\\n                    _output = _v0 && _v1;\\n                }\\n            }\\n\\n            // Store its output into the next free variable.\\n            _mem |= boolToUint256(_output) << _v;\\n            // SAFETY: `_v` is at most 144, so incrementing it can't overflow.\\n            _v = uncheckedAdd(_v, 1);\\n        }\\n\\n        if (_v == 0) return false; // no base traits or ops\\n        // SAFETY: We've just checked that `_v != 0`, so this subtraction\\n        // can't underflow.\\n        return (_mem & (1 << uncheckedSub(_v, 1))) != 0;\\n    }\\n\\n    /// Returns `_a + _b` without checking for or signalling overflow.\\n    ///\\n    /// # Safety\\n    ///\\n    /// Caller must ensure that `_a + _b` would not overflow or be prepared to\\n    /// handle an overflowed result.\\n    function uncheckedAdd(uint256 _a, uint256 _b)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return _a + _b;\\n        }\\n    }\\n\\n    /// Returns `_a - _b` without checking for or signalling underflow.\\n    ///\\n    /// # Safety\\n    ///\\n    /// Caller must ensure that `_a - _b` would not underflow or be prepared to\\n    /// handle an underflowed result.\\n    function uncheckedSub(uint256 _a, uint256 _b)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return _a - _b;\\n        }\\n    }\\n\\n    /// Equivalent to `uint256(_b ? 1 : 0)`, but without the `jump`/`jumpi`\\n    /// sequence that solc generates for that input.\\n    function boolToUint256(bool _b) internal pure returns (uint256 _x) {\\n        assembly {\\n            _x := _b\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ITraitOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\ninterface ITraitOracle {\\n    /// Queries whether the given NFT has the given trait. The NFT is specified\\n    /// by token ID only; the token contract is assumed to be known already.\\n    /// For instance, a trait oracle could be designed for a specific token\\n    /// contract, or it could call a method on `msg.sender` to determine what\\n    /// contract to use.\\n    ///\\n    /// The interpretation of trait IDs may be domain-specific and is at the\\n    /// discretion of the trait oracle. For example, an oracle might choose to\\n    /// encode traits called \\\"Normal\\\" and \\\"Rare\\\" as `0` and `1` respectively,\\n    /// or as `uint256(keccak256(\\\"Normal\\\"))` and `uint256(keccak256(\\\"Rare\\\"))`,\\n    /// or as something else. The trait oracle may expose other domain-specific\\n    /// methods to describe these traits.\\n    function hasTrait(\\n        IERC721 _tokenContract,\\n        uint256 _tokenId,\\n        bytes calldata _trait\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_tokenContract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_buf\",\"type\":\"bytes\"}],\"name\":\"hasTrait\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CircuitOracle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}