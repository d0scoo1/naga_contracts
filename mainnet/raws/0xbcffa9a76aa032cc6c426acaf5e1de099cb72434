{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.6.11;\r\n\r\n// Common interface for the Pools.\r\ninterface IPool {\r\n    \r\n    // --- Events ---\r\n    \r\n    event ETHBalanceUpdated(uint _newBalance);\r\n    event RUBCBalanceUpdated(uint _newBalance);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n    \r\n    function getETH() external view returns (uint);\r\n\r\n    function getRUBCDebt() external view returns (uint);\r\n\r\n    function increaseRUBCDebt(uint _amount) external;\r\n\r\n    function decreaseRUBCDebt(uint _amount) external;\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ILiquityBase {\r\n    function priceFeed() external view returns (IPriceFeed);\r\n}\r\n\r\ninterface IERC2612 {\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\r\n     * given `owner`'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(address owner, address spender, uint256 amount, \r\n                    uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    \r\n    /**\r\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases `owner`'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     *\r\n     * `owner` can limit the time a Permit is valid for by setting `deadline` to \r\n     * a value in the near future. The deadline argument can be set to uint(-1) to \r\n     * create Permits that effectively never expire.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n    \r\n    function version() external view returns (string memory);\r\n    function permitTypeHash() external view returns (bytes32);\r\n    function domainSeparator() external view returns (bytes32);\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    \r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IStabilityPool {\r\n\r\n    // --- Events ---\r\n    \r\n    event StabilityPoolETHBalanceUpdated(uint _newBalance);\r\n    event StabilityPoolRUBCBalanceUpdated(uint _newBalance);\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolAddressChanged(address _newActivePoolAddress);\r\n    event DefaultPoolAddressChanged(address _newDefaultPoolAddress);\r\n    event RUBCAddressChanged(address _newRUBCAddress);\r\n    event SortedTrovesAddressChanged(address _newSortedTrovesAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event CommunityIssuanceAddressChanged(address _newCommunityIssuanceAddress);\r\n\r\n    event P_Updated(uint _P);\r\n    event S_Updated(uint _S, uint128 _epoch, uint128 _scale);\r\n    event G_Updated(uint _G, uint128 _epoch, uint128 _scale);\r\n    event EpochUpdated(uint128 _currentEpoch);\r\n    event ScaleUpdated(uint128 _currentScale);\r\n\r\n    event FrontEndRegistered(address indexed _frontEnd, uint _kickbackRate);\r\n    event FrontEndTagSet(address indexed _depositor, address indexed _frontEnd);\r\n\r\n    event DepositSnapshotUpdated(address indexed _depositor, uint _P, uint _S, uint _G);\r\n    event FrontEndSnapshotUpdated(address indexed _frontEnd, uint _P, uint _G);\r\n    event UserDepositChanged(address indexed _depositor, uint _newDeposit);\r\n    event FrontEndStakeChanged(address indexed _frontEnd, uint _newFrontEndStake, address _depositor);\r\n\r\n    event ETHGainWithdrawn(address indexed _depositor, uint _ETH, uint _RUBCLoss);\r\n    event RBSTPaidToDepositor(address indexed _depositor, uint _RBST);\r\n    event RBSTPaidToFrontEnd(address indexed _frontEnd, uint _RBST);\r\n    event EtherSent(address _to, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    /*\r\n     * Called only once on init, to set addresses of other Liquity contracts\r\n     * Callable only by owner, renounces ownership at the end\r\n     */\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _troveManagerAddress,\r\n        address _activePoolAddress,\r\n        address _rubcAddress,\r\n        address _sortedTrovesAddress,\r\n        address _priceFeedAddress,\r\n        address _communityIssuanceAddress\r\n    ) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend is registered or zero address\r\n     * - Sender is not a registered frontend\r\n     * - _amount is not zero\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Tags the deposit with the provided front end tag param, if it's a new deposit\r\n     * - Sends depositor's accumulated gains (RBST, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated RBST gains to the tagged front end\r\n     * - Increases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     */\r\n    function provideToSP(uint _amount, address _frontEndTag) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - _amount is zero or there are no under collateralized troves left in the system\r\n     * - User has a non zero deposit\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Removes the deposit's front end tag if it is a full withdrawal\r\n     * - Sends all depositor's accumulated gains (RBST, ETH) to depositor\r\n     * - Sends the tagged front end's accumulated RBST gains to the tagged front end\r\n     * - Decreases deposit and tagged front end's stake, and takes new snapshots for each.\r\n     *\r\n     * If _amount > userDeposit, the user withdraws all of their compounded deposit.\r\n     */\r\n    function withdrawFromSP(uint _amount) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - User has a non zero deposit\r\n     * - User has an open trove\r\n     * - User has some ETH gain\r\n     * ---\r\n     * - Triggers a RBST issuance, based on time passed since the last issuance. The RBST issuance is shared between *all* depositors and front ends\r\n     * - Sends all depositor's RBST gain to  depositor\r\n     * - Sends all tagged front end's RBST gain to the tagged front end\r\n     * - Transfers the depositor's entire ETH gain from the Stability Pool to the caller's trove\r\n     * - Leaves their compounded deposit in the Stability Pool\r\n     * - Updates snapshots for deposit and tagged front end stake\r\n     */\r\n    function withdrawETHGainToTrove(address _upperHint, address _lowerHint) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Frontend (sender) not already registered\r\n     * - User (sender) has no deposit\r\n     * - _kickbackRate is in the range [0, 100%]\r\n     * ---\r\n     * Front end makes a one-time selection of kickback rate upon registering\r\n     */\r\n    function registerFrontEnd(uint _kickbackRate) external;\r\n\r\n    /*\r\n     * Initial checks:\r\n     * - Caller is TroveManager\r\n     * ---\r\n     * Cancels out the specified debt against the RUBC contained in the Stability Pool (as far as possible)\r\n     * and transfers the Trove's ETH collateral from ActivePool to StabilityPool.\r\n     * Only called by liquidation functions in the TroveManager.\r\n     */\r\n    function offset(uint _debt, uint _coll) external;\r\n\r\n    /*\r\n     * Returns the total amount of ETH held by the pool, accounted in an internal variable instead of `balance`,\r\n     * to exclude edge cases like ETH received from a self-destruct.\r\n     */\r\n    function getETH() external view returns (uint);\r\n\r\n    /*\r\n     * Returns RUBC held in the pool. Changes when users deposit/withdraw, and when Trove debt is offset.\r\n     */\r\n    function getTotalRUBCDeposits() external view returns (uint);\r\n\r\n    /*\r\n     * Calculates the ETH gain earned by the deposit since its last snapshots were taken.\r\n     */\r\n    function getDepositorETHGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Calculate the RBST gain earned by a deposit since its last snapshots were taken.\r\n     * If not tagged with a front end, the depositor gets a 100% cut of what their deposit earned.\r\n     * Otherwise, their cut of the deposit's earnings is equal to the kickbackRate, set by the front end through\r\n     * which they made their deposit.\r\n     */\r\n    function getDepositorRBSTGain(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the RBST gain earned by the front end.\r\n     */\r\n    function getFrontEndRBSTGain(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Return the user's compounded deposit.\r\n     */\r\n    function getCompoundedRUBCDeposit(address _depositor) external view returns (uint);\r\n\r\n    /*\r\n     * Return the front end's compounded stake.\r\n     *\r\n     * The front end's compounded stake is equal to the sum of its depositors' compounded deposits.\r\n     */\r\n    function getCompoundedFrontEndStake(address _frontEnd) external view returns (uint);\r\n\r\n    /*\r\n     * Fallback function\r\n     * Only callable by Active Pool, it just accounts for ETH received\r\n     * receive() external payable;\r\n     */\r\n}\r\n\r\ninterface IRUBC is IERC20, IERC2612 { \r\n    \r\n    // --- Events ---\r\n\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n    event StabilityPoolAddressChanged(address _newStabilityPoolAddress);\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n\r\n    event RUBCBalanceUpdated(address _user, uint _amount);\r\n\r\n    // --- Functions ---\r\n\r\n    function mint(address _account, uint256 _amount) external;\r\n\r\n    function burn(address _account, uint256 _amount) external;\r\n\r\n    function sendToPool(address _sender,  address poolAddress, uint256 _amount) external;\r\n\r\n    function returnFromPool(address poolAddress, address user, uint256 _amount ) external;\r\n}\r\n\r\ninterface IRBST is IERC20, IERC2612 { \r\n   \r\n    // --- Events ---\r\n    \r\n    event CommunityIssuanceAddressSet(address _communityIssuanceAddress);\r\n    event RBSTStakingAddressSet(address _rbstStakingAddress);\r\n    event LockupContractFactoryAddressSet(address _lockupContractFactoryAddress);\r\n\r\n    // --- Functions ---\r\n    \r\n    function sendToRBSTStaking(address _sender, uint256 _amount) external;\r\n\r\n    function getDeploymentStartTime() external view returns (uint256);\r\n\r\n    function getLpRewardsEntitlement() external view returns (uint256);\r\n}\r\n\r\ninterface IRBSTStaking {\r\n\r\n    // --- Events --\r\n    \r\n    event RBSTAddressSet(address _rbstAddress);\r\n    event RUBCAddressSet(address _rubcAddress);\r\n    event TroveManagerAddressSet(address _troveManager);\r\n    event BorrowerOperationsAddressSet(address _borrowerOperationsAddress);\r\n    event ActivePoolAddressSet(address _activePoolAddress);\r\n\r\n    event StakeChanged(address indexed staker, uint newStake);\r\n    event StakingGainsWithdrawn(address indexed staker, uint RUBCGain, uint ETHGain);\r\n    event F_ETHUpdated(uint _F_ETH);\r\n    event F_RUBCUpdated(uint _F_RUBC);\r\n    event TotalRBSTStakedUpdated(uint _totalRBSTStaked);\r\n    event EtherSent(address _account, uint _amount);\r\n    event StakerSnapshotsUpdated(address _staker, uint _F_ETH, uint _F_RUBC);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses\r\n    (\r\n        address _rbstAddress,\r\n        address _rubcAddress,\r\n        address _troveManagerAddress, \r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress\r\n    )  external;\r\n\r\n    function stake(uint _RBSTamount) external;\r\n\r\n    function unstake(uint _RBSTamount) external;\r\n\r\n    function increaseF_ETH(uint _ETHFee) external; \r\n\r\n    function increaseF_RUBC(uint _RBSTFee) external;  \r\n\r\n    function getPendingETHGain(address _user) external view returns (uint);\r\n\r\n    function getPendingRUBCGain(address _user) external view returns (uint);\r\n}\r\n\r\n\r\n// Common interface for the Trove Manager.\r\ninterface ITroveManager is ILiquityBase {\r\n    \r\n    // --- Events ---\r\n\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event PriceFeedAddressChanged(address _newPriceFeedAddress);\r\n    event RUBCAddressChanged(address _newRUBCAddress);\r\n    event ActivePoolAddressChanged(address _activePoolAddress);\r\n    event DefaultPoolAddressChanged(address _defaultPoolAddress);\r\n    event StabilityPoolAddressChanged(address _stabilityPoolAddress);\r\n    event GasPoolAddressChanged(address _gasPoolAddress);\r\n    event CollSurplusPoolAddressChanged(address _collSurplusPoolAddress);\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event RBSTAddressChanged(address _rbstAddress);\r\n    event RBSTStakingAddressChanged(address _rbstStakingAddress);\r\n\r\n    event Liquidation(uint _liquidatedDebt, uint _liquidatedColl, uint _collGasCompensation, uint _RUBCGasCompensation);\r\n    event Redemption(uint _attemptedRUBCAmount, uint _actualRUBCAmount, uint _ETHSent, uint _ETHFee);\r\n    event TroveUpdated(address indexed _borrower, uint _debt, uint _coll, uint stake, uint8 operation);\r\n    event TroveLiquidated(address indexed _borrower, uint _debt, uint _coll, uint8 operation);\r\n    event BaseRateUpdated(uint _baseRate);\r\n    event LastFeeOpTimeUpdated(uint _lastFeeOpTime);\r\n    event TotalStakesUpdated(uint _newTotalStakes);\r\n    event SystemSnapshotsUpdated(uint _totalStakesSnapshot, uint _totalCollateralSnapshot);\r\n    event LTermsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveSnapshotsUpdated(uint _L_ETH, uint _L_RUBCDebt);\r\n    event TroveIndexUpdated(address _borrower, uint _newIndex);\r\n\r\n    // --- Functions ---\r\n\r\n    function setAddresses(\r\n        address _borrowerOperationsAddress,\r\n        address _activePoolAddress,\r\n        address _defaultPoolAddress,\r\n        address _stabilityPoolAddress,\r\n        address _gasPoolAddress,\r\n        address _collSurplusPoolAddress,\r\n        address _priceFeedAddress,\r\n        address _rubcAddress,\r\n        address _sortedTrovesAddress,\r\n        address _rbstAddress,\r\n        address _rbstStakingAddress\r\n    ) external;\r\n\r\n    function stabilityPool() external view returns (IStabilityPool);\r\n    function rubc() external view returns (IRUBC);\r\n    function rbst() external view returns (IRBST);\r\n    function rbstStaking() external view returns (IRBSTStaking);\r\n\r\n    function getTroveOwnersCount() external view returns (uint);\r\n\r\n    function getTroveFromTroveOwnersArray(uint _index) external view returns (address);\r\n\r\n    function getNominalICR(address _borrower) external view returns (uint);\r\n    function getCurrentICR(address _borrower, uint _price) external view returns (uint);\r\n\r\n    function liquidate(address _borrower) external;\r\n\r\n    function liquidateTroves(uint _n) external;\r\n\r\n    function batchLiquidateTroves(address[] calldata _troveArray) external;\r\n\r\n    function redeemCollateral(\r\n        uint _RUBCAmount,\r\n        address _firstRedemptionHint,\r\n        address _upperPartialRedemptionHint,\r\n        address _lowerPartialRedemptionHint,\r\n        uint _partialRedemptionHintNICR,\r\n        uint _maxIterations,\r\n        uint _maxFee\r\n    ) external; \r\n\r\n    function updateStakeAndTotalStakes(address _borrower) external returns (uint);\r\n\r\n    function updateTroveRewardSnapshots(address _borrower) external;\r\n\r\n    function addTroveOwnerToArray(address _borrower) external returns (uint index);\r\n\r\n    function applyPendingRewards(address _borrower) external;\r\n\r\n    function getPendingETHReward(address _borrower) external view returns (uint);\r\n\r\n    function getPendingRUBCDebtReward(address _borrower) external view returns (uint);\r\n\r\n     function hasPendingRewards(address _borrower) external view returns (bool);\r\n\r\n    function getEntireDebtAndColl(address _borrower) external view returns (\r\n        uint debt, \r\n        uint coll, \r\n        uint pendingRUBCDebtReward, \r\n        uint pendingETHReward\r\n    );\r\n\r\n    function closeTrove(address _borrower) external;\r\n\r\n    function removeStake(address _borrower) external;\r\n\r\n    function getRedemptionRate() external view returns (uint);\r\n    function getRedemptionRateWithDecay() external view returns (uint);\r\n\r\n    function getRedemptionFeeWithDecay(uint _ETHDrawn) external view returns (uint);\r\n\r\n    function getBorrowingRate() external view returns (uint);\r\n    function getBorrowingRateWithDecay() external view returns (uint);\r\n\r\n    function getBorrowingFee(uint RUBCDebt) external view returns (uint);\r\n    function getBorrowingFeeWithDecay(uint _RUBCDebt) external view returns (uint);\r\n\r\n    function decayBaseRateFromBorrowing() external;\r\n\r\n    function getTroveStatus(address _borrower) external view returns (uint);\r\n    \r\n    function getTroveStake(address _borrower) external view returns (uint);\r\n\r\n    function getTroveDebt(address _borrower) external view returns (uint);\r\n\r\n    function getTroveColl(address _borrower) external view returns (uint);\r\n\r\n    function setTroveStatus(address _borrower, uint num) external;\r\n\r\n    function increaseTroveColl(address _borrower, uint _collIncrease) external returns (uint);\r\n\r\n    function decreaseTroveColl(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function increaseTroveDebt(address _borrower, uint _debtIncrease) external returns (uint); \r\n\r\n    function decreaseTroveDebt(address _borrower, uint _collDecrease) external returns (uint); \r\n\r\n    function getTCR(uint _price) external view returns (uint);\r\n\r\n    function checkRecoveryMode(uint _price) external view returns (bool);\r\n}\r\n\r\n// Common interface for the SortedTroves Doubly Linked List.\r\ninterface ISortedTroves {\r\n\r\n    // --- Events ---\r\n    \r\n    event SortedTrovesAddressChanged(address _sortedDoublyLLAddress);\r\n    event BorrowerOperationsAddressChanged(address _borrowerOperationsAddress);\r\n    event NodeAdded(address _id, uint _NICR);\r\n    event NodeRemoved(address _id);\r\n\r\n    // --- Functions ---\r\n    \r\n    function setParams(uint256 _size, address _TroveManagerAddress, address _borrowerOperationsAddress) external;\r\n\r\n    function insert(address _id, uint256 _ICR, address _prevId, address _nextId) external;\r\n\r\n    function remove(address _id) external;\r\n\r\n    function reInsert(address _id, uint256 _newICR, address _prevId, address _nextId) external;\r\n\r\n    function contains(address _id) external view returns (bool);\r\n\r\n    function isFull() external view returns (bool);\r\n\r\n    function isEmpty() external view returns (bool);\r\n\r\n    function getSize() external view returns (uint256);\r\n\r\n    function getMaxSize() external view returns (uint256);\r\n\r\n    function getFirst() external view returns (address);\r\n\r\n    function getLast() external view returns (address);\r\n\r\n    function getNext(address _id) external view returns (address);\r\n\r\n    function getPrev(address _id) external view returns (address);\r\n\r\n    function validInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (bool);\r\n\r\n    function findInsertPosition(uint256 _ICR, address _prevId, address _nextId) external view returns (address, address);\r\n}\r\n\r\ncontract BaseMath {\r\n    uint constant public DECIMAL_PRECISION = 1e18;\r\n}\r\n\r\nlibrary LiquityMath {\r\n    using SafeMath for uint;\r\n\r\n    uint internal constant DECIMAL_PRECISION = 1e18;\r\n\r\n    /* Precision for Nominal ICR (independent of price). Rationale for the value:\r\n     *\r\n     * - Making it \u201ctoo high\u201d could lead to overflows.\r\n     * - Making it \u201ctoo low\u201d could lead to an ICR equal to zero, due to truncation from Solidity floor division. \r\n     *\r\n     * This value of 1e20 is chosen for safety: the NICR will only overflow for numerator > ~1e39 ETH,\r\n     * and will only truncate to 0 if the denominator is at least 1e20 times greater than the numerator.\r\n     *\r\n     */\r\n    uint internal constant NICR_PRECISION = 1e20;\r\n\r\n    function _min(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a < _b) ? _a : _b;\r\n    }\r\n\r\n    function _max(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a : _b;\r\n    }\r\n\r\n    /* \r\n    * Multiply two decimal numbers and use normal rounding rules:\r\n    * -round product up if 19'th mantissa digit >= 5\r\n    * -round product down if 19'th mantissa digit < 5\r\n    *\r\n    * Used only inside the exponentiation, _decPow().\r\n    */\r\n    function decMul(uint x, uint y) internal pure returns (uint decProd) {\r\n        uint prod_xy = x.mul(y);\r\n\r\n        decProd = prod_xy.add(DECIMAL_PRECISION / 2).div(DECIMAL_PRECISION);\r\n    }\r\n\r\n    /* \r\n    * _decPow: Exponentiation function for 18-digit decimal base, and integer exponent n.\r\n    * \r\n    * Uses the efficient \"exponentiation by squaring\" algorithm. O(log(n)) complexity. \r\n    * \r\n    * Called by two functions that represent time in units of minutes:\r\n    * 1) TroveManager._calcDecayedBaseRate\r\n    * 2) CommunityIssuance._getCumulativeIssuanceFraction \r\n    * \r\n    * The exponent is capped to avoid reverting due to overflow. The cap 525600000 equals\r\n    * \"minutes in 1000 years\": 60 * 24 * 365 * 1000\r\n    * \r\n    * If a period of > 1000 years is ever used as an exponent in either of the above functions, the result will be\r\n    * negligibly different from just passing the cap, since: \r\n    *\r\n    * In function 1), the decayed base rate will be 0 for 1000 years or > 1000 years\r\n    * In function 2), the difference in tokens issued at 1000 years and any time > 1000 years, will be negligible\r\n    */\r\n    function _decPow(uint _base, uint _minutes) internal pure returns (uint) {\r\n       \r\n        if (_minutes > 525600000) {_minutes = 525600000;}  // cap to avoid overflow\r\n    \r\n        if (_minutes == 0) {return DECIMAL_PRECISION;}\r\n\r\n        uint y = DECIMAL_PRECISION;\r\n        uint x = _base;\r\n        uint n = _minutes;\r\n\r\n        // Exponentiation-by-squaring\r\n        while (n > 1) {\r\n            if (n % 2 == 0) {\r\n                x = decMul(x, x);\r\n                n = n.div(2);\r\n            } else { // if (n % 2 != 0)\r\n                y = decMul(x, y);\r\n                x = decMul(x, x);\r\n                n = (n.sub(1)).div(2);\r\n            }\r\n        }\r\n\r\n        return decMul(x, y);\r\n  }\r\n\r\n    function _getAbsoluteDifference(uint _a, uint _b) internal pure returns (uint) {\r\n        return (_a >= _b) ? _a.sub(_b) : _b.sub(_a);\r\n    }\r\n\r\n    function _computeNominalCR(uint _coll, uint _debt) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            return _coll.mul(NICR_PRECISION).div(_debt);\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1;\r\n        }\r\n    }\r\n\r\n    function _computeCR(uint _coll, uint _debt, uint _price) internal pure returns (uint) {\r\n        if (_debt > 0) {\r\n            uint newCollRatio = _coll.mul(_price).div(_debt);\r\n\r\n            return newCollRatio;\r\n        }\r\n        // Return the maximal value for uint256 if the Trove has a debt of 0. Represents \"infinite\" CR.\r\n        else { // if (_debt == 0)\r\n            return 2**256 - 1; \r\n        }\r\n    }\r\n}\r\n\r\ninterface IActivePool is IPool {\r\n    // --- Events ---\r\n    event BorrowerOperationsAddressChanged(address _newBorrowerOperationsAddress);\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event ActivePoolRUBCDebtUpdated(uint _RUBCDebt);\r\n    event ActivePoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETH(address _account, uint _amount) external;\r\n}\r\n\r\ninterface IDefaultPool is IPool {\r\n    // --- Events ---\r\n    event TroveManagerAddressChanged(address _newTroveManagerAddress);\r\n    event DefaultPoolRUBCDebtUpdated(uint _RUBCDebt);\r\n    event DefaultPoolETHBalanceUpdated(uint _ETH);\r\n\r\n    // --- Functions ---\r\n    function sendETHToActivePool(uint _amount) external;\r\n}\r\n\r\ninterface IPriceFeed {\r\n\r\n    // --- Events ---\r\n    event LastGoodPriceUpdated(uint _lastGoodPrice);\r\n   \r\n    // --- Function ---\r\n    function fetchPrice() external returns (uint);\r\n\r\n    function fetchRUBPriceFeedUpdateTimestamp() external returns(uint256);\r\n}\r\n\r\n/* \r\n* Base contract for TroveManager, BorrowerOperations and StabilityPool. Contains global system constants and\r\n* common functions. \r\n*/\r\ncontract LiquityBase is BaseMath, ILiquityBase {\r\n    using SafeMath for uint;\r\n\r\n    uint constant public _100pct = 1000000000000000000; // 1e18 == 100%\r\n\r\n    // Minimum collateral ratio for individual troves\r\n    uint constant public MCR = 1100000000000000000; // 110%\r\n\r\n    // Critical system collateral ratio. If the system's total collateral ratio (TCR) falls below the CCR, Recovery Mode is triggered.\r\n    uint constant public CCR = 1500000000000000000; // 150%\r\n\r\n    // Amount of RUBC to be locked in gas pool on opening troves\r\n    uint constant public RUBC_GAS_COMPENSATION = 20_000e18;\r\n\r\n    // Minimum amount of net RUBC debt a trove must have\r\n    uint constant public MIN_NET_DEBT = 100_000e18;\r\n\r\n    uint constant public PERCENT_DIVISOR = 200; // dividing by 200 yields 0.5%\r\n\r\n    uint constant public BORROWING_FEE_FLOOR = DECIMAL_PRECISION / 1000 * 5; // 0.5%\r\n\r\n    IActivePool public activePool;\r\n\r\n    IDefaultPool public defaultPool;\r\n\r\n    IPriceFeed public override priceFeed;\r\n\r\n    // --- Gas compensation functions ---\r\n\r\n    // Returns the composite debt (drawn debt + gas compensation) of a trove, for the purpose of ICR calculation\r\n    function _getCompositeDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.add(RUBC_GAS_COMPENSATION);\r\n    }\r\n\r\n    function _getNetDebt(uint _debt) internal pure returns (uint) {\r\n        return _debt.sub(RUBC_GAS_COMPENSATION);\r\n    }\r\n\r\n    // Return the amount of ETH to be drawn from a trove's collateral and sent as gas compensation.\r\n    function _getCollGasCompensation(uint _entireColl) internal pure returns (uint) {\r\n        return _entireColl / PERCENT_DIVISOR;\r\n    }\r\n\r\n    function getEntireSystemColl() public view returns (uint entireSystemColl) {\r\n        uint activeColl = activePool.getETH();\r\n        uint liquidatedColl = defaultPool.getETH();\r\n\r\n        return activeColl.add(liquidatedColl);\r\n    }\r\n\r\n    function getEntireSystemDebt() public view returns (uint entireSystemDebt) {\r\n        uint activeDebt = activePool.getRUBCDebt();\r\n        uint closedDebt = defaultPool.getRUBCDebt();\r\n\r\n        return activeDebt.add(closedDebt);\r\n    }\r\n\r\n    function _getTCR(uint _price) internal view returns (uint TCR) {\r\n        uint entireSystemColl = getEntireSystemColl();\r\n        uint entireSystemDebt = getEntireSystemDebt();\r\n\r\n        TCR = LiquityMath._computeCR(entireSystemColl, entireSystemDebt, _price);\r\n\r\n        return TCR;\r\n    }\r\n\r\n    function _checkRecoveryMode(uint _price) internal view returns (bool) {\r\n        uint TCR = _getTCR(_price);\r\n\r\n        return TCR < CCR;\r\n    }\r\n\r\n    function _requireUserAcceptsFee(uint _fee, uint _amount, uint _maxFeePercentage) internal pure {\r\n        uint feePercentage = _fee.mul(DECIMAL_PRECISION).div(_amount);\r\n        require(feePercentage <= _maxFeePercentage, \"Fee exceeded provided maximum\");\r\n    }\r\n}\r\n\r\n/**\r\n * Based on OpenZeppelin's Ownable contract:\r\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n *\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     *\r\n     * NOTE: This function is not safe, as it doesn\u2019t check owner is calling it.\r\n     * Make sure you check it before calling it.\r\n     */\r\n    function _renounceOwnership() internal {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\ncontract CheckContract {\r\n    /**\r\n     * Check that the account is an already deployed non-destroyed contract.\r\n     * See: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L12\r\n     */\r\n    function checkContract(address _account) internal view {\r\n        require(_account != address(0), \"Account cannot be zero address\");\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_account) }\r\n        require(size > 0, \"Account code size cannot be zero\");\r\n    }\r\n}\r\n\r\ncontract HintHelpers is LiquityBase, Ownable, CheckContract {\r\n    string constant public NAME = \"HintHelpers\";\r\n\r\n    ISortedTroves public sortedTroves;\r\n    ITroveManager public troveManager;\r\n\r\n    // --- Events ---\r\n\r\n    event SortedTrovesAddressChanged(address _sortedTrovesAddress);\r\n    event TroveManagerAddressChanged(address _troveManagerAddress);\r\n\r\n    // --- Dependency setters ---\r\n\r\n    function setAddresses(\r\n        address _sortedTrovesAddress,\r\n        address _troveManagerAddress\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        checkContract(_sortedTrovesAddress);\r\n        checkContract(_troveManagerAddress);\r\n\r\n        sortedTroves = ISortedTroves(_sortedTrovesAddress);\r\n        troveManager = ITroveManager(_troveManagerAddress);\r\n\r\n        emit SortedTrovesAddressChanged(_sortedTrovesAddress);\r\n        emit TroveManagerAddressChanged(_troveManagerAddress);\r\n\r\n        _renounceOwnership();\r\n    }\r\n\r\n    // --- Functions ---\r\n\r\n    /* getRedemptionHints() - Helper function for finding the right hints to pass to redeemCollateral().\r\n     *\r\n     * It simulates a redemption of `_RUBCamount` to figure out where the redemption sequence will start and what state the final Trove\r\n     * of the sequence will end up in.\r\n     *\r\n     * Returns three hints:\r\n     *  - `firstRedemptionHint` is the address of the first Trove with ICR >= MCR (i.e. the first Trove that will be redeemed).\r\n     *  - `partialRedemptionHintNICR` is the final nominal ICR of the last Trove of the sequence after being hit by partial redemption,\r\n     *     or zero in case of no partial redemption.\r\n     *  - `truncatedRUBCamount` is the maximum amount that can be redeemed out of the the provided `_RUBCamount`. This can be lower than\r\n     *    `_RUBCamount` when redeeming the full amount would leave the last Trove of the redemption sequence with less net debt than the\r\n     *    minimum allowed value (i.e. MIN_NET_DEBT).\r\n     *\r\n     * The number of Troves to consider for redemption can be capped by passing a non-zero value as `_maxIterations`, while passing zero\r\n     * will leave it uncapped.\r\n     */\r\n\r\n    function getRedemptionHints(\r\n        uint _RUBCamount, \r\n        uint _price,\r\n        uint _maxIterations\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            address firstRedemptionHint,\r\n            uint partialRedemptionHintNICR,\r\n            uint truncatedRUBCamount\r\n        )\r\n    {\r\n        ISortedTroves sortedTrovesCached = sortedTroves;\r\n\r\n        uint remainingRUBC = _RUBCamount;\r\n        address currentTroveuser = sortedTrovesCached.getLast();\r\n\r\n        while (currentTroveuser != address(0) && troveManager.getCurrentICR(currentTroveuser, _price) < MCR) {\r\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\r\n        }\r\n\r\n        firstRedemptionHint = currentTroveuser;\r\n\r\n        if (_maxIterations == 0) {\r\n            _maxIterations = uint(-1);\r\n        }\r\n\r\n        while (currentTroveuser != address(0) && remainingRUBC > 0 && _maxIterations-- > 0) {\r\n            uint netRUBCDebt = _getNetDebt(troveManager.getTroveDebt(currentTroveuser))\r\n                .add(troveManager.getPendingRUBCDebtReward(currentTroveuser));\r\n\r\n            if (netRUBCDebt > remainingRUBC) {\r\n                if (netRUBCDebt > MIN_NET_DEBT) {\r\n                    uint maxRedeemableRUBC = LiquityMath._min(remainingRUBC, netRUBCDebt.sub(MIN_NET_DEBT));\r\n\r\n                    uint ETH = troveManager.getTroveColl(currentTroveuser)\r\n                        .add(troveManager.getPendingETHReward(currentTroveuser));\r\n\r\n                    uint newColl = ETH.sub(maxRedeemableRUBC.mul(DECIMAL_PRECISION).div(_price));\r\n                    uint newDebt = netRUBCDebt.sub(maxRedeemableRUBC);\r\n\r\n                    uint compositeDebt = _getCompositeDebt(newDebt);\r\n                    partialRedemptionHintNICR = LiquityMath._computeNominalCR(newColl, compositeDebt);\r\n\r\n                    remainingRUBC = remainingRUBC.sub(maxRedeemableRUBC);\r\n                }\r\n                break;\r\n            } else {\r\n                remainingRUBC = remainingRUBC.sub(netRUBCDebt);\r\n            }\r\n\r\n            currentTroveuser = sortedTrovesCached.getPrev(currentTroveuser);\r\n        }\r\n\r\n        truncatedRUBCamount = _RUBCamount.sub(remainingRUBC);\r\n    }\r\n\r\n    /* getApproxHint() - return address of a Trove that is, on average, (length / numTrials) positions away in the \r\n    sortedTroves list from the correct insert position of the Trove to be inserted. \r\n    \r\n    Note: The output address is worst-case O(n) positions away from the correct insert position, however, the function \r\n    is probabilistic. Input can be tuned to guarantee results to a high degree of confidence, e.g:\r\n\r\n    Submitting numTrials = k * sqrt(length), with k = 15 makes it very, very likely that the ouput address will \r\n    be <= sqrt(length) positions away from the correct insert position.\r\n    */\r\n    function getApproxHint(uint _CR, uint _numTrials, uint _inputRandomSeed)\r\n        external\r\n        view\r\n        returns (address hintAddress, uint diff, uint latestRandomSeed)\r\n    {\r\n        uint arrayLength = troveManager.getTroveOwnersCount();\r\n\r\n        if (arrayLength == 0) {\r\n            return (address(0), 0, _inputRandomSeed);\r\n        }\r\n\r\n        hintAddress = sortedTroves.getLast();\r\n        diff = LiquityMath._getAbsoluteDifference(_CR, troveManager.getNominalICR(hintAddress));\r\n        latestRandomSeed = _inputRandomSeed;\r\n\r\n        uint i = 1;\r\n\r\n        while (i < _numTrials) {\r\n            latestRandomSeed = uint(keccak256(abi.encodePacked(latestRandomSeed)));\r\n\r\n            uint arrayIndex = latestRandomSeed % arrayLength;\r\n            address currentAddress = troveManager.getTroveFromTroveOwnersArray(arrayIndex);\r\n            uint currentNICR = troveManager.getNominalICR(currentAddress);\r\n\r\n            // check if abs(current - CR) > abs(closest - CR), and update closest if current is closer\r\n            uint currentDiff = LiquityMath._getAbsoluteDifference(currentNICR, _CR);\r\n\r\n            if (currentDiff < diff) {\r\n                diff = currentDiff;\r\n                hintAddress = currentAddress;\r\n            }\r\n            i++;\r\n        }\r\n    }\r\n\r\n    function computeNominalCR(uint _coll, uint _debt) external pure returns (uint) {\r\n        return LiquityMath._computeNominalCR(_coll, _debt);\r\n    }\r\n\r\n    function computeCR(uint _coll, uint _debt, uint _price) external pure returns (uint) {\r\n        return LiquityMath._computeCR(_coll, _debt, _price);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sortedTrovesAddress\",\"type\":\"address\"}],\"name\":\"SortedTrovesAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_troveManagerAddress\",\"type\":\"address\"}],\"name\":\"TroveManagerAddressChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BORROWING_FEE_FLOOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DECIMAL_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_NET_DEBT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RUBC_GAS_COMPENSATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_100pct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activePool\",\"outputs\":[{\"internalType\":\"contract IActivePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"computeCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coll\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_debt\",\"type\":\"uint256\"}],\"name\":\"computeNominalCR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultPool\",\"outputs\":[{\"internalType\":\"contract IDefaultPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_CR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numTrials\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_inputRandomSeed\",\"type\":\"uint256\"}],\"name\":\"getApproxHint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"hintAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestRandomSeed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemColl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemColl\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEntireSystemDebt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"entireSystemDebt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_RUBCamount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxIterations\",\"type\":\"uint256\"}],\"name\":\"getRedemptionHints\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"firstRedemptionHint\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"partialRedemptionHintNICR\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"truncatedRUBCamount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeed\",\"outputs\":[{\"internalType\":\"contract IPriceFeed\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sortedTrovesAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_troveManagerAddress\",\"type\":\"address\"}],\"name\":\"setAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortedTroves\",\"outputs\":[{\"internalType\":\"contract ISortedTroves\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"troveManager\",\"outputs\":[{\"internalType\":\"contract ITroveManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HintHelpers", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd337c40b3af8b8b768e57eed853dd83f0754ab9030da71371fb135df173227d"}]}