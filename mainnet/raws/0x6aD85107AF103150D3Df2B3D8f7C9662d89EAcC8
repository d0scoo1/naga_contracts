{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/inft/ERC721Minter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\r\\nimport \\\"../interfaces/AletheaERC721Spec.sol\\\";\\r\\nimport \\\"../utils/AccessControl.sol\\\";\\r\\nimport \\\"../lib/ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC721 Minter\\r\\n *\\r\\n * @notice ERC721Minter contract introduces a scalable mechanism to mint NFTs to an arbitrary\\r\\n *      amount of addresses by leveraging the power of EIP712 signature.\\r\\n */\\r\\ncontract ERC721Minter is AccessControl {\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @dev Mintable ERC721 contract address to mint tokens of\\r\\n\\t */\\r\\n\\taddress public immutable targetContract;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Number of ERC721 token been mint by ERC721Minter\\r\\n\\t */\\r\\n\\tuint256 public tokenMintCount;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Max token can be minted by ERC721Minter\\r\\n\\t */\\r\\n\\tuint256 public maxTokenMintLimit;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables the airdrop, redeeming the tokens via EIP712 signature\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_REDEEM_ACTIVE must be enabled in order for\\r\\n\\t *      `mintWithAuthorization` and `mintBatchWithAuthorization` functions to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_REDEEM_ACTIVE = 0x0000_0001;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Authorization manager is responsible for supplying the EIP712 signature\\r\\n\\t *      which then can be used to mint tokens, meaning effectively,\\r\\n\\t *      that Authorization manager may act as a minter on the target NFT contract\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_AUTHORIZATION_MANAGER allows minting tokens with authorization\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_AUTHORIZATION_MANAGER = 0x0001_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice mint limit manager is responsible for update ERC721 token mint limit\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_MINT_LIMIT_MANAGER allows update token mint limit\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_MINT_LIMIT_MANAGER = 0x0002_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t *\\r\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\r\\n\\t *      it is implied version is concatenated to the name field, like \\\"ERC721Minter\\\"\\r\\n\\t */\\r\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\r\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain separator,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t */\\r\\n\\tbytes32 public immutable DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t// keccak256(\\\"MintWithAuthorization(address from,address to,uint256 id,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant MINT_WITH_AUTHORIZATION_TYPEHASH = 0xaf4e98e5c9896ed6453d82e308a87caa8a02787c2c671d5a8cd308f9a99ed41f;\\r\\n\\r\\n\\t// keccak256(\\\"MintBatchWithAuthorization(address from,address to,uint256 id,uint256 amount,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant MINTBATCH_WITH_AUTHORIZATION_TYPEHASH = 0x67c2bc25c87d2f7202a6c00ccb845fe254f34def701c1f45f93e7e9219b1ebb2;\\r\\n\\r\\n\\t// keccak256(\\\"CancelAuthorization(address authorizer,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of used nonces for meta transactions\\r\\n\\t *\\r\\n\\t * @dev Maps authorizer address => nonce => true/false (used unused)\\r\\n\\t */\\r\\n\\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets used (ex.: `mintWithAuthorization`, `mintBatchWithAuthorization`)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has used the nonce\\r\\n\\t * @param nonce the nonce used\\r\\n\\t */\\r\\n\\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\\r\\n\\t *\\r\\n\\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\\r\\n\\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\\r\\n\\t *      implies no smart contract state change made (except the nonce marked as cancelled)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has cancelled the nonce\\r\\n\\t * @param nonce the nonce cancelled\\r\\n\\t */\\r\\n\\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever token mint Limit is updated (ex.: `updateTokenMintLimit`)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has updated token mint limit\\r\\n\\t * @param oldLimit old token mint limit\\r\\n\\t * @param newLimit new token mint limit\\r\\n\\t */\\r\\n\\tevent TokenMintLimitUpdated(address indexed authorizer, uint256 oldLimit, uint256 newLimit);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates/deploys ERC721Minter and binds it to ERC721 smart contract on construction\\r\\n\\t *\\r\\n\\t * @param _target deployed Mintable ERC721 smart contract; contract will mint NFTs of that type\\r\\n\\t */\\r\\n\\tconstructor(address _target) {\\r\\n\\t\\t// verify the input is set\\r\\n\\t\\trequire(_target != address(0), \\\"target contract is not set\\\");\\r\\n\\r\\n\\t\\t// verify the input is valid smart contract of the expected interfaces\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tERC165(_target).supportsInterface(type(ERC721).interfaceId)\\r\\n\\t\\t\\t&& ERC165(_target).supportsInterface(type(MintableERC721).interfaceId),\\r\\n\\t\\t\\t\\\"unexpected target type\\\"\\r\\n\\t\\t);\\r\\n\\r\\n\\t\\t// assign the address\\r\\n\\t\\ttargetContract = _target;\\r\\n\\r\\n\\t\\t// max ERC721Minter contract can mint 1000 token's\\r\\n\\t\\tmaxTokenMintLimit = 1000;\\r\\n\\r\\n\\t\\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"ERC721Minter\\\")), block.chainid, address(this)));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if specified nonce was already used\\r\\n\\t *\\r\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\\r\\n\\t *      unique to the authorizer's address\\r\\n\\t *\\r\\n\\t * @dev Alias for usedNonces(authorizer, nonce)\\r\\n\\t *\\r\\n\\t * @param _authorizer an address to check nonce for\\r\\n\\t * @param _nonce a nonce to check\\r\\n\\t * @return true if the nonce was used, false otherwise\\r\\n\\t */\\r\\n\\tfunction authorizationState(address _authorizer, bytes32 _nonce) public view returns (bool) {\\r\\n\\t\\t// simply return the value from the mapping\\r\\n\\t\\treturn usedNonces[_authorizer][_nonce];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Receive a token with a signed authorization from the authorization manager\\r\\n\\t *\\r\\n\\t * @dev This has an additional check to ensure that the receiver's address\\r\\n\\t *      matches the caller of this function to prevent front-running attacks.\\r\\n\\t *\\r\\n\\t * @param _from token sender and transaction authorizer\\r\\n\\t * @param _to token receiver\\r\\n\\t * @param _id token ID to mint\\r\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\r\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\r\\n\\t * @param _nonce unique random nonce\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction mintWithAuthorization(\\r\\n\\t\\taddress _from,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint256 _id,\\r\\n\\t\\tuint256 _validAfter,\\r\\n\\t\\tuint256 _validBefore,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public {\\r\\n\\t\\t// verify redeems are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_REDEEM_ACTIVE), \\\"redeems are disabled\\\");\\r\\n\\r\\n\\t\\trequire(tokenMintCount < maxTokenMintLimit, \\\"minting Limit has been reached!!\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 MintWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(MINT_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _id, _validAfter, _validBefore, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\r\\n\\t\\trequire(isOperatorInRole(signer, ROLE_AUTHORIZATION_MANAGER), \\\"invalid access\\\");\\r\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\r\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\r\\n\\t\\trequire(_to == msg.sender, \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// update token mint count\\r\\n\\t\\ttokenMintCount++;\\r\\n\\r\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_from, _nonce, false);\\r\\n\\r\\n\\t\\t// mint token to the recipient\\r\\n\\t\\tMintableERC721(targetContract).mint(_to, _id);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Receive tokens with a signed authorization from the authorization manager\\r\\n\\t *\\r\\n\\t * @dev This has an additional check to ensure that the receiver's address\\r\\n\\t *      matches the caller of this function to prevent front-running attacks.\\r\\n\\t *\\r\\n\\t * @param _from token sender and transaction authorizer\\r\\n\\t * @param _to token receiver\\r\\n\\t * @param _id token ID to mint\\r\\n\\t * @param _amount amount of tokens to create, two or more\\r\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\r\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\r\\n\\t * @param _nonce unique random nonce\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction mintBatchWithAuthorization(\\r\\n\\t\\taddress _from,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint256 _id,\\r\\n\\t\\tuint256 _amount,\\r\\n\\t\\tuint256 _validAfter,\\r\\n\\t\\tuint256 _validBefore,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public {\\r\\n\\t\\t// verify redeems are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_REDEEM_ACTIVE), \\\"redeems are disabled\\\");\\r\\n\\r\\n\\t\\trequire(tokenMintCount + _amount <= maxTokenMintLimit, \\\"minting Limit has been reached!!\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 MintBatchWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(MINTBATCH_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _id, _amount, _validAfter, _validBefore, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\r\\n\\t\\trequire(isOperatorInRole(signer, ROLE_AUTHORIZATION_MANAGER), \\\"invalid access\\\");\\r\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\r\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\r\\n\\t\\trequire(_to == msg.sender, \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// update token mint count\\r\\n\\t\\ttokenMintCount = tokenMintCount + _amount;\\r\\n\\r\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_from, _nonce, false);\\r\\n\\r\\n\\t\\t// mint token to the recipient\\r\\n\\t\\tMintableERC721(targetContract).mintBatch(_to, _id, _amount);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Attempt to cancel an authorization\\r\\n\\t *\\r\\n\\t * @param _authorizer transaction authorizer\\r\\n\\t * @param _nonce unique random nonce to cancel (mark as used)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction cancelAuthorization(\\r\\n\\t\\taddress _authorizer,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public {\\r\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _authorizer, \\\"invalid signature\\\");\\r\\n\\r\\n\\t\\t// cancel the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_authorizer, _nonce, true);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\r\\n\\t *\\r\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\r\\n\\t\\t// build the EIP-712 hashStruct of the message\\r\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\r\\n\\r\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \u2016 domainSeparator \u2016 hashStruct(message)\\r\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\r\\n\\r\\n\\t\\t// recover the address which signed the message with v, r, s\\r\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\r\\n\\r\\n\\t\\t// return the signer address derived from the signature\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\\r\\n\\t *      1. Verifies the nonce was not used before\\r\\n\\t *      2. Marks the nonce as used\\r\\n\\t *      3. Emits an event that the nonce was used/cancelled\\r\\n\\t *\\r\\n\\t * @dev Set `_cancellation` to false (default) to use nonce,\\r\\n\\t *      set `_cancellation` to true to cancel nonce\\r\\n\\t *\\r\\n\\t * @dev It is expected that the nonce supplied is a randomly\\r\\n\\t *      generated uint256 generated by the client\\r\\n\\t *\\r\\n\\t * @param _authorizer an address to use/cancel nonce for\\r\\n\\t * @param _nonce random nonce to use\\r\\n\\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\\r\\n\\t */\\r\\n\\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\\r\\n\\t\\t// verify nonce was not used before\\r\\n\\t\\trequire(!usedNonces[_authorizer][_nonce], \\\"invalid nonce\\\");\\r\\n\\r\\n\\t\\t// update the nonce state to \\\"used\\\" for that particular signer to avoid replay attack\\r\\n\\t\\tusedNonces[_authorizer][_nonce] = true;\\r\\n\\r\\n\\t\\t// depending on the usage type (use/cancel)\\r\\n\\t\\tif(_cancellation) {\\r\\n\\t\\t\\t// emit an event regarding the nonce cancelled\\r\\n\\t\\t\\temit AuthorizationCanceled(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// emit an event regarding the nonce used\\r\\n\\t\\t\\temit AuthorizationUsed(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates max ERC721 token mint Limit of \\r\\n\\t *\\t\\t\\tERC721Minter contract.\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param _tokenMintLimit new ERC721 token mint limit\\r\\n\\t */\\r\\n\\tfunction updateTokenMintLimit(uint256 _tokenMintLimit) public {\\r\\n\\t\\t// caller must have a permission to update token mint limit\\r\\n\\t\\trequire(isSenderInRole(ROLE_MINT_LIMIT_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// fire an event\\r\\n\\t\\temit TokenMintLimitUpdated(msg.sender, maxTokenMintLimit, _tokenMintLimit);\\r\\n\\r\\n\\t\\t// update token mint limit\\r\\n\\t\\tmaxTokenMintLimit = _tokenMintLimit;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"./ERC165Spec.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\n *      For example, a payable function in this interface may be implemented as nonpayable\\n *      (no state mutability specified) in implementing contract.\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\n *      we have removed all \\\"payable\\\" modifiers.\\n *\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721 is ERC165 {\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\n\\t///  When a Transfer event emits, this also indicates that the approved\\n\\t///  address for that NFT (if any) is reset to none.\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\n\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\n\\t///  The operator can manage all NFTs of the owner.\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\n\\n\\t/// @notice Count all NFTs assigned to an owner\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\n\\t///  function throws for queries about the zero address.\\n\\t/// @param _owner An address for whom to query the balance\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\n\\n\\t/// @notice Find the owner of an NFT\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\n\\t///  about them do throw.\\n\\t/// @param _tokenId The identifier for an NFT\\n\\t/// @return The address of the owner of the NFT\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\n\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\n\\t///  except this function just sets data to \\\"\\\".\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n\\t///  THEY MAY BE PERMANENTLY LOST\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\n\\t///  `_tokenId` is not a valid NFT.\\n\\t/// @param _from The current owner of the NFT\\n\\t/// @param _to The new owner\\n\\t/// @param _tokenId The NFT to transfer\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\n\\t/// @dev The zero address indicates there is no approved address.\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\n\\t///  operator of the current owner.\\n\\t/// @param _approved The new approved NFT controller\\n\\t/// @param _tokenId The NFT to approve\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\n\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\n\\t///  all of `msg.sender`'s assets\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\n\\t///  multiple operators per owner.\\n\\t/// @param _operator Address to add to the set of authorized operators\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\n\\n\\t/// @notice Get the approved address for a single NFT\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\n\\t/// @param _tokenId The NFT to find the approved address for\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\n\\n\\t/// @notice Query if an address is an authorized operator for another address\\n\\t/// @param _owner The address that owns the NFTs\\n\\t/// @param _operator The address that acts on behalf of the owner\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\n}\\n\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\ninterface ERC721TokenReceiver {\\n\\t/// @notice Handle the receipt of an NFT\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\n\\t///  transfer. Return of other than the magic value MUST result in the\\n\\t///  transaction being reverted.\\n\\t///  Note: the contract address is always the message sender.\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\n\\t/// @param _from The address which previously owned the token\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\n\\t/// @param _data Additional data with no specified format\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\n\\t///  unless throwing\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Metadata is ERC721 {\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\n\\tfunction name() external view returns (string memory _name);\\n\\n\\t/// @notice An abbreviated name for NFTs in this contract\\n\\tfunction symbol() external view returns (string memory _symbol);\\n\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\n\\t///  Metadata JSON Schema\\\".\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\n}\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n *\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\n *\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\n *\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\n */\\ninterface ERC721Enumerable is ERC721 {\\n\\t/// @notice Count NFTs tracked by this contract\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\n\\tfunction totalSupply() external view returns (uint256);\\n\\n\\t/// @notice Enumerate valid NFTs\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\n\\t/// @param _index A counter less than `totalSupply()`\\n\\t/// @return The token identifier for the `_index`th NFT,\\n\\t///  (sort order not specified)\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\n\\n\\t/// @notice Enumerate NFTs assigned to an owner\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\n\\t///   (sort order not specified)\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/AletheaERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Alethea Mintable ERC721\\n *\\n * @notice Defines mint capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what mintable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface MintableERC721 {\\n\\t/**\\n\\t * @notice Checks if specified token exists\\n\\t *\\n\\t * @dev Returns whether the specified token ID has an ownership\\n\\t *      information associated with it\\n\\t *\\n\\t * @param _tokenId ID of the token to query existence for\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\n\\t */\\n\\tfunction exists(uint256 _tokenId) external view returns(bool);\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint tokens to\\n\\t * @param _tokenId ID of the first token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\n\\n\\t/**\\n\\t * @dev Creates new token with token ID specified\\n\\t *      and assigns an ownership `_to` for this token\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\n\\n\\t/**\\n\\t * @dev Creates new tokens starting with token ID specified\\n\\t *      and assigns an ownership `_to` for these tokens\\n\\t *\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\n\\t *\\n\\t * @dev n must be greater or equal 2: `n > 1`\\n\\t *\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\n\\t *\\n\\t * @dev Should have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _to an address to mint token to\\n\\t * @param _tokenId ID of the token to mint\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\n\\t */\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\n}\\n\\n/**\\n * @title Alethea Burnable ERC721\\n *\\n * @notice Defines burn capabilities for Alethea ERC721 tokens.\\n *      This interface should be treated as a definition of what burnable means for ERC721\\n *\\n * @author Basil Gorin\\n */\\ninterface BurnableERC721 {\\n\\t/**\\n\\t * @notice Destroys the token with token ID specified\\n\\t *\\n\\t * @dev Should be accessible publicly by token owners.\\n\\t *      May have a restricted access handled by the implementation\\n\\t *\\n\\t * @param _tokenId ID of the token to burn\\n\\t */\\n\\tfunction burn(uint256 _tokenId) external;\\n}\\n\\n/**\\n * @title With Base URI\\n *\\n * @notice A marker interface for the contracts having the baseURI() function\\n *      or public string variable named baseURI\\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\\n *\\n * @author Basil Gorin\\n */\\ninterface WithBaseURI {\\n\\t/**\\n\\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\n\\t *\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\n\\t *      will have an URI https://api.com/token/1\\n\\t */\\n\\tfunction baseURI() external view returns(string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title Access Control List\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if specific operation is permitted globally and/or\\n *      if particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable specific\\n *      functions (public functions) of the smart contract for everyone.\\n * @notice User roles are designed to restrict access to specific\\n *      functions (restricted functions) of the smart contract to some users.\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @author Basil Gorin\\n */\\ncontract AccessControl {\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @notice Privileged addresses with defined roles/permissions\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t */\\n\\tmapping(address => uint256) public userRoles;\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param _by operator which called the function\\n\\t * @param _to address which was granted/revoked permissions\\n\\t * @param _requested permissions requested\\n\\t * @param _actual permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\n\\n\\t/**\\n\\t * @notice Creates an access control instance,\\n\\t *      setting contract creator to have full privileges\\n\\t */\\n\\tconstructor() {\\n\\t\\t// contract creator has full privileges\\n\\t\\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns(uint256) {\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\n\\t\\treturn userRoles[address(this)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for or zero\\n\\t *      to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = userRoles[operator];\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(userRoles[operator], required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n *\\n * @dev Copy of the Zeppelin's library:\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\\n */\\nlibrary ECDSA {\\n\\t/**\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\n\\t * `signature`. This address can then be used for verification purposes.\\n\\t *\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\n\\t * half order, and the `v` value to be either 27 or 28.\\n\\t *\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n\\t * verification to be secure: it is possible to craft signatures that\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n\\t * this is by receiving a hash of the original message (which may otherwise\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\n\\t *\\n\\t * Documentation for signature generation:\\n\\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n\\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n\\t */\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n\\t\\t// Divide the signature in r, s and v variables\\n\\t\\tbytes32 r;\\n\\t\\tbytes32 s;\\n\\t\\tuint8 v;\\n\\n\\t\\t// Check the signature length\\n\\t\\t// - case 65: r,s,v signature (standard)\\n\\t\\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n\\t\\tif (signature.length == 65) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := mload(add(signature, 0x40))\\n\\t\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse if (signature.length == 64) {\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\n\\t\\t\\t// currently is to use assembly.\\n\\t\\t\\tassembly {\\n\\t\\t\\t\\tlet vs := mload(add(signature, 0x40))\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\n\\t\\t\\t\\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n\\t\\t\\t\\tv := add(shr(255, vs), 27)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\trevert(\\\"invalid signature length\\\");\\n\\t\\t}\\n\\n\\t\\treturn recover(hash, v, r, s);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Overload of {ECDSA-recover} that receives the `v`,\\n\\t * `r` and `s` signature fields separately.\\n\\t */\\n\\tfunction recover(\\n\\t\\tbytes32 hash,\\n\\t\\tuint8 v,\\n\\t\\tbytes32 r,\\n\\t\\tbytes32 s\\n\\t) internal pure returns (address) {\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n\\t\\t// the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n\\t\\t//\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n\\t\\t// these malleable signatures as well.\\n\\t\\trequire(\\n\\t\\t\\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n\\t\\t\\t\\\"invalid signature 's' value\\\"\\n\\t\\t);\\n\\t\\trequire(v == 27 || v == 28, \\\"invalid signature 'v' value\\\");\\n\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\n\\t\\trequire(signer != address(0), \\\"invalid signature\\\");\\n\\n\\t\\treturn signer;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n\\t * produces hash corresponding to the one signed with the\\n\\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n\\t * JSON-RPC method as part of EIP-191.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n\\t\\t// 32 is the length in bytes of hash,\\n\\t\\t// enforced by the type signature above\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Returns an Ethereum Signed Typed Data, created from a\\n\\t * `domainSeparator` and a `structHash`. This produces hash corresponding\\n\\t * to the one signed with the\\n\\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n\\t * JSON-RPC method as part of EIP-712.\\n\\t *\\n\\t * See {recover}.\\n\\t */\\n\\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC165Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ERC-165 Standard Interface Detection\\n *\\n * @dev Interface of the ERC165 standard, as defined in the\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * @dev Implementers can declare support of contract interfaces,\\n *      which can then be queried by others.\\n *\\n * @author Christian Reitwie\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\n */\\ninterface ERC165 {\\n\\t/**\\n\\t * @notice Query if a contract implements an interface\\n\\t *\\n\\t * @dev Interface identification is specified in ERC-165.\\n\\t *      This function uses less than 30,000 gas.\\n\\t *\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\n\\t * @return `true` if the contract implements `interfaceID` and\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\n\\t */\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_target\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"}],\"name\":\"AuthorizationUsed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLimit\",\"type\":\"uint256\"}],\"name\":\"TokenMintLimitUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANCEL_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FEATURE_REDEEM_ACTIVE\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTBATCH_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_WITH_AUTHORIZATION_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_AUTHORIZATION_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_MINT_LIMIT_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"}],\"name\":\"authorizationState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_authorizer\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desired\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokenMintLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintBatchWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"mintWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMintCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenMintLimit\",\"type\":\"uint256\"}],\"name\":\"updateTokenMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ERC721Minter", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ce69a87c02baa8c5f17ed7eb8b1c2657afc2e1af", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}