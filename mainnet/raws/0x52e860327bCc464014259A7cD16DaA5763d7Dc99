{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@yield-protocol/vault-v2/contracts/oracles/convex/Cvx3CrvOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\n\\nimport \\\"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\\\";\\nimport \\\"@yield-protocol/vault-interfaces/src/IOracle.sol\\\";\\nimport \\\"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\\\";\\n\\nimport \\\"./ICurvePool.sol\\\";\\nimport \\\"../chainlink/AggregatorV3Interface.sol\\\";\\n\\n// Oracle Code Inspiration: https://github.com/Abracadabra-money/magic-internet-money/blob/main/contracts/oracles/3CrvOracle.sol\\n/**\\n *@title  Cvx3CrvOracle\\n *@notice Provides current values for Cvx3Crv\\n *@dev    Both peek() (view) and get() (transactional) are provided for convenience\\n */\\ncontract Cvx3CrvOracle is IOracle, AccessControl {\\n    using CastBytes32Bytes6 for bytes32;\\n    ICurvePool public threecrv;\\n    AggregatorV3Interface public DAI;\\n    AggregatorV3Interface public USDC;\\n    AggregatorV3Interface public USDT;\\n\\n    bytes32 public cvx3CrvId;\\n    bytes32 public ethId;\\n\\n    event SourceSet(\\n        bytes32 cvx3CrvId_,\\n        bytes32 ethId_,\\n        ICurvePool threecrv_,\\n        AggregatorV3Interface DAI_,\\n        AggregatorV3Interface USDC_,\\n        AggregatorV3Interface USDT_\\n    );\\n\\n    /**\\n     *@notice Set threecrv pool and the chainlink sources\\n     *@param  cvx3CrvId_ cvx3crv Id\\n     *@param  ethId_ ETH ID\\n     *@param  threecrv_ The 3CRV pool address\\n     *@param  DAI_ DAI/ETH chainlink price feed address\\n     *@param  USDC_ USDC/ETH chainlink price feed address\\n     *@param  USDT_ USDT/ETH chainlink price feed address\\n     */\\n    function setSource(\\n        bytes32 cvx3CrvId_,\\n        bytes32 ethId_,\\n        ICurvePool threecrv_,\\n        AggregatorV3Interface DAI_,\\n        AggregatorV3Interface USDC_,\\n        AggregatorV3Interface USDT_\\n    ) external auth {\\n        cvx3CrvId = cvx3CrvId_;\\n        ethId = ethId_;\\n        threecrv = threecrv_;\\n        DAI = DAI_;\\n        USDC = USDC_;\\n        USDT = USDT_;\\n        emit SourceSet(cvx3CrvId_, ethId_, threecrv_, DAI_, USDC_, USDT_);\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @notice Retrieve the value of the amount at the latest oracle price.\\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\\n     * @param base Id of base token\\n     * @param quote Id of quoted token\\n     * @param baseAmount Amount of base token for which to get a quote\\n     * @return quoteAmount Total amount in terms of quoted token\\n     * @return updateTime Time quote was last updated\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 baseAmount\\n    ) external view virtual override returns (uint256 quoteAmount, uint256 updateTime) {\\n        (quoteAmount, updateTime) = _peek(base.b6(), quote.b6(), baseAmount);\\n    }\\n\\n    /**\\n     * @notice Retrieve the value of the amount at the latest oracle price. Same as `peek` for this oracle.\\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\\n     * @param base Id of base token\\n     * @param quote Id of quoted token\\n     * @param baseAmount Amount of base token for which to get a quote\\n     * @return quoteAmount Total amount in terms of quoted token\\n     * @return updateTime Time quote was last updated\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 baseAmount\\n    ) external virtual override returns (uint256 quoteAmount, uint256 updateTime) {\\n        (quoteAmount, updateTime) = _peek(base.b6(), quote.b6(), baseAmount);\\n    }\\n\\n    /**\\n     * @notice Retrieve the value of the amount at the latest oracle price.\\n     * @dev Only cvx3crvid and ethId are accepted as asset identifiers.\\n     * @param base Id of base token\\n     * @param quote Id of quoted token\\n     * @param baseAmount Amount of base token for which to get a quote\\n     * @return quoteAmount Total amount in terms of quoted token\\n     * @return updateTime Time quote was last updated\\n     */\\n    function _peek(\\n        bytes6 base,\\n        bytes6 quote,\\n        uint256 baseAmount\\n    ) private view returns (uint256 quoteAmount, uint256 updateTime) {\\n        bytes32 cvx3CrvId_ = cvx3CrvId;\\n        bytes32 ethId_ = ethId;\\n        require(\\n            (base == ethId_ && quote == cvx3CrvId_) || (base == cvx3CrvId_ && quote == ethId_),\\n            \\\"Invalid quote or base\\\"\\n        );\\n\\n        uint80 roundId;\\n        uint80 answeredInRound;\\n        int256 daiPrice;\\n        int256 usdcPrice;\\n        int256 usdtPrice;\\n\\n        // DAI Price\\n        (roundId, daiPrice, , updateTime, answeredInRound) = DAI.latestRoundData();\\n        require(daiPrice > 0, \\\"Chainlink DAI price <= 0\\\");\\n        require(updateTime > 0, \\\"Incomplete round for DAI\\\");\\n        require(answeredInRound >= roundId, \\\"Stale price for DAI\\\");\\n\\n        // USDC Price\\n        (roundId, usdcPrice, , updateTime, answeredInRound) = USDC.latestRoundData();\\n        require(usdcPrice > 0, \\\"Chainlink USDC price <= 0\\\");\\n        require(updateTime > 0, \\\"Incomplete round for USDC\\\");\\n        require(answeredInRound >= roundId, \\\"Stale price for USDC\\\");\\n\\n        // USDT Price\\n        (roundId, usdtPrice, , updateTime, answeredInRound) = USDT.latestRoundData();\\n        require(usdtPrice > 0, \\\"Chainlink USDT price <= 0\\\");\\n        require(updateTime > 0, \\\"Incomplete round for USDT\\\");\\n        require(answeredInRound >= roundId, \\\"Stale price for USDT\\\");\\n\\n        // This won't overflow as the max value for int256 is less than the max value for uint256\\n        uint256 minStable = min(uint256(daiPrice), min(uint256(usdcPrice), uint256(usdtPrice)));\\n\\n        uint256 price = (threecrv.get_virtual_price() * minStable) / 1e18;\\n\\n        if (base == cvx3CrvId_) {\\n            quoteAmount = (baseAmount * price) / 1e18;\\n        } else {\\n            quoteAmount = (baseAmount * 1e18) / price;\\n        }\\n\\n        updateTime = block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms.\\n *\\n * Roles are referred to by their `bytes4` identifier. These are expected to be the \\n * signatures for all the functions in the contract. Special roles should be exposed\\n * in the external API and be unique:\\n *\\n * ```\\n * bytes4 public constant ROOT = 0x00000000;\\n * ```\\n *\\n * Roles represent restricted access to a function call. For that purpose, use {auth}:\\n *\\n * ```\\n * function foo() public auth {\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `ROOT`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {setRoleAdmin}.\\n *\\n * WARNING: The `ROOT` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\ncontract AccessControl {\\n    struct RoleData {\\n        mapping (address => bool) members;\\n        bytes4 adminRole;\\n    }\\n\\n    mapping (bytes4 => RoleData) private _roles;\\n\\n    bytes4 public constant ROOT = 0x00000000;\\n    bytes4 public constant ROOT4146650865 = 0x00000000; // Collision protection for ROOT, test with ROOT12007226833()\\n    bytes4 public constant LOCK = 0xFFFFFFFF;           // Used to disable further permissioning of a function\\n    bytes4 public constant LOCK8605463013 = 0xFFFFFFFF; // Collision protection for LOCK, test with LOCK10462387368()\\n\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\\n     *\\n     * `ROOT` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call.\\n     */\\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \\n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\\n     */\\n    constructor () {\\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\\n    }\\n\\n    /**\\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\\n     * ROOT can give and remove access to each function, lock any further access being granted to\\n     * a specific action, or even create other roles to delegate admin control over a function.\\n     */\\n    modifier auth() {\\n        require (_hasRole(msg.sig, msg.sender), \\\"Access denied\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allow only if the caller has been granted the admin role of `role`.\\n     */\\n    modifier admin(bytes4 role) {\\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \\\"Only admin\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes4 role, address account) external view returns (bool) {\\n        return _hasRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\\n        return _getRoleAdmin(role);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n\\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\\n        _setRoleAdmin(role, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\\n        _grantRole(role, account);\\n    }\\n\\n    \\n    /**\\n     * @dev Grants all of `role` in `roles` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _grantRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\\n\\n     * Emits a {RoleAdminChanged} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function lockRole(bytes4 role) external virtual admin(role) {\\n        _setRoleAdmin(role, LOCK);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes all of `role` in `roles` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\\n     */\\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\\n        for (uint256 i = 0; i < roles.length; i++) {\\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \\\"Only admin\\\");\\n            _revokeRole(roles[i], account);\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes4 role, address account) external virtual {\\n        require(account == msg.sender, \\\"Renounce only for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\\n        if (_getRoleAdmin(role) != adminRole) {\\n            _roles[role].adminRole = adminRole;\\n            emit RoleAdminChanged(role, adminRole);\\n        }\\n    }\\n\\n    function _grantRole(bytes4 role, address account) internal {\\n        if (!_hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, msg.sender);\\n        }\\n    }\\n\\n    function _revokeRole(bytes4 role, address account) internal {\\n        if (_hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, msg.sender);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-interfaces/src/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IOracle {\\n    /**\\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations:\\n     * @return value in wei\\n     */\\n    function peek(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external view returns (uint256 value, uint256 updateTime);\\n\\n    /**\\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\\n     * @return value in wei\\n     */\\n    function get(\\n        bytes32 base,\\n        bytes32 quote,\\n        uint256 amount\\n    ) external returns (uint256 value, uint256 updateTime);\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n\\nlibrary CastBytes32Bytes6 {\\n    function b6(bytes32 x) internal pure returns (bytes6 y){\\n        require (bytes32(y = bytes6(x)) == x, \\\"Cast overflow\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@yield-protocol/vault-v2/contracts/oracles/convex/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.6;\\n\\ninterface ICurvePool {\\n    function get_virtual_price() external view returns (uint256 price);\\n}\"\r\n    },\r\n    \"@yield-protocol/vault-v2/contracts/oracles/chainlink/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"newAdminRole\",\"type\":\"bytes4\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"cvx3CrvId_\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethId_\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"contract ICurvePool\",\"name\":\"threecrv_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"DAI_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"USDC_\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"USDT_\",\"type\":\"address\"}],\"name\":\"SourceSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DAI\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LOCK8605463013\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROOT4146650865\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cvx3CrvId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"base\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"quote\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"}],\"name\":\"get\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"}],\"name\":\"lockRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"base\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"quote\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"baseAmount\",\"type\":\"uint256\"}],\"name\":\"peek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"quoteAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updateTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"roles\",\"type\":\"bytes4[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"role\",\"type\":\"bytes4\"},{\"internalType\":\"bytes4\",\"name\":\"adminRole\",\"type\":\"bytes4\"}],\"name\":\"setRoleAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"cvx3CrvId_\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"ethId_\",\"type\":\"bytes32\"},{\"internalType\":\"contract ICurvePool\",\"name\":\"threecrv_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"DAI_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"USDC_\",\"type\":\"address\"},{\"internalType\":\"contract AggregatorV3Interface\",\"name\":\"USDT_\",\"type\":\"address\"}],\"name\":\"setSource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"threecrv\",\"outputs\":[{\"internalType\":\"contract ICurvePool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Cvx3CrvOracle", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}