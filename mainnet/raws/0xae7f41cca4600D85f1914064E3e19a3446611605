{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/SalePlatformUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IQuantumArt.sol\\\";\\nimport \\\"./interfaces/IQuantumMintPass.sol\\\";\\nimport \\\"./interfaces/IQuantumUnlocked.sol\\\";\\nimport \\\"./interfaces/IQuantumKeyRing.sol\\\";\\nimport \\\"./ContinuousDutchAuctionUpgradeable.sol\\\";\\nimport \\\"./solmate/AuthUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/BitMapsUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"./SalePlatformStorage.sol\\\";\\n\\ncontract SalePlatformUpgradeable is\\n    SalePlatformAccessors,\\n    Initializable,\\n    ContinuousDutchAuctionUpgradeable,\\n    ReentrancyGuardUpgradeable,\\n    AuthUpgradeable,\\n    UUPSUpgradeable\\n{\\n    using SalePlatformStorage for SalePlatformStorage.Layout;\\n    using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;\\n    using StringsUpgradeable for uint256;\\n\\n    event Purchased(uint256 indexed dropId, uint256 tokenId, address to);\\n    event DropCreated(uint256 dropId);\\n    event DropUpdated(uint256 dropId);\\n\\n    //mapping dropId => struct\\n    // mapping(uint256 => Sale) public sales;\\n    // mapping(uint256 => MPClaim) public mpClaims;\\n    // mapping(uint256 => Whitelist) public whitelists;\\n    // uint256 public defaultArtistCut; //10000 * percentage\\n    // IQuantumArt public quantum;\\n    // IQuantumMintPass public mintpass;\\n    // IQuantumUnlocked public keyUnlocks;\\n    // IQuantumKeyRing public keyRing;\\n    // address[] public privilegedContracts;\\n\\n    uint256 private constant SEPARATOR = 10**4;\\n\\n    // uint128 public nextUnlockDropId;\\n    // mapping(uint256 => UnlockSale) public keySales;\\n\\n    /// >>>>>>>>>>>>>>>>>>>>>  INITIALIZER  <<<<<<<<<<<<<<<<<<<<<< ///\\n\\n    function _authorizeUpgrade(address newImplementation)\\n        internal\\n        override\\n        requiresAuth\\n    {}\\n\\n    function initialize(\\n        address deployedQuantum,\\n        address deployedMP,\\n        address deployedKeyRing,\\n        address deployedUnlocks,\\n        address admin,\\n        address payable treasury,\\n        address authority,\\n        address authorizer\\n    ) public virtual initializer {\\n        __SalePlatform_init(\\n            deployedQuantum,\\n            deployedMP,\\n            deployedKeyRing,\\n            deployedUnlocks,\\n            admin,\\n            treasury,\\n            authority,\\n            authorizer\\n        );\\n    }\\n\\n    function __SalePlatform_init(\\n        address deployedQuantum,\\n        address deployedMP,\\n        address deployedKeyRing,\\n        address deployedUnlocks,\\n        address admin,\\n        address payable treasury,\\n        address authority,\\n        address authorizer\\n    ) internal onlyInitializing {\\n        __AuthAuction_init(admin, AuthorityUpgradeable(authority));\\n        __SalePlatform_init_unchained(\\n            deployedQuantum,\\n            deployedMP,\\n            deployedKeyRing,\\n            deployedUnlocks,\\n            treasury,\\n            authorizer\\n        );\\n    }\\n\\n    function __SalePlatform_init_unchained(\\n        address deployedQuantum,\\n        address deployedMP,\\n        address deployedKeyRing,\\n        address deployedUnlocks,\\n        address payable treasury,\\n        address authorizer\\n    ) internal onlyInitializing {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        s.quantum = IQuantumArt(deployedQuantum);\\n        s.mintpass = IQuantumMintPass(deployedMP);\\n        s.keyRing = IQuantumKeyRing(deployedKeyRing);\\n        s.keyUnlocks = IQuantumUnlocked(deployedUnlocks);\\n        s.quantumTreasury = treasury;\\n        s.authorizer = authorizer;\\n        s.defaultArtistCut = 8000; //default 80% for artist\\n    }\\n\\n    modifier checkCaller() {\\n        require(msg.sender.code.length == 0, \\\"Contract forbidden\\\");\\n        _;\\n    }\\n\\n    modifier isFirstTime(uint256 dropId) {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        if (!s.disablingLimiter.get(dropId)) {\\n            require(\\n                !s.alreadyBought[msg.sender].get(dropId),\\n                string(\\n                    abi.encodePacked(\\\"Already bought drop \\\", dropId.toString())\\n                )\\n            );\\n            s.alreadyBought[msg.sender].set(dropId);\\n        }\\n        _;\\n    }\\n\\n    function setPrivilegedContracts(address[] calldata contracts)\\n        public\\n        requiresAuth\\n    {\\n        SalePlatformStorage.layout().privilegedContracts = contracts;\\n    }\\n\\n    function setAuthorizer(address authorizer) public requiresAuth {\\n        SalePlatformStorage.layout().authorizer = authorizer;\\n    }\\n\\n    function withdraw(address payable to) public requiresAuth {\\n        AddressUpgradeable.sendValue(to, address(this).balance);\\n    }\\n\\n    function premint(uint256 dropId, address[] calldata recipients)\\n        public\\n        requiresAuth\\n    {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        for (uint256 i = 0; i < recipients.length; i++) {\\n            uint256 tokenId = s.quantum.mintTo(dropId, recipients[i]);\\n            emit Purchased(dropId, tokenId, recipients[i]);\\n        }\\n    }\\n\\n    function setMintpass(address deployedMP) public requiresAuth {\\n        SalePlatformStorage.layout().mintpass = IQuantumMintPass(deployedMP);\\n    }\\n\\n    function setQuantum(address deployedQuantum) public requiresAuth {\\n        SalePlatformStorage.layout().quantum = IQuantumArt(deployedQuantum);\\n    }\\n\\n    function setKeyRing(address deployedKeyRing) public requiresAuth {\\n        SalePlatformStorage.layout().keyRing = IQuantumKeyRing(deployedKeyRing);\\n    }\\n\\n    function setKeyUnlocks(address deployedUnlocks) public requiresAuth {\\n        SalePlatformStorage.layout().keyUnlocks = IQuantumUnlocked(\\n            deployedUnlocks\\n        );\\n    }\\n\\n    function setDefaultArtistCut(uint256 cut) public requiresAuth {\\n        SalePlatformStorage.layout().defaultArtistCut = cut;\\n    }\\n\\n    function createSale(\\n        uint256 dropId,\\n        uint128 price,\\n        uint64 start,\\n        uint64 limit\\n    ) public requiresAuth {\\n        SalePlatformStorage.layout().sales[dropId] = Sale(price, start, limit);\\n    }\\n\\n    function createMPClaim(\\n        uint256 dropId,\\n        uint64 mpId,\\n        uint64 start,\\n        uint128 price\\n    ) public requiresAuth {\\n        SalePlatformStorage.layout().mpClaims[dropId] = MPClaim(\\n            mpId,\\n            start,\\n            price\\n        );\\n    }\\n\\n    function createWLClaim(\\n        uint256 dropId,\\n        uint192 price,\\n        uint64 start,\\n        bytes32 root\\n    ) public requiresAuth {\\n        SalePlatformStorage.layout().whitelists[dropId] = Whitelist(\\n            price,\\n            start,\\n            root\\n        );\\n    }\\n\\n    function flipUint64(uint64 x) internal pure returns (uint64) {\\n        return x > 0 ? 0 : type(uint64).max;\\n    }\\n\\n    function flipSaleState(uint256 dropId) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        s.sales[dropId].start = flipUint64(s.sales[dropId].start);\\n    }\\n\\n    function flipMPClaimState(uint256 dropId) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        s.mpClaims[dropId].start = flipUint64(s.mpClaims[dropId].start);\\n    }\\n\\n    function flipWLState(uint256 dropId) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        s.whitelists[dropId].start = flipUint64(s.whitelists[dropId].start);\\n    }\\n\\n    function flipLimiterForDrop(uint256 dropId) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        if (s.disablingLimiter.get(dropId)) {\\n            s.disablingLimiter.unset(dropId);\\n        } else {\\n            s.disablingLimiter.set(dropId);\\n        }\\n    }\\n\\n    function overrideArtistcut(uint256 dropId, uint256 cut)\\n        public\\n        requiresAuth\\n    {\\n        SalePlatformStorage.layout().overridedArtistCut[dropId] = cut;\\n    }\\n\\n    function overrideUnlockArtistCut(uint256 dropId, uint256 cut)\\n        public\\n        requiresAuth\\n    {\\n        SalePlatformStorage.layout().keySales[dropId].overrideArtistcut = cut;\\n    }\\n\\n    function setAuction(\\n        uint256 auctionId,\\n        uint256 startingPrice,\\n        uint128 decreasingConstant,\\n        uint64 start,\\n        uint64 period\\n    ) public override requiresAuth {\\n        super.setAuction(\\n            auctionId,\\n            startingPrice,\\n            decreasingConstant,\\n            start,\\n            period\\n        );\\n    }\\n\\n    function curatedPayout(\\n        address artist,\\n        uint256 dropId,\\n        uint256 amount\\n    ) internal {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        uint256 artistCut = s.overridedArtistCut[dropId] == 0\\n            ? s.defaultArtistCut\\n            : s.overridedArtistCut[dropId];\\n        uint256 payout_ = (amount * artistCut) / 10000;\\n        AddressUpgradeable.sendValue(payable(artist), payout_);\\n        AddressUpgradeable.sendValue(s.quantumTreasury, amount - payout_);\\n    }\\n\\n    function genericPayout(\\n        address artist,\\n        uint256 amount,\\n        uint256 cut\\n    ) internal {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        uint256 artistCut = cut == 0 ? s.defaultArtistCut : cut;\\n        uint256 payout_ = (amount * artistCut) / 10000;\\n        AddressUpgradeable.sendValue(payable(artist), payout_);\\n        AddressUpgradeable.sendValue(s.quantumTreasury, amount - payout_);\\n    }\\n\\n    function _isPrivileged(address user) internal view returns (bool) {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        uint256 length = s.privilegedContracts.length;\\n        unchecked {\\n            for (uint256 i; i < length; i++) {\\n                /// @dev using this interface because has balanceOf\\n                if (IQuantumArt(s.privilegedContracts[i]).balanceOf(user) > 0) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function purchase(uint256 dropId, uint256 amount)\\n        public\\n        payable\\n        nonReentrant\\n        checkCaller\\n        isFirstTime(dropId)\\n    {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        Sale memory sale = s.sales[dropId];\\n        require(block.timestamp >= sale.start, \\\"PURCHASE:SALE INACTIVE\\\");\\n        require(amount <= sale.limit, \\\"PURCHASE:OVER LIMIT\\\");\\n        require(\\n            msg.value == amount * sale.price,\\n            \\\"PURCHASE:INCORRECT MSG.VALUE\\\"\\n        );\\n        for (uint256 i = 0; i < amount; i++) {\\n            uint256 tokenId = s.quantum.mintTo(dropId, msg.sender);\\n            emit Purchased(dropId, tokenId, msg.sender);\\n        }\\n        curatedPayout(s.quantum.getArtist(dropId), dropId, msg.value);\\n    }\\n\\n    //TODO: reinstate isFirstTime check but only before resting price\\n    function purchaseThroughAuction(uint256 dropId)\\n        public\\n        payable\\n        nonReentrant\\n        checkCaller\\n    {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        Auction memory auction = s.auctions[dropId];\\n        // if 5 minutes before public auction\\n        // if holder -> special treatment\\n        uint256 userPaid = auction.startingPrice;\\n        if (\\n            block.timestamp <= auction.start &&\\n            block.timestamp >= auction.start - 300 &&\\n            _isPrivileged(msg.sender)\\n        ) {\\n            require(msg.value == userPaid, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n        } else {\\n            userPaid = verifyBid(dropId);\\n        }\\n        uint256 tokenId = s.quantum.mintTo(dropId, msg.sender);\\n        emit Purchased(dropId, tokenId, msg.sender);\\n        curatedPayout(s.quantum.getArtist(dropId), dropId, userPaid);\\n    }\\n\\n    function authorizedUnlockWithKey(\\n        UnlockedMintAuthorization calldata mintAuth,\\n        uint256 variant\\n    ) public payable {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        // require(msg.sender == owner || msg.sender == _minter, \\\"NOT_AUTHORIZED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encodePacked(\\n                        mintAuth.id,\\n                        mintAuth.keyId,\\n                        mintAuth.dropId,\\n                        mintAuth.validFrom,\\n                        mintAuth.validPeriod\\n                    )\\n                )\\n            )\\n        );\\n        address signer = ecrecover(digest, mintAuth.v, mintAuth.r, mintAuth.s);\\n        if (signer != s.authorizer) revert(\\\"PURCHASE:INVALID SIGNATURE\\\");\\n        if (block.timestamp <= mintAuth.validFrom)\\n            revert(\\\"PURCHASE:NOT VALID YET\\\");\\n        if (\\n            mintAuth.validPeriod > 0 &&\\n            block.timestamp > mintAuth.validFrom + mintAuth.validPeriod\\n        ) revert(\\\"PURCHASE:AUTHORIZATION EXPIRED\\\");\\n\\n        UnlockSale memory sale = s.keySales[mintAuth.dropId];\\n        address recipient = s.keyRing.ownerOf(mintAuth.keyId);\\n        _unlockWithKey(\\n            mintAuth.keyId,\\n            mintAuth.dropId,\\n            variant,\\n            recipient,\\n            sale\\n        );\\n    }\\n\\n    function _unlockWithKey(\\n        uint256 keyId,\\n        uint128 dropId,\\n        uint256 variant,\\n        address recipient,\\n        UnlockSale memory sale\\n    ) private {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        require(!s.keyUnlockClaims[dropId][keyId], \\\"PURCHASE:KEY ALREADY USED\\\");\\n\\n        require(\\n            s.keyUnlocks.dropSupply(dropId) < sale.maxDropSupply,\\n            \\\"PURCHASE:NO MORE AVAILABLE\\\"\\n        );\\n        require(\\n            sale.numOfVariants == 0 ||\\n                (variant > 0 && variant < sale.numOfVariants + 1),\\n            \\\"PURCHASE:INVALID VARIANT\\\"\\n        );\\n        //Check is a valid key range (to limit to particular keys)\\n        bool inRange = false;\\n        if (sale.enabledKeyRanges.length > 0) {\\n            for (uint256 i = 0; i < sale.enabledKeyRanges.length; i++) {\\n                if (\\n                    (keyId >= (sale.enabledKeyRanges[i] * SEPARATOR)) &&\\n                    (keyId < (((sale.enabledKeyRanges[i] + 1) * SEPARATOR) - 1))\\n                ) inRange = true;\\n            }\\n        } else inRange = true;\\n        require(inRange, \\\"PURCHASE:SALE NOT AVAILABLE TO THIS KEY\\\");\\n        require(msg.value == sale.price, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n\\n        uint256 tokenId = s.keyUnlocks.mint(recipient, dropId, variant);\\n        s.keyUnlockClaims[dropId][keyId] = true;\\n        emit Purchased(dropId, tokenId, recipient);\\n        genericPayout(sale.artist, msg.value, sale.overrideArtistcut);\\n    }\\n\\n    function unlockWithKey(\\n        uint256 keyId,\\n        uint128 dropId,\\n        uint256 variant\\n    ) public payable nonReentrant checkCaller {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        require(\\n            s.keyRing.ownerOf(keyId) == msg.sender,\\n            \\\"PURCHASE:NOT KEY OWNER\\\"\\n        );\\n        UnlockSale memory sale = s.keySales[dropId];\\n        require(block.timestamp >= sale.start, \\\"PURCHASE:SALE NOT STARTED\\\");\\n        require(\\n            block.timestamp <= (sale.start + sale.period),\\n            \\\"PURCHASE:SALE EXPIRED\\\"\\n        );\\n        _unlockWithKey(keyId, dropId, variant, msg.sender, sale);\\n    }\\n\\n    function createUnlockSale(\\n        uint128 price,\\n        uint64 start,\\n        uint64 period,\\n        address artist,\\n        uint128 maxSupply,\\n        uint256 numOfVariants,\\n        uint256[] calldata enabledKeyRanges\\n    ) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        emit DropCreated(s.nextUnlockDropId);\\n        uint256[] memory blankRanges;\\n        s.keySales[s.nextUnlockDropId++] = UnlockSale(\\n            price,\\n            start,\\n            period,\\n            artist,\\n            0,\\n            blankRanges,\\n            numOfVariants,\\n            maxSupply\\n        );\\n        for (uint256 i = 0; i < enabledKeyRanges.length; i++)\\n            s.keySales[s.nextUnlockDropId - 1].enabledKeyRanges.push(\\n                enabledKeyRanges[i]\\n            );\\n    }\\n\\n    function updateUnlockSale(\\n        uint128 dropId,\\n        uint128 price,\\n        uint64 start,\\n        uint64 period,\\n        address artist,\\n        uint128 maxSupply,\\n        uint256 numOfVariants,\\n        uint256[] calldata enabledKeyRanges\\n    ) public requiresAuth {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        emit DropUpdated(dropId);\\n        uint256[] memory blankRanges;\\n        s.keySales[dropId] = UnlockSale(\\n            price,\\n            start,\\n            period,\\n            artist,\\n            0,\\n            blankRanges,\\n            numOfVariants,\\n            maxSupply\\n        );\\n        for (uint256 i = 0; i < enabledKeyRanges.length; i++)\\n            s.keySales[s.nextUnlockDropId - 1].enabledKeyRanges.push(\\n                enabledKeyRanges[i]\\n            );\\n    }\\n\\n    function setKeyUsedBatch(\\n        uint128 dropId,\\n        bool set,\\n        uint256[] calldata keys\\n    ) public requiresAuth {\\n        for (uint256 i = 0; i < keys.length; i++) {\\n            SalePlatformStorage.layout().keyUnlockClaims[dropId][keys[i]] = set;\\n        }\\n    }\\n\\n    function isKeyUsed(uint256 dropId, uint256 keyId)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        // TODO: Fix this after spaces deployment\\n        if (dropId == 0) return true;\\n        return SalePlatformStorage.layout().keyUnlockClaims[dropId][keyId];\\n    }\\n\\n    function claimWithMintPass(uint256 dropId, uint256 amount)\\n        public\\n        payable\\n        nonReentrant\\n    {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        MPClaim memory mpClaim = s.mpClaims[dropId];\\n        require(block.timestamp >= mpClaim.start, \\\"MP: CLAIMING INACTIVE\\\");\\n        require(msg.value == amount * mpClaim.price, \\\"MP:WRONG MSG.VALUE\\\");\\n        s.mintpass.burnFromRedeem(msg.sender, mpClaim.mpId, amount); //burn mintpasses\\n        for (uint256 i = 0; i < amount; i++) {\\n            uint256 tokenId = s.quantum.mintTo(dropId, msg.sender);\\n            emit Purchased(dropId, tokenId, msg.sender);\\n        }\\n        if (msg.value > 0)\\n            curatedPayout(s.quantum.getArtist(dropId), dropId, msg.value);\\n    }\\n\\n    function purchaseThroughWhitelist(\\n        uint256 dropId,\\n        uint256 amount,\\n        uint256 index,\\n        bytes32[] calldata merkleProof\\n    ) external payable nonReentrant {\\n        SalePlatformStorage.Layout storage s = SalePlatformStorage.layout();\\n        Whitelist memory whitelist = s.whitelists[dropId];\\n        require(block.timestamp >= whitelist.start, \\\"WL:INACTIVE\\\");\\n        require(msg.value == whitelist.price * amount, \\\"WL: INVALID MSG.VALUE\\\");\\n        require(!s.claimedWL[dropId].get(index), \\\"WL:ALREADY CLAIMED\\\");\\n        bytes32 node = keccak256(abi.encodePacked(msg.sender, amount, index));\\n        require(\\n            MerkleProofUpgradeable.verify(\\n                merkleProof,\\n                whitelist.merkleRoot,\\n                node\\n            ),\\n            \\\"WL:INVALID PROOF\\\"\\n        );\\n        s.claimedWL[dropId].set(index);\\n        uint256 tokenId = s.quantum.mintTo(dropId, msg.sender);\\n        emit Purchased(dropId, tokenId, msg.sender);\\n        curatedPayout(s.quantum.getArtist(dropId), dropId, msg.value);\\n    }\\n\\n    function isWLClaimed(uint256 dropId, uint256 index)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return SalePlatformStorage.layout().claimedWL[dropId].get(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumArt {\\n    function mintTo(uint256 dropId, address artist) external returns (uint256);\\n    function burn(uint256 tokenId) external;\\n    function getArtist(uint256 dropId) external view returns (address);\\n    function balanceOf(address user) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumMintPass.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumMintPass {\\n    function burnFromRedeem(address user, uint256 mpId, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumUnlocked.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumUnlocked {\\n    function dropSupply(uint128 dropId) external returns (uint128);\\n\\n    function mint(\\n        address to,\\n        uint128 dropId,\\n        uint256 variant\\n    ) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IQuantumKeyRing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IQuantumKeyRing {\\n    function make(address to, uint256 id, uint256 amount) external;\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n}\"\r\n    },\r\n    \"src/ContinuousDutchAuctionUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"./SalePlatformStorage.sol\\\";\\n\\nabstract contract ContinuousDutchAuctionUpgradeable {\\n    function auctions(uint256 auctionId)\\n        public\\n        view\\n        returns (\\n            uint256 startingPrice,\\n            uint128 decreasingConstant,\\n            uint64 start,\\n            uint64 period,\\n            bool active\\n        )\\n    {\\n        Auction memory auction = SalePlatformStorage.layout().auctions[\\n            auctionId\\n        ];\\n        startingPrice = auction.startingPrice;\\n        decreasingConstant = auction.decreasingConstant;\\n        start = auction.start;\\n        period = auction.period;\\n        active = start > 0 && block.timestamp >= start;\\n    }\\n\\n    function setAuction(\\n        uint256 auctionId,\\n        uint256 startingPrice,\\n        uint128 decreasingConstant,\\n        uint64 start,\\n        uint64 period\\n    ) public virtual {\\n        unchecked {\\n            require(\\n                startingPrice - decreasingConstant * period <= startingPrice,\\n                \\\"setAuction: floor price underflow\\\"\\n            );\\n        }\\n        SalePlatformStorage.layout().auctions[auctionId] = Auction(\\n            startingPrice,\\n            decreasingConstant,\\n            start,\\n            period\\n        );\\n    }\\n\\n    function getPrice(uint256 auctionId)\\n        public\\n        view\\n        virtual\\n        returns (uint256 price)\\n    {\\n        Auction memory auction = SalePlatformStorage.layout().auctions[\\n            auctionId\\n        ];\\n        //only compute correct price if necessary\\n        if (block.timestamp < auction.start) price = auction.startingPrice;\\n        else if (block.timestamp >= auction.start + auction.period)\\n            price =\\n                auction.startingPrice -\\n                auction.period *\\n                auction.decreasingConstant;\\n        else\\n            price =\\n                auction.startingPrice -\\n                (auction.decreasingConstant *\\n                    (block.timestamp - auction.start));\\n    }\\n\\n    function verifyBid(uint256 auctionId) internal returns (uint256) {\\n        Auction memory auction = SalePlatformStorage.layout().auctions[\\n            auctionId\\n        ];\\n        require(auction.start > 0, \\\"AUCTION:NOT CREATED\\\");\\n        require(\\n            block.timestamp >= auction.start,\\n            \\\"PURCHASE:AUCTION NOT STARTED\\\"\\n        );\\n        uint256 pricePaid = getPrice(auctionId);\\n        require(msg.value >= pricePaid, \\\"PURCHASE:INCORRECT MSG.VALUE\\\");\\n        if (msg.value - pricePaid > 0)\\n            AddressUpgradeable.sendValue(\\n                payable(msg.sender),\\n                msg.value - pricePaid\\n            ); //refund difference\\n        return pricePaid;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/solmate/AuthUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/// @notice Provides a flexible and updatable auth pattern which is completely separate from application logic.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\n/// @author Modified to be upgradeable by jcbdev @quantum\\nabstract contract AuthUpgradeable is Initializable {\\n    event OwnerUpdated(address indexed user, address indexed newOwner);\\n\\n    event AuthorityUpdated(\\n        address indexed user,\\n        AuthorityUpgradeable indexed newAuthority\\n    );\\n\\n    address public owner;\\n\\n    AuthorityUpgradeable public authority;\\n\\n    function __AuthAuction_init(address _owner, AuthorityUpgradeable _authority)\\n        internal\\n        onlyInitializing\\n    {\\n        __AuthAuction_init_unchained(_owner, _authority);\\n    }\\n\\n    function __AuthAuction_init_unchained(\\n        address _owner,\\n        AuthorityUpgradeable _authority\\n    ) internal onlyInitializing {\\n        owner = _owner;\\n        authority = _authority;\\n\\n        emit OwnerUpdated(msg.sender, _owner);\\n        emit AuthorityUpdated(msg.sender, _authority);\\n    }\\n\\n    modifier requiresAuth() {\\n        require(isAuthorized(msg.sender, msg.sig), \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    function isAuthorized(address user, bytes4 functionSig)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        AuthorityUpgradeable auth = authority; // Memoizing authority saves us a warm SLOAD, around 100 gas.\\n\\n        // Checking if the caller is the owner only after calling the authority saves gas in most cases, but be\\n        // aware that this makes protected functions uncallable even to the owner if the authority is out of order.\\n        return\\n            (address(auth) != address(0) &&\\n                auth.canCall(user, address(this), functionSig)) ||\\n            user == owner;\\n    }\\n\\n    function setAuthority(AuthorityUpgradeable newAuthority) public virtual {\\n        // We check if the caller is the owner first because we want to ensure they can\\n        // always swap out the authority even if it's reverting or using up a lot of gas.\\n        require(\\n            msg.sender == owner ||\\n                authority.canCall(msg.sender, address(this), msg.sig)\\n        );\\n\\n        authority = newAuthority;\\n\\n        emit AuthorityUpdated(msg.sender, newAuthority);\\n    }\\n\\n    function setOwner(address newOwner) public virtual requiresAuth {\\n        owner = newOwner;\\n\\n        emit OwnerUpdated(msg.sender, newOwner);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which provides authorization data to an Auth instance.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/auth/Auth.sol)\\n/// @author Modified from Dappsys (https://github.com/dapphub/ds-auth/blob/master/src/auth.sol)\\ninterface AuthorityUpgradeable {\\n    function canCall(\\n        address user,\\n        address target,\\n        bytes4 functionSig\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuardUpgradeable is Initializable {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    function __ReentrancyGuard_init() internal onlyInitializing {\\n        __ReentrancyGuard_init_unchained();\\n    }\\n\\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/BitMapsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/structs/BitMaps.sol)\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing uint256 to bool mapping in a compact and efficient way, providing the keys are sequential.\\n * Largelly inspired by Uniswap's https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol[merkle-distributor].\\n */\\nlibrary BitMapsUpgradeable {\\n    struct BitMap {\\n        mapping(uint256 => uint256) _data;\\n    }\\n\\n    /**\\n     * @dev Returns whether the bit at `index` is set.\\n     */\\n    function get(BitMap storage bitmap, uint256 index) internal view returns (bool) {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        return bitmap._data[bucket] & mask != 0;\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index` to the boolean `value`.\\n     */\\n    function setTo(\\n        BitMap storage bitmap,\\n        uint256 index,\\n        bool value\\n    ) internal {\\n        if (value) {\\n            set(bitmap, index);\\n        } else {\\n            unset(bitmap, index);\\n        }\\n    }\\n\\n    /**\\n     * @dev Sets the bit at `index`.\\n     */\\n    function set(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] |= mask;\\n    }\\n\\n    /**\\n     * @dev Unsets the bit at `index`.\\n     */\\n    function unset(BitMap storage bitmap, uint256 index) internal {\\n        uint256 bucket = index >> 8;\\n        uint256 mask = 1 << (index & 0xff);\\n        bitmap._data[bucket] &= ~mask;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/MerkleProofUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProofUpgradeable {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"src/SalePlatformStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IQuantumArt.sol\\\";\\nimport \\\"./interfaces/IQuantumMintPass.sol\\\";\\nimport \\\"./interfaces/IQuantumUnlocked.sol\\\";\\nimport \\\"./interfaces/IQuantumKeyRing.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/BitMapsUpgradeable.sol\\\";\\n\\nstruct Sale {\\n    uint128 price;\\n    uint64 start;\\n    uint64 limit;\\n}\\n\\nstruct MPClaim {\\n    uint64 mpId;\\n    uint64 start;\\n    uint128 price;\\n}\\n\\nstruct Whitelist {\\n    uint192 price;\\n    uint64 start;\\n    bytes32 merkleRoot;\\n}\\n\\nstruct UnlockedMintAuthorization {\\n    uint256 id;\\n    uint256 keyId;\\n    uint128 dropId;\\n    uint256 validFrom;\\n    uint256 validPeriod;\\n    bytes32 r;\\n    bytes32 s;\\n    uint8 v;\\n}\\n\\n//TODO: Better drop mechanism\\nstruct UnlockSale {\\n    uint128 price;\\n    uint64 start;\\n    uint64 period;\\n    address artist;\\n    uint256 overrideArtistcut;\\n    uint256[] enabledKeyRanges;\\n    uint256 numOfVariants;\\n    uint128 maxDropSupply;\\n}\\n\\nstruct Auction {\\n    uint256 startingPrice;\\n    uint128 decreasingConstant;\\n    uint64 start;\\n    uint64 period; //period in seconds : MAX IS 18 HOURS\\n}\\n\\nlibrary SalePlatformStorage {\\n    using BitMapsUpgradeable for BitMapsUpgradeable.BitMap;\\n\\n    struct Layout {\\n        mapping(uint256 => Auction) auctions;\\n        mapping(uint256 => Sale) sales;\\n        mapping(uint256 => MPClaim) mpClaims;\\n        mapping(uint256 => Whitelist) whitelists;\\n        uint256 defaultArtistCut; //10000 * percentage\\n        IQuantumArt quantum;\\n        IQuantumMintPass mintpass;\\n        IQuantumUnlocked keyUnlocks;\\n        IQuantumKeyRing keyRing;\\n        address[] privilegedContracts;\\n        BitMapsUpgradeable.BitMap disablingLimiter;\\n        mapping(uint256 => BitMapsUpgradeable.BitMap) claimedWL;\\n        mapping(address => BitMapsUpgradeable.BitMap) alreadyBought;\\n        mapping(uint256 => uint256) overridedArtistCut; // dropId -> cut\\n        address payable quantumTreasury;\\n        address authorizer;\\n        // TODO: Quantum Unlocked appended - needs rewrite\\n        uint128 nextUnlockDropId;\\n        mapping(uint256 => mapping(uint256 => bool)) keyUnlockClaims;\\n        mapping(uint256 => UnlockSale) keySales;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"quantum.contracts.storage.saleplatform.v1\\\");\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\\nabstract contract SalePlatformAccessors {\\n    using SalePlatformStorage for SalePlatformStorage.Layout;\\n\\n    function sales(uint256 dropId) public view returns (Sale memory) {\\n        return SalePlatformStorage.layout().sales[dropId];\\n    }\\n\\n    function mpClaims(uint256 dropId) public view returns (MPClaim memory) {\\n        return SalePlatformStorage.layout().mpClaims[dropId];\\n    }\\n\\n    function whitelists(uint256 dropId) public view returns (Whitelist memory) {\\n        return SalePlatformStorage.layout().whitelists[dropId];\\n    }\\n\\n    function defaultArtistCut() public view returns (uint256) {\\n        return SalePlatformStorage.layout().defaultArtistCut;\\n    }\\n\\n    function privilegedContracts() public view returns (address[] memory) {\\n        return SalePlatformStorage.layout().privilegedContracts;\\n    }\\n\\n    function nextUnlockDropId() public view returns (uint128) {\\n        return SalePlatformStorage.layout().nextUnlockDropId;\\n    }\\n\\n    function keySales(uint256 dropId) public view returns (UnlockSale memory) {\\n        return SalePlatformStorage.layout().keySales[dropId];\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract AuthorityUpgradeable\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"DropCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"DropUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Purchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"decreasingConstant\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract AuthorityUpgradeable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"dropId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"validFrom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validPeriod\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"}],\"internalType\":\"struct UnlockedMintAuthorization\",\"name\":\"mintAuth\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"variant\",\"type\":\"uint256\"}],\"name\":\"authorizedUnlockWithKey\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimWithMintPass\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"mpId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"name\":\"createMPClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"}],\"name\":\"createSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"maxSupply\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"numOfVariants\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"enabledKeyRanges\",\"type\":\"uint256[]\"}],\"name\":\"createUnlockSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"createWLClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultArtistCut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipLimiterForDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipMPClaimState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"flipWLState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedQuantum\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployedMP\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployedKeyRing\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"deployedUnlocks\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"name\":\"isKeyUsed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isWLClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"keySales\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"overrideArtistcut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"enabledKeyRanges\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"numOfVariants\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"maxDropSupply\",\"type\":\"uint128\"}],\"internalType\":\"struct UnlockSale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"mpClaims\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"mpId\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"}],\"internalType\":\"struct MPClaim\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextUnlockDropId\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"overrideArtistcut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"overrideUnlockArtistCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"premint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"privilegedContracts\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"purchaseThroughAuction\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseThroughWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"sales\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"limit\",\"type\":\"uint64\"}],\"internalType\":\"struct Sale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"decreasingConstant\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"}],\"name\":\"setAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AuthorityUpgradeable\",\"name\":\"newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"authorizer\",\"type\":\"address\"}],\"name\":\"setAuthorizer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cut\",\"type\":\"uint256\"}],\"name\":\"setDefaultArtistCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedKeyRing\",\"type\":\"address\"}],\"name\":\"setKeyRing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedUnlocks\",\"type\":\"address\"}],\"name\":\"setKeyUnlocks\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"dropId\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"keys\",\"type\":\"uint256[]\"}],\"name\":\"setKeyUsedBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedMP\",\"type\":\"address\"}],\"name\":\"setMintpass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"name\":\"setPrivilegedContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"deployedQuantum\",\"type\":\"address\"}],\"name\":\"setQuantum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"dropId\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"variant\",\"type\":\"uint256\"}],\"name\":\"unlockWithKey\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"dropId\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"price\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"artist\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"maxSupply\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"numOfVariants\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"enabledKeyRanges\",\"type\":\"uint256[]\"}],\"name\":\"updateUnlockSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"}],\"name\":\"whitelists\",\"outputs\":[{\"components\":[{\"internalType\":\"uint192\",\"name\":\"price\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct Whitelist\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SalePlatformUpgradeable", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}