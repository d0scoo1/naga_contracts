{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/RcaController.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n\\n/**\\n\\n                               ................                            \\n                          ..',,;;::::::::ccccc:;,'..                       \\n                      ..',;;;;::::::::::::cccccllllc;..                    \\n                    .';;;;;;;,'..............',:clllolc,.                  \\n                  .,;;;;;,..                    .';cooool;.                \\n                .';;;;;'.           .....          .,coodoc.               \\n               .,;;;;'.       ..',;:::cccc:;,'.      .;odddl'              \\n              .,;;;;.       .,:cccclllllllllool:'      ,odddl'             \\n             .,:;:;.      .;ccccc:;,''''',;cooooo:.     ,odddc.            \\n             ';:::'     .,ccclc,..         .':odddc.    .cdddo,            \\n            .;:::,.     ,cccc;.              .:oddd:.    ,dddd:.           \\n            '::::'     .ccll:.                .ldddo'    'odddc.           \\n            ,::c:.     ,lllc'    .';;;::::::::codddd;    ,dxxxc.           \\n           .,ccc:.    .;lllc.    ,oooooddddddddddddd;    :dxxd:            \\n            ,cccc.     ;llll'    .;:ccccccccccccccc;.   'oxxxo'            \\n            'cccc,     'loooc.                         'lxxxd;             \\n            .:lll:.    .;ooooc.                      .;oxxxd:.             \\n             ,llll;.    .;ooddo:'.                ..:oxxxxo;.              \\n             .:llol,.     'coddddl:;''.........,;codxxxxd:.                \\n              .:lool;.     .':odddddddddoooodddxxxxxxdl;.                  \\n               .:ooooc'       .';codddddddxxxxxxdol:,.                     \\n                .;ldddoc'.        ...'',,;;;,,''..                         \\n                  .:oddddl:'.                          .,;:'.              \\n                    .:odddddoc;,...              ..',:ldxxxx;              \\n                      .,:odddddddoolcc::::::::cllodxxxxxxxd:.              \\n                         .';clddxxxxxxxxxxxxxxxxxxxxxxoc;'.                \\n                             ..',;:ccllooooooollc:;,'..                    \\n                                        ......                             \\n                                                                      \\n**/\\n\\npragma solidity 0.8.11;\\nimport \\\"../general/RcaGovernable.sol\\\";\\nimport \\\"../library/MerkleProof.sol\\\";\\nimport \\\"../interfaces/IRcaShield.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title RCA Controller\\n * @notice Controller contract for all RCA vaults.\\n * This contract creates vaults, emits events when anything happens on a vault,\\n * keeps track of variables relevant to vault functionality, keeps track of capacities,\\n * amounts for sale on each vault, prices of tokens, and updates vaults when needed.\\n * @author Robert M.C. Forster, Romke Jonker, Taek Lee, Chiranjibi Poudyal\\n */\\n\\ncontract RcaController is RcaGovernable {\\n    /// @notice Address => whether or not it's a verified shield.\\n    mapping(address => bool) public shieldMapping;\\n    /// @notice Address => whether or not shield is active.\\n    mapping(address => bool) public activeShields;\\n\\n    /// @notice Address => whether or not router is verified.\\n    mapping(address => bool) public isRouterVerified;\\n\\n    /// @notice Fees for users per year for using the system. Ideally just 0 but option is here.\\n    /// In hundredths of %. 1000 == 10%.\\n    uint256 public apr;\\n    /// @notice Amount of time users must wait to withdraw tokens after requesting redemption. In seconds.\\n    uint256 public withdrawalDelay;\\n    /// @notice Discount for purchasing tokens being liquidated from a shield. 1000 == 10%.\\n    uint256 public discount;\\n    /// @notice Address that funds from selling tokens is sent to.\\n    address payable public treasury;\\n    /// @notice Amount of funds for sale on a protocol, sent in by DAO after a hack occurs (in token).\\n    bytes32 public liqForClaimsRoot;\\n    /// @notice The amount of each shield that's currently reserved for hack payouts. 1000 == 10%.\\n    bytes32 public reservedRoot;\\n    /// @notice Root of all underlying token prices--only used if the protocol is doing pricing. Price in Ether.\\n    bytes32 public priceRoot;\\n\\n    /// @notice Nonce to prevent replays of capacity signatures. User => RCA nonce.\\n    mapping(address => uint256) public nonces;\\n    /// @notice Last time each individual shield was checked for update.\\n    mapping(address => uint256) public lastShieldUpdate;\\n\\n    /**\\n     * @dev The update variable flow works in an interesting way to optimize efficiency:\\n     * Each time a user interacts with a specific shield vault, it calls Controller\\n     * for all necessary interactions (events & updates). The general Controller function\\n     * will check when when the last shield update was made vs. all recent other updates.\\n     * If a system update is more recent than the shield update, value is changed.\\n     */\\n    struct SystemUpdates {\\n        uint32 liqUpdate;\\n        uint32 reservedUpdate;\\n        uint32 withdrawalDelayUpdate;\\n        uint32 discountUpdate;\\n        uint32 aprUpdate;\\n        uint32 treasuryUpdate;\\n    }\\n    SystemUpdates public systemUpdates;\\n\\n    /**\\n     * @dev Events are used to notify the frontend of events on shields. If we have 1,000 shields,\\n     * a centralized event system can tell the frontend which shields to check for a specific user.\\n     */\\n    event Mint(address indexed rcaShield, address indexed user, uint256 timestamp);\\n    event RedeemRequest(address indexed rcaShield, address indexed user, uint256 timestamp);\\n    event RedeemFinalize(address indexed rcaShield, address indexed user, uint256 timestamp);\\n    event Purchase(address indexed rcaShield, address indexed user, uint256 timestamp);\\n    event ShieldCreated(\\n        address indexed rcaShield,\\n        address indexed underlyingToken,\\n        string name,\\n        string symbol,\\n        uint256 timestamp\\n    );\\n    event ShieldCancelled(address indexed rcaShield);\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////// modifiers //////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Ensure the sender is a shield.\\n     * @dev We don't want non-shield contracts creating mint, redeem, purchase events.\\n     */\\n    modifier onlyShield() {\\n        require(shieldMapping[msg.sender], \\\"Caller must be a Shield Vault.\\\");\\n        _;\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    /////////////////////////////////////////////// constructor /////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Construct with initial privileged addresses for controller.\\n     * @param _governor Complete control of the contracts. Can change all other owners.\\n     * @param _guardian Guardian multisig that can freeze percents after a hack.\\n     * @param _priceOracle Oracle that can submit price root to the ecosystem.\\n     * @param _capOracle Oracle that can submit capacity root to the ecosystem.\\n     * @param _apr Initial fees for the shield (1000 == 10%).\\n     * @param _discount Discount for purchasers of the token (1000 == 10%).\\n     * @param _withdrawalDelay Amount of time (in seconds) users must wait before withdrawing.\\n     * @param _treasury Address of the treasury that Ether funds will be sent to.\\n     */\\n    constructor(\\n        address _governor,\\n        address _guardian,\\n        address _priceOracle,\\n        address _capOracle,\\n        uint256 _apr,\\n        uint256 _discount,\\n        uint256 _withdrawalDelay,\\n        address payable _treasury\\n    ) {\\n        initRcaGovernable(_governor, _guardian, _capOracle, _priceOracle);\\n\\n        apr = _apr;\\n        discount = _discount;\\n        treasury = _treasury;\\n        withdrawalDelay = _withdrawalDelay;\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////// onlyShield /////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Updates contract, emits event for minting, checks capacity.\\n     * @param _user User that is minting tokens.\\n     * @param _uAmount Underlying token amount being liquidated.\\n     * @param _expiry Time (Unix timestamp) that this request expires.\\n     * @param _v The recovery byte of the signature.\\n     * @param _r Half of the ECDSA signature pair.\\n     * @param _s Half of the ECDSA signature pair.\\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\\n     */\\n    function mint(\\n        address _user,\\n        uint256 _uAmount,\\n        uint256 _expiry,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s,\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] calldata _liqForClaimsProof\\n    ) external onlyShield {\\n        _update(_newCumLiqForClaims, _liqForClaimsProof, 0, new bytes32[](0), false);\\n\\n        // Confirm the capacity oracle approved this transaction.\\n        verifyCapacitySig(_user, _uAmount, _expiry, _v, _r, _s);\\n\\n        emit Mint(msg.sender, _user, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Updates contract, emits event for redeem action.\\n     * @param _user User that is redeeming tokens.\\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\\n     * @param _newPercentReserved New percent of the shield that is reserved for hack payouts.\\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\\n     */\\n    function redeemRequest(\\n        address _user,\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] calldata _liqForClaimsProof,\\n        uint256 _newPercentReserved,\\n        bytes32[] calldata _percentReservedProof\\n    ) external onlyShield {\\n        _update(_newCumLiqForClaims, _liqForClaimsProof, _newPercentReserved, _percentReservedProof, true);\\n\\n        emit RedeemRequest(msg.sender, _user, block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Updates contract, emits event for redeem action, returns if router is verified.\\n     * @param _user User that is redeeming tokens.\\n     * @param _to Router address which should be used for zapping.\\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\\n     * @param _newPercentReserved New percent of the shield that is reserved for hack payouts.\\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\\n     */\\n    function redeemFinalize(\\n        address _user,\\n        address _to,\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] calldata _liqForClaimsProof,\\n        uint256 _newPercentReserved,\\n        bytes32[] calldata _percentReservedProof\\n    ) external onlyShield returns (bool) {\\n        _update(_newCumLiqForClaims, _liqForClaimsProof, _newPercentReserved, _percentReservedProof, true);\\n\\n        emit RedeemFinalize(msg.sender, _user, block.timestamp);\\n        return isRouterVerified[_to];\\n    }\\n\\n    /**\\n     * @notice Updates contract, emits event for purchase action, verifies price.\\n     * @param _user The user that is making the purchase.\\n     * @param _uToken The user that is making the purchase.\\n     * @param _ethPrice The price of one token in Ether.\\n     * @param _priceProof Merkle proof to verify the Ether price of the token.\\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\\n     */\\n    function purchase(\\n        address _user,\\n        address _uToken,\\n        uint256 _ethPrice,\\n        bytes32[] calldata _priceProof,\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] calldata _liqForClaimsProof\\n    ) external onlyShield {\\n        _update(_newCumLiqForClaims, _liqForClaimsProof, 0, new bytes32[](0), false);\\n\\n        verifyPrice(_uToken, _ethPrice, _priceProof);\\n        emit Purchase(msg.sender, _user, block.timestamp);\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ///////////////////////////////////////////////// internal //////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice All general updating of shields for a variety of variables that could have changed\\n     * since the last interaction. Amount for sale, whether or not the system is paused, new\\n     * withdrawal delay, new discount for sales, new APR fee for general functionality.\\n     * @param _newCumLiqForClaims New cumulative amount of liquidated tokens if an update is needed.\\n     * @param _liqForClaimsProof Merkle proof to verify the new cumulative liquidated if needed.\\n     * @param _newPercentReserved New percent of tokens of this shield that are reserved.\\n     * @param _percentReservedProof Merkle proof to verify the new percent reserved.\\n     * @param _redeem Whether or not this is a redeem request to know whether to update reserved.\\n     */\\n    function _update(\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] memory _liqForClaimsProof,\\n        uint256 _newPercentReserved,\\n        bytes32[] memory _percentReservedProof,\\n        bool _redeem\\n    ) internal {\\n        IRcaShield shield = IRcaShield(msg.sender);\\n        uint32 lastUpdate = uint32(lastShieldUpdate[msg.sender]);\\n\\n        // Seems kinda messy but not too bad on gas.\\n        SystemUpdates memory updates = systemUpdates;\\n\\n        if (lastUpdate <= updates.treasuryUpdate) shield.setTreasury(treasury);\\n        if (lastUpdate <= updates.discountUpdate) shield.setDiscount(discount);\\n        if (lastUpdate <= updates.withdrawalDelayUpdate) shield.setWithdrawalDelay(withdrawalDelay);\\n        // Update shield here to account for interim period where APR was changed but shield had not updated.\\n        if (lastUpdate <= updates.aprUpdate) {\\n            shield.controllerUpdate(apr, uint256(updates.aprUpdate));\\n            shield.setApr(apr);\\n        }\\n        if (lastUpdate <= updates.liqUpdate) {\\n            // Update potentially needed here as well if amtForSale will grow from APR.\\n            shield.controllerUpdate(apr, uint256(updates.aprUpdate));\\n            \\n            verifyLiq(msg.sender, _newCumLiqForClaims, _liqForClaimsProof);\\n            shield.setLiqForClaims(_newCumLiqForClaims);\\n        }\\n        // Only updates if it's a redeem request (which is the only call that's affected by reserved).\\n        if (lastUpdate <= updates.reservedUpdate && _redeem) {\\n            verifyReserved(msg.sender, _newPercentReserved, _percentReservedProof);\\n            shield.setPercentReserved(_newPercentReserved);\\n        }\\n\\n        lastShieldUpdate[msg.sender] = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Verify the signature approving the transaction.\\n     * @param _user User that is being minted to.\\n     * @param _amount Amount of underlying tokens being deposited.\\n     * @param _expiry Time (Unix timestamp) that this request expires.\\n     * @param _v The recovery byte of the signature.\\n     * @param _r Half of the ECDSA signature pair.\\n     * @param _s Half of the ECDSA signature pair.\\n     */\\n    function verifyCapacitySig(\\n        address _user,\\n        uint256 _amount,\\n        uint256 _expiry,\\n        uint8 _v,\\n        bytes32 _r,\\n        bytes32 _s\\n    ) internal {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"EASE_RCA_CONTROLLER_1.0\\\",\\n                block.chainid,\\n                address(this),\\n                _user,\\n                msg.sender,\\n                _amount,\\n                nonces[_user]++,\\n                _expiry\\n            )\\n        );\\n        bytes32 message = keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", digest));\\n        address signatory = ecrecover(message, _v, _r, _s);\\n\\n        require(signatory == capOracle, \\\"Invalid capacity oracle signature.\\\");\\n        require(block.timestamp <= _expiry, \\\"Capacity permission has expired.\\\");\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    /////////////////////////////////////////////////// view ////////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Verify the current amount for liquidation.\\n     * @param _shield Address of the shield to verify.\\n     * @param _newCumLiqForClaims New cumulative amount liquidated.\\n     * @param _liqForClaimsProof Proof of the for sale amounts.\\n     */\\n    function verifyLiq(\\n        address _shield,\\n        uint256 _newCumLiqForClaims,\\n        bytes32[] memory _liqForClaimsProof\\n    ) public view {\\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _newCumLiqForClaims));\\n        require(MerkleProof.verify(_liqForClaimsProof, liqForClaimsRoot, leaf), \\\"Incorrect liq proof.\\\");\\n    }\\n\\n    /**\\n     * @notice Verify price from Ease price oracle.\\n     * @param _shield Address of the shield to find price of.\\n     * @param _value Price of the underlying token (in Ether) for this shield.\\n     * @param _proof Merkle proof.\\n     */\\n    function verifyPrice(\\n        address _shield,\\n        uint256 _value,\\n        bytes32[] memory _proof\\n    ) public view {\\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _value));\\n        // This doesn't protect against oracle hacks, but does protect against some bugs.\\n        require(_value > 0, \\\"Invalid price submitted.\\\");\\n        require(MerkleProof.verify(_proof, priceRoot, leaf), \\\"Incorrect price proof.\\\");\\n    }\\n\\n    /**\\n     * @notice Verify the percent reserved for a particular shield.\\n     * @param _shield Address of the shield/token to verify reserved.\\n     * @param _percentReserved Percent of shield that's reserved. 10% == 1000.\\n     * @param _proof The Merkle proof verifying the percent reserved.\\n     */\\n    function verifyReserved(\\n        address _shield,\\n        uint256 _percentReserved,\\n        bytes32[] memory _proof\\n    ) public view {\\n        bytes32 leaf = keccak256(abi.encodePacked(_shield, _percentReserved));\\n        require(MerkleProof.verify(_proof, reservedRoot, leaf), \\\"Incorrect capacity proof.\\\");\\n    }\\n\\n    /**\\n     * @notice Makes it easier for frontend to get the balances on many shields.\\n     * @param _user User to find balances of.\\n     * @param _tokens The shields (also tokens) to find the RCA balances for.\\n     */\\n    function balanceOfs(address _user, address[] calldata _tokens) external view returns (uint256[] memory balances) {\\n        balances = new uint256[](_tokens.length);\\n\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\n            uint256 balance = IERC20(_tokens[i]).balanceOf(_user);\\n            balances[i] = balance;\\n        }\\n    }\\n\\n    /**\\n     * @notice Makes it easier for frontend to get the currently withdrawing requests for each shield.\\n     * @param _user User to find requests of.\\n     * @param _shields The shields to find the request data for.\\n     */\\n    function requestOfs(\\n        address _user, \\n        address[] calldata _shields\\n    ) external view returns (IRcaShield.WithdrawRequest[] memory requests) {\\n        requests = new IRcaShield.WithdrawRequest[](_shields.length);\\n\\n        for (uint256 i = 0; i < _shields.length; i++) {\\n            IRcaShield.WithdrawRequest memory request = IRcaShield(_shields[i]).withdrawRequests(_user);\\n            requests[i] = request;\\n        }\\n    }\\n\\n    /**\\n     * @notice Used by frontend to craft signature for a requested transaction.\\n     * @param _user User that is being minted to.\\n     * @param _shield Address of the shield that tokens are being deposited into.\\n     * @param _amount Amount of underlying tokens to deposit.\\n     * @param _nonce User nonce (current nonce +1) that this transaction will be.\\n     * @param _expiry Time (Unix timestamp) that this request will expire.\\n     */\\n    function getMessageHash(\\n        address _user,\\n        address _shield,\\n        uint256 _amount,\\n        uint256 _nonce,\\n        uint256 _expiry\\n    ) external view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    \\\"EASE_RCA_CONTROLLER_1.0\\\",\\n                    block.chainid,\\n                    address(this),\\n                    _user,\\n                    _shield,\\n                    _amount,\\n                    _nonce,\\n                    _expiry\\n                )\\n            );\\n    }\\n\\n    function getAprUpdate() external view returns (uint32) {\\n        return systemUpdates.aprUpdate;\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////// onlyGov //////////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Initialize a new shield.\\n     * @param _shield Address of the shield to initialize.\\n     */\\n    function initializeShield(address _shield) external onlyGov {\\n        IRcaShield(_shield).initialize(apr, discount, treasury, withdrawalDelay);\\n\\n        shieldMapping[_shield] = true;\\n        activeShields[_shield] = true;\\n        lastShieldUpdate[_shield] = block.timestamp;\\n\\n        emit ShieldCreated(\\n            _shield,\\n            address(IRcaShield(_shield).uToken()),\\n            IRcaShield(_shield).name(),\\n            IRcaShield(_shield).symbol(),\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @notice Governance calls to set the new total amount for sale.\\n     * @param _newLiqRoot Merkle root for new total amounts for sale for each protocol (in token).\\n     * @param _newReservedRoot Reserved root setting all percent reserved back to 0.\\n     */\\n    function setLiqTotal(bytes32 _newLiqRoot, bytes32 _newReservedRoot) external onlyGov {\\n        liqForClaimsRoot = _newLiqRoot;\\n        systemUpdates.liqUpdate = uint32(block.timestamp);\\n        reservedRoot = _newReservedRoot;\\n        systemUpdates.reservedUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Governance can reset withdrawal delay for amount of time it takes to withdraw from vaults.\\n     * Not a commonly used function, if at all really.\\n     * @param _newWithdrawalDelay New delay (in seconds) for withdrawals.\\n     */\\n    function setWithdrawalDelay(uint256 _newWithdrawalDelay) external onlyGov {\\n        require(_newWithdrawalDelay <= 86400 * 7, \\\"Withdrawal delay may not be more than 7 days.\\\");\\n        withdrawalDelay = _newWithdrawalDelay;\\n        systemUpdates.withdrawalDelayUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Governance can change the amount of discount for purchasing tokens that are being liquidated.\\n     * @param _newDiscount New discount for purchase in tenths of a percent (1000 == 10%).\\n     */\\n    function setDiscount(uint256 _newDiscount) external onlyGov {\\n        require(_newDiscount <= 2500, \\\"Discount may not be more than 25%.\\\");\\n        discount = _newDiscount;\\n        systemUpdates.discountUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Governance can set the fees taken per year from a vault. Starts at 0, can update at any time.\\n     * @param _newApr New fees per year for being in the RCA system (1000 == 10%).\\n     */\\n    function setApr(uint256 _newApr) external onlyGov {\\n        require(_newApr <= 2000, \\\"APR may not be more than 20%.\\\");\\n        apr = _newApr;\\n        systemUpdates.aprUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Governance can set address of the new treasury contract that accepts funds.\\n     * @param _newTreasury New fees per year for being in the RCA system (1000 == 10%).\\n     */\\n    function setTreasury(address payable _newTreasury) external onlyGov {\\n        treasury = _newTreasury;\\n        systemUpdates.treasuryUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Governance can cancel the shield support.\\n     * @param _shields An array of shield addresses that are being cancelled.\\n     */\\n    function cancelShield(address[] memory _shields) external onlyGov {\\n        for (uint256 i = 0; i < _shields.length; i++) {\\n            activeShields[_shields[i]] = false;\\n            emit ShieldCancelled(_shields[i]);\\n        }\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //////////////////////////////////////////////// onlyGuardian ///////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Admin can set the percent paused. This pauses this percent of tokens from each shield\\n     * while the DAO analyzes losses. If a withdrawal occurs while reserved > 0,\\n     * the user will lose this percent of tokens.\\n     * @param _newReservedRoot Percent of shields to temporarily pause for each shield. 1000 == 10%.\\n     */\\n    function setPercentReserved(bytes32 _newReservedRoot) external onlyGuardian {\\n        reservedRoot = _newReservedRoot;\\n        systemUpdates.reservedUpdate = uint32(block.timestamp);\\n    }\\n\\n    /**\\n     * @notice Admin can set which router is verified and which is not.\\n     * @param _routerAddress Address of a router.\\n     * @param _verified New verified status of the router.\\n     */\\n    function setRouterVerified(address _routerAddress, bool _verified) external onlyGuardian {\\n        isRouterVerified[_routerAddress] = _verified;\\n    }\\n\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////// onlyPriceOracle //////////////////////////////////////////////\\n    /////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n\\n    /**\\n     * @notice Set prices of all tokens with our oracle. This will likely be expanded so that price oracle is a\\n     * smart contract that accepts input from a few sources to increase decentralization.\\n     * @param _newPriceRoot Merkle root for new prices of each underlying token in\\n     * Ether (key is shield address or token for rewards).\\n     */\\n    function setPrices(bytes32 _newPriceRoot) external onlyPriceOracle {\\n        priceRoot = _newPriceRoot;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/general/RcaGovernable.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.11;\\nimport \\\"../general/Governable.sol\\\";\\n\\n/**\\n * @title Governable\\n * @dev Pretty default ownable but with variable names changed to better convey owner.\\n */\\ncontract RcaGovernable is Governable {\\n    address public guardian;\\n    address public priceOracle;\\n    address public capOracle;\\n\\n    event NewGuardian(address indexed oldGuardian, address indexed newGuardian);\\n    event NewPriceOracle(address indexed oldOracle, address indexed newOracle);\\n    event NewCapOracle(address indexed oldOracle, address indexed newOracle);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original s of the contract to the sender\\n     * account.\\n     */\\n    function initRcaGovernable(\\n        address _governor,\\n        address _guardian,\\n        address _capOracle,\\n        address _priceOracle\\n    ) internal {\\n        require(governor() == address(0), \\\"already initialized\\\");\\n        initializeGovernable(_governor);\\n\\n        guardian = _guardian;\\n        capOracle = _capOracle;\\n        priceOracle = _priceOracle;\\n\\n        emit NewGuardian(address(0), _guardian);\\n        emit NewCapOracle(address(0), _capOracle);\\n        emit NewPriceOracle(address(0), _priceOracle);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyGuardian() {\\n        require(msg.sender == guardian, \\\"msg.sender is not Guardian.\\\");\\n        _;\\n    }\\n\\n    modifier onlyPriceOracle() {\\n        require(msg.sender == priceOracle, \\\"msg.sender is not price oracle.\\\");\\n        _;\\n    }\\n\\n    modifier onlyCapOracle() {\\n        require(msg.sender == capOracle, \\\"msg.sender is not capacity oracle.\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param _newGuardian The address to transfer ownership to.\\n     */\\n    function setGuardian(address _newGuardian) public onlyGov {\\n        guardian = _newGuardian;\\n    }\\n\\n    function setPriceOracle(address _newPriceOracle) public onlyGov {\\n        priceOracle = _newPriceOracle;\\n    }\\n\\n    function setCapOracle(address _newCapOracle) public onlyGov {\\n        capOracle = _newCapOracle;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/library/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.11;\\n\\n/**\\n * @dev These functions deal with verification of Merkle trees (hash trees),\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        bytes32 computedHash = leaf;\\n\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n\\n        // Check if the computed hash (root) is equal to the provided root\\n        return computedHash == root;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRcaShield.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.11;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRcaShield {\\n    function setApr(uint256 apr) external;\\n\\n    function setTreasury(address treasury) external;\\n\\n    function setDiscount(uint256 discount) external;\\n\\n    function setLiqForClaims(uint256 addForSale) external;\\n\\n    function setPercentReserved(uint256 percentPaused) external;\\n\\n    function setWithdrawalDelay(uint256 withdrawalDelay) external;\\n\\n    function initialize(\\n        uint256 apr,\\n        uint256 discount,\\n        address treasury,\\n        uint256 withdrawalDelay\\n    ) external;\\n\\n    function name() external returns (string calldata);\\n\\n    function symbol() external returns (string calldata);\\n\\n    function uToken() external returns (IERC20);\\n\\n    function controllerUpdate(uint256 apr, uint256 aprUpdate) external;\\n\\n    struct WithdrawRequest {\\n        uint112 uAmount;\\n        uint112 rcaAmount;\\n        uint32 endTime;\\n    }\\n\\n    function withdrawRequests(address user) external view returns (WithdrawRequest memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/general/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/**\\n * @title Governable\\n * @dev Pretty default ownable but with variable names changed to better convey owner.\\n */\\ncontract Governable {\\n    address payable private _governor;\\n    address payable private _pendingGovernor;\\n\\n    event OwnershipTransferred(address indexed previousGovernor, address indexed newGovernor);\\n    event PendingOwnershipTransfer(address indexed from, address indexed to);\\n\\n    /**\\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\\n     * account.\\n     */\\n    function initializeGovernable(address _newGovernor) internal {\\n        require(_governor == address(0), \\\"already initialized\\\");\\n        _governor = payable(_newGovernor);\\n        emit OwnershipTransferred(address(0), _newGovernor);\\n    }\\n\\n    /**\\n     * @return the address of the owner.\\n     */\\n    function governor() public view returns (address payable) {\\n        return _governor;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyGov() {\\n        require(isGov(), \\\"msg.sender is not owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isGov() public view returns (bool) {\\n        return msg.sender == _governor;\\n    }\\n\\n    /**\\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\\n     * @param newGovernor The address to transfer ownership to.\\n     */\\n    function transferOwnership(address payable newGovernor) public onlyGov {\\n        _pendingGovernor = newGovernor;\\n        emit PendingOwnershipTransfer(_governor, newGovernor);\\n    }\\n\\n    function receiveOwnership() public {\\n        require(msg.sender == _pendingGovernor, \\\"Only pending governor can call this function\\\");\\n        _transferOwnership(_pendingGovernor);\\n        _pendingGovernor = payable(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newOwner.\\n     * @param newGovernor The address to transfer ownership to.\\n     */\\n    function _transferOwnership(address payable newGovernor) internal {\\n        require(newGovernor != address(0));\\n        emit OwnershipTransferred(_governor, newGovernor);\\n        _governor = newGovernor;\\n    }\\n\\n    uint256[50] private __gap;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_priceOracle\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_capOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_apr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawalDelay\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"_treasury\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"NewCapOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldGuardian\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGuardian\",\"type\":\"address\"}],\"name\":\"NewGuardian\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOracle\",\"type\":\"address\"}],\"name\":\"NewPriceOracle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousGovernor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"PendingOwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RedeemFinalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"RedeemRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"}],\"name\":\"ShieldCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rcaShield\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"underlyingToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"ShieldCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activeShields\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"apr\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"}],\"name\":\"balanceOfs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_shields\",\"type\":\"address[]\"}],\"name\":\"cancelShield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"discount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAprUpdate\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"getMessageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"}],\"name\":\"initializeShield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGov\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isRouterVerified\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastShieldUpdate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liqForClaimsRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_uAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"_v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_newCumLiqForClaims\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_liqForClaimsProof\",\"type\":\"bytes32[]\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ethPrice\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_priceProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_newCumLiqForClaims\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_liqForClaimsProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"receiveOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newCumLiqForClaims\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_liqForClaimsProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_newPercentReserved\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_percentReservedProof\",\"type\":\"bytes32[]\"}],\"name\":\"redeemFinalize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newCumLiqForClaims\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_liqForClaimsProof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"_newPercentReserved\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_percentReservedProof\",\"type\":\"bytes32[]\"}],\"name\":\"redeemRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_shields\",\"type\":\"address[]\"}],\"name\":\"requestOfs\",\"outputs\":[{\"components\":[{\"internalType\":\"uint112\",\"name\":\"uAmount\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"rcaAmount\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"}],\"internalType\":\"struct IRcaShield.WithdrawRequest[]\",\"name\":\"requests\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservedRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newApr\",\"type\":\"uint256\"}],\"name\":\"setApr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCapOracle\",\"type\":\"address\"}],\"name\":\"setCapOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDiscount\",\"type\":\"uint256\"}],\"name\":\"setDiscount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newGuardian\",\"type\":\"address\"}],\"name\":\"setGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newLiqRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_newReservedRoot\",\"type\":\"bytes32\"}],\"name\":\"setLiqTotal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newReservedRoot\",\"type\":\"bytes32\"}],\"name\":\"setPercentReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPriceOracle\",\"type\":\"address\"}],\"name\":\"setPriceOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_newPriceRoot\",\"type\":\"bytes32\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_routerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_verified\",\"type\":\"bool\"}],\"name\":\"setRouterVerified\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_newTreasury\",\"type\":\"address\"}],\"name\":\"setTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newWithdrawalDelay\",\"type\":\"uint256\"}],\"name\":\"setWithdrawalDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shieldMapping\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"systemUpdates\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"liqUpdate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"reservedUpdate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"withdrawalDelayUpdate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"discountUpdate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"aprUpdate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"treasuryUpdate\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newGovernor\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_newCumLiqForClaims\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_liqForClaimsProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyLiq\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyPrice\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_shield\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentReserved\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyReserved\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RcaController", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fa760444a229e78a50ca9b3779f4ce4cce10e1700000000000000000000000001f28ed9d4792a567dad779235c2b766ab84d8e33000000000000000000000000ea5edef12b0f19e7bf0360940e89cf34be19c091000000000000000000000000ea5edef15d1e28f92981ff4f60257747cd99a247000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ea5edef19ee4849b626cb23d62a5ae6364b58a37", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}