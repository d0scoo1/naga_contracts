{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n/*               .:  :.                                                  */\r\n/*             :--    :-:             _______  _        _______          */\r\n/*           -==-      :==-.         (  ____ \\( (    /|(  ____ \\         */\r\n/*         . ==:        .===:        | (    \\/|  \\  ( || (    \\/         */\r\n/*         +-..           -++        | (__    |   \\ | || (_____          */\r\n/*         ++=           ..-+        |  __)   | (\\ \\) |(_____  )         */\r\n/*         -*++.        :++ :        | (      | | \\   |      ) |         */\r\n/*          :+**:      =**=          | (____/\\| )  \\  |/\\____) |         */\r\n/*            .-+=   .+*-.           (_______/|/    )_)\\_______)         */\r\n/*               :-  =:                                                  */\r\n/*  )   ___                            _____                             */\r\n/* (__/_____)          /)       /) /) (, /   )            /)             */\r\n/*   /       _  _/_ _ (/   _   // //    /__ /  _  _   ___// _ _   _  __  */\r\n/*  /       (_(_(__(__/ )_(_(_(/_(/_ ) /   \\__(/_/_)_(_)(/_ (/___(/_/ (_ */\r\n/* (______)                         (_/                                  */\r\n/*                                                     by: royalfork.eth */\r\n/*                            0xca7c4a117baef1b7a122d55ede7216ba6631ac3e */\r\n\r\ninterface IDNSRecordResolver {\r\n    // DNSRecordChanged is emitted whenever a given node/name/resource's RRSET is updated.\r\n    event DNSRecordChanged(bytes32 indexed node, bytes name, uint16 resource, bytes record);\r\n    // DNSRecordDeleted is emitted whenever a given node/name/resource's RRSET is deleted.\r\n    event DNSRecordDeleted(bytes32 indexed node, bytes name, uint16 resource);\r\n    // DNSZoneCleared is emitted whenever a given node's zone information is cleared.\r\n    event DNSZoneCleared(bytes32 indexed node);\r\n\r\n    /**\r\n     * Obtain a DNS record.\r\n     * @param node the namehash of the node for which to fetch the record\r\n     * @param name the keccak-256 hash of the fully-qualified name for which to fetch the record\r\n     * @param resource the ID of the resource as per https://en.wikipedia.org/wiki/List_of_DNS_record_types\r\n     * @return the DNS record in wire format if present, otherwise empty\r\n     */\r\n    function dnsRecord(bytes32 node, bytes32 name, uint16 resource) external view returns (bytes memory);\r\n}\r\n\r\ninterface IInterfaceResolver {\r\n    event InterfaceChanged(bytes32 indexed node, bytes4 indexed interfaceID, address implementer);\r\n\r\n    /**\r\n     * Returns the address of a contract that implements the specified interface for this name.\r\n     * If an implementer has not been set for this interfaceID and name, the resolver will query\r\n     * the contract at `addr()`. If `addr()` is set, a contract exists at that address, and that\r\n     * contract implements EIP165 and returns `true` for the specified interfaceID, its address\r\n     * will be returned.\r\n     * @param node The ENS node to query.\r\n     * @param interfaceID The EIP 165 interface ID to check for.\r\n     * @return The address that implements this interface, or 0 if the interface is unsupported.\r\n     */\r\n    function interfaceImplementer(bytes32 node, bytes4 interfaceID) external view returns (address);\r\n}\r\n\r\ninterface INameResolver {\r\n    event NameChanged(bytes32 indexed node, string name);\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) external view returns (string memory);\r\n}\r\n\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IContentHashResolver {\r\n    event ContenthashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    /**\r\n     * Returns the contenthash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function contenthash(bytes32 node) external view returns (bytes memory);\r\n}\r\n\r\ninterface IExtendedResolver {\r\n    function resolve(bytes memory name, bytes memory data) external view returns(bytes memory);\r\n}\r\ninterface IAddressResolver {\r\n    event AddressChanged(bytes32 indexed node, uint coinType, bytes newAddress);\r\n\r\n    function addr(bytes32 node, uint coinType) external view returns(bytes memory);\r\n}\r\n\r\ninterface IABIResolver {\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) external view returns (uint256, bytes memory);\r\n}\r\n\r\ninterface IAddrResolver {\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) external view returns (address payable);\r\n}\r\n\r\ninterface IPubkeyResolver {\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x The X coordinate of the curve point for the public key.\r\n     * @return y The Y coordinate of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) external view returns (bytes32 x, bytes32 y);\r\n}\r\n\r\ninterface ENS {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n    // Logged when an operator is added or removed.\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    function setRecord(\r\n        bytes32 node,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeRecord(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner,\r\n        address resolver,\r\n        uint64 ttl\r\n    ) external;\r\n\r\n    function setSubnodeOwner(\r\n        bytes32 node,\r\n        bytes32 label,\r\n        address owner\r\n    ) external returns (bytes32);\r\n\r\n    function setResolver(bytes32 node, address resolver) external;\r\n\r\n    function setOwner(bytes32 node, address owner) external;\r\n\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    function owner(bytes32 node) external view returns (address);\r\n\r\n    function resolver(bytes32 node) external view returns (address);\r\n\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n\r\n    function recordExists(bytes32 node) external view returns (bool);\r\n\r\n    function isApprovedForAll(address owner, address operator)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\ninterface ITextResolver {\r\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string calldata key) external view returns (string memory);\r\n}\r\n\r\ninterface IDNSZoneResolver {\r\n    // DNSZonehashChanged is emitted whenever a given node's zone hash is updated.\r\n    event DNSZonehashChanged(bytes32 indexed node, bytes lastzonehash, bytes zonehash);\r\n\r\n    /**\r\n     * zonehash obtains the hash for the zone.\r\n     * @param node The ENS node to query.\r\n     * @return The associated contenthash.\r\n     */\r\n    function zonehash(bytes32 node) external view returns (bytes memory);\r\n}\r\n\r\ninterface Resolver is\r\n    IERC165,\r\n    IABIResolver,\r\n    IAddressResolver,\r\n    IAddrResolver,\r\n    IContentHashResolver,\r\n    IDNSRecordResolver,\r\n    IDNSZoneResolver,\r\n    IInterfaceResolver,\r\n    INameResolver,\r\n    IPubkeyResolver,\r\n    ITextResolver {}\r\n\r\n/**\r\n * @title Catch-all ENSIP-10 resolver.\r\n * @author royalfork.eth\r\n * @notice ENS resolver which proxies all resolver functions for any\r\n *         subdomain of a node to a set resolver.\r\n */\r\ncontract CatchallResolver is IExtendedResolver, Resolver {\r\n    ENS public immutable registry;\r\n\r\n    mapping(bytes32=>Resolver) resolvers;\r\n\r\n    event NewCatchallResolver(bytes32 indexed node, address resolver);\r\n\r\n    constructor(address _registry) {\r\n        registry = ENS(_registry);\r\n    }\r\n\r\n    /**\r\n     * @notice Set catchall resolver for node.  Node and all of its\r\n     *         subdomains will use this resolver.  Message sender must\r\n     *         be owner or operator for node.\r\n     * @param _node Catchall resolver will be set for this node.\r\n     * @param _resolver Catchall reoslver proxies all resolver\r\n     *        functions to this address.\r\n\t */\r\n\tfunction setResolver(bytes32 _node, Resolver _resolver) public {\r\n        address owner = registry.owner(_node);\r\n        require(owner == msg.sender || registry.isApprovedForAll(owner, msg.sender));\r\n\t\tresolvers[_node] = _resolver;\r\n\t\temit NewCatchallResolver(_node, address(_resolver));\r\n\t}\r\n\r\n    /**\r\n\t * @notice ENSIP-10 defined wildcard resolution function.\r\n     * @dev Resolve only works with resolver functions where the first\r\n     *      argument is a bytes32 node (as of ENSIP-12, all resolver\r\n     *      functions meet this criteria).\r\n\t * @param _name DNS-encoded name to be resolved.\r\n\t * @param _data ABI-encoded calldata for a resolver function.\r\n\t * @return output ABI-encoded return output from function encoded\r\n\t *         by _data.\r\n\t */\r\n    function resolve(bytes calldata _name, bytes memory _data) external override view returns(bytes memory) {\r\n\t\t(address r,,bytes32 node,) = resolver(_name, 0);\r\n\r\n\t\t// Replace node argument in data with parentNode\r\n\t\tfor (uint8 i = 0; i < 32; i++) {\r\n\t\t\t_data[i+4] = node[i];\r\n\t\t}\r\n\r\n\t\t(bool ok, bytes memory out) = r.staticcall(_data);\r\n\t\tif (!ok) {\r\n\t\t\trevert(\"invalid call\");\r\n\t\t}\r\n\t\treturn out;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns ENSIP-10 resolver for name.\r\n     * @param _name The name to resolve, in normalised and DNS-encoded form (eg: sub.example.eth)\r\n     * @return resolverAddr Found resolver for name.\r\n\t * @return resolverOwner DNS-encoded name which set the resolver (eg: example.eth).\r\n\t */\r\n\tfunction resolver(bytes calldata _name) public view returns(address, bytes memory) {\r\n\t\t(address r,uint256 o,,) = resolver(_name, 0);\r\n\t\treturn (r, _name[o:]);\r\n\t}\r\n\r\n    function supportsInterface(bytes4 interfaceID) public pure override returns(bool) {\r\n        return interfaceID == type(IExtendedResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IERC165).interfaceId ||\r\n\t\t\tinterfaceID == type(IABIResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IAddressResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IAddrResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IContentHashResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IDNSRecordResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IDNSZoneResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IInterfaceResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(INameResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(IPubkeyResolver).interfaceId ||\r\n\t\t\tinterfaceID == type(ITextResolver).interfaceId;\r\n    }\r\n\r\n\tfunction ABI(bytes32 node, uint256 contentTypes) external override view returns (uint256, bytes memory) {\r\n\t\treturn resolvers[node].ABI(node, contentTypes);\r\n\t}\r\n\tfunction addr(bytes32 node) external override view returns (address payable) {\r\n\t\treturn resolvers[node].addr(node);\r\n\t}\r\n\tfunction addr(bytes32 node, uint coinType) external override view returns(bytes memory) {\r\n\t\treturn resolvers[node].addr(node, coinType);\r\n\t}\r\n\tfunction contenthash(bytes32 node) external override view returns (bytes memory) {\r\n\t\treturn resolvers[node].contenthash(node);\r\n\t}\r\n\tfunction dnsRecord(bytes32 node, bytes32 _name, uint16 resource) external override view returns (bytes memory) {\r\n\t\treturn resolvers[node].dnsRecord(node, _name, resource);\r\n\t}\r\n\tfunction interfaceImplementer(bytes32 node, bytes4 interfaceID) external override view returns (address) {\r\n\t\treturn resolvers[node].interfaceImplementer(node, interfaceID);\r\n\t}\r\n\tfunction name(bytes32 node) external override view returns (string memory) {\r\n\t\treturn resolvers[node].name(node);\r\n\t}\r\n\tfunction pubkey(bytes32 node) external override view returns (bytes32 x, bytes32 y) {\r\n\t\treturn resolvers[node].pubkey(node);\r\n\t}\r\n\tfunction text(bytes32 node, string calldata key) external override view returns (string memory) {\r\n\t\treturn resolvers[node].text(node, key);\r\n\t}\r\n\tfunction zonehash(bytes32 node) external override view returns (bytes memory) {\r\n\t\treturn resolvers[node].zonehash(node);\r\n\t}\r\n\r\n    /**\r\n     * @dev Performs recursive ENSIP-10 lookup for a catchall resolver.\r\n     * @param _name The name to resolve, in normalised and DNS-encoded\r\n     *        form (eg: sub.example.eth)\r\n     * @param _offset The offset within name on which a catchall\r\n     *        resolver lookup is performed.\r\n     * @return resolverAddr Found resolver for name.\r\n     * @return resolverNameOffset Domain at this offset within name\r\n     *         which set resolverAddr (eg: offset of example.eth).\r\n     * @return resolverNode Namehash of name[resolverNameOffset:].\r\n     * @return node Namehash of name.\r\n     */\r\n    function resolver(bytes calldata _name, uint256 _offset) internal view returns(address, uint256, bytes32, bytes32) {\r\n        uint256 labelLength = uint256(uint8(_name[_offset]));\r\n        if(labelLength == 0) {\r\n            return (address(0), _name.length, bytes32(0), bytes32(0));\r\n        }\r\n        uint256 nextLabel = _offset + labelLength + 1;\r\n        bytes32 labelHash = keccak256(_name[_offset + 1: nextLabel]);\r\n        (address r, uint256 roffset, bytes32 rnode, bytes32 parentnode) = resolver(_name, nextLabel);\r\n        bytes32 node = keccak256(abi.encodePacked(parentnode, labelHash));\r\n        address newr = address(resolvers[node]);\r\n        if(newr != address(0)) {\r\n            return (newr, _offset, node, node);\r\n        }\r\n        return (r, roffset, rnode, node);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"contentType\",\"type\":\"uint256\"}],\"name\":\"ABIChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"AddrChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"newAddress\",\"type\":\"bytes\"}],\"name\":\"AddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"ContenthashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"record\",\"type\":\"bytes\"}],\"name\":\"DNSRecordChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"DNSRecordDeleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"DNSZoneCleared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"lastzonehash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"zonehash\",\"type\":\"bytes\"}],\"name\":\"DNSZonehashChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"implementer\",\"type\":\"address\"}],\"name\":\"InterfaceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"NewCatchallResolver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"name\":\"PubkeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"indexedKey\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"TextChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"contentTypes\",\"type\":\"uint256\"}],\"name\":\"ABI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"}],\"name\":\"addr\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"contenthash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_name\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"resource\",\"type\":\"uint16\"}],\"name\":\"dnsRecord\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"interfaceImplementer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"pubkey\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"x\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"y\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract ENS\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_name\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"resolve\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_name\",\"type\":\"bytes\"}],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_node\",\"type\":\"bytes32\"},{\"internalType\":\"contract Resolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"key\",\"type\":\"string\"}],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"node\",\"type\":\"bytes32\"}],\"name\":\"zonehash\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CatchallResolver", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000c2e074ec69a0dfb2997ba6c7d2e1e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f49534634f1f5484abde17b68367cd7c8557749ea1a0906a7364c67a0378b4fe"}]}