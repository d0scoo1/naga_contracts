{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/settings/AuthoritySettingValidatorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../settings/SettingRulesConfigurable.sol\\\";\\nimport \\\"../settings/SettingsV1.sol\\\";\\n\\n// Oracle settings\\n//\\n// Pluggable contract which implements setting changes and can be evolved to new contracts\\n//\\ncontract AuthoritySettingValidatorV1 is Ownable, SettingRulesConfigurable {\\n  // Constructor stub\\n\\n  // -- don't accept raw ether\\n  receive() external payable {\\n    revert('unsupported');\\n  }\\n\\n  // -- reject any other function\\n  fallback() external payable {\\n    revert('unsupported');\\n  }\\n}\\n\"\r\n    },\r\n    \"./contracts/settings/SettingRulesConfigurable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./SettingsV1.sol\\\";\\nimport \\\"./SettingValidatorV1.sol\\\";\\n\\nstruct SettingRule {\\n  bool isFrozen;\\n  uint64 lockedUntil;\\n}\\n\\n// Extends an ownable contract with functionality which allows configuring and freezing settings.\\nabstract contract SettingRulesConfigurable is Ownable, SettingValidatorV1 {\\n\\n  // Change rules on a certain setting to support secure go-live of the network.\\n  // The key here is the keccak256(abi.encode(...setting.path)), iterated by the path levels, which allows locking granular settings or specific subsettings\\n  mapping(bytes32 => SettingRule) internal rules;\\n\\n  event PathRuleSet(bytes32 indexed path0, bytes32 indexed pathIdx, bytes32[] path, SettingRule rule);\\n\\n  // ExternalData interface used by authority\\n  function isValidUnlockedSetting(bytes32[] calldata path, uint64, bytes calldata) external view override isPathUnlocked_(path) returns (bool) {\\n    return true;\\n  }\\n\\n  // -- GETTERS\\n\\n  function getRule(bytes32[] calldata path) external view returns (SettingRule memory) {\\n    return rules[hashPath(path)];\\n  }\\n\\n  // TODO future versions should check paths breadth-first. Since we don't need this yet and only require the structure, this is not yet implemented.\\n  function isPathUnlocked(bytes32[] calldata path) public view returns (bool) {\\n    bytes32 pathHash = hashPath(path);\\n    return rules[pathHash].isFrozen == false && rules[pathHash].lockedUntil < block.timestamp;\\n  }\\n  // -- SETTERS\\n\\n  // Set irriversible rules on the abi-encoded values\\n  function setPathRule(bytes32[] calldata path, SettingRule calldata rule) external onlyOwner isPathUnlocked_(path) {\\n    require(path.length > 0, \\\"400\\\");\\n    bytes32 pathHash = hashPath(path);\\n    rules[pathHash] = rule;\\n    emit PathRuleSet(path[0], pathHash, path, rule);\\n  }\\n\\n  // -- MODIFIERS\\n\\n  // Check if a value (or it's rules) are unlocked for changes.\\n  modifier isPathUnlocked_(bytes32[] calldata path) {\\n    require(isPathUnlocked(path), \\\"403\\\");\\n    _;\\n  }\\n}\\n\\n// More ideas here are to extend this with some setting-filter which (can) restrict updates to the values, eg: frozen-forever, frozen-TIMEdelay, supermajority, delayed-doubleconfirmation, ... we should watch out for complexity and impact to security models when looking into this.\"\r\n    },\r\n    \"./contracts/settings/SettingsV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\nfunction settingToPath(bytes32 setting) pure returns (bytes32[] memory) {\\n  bytes32[] memory path = new bytes32[](1);\\n  path[0] = setting;\\n  return path;\\n}\\n\\nfunction hashPath(bytes32[] memory path) pure returns (bytes32) {\\n  return keccak256(abi.encode(path));\\n}\\n\\nstruct Setting {\\n  // Setting path identifier, the key. Can also encode array values.\\n  // Eg: [b32str(\\\"hardFork\\\")]\\n  bytes32[] path;\\n\\n  // Pacemaker block time where the change activates in seconds.\\n  // Code activates on the first block.timestamp > releaseTime.\\n  uint64 releaseTime;\\n\\n  // Optional bbi-encoded bytes value. Can contain any structure.\\n  // Value encoding should be supported by the runtime at that future block height.\\n  // Eg: codebase url hints\\n  bytes value;\\n}\"\r\n    },\r\n    \"./contracts/settings/SettingValidatorV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity ^0.8.14;\\n\\ninterface SettingValidatorV1 {\\n  function isValidUnlockedSetting(bytes32[] calldata path, uint64 releaseTime, bytes calldata value) external view returns (bool);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"path0\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"pathIdx\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"indexed\":false,\"internalType\":\"struct SettingRule\",\"name\":\"rule\",\"type\":\"tuple\"}],\"name\":\"PathRuleSet\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"}],\"name\":\"getRule\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"internalType\":\"struct SettingRule\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"}],\"name\":\"isPathUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"isValidUnlockedSetting\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"path\",\"type\":\"bytes32[]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isFrozen\",\"type\":\"bool\"},{\"internalType\":\"uint64\",\"name\":\"lockedUntil\",\"type\":\"uint64\"}],\"internalType\":\"struct SettingRule\",\"name\":\"rule\",\"type\":\"tuple\"}],\"name\":\"setPathRule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "AuthoritySettingValidatorV1", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8152587583e9147490d9d6b24dc902a19a488afffd4228b61848509f259ea9c5"}]}