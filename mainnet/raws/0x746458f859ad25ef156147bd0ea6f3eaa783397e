{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Address\\n *\\n * @dev Utility library of inline functions on addresses.\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns whether the target address is a contract.\\n     * This function will return false if invoked during the constructor of a contract, as the code is not actually\\n     * created until after the constructor finishes.\\n     *\\n     * @param account The address of the account to check\\n     * @return True if the target address is a contract, otherwise false\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        // XXX Currently there is no better way to check if there is a contract in an address\\n        // than to check the size of the code at that address.\\n        // See https://ethereum.stackexchange.com/a/14016/36603\\n        // for more details about how this works.\\n        // TODO Check this again before the Serenity release, because all addresses will be\\n        // contracts then.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size \\u003e 0;\\n    }\\n}\\n\"},\"AdminUpgradability.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\u0027./UpgradeabilityProxy.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title AdminUpgradeabilityProxy\\r\\n *\\r\\n * @dev This contract combines an upgradeability proxy with an authorization mechanism for administrative tasks.\\r\\n * All external functions in this contract must be guarded by the `ifAdmin` modifier.\\r\\n * See ethereum/solidity#3864 for a Solidity feature proposal that would enable this to be done automatically.\\r\\n */\\r\\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\\r\\n    /**\\r\\n     * @dev Event emitted whenever the administration has been transferred.\\r\\n     *\\r\\n     * @param previousAdmin Address of the previous admin.\\r\\n     * @param newAdmin Address of the new admin.\\r\\n     *\\r\\n     */\\r\\n    event AdminChanged(address previousAdmin, address newAdmin);\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the admin of the contract.\\r\\n     * This is the keccak-256 hash of \\\"speedProp0219.proxy.admin\\\", and is validated in the constructor.\\r\\n     */\\r\\n    bytes32 private constant ADMIN_SLOT = 0xd29566bddab1b256049d4ade5efd84fd3ca810d31727b94b00dbee61e1671a81;\\r\\n    /**\\r\\n     * @dev Modifier to check whether the `msg.sender` is the admin.\\r\\n     * If it is, it will run the function. Otherwise, it will delegate the call to the implementation.\\r\\n     */\\r\\n    modifier ifAdmin() {\\r\\n        if (msg.sender == _admin()) {\\r\\n            _;\\r\\n        } else {\\r\\n            _fallback();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Contract constructor.\\r\\n     * @dev It sets the `msg.sender` as the proxy administrator.\\r\\n     *\\r\\n     * @param _implementation address of the initial implementation.\\r\\n     */\\r\\n    constructor(address _implementation) UpgradeabilityProxy(_implementation) public {\\r\\n        assert(ADMIN_SLOT == keccak256(\\\"speedProp0219.proxy.admin\\\"));\\r\\n\\r\\n        _setAdmin(msg.sender);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The address of the proxy admin.\\r\\n     */\\r\\n    function admin() external view ifAdmin returns (address) {\\r\\n        return _admin();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The address of the implementation.\\r\\n     */\\r\\n    function implementation() external view ifAdmin returns (address) {\\r\\n        return _implementation();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the admin of the proxy.\\r\\n     * Only the current admin can call this function.\\r\\n     *\\r\\n     * @param newAdmin Address to transfer proxy administration to.\\r\\n     */\\r\\n    function changeAdmin(address newAdmin) external ifAdmin {\\r\\n        require(newAdmin != address(0), \\\"Cannot change the admin of a proxy to the zero address\\\");\\r\\n        emit AdminChanged(_admin(), newAdmin);\\r\\n        _setAdmin(newAdmin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrade the backing implementation of the proxy.\\r\\n     * Only the admin can call this function.\\r\\n     *\\r\\n     * @param newImplementation Address of the new implementation.\\r\\n     */\\r\\n    function upgradeTo(address newImplementation) external ifAdmin {\\r\\n        _upgradeTo(newImplementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrade the backing implementation of the proxy and call a function on the new implementation.\\r\\n     * This is useful to initialize the proxied contract.\\r\\n     *\\r\\n     * The given `data` should include the signature and parameters of the function to be called.\\r\\n     * See https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding\\r\\n     *\\r\\n     * @param newImplementation Address of the new implementation.\\r\\n     * @param data Data to send as msg.data in the low level call.\\r\\n     */\\r\\n    function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\\r\\n        _upgradeTo(newImplementation);\\r\\n        require(address(this).call.value(msg.value)(data));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @return The admin slot.\\r\\n     */\\r\\n    function _admin() internal view returns (address adm) {\\r\\n        bytes32 slot = ADMIN_SLOT;\\r\\n        assembly {\\r\\n            adm := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the address of the proxy admin.\\r\\n     *\\r\\n     * @param newAdmin Address of the new proxy admin.\\r\\n     */\\r\\n    function _setAdmin(address newAdmin) internal {\\r\\n        bytes32 slot = ADMIN_SLOT;\\r\\n\\r\\n        assembly {\\r\\n            sstore(slot, newAdmin)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Only fall back when the sender is not the admin.\\r\\n     */\\r\\n    function _willFallback() internal {\\r\\n        require(msg.sender != _admin(), \\\"Cannot call fallback function from the proxy admin\\\");\\r\\n        super._willFallback();\\r\\n    }\\r\\n}\"},\"Proxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title Proxy\\n *\\n * @dev Implements delegation of calls to other contracts, with proper forwarding of return values and bubbling of\\n * failures.\\n * It defines a fallback function that delegates all calls to the address returned by the abstract `_implementation()`\\n * internal function.\\n */\\ncontract Proxy {\\n    /**\\n     * @dev Fallback function.\\n     * Implemented entirely in `_fallback`.\\n     */\\n    function () payable external {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @return The Address of the implementation.\\n     */\\n    function _implementation() internal view returns (address);\\n\\n    /**\\n     * @dev Delegates execution to an implementation contract.\\n     * This is a low level function that doesn\\u0027t return to its internal call site.\\n     * It will return to the external caller whatever the implementation returns.\\n     *\\n     * @param implementation Address to delegate.\\n     */\\n    function _delegate(address implementation) internal {\\n        assembly {\\n            // Copy msg.data.\\n            // We take full control of memory in this inline assembly block because it will not return to Solidity code.\\n            // We overwrite the Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize)\\n\\n            // Call the implementation.\\n            // The out and outsize are 0 because we don\\u0027t know the size yet.\\n            let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize)\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 { revert(0, returndatasize) }\\n            default { return(0, returndatasize) }\\n        }\\n    }\\n\\n    /**\\n     * @dev Function that is run as the first thing in the fallback function.\\n     * Can be redefined in derived contracts to add functionality.\\n     * Redefinitions must call super._willFallback().\\n     */\\n    function _willFallback() internal {\\n    }\\n\\n    /**\\n     * @dev fallback implementation.\\n     * Extracted to enable manual triggering.\\n     */\\n    function _fallback() internal {\\n        _willFallback();\\n        _delegate(_implementation());\\n    }\\n}\"},\"UpgradeabilityProxy.sol\":{\"content\":\"pragma solidity ^0.4.24;\\r\\n\\r\\nimport \\u0027./Proxy.sol\\u0027;\\r\\nimport \\u0027./Address.sol\\u0027;\\r\\n\\r\\n/**\\r\\n * @title UpgradeabilityProxy\\r\\n *\\r\\n * @dev This contract implements a proxy that allows to change the implementation address to which it will delegate.\\r\\n * Such a change is called an implementation upgrade.\\r\\n */\\r\\ncontract UpgradeabilityProxy is Proxy {\\r\\n    /**\\r\\n     * @dev Emitted when the implementation is upgraded.\\r\\n     *\\r\\n     * @param implementation Address of the new implementation.\\r\\n     */\\r\\n    event Upgraded(address implementation);\\r\\n\\r\\n    /**\\r\\n     * @dev Storage slot with the address of the current implementation.\\r\\n     * This is the keccak-256 hash of \\\"speedProp0219.proxy.implementation\\\", and is validated in the constructor.\\r\\n     */\\r\\n    bytes32 private constant IMPLEMENTATION_SLOT = 0x5530fbdf83b670a621816422a0f4c3fef19d6b90c96762ba0f4c86a4d0e8b1bc;\\r\\n\\r\\n    /**\\r\\n     * @dev Contract constructor.\\r\\n     *\\r\\n     * @param _implementation Address of the initial implementation.\\r\\n     */\\r\\n    constructor(address _implementation) public {\\r\\n        assert(IMPLEMENTATION_SLOT == keccak256(\\\"speedProp0219.proxy.implementation\\\"));\\r\\n\\r\\n        _setImplementation(_implementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the current implementation.\\r\\n     *\\r\\n     * @return Address of the current implementation\\r\\n     */\\r\\n    function _implementation() internal view returns (address impl) {\\r\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n        assembly {\\r\\n            impl := sload(slot)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Upgrades the proxy to a new implementation.\\r\\n     *\\r\\n     * @param newImplementation Address of the new implementation.\\r\\n     */\\r\\n    function _upgradeTo(address newImplementation) internal {\\r\\n        _setImplementation(newImplementation);\\r\\n        emit Upgraded(newImplementation);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets the implementation address of the proxy.\\r\\n     *\\r\\n     * @param newImplementation Address of the new implementation.\\r\\n     */\\r\\n    function _setImplementation(address newImplementation) private {\\r\\n        require(Address.isContract(newImplementation), \\\"Cannot set a proxy implementation to a non-contract address\\\");\\r\\n\\r\\n        bytes32 slot = IMPLEMENTATION_SLOT;\\r\\n\\r\\n        assembly {\\r\\n            sstore(slot, newImplementation)\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newImplementation\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"}]", "ContractName": "AdminUpgradeabilityProxy", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000062777934bf544ac366b5a574940d99365448f9c9", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://8231d5e65388753869b7a8339cce506edb000bbc87e2e7fd808b90aa5b930438"}]}