{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @openzeppelin\\contracts\\utils\\introspection\\IERC165.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n// File: contracts\\model\\IERC1155Views.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n\r\n/**\r\n * @title IERC1155Views - An optional utility interface to improve the ERC-1155 Standard.\r\n * @dev This interface introduces some additional capabilities for ERC-1155 Tokens.\r\n */\r\ninterface IERC1155Views {\r\n\r\n    /**\r\n     * @dev Returns the total supply of the given token id\r\n     * @param itemId the id of the token whose availability you want to know \r\n     */\r\n    function totalSupply(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the name of the given token id\r\n     * @param itemId the id of the token whose name you want to know \r\n     */\r\n    function name(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the given token id\r\n     * @param itemId the id of the token whose symbol you want to know \r\n     */\r\n    function symbol(uint256 itemId) external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals of the given token id\r\n     * @param itemId the id of the token whose decimals you want to know \r\n     */\r\n    function decimals(uint256 itemId) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the uri of the given token id\r\n     * @param itemId the id of the token whose uri you want to know \r\n     */\r\n    function uri(uint256 itemId) external view returns (string memory);\r\n}\r\n\r\n// File: contracts\\model\\Item.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\npragma abicoder v2;\r\n\r\n\r\nstruct Header {\r\n    address host;\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n}\r\n\r\nstruct CreateItem {\r\n    Header header;\r\n    bytes32 collectionId;\r\n    uint256 id;\r\n    address[] accounts;\r\n    uint256[] amounts;\r\n}\r\n\r\ninterface Item is IERC1155, IERC1155Views {\r\n\r\n    event CollectionItem(bytes32 indexed fromCollectionId, bytes32 indexed toCollectionId, uint256 indexed itemId);\r\n\r\n    function name() external view returns(string memory);\r\n    function symbol() external view returns(string memory);\r\n    function decimals() external view returns(uint256);\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) external;\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes calldata data) external;\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) external;\r\n\r\n    function mintItems(CreateItem[] calldata items) external returns(uint256[] memory itemIds);\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) external returns(bytes32[] memory oldCollectionIds);\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata newValues) external returns(Header[] memory oldValues);\r\n\r\n    function interoperableOf(uint256 itemId) external view returns(address);\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\generic\\model\\ILazyInitCapableElement.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\ninterface ILazyInitCapableElement is IERC165 {\r\n\r\n    function lazyInit(bytes calldata lazyInitData) external returns(bytes memory initResponse);\r\n    function initializer() external view returns(address);\r\n\r\n    event Host(address indexed from, address indexed to);\r\n\r\n    function host() external view returns(address);\r\n    function setHost(address newValue) external returns(address oldValue);\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) external view returns(bool);\r\n}\r\n\r\n// File: contracts\\projection\\IItemProjection.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n//pragma abicoder v2;\r\n\r\n\r\ninterface IItemProjection is Item, ILazyInitCapableElement {\r\n\r\n    function mainInterface() external view returns(address);\r\n\r\n    function collectionId() external view returns(bytes32);\r\n    function uri() external view returns(string memory);\r\n    function plainUri() external view returns(string memory);\r\n    function itemPlainUri(uint256 itemId) external view returns(string memory);\r\n    function setHeader(Header calldata value) external returns(Header memory oldValue);\r\n\r\n    function toInteroperableInterfaceAmount(uint256 amount, uint256 itemId, address account) external view returns(uint256);\r\n    function toMainInterfaceAmount(uint256 amount, uint256 itemId) external view returns(uint256);\r\n}\r\n\r\n// File: contracts\\projection\\multiOperatorHost\\model\\IMultiOperatorHost.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n//pragma abicoder v2;\r\n\r\ninterface IMultiOperatorHost is IItemProjection {\r\n\r\n    event Operator(uint256 indexed op, address indexed from, address indexed to);\r\n\r\n    function operator(uint256 op) external view returns (address);\r\n\r\n    function setOperator(uint256 op, address newValue) external returns(address oldValue);\r\n}\r\n\r\n// File: contracts\\model\\IItemMainInterface.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\nstruct ItemData {\r\n    bytes32 collectionId;\r\n    Header header;\r\n    bytes32 domainSeparator;\r\n    uint256 totalSupply;\r\n    mapping(address => uint256) balanceOf;\r\n    mapping(address => mapping(address => uint256)) allowance;\r\n    mapping(address => uint256) nonces;\r\n}\r\n\r\ninterface IItemMainInterface is Item {\r\n\r\n    event Collection(address indexed from, address indexed to, bytes32 indexed collectionId);\r\n\r\n    function interoperableInterfaceModel() external view returns(address);\r\n\r\n    function uri() external view returns(string memory);\r\n    function plainUri() external view returns(string memory);\r\n    function dynamicUriResolver() external view returns(address);\r\n    function hostInitializer() external view returns(address);\r\n\r\n    function collection(bytes32 collectionId) external view returns(address host, string memory name, string memory symbol, string memory uri);\r\n    function collectionUri(bytes32 collectionId) external view returns(string memory);\r\n    function createCollection(Header calldata _collection, CreateItem[] calldata items) external returns(bytes32 collectionId, uint256[] memory itemIds);\r\n    function setCollectionsMetadata(bytes32[] calldata collectionIds, Header[] calldata values) external returns(Header[] memory oldValues);\r\n\r\n    function setApprovalForAllByCollectionHost(bytes32 collectionId, address account, address operator, bool approved) external;\r\n\r\n    function item(uint256 itemId) external view returns(bytes32 collectionId, Header memory header, bytes32 domainSeparator, uint256 totalSupply);\r\n\r\n    function mintTransferOrBurn(bool isMulti, bytes calldata data) external;\r\n\r\n    function allowance(address account, address spender, uint256 itemId) external view returns(uint256);\r\n    function approve(address account, address spender, uint256 amount, uint256 itemId) external;\r\n    function TYPEHASH_PERMIT() external view returns (bytes32);\r\n    function EIP712_PERMIT_DOMAINSEPARATOR_NAME_AND_VERSION() external view returns(string memory domainSeparatorName, string memory domainSeparatorVersion);\r\n    function permit(uint256 itemId, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function nonces(address owner, uint256 itemId) external view returns(uint256);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC1155\\IERC1155Receiver.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: @openzeppelin\\contracts\\token\\ERC20\\IERC20.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\lib\\GeneralUtilities.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\nlibrary BehaviorUtilities {\r\n\r\n    function randomKey(uint256 i) internal view returns (bytes32) {\r\n        return keccak256(abi.encode(i, block.timestamp, block.number, tx.origin, tx.gasprice, block.coinbase, block.difficulty, msg.sender, blockhash(block.number - 5)));\r\n    }\r\n\r\n    function calculateProjectedArraySizeAndLoopUpperBound(uint256 arraySize, uint256 start, uint256 offset) internal pure returns(uint256 projectedArraySize, uint256 projectedArrayLoopUpperBound) {\r\n        if(arraySize != 0 && start < arraySize && offset != 0) {\r\n            uint256 length = start + offset;\r\n            if(start < (length = length > arraySize ? arraySize : length)) {\r\n                projectedArraySize = (projectedArrayLoopUpperBound = length) - start;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary ReflectionUtilities {\r\n\r\n    function read(address subject, bytes memory inputData) internal view returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.staticcall(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function submit(address subject, uint256 value, bytes memory inputData) internal returns(bytes memory returnData) {\r\n        bool result;\r\n        (result, returnData) = subject.call{value : value}(inputData);\r\n        if(!result) {\r\n            assembly {\r\n                revert(add(returnData, 0x20), mload(returnData))\r\n            }\r\n        }\r\n    }\r\n\r\n    function isContract(address subject) internal view returns (bool) {\r\n        if(subject == address(0)) {\r\n            return false;\r\n        }\r\n        uint256 codeLength;\r\n        assembly {\r\n            codeLength := extcodesize(subject)\r\n        }\r\n        return codeLength > 0;\r\n    }\r\n\r\n    function clone(address originalContract) internal returns(address copyContract) {\r\n        assembly {\r\n            mstore(\r\n                0,\r\n                or(\r\n                    0x5880730000000000000000000000000000000000000000803b80938091923cF3,\r\n                    mul(originalContract, 0x1000000000000000000)\r\n                )\r\n            )\r\n            copyContract := create(0, 0, 32)\r\n            switch extcodesize(copyContract)\r\n                case 0 {\r\n                    invalid()\r\n                }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary BytesUtilities {\r\n\r\n    bytes private constant ALPHABET = \"0123456789abcdef\";\r\n    string internal constant BASE64_ENCODER_DATA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\n\r\n    function asAddress(bytes memory b) internal pure returns(address) {\r\n        if(b.length == 0) {\r\n            return address(0);\r\n        }\r\n        if(b.length == 20) {\r\n            address addr;\r\n            assembly {\r\n                addr := mload(add(b, 20))\r\n            }\r\n            return addr;\r\n        }\r\n        return abi.decode(b, (address));\r\n    }\r\n\r\n    function asAddressArray(bytes memory b) internal pure returns(address[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (address[]));\r\n        }\r\n    }\r\n\r\n    function asBool(bytes memory bs) internal pure returns(bool) {\r\n        return asUint256(bs) != 0;\r\n    }\r\n\r\n    function asBoolArray(bytes memory b) internal pure returns(bool[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bool[]));\r\n        }\r\n    }\r\n\r\n    function asBytesArray(bytes memory b) internal pure returns(bytes[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (bytes[]));\r\n        }\r\n    }\r\n\r\n    function asString(bytes memory b) internal pure returns(string memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string));\r\n        }\r\n    }\r\n\r\n    function asStringArray(bytes memory b) internal pure returns(string[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (string[]));\r\n        }\r\n    }\r\n\r\n    function asUint256(bytes memory bs) internal pure returns(uint256 x) {\r\n        if (bs.length >= 32) {\r\n            assembly {\r\n                x := mload(add(bs, add(0x20, 0)))\r\n            }\r\n        }\r\n    }\r\n\r\n    function asUint256Array(bytes memory b) internal pure returns(uint256[] memory callResult) {\r\n        if(b.length > 0) {\r\n            return abi.decode(b, (uint256[]));\r\n        }\r\n    }\r\n\r\n    function toString(bytes memory data) internal pure returns(string memory) {\r\n        bytes memory str = new bytes(2 + data.length * 2);\r\n        str[0] = \"0\";\r\n        str[1] = \"x\";\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            str[2+i*2] = ALPHABET[uint256(uint8(data[i] >> 4))];\r\n            str[3+i*2] = ALPHABET[uint256(uint8(data[i] & 0x0f))];\r\n        }\r\n        return string(str);\r\n    }\r\n\r\n    function asSingletonArray(bytes memory a) internal pure returns(bytes[] memory array) {\r\n        array = new bytes[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toBase64(bytes memory data) internal pure returns (string memory) {\r\n        if (data.length == 0) return '';\r\n\r\n        string memory table = BASE64_ENCODER_DATA;\r\n\r\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\r\n\r\n        string memory result = new string(encodedLen + 32);\r\n\r\n        assembly {\r\n            mstore(result, encodedLen)\r\n\r\n            let tablePtr := add(table, 1)\r\n\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n                dataPtr := add(dataPtr, 3)\r\n                let input := mload(dataPtr)\r\n\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\r\n                resultPtr := add(resultPtr, 1)\r\n            }\r\n\r\n            switch mod(mload(data), 3)\r\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\r\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\nlibrary StringUtilities {\r\n\r\n    bytes1 private constant CHAR_0 = bytes1('0');\r\n    bytes1 private constant CHAR_A = bytes1('A');\r\n    bytes1 private constant CHAR_a = bytes1('a');\r\n    bytes1 private constant CHAR_f = bytes1('f');\r\n\r\n    bytes  internal constant BASE64_DECODER_DATA = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\r\n                                                   hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\r\n                                                   hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\r\n                                                   hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\r\n\r\n    function isEmpty(string memory test) internal pure returns (bool) {\r\n        return equals(test, \"\");\r\n    }\r\n\r\n    function equals(string memory a, string memory b) internal pure returns(bool) {\r\n        return keccak256(abi.encodePacked(a)) == keccak256(abi.encodePacked(b));\r\n    }\r\n\r\n    function toLowerCase(string memory str) internal pure returns(string memory) {\r\n        bytes memory bStr = bytes(str);\r\n        for (uint256 i = 0; i < bStr.length; i++) {\r\n            bStr[i] = bStr[i] >= 0x41 && bStr[i] <= 0x5A ? bytes1(uint8(bStr[i]) + 0x20) : bStr[i];\r\n        }\r\n        return string(bStr);\r\n    }\r\n\r\n    function asBytes(string memory str) internal pure returns(bytes memory toDecode) {\r\n        bytes memory data = abi.encodePacked(str);\r\n        if(data.length == 0 || data[0] != \"0\" || (data[1] != \"x\" && data[1] != \"X\")) {\r\n            return \"\";\r\n        }\r\n        uint256 start = 2;\r\n        toDecode = new bytes((data.length - 2) / 2);\r\n\r\n        for(uint256 i = 0; i < toDecode.length; i++) {\r\n            toDecode[i] = bytes1(_fromHexChar(uint8(data[start++])) + _fromHexChar(uint8(data[start++])) * 16);\r\n        }\r\n    }\r\n\r\n    function toBase64(string memory input) internal pure returns(string memory) {\r\n        return BytesUtilities.toBase64(abi.encodePacked(input));\r\n    }\r\n\r\n    function fromBase64(string memory _data) internal pure returns (bytes memory) {\r\n        bytes memory data = bytes(_data);\r\n\r\n        if (data.length == 0) return new bytes(0);\r\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\r\n\r\n        bytes memory table = BASE64_DECODER_DATA;\r\n\r\n        uint256 decodedLen = (data.length / 4) * 3;\r\n\r\n        bytes memory result = new bytes(decodedLen + 32);\r\n\r\n        assembly {\r\n            let lastBytes := mload(add(data, mload(data)))\r\n            if eq(and(lastBytes, 0xFF), 0x3d) {\r\n                decodedLen := sub(decodedLen, 1)\r\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\r\n                    decodedLen := sub(decodedLen, 1)\r\n                }\r\n            }\r\n\r\n            mstore(result, decodedLen)\r\n\r\n            let tablePtr := add(table, 1)\r\n\r\n            let dataPtr := data\r\n            let endPtr := add(dataPtr, mload(data))\r\n\r\n            let resultPtr := add(result, 32)\r\n\r\n            for {} lt(dataPtr, endPtr) {}\r\n            {\r\n               dataPtr := add(dataPtr, 4)\r\n               let input := mload(dataPtr)\r\n\r\n               let output := add(\r\n                   add(\r\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\r\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\r\n                   add(\r\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\r\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\r\n                    )\r\n                )\r\n                mstore(resultPtr, shl(232, output))\r\n                resultPtr := add(resultPtr, 3)\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function _fromHexChar(uint8 c) private pure returns (uint8) {\r\n        bytes1 charc = bytes1(c);\r\n        return charc < CHAR_0 || charc > CHAR_f ? 0 : (charc < CHAR_A ? 0 : 10) + c - uint8(charc < CHAR_A ? CHAR_0 : charc < CHAR_a ? CHAR_A : CHAR_a);\r\n    }\r\n}\r\n\r\nlibrary Uint256Utilities {\r\n    function asSingletonArray(uint256 n) internal pure returns(uint256[] memory array) {\r\n        array = new uint256[](1);\r\n        array[0] = n;\r\n    }\r\n\r\n    function toHex(uint256 _i) internal pure returns (string memory) {\r\n        return BytesUtilities.toString(abi.encodePacked(_i));\r\n    }\r\n\r\n    function toString(uint256 _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 j = _i;\r\n        uint256 len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint256 k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function sum(uint256[] memory arr) internal pure returns (uint256 result) {\r\n        for(uint256 i = 0; i < arr.length; i++) {\r\n            result += arr[i];\r\n        }\r\n    }\r\n}\r\n\r\nlibrary AddressUtilities {\r\n    function asSingletonArray(address a) internal pure returns(address[] memory array) {\r\n        array = new address[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(address _addr) internal pure returns (string memory) {\r\n        return _addr == address(0) ? \"0x0000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(_addr));\r\n    }\r\n}\r\n\r\nlibrary Bytes32Utilities {\r\n\r\n    function asSingletonArray(bytes32 a) internal pure returns(bytes32[] memory array) {\r\n        array = new bytes32[](1);\r\n        array[0] = a;\r\n    }\r\n\r\n    function toString(bytes32 bt) internal pure returns (string memory) {\r\n        return bt == bytes32(0) ?  \"0x0000000000000000000000000000000000000000000000000000000000000000\" : BytesUtilities.toString(abi.encodePacked(bt));\r\n    }\r\n}\r\n\r\nlibrary TransferUtilities {\r\n    using ReflectionUtilities for address;\r\n\r\n    function balanceOf(address erc20TokenAddress, address account) internal view returns(uint256) {\r\n        if(erc20TokenAddress == address(0)) {\r\n            return account.balance;\r\n        }\r\n        return abi.decode(erc20TokenAddress.read(abi.encodeWithSelector(IERC20(erc20TokenAddress).balanceOf.selector, account)), (uint256));\r\n    }\r\n\r\n    function allowance(address erc20TokenAddress, address account, address spender) internal view returns(uint256) {\r\n        if(erc20TokenAddress == address(0)) {\r\n            return 0;\r\n        }\r\n        return abi.decode(erc20TokenAddress.read(abi.encodeWithSelector(IERC20(erc20TokenAddress).allowance.selector, account, spender)), (uint256));\r\n    }\r\n\r\n    function safeApprove(address erc20TokenAddress, address spender, uint256 value) internal {\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).approve.selector, spender, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address erc20TokenAddress, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(erc20TokenAddress == address(0)) {\r\n            to.submit(value, \"\");\r\n            return;\r\n        }\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).transfer.selector, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address erc20TokenAddress, address from, address to, uint256 value) internal {\r\n        if(value == 0) {\r\n            return;\r\n        }\r\n        if(erc20TokenAddress == address(0)) {\r\n            to.submit(value, \"\");\r\n            return;\r\n        }\r\n        bytes memory returnData = erc20TokenAddress.submit(0, abi.encodeWithSelector(IERC20(erc20TokenAddress).transferFrom.selector, from, to, value));\r\n        require(returnData.length == 0 || abi.decode(returnData, (bool)), 'TRANSFERFROM_FAILED');\r\n    }\r\n}\r\n\r\n// File: @ethereansos\\swissknife\\contracts\\generic\\impl\\LazyInitCapableElement.sol\r\n\r\n// SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\nabstract contract LazyInitCapableElement is ILazyInitCapableElement {\r\n    using ReflectionUtilities for address;\r\n\r\n    address public override initializer;\r\n    address public override host;\r\n\r\n    constructor(bytes memory lazyInitData) {\r\n        if(lazyInitData.length > 0) {\r\n            _privateLazyInit(lazyInitData);\r\n        }\r\n    }\r\n\r\n    function lazyInit(bytes calldata lazyInitData) override external returns (bytes memory lazyInitResponse) {\r\n        return _privateLazyInit(lazyInitData);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) override external view returns(bool) {\r\n        return\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == this.supportsInterface.selector ||\r\n            interfaceId == type(ILazyInitCapableElement).interfaceId ||\r\n            interfaceId == this.lazyInit.selector ||\r\n            interfaceId == this.initializer.selector ||\r\n            interfaceId == this.subjectIsAuthorizedFor.selector ||\r\n            interfaceId == this.host.selector ||\r\n            interfaceId == this.setHost.selector ||\r\n            _supportsInterface(interfaceId);\r\n    }\r\n\r\n    function setHost(address newValue) external override authorizedOnly returns(address oldValue) {\r\n        oldValue = host;\r\n        host = newValue;\r\n        emit Host(oldValue, newValue);\r\n    }\r\n\r\n    function subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata payload, uint256 value) public override virtual view returns(bool) {\r\n        (bool chidlElementValidationIsConsistent, bool chidlElementValidationResult) = _subjectIsAuthorizedFor(subject, location, selector, payload, value);\r\n        if(chidlElementValidationIsConsistent) {\r\n            return chidlElementValidationResult;\r\n        }\r\n        if(subject == host) {\r\n            return true;\r\n        }\r\n        if(!host.isContract()) {\r\n            return false;\r\n        }\r\n        (bool result, bytes memory resultData) = host.staticcall(abi.encodeWithSelector(ILazyInitCapableElement(host).subjectIsAuthorizedFor.selector, subject, location, selector, payload, value));\r\n        return result && abi.decode(resultData, (bool));\r\n    }\r\n\r\n    function _privateLazyInit(bytes memory lazyInitData) private returns (bytes memory lazyInitResponse) {\r\n        require(initializer == address(0), \"init\");\r\n        initializer = msg.sender;\r\n        (host, lazyInitResponse) = abi.decode(lazyInitData, (address, bytes));\r\n        emit Host(address(0), host);\r\n        lazyInitResponse = _lazyInit(lazyInitResponse);\r\n    }\r\n\r\n    function _lazyInit(bytes memory) internal virtual returns (bytes memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function _supportsInterface(bytes4 selector) internal virtual view returns (bool);\r\n\r\n    function _subjectIsAuthorizedFor(address, address, bytes4, bytes calldata, uint256) internal virtual view returns(bool, bool) {\r\n    }\r\n\r\n    modifier authorizedOnly {\r\n        require(_authorizedOnly(), \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function _authorizedOnly() internal returns(bool) {\r\n        return subjectIsAuthorizedFor(msg.sender, address(this), msg.sig, msg.data, msg.value);\r\n    }\r\n}\r\n\r\n// File: contracts\\util\\ERC1155CommonLibrary.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\npragma solidity >=0.7.0;\r\n\r\n\r\nlibrary ERC1155CommonLibrary {\r\n    using ReflectionUtilities for address;\r\n\r\n    function doSafeTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) internal {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155Received(\r\n                    operator,\r\n                    from,\r\n                    id,\r\n                    amount,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response != IERC1155Receiver(to).onERC1155Received.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function doSafeBatchTransferAcceptanceCheck(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) internal {\r\n        if (to.isContract()) {\r\n            try\r\n                IERC1155Receiver(to).onERC1155BatchReceived(\r\n                    operator,\r\n                    from,\r\n                    ids,\r\n                    amounts,\r\n                    data\r\n                )\r\n            returns (bytes4 response) {\r\n                if (\r\n                    response !=\r\n                    IERC1155Receiver(to).onERC1155BatchReceived.selector\r\n                ) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\projection\\ItemProjection.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n//pragma abicoder v2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nabstract contract ItemProjection is IItemProjection, LazyInitCapableElement {\r\n    using AddressUtilities for address;\r\n    using BytesUtilities for bytes;\r\n\r\n    address public override mainInterface;\r\n    bytes32 public override collectionId;\r\n\r\n    constructor(bytes memory lazyInitData) LazyInitCapableElement(lazyInitData) {\r\n    }\r\n\r\n    function _lazyInit(bytes memory lazyInitParams) override virtual internal returns(bytes memory lazyInitResponse) {\r\n        (mainInterface, lazyInitResponse) = abi.decode(lazyInitParams, (address, bytes));\r\n        Header memory header;\r\n        CreateItem[] memory items;\r\n        (collectionId, header, items, lazyInitResponse) = abi.decode(lazyInitResponse, (bytes32, Header, CreateItem[], bytes));\r\n        if(collectionId == bytes32(0)) {\r\n            header.host = address(this);\r\n            (collectionId,) = IItemMainInterface(mainInterface).createCollection(header, items);\r\n        } else if(items.length > 0) {\r\n            IItemMainInterface(mainInterface).mintItems(items);\r\n        }\r\n        lazyInitResponse = _projectionLazyInit(lazyInitResponse);\r\n    }\r\n\r\n    function _supportsInterface(bytes4 interfaceId) override internal pure returns (bool) {\r\n        return\r\n            interfaceId == type(IItemProjection).interfaceId ||\r\n            interfaceId == 0xeac989f8 ||//uri()\r\n            interfaceId == this.mainInterface.selector ||\r\n            interfaceId == this.collectionId.selector ||\r\n            interfaceId == this.plainUri.selector ||\r\n            interfaceId == this.itemPlainUri.selector ||\r\n            interfaceId == this.setHeader.selector ||\r\n            interfaceId == this.toInteroperableInterfaceAmount.selector ||\r\n            interfaceId == this.toMainInterfaceAmount.selector ||\r\n            interfaceId == this.balanceOf.selector ||\r\n            interfaceId == this.balanceOfBatch.selector ||\r\n            interfaceId == this.setApprovalForAll.selector ||\r\n            interfaceId == this.isApprovedForAll.selector ||\r\n            interfaceId == this.safeTransferFrom.selector ||\r\n            interfaceId == this.safeBatchTransferFrom.selector ||\r\n            interfaceId == 0xd9b67a26 ||//OpenSea Standard\r\n            interfaceId == type(IERC1155Views).interfaceId ||\r\n            interfaceId == this.totalSupply.selector ||\r\n            interfaceId == 0x00ad800c ||//name(uint256)\r\n            interfaceId == 0x4e41a1fb ||//symbol(uint256)\r\n            interfaceId == 0x3f47e662 ||//decimals(uint256)\r\n            interfaceId == 0x313ce567 ||//decimals()\r\n            interfaceId == 0x0e89341c ||//uri(uint256)\r\n            interfaceId == type(Item).interfaceId ||\r\n            interfaceId == 0x06fdde03 ||//name()\r\n            interfaceId == 0x95d89b41 ||//symbol()\r\n            interfaceId == 0xf5298aca ||//burn(address,uint256,uint256)\r\n            interfaceId == 0x6b20c454 ||//burnBatch(address,uint256[],uint256[])\r\n            interfaceId == 0x8a94b05f ||//burn(address,uint256,uint256,bytes)\r\n            interfaceId == 0x5473422e ||//burnBatch(address,uint256[],uint256[],bytes)\r\n            interfaceId == this.mintItems.selector ||\r\n            interfaceId == this.setItemsCollection.selector ||\r\n            interfaceId == this.setItemsMetadata.selector ||\r\n            interfaceId == this.interoperableOf.selector;\r\n    }\r\n\r\n    function _projectionLazyInit(bytes memory) internal virtual returns (bytes memory) {\r\n        return \"\";\r\n    }\r\n\r\n    function setHeader(Header calldata value) authorizedOnly override external virtual returns(Header memory oldValue) {\r\n        Header[] memory values = new Header[](1);\r\n        values[0] = value;\r\n        bytes32[] memory collectionIds = new bytes32[](1);\r\n        collectionIds[0] = collectionId;\r\n        return IItemMainInterface(mainInterface).setCollectionsMetadata(collectionIds, values)[0];\r\n    }\r\n\r\n    function setItemsMetadata(uint256[] calldata itemIds, Header[] calldata values) authorizedOnly override external virtual returns(Header[] memory oldValues) {\r\n        return IItemMainInterface(mainInterface).setItemsMetadata(itemIds, values);\r\n    }\r\n\r\n    function mintItems(CreateItem[] memory items) authorizedOnly virtual override public returns(uint256[] memory itemIds) {\r\n        uint256 multiplier = 10 ** (18 - decimals(0));\r\n        for(uint256 i = 0; i < items.length; i++) {\r\n            items[i].collectionId = collectionId;\r\n            uint256[] memory amounts = items[i].amounts;\r\n            for(uint256 z = 0; z < amounts.length; z++) {\r\n                amounts[z] = amounts[z] * multiplier;\r\n            }\r\n            items[i].amounts = amounts;\r\n        }\r\n        return IItemMainInterface(mainInterface).mintItems(items);\r\n    }\r\n\r\n    function setItemsCollection(uint256[] calldata itemIds, bytes32[] calldata collectionIds) authorizedOnly virtual override external returns(bytes32[] memory oldCollectionIds) {\r\n        return IItemMainInterface(mainInterface).setItemsCollection(itemIds, collectionIds);\r\n    }\r\n\r\n    function name() override external view returns(string memory value) {\r\n        (,value,,) = IItemMainInterface(mainInterface).collection(collectionId);\r\n    }\r\n\r\n    function symbol() override external view returns(string memory value) {\r\n        (,,value,) = IItemMainInterface(mainInterface).collection(collectionId);\r\n    }\r\n\r\n    function plainUri() override public view returns(string memory value) {\r\n        (,,,value) = IItemMainInterface(mainInterface).collection(collectionId);\r\n    }\r\n\r\n    function uri() override public view returns(string memory) {\r\n        return IItemMainInterface(mainInterface).collectionUri(collectionId);\r\n    }\r\n\r\n    function interoperableOf(uint256 itemId) override public pure returns(address) {\r\n        return address(uint160(itemId));\r\n    }\r\n\r\n    function name(uint256 itemId) override external view returns(string memory) {\r\n        (,Header memory header,,) = IItemMainInterface(mainInterface).item(itemId);\r\n        return header.name;\r\n    }\r\n\r\n    function symbol(uint256 itemId) override external view returns(string memory) {\r\n        (,Header memory header,,) = IItemMainInterface(mainInterface).item(itemId);\r\n        return header.symbol;\r\n    }\r\n\r\n    function decimals(uint256) override public virtual view returns(uint256) {\r\n        return 18;\r\n    }\r\n\r\n    function decimals() external override view returns(uint256) {\r\n        return 18;\r\n    }\r\n\r\n    function toMainInterfaceAmount(uint256 interoperableInterfaceAmount, uint256 itemId) override public view returns(uint256) {\r\n        if(interoperableInterfaceAmount == 0) {\r\n            return 0;\r\n        }\r\n        uint256 itemDecimals = decimals(itemId);\r\n        if(itemDecimals == 18) {\r\n            return interoperableInterfaceAmount;\r\n        }\r\n        uint256 interoperableTotalSupply = IERC20(interoperableOf(itemId)).totalSupply();\r\n        uint256 interoperableUnity = 1e18;\r\n        uint256 interoperableHalfUnity = (interoperableUnity / 51) * 100;\r\n        uint256 mainInterfaceUnity = 10 ** itemDecimals;\r\n        if(interoperableTotalSupply <= interoperableUnity && interoperableInterfaceAmount <= interoperableUnity) {\r\n            return interoperableInterfaceAmount < interoperableHalfUnity ? 0 : mainInterfaceUnity;\r\n        }\r\n        return (interoperableInterfaceAmount * mainInterfaceUnity) / interoperableUnity;\r\n    }\r\n\r\n    function toInteroperableInterfaceAmount(uint256 mainInterfaceAmount, uint256 itemId, address account) override public view returns(uint256) {\r\n        if(mainInterfaceAmount == 0) {\r\n            return 0;\r\n        }\r\n        if(decimals(itemId) == 18) {\r\n            return mainInterfaceAmount;\r\n        }\r\n        uint256 interoperableInterfaceAmount = mainInterfaceAmount * 10 ** (18 - decimals(itemId));\r\n        if(account == address(0)) {\r\n            return interoperableInterfaceAmount;\r\n        }\r\n        uint256 interoperableBalance = IItemMainInterface(mainInterface).balanceOf(account, itemId);\r\n        if(interoperableBalance == 0) {\r\n            return interoperableInterfaceAmount;\r\n        }\r\n        uint256 interoperableTotalSupply = IERC20(interoperableOf(itemId)).totalSupply();\r\n        uint256 interoperableUnity = 1e18;\r\n        uint256 interoperableHalfUnity = (interoperableUnity / 51) * 100;\r\n        if(interoperableTotalSupply <= interoperableUnity && interoperableInterfaceAmount == interoperableUnity && interoperableBalance >= interoperableHalfUnity) {\r\n            return interoperableBalance < interoperableInterfaceAmount ? interoperableBalance : interoperableInterfaceAmount;\r\n        }\r\n        return interoperableInterfaceAmount;\r\n    }\r\n\r\n    function uri(uint256 itemId) override external view returns(string memory) {\r\n        return IItemMainInterface(mainInterface).uri(itemId);\r\n    }\r\n\r\n    function itemPlainUri(uint256 itemId) override external view returns(string memory) {\r\n        (, Header memory header,,) = IItemMainInterface(mainInterface).item(itemId);\r\n        return header.uri;\r\n    }\r\n\r\n    function totalSupply(uint256 itemId) override external view returns (uint256) {\r\n        return IItemMainInterface(mainInterface).totalSupply(itemId);\r\n    }\r\n\r\n    function balanceOf(address account, uint256 itemId) override external view returns (uint256) {\r\n        return toMainInterfaceAmount(IItemMainInterface(mainInterface).balanceOf(account, itemId), itemId);\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata itemIds) override external view returns (uint256[] memory balances) {\r\n        balances = IItemMainInterface(mainInterface).balanceOfBatch(accounts, itemIds);\r\n        for(uint256 i = 0; i < itemIds.length; i++) {\r\n            balances[i] = toMainInterfaceAmount(balances[i], itemIds[i]);\r\n        }\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) override external view returns (bool) {\r\n        return IItemMainInterface(mainInterface).isApprovedForAll(account, operator);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) override external virtual {\r\n        IItemMainInterface(mainInterface).setApprovalForAllByCollectionHost(collectionId, msg.sender, operator, approved);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 itemId, uint256 amount, bytes calldata data) override external virtual {\r\n        require(from != address(0), \"required from\");\r\n        require(to != address(0), \"required to\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(msg.sender, from, to, itemId, toInteroperableInterfaceAmount(amount, itemId, from)));\r\n        ERC1155CommonLibrary.doSafeTransferAcceptanceCheck(msg.sender, from, to, itemId, amount, data);\r\n        emit TransferSingle(msg.sender, from, to, itemId, amount);\r\n    }\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) override external virtual {\r\n        require(from != address(0), \"required from\");\r\n        require(to != address(0), \"required to\");\r\n        uint256[] memory interoperableInterfaceAmounts = new uint256[](amounts.length);\r\n        for(uint256 i = 0 ; i < interoperableInterfaceAmounts.length; i++) {\r\n            interoperableInterfaceAmounts[i] = toInteroperableInterfaceAmount(amounts[i], itemIds[i], from);\r\n        }\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(true, abi.encode(true, abi.encode(abi.encode(msg.sender, from, to, itemIds, interoperableInterfaceAmounts).asSingletonArray())));\r\n        ERC1155CommonLibrary.doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, itemIds, amounts, data);\r\n        emit TransferBatch(msg.sender, from, to, itemIds, amounts);\r\n    }\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount) override external {\r\n        burn(account, itemId, amount, \"\");\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts) override external {\r\n        burnBatch(account, itemIds, amounts, \"\");\r\n    }\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes memory) override virtual public {\r\n        require(account != address(0), \"required account\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(msg.sender, account, address(0), itemId, toInteroperableInterfaceAmount(amount, itemId, account)));\r\n        emit TransferSingle(msg.sender, account, address(0), itemId, amount);\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes memory) override virtual public {\r\n        require(account != address(0), \"required account\");\r\n        uint256[] memory interoperableInterfaceAmounts = new uint256[](amounts.length);\r\n        for(uint256 i = 0 ; i < interoperableInterfaceAmounts.length; i++) {\r\n            interoperableInterfaceAmounts[i] = toInteroperableInterfaceAmount(amounts[i], itemIds[i], account);\r\n        }\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(true, abi.encode(true, abi.encode(abi.encode(msg.sender, account, address(0), itemIds, interoperableInterfaceAmounts).asSingletonArray())));\r\n        emit TransferBatch(msg.sender, account, address(0), itemIds, amounts);\r\n    }\r\n}\r\n\r\n// File: contracts\\projection\\multiOperatorHost\\impl\\MultiOperatorHost.sol\r\n\r\n//SPDX_License_Identifier: MIT\r\n\r\npragma solidity >=0.7.0;\r\n//pragma abicoder v2;\r\n\r\n\r\ncontract MultiOperatorHost is IMultiOperatorHost, ItemProjection {\r\n    using BytesUtilities for bytes;\r\n\r\n    mapping(uint256 => address) public override operator;\r\n\r\n    constructor(bytes memory lazyInitData) ItemProjection(lazyInitData) {\r\n    }\r\n\r\n    function _projectionLazyInit(bytes memory lazyInitData) internal override returns(bytes memory) {\r\n        require(host == address(0), \"No host allowed\");\r\n        (uint256[] memory ops, address[] memory authorized) = abi.decode(lazyInitData, (uint256[], address[]));\r\n        for(uint256 i = 0; i < ops.length; i++) {\r\n            _setOperator(ops[i], authorized[i]);\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    function setOperator(uint256 op, address newValue) external override returns(address oldValue) {\r\n        require(operator[op] == msg.sender, \"Unauthorized\");\r\n        return _setOperator(op, newValue);\r\n    }\r\n\r\n    function setApprovalForAll(address, bool) authorizedOnly override(ItemProjection, IERC1155) external {\r\n        revert();\r\n    }\r\n\r\n    function setHeader(Header memory value) authorizedOnly override(IItemProjection, ItemProjection) external returns(Header memory oldValue) {\r\n        value.host = address(this);\r\n        Header[] memory values = new Header[](1);\r\n        values[0] = value;\r\n        bytes32[] memory collectionIds = new bytes32[](1);\r\n        collectionIds[0] = collectionId;\r\n        oldValue = IItemMainInterface(mainInterface).setCollectionsMetadata(collectionIds, values)[0];\r\n        (address currentHost,,,) =  IItemMainInterface(mainInterface).collection(collectionId);\r\n        require(currentHost == address(this), \"Invalid change\");\r\n        return oldValue;\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 itemId, uint256 amount, bytes calldata data) authorizedOnly override(ItemProjection, IERC1155) external {\r\n        require(from != address(0), \"required from\");\r\n        require(to != address(0), \"required to\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(from, from, to, itemId, toInteroperableInterfaceAmount(amount, itemId, from)));\r\n        ERC1155CommonLibrary.doSafeTransferAcceptanceCheck(msg.sender, from, to, itemId, amount, data);\r\n        emit TransferSingle(msg.sender, from, to, itemId, amount);\r\n    }\r\n\r\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata itemIds, uint256[] calldata amounts, bytes calldata data) authorizedOnly override(ItemProjection, IERC1155) external {\r\n        require(from != address(0), \"required from\");\r\n        require(to != address(0), \"required to\");\r\n        uint256[] memory interoperableInterfaceAmounts = new uint256[](amounts.length);\r\n        for(uint256 i = 0 ; i < interoperableInterfaceAmounts.length; i++) {\r\n            interoperableInterfaceAmounts[i] = toInteroperableInterfaceAmount(amounts[i], itemIds[i], from);\r\n        }\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(true, abi.encode(true, abi.encode(abi.encode(from, from, to, itemIds, interoperableInterfaceAmounts).asSingletonArray())));\r\n        ERC1155CommonLibrary.doSafeBatchTransferAcceptanceCheck(msg.sender, from, to, itemIds, amounts, data);\r\n        emit TransferBatch(msg.sender, from, to, itemIds, amounts);\r\n    }\r\n\r\n    function burn(address account, uint256 itemId, uint256 amount, bytes memory) authorizedOnly override(ItemProjection, Item) public {\r\n        require(account != address(0), \"required account\");\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(false, abi.encode(account, account, address(0), itemId, toInteroperableInterfaceAmount(amount, itemId, account)));\r\n        emit TransferSingle(msg.sender, account, address(0), itemId, amount);\r\n    }\r\n\r\n    function burnBatch(address account, uint256[] calldata itemIds, uint256[] calldata amounts, bytes memory) authorizedOnly override(ItemProjection, Item) public {\r\n        require(account != address(0), \"required account\");\r\n        uint256[] memory interoperableInterfaceAmounts = new uint256[](amounts.length);\r\n        for(uint256 i = 0 ; i < interoperableInterfaceAmounts.length; i++) {\r\n            interoperableInterfaceAmounts[i] = toInteroperableInterfaceAmount(amounts[i], itemIds[i], account);\r\n        }\r\n        IItemMainInterface(mainInterface).mintTransferOrBurn(true, abi.encode(true, abi.encode(abi.encode(account, account, address(0), itemIds, interoperableInterfaceAmounts).asSingletonArray())));\r\n        emit TransferBatch(msg.sender, account, address(0), itemIds, amounts);\r\n    }\r\n\r\n    function _setOperator(uint256 op, address newValue) private returns(address oldValue) {\r\n        require(op > 0, \"invalid op\");\r\n        oldValue = operator[op];\r\n        operator[op] = newValue;\r\n        emit Operator(op, oldValue, newValue);\r\n    }\r\n\r\n    function _subjectIsAuthorizedFor(address subject, address location, bytes4 selector, bytes calldata, uint256) internal virtual override view returns(bool, bool) {\r\n        //1 = mintItems, 2 = burn, 3 = transfer, 4 = setMetadata, 5 = itemsCollection\r\n        uint256 op = selector == this.mintItems.selector ? 1 :\r\n            /*(\r\n                selector == 0xf5298aca ||//burn(address,uint256,uint256)\r\n                selector == 0x6b20c454 ||//burnBatch(address,uint256[],uint256[])\r\n                selector == 0x8a94b05f ||//burn(address,uint256,uint256,bytes)\r\n                selector == 0x5473422e   //burnBatch(address,uint256[],uint256[],bytes)\r\n            ) ? 2 :\r\n            (selector == this.safeTransferFrom.selector || selector == this.safeBatchTransferFrom.selector) ? 3 :*/\r\n            (selector == this.setHeader.selector || selector == this.setItemsMetadata.selector) ? 4 : 0;\r\n            //selector == this.setItemsCollection.selector ? 5 : 0;\r\n        return(true, op > 0 && location == address(this) && operator[op] == subject);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitData\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"fromCollectionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"toCollectionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"CollectionItem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Host\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"op\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Operator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"burnBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectionId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"host\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"interoperableOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"itemPlainUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitData\",\"type\":\"bytes\"}],\"name\":\"lazyInit\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"lazyInitResponse\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mainInterface\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"header\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"collectionId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct CreateItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"}],\"name\":\"mintItems\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"plainUri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"value\",\"type\":\"tuple\"}],\"name\":\"setHeader\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header\",\"name\":\"oldValue\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setHost\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"collectionIds\",\"type\":\"bytes32[]\"}],\"name\":\"setItemsCollection\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"oldCollectionIds\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"itemIds\",\"type\":\"uint256[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"values\",\"type\":\"tuple[]\"}],\"name\":\"setItemsMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"host\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"internalType\":\"struct Header[]\",\"name\":\"oldValues\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"op\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"oldValue\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"subject\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"location\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"selector\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"subjectIsAuthorizedFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mainInterfaceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"toInteroperableInterfaceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"interoperableInterfaceAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"toMainInterfaceAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"itemId\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MultiOperatorHost", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://070f6cba65cc0ab76b58f6e9db0d734a1aa1622273f236c3e8412dac9fcd51d8"}]}