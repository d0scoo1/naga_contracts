{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.4;\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\t\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\t\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\t\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\t\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\t\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\t\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n  \r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n   \r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\t\r\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\t\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\t\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\t\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\t\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\t\t\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\nlibrary MerkleProof {\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n            if (computedHash <= proofElement) {\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\ncontract PledgeMint is Ownable, ReentrancyGuard {\r\n\r\n    using SafeERC20 for IERC20; \r\n\t\r\n\tstruct PhaseConfig {\r\n       uint256 mintPrice;\r\n\t   uint256 mintPriceWhiteList;\r\n       uint256 maxPerWallet;\r\n\t   uint256 maxSupply;\r\n\t   uint256 minted;\r\n\t   bytes32 merkleRoot;\r\n\t   bool saleEnable;\r\n    }\r\n\t\r\n\tIERC20 public USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48); // USDC\r\n    mapping(uint256 => address[]) public pledgers;\r\n    mapping(uint256 => mapping(address => uint256)) public pledges;\r\n\r\n    PhaseConfig[] public phases;\r\n\r\n    modifier callerIsUser() {\r\n        require(tx.origin == msg.sender, \"The caller is another contract\");\r\n        _; \r\n    }\r\n\t\r\n    constructor() {}\r\n\t\r\n    function addPhase(uint256 mintPrice, uint256 mintPriceWhiteList, uint256 maxPerWallet, uint256 maxSupply, bytes32 merkleRoot) external onlyOwner {\r\n        phases.push(PhaseConfig(mintPrice, mintPriceWhiteList, maxPerWallet, maxSupply, 0, merkleRoot, false));\r\n    }\r\n\t\r\n    function pledge(uint256 phaseId, uint256 number) external callerIsUser nonReentrant{\r\n        PhaseConfig storage phase = phases[phaseId];\r\n\t\t\r\n\t\trequire(phases.length > phaseId, \"PhaseID not found\");\r\n\t\trequire(phase.saleEnable, \"Sale is not enable\");\r\n        require(number <= phase.maxPerWallet, \"Cannot buy that many NFTs\");\r\n        require(number > 0, \"Need to buy at least one\");\r\n\t\trequire(USDC.balanceOf(msg.sender) >= phase.mintPrice * number, \"USDC balance is not available for pledge\");\r\n\t\trequire(pledges[phaseId][msg.sender] + number <= phase.maxPerWallet, \"Already pledged\");\r\n\t\trequire(phase.minted + number <= phase.maxSupply, \"Max supply reached\");\r\n\t\t\r\n\t\tif(pledges[phaseId][msg.sender]==0)\r\n\t\t{\r\n\t\t   pledgers[phaseId].push(msg.sender);\r\n\t\t}\r\n\t\t\r\n\t\tphase.minted = phase.minted + number;\r\n        pledges[phaseId][msg.sender] = pledges[phaseId][msg.sender] + number;\r\n\t\tUSDC.safeTransferFrom(address(msg.sender), address(this), phase.mintPrice * number);\r\n    }\r\n\t\r\n\tfunction pledge(uint256 phaseId, uint256 number, bytes32[] calldata merkleProof) external callerIsUser nonReentrant{\r\n        PhaseConfig storage phase = phases[phaseId];\r\n\t\tbytes32 node = keccak256(abi.encodePacked(msg.sender));\r\n\t\t\r\n\t\trequire(phases.length > phaseId, \"PhaseID not found\");\r\n\t\trequire(phase.saleEnable, \"Sale is not enable\");\r\n        require(number <= phase.maxPerWallet, \"Cannot buy that many NFTs\");\r\n        require(number > 0, \"Need to buy at least one\");\r\n\t\trequire(USDC.balanceOf(msg.sender) >= phase.mintPriceWhiteList * number, \"USDC balance is not available for pledge\");\r\n        require(pledges[phaseId][msg.sender] + number <= phase.maxPerWallet, \"Already pledged\");\r\n\t\trequire(MerkleProof.verify(merkleProof, phase.merkleRoot, node), \"Invalid Proof\");\r\n\t\trequire(phase.minted + number <= phase.maxSupply, \"Max supply reached\");\r\n\t\t\r\n\t\tif(pledges[phaseId][msg.sender]==0)\r\n\t\t{\r\n\t\t   pledgers[phaseId].push(msg.sender);\r\n\t\t}\r\n\t\t\r\n\t\tphase.minted = phase.minted + number;\r\n\t\tpledges[phaseId][msg.sender] = pledges[phaseId][msg.sender] + number;\r\n\t\tUSDC.safeTransferFrom(address(msg.sender), address(this), phase.mintPriceWhiteList * number);\r\n    }\r\n\t\r\n\tfunction withdraw() external onlyOwner nonReentrant{\r\n       USDC.safeTransfer(address(msg.sender), USDC.balanceOf(address(this)));\r\n    }\r\n\t\r\n\tfunction withdrawETH() external onlyOwner nonReentrant{\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\t\r\n\tfunction migrateTokens(address token, uint256 amount) external onlyOwner nonReentrant{\r\n       IERC20(token).safeTransfer(address(msg.sender), amount);\r\n    }\r\n\t\r\n\tfunction updateMerkleRoot(uint256 phaseId, bytes32 newMerkleRoot) external onlyOwner {\r\n\t   require(phases.length > phaseId, \"PhaseID not found\");\r\n\t   phases[phaseId].merkleRoot = newMerkleRoot;\r\n\t}\r\n\t\r\n\tfunction saleStatus(uint256 phaseId, bool status) external onlyOwner {\r\n\t   require(phases.length > phaseId, \"PhaseID not found\");\r\n\t   phases[phaseId].saleEnable = status;\r\n\t}\r\n\t\r\n\tfunction updatePrice(uint256 phaseId, uint256 mintPrice, uint256 mintPriceWhiteList) external onlyOwner {\r\n\t   require(phases.length > phaseId, \"PhaseID not found\");\r\n\t   phases[phaseId].mintPrice = mintPrice;\r\n\t   phases[phaseId].mintPriceWhiteList = mintPriceWhiteList;\r\n\t}\r\n\t\r\n\tfunction updateMintLimit(uint256 phaseId, uint256 maxPerWallet) external onlyOwner {\r\n\t   require(phases.length > phaseId, \"PhaseID not found\");\r\n\t   require(maxPerWallet >= 0, \"Incorrect value\");\r\n\t   phases[phaseId].maxPerWallet = maxPerWallet;\r\n\t}\r\n\t\r\n\tfunction updateSupply(uint256 phaseId, uint256 supplyLimit) external onlyOwner {\r\n\t   require(phases.length > phaseId, \"PhaseID not found\");\r\n\t   require(supplyLimit >= phases[phaseId].minted, \"Incorrect value\");\r\n\t   phases[phaseId].maxSupply = supplyLimit;\r\n\t}\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"USDC\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPriceWhiteList\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"addPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"migrateTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPriceWhiteList\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"saleEnable\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"pledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"pledge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pledgers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"pledges\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"saleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"newMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"updateMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerWallet\",\"type\":\"uint256\"}],\"name\":\"updateMintLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintPriceWhiteList\",\"type\":\"uint256\"}],\"name\":\"updatePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"phaseId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyLimit\",\"type\":\"uint256\"}],\"name\":\"updateSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PledgeMint", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fba675319942be2e0c85f96f5518664d43c598ddc11e44c2ba8475a84d4183a4"}]}