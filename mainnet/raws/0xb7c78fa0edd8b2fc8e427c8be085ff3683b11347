{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n                    \r\n////////////////////////////////////////////////////////////////////////////////////////////////                                                                    \r\n//   _____ _ _ _ _____ _____ _____ _____ _____ _____ _____    _____ _____ _____ __ __ __ __   //\r\n//  |     | | | |   | |   __| __  |   __|  |  |     |  _  |  |  _  | __  |     |  |  |  |  |  //\r\n//  |  |  | | | | | | |   __|    -|__   |     |-   -|   __|  |   __|    -|  |  |-   -|_   _|  //\r\n//  |_____|_____|_|___|_____|__|__|_____|__|__|_____|__|     |__|  |__|__|_____|__|__| |_|    //\r\n//  By: 0xInuarashi.eth | twitter.com/0xinuarashi | 0xInuarashi#1234                          //\r\n////////////////////////////////////////////////////////////////////////////////////////////////                                       \r\n                                                                             \r\n/*\r\n    This is a factory contract that allows production of ERC721OwnershipProxy contracts.\r\n\r\n    What it is:\r\n\r\n        ERC721OwnershipProxy is a delegatable ownership prover that allows users to \r\n        verify ownership of assets in hardware wallets using a delegation method to\r\n        enable the verifying in a software wallet instead. \r\n\r\n        This is purely for security and/or ease-of-mind applications for verification\r\n        methods that may require a signature or transaction which you do not want to \r\n        do on your hardware wallet for any reason.\r\n\r\n    To create:\r\n\r\n        Call the function createERC721OwnershipProxy(address address_) using address \r\n        as the ERC721 contract that you would like to create a delegation proxy for.\r\n\r\n        After that, your contract will be created. To figure out the address of the\r\n        created contract, you can check the transaction -> internal transactions\r\n        on etherscan to find the contract being created.\r\n\r\n        In order to verify the source code, copy paste interface IERC721{} and\r\n        contract ERC721OwnershipProxy{} (do not need to copy paste ownershipProxyFactory)\r\n        and then add in ABI-Encoded constructor arguments. Hooray! You have verified the\r\n        source code of your factory-made ERC721OwnershipProxy.\r\n\r\n    To use:\r\n\r\n        This contract is meant to be used with NFT verification services such as \r\n        Collab.Land (discord) for channel access or something similar. \r\n\r\n        All it does is enable you to verify your assets using a delegation from your\r\n        hardware wallet to your software wallet.\r\n\r\n        Add the ERC721OwnershipProxy contract address in the same way you would add\r\n        an NFT. \r\n\r\n        Verify with bot or verification service. If done correct, it should work!\r\n\r\n        Also note that Collab.Land sometimes has black-box mechanics and will not\r\n        be able to verify using something like this in some unannounced patches \r\n        (as it had happened in the past). However, it is working as tested on\r\n        2022-04-20.\r\n\r\n    Made with love by: 0xInuarashi\r\n*/\r\n\r\ninterface IERC721 {\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function balanceOf(address address_) external view returns (uint256);\r\n}\r\n\r\ncontract ERC721OwnershipProxy {\r\n    // Address Based Global Proxy\r\n\r\n    address public tokenContract;\r\n    IERC721 public Token;\r\n    constructor(address contract_) { \r\n        tokenContract = contract_;\r\n        Token = IERC721(tokenContract);\r\n    }\r\n\r\n    mapping(address => address) internal hwToSw;\r\n    mapping(address => address) internal swToHw;\r\n\r\n    function linkSwToHw(address sw_) external {\r\n        // First, clear the past record\r\n        address _previousLink = hwToSw[msg.sender];\r\n        \r\n        if (_previousLink != address(0)) {\r\n            swToHw[_previousLink] = address(0);\r\n        }\r\n\r\n        // Next, set the new data;\r\n        hwToSw[msg.sender] = sw_;\r\n        swToHw[sw_] = msg.sender;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId_) external view returns (address) {\r\n        return hwToSw[Token.ownerOf(tokenId_)] == address(0) ?\r\n            Token.ownerOf(tokenId_) :\r\n            hwToSw[Token.ownerOf(tokenId_)];\r\n    }\r\n\r\n    function balanceOf(address address_) external view returns (uint256) {\r\n        return swToHw[address_] == address(0) ?\r\n            Token.balanceOf(address_) :\r\n            Token.balanceOf(swToHw[address_]);\r\n    }\r\n}\r\n\r\ncontract ownershipProxyFactory {\r\n    function createERC721OwnershipProxy(address address_) external {\r\n        new ERC721OwnershipProxy(address_);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"createERC721OwnershipProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ownershipProxyFactory", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a794961f0f615234fea0dcf953aac3b74d3459dc130c52da436dcab5e216f1b6"}]}