{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981 is IERC165 {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be payed in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/FinalizeAuctionControllerMint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"./utils/EnglishAuctionStorage.sol\\\";\\nimport \\\"./SafeEthSender.sol\\\";\\nimport \\\"../interfaces/INFT.sol\\\";\\n\\ncontract FinalizeAuctionControllerMint is EnglishAuctionStorage, SafeEthSender {\\n    event AuctionRoyaltiesPaid(\\n        uint32 auctionId,\\n        uint32 nftId,\\n        address artistAddress,\\n        uint256 royaltyAmount\\n    );\\n\\n    function finalize(uint32 _auctionId) external {\\n        AuctionStruct storage auction = auctionIdToAuction[_auctionId];\\n\\n        INFT nft = INFT(auction.nftContractAddress);\\n\\n        uint32 nftId = nft.nftId();\\n\\n        if (\\n            auction.auctionBalance == 0 && auction.bidder == payable(address(0))\\n        ) {\\n            emit AuctionRoyaltiesPaid(_auctionId, nftId, address(0), 0);\\n        } else {\\n            (address receiver, uint256 royaltyAmount) = nft.royaltyInfo(\\n                auction.tokenId,\\n                auction.auctionBalance\\n            );\\n\\n            uint256 amountForWithdrawalAddress = auction.auctionBalance -\\n                royaltyAmount;\\n\\n            auction.auctionBalance = 0;\\n\\n            sendEthWithLimitedGas(payable(receiver), royaltyAmount, 5000);\\n\\n            sendEthWithLimitedGas(\\n                withdrawalAddress,\\n                amountForWithdrawalAddress,\\n                5000\\n            );\\n\\n            nft.awardToken(auction.bidder, auction.tokenId);\\n\\n            emit AuctionRoyaltiesPaid(\\n                _auctionId,\\n                nftId,\\n                receiver,\\n                royaltyAmount\\n            );\\n        }\\n    }\\n\\n    function cancel(uint32 _auctionId) external {\\n        revert();\\n    }\\n\\n    function adminCancel(uint32 _auctionId, string memory _reason) external {\\n        require(\\n            bytes(_reason).length > 0,\\n            \\\"English Auction: Include a reason for this cancellation\\\"\\n        );\\n        AuctionStruct storage auction = auctionIdToAuction[_auctionId];\\n        require(auction.timeEnd > 0, \\\"English Auction: Auction not found\\\");\\n    }\\n\\n    function getAuctionType() external view returns (string memory) {\\n        return \\\"MINT\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SafeEthSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"./utils/CallHelpers.sol\\\";\\n\\nabstract contract SafeEthSender is ReentrancyGuard {\\n    mapping(address => uint256) private withdrawRegistry;\\n\\n    event PendingWithdraw(address _user, uint256 _amount);\\n    event Withdrawn(address _user, uint256 _amount);\\n\\n    constructor() ReentrancyGuard() {}\\n\\n    function sendEthWithLimitedGas(\\n        address payable _user,\\n        uint256 _amount,\\n        uint256 _gasLimit\\n    ) internal {\\n        if (_amount == 0) {\\n            return;\\n        }\\n\\n        (bool success, ) = _user.call{value: _amount, gas: _gasLimit}(\\\"\\\");\\n        if (!success) {\\n            withdrawRegistry[_user] += _amount;\\n\\n            emit PendingWithdraw(_user, _amount);\\n        }\\n    }\\n\\n    function getAmountToWithdrawForUser(address user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return withdrawRegistry[user];\\n    }\\n\\n    function withdrawPendingEth() external {\\n        this.withdrawPendingEthFor(payable(msg.sender));\\n    }\\n\\n    function withdrawPendingEthFor(address payable _user)\\n        external\\n        nonReentrant\\n    {\\n        uint256 amount = withdrawRegistry[_user];\\n        require(amount > 0, \\\"SafeEthSender: no funds to withdraw\\\");\\n        withdrawRegistry[_user] = 0;\\n        (bool success, bytes memory response) = _user.call{value: amount}(\\\"\\\");\\n\\n        if (!success) {\\n            string memory message = CallHelpers.getRevertMsg(response);\\n            revert(message);\\n        }\\n\\n        emit Withdrawn(_user, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/CallHelpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nlibrary CallHelpers {\\n    function getRevertMsg(bytes memory _returnData)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (_returnData.length < 68) return \\\"Transaction reverted silently\\\";\\n\\n        assembly {\\n            _returnData := add(_returnData, 0x04)\\n        }\\n        return abi.decode(_returnData, (string));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/EnglishAuctionStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"../../interfaces/IAccessManager.sol\\\";\\n\\nabstract contract EnglishAuctionStorage {\\n    uint32 lastAuctionId;\\n    address payable public withdrawalAddress;\\n    IAccessManager accessManager;\\n\\n    struct AuctionStruct {\\n        uint32 tokenId;\\n        uint32 timeStart;\\n        uint32 timeEnd;\\n        uint8 minBidPercentage;\\n        uint256 initialPrice;\\n        uint256 minBidValue;\\n        uint256 auctionBalance;\\n        address nftContractAddress;\\n        address finalizeAuctionControllerAddress;\\n        address payable bidder;\\n        bytes additionalDataForFinalizeAuction;\\n    }\\n\\n    mapping(uint32 => AuctionStruct) auctionIdToAuction;\\n}\\n\"\r\n    },\r\n    \"interfaces/IAccessManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\ninterface IAccessManager {\\n    function isOperationalAddress(address _address)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"interfaces/INFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC2981.sol\\\";\\n\\ninterface INFT is IERC2981 {\\n    function awardToken(address _user, uint32 _tokenID) external;\\n\\n    function totalAmountOfEdition() external view returns (uint32);\\n\\n    function timeStart() external view returns (uint32);\\n\\n    function timeEnd() external view returns (uint32);\\n\\n    function nftId() external view returns (uint32);\\n\\n    function init(\\n        address _accessManangerAddress,\\n        bytes memory _staticData,\\n        bytes memory _dynamicData\\n    ) external;\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"auctionId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"nftId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"artistAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"name\":\"AuctionRoyaltiesPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"PendingWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_auctionId\",\"type\":\"uint32\"},{\"internalType\":\"string\",\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"adminCancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_auctionId\",\"type\":\"uint32\"}],\"name\":\"cancel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_auctionId\",\"type\":\"uint32\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAmountToWithdrawForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAuctionType\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPendingEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"withdrawPendingEthFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalAddress\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FinalizeAuctionControllerMint", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}