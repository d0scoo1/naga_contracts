{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MerkleClaim.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// ============ Imports ============\\n\\n//import { MerkleProof } from \\\"@openzeppelin/utils/cryptography/MerkleProof.sol\\\"; // OZ: MerkleProof\\nimport { Owned } from \\\"./Owned.sol\\\";\\nimport { TransferHelper } from \\\"./TransferHelper.sol\\\";\\nimport { MerkleProof } from \\\"./MerkleProof.sol\\\"; // OZ: MerkleProof\\n\\ninterface IERC20 {\\n  function approve(address spender, uint256 amount) external returns (bool);\\n  function allowance(address owner, address spender) external view returns (uint256);\\n  function balanceOf(address account) external view returns (uint256);\\n  function transfer(address to, uint256 amount) external returns (bool);\\n  function transferFrom(address from, address to, uint256 amount ) external returns (bool);\\n}\\n\\n/// @title MerkleClaim\\n/// @notice Allows a held ERC20 to be claimable by members of a merkle tree\\n/// @author Anish Agnihotri <contact@anishagnihotri.com>\\n/// @author Jack Corddry https://github.com/corddry\\ncontract MerkleClaim is Owned{\\n\\n  /// ============ Immutable storage ============\\n\\n  /// @notice ERC20-claimee inclusion root\\n  bytes32 public immutable merkleRoot;\\n\\n  /// @notice Contract address of airdropped token\\n  IERC20 public immutable token;\\n\\n  address public timelock_address;\\n\\n  /// ============ Mutable storage ============\\n\\n  /// @notice Mapping of addresses who have claimed tokens\\n  mapping(address => bool) public hasClaimed;\\n\\n  /// ============ Errors ============\\n\\n  /// @notice Thrown if address has already claimed\\n  error AlreadyClaimed();\\n  /// @notice Thrown if address/amount are not part of Merkle tree\\n  error NotInMerkle();\\n  /// @notice Thrown if claim contract doesn't have enough tokens to payout\\n  error notEnoughRewards();\\n\\n  /// ============ Modifiers ============\\n\\n  modifier onlyByOwnGov() {\\n    require(msg.sender == owner || msg.sender == timelock_address, \\\"Not owner or timelock\\\");\\n    _;\\n  }\\n\\n  /// ============ Constructor ============\\n\\n  /// @notice Creates a new MerkleClaimERC20 contract\\n  /// @param _erc20Address of token to be airdropped\\n  /// @param _merkleRoot of claimees\\n  constructor(\\n    address _erc20Address,\\n    bytes32 _merkleRoot,\\n    address _owner_address,\\n    address _timelock_address\\n  ) Owned(_owner_address)\\n  {\\n    merkleRoot = _merkleRoot;\\n    token = IERC20(_erc20Address);\\n    timelock_address = _timelock_address;\\n  }\\n\\n  /// ============ Events ============\\n\\n  /// @notice Emitted after a successful token claim\\n  /// @param to recipient of claim\\n  /// @param amount of tokens claimed\\n  event Claim(address indexed to, uint256 amount);\\n\\n  /// @notice Emitted after a successful token recovery\\n  /// @param token address being recovered\\n  /// @param amount of tokens recoverd\\n  event Recovered(address token, uint256 amount);\\n\\n  /// ============ Functions ============\\n\\n  /// @notice Allows claiming tokens if address is part of merkle tree\\n  /// @param to address of claimee\\n  /// @param amount of tokens owed to claimee\\n  /// @param proof merkle proof to prove address and amount are in tree\\n  function claim(address to, uint256 amount, bytes32[] calldata proof) external {\\n    // Throw if address has already claimed tokens\\n    if (hasClaimed[to]) revert AlreadyClaimed();\\n\\n    // Verify merkle proof, or revert if not in tree\\n    bytes32 leaf = keccak256(abi.encodePacked(to, amount));\\n    bool isValidLeaf = MerkleProof.verify(proof, merkleRoot, leaf);\\n    if (!isValidLeaf) revert NotInMerkle();\\n\\n    // Throw if the contract doesn't hold enough tokens for claimee\\n    if (amount > token.balanceOf(address(this))) revert notEnoughRewards();\\n\\n    // Set address to claimed\\n    hasClaimed[to] = true;\\n\\n    // Award tokens to address\\n    token.transfer(to, amount);\\n\\n    // Emit claim event\\n    emit Claim(to, amount);\\n  }\\n\\n    /// ============ Permissioned Functions ============\\n  \\n    function setTimelock(address _new_timelock_address) external onlyByOwnGov {\\n      timelock_address = _new_timelock_address;\\n    }\\n    \\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\\n        // Can only be triggered by owner or governance\\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\\n        \\n        emit Recovered(tokenAddress, tokenAmount);\\n    }\\n\\n    // Generic proxy\\n    function execute(\\n        address _to,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external onlyByOwnGov returns (bool, bytes memory) {\\n        (bool success, bytes memory result) = _to.call{value:_value}(_data);\\n        return (success, result);\\n    }\\n}\\n\\n\"\r\n    },\r\n    \"contracts/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.11;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"contracts/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.11;\\n\\n// https://docs.synthetix.io/contracts/Owned\\ncontract Owned {\\n    address public owner;\\n    address public nominatedOwner;\\n\\n    constructor (address _owner) {\\n        require(_owner != address(0), \\\"Owner address cannot be 0\\\");\\n        owner = _owner;\\n        emit OwnerChanged(address(0), _owner);\\n    }\\n\\n    function nominateNewOwner(address _owner) external onlyOwner {\\n        nominatedOwner = _owner;\\n        emit OwnerNominated(_owner);\\n    }\\n\\n    function acceptOwnership() external {\\n        require(msg.sender == nominatedOwner, \\\"You must be nominated before you can accept ownership\\\");\\n        emit OwnerChanged(owner, nominatedOwner);\\n        owner = nominatedOwner;\\n        nominatedOwner = address(0);\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Only the contract owner may perform this action\\\");\\n        _;\\n    }\\n\\n    event OwnerNominated(address newOwner);\\n    event OwnerChanged(address oldOwner, address newOwner);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_erc20Address\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_owner_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyClaimed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotInMerkle\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"notEnoughRewards\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Recovered\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_timelock_address\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MerkleClaim", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2544a32872a91f4a553b404c6950e89de901fdb1cc89145d7ddfb4a255e327ab01d1f98259db2b14430efdc24124d5cdb169ba10000000000000000000000003ce4d19c155d977b04c8560ed1cc9c6f38ee3d320000000000000000000000008412ebf45bac1b340bbe8f318b928c466c4e39ca", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}