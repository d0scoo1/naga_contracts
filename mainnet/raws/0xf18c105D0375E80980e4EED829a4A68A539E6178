{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/authorizers/RequesterAuthorizerWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"../whitelist/WhitelistRolesWithAirnode.sol\\\";\\nimport \\\"./RequesterAuthorizer.sol\\\";\\nimport \\\"./interfaces/IRequesterAuthorizerWithAirnode.sol\\\";\\n\\n/// @title Authorizer contract that Airnode operators can use to temporarily or\\n/// indefinitely whitelist requesters for Airnode\u2013endpoint pairs\\ncontract RequesterAuthorizerWithAirnode is\\n    WhitelistRolesWithAirnode,\\n    RequesterAuthorizer,\\n    IRequesterAuthorizerWithAirnode\\n{\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    )\\n        WhitelistRolesWithAirnode(_accessControlRegistry, _adminRoleDescription)\\n    {}\\n\\n    /// @notice Extends the expiration of the temporary whitelist of\\n    /// `requester` for the `airnode`\u2013`endpointId` pair if the sender has the\\n    /// whitelist expiration extender role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function extendWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external override {\\n        require(\\n            hasWhitelistExpirationExtenderRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Cannot extend expiration\\\"\\n        );\\n        _extendWhitelistExpirationAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\\n    /// for the `airnode`\u2013`endpointId` pair if the sender has the whitelist\\n    /// expiration setter role\\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function setWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external override {\\n        require(\\n            hasWhitelistExpirationSetterRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Cannot set expiration\\\"\\n        );\\n        _setWhitelistExpirationAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of `requester` for the\\n    /// `airnode`\u2013`endpointId` pair if the sender has the indefinite\\n    /// whitelister role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param status Indefinite whitelist status\\n    function setIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) external override {\\n        require(\\n            hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, msg.sender),\\n            \\\"Cannot set indefinite status\\\"\\n        );\\n        _setIndefiniteWhitelistStatusAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            status\\n        );\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted by a specific\\n    /// account that no longer has the indefinite whitelister role\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function revokeIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external override {\\n        require(\\n            !hasIndefiniteWhitelisterRoleOrIsAirnode(airnode, setter),\\n            \\\"setter can set indefinite status\\\"\\n        );\\n        _revokeIndefiniteWhitelistStatusAndEmit(\\n            airnode,\\n            endpointId,\\n            requester,\\n            setter\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/WhitelistRolesWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./WhitelistRoles.sol\\\";\\nimport \\\"../access-control-registry/AccessControlRegistryAdminned.sol\\\";\\nimport \\\"./interfaces/IWhitelistRolesWithAirnode.sol\\\";\\nimport \\\"../access-control-registry/interfaces/IAccessControlRegistry.sol\\\";\\n\\n/// @title Contract to be inherited by Whitelist contracts that will use\\n/// roles where each individual Airnode address is its own manager\\ncontract WhitelistRolesWithAirnode is\\n    WhitelistRoles,\\n    AccessControlRegistryAdminned,\\n    IWhitelistRolesWithAirnode\\n{\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    )\\n        AccessControlRegistryAdminned(\\n            _accessControlRegistry,\\n            _adminRoleDescription\\n        )\\n    {}\\n\\n    /// @notice Derives the admin role for the Airnode\\n    /// @param airnode Airnode address\\n    /// @return adminRole Admin role\\n    function deriveAdminRole(address airnode)\\n        external\\n        view\\n        override\\n        returns (bytes32 adminRole)\\n    {\\n        adminRole = _deriveAdminRole(airnode);\\n    }\\n\\n    /// @notice Derives the whitelist expiration extender role for the Airnode\\n    /// @param airnode Airnode address\\n    /// @return whitelistExpirationExtenderRole Whitelist expiration extender\\n    /// role\\n    function deriveWhitelistExpirationExtenderRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 whitelistExpirationExtenderRole)\\n    {\\n        whitelistExpirationExtenderRole = _deriveRole(\\n            _deriveAdminRole(airnode),\\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n\\n    /// @notice Derives the whitelist expiration setter role for the Airnode\\n    /// @param airnode Airnode address\\n    /// @return whitelistExpirationSetterRole Whitelist expiration setter role\\n    function deriveWhitelistExpirationSetterRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 whitelistExpirationSetterRole)\\n    {\\n        whitelistExpirationSetterRole = _deriveRole(\\n            _deriveAdminRole(airnode),\\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n\\n    /// @notice Derives the indefinite whitelister role for the Airnode\\n    /// @param airnode Airnode address\\n    /// @return indefiniteWhitelisterRole Indefinite whitelister role\\n    function deriveIndefiniteWhitelisterRole(address airnode)\\n        public\\n        view\\n        override\\n        returns (bytes32 indefiniteWhitelisterRole)\\n    {\\n        indefiniteWhitelisterRole = _deriveRole(\\n            _deriveAdminRole(airnode),\\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\\n        );\\n    }\\n\\n    /// @dev Returns if the account has the whitelist expiration extender role\\n    /// or is the Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the whitelist extender role or is the\\n    /// Airnode address\\n    function hasWhitelistExpirationExtenderRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveWhitelistExpirationExtenderRole(airnode),\\n                account\\n            );\\n    }\\n\\n    /// @dev Returns if the account has the whitelist expriation setter role or\\n    /// is the Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the whitelist setter role or is the Airnode\\n    /// address\\n    function hasWhitelistExpirationSetterRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveWhitelistExpirationSetterRole(airnode),\\n                account\\n            );\\n    }\\n\\n    /// @dev Returns if the account has the indefinite whitelister role or is the\\n    /// Airnode address\\n    /// @param airnode Airnode address\\n    /// @param account Account address\\n    /// @return If the account has the indefinite whitelister role or is the\\n    /// Airnode addrss\\n    function hasIndefiniteWhitelisterRoleOrIsAirnode(\\n        address airnode,\\n        address account\\n    ) internal view returns (bool) {\\n        return\\n            airnode == account ||\\n            IAccessControlRegistry(accessControlRegistry).hasRole(\\n                deriveIndefiniteWhitelisterRole(airnode),\\n                account\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/RequesterAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../whitelist/Whitelist.sol\\\";\\nimport \\\"./interfaces/IRequesterAuthorizer.sol\\\";\\n\\n/// @title Abstract contract to be inherited by Authorizer contracts that\\n/// temporarily or permanently whitelist requesters for Airnode\u2013endpoint pairs\\nabstract contract RequesterAuthorizer is Whitelist, IRequesterAuthorizer {\\n    /// @notice Extends the expiration of the temporary whitelist of\\n    /// `requester` for the `airnode`\u2013`endpointId` pair and emits an event\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _extendWhitelistExpirationAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        require(requester != address(0), \\\"Requester address zero\\\");\\n        _extendWhitelistExpiration(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            expirationTimestamp\\n        );\\n        emit ExtendedWhitelistExpiration(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of `requester`\\n    /// for the `airnode`\u2013`endpointId` pair and emits an event\\n    /// @dev Unlike `_extendWhitelistExpiration()`, this can hasten expiration\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param requester Requester address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _setWhitelistExpirationAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        require(requester != address(0), \\\"Requester address zero\\\");\\n        _setWhitelistExpiration(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            expirationTimestamp\\n        );\\n        emit SetWhitelistExpiration(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            expirationTimestamp\\n        );\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of `requester` for the\\n    /// `airnode`\u2013`endpointId` pair and emits an event\\n    /// @dev Emits the event even if it does not change the state.\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param requester Requester address\\n    /// @param status Indefinite whitelist status\\n    function _setIndefiniteWhitelistStatusAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) internal {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        require(requester != address(0), \\\"Requester address zero\\\");\\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\\n            deriveServiceId(airnode, endpointId),\\n            requester,\\n            status\\n        );\\n        emit SetIndefiniteWhitelistStatus(\\n            airnode,\\n            endpointId,\\n            requester,\\n            msg.sender,\\n            status,\\n            indefiniteWhitelistCount\\n        );\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted to `requester`\\n    /// for the `airnode`\u2013`endpointId` pair by a specific account and emits an\\n    /// event\\n    /// @dev Only emits the event if it changes the state\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID (allowed to be `bytes32(0)`)\\n    /// @param requester Requester address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function _revokeIndefiniteWhitelistStatusAndEmit(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) internal {\\n        require(airnode != address(0), \\\"Airnode address zero\\\");\\n        require(requester != address(0), \\\"Requester address zero\\\");\\n        require(setter != address(0), \\\"Setter address zero\\\");\\n        (\\n            bool revoked,\\n            uint192 indefiniteWhitelistCount\\n        ) = _revokeIndefiniteWhitelistStatus(\\n                deriveServiceId(airnode, endpointId),\\n                requester,\\n                setter\\n            );\\n        if (revoked) {\\n            emit RevokedIndefiniteWhitelistStatus(\\n                airnode,\\n                endpointId,\\n                requester,\\n                setter,\\n                msg.sender,\\n                indefiniteWhitelistCount\\n            );\\n        }\\n    }\\n\\n    /// @notice Verifies the authorization status of a request\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @return Authorization status of the request\\n    function isAuthorized(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    ) external view override returns (bool) {\\n        return\\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\\n    }\\n\\n    /// @notice Verifies the authorization status of a request\\n    /// @dev This method has redundant arguments because V0 authorizer\\n    /// contracts have to have the same interface and potential authorizer\\n    /// contracts may require to access the arguments that are redundant here\\n    /// @param requestId Request ID\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param sponsor Sponsor address\\n    /// @param requester Requester address\\n    /// @return Authorization status of the request\\n    function isAuthorizedV0(\\n        bytes32 requestId, // solhint-disable-line no-unused-vars\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor, // solhint-disable-line no-unused-vars\\n        address requester\\n    ) external view override returns (bool) {\\n        return\\n            userIsWhitelisted(deriveServiceId(airnode, endpointId), requester);\\n    }\\n\\n    /// @notice Returns the whitelist status of `requester` for the\\n    /// `airnode`\u2013`endpointId` pair\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @return expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    /// @return indefiniteWhitelistCount Number of times `requester` was\\n    /// whitelisted indefinitely for the `airnode`\u2013`endpointId` pair\\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    )\\n        external\\n        view\\n        override\\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\\n    {\\n        WhitelistStatus\\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\\n                deriveServiceId(airnode, endpointId)\\n            ][requester];\\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\\n    }\\n\\n    /// @notice Returns if an account has indefinitely whitelisted `requester`\\n    /// for the `airnode`\u2013`endpointId` pair\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @param requester Requester address\\n    /// @param setter Address of the account that has potentially whitelisted\\n    /// `requester` for the `airnode`\u2013`endpointId` pair indefinitely\\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\\n    /// whitelisted `requester` for the `airnode`\u2013`endpointId` pair\\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external view override returns (bool indefiniteWhitelistStatus) {\\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\\n            deriveServiceId(airnode, endpointId)\\n        ][requester][setter];\\n    }\\n\\n    /// @notice Called privately to derive a service ID out of the Airnode\\n    /// address and the endpoint ID\\n    /// @dev This is done to re-use the more general Whitelist contract for\\n    /// the specific case of Airnode\u2013endpoint pairs\\n    /// @param airnode Airnode address\\n    /// @param endpointId Endpoint ID\\n    /// @return serviceId Service ID\\n    function deriveServiceId(address airnode, bytes32 endpointId)\\n        private\\n        pure\\n        returns (bytes32 serviceId)\\n    {\\n        serviceId = keccak256(abi.encodePacked(airnode, endpointId));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IRequesterAuthorizerWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../whitelist/interfaces/IWhitelistRolesWithAirnode.sol\\\";\\nimport \\\"./IRequesterAuthorizer.sol\\\";\\n\\ninterface IRequesterAuthorizerWithAirnode is\\n    IWhitelistRolesWithAirnode,\\n    IRequesterAuthorizer\\n{}\\n\"\r\n    },\r\n    \"contracts/whitelist/WhitelistRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IWhitelistRoles.sol\\\";\\n\\n/// @title Contract to be inherited by Whitelist contracts that will use\\n/// generic AccessControlRegistry roles\\ncontract WhitelistRoles is IWhitelistRoles {\\n    // There are four roles implemented in this contract:\\n    // Root\\n    // \u2514\u2500\u2500 (1) Admin (can grant and revoke the roles below)\\n    //     \u251c\u2500\u2500 (2) Whitelist expiration extender\\n    //     \u251c\u2500\u2500 (3) Whitelist expiration setter\\n    //     \u2514\u2500\u2500 (4) Indefinite whitelister\\n    // Their IDs are derived from the descriptions below. Refer to\\n    // AccessControlRegistry for more information.\\n    // To clarify, the root role of the manager is the admin of (1), while (1)\\n    // is the admin of (2), (3) and (4). So (1) is more of a \\\"contract admin\\\",\\n    // while the `adminRole` used in AccessControl and AccessControlRegistry\\n    // refers to a more general adminship relationship between roles.\\n\\n    /// @notice Whitelist expiration extender role description\\n    string\\n        public constant\\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\\n        \\\"Whitelist expiration extender\\\";\\n\\n    /// @notice Whitelist expiration setter role description\\n    string\\n        public constant\\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\\n        \\\"Whitelist expiration setter\\\";\\n\\n    /// @notice Indefinite whitelister role description\\n\\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\\n        \\\"Indefinite whitelister\\\";\\n\\n    bytes32\\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\\n        keccak256(\\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\\n        );\\n\\n    bytes32\\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\\n        keccak256(\\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\\n        );\\n\\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/AccessControlRegistryAdminned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport \\\"./RoleDeriver.sol\\\";\\nimport \\\"./AccessControlRegistryUser.sol\\\";\\nimport \\\"./interfaces/IAccessControlRegistryAdminned.sol\\\";\\n\\n/// @title Contract to be inherited by contracts whose adminship functionality\\n/// will be implemented using AccessControlRegistry\\ncontract AccessControlRegistryAdminned is\\n    Multicall,\\n    RoleDeriver,\\n    AccessControlRegistryUser,\\n    IAccessControlRegistryAdminned\\n{\\n    /// @notice Admin role description\\n    string public override adminRoleDescription;\\n\\n    bytes32 internal immutable adminRoleDescriptionHash;\\n\\n    /// @dev Contracts deployed with the same admin role descriptions will have\\n    /// the same roles, meaning that granting an account a role will authorize\\n    /// it in multiple contracts. Unless you want your deployed contract to\\n    /// share the role configuration of another contract, use a unique admin\\n    /// role description.\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    /// @param _adminRoleDescription Admin role description\\n    constructor(\\n        address _accessControlRegistry,\\n        string memory _adminRoleDescription\\n    ) AccessControlRegistryUser(_accessControlRegistry) {\\n        require(\\n            bytes(_adminRoleDescription).length > 0,\\n            \\\"Admin role description empty\\\"\\n        );\\n        adminRoleDescription = _adminRoleDescription;\\n        adminRoleDescriptionHash = keccak256(\\n            abi.encodePacked(_adminRoleDescription)\\n        );\\n    }\\n\\n    /// @notice Derives the admin role for the specific manager address\\n    /// @param manager Manager address\\n    /// @return adminRole Admin role\\n    function _deriveAdminRole(address manager)\\n        internal\\n        view\\n        returns (bytes32 adminRole)\\n    {\\n        adminRole = _deriveRole(\\n            _deriveRootRole(manager),\\n            adminRoleDescriptionHash\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/interfaces/IWhitelistRolesWithAirnode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IWhitelistRoles.sol\\\";\\nimport \\\"../../access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\\\";\\n\\ninterface IWhitelistRolesWithAirnode is\\n    IWhitelistRoles,\\n    IAccessControlRegistryAdminned\\n{\\n    function deriveAdminRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveWhitelistExpirationExtenderRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveWhitelistExpirationSetterRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n\\n    function deriveIndefiniteWhitelisterRole(address airnode)\\n        external\\n        view\\n        returns (bytes32 role);\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IAccessControlRegistry is IAccessControl {\\n    event InitializedManager(bytes32 indexed rootRole, address indexed manager);\\n\\n    event InitializedRole(\\n        bytes32 indexed role,\\n        bytes32 indexed adminRole,\\n        string description,\\n        address sender\\n    );\\n\\n    function initializeManager(address manager) external;\\n\\n    function initializeRoleAndGrantToSender(\\n        bytes32 adminRole,\\n        string calldata description\\n    ) external returns (bytes32 role);\\n\\n    function deriveRootRole(address manager)\\n        external\\n        pure\\n        returns (bytes32 rootRole);\\n\\n    function deriveRole(bytes32 adminRole, string calldata description)\\n        external\\n        pure\\n        returns (bytes32 role);\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/interfaces/IWhitelistRoles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IWhitelistRoles {\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n\\n    // solhint-disable-next-line func-name-mixedcase\\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\\n        external\\n        view\\n        returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/RoleDeriver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contract to be inherited by contracts that will derive\\n/// AccessControlRegistry roles\\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\\n/// derive roles, it should inherit this contract instead of re-implementing\\n/// the logic\\ncontract RoleDeriver {\\n    /// @notice Derives the root role of the manager\\n    /// @param manager Manager address\\n    /// @return rootRole Root role\\n    function _deriveRootRole(address manager)\\n        internal\\n        pure\\n        returns (bytes32 rootRole)\\n    {\\n        rootRole = keccak256(abi.encodePacked(manager));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param description Human-readable description of the role\\n    /// @return role Role\\n    function _deriveRole(bytes32 adminRole, string memory description)\\n        internal\\n        pure\\n        returns (bytes32 role)\\n    {\\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\\n    }\\n\\n    /// @notice Derives the role using its admin role and description hash\\n    /// @dev This implies that roles adminned by the same role cannot have the\\n    /// same description\\n    /// @param adminRole Admin role\\n    /// @param descriptionHash Hash of the human-readable description of the\\n    /// role\\n    /// @return role Role\\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\\n        internal\\n        pure\\n        returns (bytes32 role)\\n    {\\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/AccessControlRegistryUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/IAccessControlRegistry.sol\\\";\\nimport \\\"./interfaces/IAccessControlRegistryUser.sol\\\";\\n\\n/// @title Contract to be inherited by contracts that will interact with\\n/// AccessControlRegistry\\ncontract AccessControlRegistryUser is IAccessControlRegistryUser {\\n    /// @notice AccessControlRegistry contract address\\n    address public immutable override accessControlRegistry;\\n\\n    /// @param _accessControlRegistry AccessControlRegistry contract address\\n    constructor(address _accessControlRegistry) {\\n        require(_accessControlRegistry != address(0), \\\"ACR address zero\\\");\\n        accessControlRegistry = _accessControlRegistry;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlRegistryUser.sol\\\";\\n\\ninterface IAccessControlRegistryAdminned is IAccessControlRegistryUser {\\n    function adminRoleDescription() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access-control-registry/interfaces/IAccessControlRegistryUser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAccessControlRegistryUser {\\n    function accessControlRegistry() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/whitelist/Whitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Contract to be inherited by contracts that need temporary and\\n/// permanent whitelists for services identified by hashes\\n/// @notice This contract implements two kinds of whitelisting:\\n///   (1) Temporary, ends when the expiration timestamp is in the past\\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\\n/// Multiple senders can indefinitely whitelist/unwhitelist independently. The\\n/// user will be considered whitelisted as long as there is at least one active\\n/// indefinite whitelisting.\\n/// @dev The interface of this contract is not implemented. It should be\\n/// inherited and its functions should be exposed with a sort of an\\n/// authorization scheme.\\ncontract Whitelist {\\n    struct WhitelistStatus {\\n        uint64 expirationTimestamp;\\n        uint192 indefiniteWhitelistCount;\\n    }\\n\\n    mapping(bytes32 => mapping(address => WhitelistStatus))\\n        internal serviceIdToUserToWhitelistStatus;\\n\\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\\n\\n    /// @notice Extends the expiration of the temporary whitelist of the user\\n    /// for the service\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _extendWhitelistExpiration(\\n        bytes32 serviceId,\\n        address user,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        require(\\n            expirationTimestamp >\\n                serviceIdToUserToWhitelistStatus[serviceId][user]\\n                    .expirationTimestamp,\\n            \\\"Does not extend expiration\\\"\\n        );\\n        serviceIdToUserToWhitelistStatus[serviceId][user]\\n            .expirationTimestamp = expirationTimestamp;\\n    }\\n\\n    /// @notice Sets the expiration of the temporary whitelist of the user for\\n    /// the service\\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\\n    /// will expire\\n    function _setWhitelistExpiration(\\n        bytes32 serviceId,\\n        address user,\\n        uint64 expirationTimestamp\\n    ) internal {\\n        serviceIdToUserToWhitelistStatus[serviceId][user]\\n            .expirationTimestamp = expirationTimestamp;\\n    }\\n\\n    /// @notice Sets the indefinite whitelist status of the user for the\\n    /// service\\n    /// @dev As long as at least there is at least one account that has set the\\n    /// indefinite whitelist status of the user for the service as true, the\\n    /// user will be considered whitelisted\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param status Indefinite whitelist status\\n    function _setIndefiniteWhitelistStatus(\\n        bytes32 serviceId,\\n        address user,\\n        bool status\\n    ) internal returns (uint192 indefiniteWhitelistCount) {\\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\\n            user\\n        ].indefiniteWhitelistCount;\\n        if (\\n            status &&\\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\\n                user\\n            ][msg.sender]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ] = true;\\n            indefiniteWhitelistCount++;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n        } else if (\\n            !status &&\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                msg.sender\\n            ] = false;\\n            indefiniteWhitelistCount--;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n        }\\n    }\\n\\n    /// @notice Revokes the indefinite whitelist status granted to the user for\\n    /// the service by a specific account\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @param setter Setter of the indefinite whitelist status\\n    function _revokeIndefiniteWhitelistStatus(\\n        bytes32 serviceId,\\n        address user,\\n        address setter\\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\\n            user\\n        ].indefiniteWhitelistCount;\\n        if (\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                setter\\n            ]\\n        ) {\\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\\n                setter\\n            ] = false;\\n            indefiniteWhitelistCount--;\\n            serviceIdToUserToWhitelistStatus[serviceId][user]\\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\\n            revoked = true;\\n        }\\n    }\\n\\n    /// @notice Returns if the user is whitelised to use the service\\n    /// @param serviceId Service ID\\n    /// @param user User address\\n    /// @return isWhitelisted If the user is whitelisted\\n    function userIsWhitelisted(bytes32 serviceId, address user)\\n        internal\\n        view\\n        returns (bool isWhitelisted)\\n    {\\n        WhitelistStatus\\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\\n                serviceId\\n            ][user];\\n        return\\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\\n            whitelistStatus.expirationTimestamp > block.timestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IRequesterAuthorizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAuthorizerV0.sol\\\";\\n\\ninterface IRequesterAuthorizer is IAuthorizerV0 {\\n    event ExtendedWhitelistExpiration(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        uint256 expiration\\n    );\\n\\n    event SetWhitelistExpiration(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        uint256 expiration\\n    );\\n\\n    event SetIndefiniteWhitelistStatus(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed sender,\\n        bool status,\\n        uint192 indefiniteWhitelistCount\\n    );\\n\\n    event RevokedIndefiniteWhitelistStatus(\\n        address indexed airnode,\\n        bytes32 endpointId,\\n        address indexed requester,\\n        address indexed setter,\\n        address sender,\\n        uint192 indefiniteWhitelistCount\\n    );\\n\\n    function extendWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external;\\n\\n    function setWhitelistExpiration(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        uint64 expirationTimestamp\\n    ) external;\\n\\n    function setIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        bool status\\n    ) external;\\n\\n    function revokeIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external;\\n\\n    function airnodeToEndpointIdToRequesterToWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    )\\n        external\\n        view\\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\\n\\n    function airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester,\\n        address setter\\n    ) external view returns (bool indefiniteWhitelistStatus);\\n\\n    function isAuthorized(\\n        address airnode,\\n        bytes32 endpointId,\\n        address requester\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/authorizers/interfaces/IAuthorizerV0.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IAuthorizerV0 {\\n    function isAuthorizedV0(\\n        bytes32 requestId,\\n        address airnode,\\n        bytes32 endpointId,\\n        address sponsor,\\n        address requester\\n    ) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_accessControlRegistry\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_adminRoleDescription\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"ExtendedWhitelistExpiration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"name\":\"RevokedIndefiniteWhitelistStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"name\":\"SetIndefiniteWhitelistStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"}],\"name\":\"SetWhitelistExpiration\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INDEFINITE_WHITELISTER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accessControlRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminRoleDescription\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"}],\"name\":\"airnodeToEndpointIdToRequesterToSetterToIndefiniteWhitelistStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"indefiniteWhitelistStatus\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"airnodeToEndpointIdToRequesterToWhitelistStatus\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"},{\"internalType\":\"uint192\",\"name\":\"indefiniteWhitelistCount\",\"type\":\"uint192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveAdminRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"adminRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveIndefiniteWhitelisterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"indefiniteWhitelisterRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveWhitelistExpirationExtenderRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"whitelistExpirationExtenderRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"}],\"name\":\"deriveWhitelistExpirationSetterRole\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"whitelistExpirationSetterRole\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"}],\"name\":\"extendWhitelistExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"isAuthorized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"isAuthorizedV0\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"setter\",\"type\":\"address\"}],\"name\":\"revokeIndefiniteWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setIndefiniteWhitelistStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"airnode\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"endpointId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"expirationTimestamp\",\"type\":\"uint64\"}],\"name\":\"setWhitelistExpiration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RequesterAuthorizerWithAirnode", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000092e5125adf385d86bedb950793526106143b6df100000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000024526571756573746572417574686f72697a6572576974684169726e6f64652061646d696e00000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}