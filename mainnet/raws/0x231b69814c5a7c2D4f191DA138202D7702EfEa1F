{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\npragma solidity 0.7.5;\r\n\r\nlibrary LowGasSafeMath {\r\n    /// @notice Returns x + y, reverts if sum overflows uint256\r\n    /// @param x The augend\r\n    /// @param y The addend\r\n    /// @return z The sum of x and y\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function add32(uint32 x, uint32 y) internal pure returns (uint32 z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    /// @notice Returns x - y, reverts if underflows\r\n    /// @param x The minuend\r\n    /// @param y The subtrahend\r\n    /// @return z The difference of x and y\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    function sub32(uint32 x, uint32 y) internal pure returns (uint32 z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n\r\n    /// @notice Returns x * y, reverts if overflows\r\n    /// @param x The multiplicand\r\n    /// @param y The multiplier\r\n    /// @return z The product of x and y\r\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\r\n        require(x == 0 || (z = x * y) / x == y);\r\n    }\r\n\r\n    /// @notice Returns x + y, reverts if overflows or underflows\r\n    /// @param x The augend\r\n    /// @param y The addend\r\n    /// @return z The sum of x and y\r\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require((z = x + y) >= x == (y >= 0));\r\n    }\r\n\r\n    /// @notice Returns x - y, reverts if overflows or underflows\r\n    /// @param x The minuend\r\n    /// @param y The subtrahend\r\n    /// @return z The difference of x and y\r\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\r\n        require((z = x - y) <= x == (y >= 0));\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns(uint256 z){\r\n        require(y > 0);\r\n        z=x/y;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nlibrary Address {\r\n\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(\r\n        address target, \r\n        bytes memory data, \r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return _functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(\r\n        address target, \r\n        bytes memory data, \r\n        uint256 value, \r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _functionCallWithValue(\r\n        address target, \r\n        bytes memory data, \r\n        uint256 weiValue, \r\n        string memory errorMessage\r\n    ) private returns (bytes memory) {\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(\r\n        address target, \r\n        bytes memory data, \r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(\r\n        address target, \r\n        bytes memory data, \r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success, \r\n        bytes memory returndata, \r\n        string memory errorMessage\r\n    ) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addressToString(address _address) internal pure returns(string memory) {\r\n        bytes32 _bytes = bytes32(uint256(_address));\r\n        bytes memory HEX = \"0123456789abcdef\";\r\n        bytes memory _addr = new bytes(42);\r\n\r\n        _addr[0] = '0';\r\n        _addr[1] = 'x';\r\n\r\n        for(uint256 i = 0; i < 20; i++) {\r\n            _addr[2+i*2] = HEX[uint8(_bytes[i + 12] >> 4)];\r\n            _addr[3+i*2] = HEX[uint8(_bytes[i + 12] & 0x0f)];\r\n        }\r\n\r\n        return string(_addr);\r\n\r\n    }\r\n}\r\n\r\ncontract OwnableData {\r\n    address public owner;\r\n    address public pendingOwner;\r\n}\r\n\r\ncontract Ownable is OwnableData {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice `owner` defaults to msg.sender on construction.\r\n    constructor() {\r\n        owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n    }\r\n\r\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\r\n    /// Can only be invoked by the current `owner`.\r\n    /// @param newOwner Address of the new owner.\r\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\r\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\r\n    function transferOwnership(\r\n        address newOwner,\r\n        bool direct,\r\n        bool renounce\r\n    ) public onlyOwner {\r\n        if (direct) {\r\n            // Checks\r\n            require(newOwner != address(0) || renounce, \"Ownable: zero address\");\r\n\r\n            // Effects\r\n            emit OwnershipTransferred(owner, newOwner);\r\n            owner = newOwner;\r\n            pendingOwner = address(0);\r\n        } else {\r\n            // Effects\r\n            pendingOwner = newOwner;\r\n        }\r\n    }\r\n\r\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\r\n    function claimOwnership() public {\r\n        address _pendingOwner = pendingOwner;\r\n\r\n        // Checks\r\n        require(msg.sender == _pendingOwner, \"Ownable: caller != pending owner\");\r\n\r\n        // Effects\r\n        emit OwnershipTransferred(owner, _pendingOwner);\r\n        owner = _pendingOwner;\r\n        pendingOwner = address(0);\r\n    }\r\n\r\n    /// @notice Only allows the `owner` to execute the function.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n}\r\n\r\ninterface ITreasury {\r\n    function mintRewards( address _recipient, uint _amount ) external;\r\n}\r\n\r\ncontract Distributor is Ownable {\r\n    using LowGasSafeMath for uint;\r\n    using LowGasSafeMath for uint32;\r\n    \r\n    \r\n    \r\n    /* ====== VARIABLES ====== */\r\n\r\n    IERC20 public immutable SIN;\r\n    ITreasury public immutable treasury;\r\n    \r\n    uint32 public immutable epochLength;\r\n    uint32 public nextEpochTime;\r\n    \r\n    mapping( uint => Adjust ) public adjustments;\r\n\r\n    event LogDistribute(address indexed recipient, uint amount);\r\n    event LogAdjust(uint initialRate, uint currentRate, uint targetRate);\r\n    event LogAddRecipient(address indexed recipient, uint rate);\r\n    event LogRemoveRecipient(address indexed recipient);\r\n    \r\n    /* ====== STRUCTS ====== */\r\n        \r\n    struct Info {\r\n        uint rate; // in ten-thousandths ( 5000 = 0.5% )\r\n        address recipient;\r\n    }\r\n    Info[] public info;\r\n    \r\n    struct Adjust {\r\n        bool add;\r\n        uint rate;\r\n        uint target;\r\n    }\r\n    \r\n    \r\n    \r\n    /* ====== CONSTRUCTOR ====== */\r\n\r\n    constructor( address _treasury, address _sin, uint32 _epochLength, uint32 _nextEpochTime ) {        \r\n        require( _treasury != address(0) );\r\n        treasury = ITreasury(_treasury);\r\n        require( _sin != address(0) );\r\n        SIN = IERC20(_sin);\r\n        epochLength = _epochLength;\r\n        nextEpochTime = _nextEpochTime;\r\n    }\r\n    \r\n    \r\n    \r\n    /* ====== PUBLIC FUNCTIONS ====== */\r\n    \r\n    /**\r\n        @notice send epoch reward to staking contract\r\n     */\r\n    function distribute() external returns ( bool ) {\r\n        if ( nextEpochTime <= uint32(block.timestamp) ) {\r\n            nextEpochTime = nextEpochTime.add32( epochLength ); // set next epoch time\r\n            \r\n            // distribute rewards to each recipient\r\n            for ( uint i = 0; i < info.length; i++ ) {\r\n                if ( info[ i ].rate > 0 ) {\r\n                    treasury.mintRewards( // mint and send from treasury\r\n                        info[ i ].recipient, \r\n                        nextRewardAt( info[ i ].rate ) \r\n                    );\r\n                    adjust( i ); // check for adjustment\r\n                }\r\n                emit LogDistribute(info[ i ].recipient, nextRewardAt( info[ i ].rate ));\r\n            }\r\n            return true;\r\n        } else { \r\n            return false; \r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /* ====== INTERNAL FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice increment reward rate for collector\r\n     */\r\n    function adjust( uint _index ) internal {\r\n        Adjust memory adjustment = adjustments[ _index ];\r\n        if ( adjustment.rate != 0 ) {\r\n            uint initial = info[ _index ].rate;\r\n            uint rate = initial;\r\n            if ( adjustment.add ) { // if rate should increase\r\n                rate = rate.add( adjustment.rate ); // raise rate\r\n                if ( rate >= adjustment.target ) { // if target met\r\n                    rate = adjustment.target;\r\n                    delete adjustments[ _index ];\r\n                }\r\n            } else { // if rate should decrease\r\n                rate = rate.sub( adjustment.rate ); // lower rate\r\n                if ( rate <= adjustment.target ) { // if target met\r\n                    rate = adjustment.target;\r\n                    delete adjustments[ _index ];\r\n                }\r\n            }\r\n            info[ _index ].rate = rate;\r\n            emit LogAdjust(initial, rate, adjustment.target);\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    /* ====== VIEW FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice view function for next reward at given rate\r\n        @param _rate uint\r\n        @return uint\r\n     */\r\n    function nextRewardAt( uint _rate ) public view returns ( uint ) {\r\n        return SIN.totalSupply().mul( _rate ).div( 1000000 );\r\n    }\r\n\r\n    /**\r\n        @notice view function for next reward for specified address\r\n        @param _recipient address\r\n        @return uint\r\n     */\r\n    function nextRewardFor( address _recipient ) external view returns ( uint ) {\r\n        uint reward;\r\n        for ( uint i = 0; i < info.length; i++ ) {\r\n            if ( info[ i ].recipient == _recipient ) {\r\n                reward = nextRewardAt( info[ i ].rate );\r\n            }\r\n        }\r\n        return reward;\r\n    }\r\n    \r\n    \r\n    \r\n    /* ====== POLICY FUNCTIONS ====== */\r\n\r\n    /**\r\n        @notice adds recipient for distributions\r\n        @param _recipient address\r\n        @param _rewardRate uint\r\n     */\r\n    function addRecipient( address _recipient, uint _rewardRate ) external onlyOwner {\r\n        require( _recipient != address(0), \"IA\" );\r\n        require(info.length <= 4, \"limit recipients max to 5\");\r\n        info.push( Info({\r\n            recipient: _recipient,\r\n            rate: _rewardRate\r\n        }));\r\n        emit LogAddRecipient(_recipient, _rewardRate);\r\n    }\r\n\r\n    /**\r\n        @notice removes recipient for distributions\r\n        @param _index uint\r\n        @param _recipient address\r\n     */\r\n    function removeRecipient( uint _index, address _recipient ) external onlyOwner {\r\n        require( _recipient == info[ _index ].recipient, \"NA\" );\r\n        info[_index] = info[info.length-1];\r\n        adjustments[_index] = adjustments[ info.length-1 ];\r\n        info.pop();\r\n        delete adjustments[ info.length-1 ];\r\n        emit LogRemoveRecipient(_recipient);\r\n    }\r\n\r\n    /**\r\n        @notice set adjustment info for a collector's reward rate\r\n        @param _index uint\r\n        @param _add bool\r\n        @param _rate uint\r\n        @param _target uint\r\n     */\r\n    function setAdjustment( uint _index, bool _add, uint _rate, uint _target ) external onlyOwner {\r\n        adjustments[ _index ] = Adjust({\r\n            add: _add,\r\n            rate: _rate,\r\n            target: _target\r\n        });\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_sin\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_epochLength\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nextEpochTime\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"LogAddRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"initialRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetRate\",\"type\":\"uint256\"}],\"name\":\"LogAdjust\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"LogRemoveRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SIN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardRate\",\"type\":\"uint256\"}],\"name\":\"addRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adjustments\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochLength\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"info\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEpochTime\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"nextRewardAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"nextRewardFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"removeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_target\",\"type\":\"uint256\"}],\"name\":\"setAdjustment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"renounce\",\"type\":\"bool\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"contract ITreasury\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Distributor", "CompilerVersion": "v0.7.5+commit.eb77ed08", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "000000000000000000000000319ef1897e4220714b3c4814bc4daccfea5eee86000000000000000000000000804a4f2705f7bd08b1d84ae8698014a18c708dbc00000000000000000000000000000000000000000000000000000000000070800000000000000000000000000000000000000000000000000000000062016c30", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a4eafa2015a321d2d62e4abd70696d69fefc4cce190967994f56f8fe06c63fbf"}]}