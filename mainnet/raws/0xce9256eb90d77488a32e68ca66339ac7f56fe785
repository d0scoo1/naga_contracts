{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"FansOnlyCoin.sol\":{\"content\":\"/**\\r\\n *Submitted for verification at Etherscan.io on 2020-06-25\\r\\n*/\\r\\n\\r\\npragma solidity 0.8.1;\\r\\n\\r\\nlibrary SafeMath\\r\\n{\\r\\n\\r\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256)\\r\\n    \\t{\\r\\n\\t\\tuint256 c = a * b;\\r\\n\\t\\tassert(a == 0 || c / a == b);\\r\\n\\r\\n\\t\\treturn c;\\r\\n  \\t}\\r\\n\\r\\n  \\tfunction div(uint256 a, uint256 b) internal pure returns (uint256)\\r\\n\\t{\\r\\n\\t\\tuint256 c = a / b;\\r\\n\\r\\n\\t\\treturn c;\\r\\n  \\t}\\r\\n\\r\\n  \\tfunction sub(uint256 a, uint256 b) internal pure returns (uint256)\\r\\n\\t{\\r\\n\\t\\tassert(b \\u003c= a);\\r\\n\\r\\n\\t\\treturn a - b;\\r\\n  \\t}\\r\\n\\r\\n  \\tfunction add(uint256 a, uint256 b) internal pure returns (uint256)\\r\\n\\t{\\r\\n\\t\\tuint256 c = a + b;\\r\\n\\t\\tassert(c \\u003e= a);\\r\\n\\r\\n\\t\\treturn c;\\r\\n  \\t}\\r\\n}\\r\\n\\r\\ncontract OwnerHelper\\r\\n{\\r\\n  \\taddress public owner;\\r\\n    address public manager;\\r\\n\\r\\n  \\tevent ChangeOwner(address indexed _from, address indexed _to);\\r\\n    event ChangeManager(address indexed _from, address indexed _to);\\r\\n\\r\\n    function setOwner(address to) public {\\r\\n        require(owner == address(0), \\\"Already initalized\\\");\\r\\n        owner = to;\\r\\n    }\\r\\n  \\tmodifier onlyOwner\\r\\n\\t{\\r\\n\\t\\trequire(msg.sender == owner, \\\"Only owner is allowed to perform this action\\\");\\r\\n\\t\\t_;\\r\\n  \\t}\\r\\n  \\t\\r\\n    modifier onlyManager\\r\\n    {\\r\\n        require(msg.sender == manager);\\r\\n        _;\\r\\n    }\\r\\n  \\t\\r\\n  \\tfunction transferOwnership(address _to) onlyOwner public\\r\\n  \\t{\\r\\n    \\trequire(_to != owner);\\r\\n        require(_to != manager);\\r\\n    \\trequire(_to != address(0x0));\\r\\n\\r\\n        address from = owner;\\r\\n      \\towner = _to;\\r\\n  \\t    \\r\\n      \\temit ChangeOwner(from, _to);\\r\\n  \\t}\\r\\n\\r\\n    function transferManager(address _to) onlyOwner public\\r\\n    {\\r\\n        require(_to != owner);\\r\\n        require(_to != manager);\\r\\n        require(_to != address(0x0));\\r\\n        \\r\\n        address from = manager;\\r\\n        manager = _to;\\r\\n        \\r\\n        emit ChangeManager(from, _to);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\n\\r\\n\\r\\ncontract FansOnlyCoin is IERC20, OwnerHelper\\r\\n{\\r\\n    using SafeMath for uint;\\r\\n    \\r\\n    string public name;\\r\\n    uint public decimals;\\r\\n    string public symbol;\\r\\n    \\r\\n    uint  private E18;\\r\\n    uint private month;\\r\\n    \\r\\n    // Team                                   (25%)\\r\\n    uint public vestingScheduleSupply;\\r\\n    uint private vestinglock;\\r\\n\\r\\n    \\r\\n    uint public totalTokenSupply;\\r\\n    uint public tokenIssuedSale;\\r\\n        \\r\\n    uint public burnTokenSupply;\\r\\n    \\r\\n    mapping (address =\\u003e uint) public balances;\\r\\n    mapping (address =\\u003e mapping ( address =\\u003e uint )) public approvals;\\r\\n    \\r\\n    bool public tokenLock;\\r\\n    uint256 lastRun;\\r\\n\\r\\n    event SaleIssue(address indexed _to, uint _tokens);\\r\\n    event SaleIssueLock(uint _tokens);\\r\\n\\r\\n    event Burn(address indexed _from, uint _tokens);\\r\\n    \\r\\n    event TokenUnlock(address indexed _to, uint _tokens);\\r\\n    \\r\\n    function constructor1() public\\r\\n    {\\r\\n        setOwner(msg.sender);\\r\\n        name        = \\\"FansOnlyCoin\\\";\\r\\n        decimals    = 18;\\r\\n        symbol      = \\\"FOC\\\";\\r\\n    \\r\\n        E18 = 1000000000000000000;\\r\\n        month = 2592000;\\r\\n    \\r\\n        vestingScheduleSupply      = 25*10**7 * E18;\\r\\n        totalTokenSupply = 10**9 * E18;\\r\\n        tokenLock = true;\\r\\n        vestinglock=0;\\r\\n        balances[msg.sender] = totalTokenSupply;\\r\\n        require(totalTokenSupply==vestingScheduleSupply*4,\\\"\\\");\\r\\n\\r\\n        tokenIssuedSale     = 0;\\r\\n        burnTokenSupply     = 0;\\r\\n        lastRun=block.timestamp;\\r\\n    }\\r\\n    \\r\\n    function totalSupply() override view public returns (uint) \\r\\n    {\\r\\n        return totalTokenSupply;\\r\\n    }\\r\\n    \\r\\n    function balanceOf(address _who) override view public returns (uint) \\r\\n    {\\r\\n        return balances[_who];\\r\\n    }\\r\\n    \\r\\n    function transfer(address _to, uint _value) override public returns (bool) \\r\\n    {\\r\\n        require(balances[msg.sender]\\u003e=_value,\\\"No enough money\\\");\\r\\n        require(isTransferable() == true);\\r\\n        saleIssueLock();\\r\\n        if(msg.sender!=owner){\\r\\n            require(vestinglock \\u003e 0,\\\"No time to transfer\\\");\\r\\n            require(balances[msg.sender]*vestinglock/4 \\u003e= _value,\\\"Don\\u0027t transfer out of allowed money value\\\");\\r\\n        }\\r\\n        balances[msg.sender] = balances[msg.sender].sub(_value);\\r\\n        balances[_to] = balances[_to].add(_value);\\r\\n        \\r\\n        emit Transfer(msg.sender, _to, _value);\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function approve(address _spender, uint _value) override public returns (bool)\\r\\n    {\\r\\n        require(balances[msg.sender]\\u003e=_value,\\\"No enough money\\\");\\r\\n        require(isTransferable() == true);\\r\\n        saleIssueLock();\\r\\n        require(vestinglock \\u003e 0,\\\"No time to transfer\\\");\\r\\n        require(balances[msg.sender]*vestinglock/4 \\u003e= _value,\\\"Don\\u0027t transfer out of allowed money value\\\");\\r\\n        \\r\\n        approvals[msg.sender][_spender] = _value;                                                                                \\r\\n        \\r\\n        emit Approval(msg.sender, _spender, _value);\\r\\n        \\r\\n        return true; \\r\\n    }\\r\\n    \\r\\n    function allowance(address _owner, address _spender) override view public returns (uint) \\r\\n    {\\r\\n        return approvals[_owner][_spender];\\r\\n    }\\r\\n\\r\\n    function transferFrom(address _from, address _to, uint _value) override public returns (bool) \\r\\n    {\\r\\n        require(balances[_from]\\u003e=_value,\\\"No enough money\\\");\\r\\n        require(isTransferable() == true);\\r\\n        saleIssueLock();\\r\\n        require(vestinglock \\u003e 0,\\\"No time to transfer\\\");\\r\\n        require(balances[_from]*vestinglock/4 \\u003e= _value,\\\"Don\\u0027t transfer out of allowed money value\\\");\\r\\n        require(approvals[_from][msg.sender] \\u003e= _value);\\r\\n        \\r\\n        approvals[_from][msg.sender] = approvals[_from][msg.sender].sub(_value);\\r\\n        balances[_from] = balances[_from].sub(_value);\\r\\n        balances[_to]  = balances[_to].add(_value);\\r\\n        \\r\\n        emit Transfer(_from, _to, _value);\\r\\n        \\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    function saleIssue(address _to) onlyOwner public\\r\\n    {   \\r\\n        require(tokenIssuedSale == 0);    \\r\\n        uint tokens = vestingScheduleSupply;\\r\\n        \\r\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\r\\n\\r\\n        balances[_to] = balances[_to].add(tokens);\\r\\n        \\r\\n        tokenIssuedSale = tokenIssuedSale.add(tokens);\\r\\n        \\r\\n        emit SaleIssue(_to, tokens);\\r\\n    }\\r\\n\\r\\n    function saleIssueLock() public\\r\\n    {   \\r\\n        if(block.timestamp - lastRun-month*vestinglock \\u003e= month){\\r\\n            vestinglock=uint(block.timestamp - lastRun)/month;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function isTransferable() private view returns (bool)\\r\\n    {\\r\\n        if(tokenLock == false)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n        else if(msg.sender == owner)\\r\\n        {\\r\\n            return true;\\r\\n        }\\r\\n        \\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    function setTokenUnlock() onlyManager public\\r\\n    {\\r\\n        require(tokenLock == true);\\r\\n        \\r\\n        tokenLock = false;\\r\\n    }\\r\\n    \\r\\n    function setTokenLock() onlyManager public\\r\\n    {\\r\\n        require(tokenLock == false);\\r\\n        \\r\\n        tokenLock = true;\\r\\n    }\\r\\n    \\r\\n    \\r\\n    function transferAnyERC20Token(address tokenAddress, uint tokens) onlyOwner public returns (bool success)\\r\\n    {\\r\\n        return IERC20(tokenAddress).transfer(manager, tokens);\\r\\n    }\\r\\n    \\r\\n    function burnToken(uint _value) onlyManager public\\r\\n    {\\r\\n        uint tokens = _value * E18;\\r\\n        \\r\\n        require(balances[msg.sender] \\u003e= tokens);\\r\\n        \\r\\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\\r\\n        \\r\\n        burnTokenSupply = burnTokenSupply.add(tokens);\\r\\n        totalTokenSupply = totalTokenSupply.sub(tokens);\\r\\n        \\r\\n        emit Burn(msg.sender, tokens);\\r\\n    }\\r\\n    \\r\\n}\"},\"MyTokenLogic.sol\":{\"content\":\"pragma solidity 0.8.1;\\r\\nimport \\u0027./FansOnlyCoin.sol\\u0027;\\r\\ncontract Proxy {\\r\\n    // Code position in storage is keccak256(\\\"PROXIABLE\\\") = \\\"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\\\"\\r\\n    constructor(bytes memory constructData, address contractLogic) {\\r\\n        // save the code address\\r\\n        assembly { // solium-disable-line\\r\\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, contractLogic)\\r\\n        }\\r\\n        (bool success, bytes memory result ) = contractLogic.delegatecall(constructData); // solium-disable-line\\r\\n        require(success, \\\"Construction failed\\\");\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        assembly { // solium-disable-line\\r\\n            let contractLogic := sload(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7)\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let success := delegatecall(sub(gas(), 10000), contractLogic, 0x0, calldatasize(), 0, 0)\\r\\n            let retSz := returndatasize()\\r\\n            returndatacopy(0, 0, retSz)\\r\\n            switch success\\r\\n            case 0 {\\r\\n                revert(0, retSz)\\r\\n            }\\r\\n            default {\\r\\n                return(0, retSz)\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\ncontract Proxiable {\\r\\n    // Code position in storage is keccak256(\\\"PROXIABLE\\\") = \\\"0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7\\\"\\r\\n\\r\\n    function updateCodeAddress(address newAddress) internal {\\r\\n        require(\\r\\n            bytes32(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7) == Proxiable(newAddress).proxiableUUID(),\\r\\n            \\\"Not compatible\\\"\\r\\n        );\\r\\n        assembly { // solium-disable-line\\r\\n            sstore(0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7, newAddress)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function proxiableUUID() public pure returns (bytes32) {\\r\\n        return 0xc5f16f0fcc639fa48a6947836d9850f504798523bf8c9a3a87d5876cf622bcf7;\\r\\n    }\\r\\n} \\r\\n\\r\\n\\r\\ncontract MyTokenLogic is FansOnlyCoin, Proxiable {\\r\\n\\r\\n    function updateCode(address newCode) public {\\r\\n        updateCodeAddress(newCode);\\r\\n    }\\r\\n}\\r\\n\\r\\n//https://ropsten.etherscan.io/address/0xdb71ee19a6f471c21ecd6ef4c809aaeacc499c98#code\\r\\n//https://ropsten.etherscan.io/address/0xd8a500343789e6e727336898fc9f4cce0767a9e0#code\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"constructData\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"contractLogic\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "Proxy", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000400000000000000000000000008bdb757ace9e0c649e33b4aba75601d37e1f8dcd0000000000000000000000000000000000000000000000000000000000000004473be60400000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a1bd8f7fcdda7e4a77ec34222b241dfb1169282909f446ebc82e995d6b3167dc"}]}