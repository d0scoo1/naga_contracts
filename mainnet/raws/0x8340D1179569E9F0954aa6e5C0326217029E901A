{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MetaAndMagic.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\ncontract MetaAndMagic {\\n\\n    uint256 constant public precision = 1e12;\\n\\n    address heroesAddress;\\n    address itemsAddress;\\n\\n    uint256 public currentBoss;\\n\\n    mapping(uint256 => Heroes) public heroes;\\n    mapping(uint256 => Boss)   public bosses;\\n    mapping(bytes32 => Fight)  public fights;     \\n\\n    mapping(uint256 => uint256) public requests;  \\n    mapping(uint256 => uint256) public prizeValues;\\n    mapping(uint256 => address) public prizeTokens;\\n\\n    // Oracle information\\n    address VRFcoord;\\n    uint64  subId;\\n    bytes32 keyhash;\\n\\n     /*///////////////////////////////////////////////////////////////\\n                            DATA STRUCTURES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    struct Heroes { address owner; uint16 lastBoss; uint32 highestScore;}\\n\\n    struct Fight  { uint16 heroId; uint16 boss; bytes10 items; uint32 start; uint32 count; bool claimedScore; bool claimedBoss; }\\n    \\n    struct Boss   { bytes8 stats; uint16 topScorers; uint56 highestScore; uint56 entries; uint56 winIndex; }\\n\\n    struct Combat { uint256 hp; uint256 phyDmg; uint256 mgkDmg; uint256 phyRes; uint256 mgkRes; }\\n\\n    enum Stat { HP, PHY_DMG, MGK_DMG, MGK_RES, MGK_PEN, PHY_RES, PHY_PEN, ELM }\\n\\n    event FightResult(address sender, uint256 hero, uint256 boss, bytes10 items, uint256 score, bytes32 id);\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n        @dev Initialize contract \\n    */\\n    function initialize(address heroes_, address items_) external {\\n        require(msg.sender == _owner());\\n\\n        heroesAddress = heroes_;\\n        itemsAddress  = items_;\\n    }\\n\\n    /**\\n        @dev Initialize oracle information \\n    */\\n    function setUpOracle(address vrf_, bytes32 keyHash, uint64 subscriptionId) external {\\n        require(msg.sender == _owner());\\n\\n        VRFcoord = vrf_;\\n        keyhash  = keyHash;\\n        subId    = subscriptionId;\\n    }\\n\\n    /**\\n        @dev Add next week boss and move it \\n    */\\n    function addBoss(address prizeToken, uint256 halfPrize, uint256 hp_, uint256 atk_, uint256 mgk_, uint256 mod_, uint256 element_) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n        uint256 boss = currentBoss + 1;\\n\\n        prizeValues[boss] = halfPrize;\\n        prizeTokens[boss] = prizeToken;\\n\\n        bosses[boss] = Boss({stats: bytes8(abi.encodePacked(uint16(hp_),uint16(atk_),uint16(mgk_), uint8(element_), uint8(mod_))), topScorers:0, highestScore: 0, entries:0, winIndex:0});\\n    }\\n\\n    function moveBoss() external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        require(bosses[currentBoss + 1].stats != bytes8(0), \\\"not set\\\");\\n\\n        currentBoss++;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STAKING FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n        @dev Stake and or unstake a list of heroes\\n    */\\n    function manageHero(uint256[] calldata toStake, uint256[] calldata toUnstake) external {\\n        uint256 len = toStake.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            stake(toStake[i]);\\n        }\\n\\n        len = toUnstake.length;\\n        for (uint256 i = 0; i < len; i++) {\\n            unstake(toUnstake[i]);\\n        }\\n    }\\n\\n    /**\\n        @dev Stake a single hero \\n    */\\n    function stake(uint256 heroId) public {\\n        require(currentBoss != 0, \\\"not started\\\");\\n        _pull(heroesAddress, heroId);\\n        heroes[heroId] = Heroes(msg.sender, 0, 0);\\n    }\\n\\n    /**\\n        @dev Unstake a single hero \\n    */\\n    function unstake(uint256 heroId) public {\\n        Heroes memory hero = heroes[heroId];\\n\\n        require(msg.sender == hero.owner,   \\\"not owner\\\");\\n        require(hero.lastBoss < currentBoss,\\\"alredy entered\\\");\\n        // transfer NFT\\n        _push(heroesAddress, hero.owner, heroId);\\n\\n        delete heroes[heroId];\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            FIGHT FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n        @dev Fight this week's boss\\n    */\\n    function fight(uint256 heroId, bytes10 items) public returns(bytes32 fightId) {\\n        Heroes memory hero = heroes[heroId];\\n        require(msg.sender == hero.owner, \\\"not owner\\\");\\n\\n        _validateItems(items);\\n\\n        uint256 currBoss = currentBoss;\\n        Boss memory boss = bosses[currBoss];\\n\\n        require(boss.stats != bytes8(0), \\\"invalid boss\\\");\\n\\n        uint256 score = _calculateScore(currBoss, boss.stats, heroId, items, msg.sender);\\n\\n        if (hero.lastBoss < currBoss) {\\n            hero.lastBoss     = uint16(currBoss);\\n            hero.highestScore = 0;\\n        }\\n\\n        fightId = getFightId(heroId, currBoss, items, msg.sender);\\n        require(fights[fightId].heroId == 0, \\\"already fought\\\");\\n\\n        Fight memory fh = Fight(uint16(heroId), uint16(currBoss), items, 0, 0, false, false);\\n\\n        if (score == boss.highestScore) boss.topScorers++; // Tied to the highest score;\\n        \\n        // This is a new highscore, so we reset the leaderboard\\n        if (score > boss.highestScore) {\\n            boss.highestScore = uint32(score);\\n            boss.topScorers   = 1;\\n        }\\n\\n        // Getting Raffle tickets\\n        if (score > hero.highestScore) {\\n            uint32 diff = uint32(score - hero.highestScore);  \\n\\n            fh.start = uint32(boss.entries) + 1;\\n            fh.count = diff;\\n\\n            boss.entries += diff;            \\n            hero.highestScore = uint32(score);\\n        }\\n\\n        bosses[currBoss] = boss;\\n        heroes[heroId]   = hero;\\n        fights[fightId]  = fh;\\n\\n        emit FightResult(msg.sender, heroId, currBoss, items, score, fightId);\\n    }\\n\\n    /**\\n        @dev Get the boss drop item from this week \\n    */\\n    function getBossDrop(uint256 heroId_, uint boss_, bytes10 items_) external returns (uint256 bossItemId){\\n        bytes32 fightId = getFightId(heroId_, boss_, items_, msg.sender);\\n\\n        Fight memory fh = fights[fightId];\\n\\n        require(fh.boss == currentBoss, \\\"claim over\\\");\\n        require(fh.heroId != 0,         \\\"non existent fight\\\");\\n        require(!fh.claimedBoss,        \\\"already claimed\\\");\\n\\n        uint256 score = _calculateScore(fh.boss, bosses[fh.boss].stats, fh.heroId, fh.items, msg.sender);\\n        require(score > 0, \\\"not won\\\");\\n\\n        uint16[5] memory _items = _unpackItems(fh.items);\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (_items[i] == 0) break;\\n            // Burn the item  if it's not burnt already\\n            if (IERC721(itemsAddress).ownerOf(_items[i]) != address(0)) require(MetaAndMagicLike(itemsAddress).burnFrom(msg.sender, _items[i]), \\\"burn failed\\\");\\n        }\\n\\n        fights[fightId].claimedBoss = true;\\n        // Boss drops supplies are checked at the itemsAddress\\n        bossItemId = MetaAndMagicLike(fh.boss == 10 ? heroesAddress : itemsAddress).mintDrop(boss_, msg.sender);\\n    }\\n\\n    /**\\n        @dev Get the prize for having the highest score\\n    */\\n    function getPrize(uint256 heroId_, uint256 boss_, bytes10 items_) external {\\n        bytes32 fightId = getFightId(heroId_, boss_, items_, msg.sender);\\n        \\n        Fight memory fh   = fights[fightId];\\n        Boss  memory boss = bosses[fh.boss];\\n\\n        require(fh.boss < currentBoss, \\\"not finished\\\");\\n        require(!fh.claimedScore,      \\\"already claimed\\\");\\n    \\n        uint256 score  = _calculateScore(fh.boss, boss.stats, fh.heroId, fh.items, msg.sender);\\n\\n        require(score == boss.highestScore && boss.highestScore != 0, \\\"not high score\\\");\\n\\n        fights[fightId].claimedScore = true;\\n\\n        require(IERC20(prizeTokens[fh.boss]).transfer(msg.sender, prizeValues[fh.boss] / boss.topScorers));\\n    }\\n\\n    /**\\n        @dev Get the raffle prize\\n    */\\n    function getRafflePrize(uint256 heroId_, uint256 boss_, bytes10 items_) external {\\n        bytes32 fightId = getFightId(heroId_, boss_, items_, msg.sender);\\n        \\n        Fight memory fh   = fights[fightId];\\n        Boss  memory boss = bosses[fh.boss];\\n\\n        require(fh.boss < currentBoss, \\\"not finished\\\");\\n        require(boss.highestScore > 0, \\\"not fought\\\");\\n        require(boss.winIndex != 0,    \\\"not raffled\\\");\\n\\n        require(fh.start <= boss.winIndex && (fh.start + fh.count > boss.winIndex), \\\"not winner\\\");\\n\\n        fights[fightId].count = 0;\\n        require(IERC20(prizeTokens[fh.boss]).transfer(msg.sender, prizeValues[fh.boss]));\\n    }\\n\\n    /**\\n        @dev Request chainlink oracle for the week's raffle\\n    */\\n    function requestRaffleResult(uint256 boss_) external {\\n        require(boss_ < currentBoss,  \\\"not finished\\\");\\n        require(requests[boss_] == 0 || msg.sender == _owner(), \\\"already requested\\\");\\n\\n        uint256 reqId = VRFCoordinatorV2Interface(VRFcoord).requestRandomWords(keyhash, subId, 3, 200000, 1);\\n        requests[boss_] = reqId;\\n    }\\n\\n    /**\\n        @dev Chainlink specific function to fulfill the randomness request \\n    */\\n    function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n        require(msg.sender == VRFcoord, \\\"not allowed\\\");\\n        for (uint256 index = currentBoss; index > 0; index--) {\\n            if (requests[index] == requestId) {\\n                Boss memory boss = bosses[index];\\n\\n                bosses[index].winIndex = uint56(randomWords[0] % uint256(boss.entries) + 1); // 1 -> raffleEntry\\n            }\\n        }\\n   }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function getScore(bytes32 fightId, address player) external view returns(uint256 score) {\\n        Fight memory fh   = fights[fightId];\\n        require(fh.boss != 0);\\n        score = _calculateScore(fh.boss, bosses[fh.boss].stats, fh.heroId, fh.items,player);\\n    }\\n\\n    function getFightId(uint256 hero_, uint256 boss_, bytes10 items_, address owner_) public pure returns (bytes32 id) {\\n        id = keccak256(abi.encode(hero_, boss_, items_, owner_));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _calculateScore(uint256 boss, bytes8 bossStats, uint256 heroId, bytes10 packedItems, address fighter) internal view virtual returns (uint256) {\\n        bytes10[6] memory stats = MetaAndMagicLike(heroesAddress).getStats(heroId);\\n\\n        // Start with empty combat\\n        Combat memory combat = Combat(0,0,0,precision,precision);\\n        \\n        // Tally Hero modifies the combat memory inplace\\n        _tally(combat, stats, bossStats);\\n\\n        uint16[5] memory items_ = _unpackItems(packedItems);\\n        for (uint256 i = 0; i < 5; i++) {\\n            if (items_[i] == 0) break;\\n            stats = MetaAndMagicLike(itemsAddress).getStats(items_[i]);\\n            _tally(combat, stats, bossStats);\\n        }\\n        \\n        uint256 crit = _critical(heroId,boss,packedItems,fighter);\\n        return _getResult(combat, bossStats, crit);\\n    }\\n\\n    function _getResult(Combat memory combat, bytes10 bossStats, uint256 crit) internal pure returns (uint256) {        \\n        uint256 bossAtk         = combat.phyRes * _get(bossStats, Stat.PHY_DMG) / precision;\\n        uint256 bossMgk         = combat.mgkRes * _get(bossStats, Stat.MGK_DMG) / precision;\\n        uint256 totalHeroAttack = combat.phyDmg + combat.mgkDmg + ((combat.phyDmg + combat.mgkDmg) * crit / 1e18);\\n        \\n        if (bossAtk + bossMgk > combat.hp || totalHeroAttack < _get(bossStats, Stat.HP)) return 0;\\n\\n        return totalHeroAttack - _get(bossStats, Stat.HP) + combat.hp - bossAtk + bossMgk;\\n    }\\n\\n     /// @dev This is the core function for calculating scores\\n    function _tally(Combat memory combat, bytes10[6] memory stats , bytes8 bossStats) internal pure {\\n        uint256 bossPhyPen = _get(bossStats, Stat.PHY_PEN);\\n        uint256 bossMgkPen = _get(bossStats, Stat.MGK_PEN);\\n        bool    bossPhyRes = _get(bossStats, Stat.PHY_RES) == 1;\\n        bool    bossMgkRes = _get(bossStats, Stat.MGK_RES) == 1;\\n\\n        uint256 itemElement = _get(stats[5], Stat.ELM);\\n        uint256 bossElement = uint8(uint64(bossStats) >> 8);\\n\\n        for (uint256 i = 0; i < 6; i++) {\\n            // Sum HP\\n            combat.hp += _get(stats[i], Stat.HP);\\n\\n            combat.phyDmg += _sumAtk(stats[i], Stat.PHY_DMG, Stat.PHY_PEN, bossPhyRes);\\n\\n            uint256 mgk = _sumAtk(stats[i], Stat.MGK_DMG, Stat.MGK_PEN, bossMgkRes);\\n            uint256 adv = _getAdv(itemElement, bossElement);\\n\\n            combat.mgkDmg += adv == 3 ?  0 : mgk * (adv == 1 ? 2 : 1) / (adv == 2 ? 2 : 1);\\n\\n            combat.phyRes = _stack(combat.phyRes, stats[i], Stat.PHY_RES, bossPhyPen);\\n            combat.mgkRes = _stack(combat.mgkRes, stats[i], Stat.MGK_RES, bossMgkPen);\\n\\n            combat.mgkRes = stackElement(combat.mgkRes, itemElement, bossElement);\\n        }\\n    }      \\n\\n    function _critical(uint256 hero_, uint256 boss_, bytes10 items_, address fighter) internal pure returns (uint256 draw) {\\n        draw = uint256(getFightId(hero_, boss_, items_, fighter)) % 0.25e18 + 1;\\n    }\\n\\n    function _get(bytes10 src, Stat stat) internal pure returns (uint256) {\\n        uint8 st = uint8(stat);\\n\\n        if (st == 7) return uint8(uint80(src)); // Element\\n        if (st < 3)  return uint16(bytes2(src << (st * 16))); // Hp, PhyDmg or MgkDmg\\n\\n        return (uint16(bytes2(src << (48))) & (1 << st - 3)) >> st - 3;\\n    }\\n\\n    function _getAdv(uint256 ele, uint256 oppEle) internal pure returns (uint256 adv) {\\n        // Returns 0 if elements don't iteract\\n        if (ele == 0 || oppEle == 0) return 0;\\n\\n        // Returns 1 if ele has advantage\\n        if (ele == oppEle - 1 || (ele == 4 && oppEle == 1)) return adv = 1;\\n        // // Returns 2 if ele has disavantage\\n        if (ele - 1 == oppEle || (ele == 1 && oppEle == 4)) return adv = 2;\\n        // Returns 3 if ele is the same\\n        if (ele == oppEle) return adv = 3;\\n    }\\n\\n    function stackElement(uint256 val, uint256 ele, uint256 oppEle) internal pure returns (uint256) {\\n        uint256 adv = _getAdv(ele, oppEle);\\n        if (adv == 0) return val;\\n\\n        if (adv == 3) return 0;\\n\\n        if (adv == 1) return val * precision / (2 * precision);\\n\\n        return val * 2 * precision / precision;\\n    }\\n\\n    function _sumAtk(bytes10 src, Stat stat, Stat pen, bool bossRes) internal pure returns (uint256 sum) {\\n        sum  = _get(src, stat) / (((_get(src, pen) == 0) && bossRes) ? 2 : 1);\\n    }\\n\\n    function _stack(uint256 val, bytes10 src, Stat res, uint256 oppPen) internal pure returns (uint256) {\\n        return _stack(val, _get(src, res), oppPen);\\n    }\\n\\n    function _stack(uint256 val, uint256 res, uint256 oppPen) internal pure returns (uint256 ret) {\\n        ret = val * ((oppPen == 0) && (res == 1) ? 0.5e12: precision) / precision;\\n    }\\n\\n    function _getPackedItems(uint16[5] memory items) internal pure returns(bytes10 packed) {\\n        packed = bytes10(abi.encodePacked(items[0], items[1], items[2], items[3], items[4]));\\n    }\\n\\n    function _validateItems(bytes10 packedItems) internal view {\\n        uint16[5] memory items = _unpackItems(packedItems);\\n        \\n        for (uint256 i = 1; i < items.length; i++) {\\n            require(items[i - 1] == 0 ? items[i] == 0 : items[i - 1] > items[i], \\\"invalid items\\\"); \\n            if (items[i] != 0) require(IERC721(itemsAddress).ownerOf(items[i]) == msg.sender, \\\"not item owner\\\");\\n        }\\n    }\\n\\n    function _unpackItems(bytes10 items) internal pure returns(uint16[5] memory unpacked) {\\n        unpacked[0] = uint16(bytes2(items));\\n        unpacked[1] = uint16(bytes2(items << 16));\\n        unpacked[2] = uint16(bytes2(items << 32));\\n        unpacked[3] = uint16(bytes2(items << 48));\\n        unpacked[4] = uint16(bytes2(items << 64));\\n    }\\n\\n    function _pull(address token, uint256 id) internal {\\n        require(IERC721(token).transferFrom(msg.sender, address(this), id), \\\"failed transfer\\\");\\n    }\\n\\n    function _push(address token, address to_, uint256 id) internal {\\n        require(IERC721(token).transferFrom(address(this), address(to_), id), \\\"transfer failed\\\");\\n    }\\n\\n    function _owner() internal view returns (address owner_) {\\n        bytes32 slot = bytes32(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\\n        assembly {\\n            owner_ := sload(slot)\\n        }\\n    } \\n}\\n\\ninterface MetaAndMagicLike {\\n    function getStats(uint256 id_) external view returns(bytes10[6] memory stats);\\n    function mintDrop(uint256 bossId, address to_) external returns(uint256 id);\\n    function burnFrom(address from, uint256 id) external returns (bool);\\n}\\n\\ninterface IERC721 {\\n    function transferFrom(address from_, address to_, uint256 id_) external returns(bool);\\n    function ownerOf(uint256 id) external view returns(address);\\n}\\n\\ninterface IERC20 {\\n    function transfer(address to_, uint256 id_) external returns(bool);\\n}\\n\\ninterface VRFCoordinatorV2Interface {\\n    function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"hero\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"boss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes10\",\"name\":\"items\",\"type\":\"bytes10\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"FightResult\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"prizeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"halfPrize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hp_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"atk_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mgk_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mod_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"element_\",\"type\":\"uint256\"}],\"name\":\"addBoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bosses\",\"outputs\":[{\"internalType\":\"bytes8\",\"name\":\"stats\",\"type\":\"bytes8\"},{\"internalType\":\"uint16\",\"name\":\"topScorers\",\"type\":\"uint16\"},{\"internalType\":\"uint56\",\"name\":\"highestScore\",\"type\":\"uint56\"},{\"internalType\":\"uint56\",\"name\":\"entries\",\"type\":\"uint56\"},{\"internalType\":\"uint56\",\"name\":\"winIndex\",\"type\":\"uint56\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBoss\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"},{\"internalType\":\"bytes10\",\"name\":\"items\",\"type\":\"bytes10\"}],\"name\":\"fight\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"fightId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fights\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"heroId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"boss\",\"type\":\"uint16\"},{\"internalType\":\"bytes10\",\"name\":\"items\",\"type\":\"bytes10\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"count\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"claimedScore\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"claimedBoss\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boss_\",\"type\":\"uint256\"},{\"internalType\":\"bytes10\",\"name\":\"items_\",\"type\":\"bytes10\"}],\"name\":\"getBossDrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bossItemId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"hero_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boss_\",\"type\":\"uint256\"},{\"internalType\":\"bytes10\",\"name\":\"items_\",\"type\":\"bytes10\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"getFightId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boss_\",\"type\":\"uint256\"},{\"internalType\":\"bytes10\",\"name\":\"items_\",\"type\":\"bytes10\"}],\"name\":\"getPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"boss_\",\"type\":\"uint256\"},{\"internalType\":\"bytes10\",\"name\":\"items_\",\"type\":\"bytes10\"}],\"name\":\"getRafflePrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"fightId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"score\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"heroes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"lastBoss\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"highestScore\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"heroes_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"items_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"toStake\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"toUnstake\",\"type\":\"uint256[]\"}],\"name\":\"manageHero\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moveBoss\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"precision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prizeTokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"prizeValues\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boss_\",\"type\":\"uint256\"}],\"name\":\"requestRaffleResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requests\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vrf_\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"}],\"name\":\"setUpOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"heroId\",\"type\":\"uint256\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MetaAndMagic", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}