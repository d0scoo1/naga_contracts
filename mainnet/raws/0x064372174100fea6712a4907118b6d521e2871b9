{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.4;\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC1155 is IERC165 {\r\n\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\nabstract contract ERC1155Receiver is ERC165, IERC1155Receiver {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n}\r\n\r\ncontract ERC1155Holder is ERC1155Receiver {\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n\r\n    function onERC1155BatchReceived(\r\n        address,\r\n        address,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC1155BatchReceived.selector;\r\n    }\r\n}\r\ninterface IERC721 is IERC165 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n    function approve(address to, uint256 tokenId) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\ninterface IERC721Enumerable is IERC721 {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\r\n    function tokenByIndex(uint256 index) external view returns (uint256);\r\n}\r\ninterface IERC721Receiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\ncontract ERC721Holder is IERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) public virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n}\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\ncontract Staking is ERC721Holder, ERC1155Holder, Ownable {\r\n    address public whaleMakerAddress = 0xA87121eDa32661C0c178f06F8b44F12f80ae4E88;\r\n    address public alphaPassAddress = 0xABC550e4Bff18e37c04083dCae2AcF77B6bE6CAd;\r\n    address public podAddress = 0x5B3E42382C3AaAd8Ff9e106664E362C308CBa3BC;\r\n    address public stakeMasterAddress = 0xDBef1bbCb494fAcd6cD1BF426e25dA7A10d96eAa;\r\n    address nullAddress = 0x0000000000000000000000000000000000000000;\r\n\r\n    uint256 public maxWalletStaked = 10;\r\n\r\n    uint256 public contractPublishedAt = block.timestamp;\r\n\r\n    // Mapping of WHALE/ALPHA TokenId to timestamp\r\n    mapping(uint256 => uint256) public tokenIdToStakeTime;\r\n    mapping(uint256 => uint256) public tokenIdToLastClaimTime;\r\n\r\n    // Mapping of WHALE/ALPHA TokenId to staker\r\n    mapping(uint256 => address) _tokenIdToStaker;\r\n\r\n    // Mapping of staker to WHALE/ALPHA TokenIds\r\n    mapping(address => uint256[]) _stakerToTokenIds;\r\n\r\n    uint256[] private _stakedTokenIds;\r\n\r\n    uint256 public claimStartTime = 1672531199; // Dec 31 2022 11:59:59 PM\r\n\r\n    /**\r\n     * [ Dec 31 2022 11:59:59 PM, Dec 31 2023 11:59:59 PM, Dec 31 2024 11:59:59 PM, Dec 31 2025 11:59:59 PM, Dec 31 2026 11:59:59 PM, Dec 31 2027 11:59:59 PM, Dec 31 2031 11:59:59 PM ]\r\n    */\r\n    uint256[] public rewardsStepsTimestamp = [1672531199, 1704067199, 1735689599, 1767225599, 1798761599, 1830297599, 1956527999]; \r\n    mapping(uint256 => uint256) public rewardsStepsMonthlyAmount;\r\n\r\n    constructor() {\r\n        rewardsStepsMonthlyAmount[1672531199] = 4500; // Till Dec 31 2022 11:59:59 PM\r\n        rewardsStepsMonthlyAmount[1704067199] = 3500;\r\n        rewardsStepsMonthlyAmount[1735689599] = 2500;\r\n        rewardsStepsMonthlyAmount[1767225599] = 1500;\r\n        rewardsStepsMonthlyAmount[1798761599] = 1000;\r\n        rewardsStepsMonthlyAmount[1830297599] = 500;\r\n        rewardsStepsMonthlyAmount[1956527999] = 250;\r\n    }\r\n\r\n    function stakedTokenIds() public view returns (uint256[] memory) {\r\n        return _stakedTokenIds;\r\n    }\r\n\r\n    function getTokensStaked(address staker) public view returns (uint256[] memory) {\r\n        return _stakerToTokenIds[staker];\r\n    }\r\n\r\n    function _remove(address staker, uint256 index) internal {\r\n        if (index >= _stakerToTokenIds[staker].length) return;\r\n\r\n        for (uint256 i=index; i<_stakerToTokenIds[staker].length-1; i++) {\r\n            _stakerToTokenIds[staker][i] = _stakerToTokenIds[staker][i + 1];\r\n        }\r\n        _stakerToTokenIds[staker].pop();\r\n    }\r\n\r\n    function _removeTokenIdFromStaker(address staker, uint256 tokenId) internal {\r\n        for (uint256 i=0; i<_stakerToTokenIds[staker].length; i++) {\r\n            if (_stakerToTokenIds[staker][i] == tokenId) {\r\n                //This is the tokenId to remove;\r\n                _remove(staker, i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _removeItem(uint256 index) internal {\r\n        if (index >= _stakedTokenIds.length) return;\r\n        for (uint256 i=index; i<_stakedTokenIds.length-1; i++) {\r\n            _stakedTokenIds[i] = _stakedTokenIds[i+1];\r\n        }\r\n        _stakedTokenIds.pop();\r\n    }\r\n\r\n    function _removeStakedTokenId(uint256 tokenId) internal {\r\n        for (uint256 i=0; i<_stakedTokenIds.length; i++) {\r\n            if (_stakedTokenIds[i] == tokenId) {\r\n                _removeStakedTokenId(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _calculateRewardsById(uint256 tokenId) internal view returns (uint256) {\r\n        require (_tokenIdToStaker[tokenId] != nullAddress, \"NOT_STAKED_TOKEN\");\r\n        uint256 rewards = 0;\r\n        uint256 staked_days; // The token staked days in this step\r\n        uint256 startTs = tokenIdToLastClaimTime[tokenId] + 1; // The timestamp that the step started\r\n        for (uint256 i=0; i<rewardsStepsTimestamp.length; i++) {\r\n            if (rewardsStepsTimestamp[i] < block.timestamp) {\r\n                if (tokenIdToStakeTime[tokenId] < rewardsStepsTimestamp[i]) { // if token was staked in the step\r\n                    staked_days = (rewardsStepsTimestamp[i] - startTs) / 86400; \r\n                    rewards = rewards + staked_days * rewardsStepsMonthlyAmount[rewardsStepsTimestamp[i]] * 10 ** 18 / 30;\r\n                    startTs = rewardsStepsTimestamp[i] + 1;\r\n                }\r\n            } else { // the current step\r\n                staked_days = block.timestamp - startTs;\r\n                rewards = rewards + staked_days * rewardsStepsMonthlyAmount[rewardsStepsTimestamp[i]] * 10 ** 18 / 30;\r\n                break; // Ignore the next steps\r\n            }\r\n        }\r\n        return rewards;\r\n    }\r\n\r\n    function stakeByIds(uint256[] memory tokenIds) public {\r\n        require(_stakerToTokenIds[msg.sender].length + tokenIds.length <= maxWalletStaked, \"EXCEED_MAX_WALLET_STAKED\");\r\n        for (uint256 i=0; i<tokenIds.length; i++) {\r\n            require(\r\n                IERC721(whaleMakerAddress).ownerOf(tokenIds[i]) == msg.sender && IERC1155(alphaPassAddress).balanceOf(msg.sender, tokenIds[i]) > 0 && _tokenIdToStaker[tokenIds[i]] == nullAddress,\r\n                \"NOT_BOTH_TOKEN_OWNER\"\r\n            );\r\n            IERC721(whaleMakerAddress).safeTransferFrom(msg.sender, stakeMasterAddress, tokenIds[i]);\r\n            IERC1155(alphaPassAddress).safeTransferFrom(msg.sender, stakeMasterAddress, tokenIds[i], 1, \"\");\r\n            _stakerToTokenIds[msg.sender].push(tokenIds[i]);\r\n            tokenIdToStakeTime[tokenIds[i]] = block.timestamp;\r\n            tokenIdToLastClaimTime[tokenIds[i]] = block.timestamp;\r\n            _tokenIdToStaker[tokenIds[i]] = msg.sender;\r\n            _stakedTokenIds.push(tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    function _unstakeTokenId(uint256 tokenId) internal {\r\n        IERC721(whaleMakerAddress).safeTransferFrom(stakeMasterAddress, msg.sender, tokenId);\r\n        IERC1155(alphaPassAddress).safeTransferFrom(stakeMasterAddress, msg.sender, tokenId, 1, \"\");\r\n        _removeTokenIdFromStaker(msg.sender, tokenId);\r\n        _removeStakedTokenId(tokenId);\r\n        _tokenIdToStaker[tokenId] = nullAddress;\r\n    }\r\n    \r\n    function unstakeByIds(uint256[] memory tokenIds) public {\r\n        require(claimStartTime < block.timestamp, \"DISABLED_CLIAM\");\r\n        // Get Total Rewards\r\n        uint256 totalRewards = 0;\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            require(_tokenIdToStaker[tokenIds[i]] == msg.sender, \"NOT_VALID_STAKER\");\r\n            totalRewards = totalRewards + _calculateRewardsById(tokenIds[i]);\r\n        }\r\n        \r\n        require(totalRewards < IERC20(podAddress).balanceOf(stakeMasterAddress), \"NOT_ENOUGH_BALANCE_ON_CONTRACT\");\r\n\r\n        // Unstake all Whale/AP tokens\r\n        for (uint256 i=0; i<tokenIds.length; i++) {\r\n            _unstakeTokenId(tokenIds[i]);\r\n        }\r\n\r\n        // Transfer rewards\r\n        IERC20(podAddress).transferFrom(stakeMasterAddress, msg.sender, totalRewards);\r\n    }\r\n\r\n    function unstakeAll() public {\r\n        require(_stakerToTokenIds[msg.sender].length > 0, \"ZERO_STAKED_TOKEN\");\r\n        unstakeByIds(_stakerToTokenIds[msg.sender]);\r\n    }\r\n\r\n    function claimByTokenIds(uint256[] memory tokenIds) public {\r\n        require(claimStartTime < block.timestamp, \"DISABLED_CLIAM\");\r\n        // Get Total Claim ammount\r\n        uint256 totalRewards = 0;\r\n        for (uint256 i=0; i<tokenIds.length; i++) {\r\n            require(_tokenIdToStaker[tokenIds[i]] == msg.sender, \"NOT_VALID_STAKER\");\r\n            totalRewards = totalRewards + _calculateRewardsById(tokenIds[i]);\r\n        }\r\n        \r\n        require(totalRewards < IERC20(podAddress).balanceOf(stakeMasterAddress), \"NOT_ENOUGH_BALANCE_ON_CONTRACT\");\r\n        IERC20(podAddress).transferFrom(stakeMasterAddress, msg.sender, totalRewards);\r\n\r\n        for (uint256 i=0; i<tokenIds.length; i++) {\r\n            tokenIdToLastClaimTime[tokenIds[i]] = block.timestamp;\r\n        }\r\n    }\r\n\r\n    function claimAll() public {\r\n        require(_stakerToTokenIds[msg.sender].length > 0, \"ZERO_STAKED_TOKEN\");\r\n        claimByTokenIds(_stakerToTokenIds[msg.sender]);\r\n    }\r\n\r\n    function getAllRewards(address staker) public view returns (uint256) {\r\n        uint256[] memory tokenIds = _stakerToTokenIds[staker];\r\n        uint256 totalRewards = 0;\r\n        for (uint256 i=0; i<tokenIds.length; i++) {\r\n            totalRewards = totalRewards + _calculateRewardsById(tokenIds[i]);\r\n        }\r\n        return totalRewards;\r\n    }\r\n\r\n    function getRewardsByTokenId(uint256 tokenId) public view returns (uint256) {\r\n        require(_tokenIdToStaker[tokenId] != nullAddress, \"Token is not staked!\");\r\n        return _calculateRewardsById(tokenId);\r\n    }\r\n\r\n    function getStaker(uint256 tokenId) public view returns (address) {\r\n        return _tokenIdToStaker[tokenId];\r\n    }\r\n    \r\n    function setWhaleMakerAddress(address newAddress) public onlyOwner {\r\n        whaleMakerAddress = newAddress;\r\n    }\r\n    function setAlphaPassAddress(address newAddress) public onlyOwner {\r\n        alphaPassAddress = newAddress;\r\n    }\r\n    function setPodAddress(address newAddress) public onlyOwner {\r\n        podAddress = newAddress;\r\n    }\r\n    function setStakeMasterAddress(address newAddress) public onlyOwner {\r\n        stakeMasterAddress = newAddress;\r\n    }\r\n    function setMaxWalletStaked(uint256 newValue) public onlyOwner {\r\n        maxWalletStaked = newValue;\r\n    }\r\n    function setClaimStartTime(uint256 newClaimStartTime) public onlyOwner {\r\n        claimStartTime = newClaimStartTime;\r\n    }\r\n    function withdrawETH() external onlyOwner {\r\n        require(address(this).balance > 0, \"NO_BALANCE\");\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"alphaPassAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claimByTokenIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractPublishedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getAllRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRewardsByTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"}],\"name\":\"getTokensStaked\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWalletStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"podAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsStepsMonthlyAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardsStepsTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setAlphaPassAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newClaimStartTime\",\"type\":\"uint256\"}],\"name\":\"setClaimStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletStaked\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setPodAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setStakeMasterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"setWhaleMakerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeMasterAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToLastClaimTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToStakeTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeByIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whaleMakerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3bd1151d855440c4ef4b5ab85b0c442677f4a5d87ce0e8d40ac0d316e37f154e"}]}