{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lending/Vault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n//import \\\"../_external/IWETH.sol\\\";\\n\\nimport \\\"../IUSDI.sol\\\";\\nimport \\\"./IVault.sol\\\";\\nimport \\\"./IVaultController.sol\\\";\\n\\nimport \\\"../_external/CompLike.sol\\\";\\nimport \\\"../_external/IERC20.sol\\\";\\nimport \\\"../_external/Context.sol\\\";\\nimport \\\"../_external/openzeppelin/SafeERC20Upgradeable.sol\\\";\\n\\n/// @title Vault\\n/// @notice our implentation of maker-vault like vault\\n/// major differences:\\n/// 1. multi-collateral\\n/// 2. generate interest in USDi\\n/// 3. can delegate voting power of contained tokens\\ncontract Vault is IVault, Context {\\n  using SafeERC20Upgradeable for IERC20;\\n\\n  /// @title VaultInfo struct\\n  /// @notice this struct is used to store the vault metadata\\n  /// this should reduce the cost of minting by ~15,000\\n  /// by limiting us to max 2**96-1 vaults\\n  struct VaultInfo {\\n    uint96 id;\\n    address minter;\\n  }\\n  /// @notice Metadata of vault, aka the id & the minter's address\\n  VaultInfo public _vaultInfo;\\n  IVaultController public immutable _controller;\\n\\n  /// @notice this is the unscaled liability of the vault.\\n  /// the number is meaningless on its own, and must be combined with the factor taken from\\n  /// the vaultController in order to find the true liabilitiy\\n  uint256 public _baseLiability;\\n\\n  /// @notice checks if _msgSender is the controller of the vault\\n  modifier onlyVaultController() {\\n    require(_msgSender() == address(_controller), \\\"sender not VaultController\\\");\\n    _;\\n  }\\n\\n  /// @notice checks if _msgSender is the minter of the vault\\n  modifier onlyMinter() {\\n    require(_msgSender() == _vaultInfo.minter, \\\"sender not minter\\\");\\n    _;\\n  }\\n\\n  /// @notice must be called by VaultController, else it will not be registered as a vault in system\\n  /// @param id_ unique id of the vault, ever increasing and tracked by VaultController\\n  /// @param minter_ address of the person who created this vault\\n  /// @param controller_address address of the VaultController\\n  constructor(\\n    uint96 id_,\\n    address minter_,\\n    address controller_address\\n  ) {\\n    _vaultInfo = VaultInfo(id_, minter_);\\n    _controller = IVaultController(controller_address);\\n  }\\n\\n  /// @notice minter of the vault\\n  /// @return address of minter\\n  function minter() external view override returns (address) {\\n    return _vaultInfo.minter;\\n  }\\n\\n  /// @notice id of the vault\\n  /// @return address of minter\\n  function id() external view override returns (uint96) {\\n    return _vaultInfo.id;\\n  }\\n\\n  /// @notice current vault base liability\\n  /// @return base liability of vault\\n  function baseLiability() external view override returns (uint256) {\\n    return _baseLiability;\\n  }\\n\\n  /// @notice get vaults balance of an erc20 token\\n  /// @param addr address of the erc20 token\\n  /// @dev scales wBTC up to normal erc20 size\\n  function tokenBalance(address addr) external view override returns (uint256) {\\n    return IERC20(addr).balanceOf(address(this));\\n  }\\n\\n  /// @notice withdraw an erc20 token from the vault\\n  /// this can only be called by the minter\\n  /// the withdraw will be denied if ones vault would become insolvent\\n  /// @param token_address address of erc20 token\\n  /// @param amount amount of erc20 token to withdraw\\n  function withdrawErc20(address token_address, uint256 amount) external override onlyMinter {\\n    // transfer the token to the owner\\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(token_address), _msgSender(), amount);\\n    //  check if the account is solvent\\n    require(_controller.checkVault(_vaultInfo.id), \\\"over-withdrawal\\\");\\n    emit Withdraw(token_address, amount);\\n  }\\n\\n  /// @notice delegate the voting power of a comp-like erc20 token to another address\\n  /// @param delegatee address that will receive the votes\\n  /// @param token_address address of comp-like erc20 token\\n  function delegateCompLikeTo(address delegatee, address token_address) external override onlyMinter {\\n    CompLike(token_address).delegate(delegatee);\\n  }\\n\\n  /// @notice function used by the VaultController to transfer tokens\\n  /// callable by the VaultController only\\n  /// @param _token token to transfer\\n  /// @param _to person to send the coins to\\n  /// @param _amount amount of coins to move\\n  function controllerTransfer(\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external override onlyVaultController {\\n    SafeERC20Upgradeable.safeTransfer(IERC20Upgradeable(_token), _to, _amount);\\n  }\\n\\n  /// @notice function used by the VaultController to reduce a vaults liability\\n  /// callable by the VaultController only\\n  /// @param increase true to increase, false to decerase\\n  /// @param base_amount amount to reduce base liability by\\n  function modifyLiability(bool increase, uint256 base_amount) external override onlyVaultController returns (uint256) {\\n    if (increase) {\\n      _baseLiability = _baseLiability + base_amount;\\n    } else {\\n      // require statement only valid for repayment\\n      require(_baseLiability >= base_amount, \\\"repay too much\\\");\\n      _baseLiability = _baseLiability - base_amount;\\n    }\\n    return _baseLiability;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/IUSDI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\nimport \\\"./_external/IERC20Metadata.sol\\\";\\n\\n/// @title USDI Events\\n/// @notice interface which contains any events which the USDI contract emits\\ninterface USDIEvents {\\n  event Deposit(address indexed _from, uint256 _value);\\n  event Withdraw(address indexed _from, uint256 _value);\\n  event Mint(address to, uint256 _value);\\n  event Burn(address from, uint256 _value);\\n  event Donation(address indexed _from, uint256 _value, uint256 _totalSupply);\\n}\\n\\n/// @title USDI Interface\\n/// @notice extends USDIEvents and IERC20Metadata\\ninterface IUSDI is IERC20Metadata, USDIEvents {\\n  /// @notice initializer specifies the reserveAddress\\n  function initialize(address reserveAddress) external;\\n\\n  // getters\\n  function reserveRatio() external view returns (uint192);\\n\\n  function reserveAddress() external view returns (address);\\n\\n  // owner\\n  function owner() external view returns (address);\\n\\n  // business\\n  function deposit(uint256 usdc_amount) external;\\n\\n  function withdraw(uint256 usdc_amount) external;\\n\\n  function withdrawAll() external;\\n\\n  function donate(uint256 usdc_amount) external;\\n\\n  function donateReserve() external;\\n\\n  // admin functions\\n\\n  function setPauser(address pauser_) external;\\n\\n  function pauser() external view returns (address);\\n\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function mint(uint256 usdc_amount) external;\\n\\n  function burn(uint256 usdc_amount) external;\\n\\n  function setVaultController(address vault_master_address) external;\\n\\n  function getVaultController() external view returns (address);\\n\\n  // functions for the vault controller to call\\n  function vaultControllerBurn(address target, uint256 amount) external;\\n\\n  function vaultControllerMint(address target, uint256 amount) external;\\n\\n  function vaultControllerDonate(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"contracts/lending/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n// @title Vault Events\\n/// @notice interface which contains any events which the Vault contract emits\\ninterface VaultEvents {\\n  event Deposit(address token_address, uint256 amount);\\n  event Withdraw(address token_address, uint256 amount);\\n}\\n\\n/// @title Vault Interface\\n/// @notice extends VaultEvents\\ninterface IVault is VaultEvents {\\n  /// @notice value of _baseLiability\\n  function baseLiability() external view returns (uint256);\\n  /// @notice value of _vaultInfo.minter\\n  function minter() external view returns (address);\\n  /// @notice value of _vaultInfo.id\\n  function id() external view returns (uint96);\\n  /// @notice value of _tokenBalance\\n  function tokenBalance(address) external view returns (uint256);\\n\\n  // business logic\\n\\n  function withdrawErc20(address token_address, uint256 amount) external;\\n  function delegateCompLikeTo(address compLikeDelegatee, address compLikeToken) external;\\n\\n  // administrative functions\\n  function controllerTransfer(\\n    address _token,\\n    address _to,\\n    uint256 _amount\\n  ) external;\\n\\n  function modifyLiability(bool increase, uint256 base_amount) external returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/lending/IVaultController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n// @title VaultController Events\\n/// @notice interface which contains any events which the VaultController contract emits\\ninterface VaultControllerEvents {\\n  event InterestEvent(uint64 epoch, uint192 amount, uint256 curve_val);\\n  event NewProtocolFee(uint256 protocol_fee);\\n  event RegisteredErc20(address token_address, uint256 LTVe4, address oracle_address, uint256 liquidationIncentivee4);\\n  event UpdateRegisteredErc20(\\n    address token_address,\\n    uint256 LTVe4,\\n    address oracle_address,\\n    uint256 liquidationIncentivee4\\n  );\\n  event NewVault(address vault_address, uint256 vaultId, address vaultOwner);\\n  event RegisterOracleMaster(address oracleMasterAddress);\\n  event RegisterCurveMaster(address curveMasterAddress);\\n  event BorrowUSDi(uint256 vaultId, address vaultAddress, uint256 borrowAmount);\\n  event RepayUSDi(uint256 vaultId, address vaultAddress, uint256 repayAmount);\\n  event Liquidate(uint256 vaultId, address asset_address, uint256 usdi_to_repurchase, uint256 tokens_to_liquidate);\\n}\\n\\n/// @title VaultController Interface\\n/// @notice extends VaultControllerEvents\\ninterface IVaultController is VaultControllerEvents {\\n  // initializer\\n  function initialize() external;\\n\\n  // view functions\\n\\n  function tokensRegistered() external view returns (uint256);\\n\\n  function vaultsMinted() external view returns (uint96);\\n\\n  function lastInterestTime() external view returns (uint64);\\n\\n  function totalBaseLiability() external view returns (uint192);\\n\\n  function interestFactor() external view returns (uint192);\\n\\n  function protocolFee() external view returns (uint192);\\n\\n  function vaultAddress(uint96 id) external view returns (address);\\n\\n  function vaultIDs(address wallet) external view returns (uint96[] memory);\\n\\n  function amountToSolvency(uint96 id) external view returns (uint256);\\n\\n  function vaultLiability(uint96 id) external view returns (uint192);\\n\\n  function vaultBorrowingPower(uint96 id) external view returns (uint192);\\n\\n  function tokensToLiquidate(uint96 id, address token) external view returns (uint256);\\n\\n  function checkVault(uint96 id) external view returns (bool);\\n\\n  struct VaultSummary {\\n    uint96 id;\\n    uint192 borrowingPower;\\n    uint192 vaultLiability;\\n    address[] tokenAddresses;\\n    uint256[] tokenBalances;\\n  }\\n  function vaultSummaries(uint96 start, uint96 stop) external view returns (VaultSummary[] memory);\\n\\n  // interest calculations\\n  function calculateInterest() external returns (uint256);\\n\\n  // vault management business\\n  function mintVault() external returns (address);\\n\\n  function liquidateVault(\\n    uint96 id,\\n    address asset_address,\\n    uint256 tokenAmount\\n  ) external returns (uint256);\\n\\n  function borrowUsdi(uint96 id, uint192 amount) external;\\n\\n  function repayUSDi(uint96 id, uint192 amount) external;\\n\\n  function repayAllUSDi(uint96 id) external;\\n\\n  // admin\\n  function pause() external;\\n\\n  function unpause() external;\\n\\n  function getOracleMaster() external view returns (address);\\n\\n  function registerOracleMaster(address master_oracle_address) external;\\n\\n  function getCurveMaster() external view returns (address);\\n\\n  function registerCurveMaster(address master_curve_address) external;\\n\\n  function changeProtocolFee(uint192 new_protocol_fee) external;\\n\\n  function registerErc20(\\n    address token_address,\\n    uint256 LTV,\\n    address oracle_address,\\n    uint256 liquidationIncentive\\n  ) external;\\n\\n  function registerUSDi(address usdi_address) external;\\n\\n  function updateRegisteredErc20(\\n    address token_address,\\n    uint256 LTV,\\n    address oracle_address,\\n    uint256 liquidationIncentive\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/CompLike.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\ninterface CompLike {\\n  function delegate(address delegatee) external;\\n}\\n\"\r\n    },\r\n    \"contracts/_external/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the token decimals.\\n   */\\n  function decimals() external view returns (uint8);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.9;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view virtual returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal view virtual returns (bytes calldata) {\\n    this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n    return msg.data;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/_external/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/_external/openzeppelin/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity 0.8.9;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n   *\\n   * [IMPORTANT]\\n   * ====\\n   * It is unsafe to assume that an address for which this function returns\\n   * false is an externally-owned account (EOA) and not a contract.\\n   *\\n   * Among others, `isContract` will return false for the following\\n   * types of addresses:\\n   *\\n   *  - an externally-owned account\\n   *  - a contract in construction\\n   *  - an address where a contract will be created\\n   *  - an address where a contract lived, but was destroyed\\n   * ====\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize, which returns 0 for contracts in\\n    // construction, since the code is only stored at the end of the\\n    // constructor execution.\\n\\n    uint256 size;\\n    assembly {\\n      size := extcodesize(account)\\n    }\\n    return size > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n   * `recipient`, forwarding all available gas and reverting on errors.\\n   *\\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n   * imposed by `transfer`, making them unable to receive funds via\\n   * `transfer`. {sendValue} removes this limitation.\\n   *\\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n   *\\n   * IMPORTANT: because control is transferred to `recipient`, care must be\\n   * taken to not create reentrancy vulnerabilities. Consider using\\n   * {ReentrancyGuard} or the\\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n   */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n   * plain `call` is an unsafe replacement for a function call: use this\\n   * function instead.\\n   *\\n   * If `target` reverts with a revert reason, it is bubbled up by this\\n   * function (like regular Solidity function calls).\\n   *\\n   * Returns the raw returned data. To convert to the expected return value,\\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n   *\\n   * Requirements:\\n   *\\n   * - `target` must be a contract.\\n   * - calling `target` with `data` must not revert.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n   * `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but also transferring `value` wei to `target`.\\n   *\\n   * Requirements:\\n   *\\n   * - the calling contract must have an ETH balance of at least `value`.\\n   * - the called Solidity function must be `payable`.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\\n   *\\n   * _Available since v3.1._\\n   */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n   * but performing a static call.\\n   *\\n   * _Available since v3.3._\\n   */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResult(success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n   * revert reason using the provided one.\\n   *\\n   * _Available since v4.3._\\n   */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      // Look for revert reason and bubble it up if present\\n      if (returndata.length > 0) {\\n        // The easiest way to bubble the revert reason is using memory via assembly\\n\\n        assembly {\\n          let returndata_size := mload(returndata)\\n          revert(add(32, returndata), returndata_size)\\n        }\\n      } else {\\n        revert(errorMessage);\\n      }\\n    }\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"id_\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_baseLiability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_controller\",\"outputs\":[{\"internalType\":\"contract IVaultController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_vaultInfo\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"id\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseLiability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"controllerTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"}],\"name\":\"delegateCompLikeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"increase\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"base_amount\",\"type\":\"uint256\"}],\"name\":\"modifyLiability\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawErc20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Vault", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000958892b4a0512b28aaac890fc938868bbd42f0640000000000000000000000004aae9823fb4c70490f1d802fc697f3fff8d5cbe3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}