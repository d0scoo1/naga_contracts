{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/protocol/VinciCollectAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"@chainlink/contracts/src/v0.8/SimpleReadAccessController.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\nimport {SignedSafeMath} from '../dependencies/openzeppelin/contracts/utils/math/SignedSafeMath.sol';\\nimport {SafeMath} from '../dependencies/openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport \\\"./VinciCollectPriceCumulative.sol\\\";\\n\\ncontract CollectAggregator is AggregatorV2V3Interface, SimpleReadAccessController {\\n    struct Round {\\n      int256 answer;\\n      uint64 startedAt;\\n      uint64 updatedAt;\\n      uint32 answeredInRound;\\n    }\\n\\n    uint32 internal latestRoundId;\\n    mapping(uint32 => Round) internal rounds;\\n\\n    uint8 public override decimals;\\n    string public override description;\\n\\n    int256 immutable public minSubmissionValue;\\n    int256 immutable public maxSubmissionValue;\\n\\n    uint256 constant public override version = 3;\\n\\n    uint32 constant private ROUND_MAX = 2**32-1;\\n    // An error specific to the Aggregator V3 Interface, to prevent possible\\n    // confusion around accidentally reading unset values as reported values.\\n    string constant private V3_NO_DATA_ERROR = \\\"No data present\\\";\\n\\n    address private _operator;\\n    address private _collector;\\n    uint64 private timeInterval;\\n\\n    int256 priceCumulative;\\n    uint64 latestTimeAt;\\n\\n    /**\\n    * @notice set up the aggregator with initial configuration\\n    * @param _timeout is the number of seconds after the previous round that are\\n    * allowed to lapse before allowing an oracle to skip an unfinished round\\n    * @param _minSubmissionValue is an immutable check for a lower bound of what\\n    * submission values are accepted from an oracle\\n    * @param _maxSubmissionValue is an immutable check for an upper bound of what\\n    * submission values are accepted from an oracle\\n    * @param _decimals represents the number of decimals to offset the answer by\\n    * @param _description a short description of what is being reported\\n    */\\n    constructor(\\n      uint32 _timeout,\\n      int256 _minSubmissionValue,\\n      int256 _maxSubmissionValue,\\n      uint8 _decimals,\\n      uint64 _timeInterval,\\n      string memory _description\\n    ) {\\n      minSubmissionValue = _minSubmissionValue;\\n      maxSubmissionValue = _maxSubmissionValue;\\n      decimals = _decimals;\\n      description = _description;\\n      timeInterval = _timeInterval;\\n      rounds[0].updatedAt = uint64(block.timestamp - (uint256(_timeout)));\\n    }\\n\\n    function computeAmountOut() private view returns (int256 amountOut, int256 currentPriceCumulative, uint64 currentTime) {\\n      require(_collector != address(0), \\\"Please set the collector first\\\");\\n\\n      (currentPriceCumulative, currentTime) = CollectInterface(_collector).getPriceCumulative();\\n      int256 timeElapsed = int256(SafeMath.sub(currentTime, latestTimeAt));\\n      int256 priceDifference = SignedSafeMath.sub(currentPriceCumulative, priceCumulative);\\n      amountOut = SignedSafeMath.div(priceDifference, timeElapsed);\\n    }\\n\\n    /**\\n      * Receive the response in the form of uint256\\n      */ \\n    function submit(int256 _data) public onlyOwner\\n    {\\n      require(_data >= minSubmissionValue, \\\"value below minSubmissionValue\\\");\\n      require(_data <= maxSubmissionValue, \\\"value above maxSubmissionValue\\\");\\n\\n      uint64 startedAt = uint64(block.timestamp); \\n      updateRoundAnswer(latestRoundId + 1, startedAt, _data);\\n    }\\n\\n    function submitWithTWAP() public\\n    {\\n      int256 data;\\n      (data, priceCumulative, latestTimeAt)= computeAmountOut();\\n      updateRoundAnswer(latestRoundId + 1, uint64(block.timestamp), data);\\n    }\\n\\n    function setCollector(address _address) public onlyOwner {\\n      _collector = _address;\\n    }\\n\\n    function getCollector() public view returns (address) {\\n      return _collector;\\n    }\\n\\n    function setTimesInterval(uint64 _timeInterval) public onlyOwner {\\n      timeInterval = _timeInterval;\\n    }\\n\\n    function getTimesInterval() public view returns (uint64) {\\n      return timeInterval;\\n    }\\n\\n    /**\\n    * @notice get the most recently reported answer\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestAnswer()\\n      public\\n      view\\n      virtual\\n      override\\n      returns (int256)\\n    {\\n      return rounds[latestRoundId].answer;\\n    }\\n\\n    /**\\n    * @notice get the most recent updated at timestamp\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestTimestamp()\\n      public\\n      view\\n      virtual\\n      override\\n      returns (uint256)\\n    {\\n      return rounds[latestRoundId].updatedAt;\\n    }\\n\\n    /**\\n    * @notice get the ID of the last updated round\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestRound()\\n      public\\n      view\\n      virtual\\n      override\\n      returns (uint256)\\n    {\\n      return latestRoundId;\\n    }\\n\\n    /**\\n    * @notice get past rounds answers\\n    * @param _roundId the round number to retrieve the answer for\\n    *\\n    * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended getRoundData\\n    * instead which includes better verification information.\\n    */\\n    function getAnswer(uint256 _roundId)\\n      public\\n      view\\n      virtual\\n      override\\n      returns (int256)\\n    {\\n      if (validRoundId(_roundId)) {\\n        return rounds[uint32(_roundId)].answer;\\n      }\\n      return 0;\\n    }\\n\\n    /**\\n    * @notice get timestamp when an answer was last updated\\n    * @param _roundId the round number to retrieve the updated timestamp for\\n    *\\n    * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended getRoundData\\n    * instead which includes better verification information.\\n    */\\n    function getTimestamp(uint256 _roundId)\\n      public\\n      view\\n      virtual\\n      override\\n      returns (uint256)\\n    {\\n      if (validRoundId(_roundId)) {\\n        return rounds[uint32(_roundId)].updatedAt;\\n      }\\n      return 0;\\n    }\\n\\n    /**\\n    * @notice get data about a round. Consumers are encouraged to check\\n    * that they're receiving fresh data by inspecting the updatedAt and\\n    * answeredInRound return values.\\n    * @param _roundId the round ID to retrieve the round data for\\n    * @return roundId is the round ID for which data was retrieved\\n    * @return answer is the answer for the given round\\n    * @return startedAt is the timestamp when the round was started. This is 0\\n    * if the round hasn't been started yet.\\n    * @return updatedAt is the timestamp when the round last was updated (i.e.\\n    * answer was last computed)\\n    * @return answeredInRound is the round ID of the round in which the answer\\n    * was computed. answeredInRound may be smaller than roundId when the round\\n    * timed out. answeredInRound is equal to roundId when the round didn't time out\\n    * and was completed regularly.\\n    * @dev Note that for in-progress rounds (i.e. rounds that haven't yet received\\n    * maxSubmissions) answer and updatedAt may change between queries.\\n    */\\n    function getRoundData(uint80 _roundId)\\n      public\\n      view\\n      virtual\\n      override\\n      returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n      )\\n    {\\n      Round memory r = rounds[uint32(_roundId)];\\n\\n      require(r.answeredInRound > 0 && validRoundId(_roundId), V3_NO_DATA_ERROR);\\n\\n      return (\\n        _roundId,\\n        r.answer,\\n        r.startedAt,\\n        r.updatedAt,\\n        r.answeredInRound\\n      );\\n    }\\n\\n    /**\\n    * @notice get data about the latest round. Consumers are encouraged to check\\n    * that they're receiving fresh data by inspecting the updatedAt and\\n    * answeredInRound return values. Consumers are encouraged to\\n    * use this more fully featured method over the \\\"legacy\\\" latestRound/\\n    * latestAnswer/latestTimestamp functions. Consumers are encouraged to check\\n    * that they're receiving fresh data by inspecting the updatedAt and\\n    * answeredInRound return values.\\n    * @return roundId is the round ID for which data was retrieved\\n    * @return answer is the answer for the given round\\n    * @return startedAt is the timestamp when the round was started. This is 0\\n    * if the round hasn't been started yet.\\n    * @return updatedAt is the timestamp when the round last was updated (i.e.\\n    * answer was last computed)\\n    * @return answeredInRound is the round ID of the round in which the answer\\n    * was computed. answeredInRound may be smaller than roundId when the round\\n    * timed out. answeredInRound is equal to roundId when the round didn't time\\n    * out and was completed regularly.\\n    * @dev Note that for in-progress rounds (i.e. rounds that haven't yet\\n    * received maxSubmissions) answer and updatedAt may change between queries.\\n    */\\n    function latestRoundData()\\n      public\\n      view\\n      virtual\\n      override\\n      returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    )\\n    {\\n      return getRoundData(latestRoundId);\\n    }\\n\\n    function updateRoundAnswer(uint32 _roundId, uint64 _startedAt, int256 _newAnswer)\\n      internal\\n    {\\n      require(timeInterval <= SafeMath.sub(_startedAt, latestTimestamp()), \\\"No repeated feeding during the minimum interval\\\");\\n\\n      rounds[_roundId].answer = _newAnswer;\\n      rounds[_roundId].startedAt = _startedAt;\\n      rounds[_roundId].updatedAt = uint64(block.timestamp);\\n      rounds[_roundId].answeredInRound = _roundId;\\n      latestRoundId = _roundId;\\n\\n      emit AnswerUpdated(_newAnswer, _roundId, block.timestamp);\\n    }\\n\\n    function validRoundId(uint256 _roundId)\\n      private\\n      pure\\n      returns (bool)\\n    {\\n      return _roundId <= ROUND_MAX;\\n    }\\n}\\n\\n\\ncontract VinciCollectAggregator is CollectAggregator {\\n    /**\\n    * @notice set up the aggregator with initial configuration\\n    * @param _timeout is the number of seconds after the previous round that are\\n    * allowed to lapse before allowing an oracle to skip an unfinished round\\n    * @param _minSubmissionValue is an immutable check for a lower bound of what\\n    * submission values are accepted from an oracle\\n    * @param _maxSubmissionValue is an immutable check for an upper bound of what\\n    * submission values are accepted from an oracle\\n    * @param _decimals represents the number of decimals to offset the answer by\\n    * @param _description a short description of what is being reported\\n    */\\n    constructor(\\n      uint32 _timeout,\\n      int256 _minSubmissionValue,\\n      int256 _maxSubmissionValue,\\n      uint8 _decimals,\\n      uint64 _timeInterval,\\n      string memory _description\\n    ) CollectAggregator(\\n      _timeout,\\n      _minSubmissionValue,\\n      _maxSubmissionValue,\\n      _decimals,\\n      _timeInterval,\\n      _description\\n    ){}\\n\\n    /**\\n    * @notice get data about a round. Consumers are encouraged to check\\n    * that they're receiving fresh data by inspecting the updatedAt and\\n    * answeredInRound return values.\\n    * @param _roundId the round ID to retrieve the round data for\\n    * @return roundId is the round ID for which data was retrieved\\n    * @return answer is the answer for the given round\\n    * @return startedAt is the timestamp when the round was started. This is 0\\n    * if the round hasn't been started yet.\\n    * @return updatedAt is the timestamp when the round last was updated (i.e.\\n    * answer was last computed)\\n    * @return answeredInRound is the round ID of the round in which the answer\\n    * was computed. answeredInRound may be smaller than roundId when the round\\n    * timed out. answerInRound is equal to roundId when the round didn't time out\\n    * and was completed regularly.\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    * @dev Note that for in-progress rounds (i.e. rounds that haven't yet\\n    * received maxSubmissions) answer and updatedAt may change between queries.\\n    */\\n    function getRoundData(uint80 _roundId)\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n      )\\n    {\\n      return super.getRoundData(_roundId);\\n    }\\n\\n    /**\\n    * @notice get data about the latest round. Consumers are encouraged to check\\n    * that they're receiving fresh data by inspecting the updatedAt and\\n    * answeredInRound return values. Consumers are encouraged to\\n    * use this more fully featured method over the \\\"legacy\\\" latestAnswer\\n    * functions. Consumers are encouraged to check that they're receiving fresh\\n    * data by inspecting the updatedAt and answeredInRound return values.\\n    * @return roundId is the round ID for which data was retrieved\\n    * @return answer is the answer for the given round\\n    * @return startedAt is the timestamp when the round was started. This is 0\\n    * if the round hasn't been started yet.\\n    * @return updatedAt is the timestamp when the round last was updated (i.e.\\n    * answer was last computed)\\n    * @return answeredInRound is the round ID of the round in which the answer\\n    * was computed. answeredInRound may be smaller than roundId when the round\\n    * timed out. answerInRound is equal to roundId when the round didn't time out\\n    * and was completed regularly.\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    * @dev Note that for in-progress rounds (i.e. rounds that haven't yet\\n    * received maxSubmissions) answer and updatedAt may change between queries.\\n    */\\n    function latestRoundData()\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (\\n        uint80 roundId,\\n        int256 answer,\\n        uint256 startedAt,\\n        uint256 updatedAt,\\n        uint80 answeredInRound\\n      )\\n    {\\n      return super.latestRoundData();\\n    }\\n\\n    /**\\n    * @notice get the most recently reported answer\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestAnswer()\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (int256)\\n    {\\n      return super.latestAnswer();\\n    }\\n\\n    /**\\n    * @notice get the most recently reported round ID\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestRound()\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (uint256)\\n    {\\n      return super.latestRound();\\n    }\\n\\n    /**\\n    * @notice get the most recent updated at timestamp\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    *\\n    * @dev #[deprecated] Use latestRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended latestRoundData\\n    * instead which includes better verification information.\\n    */\\n    function latestTimestamp()\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (uint256)\\n    {\\n\\n      return super.latestTimestamp();\\n    }\\n\\n    /**\\n    * @notice get past rounds answers\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    * @param _roundId the round number to retrieve the answer for\\n    *\\n    * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended getRoundData\\n    * instead which includes better verification information.\\n    */\\n    function getAnswer(uint256 _roundId)\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (int256)\\n    {\\n      return super.getAnswer(_roundId);\\n    }\\n\\n    /**\\n    * @notice get timestamp when an answer was last updated\\n    * @dev overridden funcion to add the checkAccess() modifier\\n    * @param _roundId the round number to retrieve the updated timestamp for\\n    *\\n    * @dev #[deprecated] Use getRoundData instead. This does not error if no\\n    * answer has been reached, it will simply return 0. Either wait to point to\\n    * an already answered Aggregator or use the recommended getRoundData\\n    * instead which includes better verification information.\\n    */\\n    function getTimestamp(uint256 _roundId)\\n      public\\n      view\\n      override\\n      checkAccess()\\n      returns (uint256)\\n    {\\n      return super.getTimestamp(_roundId);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/SimpleReadAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./SimpleWriteAccessController.sol\\\";\\n\\n/**\\n * @title SimpleReadAccessController\\n * @notice Gives access to:\\n * - any externally owned account (note that off-chain actors can always read\\n * any contract storage regardless of on-chain access control measures, so this\\n * does not weaken the access control while improving usability)\\n * - accounts explicitly added to an access list\\n * @dev SimpleReadAccessController is not suitable for access controlling writes\\n * since it grants any externally owned account access! See\\n * SimpleWriteAccessController for that.\\n */\\ncontract SimpleReadAccessController is SimpleWriteAccessController {\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory _calldata) public view virtual override returns (bool) {\\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SignedSafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/protocol/VinciCollectPriceCumulative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport {SignedSafeMath} from '../dependencies/openzeppelin/contracts/utils/math/SignedSafeMath.sol';\\nimport {SafeMath} from '../dependencies/openzeppelin/contracts/utils/math/SafeMath.sol';\\nimport {Operatable} from './Operatable.sol';\\nimport {CollectInterface} from '../interface/CollectInterface.sol';\\n\\ncontract VinciCollectPriceCumulative is CollectInterface, Operatable {\\n    \\n    int256 priceCumulative;\\n    uint64 latestUpdatedAt;\\n\\n    uint8 public decimals;\\n    string public description;\\n\\n    int256 immutable public minSubmissionValue;\\n    int256 immutable public maxSubmissionValue;\\n\\n    uint256 constant public version = 1;\\n    address private _operator;\\n\\n    /**\\n    * @notice set up the aggregator with initial configuration\\n    * @param _timeout is the number of seconds after the previous round that are\\n    * allowed to lapse before allowing an oracle to skip an unfinished round\\n    * @param _minSubmissionValue is an immutable check for a lower bound of what\\n    * submission values are accepted from an oracle\\n    * @param _maxSubmissionValue is an immutable check for an upper bound of what\\n    * submission values are accepted from an oracle\\n    * @param _decimals represents the number of decimals to offset the answer by\\n    * @param _description a short description of what is being reported\\n    */\\n    constructor(\\n      uint32 _timeout,\\n      int256 _minSubmissionValue,\\n      int256 _maxSubmissionValue,\\n      uint8 _decimals,\\n      string memory _description\\n    ) {\\n      minSubmissionValue = _minSubmissionValue;\\n      maxSubmissionValue = _maxSubmissionValue;\\n      decimals = _decimals;\\n      description = _description;\\n      latestUpdatedAt = uint64(block.timestamp - (uint256(_timeout)));\\n    }\\n\\n    function computeAmountOut(int256 _price, uint64 _startedAt) internal view returns (int256 priceCumulativeOut) {\\n      int256 timeElapsed = int256(SafeMath.sub(_startedAt, latestUpdatedAt));\\n      priceCumulativeOut = SignedSafeMath.mul(_price, timeElapsed);\\n      priceCumulativeOut = SignedSafeMath.add(priceCumulativeOut, priceCumulative);\\n    }\\n\\n    /**\\n      * Receive the response in the form of uint256\\n      */ \\n    function updatePriceCumulative(int256 _data) public onlyOperator {\\n      require(_data >= minSubmissionValue, \\\"value below minSubmissionValue\\\");\\n      require(_data <= maxSubmissionValue, \\\"value above maxSubmissionValue\\\");\\n\\n      uint64 startedAt = uint64(block.timestamp);\\n      priceCumulative = computeAmountOut(_data, startedAt);\\n      latestUpdatedAt = startedAt;\\n    }\\n\\n    function getPriceCumulative() public view override returns (int256, uint64) {\\n      return (priceCumulative, latestUpdatedAt);\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/SimpleWriteAccessController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwner.sol\\\";\\nimport \\\"./interfaces/AccessControllerInterface.sol\\\";\\n\\n/**\\n * @title SimpleWriteAccessController\\n * @notice Gives access to accounts explicitly added to an access list by the\\n * controller's owner.\\n * @dev does not make any special permissions for externally, see\\n * SimpleReadAccessController for that.\\n */\\ncontract SimpleWriteAccessController is AccessControllerInterface, ConfirmedOwner {\\n  bool public checkEnabled;\\n  mapping(address => bool) internal accessList;\\n\\n  event AddedAccess(address user);\\n  event RemovedAccess(address user);\\n  event CheckAccessEnabled();\\n  event CheckAccessDisabled();\\n\\n  constructor() ConfirmedOwner(msg.sender) {\\n    checkEnabled = true;\\n  }\\n\\n  /**\\n   * @notice Returns the access of an address\\n   * @param _user The address to query\\n   */\\n  function hasAccess(address _user, bytes memory) public view virtual override returns (bool) {\\n    return accessList[_user] || !checkEnabled;\\n  }\\n\\n  /**\\n   * @notice Adds an address to the access list\\n   * @param _user The address to add\\n   */\\n  function addAccess(address _user) external onlyOwner {\\n    if (!accessList[_user]) {\\n      accessList[_user] = true;\\n\\n      emit AddedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice Removes an address from the access list\\n   * @param _user The address to remove\\n   */\\n  function removeAccess(address _user) external onlyOwner {\\n    if (accessList[_user]) {\\n      accessList[_user] = false;\\n\\n      emit RemovedAccess(_user);\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check enforced\\n   */\\n  function enableAccessCheck() external onlyOwner {\\n    if (!checkEnabled) {\\n      checkEnabled = true;\\n\\n      emit CheckAccessEnabled();\\n    }\\n  }\\n\\n  /**\\n   * @notice makes the access check unenforced\\n   */\\n  function disableAccessCheck() external onlyOwner {\\n    if (checkEnabled) {\\n      checkEnabled = false;\\n\\n      emit CheckAccessDisabled();\\n    }\\n  }\\n\\n  /**\\n   * @dev reverts if the caller does not have access\\n   */\\n  modifier checkAccess() {\\n    require(hasAccess(msg.sender, msg.data), \\\"No access\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AccessControllerInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AccessControllerInterface {\\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/protocol/Operatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Operatable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport {Ownable} from '../dependencies/openzeppelin/contracts/Ownable.sol';\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an operator) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the operator account will be the one that deploys the contract. This\\n * can later be changed with {transferOperationRight}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOperator`, which can be applied to your functions to restrict their use to\\n * the operator.\\n */\\nabstract contract Operatable is Ownable {\\n    address private _operator;\\n\\n    event OperationRightTransferred(address indexed previousOperator, address indexed newOperator);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial operator.\\n     */\\n    constructor() Ownable () {\\n        _transferOperationRight(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current operator.\\n     */\\n    function operator() public view virtual returns (address) {\\n        return _operator;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the operator.\\n     */\\n    modifier onlyOperator() {\\n        require(operator() == _msgSender(), \\\"Operatable: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without operator. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing operation Rights will leave the contract without an operator,\\n     * thereby removing any functionality that is only available to the operator.\\n     */\\n    function renounceOperationRight() public virtual onlyOwner {\\n        _transferOperationRight(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers operation right of the contract to a new account (`newOperator`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOperationRight(address newOperator) public virtual onlyOwner {\\n        require(newOperator != address(0), \\\"Operatable: new owner is the zero address\\\");\\n        _transferOperationRight(newOperator);\\n    }\\n\\n    /**\\n     * @dev Transfers operation right of the contract to a new account (`newOperator`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOperationRight(address newOperator) internal virtual {\\n        address oldOperator = _operator;\\n        _operator = newOperator;\\n        emit OperationRightTransferred(oldOperator, newOperator);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/CollectInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface CollectInterface {\\n  function getPriceCumulative() external view returns (int256, uint64);\\n}\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/dependencies/openzeppelin/contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_timeout\",\"type\":\"uint32\"},{\"internalType\":\"int256\",\"name\":\"_minSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"_maxSubmissionValue\",\"type\":\"int256\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_timeInterval\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTimesInterval\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minSubmissionValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_timeInterval\",\"type\":\"uint64\"}],\"name\":\"setTimesInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"_data\",\"type\":\"int256\"}],\"name\":\"submit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitWithTWAP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VinciCollectAggregator", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004ee2d6d415b85acef80ffffffff00000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000e1000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000000104241594320466c6f6f7220507269636500000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}