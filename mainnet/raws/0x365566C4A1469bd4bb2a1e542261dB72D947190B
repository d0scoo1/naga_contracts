{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Elegance.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\nimport \\\"./Token.sol\\\";\\n\\n/**\\n * @dev This is the smart contract implementation of Elegance coin.\\n */\\ncontract Elegance is Token {\\n\\n  constructor()\\n    public\\n  {\\n    tokenName = \\\"Elegance\\\";\\n    tokenSymbol = \\\"LGX\\\";\\n    tokenDecimals = 18;\\n    tokenTotalSupply = 100000000000000000000000000;\\n    balances[msg.sender] = tokenTotalSupply;\\n  }\\n}\\n\"},\"ERC20.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\n/**\\n * @title A standard interface for tokens.\\n */\\ninterface ERC20 {\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string _name);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string _symbol);\\n\\n  /**\\n   * @dev Returns the number of decimals the token uses.\\n   */\\n  function decimals()\\n    external\\n    view\\n    returns (uint8 _decimals);\\n\\n  /**\\n   * @dev Returns the total token supply.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256 _totalSupply);\\n\\n  /**\\n   * @dev Returns the account balance of another account with address _owner.\\n   * @param _owner The address from which the balance will be retrieved.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256 _balance);\\n\\n  /**\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transfer(\\n    address _to,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\n   * Transfer event.\\n   * @param _from The address of the sender.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Allows _spender to withdraw from your account multiple times, up to\\n   * the _value amount. If this function is called again it overwrites the current\\n   * allowance with _value.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   * @param _value The amount of tokens to be approved for transfer.\\n   */\\n  function approve(\\n    address _spender,\\n    uint256 _value\\n  )\\n    external\\n    returns (bool _success);\\n\\n  /**\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\n   * @param _owner The address of the account owning tokens.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n  )\\n    external\\n    view\\n    returns (uint256 _remaining);\\n\\n  /**\\n   * @dev Triggers when tokens are transferred, including zero value transfers.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Triggers on any successful call to approve(address _spender, uint256 _value).\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _value\\n  );\\n\\n}\\n\"},\"SafeMath.sol\":{\"content\":\"pragma solidity ^0.4.23;\\n\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n    c = a * b;\\n    assert(c / a == b);\\n    return c;\\n  }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b \\u003e 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\n    return a / b;\\n  }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n    assert(b \\u003c= a);\\n    return a - b;\\n  }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n    c = a + b;\\n    assert(c \\u003e= a);\\n    return c;\\n  }\\n}\"},\"Token.sol\":{\"content\":\"pragma solidity ^0.4.24;\\n\\nimport \\\"./SafeMath.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @title ERC20 standard token implementation.\\n * @dev Standard ERC20 token. This contract follows the implementation at https://goo.gl/mLbAPJ.\\n */\\ncontract Token is\\n  ERC20\\n{\\n  using SafeMath for uint256;\\n\\n  /**\\n   * Token name.\\n   */\\n  string internal tokenName;\\n\\n  /**\\n   * Token symbol.\\n   */\\n  string internal tokenSymbol;\\n\\n  /**\\n   * Number of decimals.\\n   */\\n  uint8 internal tokenDecimals;\\n\\n  /**\\n   * Total supply of tokens.\\n   */\\n  uint256 internal tokenTotalSupply;\\n\\n  /**\\n   * Balance information map.\\n   */\\n  mapping (address =\\u003e uint256) internal balances;\\n\\n  /**\\n   * Token allowance mapping.\\n   */\\n  mapping (address =\\u003e mapping (address =\\u003e uint256)) internal allowed;\\n\\n  /**\\n   * @dev Trigger when tokens are transferred, including zero value transfers.\\n   */\\n  event Transfer(\\n    address indexed _from,\\n    address indexed _to,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Trigger on any successful call to approve(address _spender, uint256 _value).\\n   */\\n  event Approval(\\n    address indexed _owner,\\n    address indexed _spender,\\n    uint256 _value\\n  );\\n\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name()\\n    external\\n    view\\n    returns (string _name)\\n  {\\n    _name = tokenName;\\n  }\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n   */\\n  function symbol()\\n    external\\n    view\\n    returns (string _symbol)\\n  {\\n    _symbol = tokenSymbol;\\n  }\\n\\n  /**\\n   * @dev Returns the number of decimals the token uses.\\n   */\\n  function decimals()\\n    external\\n    view\\n    returns (uint8 _decimals)\\n  {\\n    _decimals = tokenDecimals;\\n  }\\n\\n  /**\\n   * @dev Returns the total token supply.\\n   */\\n  function totalSupply()\\n    external\\n    view\\n    returns (uint256 _totalSupply)\\n  {\\n    _totalSupply = tokenTotalSupply;\\n  }\\n\\n  /**\\n   * @dev Returns the account balance of another account with address _owner.\\n   * @param _owner The address from which the balance will be retrieved.\\n   */\\n  function balanceOf(\\n    address _owner\\n  )\\n    external\\n    view\\n    returns (uint256 _balance)\\n  {\\n    _balance = balances[_owner];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. The\\n   * function SHOULD throw if the _from account balance does not have enough tokens to spend.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transfer(\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require(_value \\u003c= balances[msg.sender]);\\n\\n    balances[msg.sender] = balances[msg.sender].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n\\n    emit Transfer(msg.sender, _to, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. If\\n   * this function is called again it overwrites the current allowance with _value.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   * @param _value The amount of tokens to be approved for transfer.\\n   */\\n  function approve(\\n    address _spender,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require((_value == 0) || (allowed[msg.sender][_spender] == 0));\\n\\n    allowed[msg.sender][_spender] = _value;\\n\\n    emit Approval(msg.sender, _spender, _value);\\n    _success = true;\\n  }\\n\\n  /**\\n   * @dev Returns the amount which _spender is still allowed to withdraw from _owner.\\n   * @param _owner The address of the account owning tokens.\\n   * @param _spender The address of the account able to transfer the tokens.\\n   */\\n  function allowance(\\n    address _owner,\\n    address _spender\\n  )\\n    external\\n    view\\n    returns (uint256 _remaining)\\n  {\\n    _remaining = allowed[_owner][_spender];\\n  }\\n\\n  /**\\n   * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the\\n   * Transfer event.\\n   * @param _from The address of the sender.\\n   * @param _to The address of the recipient.\\n   * @param _value The amount of token to be transferred.\\n   */\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  )\\n    public\\n    returns (bool _success)\\n  {\\n    require(_value \\u003c= balances[_from]);\\n    require(_value \\u003c= allowed[_from][msg.sender]);\\n\\n    balances[_from] = balances[_from].sub(_value);\\n    balances[_to] = balances[_to].add(_value);\\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\\n\\n    emit Transfer(_from, _to, _value);\\n    _success = true;\\n  }\\n\\n}\\n\"}}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"_remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]", "ContractName": "Elegance", "CompilerVersion": "v0.4.26+commit.4563c3fc", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://e7e607ac0b6aef21c26b1e120b2691018861471e77fa8e4ed5c540ed5ca2109c"}]}