{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/OKG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\n// An Omega Key and its owners\\nstruct OmegaKey {\\n\\tbool active;\\n\\tbool removed; // whether a Key is removed by a successful Reward claim\\n\\tuint8 order; // Order of the Key will be released\\n\\tuint256 keyId; // equal to the Id of the Voxo this Key was assigned to\\n\\taddress[] owners;\\n}\\n\\n// A Player's Omega Key collection\\nstruct Player {\\n\\tbool active;\\n\\tuint256[] keyids; // A Key # is equal to the Voxo's Id it was assigned to\\n}\\n\\n/**\\n * @title Omega Key Game Smart Contract\\n * @dev All methods to conduct the Omega Key Game on-chain\\n * @dev https://voxodeus.notion.site/Omega-Key-Game-143fcf958a254295a5a1e2b344867fca\\n */\\n\\ncontract OKG is Ownable, Pausable {\\n\\tusing SafeMath for uint256;\\n\\tusing Address for address;\\n\\n\\t// Mapping to handle Omega Keys\\n\\tmapping(uint256 => OmegaKey) public omegaKeys;\\n\\t// Mapping to handle Players\\n\\tmapping(address => Player) public players;\\n\\t// Event for when an Omega Key is released\\n\\tevent OmegaKeyReleased(uint256[] OmegaKey, uint8[] order);\\n\\t// Event for when a Player registers their ownership of an Omega Key\\n\\tevent OmegaKeyRegistered(address indexed Owner, uint256[]  OmegaKey);\\n\\t// Event for when an Omega Key is removed from the game\\n\\tevent OmegaKeyRemoved(address indexed Winner, uint256 indexed OmegaKey, uint256 indexed Tier, address[] allOwners);\\n\\t// Event for when the removal of an Omega Key is reversed\\n\\tevent OmegaKeyRestored(address[] oldOwners, uint256 indexed OmegaKey);\\n\\t// Event for when an Omega Reward is successfully claimed\\n\\tevent RewardClaimed(address indexed Winner, uint256 indexed Tier, uint256 Amount);\\n\\t// Event for when an Omega Reward's claim status is reverted to being available\\n\\tevent RewardRestored(uint256 indexed Tier, uint256 Amount);\\n\\t// General Order of Omega Keys Released\\n\\tuint8 public releaseOrder;\\n\\t// Address of the NFT contract\\n\\taddress public nftContract;\\n\\t// Availability of the Diamond Reward\\n\\tbool public isDiamondRewardClaimed;\\n\\t// Availability of the Gold Reward\\n\\tbool public isGoldRewardClaimed;\\n\\t// Availability of the Silver Reward\\n\\tbool public isSilverRewardClaimed;\\n\\t// Availability of the Bronze Reward\\n\\tbool public isBronzeRewardClaimed;\\n\\n\\n    constructor(address NFT_contract_address) {\\n    \\tnftContract = NFT_contract_address;\\n    }\\n\\n\\tmodifier isReleased(uint256 _keyId) {\\n\\t\\trequire(isKey(_keyId), \\\"VOXO: Omega Key not released\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier whenNotGameOver() {\\n\\t\\trequire(!isGameOver(), \\\"VOXO: Game Over\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\tmodifier isOmegaRewardAmount(uint256 _ethReward) {\\n\\t\\trequire(isOmegaReward(_ethReward), \\\"VOXO: Reward for this ETH amount does not exist\\\");\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n     * @dev Implementation / Instance of paused methods() in the ERC20.\\n     * @param status Setting the status boolean (True for paused, or False for unpaused)\\n     * See {ERC20Pausable}.\\n     */\\n    function pause(bool status) public onlyOwner() {\\n        if (status) {\\n            _pause();\\n        } else {\\n            _unpause();\\n        }\\n    }\\n\\n\\t/**\\n\\t * @dev Method to record the release of a new Omega Key\\n\\t * @dev A Key # is equal to the voxoId of the Voxo it is assigned to\\n\\t * @param _ids The Array of keyids\\n\\t */\\n\\tfunction release(uint256[] calldata _ids) external\\n\\t\\tonlyOwner()\\n\\t\\twhenNotGameOver()\\n\\t\\twhenNotPaused()\\n\\t{\\n\\t\\trequire(!hasDuplicates(_ids), \\\"VOXO: Duplicate Key Ids\\\");\\n\\t\\tuint8[] memory _order = new uint8[](_ids.length);\\n\\t\\tfor (uint i = 0; i < _ids.length; i++) {\\n\\t\\t\\trequire((_ids[i] != uint(0)), \\\"VOXO: Voxo Id cannot be Zero\\\");\\n\\t\\t\\trequire(!isKey(_ids[i]), \\\"VOXO: Voxo can only be assigned 1 Omega Key\\\");\\n\\t\\t\\trequire(!isRemoved(_ids[i]), \\\"VOXO: Voxo cannot be assigned to a removed Omega Key\\\");\\n\\n\\t\\t}\\n\\n\\t\\tfor (uint i = 0; i < _ids.length; i++) {\\n\\t\\t\\treleaseOrder++;\\n\\t\\t\\t_order[i] = releaseOrder;\\n\\t\\t\\tomegaKeys[_ids[i]] = OmegaKey({\\n\\t\\t\\t\\tactive: true,\\n\\t\\t\\t\\tremoved: false,\\n\\t\\t\\t\\torder: releaseOrder,\\n\\t\\t\\t\\tkeyId: _ids[i],\\n\\t\\t\\t\\towners: new address[](0)\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\t// Emit Event for the released Omega Key\\n\\t\\temit OmegaKeyReleased(_ids, _order);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to register a Player's ownership of an Omega Key\\n\\t * @param _keyIds The Voxo Id / Key # a player intends to register\\n\\t */\\n\\tfunction register(uint256[] calldata _keyIds) external\\n\\t\\twhenNotGameOver()\\n\\t\\twhenNotPaused()\\n\\t{\\n\\t\\trequire(!hasDuplicates(_keyIds), \\\"VOXO: Duplicate Key Ids\\\");\\n\\t\\t// Instance of NFT VoxoDeus, to Verify the ownership\\n\\t\\tIERC721 _token = IERC721(address(nftContract));\\n\\t\\tfor (uint i = 0; i < _keyIds.length; i++) {\\n\\t\\t\\trequire((_keyIds[i] != uint(0)), \\\"VOXO: Voxo Id cannot be Zero\\\");\\n\\t\\t\\trequire(isKey(_keyIds[i]), \\\"VOXO: Omega Key not released\\\");\\n\\t\\t\\trequire(!isRegistered(_keyIds[i], _msgSender()), \\\"VOXO: Omega Key already registered\\\");\\n\\t\\t\\trequire(_token.ownerOf(_keyIds[i]) == _msgSender(), \\\"VOXO: You are not the owner of this KeyVoxo\\\");\\n\\t\\t}\\n\\n\\t\\tfor (uint i = 0; i < _keyIds.length; i++) {\\n\\t\\t\\t// register Player as an owner of this Omega Key\\n\\t\\t\\tomegaKeys[_keyIds[i]].owners.push(_msgSender());\\n\\t\\t\\t// add Omega Key to a Player's Omega Key Collection\\n\\t\\t\\tif (players[_msgSender()].active) {\\n\\t\\t\\t\\tplayers[_msgSender()].keyids.push(_keyIds[i]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tplayers[_msgSender()].active = true;\\n\\t\\t\\t\\tplayers[_msgSender()].keyids.push(_keyIds[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Emit Event for the Player registering an Omega Key\\n\\t\\temit OmegaKeyRegistered(_msgSender(), _keyIds);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to claim an Omega Reward\\n\\t * @dev To claim a Reward, a Player needs to have at least\\n\\t * @dev the Reward's required number of Keys in their Collection\\n\\t * @dev Key Requirements: 3 for Bronze, 4 for Silver, 6 for Gold, and 8 for Diamond.\\n\\t * @param _ethClaim The ETH amount the Reward's winner will be awarded\\n\\t */\\n\\tfunction claim(uint256 _ethClaim) public\\n\\t\\twhenNotGameOver()\\n\\t\\twhenNotPaused()\\n\\t\\tisOmegaRewardAmount(_ethClaim)\\n\\t{\\n\\t\\trequire(players[_msgSender()].active, \\\"VOXO: Player does not exist\\\");\\n\\n\\t\\t// The Reward specifics\\n\\t\\tuint256 noKeysRequired;\\n\\t\\t// Tier Bronze\\n\\t\\tif (_ethClaim == uint256(16)) {\\n\\t\\t\\trequire(!isBronzeRewardClaimed, \\\"VOXO: Bronze Reward already claimed\\\");\\n\\t\\t\\trequire(players[_msgSender()].keyids.length >= 3, \\\"VOXO: Player Key collection insufficient for this Reward\\\");\\n\\t\\t\\tnoKeysRequired = 3;\\n\\t\\t\\tremoveOmegaKeys(noKeysRequired);\\n\\t\\t\\tisBronzeRewardClaimed = true;\\n\\t\\t}\\n\\t\\t// Tier Silver\\n\\t\\tif (_ethClaim == uint256(33))  {\\n\\t\\t\\trequire(!isSilverRewardClaimed, \\\"VOXO: Silver Reward already claimed\\\");\\n\\t\\t\\trequire(players[_msgSender()].keyids.length >= 4, \\\"VOXO: Player Key collection insufficient for this Reward\\\");\\n\\t\\t\\tnoKeysRequired = 4;\\n\\t\\t\\tremoveOmegaKeys(noKeysRequired);\\n\\t\\t\\tisSilverRewardClaimed = true;\\n\\t\\t}\\n\\t\\t// Tier Gold\\n\\t\\tif (_ethClaim == uint256(66))  {\\n\\t\\t\\trequire(!isGoldRewardClaimed, \\\"VOXO: Gold Reward already claimed\\\");\\n\\t\\t\\trequire(players[_msgSender()].keyids.length >= 6, \\\"VOXO: Player Key collection insufficient for this Reward\\\");\\n\\t\\t\\tnoKeysRequired = 6;\\n\\t\\t\\tremoveOmegaKeys(noKeysRequired);\\n\\t\\t\\tisGoldRewardClaimed = true;\\n\\t\\t}\\n\\t\\t// Tier Diamond\\n\\t\\tif (_ethClaim == uint256(135)) {\\n\\t\\t\\trequire(!isDiamondRewardClaimed, \\\"VOXO: Diamond Reward already claimed\\\");\\n\\t\\t\\trequire(players[_msgSender()].keyids.length >= 8, \\\"VOXO: Player Key collection insufficient for this Reward\\\");\\n\\t\\t\\tnoKeysRequired = 8;\\n\\t\\t\\tremoveOmegaKeys(noKeysRequired);\\n\\t\\t\\tisDiamondRewardClaimed = true;\\n\\t\\t}\\n\\n\\t\\temit RewardClaimed(_msgSender(), noKeysRequired, _ethClaim);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to remove Omega Keys.\\n\\t * @dev Omega Keys are removed from the game - burned - whenever a Player\\n\\t * @dev uses that Key # to claim a Reward. This method doesn't check the\\n     * @dev ownership of the VoxoId, as Players can own Omega Keys without\\n     * @dev still holding the KeyVoxo.\\n\\t * @dev\\n\\t * @dev Omega Keys are removed in the order that they were registered.\\n\\t * @dev Thus, a Player may still have Keys left after removing all the\\n\\t * @dev Keys they used to claim a Reward.\\n\\t * @dev\\n\\t * @param _keys Number of keys to burn\\n\\t */\\n\\tfunction removeOmegaKeys(uint256 _keys) private {\\n\\t\\tfor (uint i = 0; i < _keys; i++) {\\n\\t\\t\\t// Select the Player's oldest remaining Key to burn\\n\\t\\t\\tuint256 keyToRemove = players[_msgSender()].keyids[0];\\n\\t\\t\\tomegaKeys[keyToRemove].active = false;\\n\\t\\t\\tomegaKeys[keyToRemove].removed = true;\\n\\t\\t\\t// Remove all owners from that Key\\n\\t\\t\\taddress[] memory allOwners = omegaKeys[keyToRemove].owners;\\n\\t\\t\\t// Likewise, the Omega Key must be removed from all Players whom\\n\\t\\t\\t// had previously registered it / added it to their Key Collection.\\n\\t\\t\\tfor (uint j = 0; j < allOwners.length; j++) {\\n\\t\\t\\t\\tplayers[allOwners[j]].keyids = removeKeyFromPlayer(keyToRemove, allOwners[j]);\\n\\t\\t\\t\\tif (players[allOwners[j]].keyids.length > 0) {\\n\\t\\t\\t\\t\\tplayers[allOwners[j]].keyids.pop();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\temit OmegaKeyRemoved(_msgSender(), keyToRemove, _keys, allOwners);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to remove an Omega Key from a Player's Collection.\\n\\t * @param _keyId The Voxo Id / Key # - The Omega Key to remove\\n\\t * @param _player the owner of the Key Collection\\n\\t * @return keyids Player's Collection with the removed Keys removed\\n\\t */\\n\\tfunction removeKeyFromPlayer(uint256 _keyId, address _player) internal view returns (uint256[] memory keyids) {\\n\\t\\tkeyids = players[_player].keyids;\\n\\t\\tuint256 index = keyids.length;\\n\\t\\tfor (uint i = 0; i < index; i++) {\\n\\t\\t\\tif (keyids[i] == _keyId) {\\n\\t\\t\\t\\tkeyids[i] = keyids[index - 1];\\n\\t\\t\\t\\tdelete keyids[index - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t }\\n\\n\\t/**\\n\\t * @dev Method reverting the game state following an invalidated Omega Reward Claim\\n\\t * @dev Used exclusively in the unexpected case where a winning claim is found to be fraudulent\\n\\t * @dev or otherwise in conflict with the terms governing a player's participation in the game.\\n\\t * @param _ethReward the ETH payout amount corresponding to an Omega Reward tier\\n\\t */\\n\\tfunction restoreReward(uint256 _ethReward) private\\n\\t{\\n\\t\\tuint256 noKeysRequired = 0;\\n\\t\\tif ((_ethReward == uint256(16)) && (isBronzeRewardClaimed)) {\\n\\t\\t\\tisBronzeRewardClaimed = false;\\n\\t\\t\\tnoKeysRequired = 3;\\n\\t\\t}\\n\\t\\tif ((_ethReward == uint256(33)) && (isSilverRewardClaimed)) {\\n\\t\\t\\tisSilverRewardClaimed = false;\\n\\t\\t\\tnoKeysRequired = 4;\\n\\t\\t}\\n\\t\\tif ((_ethReward == uint256(66)) && (isGoldRewardClaimed)) {\\n\\t\\t\\tisGoldRewardClaimed = false;\\n\\t\\t\\tnoKeysRequired = 6;\\n\\t\\t}\\n\\t\\tif (_ethReward == uint256(135) && (isDiamondRewardClaimed)) {\\n\\t\\t\\tisDiamondRewardClaimed = false;\\n\\t\\t\\tnoKeysRequired = 8;\\n\\t\\t}\\n\\t\\temit RewardRestored(noKeysRequired, _ethReward);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to revert a removed Omega Key for all previous Owners\\n\\t * @dev Used exclusively in the unexpected case where a winning claim is found to be fraudulent\\n\\t * @dev or otherwise in conflict with the terms governing a player's participation in the game.\\n\\t * @param _keyIds an Array of Keys #s\\n\\t */\\n\\tfunction revertRewardClaim(uint256 _ethReward, uint256[] memory _keyIds, address _disqualifiedPlayer) public\\n\\t\\tonlyOwner()\\n\\t\\twhenNotPaused()\\n\\t\\tisOmegaRewardAmount(_ethReward)\\n\\t{\\n\\t\\trequire(!hasDuplicates(_keyIds), \\\"VOXO: Duplicate Key Ids\\\");\\n\\t\\t// Verify that all the Keys-to-be-restored were previously removed\\n\\t\\tfor (uint j = 0; j < _keyIds.length; j++) {\\n\\t\\t\\trequire ((omegaKeys[_keyIds[j]].removed && !omegaKeys[_keyIds[j]].active), \\\"VOXO: Omega Key is not removed\\\");\\n\\t\\t}\\n\\t\\t// Restore the Reward\\n\\t\\trestoreReward(_ethReward);\\n\\t\\t// Restore the Keys to the Player's Collection\\n\\t\\tfor (uint i = 0; i < _keyIds.length; i++) {\\n\\t\\t\\taddress[] memory oldOwners;\\n\\t\\t\\tomegaKeys[_keyIds[i]].owners = removePlayer(_keyIds[i], _disqualifiedPlayer);\\n\\t\\t\\tif (omegaKeys[_keyIds[i]].owners.length > 0) {\\n\\t\\t\\t\\tomegaKeys[_keyIds[i]].owners.pop();\\n\\t\\t\\t\\toldOwners = omegaKeys[_keyIds[i]].owners;\\n\\t\\t\\t}\\n\\t\\t\\tuint8 oldOrder = omegaKeys[_keyIds[i]].order;\\n\\t\\t\\tomegaKeys[_keyIds[i]] = OmegaKey({\\n\\t\\t\\t\\tactive: true,\\n\\t\\t\\t\\tremoved: false,\\n\\t\\t\\t\\torder: oldOrder,\\n\\t\\t\\t\\tkeyId: _keyIds[i],\\n\\t\\t\\t\\towners: oldOwners\\n\\t\\t\\t});\\n\\t\\t\\t// Add Key back to each Owner's Key Collection\\n\\t\\t\\tfor(uint k = 0; k < omegaKeys[_keyIds[i]].owners.length; k++) {\\n\\t\\t\\t\\tplayers[omegaKeys[_keyIds[i]].owners[k]].keyids.push(_keyIds[i]);\\n\\t\\t\\t}\\n\\t\\t\\temit OmegaKeyRestored(omegaKeys[_keyIds[i]].owners, _keyIds[i]);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to verify an Key # is among the released Omega Keys\\n\\t * @param _keyId The Voxo Id / Key #\\n\\t * @return True if the Key # was released, False if not\\n\\t */\\n\\tfunction isKey(uint256 _keyId) public view returns (bool) {\\n\\t\\treturn omegaKeys[_keyId].active;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to verify that an Omega Key was removed\\n\\t * @param _keyId The Voxo Id / Key #\\n\\t * @return True if the Omega Key was removed, False if not\\n\\t */\\n\\tfunction isRemoved(uint256 _keyId) public view returns (bool) {\\n\\t\\treturn omegaKeys[_keyId].removed;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to verify an ETH amount has a corresponding Omega Reward\\n\\t * @param _ethReward The ETH amount an Omega Reward pays out\\n\\t * @return True if Omega Reward with that ETH reward exists, False if not\\n\\t */\\n\\tfunction isOmegaReward(uint256 _ethReward) public pure returns (bool) {\\n\\t\\treturn (_ethReward == uint256(16)) || (_ethReward == uint256(33)) || (_ethReward == uint256(66)) || (_ethReward == uint256(135));\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to verify that no Rewards are left unclaimed,\\n\\t * @dev marking the end of the Omega Key Game\\n\\t * @return True if all Reward are unavailable, False if at least one Reward is still available\\n\\t */\\n\\tfunction isGameOver() public view returns (bool) {\\n\\t\\treturn (isDiamondRewardClaimed && isGoldRewardClaimed && isSilverRewardClaimed && isBronzeRewardClaimed);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method to verify that a Player has registered an Omega Key\\n\\t * @param _keyId The Voxo Id / Key #\\n\\t * @return registered True if the Omega Key is registered, False if not\\n\\t */\\n\\tfunction isRegistered(uint256 _keyId, address _owner) public view isReleased(_keyId) returns (bool registered) {\\n\\t\\tregistered = false;\\n\\t\\tfor (uint i = 0; i < omegaKeys[_keyId].owners.length; i++) {\\n\\t\\t\\tif (omegaKeys[_keyId].owners[i] == _owner) {\\n\\t\\t\\t\\tregistered = true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn registered;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method returning the Player's Key Collection\\n\\t * @param _player The owner of the Key Collection\\n\\t * @return The list of Keys collected (and registered) by the Player\\n\\t */\\n\\tfunction getKeyCollection(address _player) public view returns (uint256[] memory) {\\n\\t\\treturn players[_player].keyids;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method returning the Player's Key Collection size\\n\\t * @param _player The owner of the Key Collection\\n\\t * @return The number of keys collected (and registered) by the Player\\n\\t */\\n\\tfunction getKeyCollectionSize(address _player) public view returns (uint256 ) {\\n\\t\\treturn players[_player].keyids.length;\\n\\t}\\n\\n\\t/**\\n\\t * @dev Method returning the Omega Key Collection without disqualified Player\\n\\t * @param _keyIds The Voxo Id / Key #, where the disqualified Player will be removed from\\n\\t * @param _disqualifiedPlayer The disqualifiedPlayer of the Key Collection\\n\\t * @return owners The Omega Key Collection without disqualified Player\\n\\t */\\n\\tfunction removePlayer(uint256 _keyIds, address _disqualifiedPlayer) internal view returns (address[] memory owners) {\\n\\t\\towners = omegaKeys[_keyIds].owners;\\n\\t\\tuint256 index = owners.length;\\n\\t\\tfor (uint i = 0; i < index; i++) {\\n\\t\\t\\tif (owners[i] == _disqualifiedPlayer) {\\n\\t\\t\\t\\towners[i] = owners[index - 1];\\n\\t\\t\\t\\tdelete owners[index - 1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t* Returns whether or not there's a duplicate. Runs in O(n^2).\\n\\t* @param A Array to search\\n\\t* @return Returns true if duplicate, false otherwise\\n\\t*/\\n\\tfunction hasDuplicates(uint256[] memory A) internal pure returns (bool) {\\n\\t\\tif (A.length == 0) {\\n\\t\\treturn false;\\n\\t\\t}\\n\\t\\tfor (uint256 i = 0; i < A.length - 1; i++) {\\n\\t\\t\\tfor (uint256 j = i + 1; j < A.length; j++) {\\n\\t\\t\\t\\tif (A[i] == A[j]) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 500\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"NFT_contract_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"OmegaKey\",\"type\":\"uint256[]\"}],\"name\":\"OmegaKeyRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"OmegaKey\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint8[]\",\"name\":\"order\",\"type\":\"uint8[]\"}],\"name\":\"OmegaKeyReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"OmegaKey\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"Tier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"allOwners\",\"type\":\"address[]\"}],\"name\":\"OmegaKeyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"oldOwners\",\"type\":\"address[]\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"OmegaKey\",\"type\":\"uint256\"}],\"name\":\"OmegaKeyRestored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"Winner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"Tier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"Tier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"}],\"name\":\"RewardRestored\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethClaim\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getKeyCollection\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getKeyCollectionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBronzeRewardClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isDiamondRewardClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGameOver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isGoldRewardClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keyId\",\"type\":\"uint256\"}],\"name\":\"isKey\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethReward\",\"type\":\"uint256\"}],\"name\":\"isOmegaReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keyId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isRegistered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"registered\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_keyId\",\"type\":\"uint256\"}],\"name\":\"isRemoved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSilverRewardClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"omegaKeys\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"removed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"order\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"keyId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_keyIds\",\"type\":\"uint256[]\"}],\"name\":\"register\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"releaseOrder\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ethReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_keyIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_disqualifiedPlayer\",\"type\":\"address\"}],\"name\":\"revertRewardClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OKG", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "500", "ConstructorArguments": "000000000000000000000000afba8c6b3875868a90e5055e791213258a9fe7a7", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}