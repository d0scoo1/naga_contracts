{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/Bridge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./utils/Pausable.sol\\\";\\nimport \\\"./utils/SafeMath.sol\\\";\\nimport \\\"./interfaces/IDepositExecute.sol\\\";\\nimport \\\"./interfaces/IBridge.sol\\\";\\nimport \\\"./interfaces/IERCHandler.sol\\\";\\n\\n/**\\n    @title Facilitates deposits, creation and votiing of deposit proposals, and deposit executions.\\n */\\ncontract Bridge is Pausable, SafeMath {\\n    bytes8 public _chainID;\\n    uint256 public _fee;\\n    address public _backendSrvAddress;\\n    address public _ownerAddress;\\n\\n    enum ProposalStatus {\\n        Inactive,\\n        Active,\\n        Passed,\\n        Executed,\\n        Cancelled\\n    }\\n\\n    bytes32 public _nativeResourceID;\\n\\n    // destinationChainID => number of deposits\\n    mapping(bytes8 => uint64) public _depositCounts;\\n    // resourceID => handler address\\n    mapping(bytes32 => address) public _resourceIDToHandlerAddress;\\n    // depositNonce => destinationChainID => bytes\\n    mapping(uint64 => mapping(bytes8 => bytes)) public _depositRecords;\\n    // destinationChainID + depositNonce => dataHash => bool\\n    mapping(bytes32 => mapping(bytes32 => bool)) public _executedProposals;\\n\\n    event Deposit(\\n        bytes8 originChainID,\\n        bytes8 indexed destinationChainID,\\n        bytes32 indexed resourceID,\\n        uint64 indexed depositNonce,\\n        address depositor,\\n        address recipientAddress,\\n        address tokenAddress,\\n        uint256 amount,\\n        bytes32 dataHash\\n    );\\n    event ProposalEvent(\\n        bytes8 indexed originChainID,\\n        bytes8 indexed destinationChainID,\\n        address indexed recipientAddress,\\n        uint256 amount,\\n        uint64 depositNonce,\\n        ProposalStatus status,\\n        bytes32 resourceID,\\n        bytes32 dataHash\\n    );\\n    event ExtraFeeSupplied(\\n        bytes8 originChainID,\\n        bytes8 destinationChainID,\\n        uint64 depositNonce,\\n        bytes32 resourceID,\\n        address recipientAddress,\\n        uint256 amount\\n    );\\n\\n    modifier onlyAdmin() {\\n        _onlyAdmin();\\n        _;\\n    }\\n\\n    modifier onlyBackendSrv() {\\n        _onlyBackendSrv();\\n        _;\\n    }\\n\\n    function _onlyAdmin() private view {\\n        require(msg.sender == _ownerAddress, \\\"sender doesn't have admin role\\\");\\n    }\\n\\n    function _onlyBackendSrv() private view {\\n        require(\\n            _backendSrvAddress == msg.sender,\\n            \\\"sender is not a backend service\\\"\\n        );\\n    }\\n\\n    /**\\n        @notice Initializes Bridge, creates and grants {msg.sender} the admin role,\\n        creates and grants {initialRelayers} the relayer role.\\n        @param chainID ID of chain the Bridge contract exists on.\\n     */\\n    constructor(\\n        bytes8 chainID,\\n        uint256 fee,\\n        address initBackendSrvAddress\\n    ) public {\\n        _chainID = chainID;\\n        _fee = fee;\\n        _backendSrvAddress = initBackendSrvAddress;\\n        _ownerAddress = msg.sender;\\n    }\\n\\n    /**\\n        @notice sets new backend srv.\\n        @notice Only callable by an address that currently has the admin role.\\n        @param newBackendSrv Address of new backend srv.\\n     */\\n    function adminSetBackendSrv(address newBackendSrv) external onlyAdmin {\\n        _backendSrvAddress = newBackendSrv;\\n    }\\n\\n\\n    /**\\n        @notice Removes admin role from {msg.sender} and grants it to {newAdmin}.\\n        @notice Only callable by an address that currently has the admin role.\\n        @param newAdmin Address that admin role will be granted to.\\n     */\\n    function renounceAdmin(address newAdmin) external onlyAdmin {\\n        _ownerAddress = newAdmin;\\n    }\\n\\n    /**\\n        @notice Pauses deposits, proposal creation and voting, and deposit executions.\\n        @notice Only callable by an address that currently has the admin role.\\n     */\\n    function adminPauseTransfers() external onlyAdmin {\\n        _pause();\\n    }\\n\\n    /**\\n        @notice Unpauses deposits, proposal creation and voting, and deposit executions.\\n        @notice Only callable by an address that currently has the admin role.\\n     */\\n    function adminUnpauseTransfers() external onlyAdmin {\\n        _unpause();\\n    }\\n\\n    /**\\n        @notice Sets a new resource for handler contracts that use the IERCHandler interface,\\n        and maps the {handlerAddress} to {resourceID} in {_resourceIDToHandlerAddress}.\\n        @notice Only callable by an address that currently has the admin role.\\n        @param handlerAddress Address of handler resource will be set for.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function adminSetResource(\\n        address handlerAddress,\\n        bytes32 resourceID,\\n        address tokenAddress\\n    ) external onlyAdmin {\\n        _resourceIDToHandlerAddress[resourceID] = handlerAddress;\\n        IERCHandler handler = IERCHandler(handlerAddress);\\n        handler.setResource(resourceID, tokenAddress);\\n    }\\n\\n    /**\\n        @notice sets resourceID for native token\\n        @dev can only be called through admin address\\n        @param resourceID resourceID for native token\\n     */\\n    function adminSetNativeResourceID(bytes32 resourceID) external onlyAdmin {\\n        _nativeResourceID = resourceID;\\n    }\\n\\n    /**\\n        @notice to change owner\\n        @dev can only be called by owner\\n        @param newOwner will be new owner\\n    */\\n    function adminChangeOwner(address newOwner) external onlyAdmin {\\n        _ownerAddress = newOwner;\\n    }\\n\\n\\n    /**\\n        @notice Sets a resource as burnable for handler contracts that use the IERCHandler interface.\\n        @notice Only callable by an address that currently has the admin role.\\n        @param handlerAddress Address of handler resource will be set for.\\n        @param tokenAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function adminSetBurnable(address handlerAddress, address tokenAddress)\\n        external\\n        onlyAdmin\\n    {\\n        IERCHandler handler = IERCHandler(handlerAddress);\\n        handler.setBurnable(tokenAddress);\\n    }\\n\\n    /**\\n        @notice Changes deposit fee.\\n        @notice Only callable by admin.\\n        @param newFee Value {_fee} will be updated to.\\n     */\\n    function adminChangeFee(uint256 newFee) external onlyAdmin {\\n        require(_fee != newFee, \\\"Current fee is equal to new fee\\\");\\n        _fee = newFee;\\n    }\\n\\n    /**\\n        @notice Used to manually withdraw funds from ERC safes.\\n        @param handlerAddress Address of handler to withdraw from.\\n        @param tokenAddress Address of token to withdraw.\\n        @param recipient Address to withdraw tokens to.\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to withdraw.\\n     */\\n    function adminWithdraw(\\n        address handlerAddress,\\n        address tokenAddress,\\n        address recipient,\\n        uint256 amountOrTokenID\\n    ) external onlyAdmin {\\n        IERCHandler handler = IERCHandler(handlerAddress);\\n        handler.withdraw(tokenAddress, recipient, amountOrTokenID);\\n    }\\n\\n    /**\\n        @notice Initiates a transfer using a specified handler contract.\\n        @notice Only callable when Bridge is not paused.\\n        @param destinationChainID ID of chain deposit will be bridged to.\\n        @param resourceID ResourceID used to find address of handler to be used for deposit.\\n        @param amountToLA to be converted to LA with bridge swap.\\n        @notice Emits {Deposit} event.\\n     */\\n    function deposit(\\n        bytes8 destinationChainID,\\n        bytes32 resourceID,\\n        uint256 amount,\\n        address recipientAddress,\\n        uint256 amountToLA\\n    ) external payable whenNotPaused {\\n        uint64 depositNonce = ++_depositCounts[destinationChainID];\\n        bytes memory data = abi.encode(amount, recipientAddress);\\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\\n        _depositRecords[depositNonce][destinationChainID] = data;\\n\\n        address tokenAddress;\\n        uint256 totalAmount = amount + amountToLA;\\n        if (resourceID == _nativeResourceID) {\\n            require(\\n                msg.value >= (totalAmount + _fee),\\n                \\\"Incorrect fee/amount supplied\\\"\\n            );\\n\\n            tokenAddress = address(0);\\n\\n        } else {\\n            require(msg.value >= _fee, \\\"Incorrect fee supplied\\\");\\n\\n            address handler = _resourceIDToHandlerAddress[resourceID];\\n            require(handler != address(0), \\\"resourceID not mapped to handler\\\");\\n\\n            tokenAddress = IDepositExecute(handler).deposit(\\n                resourceID,\\n                destinationChainID,\\n                depositNonce,\\n                msg.sender,\\n                recipientAddress,\\n                totalAmount\\n            );\\n        }\\n            if (amountToLA > 0) {\\n                emit ExtraFeeSupplied(\\n                    _chainID,\\n                    destinationChainID,\\n                    depositNonce,\\n                    resourceID,\\n                    recipientAddress,\\n                    amountToLA\\n                );\\n            }\\n\\n        emit Deposit(\\n            _chainID,\\n            destinationChainID,\\n            resourceID,\\n            depositNonce,\\n            msg.sender,\\n            recipientAddress,\\n            tokenAddress,\\n            amount,\\n            dataHash\\n        );\\n    }\\n\\n    /**\\n        @notice Executes a deposit proposal that is considered passed using a specified handler contract.\\n        @notice Only callable by relayers when Bridge is not paused.\\n        @param destinationChainID ID of chain where proposal is executed.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param depositNonce ID of deposited generated by origin Bridge contract.\\n        @notice Proposal must not have executed before.\\n        @notice Emits {ProposalEvent} event with status {Executed}.\\n     */\\n    function executeProposal(\\n        bytes8 originChainID,\\n        bytes8 destinationChainID,\\n        uint64 depositNonce,\\n        bytes32 resourceID,\\n        address payable recipientAddress,\\n        uint256 amount\\n    ) external onlyBackendSrv whenNotPaused {\\n        bytes memory data = abi.encode(amount, recipientAddress);\\n        bytes32 nonceAndID = keccak256(\\n            abi.encode(depositNonce, originChainID, destinationChainID)\\n        );\\n        bytes32 dataHash = keccak256(abi.encode(resourceID, data));\\n\\n        require(\\n            !_executedProposals[nonceAndID][dataHash],\\n            \\\"proposal already executed\\\"\\n        );\\n        require(destinationChainID == _chainID, \\\"ChainID Incorrect\\\");\\n\\n        _executedProposals[nonceAndID][dataHash] = true;\\n\\n        if (resourceID == _nativeResourceID) {\\n            recipientAddress.transfer(amount);\\n        } else {\\n            address handler = _resourceIDToHandlerAddress[resourceID];\\n            require(handler != address(0), \\\"resourceID not mapped to handler\\\");\\n\\n            IDepositExecute depositHandler = IDepositExecute(handler);\\n            depositHandler.executeProposal(\\n                resourceID,\\n                recipientAddress,\\n                amount\\n            );\\n        }\\n\\n        emit ProposalEvent(\\n            originChainID,\\n            destinationChainID,\\n            recipientAddress,\\n            amount,\\n            depositNonce,\\n            ProposalStatus.Executed,\\n            resourceID,\\n            dataHash\\n        );\\n    }\\n\\n    /**\\n        @notice to be called if owner wants to collect fees\\n        @dev can only be called by owner\\n        @param amount will be trasnfered to owner if contract balace is higher or equal to amount\\n    */\\n    function adminCollectFees(uint256 amount) external onlyAdmin {\\n        uint256 amountToTransfer = amount < address(this).balance\\n            ? amount\\n            : address(this).balance;\\n        msg.sender.transfer(amountToTransfer);\\n    }\\n\\n    /** \\n        @notice to deposit native token to the contract\\n        @dev to be called by admin\\n    */\\n    function depositFunds() external payable onlyAdmin {}\\n}\\n\"\r\n    },\r\n    \"/contracts/utils/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * note that this is a stripped down version of open zeppelin's safemath\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/SafeMath.sol\\n */\\n\\ncontract SafeMath {\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) public pure returns (uint256) {\\n        return _sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot overflow.\\n     */\\n    function _sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n}\"\r\n    },\r\n    \"/contracts/utils/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This is a stripped down version of Open zeppelin's Pausable contract.\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/EnumerableSet.sol\\n *\\n */\\ncontract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor () internal {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _whenNotPaused();\\n        _;\\n    }\\n\\n    function _whenNotPaused() private view {\\n        require(!_paused, \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenPaused() {\\n        _whenPaused();\\n        _;\\n    }\\n\\n    function _whenPaused() private view {\\n        require(_paused, \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\"\r\n    },\r\n    \"/contracts/interfaces/IERCHandler.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\n/**\\n    @title Interface to be used with handlers that support ERC20s and ERC721s.\\n */\\ninterface IERCHandler {\\n    /**\\n        @notice Correlates {resourceID} with {contractAddress}.\\n        @param resourceID ResourceID to be used when making deposits.\\n        @param contractAddress Address of contract to be called when a deposit is made and a deposited is executed.\\n     */\\n    function setResource(bytes32 resourceID, address contractAddress) external;\\n    /**\\n        @notice Marks {contractAddress} as mintable/burnable.\\n        @param contractAddress Address of contract to be used when making or executing deposits.\\n     */\\n    function setBurnable(address contractAddress) external;\\n    /**\\n        @notice Used to manually release funds from ERC safes.\\n        @param tokenAddress Address of token contract to release.\\n        @param recipient Address to release tokens to.\\n        @param amountOrTokenID Either the amount of ERC20 tokens or the ERC721 token ID to release.\\n     */\\n    function withdraw(address tokenAddress, address recipient, uint256 amountOrTokenID) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IDepositExecute.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\n/**\\n    @title Interface for handler contracts that support deposits and deposit executions.\\n    @author ChainSafe Systems.\\n */\\ninterface IDepositExecute {\\n    /**\\n        @notice It is intended that deposit are made using the Bridge contract.\\n        @param destinationChainID Chain ID deposit is expected to be bridged to.\\n        @param depositNonce This value is generated as an ID by the Bridge contract.\\n        @param depositer Address of account making the deposit in the Bridge contract.\\n     */\\n    function deposit(\\n        bytes32 resourceID,\\n        bytes8 destinationChainID,\\n        uint64 depositNonce,\\n        address depositer,\\n        address recipientAddress,\\n        uint256 amount\\n    ) external returns (address);\\n\\n    /**\\n        @notice It is intended that proposals are executed by the Bridge contract.\\n     */\\n    function executeProposal(bytes32 resourceID, address recipientAddress, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IBridge.sol\": {\r\n      \"content\": \"pragma solidity 0.6.4;\\n\\n/**\\n    @title Interface for Bridge contract.\\n    @author ChainSafe Systems.\\n */\\ninterface IBridge {\\n    /**\\n        @notice Exposing getter for {_chainID} instead of forcing the use of call.\\n        @return uint8 The {_chainID} that is currently set for the Bridge contract.\\n     */\\n    function _chainID() external returns (uint8);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"chainID\",\"type\":\"bytes8\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"initBackendSrvAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":false,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ExtraFeeSupplied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"enum Bridge.ProposalStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"ProposalEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_backendSrvAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_chainID\",\"outputs\":[{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"name\":\"_depositCounts\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"},{\"internalType\":\"bytes8\",\"name\":\"\",\"type\":\"bytes8\"}],\"name\":\"_depositRecords\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_executedProposals\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_nativeResourceID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_ownerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"_resourceIDToHandlerAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"adminChangeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"adminChangeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"adminCollectFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminPauseTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBackendSrv\",\"type\":\"address\"}],\"name\":\"adminSetBackendSrv\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"adminSetBurnable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"}],\"name\":\"adminSetNativeResourceID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"adminSetResource\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"adminUnpauseTransfers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"handlerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountOrTokenID\",\"type\":\"uint256\"}],\"name\":\"adminWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToLA\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositFunds\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes8\",\"name\":\"originChainID\",\"type\":\"bytes8\"},{\"internalType\":\"bytes8\",\"name\":\"destinationChainID\",\"type\":\"bytes8\"},{\"internalType\":\"uint64\",\"name\":\"depositNonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"resourceID\",\"type\":\"bytes32\"},{\"internalType\":\"address payable\",\"name\":\"recipientAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"renounceAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"sub\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Bridge", "CompilerVersion": "v0.6.4+commit.1dca32f3", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000000000000003493b995d0d8c226166c051ebe9b42c9125315c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}