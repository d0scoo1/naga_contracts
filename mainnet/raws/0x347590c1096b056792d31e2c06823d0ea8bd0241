{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/FlashMatchDai.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/IWETH.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IMorpho.sol\\\";\\nimport \\\"./interfaces/ICompound.sol\\\";\\nimport \\\"./interfaces/IERC3156FlashLender.sol\\\";\\nimport \\\"./interfaces/IERC3156FlashBorrower.sol\\\";\\n\\ncontract FlashMatchDai is IERC3156FlashBorrower {\\n    address public constant dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    address public constant cDai = 0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643;\\n    IMorpho public constant morpho =\\n        IMorpho(0x8888882f8f843896699869179fB6E4f7e3B58888);\\n    IComptroller public constant comptroller =\\n        IComptroller(0x3d9819210A31b4961b30EF54bE2aeD79B9c9Cd3B);\\n    IERC3156FlashLender public constant lender =\\n        IERC3156FlashLender(0x1EB4CF3A948E7D72A198fe073cCb8C7a948cD853);\\n\\n    constructor() {\\n        address[] memory cTokens = new address[](1);\\n        cTokens[0] = cDai;\\n        comptroller.enterMarkets(cTokens);\\n    }\\n\\n    /// @dev ERC-3156 Flash loan callback\\n    function onFlashLoan(\\n        address initiator,\\n        address, // token = dai\\n        uint256 amount,\\n        uint256, // fee = 0\\n        bytes calldata data\\n    ) external override returns (bytes32) {\\n        require(msg.sender == address(lender), \\\"FlashMatch: Untrusted lender\\\");\\n        require(\\n            initiator == address(this),\\n            \\\"FlashMatch: Untrusted loan initiator\\\"\\n        );\\n\\n        uint256 maxGasForMatching = abi.decode(data, (uint256));\\n\\n        // supply on Morpho\\n        IERC20(dai).approve(address(morpho), amount);\\n        morpho.supply(cDai, address(this), amount, maxGasForMatching);\\n        // transfer withdraw on Morpho\\n        morpho.withdraw(cDai, type(uint256).max);\\n\\n        return keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n    }\\n\\n    /// @dev Match dai market on Morpho.\\n    ///     - initiate a DAI flash loan\\n    ///     - supply them into Morpho to match on pool borrowers\\n    ///     - withdraw to do a transfer withdraw, and match on pool suppliers.\\n    ///     - reimburse the flash loan\\n    /// @dev Send some DAI dust on the contract, to avoid revert because of\\n    /// Morpho rounding errors.\\n    /// @param amount the amount of token to supply.\\n    /// @param maxGasForMatching the `maxGasForMatching` to use for the supply.\\n    function flashMatchDai(uint256 amount, uint256 maxGasForMatching) public {\\n        bytes memory data = abi.encode(maxGasForMatching);\\n        require(lender.flashFee(dai, amount) == 0, \\\"Flashloan is not free\\\");\\n        IERC20(dai).approve(\\n            address(lender),\\n            IERC20(dai).allowance(address(this), address(lender)) + amount\\n        );\\n        lender.flashLoan(this, dai, amount, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU AGPLv3\\npragma solidity ^0.8.0;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity 0.8.13;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IMorpho.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU AGPLv3\\npragma solidity 0.8.13;\\n\\n// prettier-ignore\\ninterface IMorpho {\\n\\n    /// STORAGE ///\\n\\n    function defaultMaxGasForMatching() external view returns (Types.MaxGasForMatching memory);\\n    function maxSortedUsers() external view returns (uint256);\\n    function dustThreshold() external view returns (uint256);\\n    function supplyBalanceInOf(address, address) external view returns (Types.SupplyBalance memory);\\n    function borrowBalanceInOf(address, address) external view returns (Types.BorrowBalance memory);\\n    function enteredMarkets(address) external view returns (address);\\n    function deltas(address) external view returns (Types.Delta memory);\\n    function marketsCreated() external view returns (address[] memory);\\n    function marketParameters(address) external view returns (Types.MarketParameters memory);\\n    function p2pDisabled(address) external view returns (bool);\\n    function p2pSupplyIndex(address) external view returns (uint256);\\n    function p2pBorrowIndex(address) external view returns (uint256);\\n    function lastPoolIndexes(address) external view returns (Types.LastPoolIndexes memory);\\n    function marketStatus(address) external view returns (Types.MarketStatus memory);\\n    // function comptroller() external view returns (IComptroller);\\n    // function interestRatesManager() external view returns (IInterestRatesManager);\\n    // function rewardsManager() external view returns (IRewardsManager);\\n    // function positionsManager() external view returns (IPositionsManager);\\n    // function incentiveVault() external view returns (IIncentivesVault);\\n    function treasuryVault() external view returns (address);\\n    function cEth() external view returns (address);\\n    function wEth() external view returns (address);\\n\\n    /// GETTERS ///\\n\\n    function updateP2PIndexes(address _poolTokenAddress) external;\\n    function getEnteredMarkets(address _user) external view returns (address[] memory enteredMarkets_);\\n    function getAllMarkets() external view returns (address[] memory marketsCreated_);\\n    function getHead(address _poolTokenAddress, Types.PositionType _positionType) external view returns (address head);\\n    function getNext(address _poolTokenAddress, Types.PositionType _positionType, address _user) external view returns (address next);\\n\\n    /// GOVERNANCE ///\\n\\n    function setMaxSortedUsers(uint256 _newMaxSortedUsers) external;\\n    function setDefaultMaxGasForMatching(Types.MaxGasForMatching memory _maxGasForMatching) external;\\n    function setTreasuryVault(address _newTreasuryVaultAddress) external;\\n    function setIncentivesVault(address _newIncentivesVault) external;\\n    function setRewardsManager(address _rewardsManagerAddress) external;\\n    function setDustThreshold(uint256 _dustThreshold) external;\\n    function setP2PDisable(address _poolTokenAddress, bool _p2pDisabled) external;\\n    function setReserveFactor(address _poolTokenAddress, uint256 _newReserveFactor) external;\\n    function setP2PIndexCursor(address _poolTokenAddress, uint16 _p2pIndexCursor) external;\\n    function setPauseStatus(address _poolTokenAddress) external;\\n    function setPartialPauseStatus(address _poolTokenAddress) external;\\n    function claimToTreasury(address _poolTokenAddress, uint256 _amount) external;\\n    function createMarket(address _poolTokenAddress, Types.MarketParameters calldata _params) external;\\n\\n    /// USERS ///\\n\\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount) external;\\n    function supply(address _poolTokenAddress, address _onBehalf, uint256 _amount, uint256 _maxGasForMatching) external;\\n    function borrow(address _poolTokenAddress, uint256 _amount) external;\\n    function borrow(address _poolTokenAddress, uint256 _amount, uint256 _maxGasForMatching) external;\\n    function withdraw(address _poolTokenAddress, uint256 _amount) external;\\n    function repay(address _poolTokenAddress, address _onBehalf, uint256 _amount) external;\\n    function liquidate(address _poolTokenBorrowedAddress, address _poolTokenCollateralAddress, address _borrower, uint256 _amount) external;\\n    function claimRewards(address[] calldata _cTokenAddresses, bool _tradeForMorphoToken) external;\\n}\\n\\nlibrary Types {\\n    /// ENUMS ///\\n\\n    enum PositionType {\\n        SUPPLIERS_IN_P2P,\\n        SUPPLIERS_ON_POOL,\\n        BORROWERS_IN_P2P,\\n        BORROWERS_ON_POOL\\n    }\\n\\n    /// STRUCTS ///\\n\\n    struct SupplyBalance {\\n        uint256 inP2P; // In supplier's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests earned by suppliers in peer-to-peer. Multiply by the peer-to-peer supply index to get the underlying amount.\\n        uint256 onPool; // In cToken. Multiply by the pool supply index to get the underlying amount.\\n    }\\n\\n    struct BorrowBalance {\\n        uint256 inP2P; // In borrower's peer-to-peer unit, a unit that grows in underlying value, to keep track of the interests paid by borrowers in peer-to-peer. Multiply by the peer-to-peer borrow index to get the underlying amount.\\n        uint256 onPool; // In cdUnit, a unit that grows in value, to keep track of the debt increase when borrowers are on Compound. Multiply by the pool borrow index to get the underlying amount.\\n    }\\n\\n    // Max gas to consume during the matching process for supply, borrow, withdraw and repay functions.\\n    struct MaxGasForMatching {\\n        uint64 supply;\\n        uint64 borrow;\\n        uint64 withdraw;\\n        uint64 repay;\\n    }\\n\\n    struct Delta {\\n        uint256 p2pSupplyDelta; // Difference between the stored peer-to-peer supply amount and the real peer-to-peer supply amount (in cToken).\\n        uint256 p2pBorrowDelta; // Difference between the stored peer-to-peer borrow amount and the real peer-to-peer borrow amount (in cdUnit).\\n        uint256 p2pSupplyAmount; // Sum of all stored peer-to-peer supply (in peer-to-peer unit).\\n        uint256 p2pBorrowAmount; // Sum of all stored peer-to-peer borrow (in peer-to-peer unit).\\n    }\\n\\n    struct AssetLiquidityData {\\n        uint256 collateralValue; // The collateral value of the asset.\\n        uint256 maxDebtValue; // The maximum possible debt value of the asset.\\n        uint256 debtValue; // The debt value of the asset.\\n        uint256 underlyingPrice; // The price of the token.\\n        uint256 collateralFactor; // The liquidation threshold applied on this token.\\n    }\\n\\n    struct LiquidityData {\\n        uint256 collateralValue; // The collateral value.\\n        uint256 maxDebtValue; // The maximum debt value possible.\\n        uint256 debtValue; // The debt value.\\n    }\\n\\n    // Variables are packed together to save gas (will not exceed their limit during Morpho's lifetime).\\n    struct LastPoolIndexes {\\n        uint32 lastUpdateBlockNumber; // The last time the peer-to-peer indexes were updated.\\n        uint112 lastSupplyPoolIndex; // Last pool supply index.\\n        uint112 lastBorrowPoolIndex; // Last pool borrow index.\\n    }\\n\\n    struct MarketParameters {\\n        uint16 reserveFactor; // Proportion of the interest earned by users sent to the DAO for each market, in basis point (100% = 10 000). The value is set at market creation.\\n        uint16 p2pIndexCursor; // Position of the peer-to-peer rate in the pool's spread. Determine the weights of the weighted arithmetic average in the indexes computations ((1 - p2pIndexCursor) * r^S + p2pIndexCursor * r^B) (in basis point).\\n    }\\n\\n    struct MarketStatus {\\n        bool isCreated; // Whether or not this market is created.\\n        bool isPaused; // Whether the market is paused or not (all entry points on Morpho are frozen; supply, borrow, withdraw, repay and liquidate).\\n        bool isPartiallyPaused; // Whether the market is partially paused or not (only supply and borrow are frozen).\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ICompound.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GNU AGPLv3\\npragma solidity ^0.8.0;\\n\\ninterface ICEth {\\n    function accrueInterest() external returns (uint256);\\n\\n    function borrowRate() external returns (uint256);\\n\\n    function borrowIndex() external returns (uint256);\\n\\n    function borrowBalanceStored(address) external returns (uint256);\\n\\n    function mint() external payable;\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function supplyRatePerBlock() external returns (uint256);\\n\\n    function redeem(uint256) external returns (uint256);\\n\\n    function redeemUnderlying(uint256) external returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address,\\n        address,\\n        uint256\\n    ) external returns (bool);\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function balanceOf(address) external returns (uint256);\\n\\n    function balanceOfUnderlying(address account) external returns (uint256);\\n\\n    function borrow(uint256) external returns (uint256);\\n\\n    function repayBorrow() external payable;\\n\\n    function borrowBalanceCurrent(address) external returns (uint256);\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n}\\n\\ninterface IComptroller {\\n    struct CompMarketState {\\n        /// @notice The market's last updated compBorrowIndex or compSupplyIndex\\n        uint224 index;\\n        /// @notice The block number the index was last updated at\\n        uint32 block;\\n    }\\n\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\n\\n    function closeFactorMantissa() external view returns (uint256);\\n\\n    function admin() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function markets(address)\\n        external\\n        view\\n        returns (\\n            bool isListed,\\n            uint256 collateralFactorMantissa,\\n            bool isComped\\n        );\\n\\n    function enterMarkets(address[] calldata cTokens) external returns (uint256[] memory);\\n\\n    function exitMarket(address cToken) external returns (uint256);\\n\\n    function mintAllowed(\\n        address cToken,\\n        address minter,\\n        uint256 mintAmount\\n    ) external returns (uint256);\\n\\n    function mintVerify(\\n        address cToken,\\n        address minter,\\n        uint256 mintAmount,\\n        uint256 mintTokens\\n    ) external;\\n\\n    function redeemAllowed(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemTokens\\n    ) external returns (uint256);\\n\\n    function redeemVerify(\\n        address cToken,\\n        address redeemer,\\n        uint256 redeemAmount,\\n        uint256 redeemTokens\\n    ) external;\\n\\n    function borrowAllowed(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external returns (uint256);\\n\\n    function borrowVerify(\\n        address cToken,\\n        address borrower,\\n        uint256 borrowAmount\\n    ) external;\\n\\n    function repayBorrowAllowed(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256);\\n\\n    function repayBorrowVerify(\\n        address cToken,\\n        address payer,\\n        address borrower,\\n        uint256 repayAmount,\\n        uint256 borrowerIndex\\n    ) external;\\n\\n    function liquidateBorrowAllowed(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount\\n    ) external returns (uint256);\\n\\n    function liquidateBorrowVerify(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        address liquidator,\\n        address borrower,\\n        uint256 repayAmount,\\n        uint256 seizeTokens\\n    ) external;\\n\\n    function seizeAllowed(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external returns (uint256);\\n\\n    function seizeVerify(\\n        address cTokenCollateral,\\n        address cTokenBorrowed,\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external;\\n\\n    function transferAllowed(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external returns (uint256);\\n\\n    function transferVerify(\\n        address cToken,\\n        address src,\\n        address dst,\\n        uint256 transferTokens\\n    ) external;\\n\\n    /*** Liquidity/Liquidation Calculations ***/\\n\\n    function liquidateCalculateSeizeTokens(\\n        address cTokenBorrowed,\\n        address cTokenCollateral,\\n        uint256 repayAmount\\n    ) external view returns (uint256, uint256);\\n\\n    function getAccountLiquidity(address)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function getHypotheticalAccountLiquidity(\\n        address,\\n        address,\\n        uint256,\\n        uint256\\n    )\\n        external\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function checkMembership(address, address) external view returns (bool);\\n\\n    function claimComp(address holder) external;\\n\\n    function claimComp(address holder, address[] memory cTokens) external;\\n\\n    function compSpeeds(address) external view returns (uint256);\\n\\n    function compSupplySpeeds(address) external view returns (uint256);\\n\\n    function compBorrowSpeeds(address) external view returns (uint256);\\n\\n    function compSupplyState(address) external view returns (CompMarketState memory);\\n\\n    function compBorrowState(address) external view returns (CompMarketState memory);\\n\\n    function getCompAddress() external view returns (address);\\n\\n    function _setPriceOracle(address newOracle) external returns (uint256);\\n\\n    function _setMintPaused(ICToken cToken, bool state) external returns (bool);\\n\\n    function _setBorrowPaused(ICToken cToken, bool state) external returns (bool);\\n\\n    function _setCollateralFactor(ICToken cToken, uint256 newCollateralFactorMantissa)\\n        external\\n        returns (uint256);\\n\\n    function _setCompSpeeds(\\n        ICToken[] memory cTokens,\\n        uint256[] memory supplySpeeds,\\n        uint256[] memory borrowSpeeds\\n    ) external;\\n}\\n\\ninterface IInterestRateModel {\\n    function getBorrowRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves\\n    ) external view returns (uint256);\\n\\n    function getSupplyRate(\\n        uint256 cash,\\n        uint256 borrows,\\n        uint256 reserves,\\n        uint256 reserveFactorMantissa\\n    ) external view returns (uint256);\\n}\\n\\ninterface ICToken {\\n    function isCToken() external returns (bool);\\n\\n    function transfer(address dst, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address src,\\n        address dst,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function balanceOfUnderlying(address owner) external returns (uint256);\\n\\n    function getAccountSnapshot(address account)\\n        external\\n        view\\n        returns (\\n            uint256,\\n            uint256,\\n            uint256,\\n            uint256\\n        );\\n\\n    function borrowRatePerBlock() external view returns (uint256);\\n\\n    function supplyRatePerBlock() external view returns (uint256);\\n\\n    function totalBorrowsCurrent() external returns (uint256);\\n\\n    function borrowBalanceCurrent(address account) external returns (uint256);\\n\\n    function borrowBalanceStored(address account) external view returns (uint256);\\n\\n    function exchangeRateCurrent() external returns (uint256);\\n\\n    function exchangeRateStored() external view returns (uint256);\\n\\n    function getCash() external view returns (uint256);\\n\\n    function seize(\\n        address liquidator,\\n        address borrower,\\n        uint256 seizeTokens\\n    ) external returns (uint256);\\n\\n    function borrowRate() external returns (uint256);\\n\\n    function borrowIndex() external view returns (uint256);\\n\\n    function borrow(uint256) external returns (uint256);\\n\\n    function repayBorrow(uint256) external returns (uint256);\\n\\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\\n\\n    function liquidateBorrow(\\n        address borrower,\\n        uint256 repayAmount,\\n        address cTokenCollateral\\n    ) external returns (uint256);\\n\\n    function underlying() external view returns (address);\\n\\n    function mint(uint256) external returns (uint256);\\n\\n    function redeemUnderlying(uint256) external returns (uint256);\\n\\n    function accrueInterest() external returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function totalBorrows() external view returns (uint256);\\n\\n    function accrualBlockNumber() external view returns (uint256);\\n\\n    function totalReserves() external view returns (uint256);\\n\\n    function interestRateModel() external view returns (IInterestRateModel);\\n\\n    function reserveFactorMantissa() external view returns (uint256);\\n\\n    function initialExchangeRateMantissa() external view returns (uint256);\\n\\n    /*** Admin Functions ***/\\n\\n    function _setPendingAdmin(address payable newPendingAdmin) external returns (uint256);\\n\\n    function _acceptAdmin() external returns (uint256);\\n\\n    function _setComptroller(IComptroller newComptroller) external returns (uint256);\\n\\n    function _setReserveFactor(uint256 newReserveFactorMantissa) external returns (uint256);\\n\\n    function _reduceReserves(uint256 reduceAmount) external returns (uint256);\\n\\n    function _setInterestRateModel(IInterestRateModel newInterestRateModel)\\n        external\\n        returns (uint256);\\n}\\n\\ninterface ICEther is ICToken {\\n    function mint() external payable;\\n\\n    function repayBorrow() external payable;\\n}\\n\\ninterface ICompoundOracle {\\n    function getUnderlyingPrice(address) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(\\n        IERC3156FlashBorrower receiver,\\n        address token,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\n// Copyright (C) 2021 Dai Foundation\\n//\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU Affero General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n//\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU Affero General Public License for more details.\\n//\\n// You should have received a copy of the GNU Affero General Public License\\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\npragma solidity 0.8.13;\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(\\n        address initiator,\\n        address token,\\n        uint256 amount,\\n        uint256 fee,\\n        bytes calldata data\\n    ) external returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"cDai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"comptroller\",\"outputs\":[{\"internalType\":\"contract IComptroller\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dai\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxGasForMatching\",\"type\":\"uint256\"}],\"name\":\"flashMatchDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lender\",\"outputs\":[{\"internalType\":\"contract IERC3156FlashLender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"morpho\",\"outputs\":[{\"internalType\":\"contract IMorpho\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onFlashLoan\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "FlashMatchDai", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}