{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"ousdKeeper.sol\": {\r\n      \"content\": \"pragma solidity 0.8.7;\\n\\ninterface KeeperCompatibleInterface {\\n    function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\\n    function performUpkeep(bytes calldata performData) external;\\n}\\n\\n\\ncontract OusdKeeper is KeeperCompatibleInterface {\\n\\n    event ConfigUpdated(bytes32 config);\\n\\n    address constant vault = 0xE75D77B1865Ae93c7eaa3040B038D7aA7BC02F70;\\n    address constant dripper = 0x80C898ae5e56f888365E235CeB8CEa3EB726CB58;\\n    address constant owner = 0xF14BBdf064E3F67f51cd9BD646aE3716aD938FDC;\\n    uint24 immutable windowStart; // seconds after start of day\\n    uint24 immutable windowEnd; // seconds after start of day\\n    uint256 lastRunDay = 0;\\n    bytes32 public config;\\n    \\n\\n    constructor(\\n        uint24 windowStart_,\\n        uint24 windowEnd_,\\n        bytes32 config_\\n    ) {\\n        windowStart = windowStart_;\\n        windowEnd = windowEnd_;\\n        config = config_;\\n    }\\n\\n    function setConfig(bytes32 config_) external {\\n        require(msg.sender == owner);\\n        config = config_;\\n        emit ConfigUpdated(config);\\n    }\\n\\n    function checkUpkeep(bytes calldata checkData)\\n        external\\n        view\\n        override\\n        returns (bool upkeepNeeded, bytes memory performData)\\n    {\\n        (bool runRebase, bool runAllocate) = _shouldRun();\\n        // If either can run, let's go!\\n        upkeepNeeded = (runRebase || runAllocate);\\n        performData = checkData;\\n    }\\n\\n    function performUpkeep(bytes calldata performData) external override {\\n        (bool runRebase, bool runAllocate) = _shouldRun();\\n        if (runRebase || runAllocate) {\\n            // write today, so that we only run once per day\\n            lastRunDay = (block.timestamp / 86400);\\n        }\\n        \\n    \\n        // Both commands run and do not revert if they fail so that the last run\\n        // day is still written, and the keepers do not empty their gas running\\n        // the failing method over and over again.\\n\\n        // Collect and rebase first, so that the allocate can allocate dripped rewards\\n        if (runRebase) {\\n            dripper.call(abi.encodeWithSignature(\\\"collectAndRebase()\\\"));\\n        }\\n\\n        if (runAllocate) {\\n            vault.call(abi.encodeWithSignature(\\\"allocate()\\\"));\\n        }\\n        \\n    }\\n\\n    function _shouldRun()\\n        internal\\n        view\\n        returns (bool runRebase, bool runAllocate)\\n    {\\n        bytes32 _config = config; // Gas savings\\n\\n        // Have we run today?\\n        uint256 day = block.timestamp / 86400;\\n        if (lastRunDay >= day) {\\n            return (false, false);\\n        }\\n\\n        // Are we in the window?\\n        uint256 daySeconds = block.timestamp % 86400;\\n        if (daySeconds < windowStart || daySeconds > windowEnd) {\\n            return (false, false);\\n        }\\n\\n        // Load schedule\\n        uint8 rebaseDays = uint8(_config[0]); // day of week bits\\n        uint8 allocateDays = uint8(_config[1]); // day of week bits\\n\\n        // Weekday\\n        uint8 weekday = uint8((day + 4) % 7);\\n\\n        // Need a rebase?\\n        if (((rebaseDays >> weekday) & 1) != 0) {\\n            runRebase = true;\\n        }\\n\\n        // Need an allocate?\\n        if (((allocateDays >> weekday) & 1) != 0) {\\n            runAllocate = true;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"ousdKeeper.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"windowStart_\",\"type\":\"uint24\"},{\"internalType\":\"uint24\",\"name\":\"windowEnd_\",\"type\":\"uint24\"},{\"internalType\":\"bytes32\",\"name\":\"config_\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"config\",\"type\":\"bytes32\"}],\"name\":\"ConfigUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"checkData\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"upkeepNeeded\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"config_\",\"type\":\"bytes32\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OusdKeeper", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000624d00000000000000000000000000000000000000000000000000000000000065d1ff09000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}