{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/staking/KermanRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport {Address} from \\\"../lib/Address.sol\\\";\\nimport {Adminable} from \\\"../lib/Adminable.sol\\\";\\nimport {Initializable} from \\\"../lib/Initializable.sol\\\";\\nimport {SafeERC20} from \\\"../lib/SafeERC20.sol\\\";\\nimport {IKermanERC20} from \\\"../token/KermanERC20.sol\\\";\\nimport {IERC20} from \\\"../token/IERC20.sol\\\";\\nimport {ISablier} from \\\"../global/ISablier.sol\\\";\\n\\ncontract KermanRewards is Adminable, Initializable {\\n    /* ========== Libraries ========== */\\n\\n    using Address for address;\\n    using SafeERC20 for IERC20;\\n\\n    /* ========== Variables ========== */\\n\\n    IKermanERC20 public stakingToken;\\n    IERC20 public rewardsToken;\\n\\n    ISablier public sablierContract;\\n    uint256 public sablierStreamId;\\n    uint256 public stakeDeadline;\\n\\n    uint256 public sablierStartTime;\\n    uint256 public sablierStopTime;\\n    uint256 public sablierRatePerSecond;\\n\\n    uint256 public totalStaked;\\n    mapping (address => uint256) public staked;\\n    mapping (address => uint256) public claimed;\\n\\n    /* ========== Events ========== */\\n\\n    event Staked(address indexed _user, uint256 _amount);\\n\\n    event Claimed(address indexed _user, uint256 _amount);\\n\\n    event Burnt(address indexed _user, uint256 _amount);\\n\\n    event SablierContractSet(address _sablierContract);\\n\\n    event SablierStreamIdSet(uint256 _streamId);\\n\\n    event StakeDeadlineSet(uint256 stakeDeadline);\\n\\n    /* ========== Restricted Functions ========== */\\n\\n    function init(\\n        address _sablierContract,\\n        address _stakingToken,\\n        address _rewardsToken,\\n        uint256 _stakeDeadline\\n    )\\n        external\\n        onlyAdmin\\n        initializer\\n    {\\n        require (\\n            _rewardsToken.isContract(),\\n            \\\"KermanRewards: rewards token is not a contract\\\"\\n        );\\n\\n        require (\\n            _stakingToken.isContract(),\\n            \\\"KermanRewards: staking token is not a contract\\\"\\n        );\\n\\n        require (\\n            _sablierContract.isContract(),\\n            \\\"KermanRewards: the sablier contract is invalid\\\"\\n        );\\n        stakingToken = IKermanERC20(_stakingToken);\\n        rewardsToken = IERC20(_rewardsToken);\\n        sablierContract = ISablier(_sablierContract);\\n        stakeDeadline = _stakeDeadline;\\n    }\\n\\n\\n    /**\\n     * @notice Sets the Sablier contract address\\n     */\\n    function setSablierContract(\\n        address _sablierContract\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require (\\n            _sablierContract.isContract(),\\n            \\\"StakingAccrualERC20: address is not a contract\\\"\\n        );\\n\\n        sablierContract = ISablier(_sablierContract);\\n\\n        emit SablierContractSet(_sablierContract);\\n    }\\n\\n    /**\\n     * @notice Sets the Sablier stream ID\\n     */\\n    function setSablierStreamId(\\n        uint256 _sablierStreamId\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        require (\\n            sablierStreamId != _sablierStreamId,\\n            \\\"KermanRewards: the same stream ID is already set\\\"\\n        );\\n\\n        (, address recipient,, address tokenAddress, uint256 startTime, uint256 stopTime,, uint256 ratePerSecond) = sablierContract.getStream(_sablierStreamId);\\n\\n        require(\\n            tokenAddress == address(rewardsToken),\\n            \\\"KermanRewards: token of the stream is not current rewardsToken\\\"\\n        );\\n\\n        require (\\n            recipient == address(this),\\n            \\\"KermanRewards: recipient of stream is not current contract\\\"\\n        );\\n\\n        sablierStartTime = startTime;\\n        sablierStopTime = stopTime;\\n        sablierRatePerSecond = ratePerSecond;\\n\\n        sablierStreamId = _sablierStreamId;\\n\\n        emit SablierStreamIdSet(sablierStreamId);\\n    }\\n\\n    function setStakeDeadline(uint256 _stakeDeadline)\\n        external\\n        onlyAdmin\\n    {\\n        stakeDeadline = _stakeDeadline;\\n\\n        emit StakeDeadlineSet(stakeDeadline);\\n    }\\n\\n    /* ========== Public Functions ========== */\\n\\n    /**\\n     * @notice Withdraws from the sablier stream if possible\\n     */\\n    function claimStreamFunds()\\n        public\\n    {\\n        if (address(sablierContract) == address(0) || sablierStreamId == 0) {\\n            return;\\n        }\\n\\n        try sablierContract.balanceOf(sablierStreamId, address(this)) returns (uint256 availableBalance) {\\n            sablierContract.withdrawFromStream(sablierStreamId, availableBalance);\\n        } catch {\\n            return;\\n        }\\n\\n    }\\n\\n    function stake() external {\\n        uint256 userBalance = stakingToken.balanceOf(msg.sender);\\n\\n        require(\\n            userBalance > 0,\\n            \\\"KermanRewards: balance of staking token is 0\\\"\\n        );\\n\\n        require(\\n            currentTimestamp() < stakeDeadline,\\n            \\\"KermanRewards: staking period finished\\\"\\n        );\\n\\n        _mintShares(msg.sender, userBalance);\\n\\n        stakingToken.burnFrom(msg.sender, userBalance);\\n\\n        emit Staked(msg.sender, userBalance);\\n    }\\n\\n    function claim() external {\\n        require(\\n            staked[msg.sender] > 0,\\n            \\\"KermanRewards: user does not have staked balance\\\"\\n        );\\n\\n        require(\\n            currentTimestamp() > stakeDeadline,\\n            \\\"KermanRewards: stake period is not finished\\\"\\n        );\\n\\n        uint256 _amount = rewardsAvailable(msg.sender);\\n\\n        require(\\n            _amount > 0,\\n            \\\"KermanRewards: User has not rewards to claim\\\"\\n        );\\n\\n        claimed[msg.sender] = claimed[msg.sender] + _amount;\\n\\n        claimStreamFunds();\\n\\n        rewardsToken.safeTransfer(\\n            msg.sender,\\n            _amount\\n        );\\n\\n        emit Claimed(msg.sender, _amount);\\n    }\\n\\n    /* ========== View Functions ========== */\\n\\n    /**\\n     * @notice Show the amount of tokens from sablier stream\\n     */\\n    function rewardsAvailable(address _user)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        uint256 timestamp = currentTimestamp();\\n\\n        if (\\n            timestamp > stakeDeadline &&\\n            timestamp >= sablierStartTime &&\\n            staked[_user] > 0\\n        ) {\\n            uint256 claimDuration = _getStopTime(timestamp) - sablierStartTime;\\n            // (staked[user] / totalStaked) * sablierRatePerSecond * claimDuration\\n            return staked[_user] *\\n                sablierRatePerSecond *\\n                claimDuration / totalStaked -\\n                claimed[_user];\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function currentTimestamp()\\n        public\\n        virtual\\n        view\\n        returns (uint256)\\n    {\\n        return block.timestamp;\\n    }\\n\\n    /* ========== Private Functions ========== */\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     */\\n    function _mintShares(\\n        address account,\\n        uint256 amount\\n    )\\n        private\\n    {\\n        totalStaked = totalStaked + amount;\\n        staked[account] = staked[account] + amount;\\n    }\\n\\n    function _getStopTime(\\n        uint256 timestamp\\n    )\\n        private\\n        view\\n        returns (uint256)\\n    {\\n         if( sablierStopTime < timestamp) {\\n            return sablierStopTime;\\n        } else {\\n            return timestamp;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev Collection of functions related to the address type.\\n *      Take from OpenZeppelin at\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Adminable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nimport { Storage } from \\\"./Storage.sol\\\";\\n\\n/**\\n * @title Adminable\\n * @author dYdX\\n *\\n * @dev EIP-1967 Proxy Admin contract.\\n */\\ncontract Adminable {\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     *  This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1.\\n     */\\n    bytes32 internal constant ADMIN_SLOT =\\n    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n    * @dev Modifier to check whether the `msg.sender` is the admin.\\n    *  If it is, it will run the function. Otherwise, it will revert.\\n    */\\n    modifier onlyAdmin() {\\n        require(\\n            msg.sender == getAdmin(),\\n            \\\"Adminable: caller is not admin\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @return The EIP-1967 proxy admin\\n     */\\n    function getAdmin()\\n        public\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(Storage.load(ADMIN_SLOT))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * Taken from OpenZeppelin\\n */\\ncontract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport {IERC20} from \\\"../token/IERC20.sol\\\";\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary SafeERC20 {\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        /* solhint-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(0x095ea7b3, to, value)\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: APPROVE_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        /* solhint-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(0xa9059cbb, to, value)\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        /* solhint-disable-next-line */\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(\\n                0x23b872dd,\\n                from,\\n                to,\\n                value\\n            )\\n        );\\n\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"SafeERC20: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/KermanERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n/**\\n *Submitted for verification at Etherscan.io on 2020-08-27\\n*/\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @title ERC20 interface\\n * @dev see https://github.com/ethereum/EIPs/issues/20\\n */\\ninterface IKermanERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address who) external view returns (uint256);\\n\\n  function allowance(address owner, address spender)\\n    external view returns (uint256);\\n\\n  function transfer(address to, uint256 value) external returns (bool);\\n\\n  function approve(address spender, uint256 value)\\n    external returns (bool);\\n\\n  function transferFrom(address from, address to, uint256 value)\\n    external returns (bool);\\n\\n  function burnFrom(address account, uint256 amount) external;\\n\\n  event Transfer(\\n    address indexed from,\\n    address indexed to,\\n    uint256 value\\n  );\\n\\n  event Approval(\\n    address indexed owner,\\n    address indexed spender,\\n    uint256 value\\n  );\\n}\\n\\n/**\\n * @title SafeMath\\n * @dev Math operations with safety checks that throw on error\\n */\\nlibrary SafeMath {\\n\\n  /**\\n  * @dev Multiplies two numbers, throws on overflow.\\n  */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n    }\\n        uint256 c = a * b;\\n        assert(c / a == b);\\n        return c;\\n    }\\n\\n  /**\\n  * @dev Integer division of two numbers, truncating the quotient.\\n  */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\\n    // uint256 c = a / b;\\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n        return a / b;\\n    }\\n\\n  /**\\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\\n  */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        assert(b <= a);\\n        return a - b;\\n    }\\n\\n  /**\\n  * @dev Adds two numbers, throws on overflow.\\n  */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        assert(c >= a);\\n        return c;\\n    }\\n}\\n\\n    /**\\n    * @title Standard ERC20 token\\n    *\\n    * @dev Implementation of the basic standard token.\\n    * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\\n    * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\\n    */\\ncontract KermanERC20 is IKermanERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowed;\\n\\n    uint256 private _totalSupply;\\n    string public name;\\n    string public symbol;\\n    uint8 public decimals;\\n\\n    /**\\n    * @dev Total number of tokens in existence\\n    */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n    * @dev Gets the balance of the specified address.\\n    * @param owner The address to query the the balance of.\\n    * @return An uint256 representing the amount owned by the passed address.\\n    */\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        return _balances[owner];\\n    }\\n\\n    /**\\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\\n    * @param owner address The address which owns the funds.\\n    * @param spender address The address which will spend the funds.\\n    * @return A uint256 specifying the amount of tokens still available for the spender.\\n    */\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _allowed[owner][spender];\\n    }\\n\\n\\n    /**\\n    * @dev Transfer token for a specified address\\n    * @param to The address to transfer to.\\n    * @param value The amount to be transferred.\\n    */\\n    function transfer(address to, uint256 value) public override returns (bool) {\\n        require(value <= _balances[msg.sender], \\\"\\\");\\n        require(to != address(0), \\\"\\\");\\n\\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        emit Transfer(msg.sender, to, value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n    * @param spender The address which will spend the funds.\\n    * @param value The amount of tokens to be spent.\\n    */\\n    function approve(address spender, uint256 value) public override returns (bool) {\\n        require(spender != address(0), \\\"\\\");\\n\\n        _allowed[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Transfer tokens from one address to another\\n    * @param from address The address which you want to send tokens from\\n    * @param to address The address which you want to transfer to\\n    * @param value uint256 the amount of tokens to be transferred\\n    */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    )\\n        public\\n        override\\n        returns (bool)\\n    {\\n        require(value <= _balances[from], \\\"\\\");\\n        require(value <= _allowed[from][msg.sender], \\\"\\\");\\n        require(to != address(0), \\\"\\\");\\n\\n        _balances[from] = _balances[from].sub(value);\\n        _balances[to] = _balances[to].add(value);\\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed_[_spender] == 0. To increment\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param spender The address which will spend the funds.\\n    * @param addedValue The amount of tokens to increase the allowance by.\\n    */\\n    function increaseAllowance(\\n        address spender,\\n        uint256 addedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        require(spender != address(0), \\\"\\\");\\n\\n        _allowed[msg.sender][spender] = (\\n        _allowed[msg.sender][spender].add(addedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\\n    * approve should be called when allowed_[_spender] == 0. To decrement\\n    * allowed value is better to use this function to avoid 2 calls (and wait until\\n    * the first transaction is mined)\\n    * From MonolithDAO Token.sol\\n    * @param spender The address which will spend the funds.\\n    * @param subtractedValue The amount of tokens to decrease the allowance by.\\n    */\\n    function decreaseAllowance(\\n        address spender,\\n        uint256 subtractedValue\\n    )\\n        public\\n        returns (bool)\\n    {\\n        require(spender != address(0), \\\"\\\");\\n\\n        _allowed[msg.sender][spender] = (\\n        _allowed[msg.sender][spender].sub(subtractedValue));\\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\\n        return true;\\n    }\\n\\n    /**\\n    * @dev Internal function that mints an amount of the token and assigns it to\\n    * an account. This encapsulates the modification of balances such that the\\n    * proper events are emitted.\\n    * @param account The account that will receive the created tokens.\\n    * @param amount The amount that will be created.\\n    */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"\\\");\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n    * @dev Internal function that burns an amount of the token of a given\\n    * account.\\n    * @param account The account whose tokens will be burnt.\\n    * @param amount The amount that will be burnt.\\n    */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"\\\");\\n        require(amount <= _balances[account], \\\"\\\");\\n\\n        _totalSupply = _totalSupply.sub(amount);\\n        _balances[account] = _balances[account].sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n    * @dev Internal function that burns an amount of the token of a given\\n    * account, deducting from the sender's allowance for said account. Uses the\\n    * internal burn function.\\n    * @param account The account whose tokens will be burnt.\\n    * @param amount The amount that will be burnt.\\n    */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        require(amount <= _allowed[account][msg.sender], \\\"\\\");\\n\\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\\n        // this function needs to emit an event with the updated approval.\\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\\n        amount);\\n        _burn(account, amount);\\n    }\\n\\n    function burnFrom(address account, uint256 amount) public override {\\n        _burnFrom(account, amount);\\n    }\\n}\\n\\n/**\\n * @title Template contract for social money, to be used by TokenFactory\\n * @author Jake Goh Si Yuan @ jakegsy, jake@jakegsy.com\\n */\\n\\n\\n\\ncontract KermanSocialMoney is KermanERC20 {\\n\\n    /**\\n     * @dev Constructor on SocialMoney\\n     * @param _name string Name parameter of Token\\n     * @param _symbol string Symbol parameter of Token\\n     * @param _decimals uint8 Decimals parameter of Token\\n     * @param _proportions uint256[3] Parameter that dictates how totalSupply will be divvied up,\\n                            _proportions[0] = Vesting Beneficiary Initial Supply\\n                            _proportions[1] = Turing Supply\\n                            _proportions[2] = Vesting Beneficiary Vesting Supply\\n     * @param _vestingBeneficiary address Address of the Vesting Beneficiary\\n     * @param _platformWallet Address of Turing platform wallet\\n     * @param _tokenVestingInstance address Address of Token Vesting contract\\n     */\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals,\\n        uint256[3] memory _proportions,\\n        address _vestingBeneficiary,\\n        address _platformWallet,\\n        address _tokenVestingInstance\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        uint256 totalProportions = _proportions[0] + _proportions[1] + _proportions[2];\\n\\n        _mint(_vestingBeneficiary, _proportions[0]);\\n        _mint(_platformWallet, _proportions[1]);\\n        _mint(_tokenVestingInstance, _proportions[2]);\\n\\n        //Sanity check that the totalSupply is exactly where we want it to be\\n        assert(totalProportions == totalSupply());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/token/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address recipient,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    )\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(\\n        address spender,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    )\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/global/ISablier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @title ISablier\\n * @author Sablier\\n */\\ninterface ISablier {\\n    /**\\n     * @notice Emits when a stream is successfully created.\\n     */\\n    event CreateStream(\\n        uint256 indexed streamId,\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 deposit,\\n        address tokenAddress,\\n        uint256 startTime,\\n        uint256 stopTime\\n    );\\n\\n    /**\\n     * @notice Emits when the recipient of a stream withdraws a portion or all their pro rata share of the stream.\\n     */\\n    event WithdrawFromStream(uint256 indexed streamId, address indexed recipient, uint256 amount);\\n\\n    /**\\n     * @notice Emits when a stream is successfully cancelled and tokens are transferred back on a pro rata basis.\\n     */\\n    event CancelStream(\\n        uint256 indexed streamId,\\n        address indexed sender,\\n        address indexed recipient,\\n        uint256 senderBalance,\\n        uint256 recipientBalance\\n    );\\n\\n    function balanceOf(uint256 streamId, address who) external view returns (uint256 balance);\\n\\n    function getStream(uint256 streamId)\\n        external\\n        view\\n        returns (\\n            address sender,\\n            address recipient,\\n            uint256 deposit,\\n            address token,\\n            uint256 startTime,\\n            uint256 stopTime,\\n            uint256 remainingBalance,\\n            uint256 ratePerSecond\\n        );\\n\\n    function createStream(\\n        address recipient,\\n        uint256 deposit,\\n        address tokenAddress,\\n        uint256 startTime,\\n        uint256 stopTime\\n    )\\n        external\\n        returns (uint256 streamId);\\n\\n    function withdrawFromStream(uint256 streamId, uint256 funds) external returns (bool);\\n\\n    function cancelStream(uint256 streamId) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/lib/Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.4;\\n\\nlibrary Storage {\\n\\n    /**\\n     * @dev Performs an SLOAD and returns the data in the slot.\\n     */\\n    function load(\\n        bytes32 slot\\n    )\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 result;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            result := sload(slot)\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Performs an SSTORE to save the value to the slot.\\n     */\\n    function store(\\n        bytes32 slot,\\n        bytes32 value\\n    )\\n        internal\\n    {\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            sstore(slot, value)\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Burnt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_sablierContract\",\"type\":\"address\"}],\"name\":\"SablierContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_streamId\",\"type\":\"uint256\"}],\"name\":\"SablierStreamIdSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeDeadline\",\"type\":\"uint256\"}],\"name\":\"StakeDeadlineSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimStreamFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sablierContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_stakeDeadline\",\"type\":\"uint256\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"rewardsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sablierContract\",\"outputs\":[{\"internalType\":\"contract ISablier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sablierRatePerSecond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sablierStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sablierStopTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sablierStreamId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_sablierContract\",\"type\":\"address\"}],\"name\":\"setSablierContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sablierStreamId\",\"type\":\"uint256\"}],\"name\":\"setSablierStreamId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_stakeDeadline\",\"type\":\"uint256\"}],\"name\":\"setStakeDeadline\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingToken\",\"outputs\":[{\"internalType\":\"contract IKermanERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "KermanRewards", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}