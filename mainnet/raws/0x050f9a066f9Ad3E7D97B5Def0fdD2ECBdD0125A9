{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Finns.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\nimport \\\"@beskay/erc721b/contracts/ERC721B.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nlibrary LibPart {\\r\\n    bytes32 public constant TYPE_HASH = keccak256(\\\"Part(address account,uint96 value)\\\");\\r\\n\\r\\n    struct Part {\\r\\n        address payable account;\\r\\n        uint96 value;\\r\\n    }\\r\\n\\r\\n    function hash(Part memory part) internal pure returns (bytes32) {\\r\\n        return keccak256(abi.encode(TYPE_HASH, part.account, part.value));\\r\\n    }\\r\\n}\\r\\n\\r\\n// Developer: uglyrobot.eth\\r\\ncontract HouseOfFinns is ERC721B, Ownable, ReentrancyGuard {\\r\\n    using Strings for uint256;\\r\\n\\r\\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\r\\n\\r\\n    /*\\r\\n     * bytes4(keccak256('getRoyalties(LibAsset.AssetType)')) == 0x44c74bcc\\r\\n     */\\r\\n    bytes4 private constant _INTERFACE_ID_ROYALTIES = 0x44c74bcc;\\r\\n\\r\\n    string public hofProvenance; // Hash of all images\\r\\n    \\r\\n    string private _licenseText;\\r\\n    bool public licenseLocked; // Init false. Team can't edit the license after this is flipped.\\r\\n    \\r\\n    string private _baseTokenURI; // Will be updated with IPFS url once minted out\\r\\n    bool public baseURILocked; // Init false. Team can't change the baseURI after flipping this, making the metadata truly locked forever.\\r\\n    string public contractURI; //used by OpenSea, not an official standard\\r\\n    \\r\\n    uint256 public hofPrice = 80000000000000000; // 0.08 ETH\\r\\n    uint96 private _royaltyBPS = 500; // 5% royalty for Rarible/Mintable\\r\\n    address private _royaltyReceiver; //address of wallet to receive royalties. Defaults to owner().\\r\\n\\r\\n    uint256 public constant HOF_MAX = 10000; //cannot be changed\\r\\n    uint256 public maxHofPurchase = 50; //max per mint, to make sale fairer.\\r\\n\\r\\n    bool public saleIsActive;// Init false.\\r\\n\\r\\n    uint256 public marketingReserve = 850; // Reserve for marketing - Giveaways/Prizes etc\\r\\n\\r\\n    address public withdrawAddress; //address of profits wallet\\r\\n    \\r\\n\\r\\n    event licenseIsLocked(string _licenseText);\\r\\n    event metadataLocked(string _baseTokenURI);\\r\\n\\r\\n    constructor(\\r\\n        address _teamWallet, \\r\\n        string memory _initLicenseText, \\r\\n        string memory _initBaseTokenURI,\\r\\n        string memory _ContractURI\\r\\n    ) ERC721B(\\\"House of Finns\\\", \\\"HOF\\\") payable {\\r\\n        withdrawAddress = _teamWallet; //set marketing team address\\r\\n        _royaltyReceiver = _teamWallet; //default to owner\\r\\n        _licenseText = _initLicenseText;\\r\\n        _baseTokenURI = _initBaseTokenURI;\\r\\n        contractURI = _ContractURI;\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier contractOwner() {\\r\\n        _isOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * This actually saves a chunk of contract deployment gas when modifier is used multiple times.\\r\\n    */\\r\\n    function _isOwner() internal view {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: not the owner\\\");\\r\\n    }\\r\\n    \\r\\n    function withdraw() public {\\r\\n        require(withdrawAddress == msg.sender, \\\"Withdrawl wallet only\\\");\\r\\n\\r\\n        uint balance = address(this).balance;\\r\\n        payable(msg.sender).transfer(balance);\\r\\n    }\\r\\n\\r\\n    //Rarible royalty interface new\\r\\n    function getRaribleV2Royalties(uint256 /*id*/) external view returns (LibPart.Part[] memory) {\\r\\n         LibPart.Part[] memory _royalties = new LibPart.Part[](1);\\r\\n        _royalties[0].value = _royaltyBPS;\\r\\n        _royalties[0].account = payable(_royaltyReceiver);\\r\\n        return _royalties;\\r\\n    }\\r\\n\\r\\n    //Mintable royalty handler\\r\\n    function royaltyInfo(uint256 /*_tokenId*/, uint256 _salePrice) external view returns (address receiver, uint256 royaltyAmount) {\\r\\n       return (_royaltyReceiver, (_salePrice * _royaltyBPS)/10000);\\r\\n    }\\r\\n\\r\\n    // Register support for our two royalty standards, falling back to inherited contracts\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721B) returns (bool) {\\r\\n        if(interfaceId == _INTERFACE_ID_ROYALTIES) {\\r\\n            return true;\\r\\n        }\\r\\n        if(interfaceId == _INTERFACE_ID_ERC2981) {\\r\\n            return true;\\r\\n        }\\r\\n        return super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Slightly more gas efficient than balanceOf for merely returning ownership status.\\r\\n     */\\r\\n    function isFinnsOwner(address owner) public view virtual returns (bool) {\\r\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\r\\n\\r\\n        uint256 qty = _owners.length;\\r\\n        // Cannot realistically overflow, since we are using uint256\\r\\n        unchecked {\\r\\n            for (uint256 i = 0; i < qty; i++) {\\r\\n                if (owner == ownerOf(i)) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Returns array of tokens only from the last mint in descending order. Transfers\\r\\n     * will affect this, it's only useful right after minting.\\r\\n     * It is not recommended to call this function from another smart contract\\r\\n     * as it can become quite expensive -- call this function off chain instead.\\r\\n     */\\r\\n    function latestMinted(address owner) public view virtual returns (uint256[] memory) {\\r\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\r\\n        \\r\\n        if (totalSupply() == 0) {\\r\\n            return new uint256[](0);\\r\\n        }\\r\\n\\r\\n        uint256 count;\\r\\n        uint256 start;\\r\\n        bool started;\\r\\n        for (uint256 tokenId = _owners.length-1; tokenId >= 0; tokenId--) {\\r\\n            if (!started && _owners[tokenId] == owner) {\\r\\n                start = tokenId;\\r\\n                started = true;\\r\\n                count++;\\r\\n            } else if (_owners[tokenId] == address(0)) {\\r\\n                count++;\\r\\n            } else if (count >= 1) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (tokenId == 0) {\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 i;\\r\\n        uint256 end = 0;\\r\\n        if (count <= start) { //prevent underflow\\r\\n            end = start - count;\\r\\n        }\\r\\n        uint256[] memory tokenIds = new uint256[](count);\\r\\n        for (uint256 tokenId = start; tokenId > end; tokenId--) {\\r\\n            tokenIds[i] = tokenId;\\r\\n            i++;\\r\\n        }\\r\\n\\r\\n        return tokenIds;\\r\\n    }\\r\\n\\r\\n    // see https://medium.com/coinmonks/the-elegance-of-the-nft-provenance-hash-solution-823b39f99473\\r\\n    function setProvenanceHash(string memory provenanceHash) public contractOwner {\\r\\n        hofProvenance = provenanceHash;\\r\\n    }\\r\\n\\r\\n    //change the metadata baseURI\\r\\n    function setBaseURI(string memory baseURI) public contractOwner {\\r\\n        require(baseURILocked == false, \\\"Already locked\\\");\\r\\n        _baseTokenURI = baseURI;\\r\\n    }\\r\\n\\r\\n    // Locks the baseURI to prevent further metadata changes. Only lock if it's all in onchain storage, and you will never need to update it again, or you're screwed!\\r\\n    function lockBaseURI() public contractOwner {\\r\\n        baseURILocked = true;\\r\\n        emit metadataLocked(_baseTokenURI);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-tokenURI}.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\r\\n\\r\\n        return bytes(_baseTokenURI).length > 0 ? string(abi.encodePacked(_baseTokenURI, tokenId.toString())) : \\\"\\\";\\r\\n    }\\r\\n\\r\\n    //used by OpenSea\\r\\n    function setContractURI(string memory _uri) public contractOwner {\\r\\n        contractURI = _uri;\\r\\n    }\\r\\n\\r\\n    //This enables minting\\r\\n    function flipSaleState() public contractOwner {\\r\\n        saleIsActive = !saleIsActive;\\r\\n    }\\r\\n\\r\\n    // Returns the license for tokens\\r\\n    function tokenLicense(uint256 _id) public view returns(string memory) {\\r\\n        require(_id < totalSupply(), \\\"Invalid token\\\");\\r\\n        return _licenseText;\\r\\n    }\\r\\n    \\r\\n    // Locks the license to prevent further changes \\r\\n    function lockLicense() public contractOwner {\\r\\n        licenseLocked = true;\\r\\n        emit licenseIsLocked(_licenseText);\\r\\n    }\\r\\n    \\r\\n    // Change the license\\r\\n    function changeLicense(string memory _license) public contractOwner {\\r\\n        require(licenseLocked == false, \\\"Already locked\\\");\\r\\n        _licenseText = _license;\\r\\n    }\\r\\n    \\r\\n    // Change the mintPrice\\r\\n    function setMintPrice(uint256 _newPrice) public contractOwner {\\r\\n        require(_newPrice != hofPrice, \\\"Not new value\\\");\\r\\n        hofPrice = _newPrice;\\r\\n    }\\r\\n    \\r\\n    // Change the royaltyBPS\\r\\n    function setRoyaltyBPS(uint96 _newRoyaltyBPS) public contractOwner {\\r\\n        require(_newRoyaltyBPS != _royaltyBPS, \\\"Not new value\\\");\\r\\n        _royaltyBPS = _newRoyaltyBPS;\\r\\n    }\\r\\n    \\r\\n    // Change the royalty receiver address\\r\\n    function setRoyaltyReceiver(address _account) public contractOwner {\\r\\n        require(_account != _royaltyReceiver, \\\"Not new value\\\");\\r\\n        _royaltyReceiver = _account;\\r\\n    }\\r\\n\\r\\n    //calculate the mint limit factoring in balances of all reserves\\r\\n    function _mintLimit() internal virtual returns (uint256 limit) {\\r\\n        if (marketingReserve > HOF_MAX) {\\r\\n            return HOF_MAX;\\r\\n        } else {\\r\\n            return HOF_MAX - marketingReserve;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    // Change per-mint limit\\r\\n    function setMaxHofPurchase(uint256 _limit) public contractOwner {\\r\\n        require(maxHofPurchase != _limit, \\\"Not new value\\\");\\r\\n        maxHofPurchase = _limit;\\r\\n    }\\r\\n\\r\\n    /*---------------- Mint Functions -----------*/\\r\\n    \\r\\n    // Mint function for marketing reserve\\r\\n    function reserveMintMarketing(address _to, uint256 _reserveAmount) public contractOwner {        \\r\\n        require(_reserveAmount > 0 && _reserveAmount <= marketingReserve, \\\"Exceeds reserve remaining\\\");\\r\\n        require(totalSupply() + _reserveAmount < HOF_MAX, \\\"Exceeds  supply\\\");\\r\\n\\r\\n        marketingReserve -= _reserveAmount;\\r\\n        _safeMint(_to, _reserveAmount);\\r\\n    }\\r\\n    \\r\\n    // Mint function for marketing reserve to multiple addresses\\r\\n    function reserveMintMarketingMass(address[] memory _to, uint256[] memory _reserveAmount) public contractOwner { \\r\\n        require(_to.length == _reserveAmount.length, \\\"To and amount length mismatch\\\");\\r\\n        require(_to.length > 0, \\\"No tos\\\");\\r\\n\\r\\n        uint256 totalReserve = 0;\\r\\n        for (uint256 i = 0; i < _to.length; i++) {\\r\\n            totalReserve += _reserveAmount[i];\\r\\n        }       \\r\\n        require(totalReserve > 0 && totalReserve <= marketingReserve, \\\"Exceeds reserve remaining\\\");\\r\\n        require(totalSupply() + totalReserve < HOF_MAX, \\\"Exceeds  supply\\\");\\r\\n\\r\\n        marketingReserve -= totalReserve;\\r\\n        for (uint256 i = 0; i < _to.length; i++) {\\r\\n            _safeMint(_to[i], _reserveAmount[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Mint for the hof minting drop\\r\\n    function mintFinns(uint256 numberOfTokens) public payable nonReentrant {\\r\\n        require(saleIsActive, \\\"Sale Inactive\\\");\\r\\n        require(numberOfTokens > 0 && numberOfTokens <= maxHofPurchase, \\\"Exceeds transaction max\\\");\\r\\n        require(totalSupply() + numberOfTokens < _mintLimit(), \\\"Exceeds max supply\\\");\\r\\n        require(msg.value == hofPrice * numberOfTokens, \\\"Check price\\\");\\r\\n        \\r\\n        _safeMint(msg.sender, numberOfTokens);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@beskay/erc721b/contracts/ERC721B.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\n\\nerror ApprovalCallerNotOwnerNorApproved();\\nerror ApprovalQueryForNonexistentToken();\\nerror ApproveToCaller();\\nerror ApprovalToCurrentOwner();\\nerror BalanceQueryForZeroAddress();\\nerror MintedQueryForZeroAddress();\\nerror MintToZeroAddress();\\nerror MintZeroQuantity();\\nerror OwnerIndexOutOfBounds();\\nerror OwnerQueryForNonexistentToken();\\nerror TokenIndexOutOfBounds();\\nerror TransferCallerNotOwnerNorApproved();\\nerror TransferFromIncorrectOwner();\\nerror TransferToNonERC721ReceiverImplementer();\\nerror TransferToZeroAddress();\\nerror UnableDetermineTokenOwner();\\nerror UnableGetTokenOwnerByIndex();\\nerror URIQueryForNonexistentToken();\\n\\n/**\\n * Updated, minimalist and gas efficient version of OpenZeppelins ERC721 contract.\\n * Includes the Metadata and  Enumerable extension.\\n *\\n * Assumes serials are sequentially minted starting at 0 (e.g. 0, 1, 2, 3..).\\n * Does not support burning tokens\\n *\\n * @author beskay0x\\n * Credits: chiru-labs, solmate, transmissions11, nftchance, squeebo_nft and others\\n */\\n\\nabstract contract ERC721B {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          ERC721 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    // Array which maps token ID to address (index is tokenID)\\n    address[] internal _owners;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x780e9d63 || // ERC165 Interface ID for ERC721Enumerable\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       ERC721ENUMERABLE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view returns (uint256) {\\n        return _owners.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     * Dont call this function on chain from another smart contract, since it can become quite expensive\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256 tokenId) {\\n        if (index >= balanceOf(owner)) revert OwnerIndexOutOfBounds();\\n\\n        uint256 count;\\n        uint256 qty = _owners.length;\\n        // Cannot realistically overflow, since we are using uint256\\n        unchecked {\\n            for (tokenId; tokenId < qty; tokenId++) {\\n                if (owner == ownerOf(tokenId)) {\\n                    if (count == index) return tokenId;\\n                    else count++;\\n                }\\n            }\\n        }\\n\\n        revert UnableGetTokenOwnerByIndex();\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual returns (uint256) {\\n        if (index >= totalSupply()) revert TokenIndexOutOfBounds();\\n        return index;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Iterates through _owners array, returns balance of address\\n     * It is not recommended to call this function from another smart contract\\n     * as it can become quite expensive -- call this function off chain instead.\\n     */\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        if (owner == address(0)) revert BalanceQueryForZeroAddress();\\n\\n        uint256 count;\\n        uint256 qty = _owners.length;\\n        // Cannot realistically overflow, since we are using uint256\\n        unchecked {\\n            for (uint256 i = 0; i < qty; i++) {\\n                if (owner == ownerOf(i)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     * Gas spent here starts off proportional to the maximum mint batch size.\\n     * It gradually moves to O(1) as tokens get transferred around in the collection over time.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\\n\\n        // Cannot realistically overflow, since we are using uint256\\n        unchecked {\\n            for (uint256 i = tokenId; ; i++) {\\n                if (_owners[i] != address(0)) {\\n                    return _owners[i];\\n                }\\n            }\\n        }\\n\\n        revert UnableDetermineTokenOwner();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual {\\n        address owner = ownerOf(tokenId);\\n        if (to == owner) revert ApprovalToCurrentOwner();\\n\\n        if (msg.sender != owner && !isApprovedForAll(owner, msg.sender)) revert ApprovalCallerNotOwnerNorApproved();\\n\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(owner, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\\n        if (!_exists(tokenId)) revert ApprovalQueryForNonexistentToken();\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        if (operator == msg.sender) revert ApproveToCaller();\\n\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual {\\n        if (!_exists(tokenId)) revert OwnerQueryForNonexistentToken();\\n        if (ownerOf(tokenId) != from) revert TransferFromIncorrectOwner();\\n        if (to == address(0)) revert TransferToZeroAddress();\\n\\n        bool isApprovedOrOwner = (msg.sender == from ||\\n            msg.sender == getApproved(tokenId) ||\\n            isApprovedForAll(from, msg.sender));\\n        if (!isApprovedOrOwner) revert TransferCallerNotOwnerNorApproved();\\n\\n        // delete token approvals from previous owner\\n        delete _tokenApprovals[tokenId];\\n        _owners[tokenId] = to;\\n\\n        // if token ID below transferred one isnt set, set it to previous owner\\n        // if tokenid is zero, skip this to prevent underflow\\n        if (tokenId > 0) {\\n            if (_owners[tokenId - 1] == address(0)) {\\n                _owners[tokenId - 1] = from;\\n            }\\n        }\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (!_checkOnERC721Received(from, to, id, '')) revert TransferToNonERC721ReceiverImplementer();\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        if (!_checkOnERC721Received(from, to, id, data)) revert TransferToNonERC721ReceiverImplementer();\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return tokenId < _owners.length;\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.code.length > 0) {\\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver(to).onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert TransferToNonERC721ReceiverImplementer();\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev check if contract confirms token transfer, if not - reverts\\n     * unlike the standard ERC721 implementation this is only called once per mint,\\n     * no matter how many tokens get minted, since it is useless to check this\\n     * requirement several times -- if the contract confirms one token,\\n     * it will confirm all additional ones too.\\n     * This saves us around 5k gas per additional mint\\n     */\\n    function _safeMint(address to, uint256 qty) internal virtual {\\n        _mint(to, qty);\\n\\n        if (!_checkOnERC721Received(address(0), to, _owners.length - 1, ''))\\n            revert TransferToNonERC721ReceiverImplementer();\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 qty,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, qty);\\n\\n        if (!_checkOnERC721Received(address(0), to, _owners.length - 1, data))\\n            revert TransferToNonERC721ReceiverImplementer();\\n    }\\n\\n    function _mint(address to, uint256 qty) internal virtual {\\n        if (to == address(0)) revert MintToZeroAddress();\\n        if (qty == 0) revert MintZeroQuantity();\\n\\n        uint256 _currentIndex = _owners.length;\\n\\n        // Cannot realistically overflow, since we are using uint256\\n        unchecked {\\n            for (uint256 i = 0; i < qty - 1; i++) {\\n                _owners.push();\\n                emit Transfer(address(0), to, _currentIndex + i);\\n            }\\n        }\\n\\n        // set last index to receiver\\n        _owners.push(to);\\n        emit Transfer(address(0), to, _currentIndex + (qty - 1));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_teamWallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_initLicenseText\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_initBaseTokenURI\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_ContractURI\",\"type\":\"string\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ApprovalCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApprovalToCurrentOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ApproveToCaller\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BalanceQueryForZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintZeroQuantity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerQueryForNonexistentToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenIndexOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferCallerNotOwnerNorApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromIncorrectOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToNonERC721ReceiverImplementer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferToZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableDetermineTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnableGetTokenOwnerByIndex\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_licenseText\",\"type\":\"string\"}],\"name\":\"licenseIsLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_baseTokenURI\",\"type\":\"string\"}],\"name\":\"metadataLocked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HOF_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURILocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_license\",\"type\":\"string\"}],\"name\":\"changeLicense\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flipSaleState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getRaribleV2Royalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hofPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hofProvenance\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"isFinnsOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"latestMinted\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"licenseLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockLicense\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingReserve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxHofPurchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numberOfTokens\",\"type\":\"uint256\"}],\"name\":\"mintFinns\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_reserveAmount\",\"type\":\"uint256\"}],\"name\":\"reserveMintMarketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_reserveAmount\",\"type\":\"uint256[]\"}],\"name\":\"reserveMintMarketingMass\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setContractURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setMaxHofPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPrice\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"provenanceHash\",\"type\":\"string\"}],\"name\":\"setProvenanceHash\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_newRoyaltyBPS\",\"type\":\"uint96\"}],\"name\":\"setRoyaltyBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"setRoyaltyReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"tokenLicense\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "HouseOfFinns", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "0000000000000000000000000e3aa6cf5c0a3101ffd163546fde723299c136ae000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000035442440000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003d68747470733a2f2f6e7474776e79693461692e657865637574652d6170692e75732d656173742d312e616d617a6f6e6177732e636f6d2f66696e6e732f000000000000000000000000000000000000000000000000000000000000000000004368747470733a2f2f65766a6178792e696e66696e69746575706c6f6164732e636c6f75642f323032322f30332f636f6e74726163742d6d657461646174612e6a736f6e0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}