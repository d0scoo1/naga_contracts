{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StarshipCrowdsale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity 0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"./interfaces/ITreasury.sol\\\";\\nimport \\\"./interfaces/IStaking.sol\\\";\\nimport \\\"./interfaces/IBondDepository.sol\\\";\\nimport \\\"./types/Ownable.sol\\\";\\n\\n/**\\n *  This contract allows Starship seed investors and advisors to claim tokens.\\n *  step was taken to ensure fair distribution of exposure in the network.\\n */\\ncontract StarshipCrowdsale is Ownable {\\n    /* ========== DEPENDENCIES ========== */\\n\\n    /* ========== EVENTS ========== */\\n\\n    event StarMinted(address caller, uint256 amount, address reserve);\\n    event CrowdsaleInitialized(address caller, uint256 startTime);\\n    \\n    /* ========== STATE VARIABLES ========== */\\n\\n    // our token\\n    IERC20 public immutable star;\\n    // receieves deposits, mints and returns STAR\\n    ITreasury internal immutable treasury;\\n  \\n    IBondDepository internal immutable depository;\\n\\n    uint public constant MAX_TOKENS = 12500000 * 1e9;\\n    uint256 public tokensMinted;\\n\\n    uint256 public startTime;\\n    bool public isActive;\\n    bool public isCompleted;\\n        \\n    uint256 public endTime;\\n\\n    constructor( address _star, address _treasury, address _depository )\\n    {\\n      tokensMinted = 0;\\n      star = IERC20(_star);\\n      treasury = ITreasury(_treasury);\\n      depository = IBondDepository(_depository);\\n    }\\n\\n    /* ========== MUTABLE FUNCTIONS ========== */\\n\\n    /**\\n     * @notice allows wallet to mint STAR via the feb crowdsale\\n     * @param _amount uint256\\n     * @param _reserve address\\n     */\\n    function MintStar(uint256 _amount, address _reserve) external {\\n        uint256 minted = _crowdsaleMint(_amount, _reserve);\\n    }\\n\\n    /**\\n     * @notice logic for purchasing STAR\\n     * @param _amount uint256\\n     * @param _reserve address\\n     * @return toSend_ uint256\\n     */\\n    function _crowdsaleMint(uint256 _amount, address _reserve) internal returns (uint256 toSend_) {\\n        \\n        require(activeSale(), \\\"crowdsale is inactive\\\");\\n        \\n        toSend_ = treasury.deposit(msg.sender,_amount, _reserve, treasury.tokenValue(_reserve, _amount) * 75 / 100);\\n        require(validTransaction(toSend_), \\\"minting too many tokens\\\");\\n        tokensMinted += toSend_;\\n        depository.crowdsalePurchase(toSend_);\\n        \\n        emit StarMinted(msg.sender, _amount, _reserve);\\n    }\\n    \\n    function initialize() external onlyOwner {\\n      isActive = true;\\n      startTime = block.timestamp;\\n      endTime = block.timestamp + 3 days;\\n      emit CrowdsaleInitialized(msg.sender, startTime);\\n    }\\n    \\n    function completeSale() external onlyOwner {\\n      isActive = false;\\n      isCompleted = true;\\n    }\\n    \\n    function resetCrowdsale() external onlyOwner {\\n      isActive = false;\\n      isCompleted = false;\\n      startTime = 0;\\n      endTime = 0;\\n      tokensMinted = 0;\\n    }\\n\\n    function activeSale() public returns (bool) { \\n    \\n      bool withinPeriod = block.timestamp >= startTime && block.timestamp <= endTime;\\n      \\n      return isActive && withinPeriod;\\n    }\\n    \\n    function validTransaction(uint256 toSend_) internal returns (bool) {\\n      \\n      bool validPurchase = tokensMinted + toSend_ <= MAX_TOKENS;\\n      //bool nonZeroPurchase = msg.value != 0;\\n      return validPurchase;\\n    }\\n\\n    /* ========== VIEW FUNCTIONS ========== */\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        address _from,\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IStaking {\\n    function stake(\\n        address _to,\\n        uint256 _amount,\\n        bool _rebasing,\\n        bool _claim\\n    ) external returns (uint256);\\n\\n    function claim(address _recipient, bool _rebasing) external returns (uint256);\\n\\n    function forfeit() external returns (uint256);\\n\\n    function toggleLock() external;\\n\\n    function unstake(\\n        address _to,\\n        uint256 _amount,\\n        bool _trigger,\\n        bool _rebasing\\n    ) external returns (uint256);\\n\\n    function wrap(address _to, uint256 _amount) external returns (uint256 gBalance_);\\n\\n    function unwrap(address _to, uint256 _amount) external returns (uint256 sBalance_);\\n\\n    function rebase() external;\\n\\n    function index() external view returns (uint256);\\n\\n    function contractBalance() external view returns (uint256);\\n\\n    function totalStaked() external view returns (uint256);\\n\\n    function supplyInWarmup() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBondDepository.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IBondDepository {\\n    // Info about each type of market\\n    struct Market {\\n        uint256 capacity; // capacity remaining\\n        IERC20 quoteToken; // token to accept as payment\\n        bool capacityInQuote; // capacity limit is in payment token (true) or in OHM (false, default)\\n        uint64 totalDebt; // total debt from market\\n        uint64 maxPayout; // max tokens in/out (determined by capacityInQuote false/true, respectively)\\n        uint64 sold; // base tokens out\\n        uint256 purchased; // quote tokens in\\n    }\\n\\n    // Info for creating new markets\\n    struct Terms {\\n        bool fixedTerm; // fixed term or fixed expiration\\n        uint64 controlVariable; // scaling variable for price\\n        uint48 vesting; // length of time from deposit to maturity if fixed-term\\n        uint48 conclusion; // timestamp when market no longer offered (doubles as time when market matures if fixed-expiry)\\n        uint64 maxDebt; // 9 decimal debt maximum in OHM\\n    }\\n\\n    // Additional info about market.\\n    struct Metadata {\\n        uint48 lastTune; // last timestamp when control variable was tuned\\n        uint48 lastDecay; // last timestamp when market was created and debt was decayed\\n        uint48 length; // time from creation to conclusion. used as speed to decay debt.\\n        uint48 depositInterval; // target frequency of deposits\\n        uint48 tuneInterval; // frequency of tuning\\n        uint8 quoteDecimals; // decimals of quote token\\n    }\\n\\n    // Control variable adjustment data\\n    struct Adjustment {\\n        uint64 change;\\n        uint48 lastAdjustment;\\n        uint48 timeToAdjusted;\\n        bool active;\\n    }\\n\\n    /**\\n     * @notice deposit market\\n     * @param _bid uint256\\n     * @param _amount uint256\\n     * @param _maxPrice uint256\\n     * @param _user address\\n     * @param _referral address\\n     * @return payout_ uint256\\n     * @return expiry_ uint256\\n     * @return index_ uint256\\n     */\\n    function deposit(\\n        uint256 _bid,\\n        uint256 _amount,\\n        uint256 _maxPrice,\\n        address _user,\\n        address _referral\\n    )\\n        external\\n        returns (\\n            uint256 payout_,\\n            uint256 expiry_,\\n            uint256 index_\\n        );\\n\\n    function create(\\n        IERC20 _quoteToken, // token used to deposit\\n        uint256[3] memory _market, // [capacity, initial price]\\n        bool[2] memory _booleans, // [capacity in quote, fixed term]\\n        uint256[2] memory _terms, // [vesting, conclusion]\\n        uint32[2] memory _intervals // [deposit interval, tune interval]\\n    ) external returns (uint256 id_);\\n\\n    function close(uint256 _id) external;\\n    \\n    function setCrowdsale(address _contract) external;\\n    \\n    function crowdsalePurchase (uint256 _payout) external returns (uint256);\\n\\n    function isLive(uint256 _bid) external view returns (bool);\\n\\n    function liveMarkets() external view returns (uint256[] memory);\\n\\n    function liveMarketsFor(address _quoteToken) external view returns (uint256[] memory);\\n\\n    function payoutFor(uint256 _amount, uint256 _bid) external view returns (uint256);\\n\\n    function marketPrice(uint256 _bid) external view returns (uint256);\\n\\n    function currentDebt(uint256 _bid) external view returns (uint256);\\n\\n    function debtRatio(uint256 _bid) external view returns (uint256);\\n\\n    function debtDecay(uint256 _bid) external view returns (uint64);\\n}\\n\"\r\n    },\r\n    \"contracts/types/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IOwnable.sol\\\";\\n\\nabstract contract Ownable is IOwnable {\\n    address internal _owner;\\n    address internal _newOwner;\\n\\n    event OwnershipPushed(address indexed previousOwner, address indexed newOwner);\\n    event OwnershipPulled(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor() {\\n        _owner = msg.sender;\\n        emit OwnershipPushed(address(0), _owner);\\n    }\\n\\n    function owner() public view override returns (address) {\\n        return _owner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    function renounceManagement() public virtual override onlyOwner {\\n        emit OwnershipPulled(_owner, address(0));\\n        _owner = address(0);\\n        _newOwner = address(0);\\n    }\\n\\n    function pushManagement(address newOwner_) public virtual override onlyOwner {\\n        emit OwnershipPushed(_owner, newOwner_);\\n        _newOwner = newOwner_;\\n    }\\n\\n    function pullManagement() public virtual override {\\n        require(msg.sender == _newOwner, \\\"Ownable: must be new owner to pull\\\");\\n        emit OwnershipPulled(_owner, _newOwner);\\n        _owner = _newOwner;\\n        _newOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n\\n    function renounceManagement() external;\\n\\n    function pushManagement(address newOwner_) external;\\n\\n    function pullManagement() external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_star\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depository\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPulled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipPushed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"reserve\",\"type\":\"address\"}],\"name\":\"StarMinted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_TOKENS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_reserve\",\"type\":\"address\"}],\"name\":\"MintStar\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeSale\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completeSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isCompleted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pullManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"pushManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceManagement\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetCrowdsale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"star\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StarshipCrowdsale", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "00000000000000000000000063c389cb2c573dd8a9239a13a3eb65935ddb5e2f00000000000000000000000008bfb0a377f147f9063935a37762e7878cf2974500000000000000000000000065283b2a5770e9902081de90be1faea7ee38e36d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}