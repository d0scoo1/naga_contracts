{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/FlowerFamMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport { MerkleProof } from \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\r\\n\\r\\ninterface IFlowerFam {\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n     function mint(\\r\\n        address sender,\\r\\n        uint256 amount\\r\\n    ) external;\\r\\n    function getLastMintedId() external view returns (uint256);\\r\\n    function totalSupply() external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface IFlowerFamMintPass {\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n    function userPassesLeft(address owner) external view returns (uint256);\\r\\n    function redeemPasses(address owner, uint256 amount) external;\\r\\n}\\r\\n\\r\\ninterface IFlowerFamEcoSystem {\\r\\n    function mintAndStakeFlowerFamFlower(address staker, uint256 flowerFamId) external;\\r\\n    function mintAndBatchStakeFlowerFamFlowers(address staker, uint256[] calldata flowerFamIds) external; \\r\\n}\\r\\n\\r\\ncontract FlowerFamMinter is Ownable {\\r\\n\\r\\n    IFlowerFam public immutable flowerFam;\\r\\n    IFlowerFamMintPass public immutable flowerFamMintPass;\\r\\n    IFlowerFamEcoSystem public immutable flowerFamEcoSystem;\\r\\n\\r\\n    uint256 public whitelistRound = 0;\\r\\n    uint256 public giveawaysRound = 1;\\r\\n    uint256 public raffleRound = 2;\\r\\n    uint256 public publicRound = 3;\\r\\n\\r\\n    uint256 public maxSupply = 6969;\\r\\n    uint256 public price = 0.069 ether;\\r\\n\\r\\n    uint256 public mintDuration = 69 minutes; /// @dev unix timestamp duration of each mint round.\\r\\n    uint256 public startTimeWL = 1653148800 - 1 minutes; /// @dev unix timestamp of start time of whitelist mint (first round).\\r\\n    uint256 public startTimeGiveaway = startTimeWL + mintDuration;\\r\\n    uint256 public startTimeRaffle = startTimeGiveaway + mintDuration;\\r\\n    uint256 public startTimePublic = startTimeRaffle + mintDuration;\\r\\n\\r\\n    mapping(uint256 => uint256) public roundToMintLimits; /// @dev mint per wallet limit per round\\r\\n    mapping(address => mapping(uint256 => uint256)) public roundToMinted; /// @dev number of flowers minted per wallet per round\\r\\n    mapping(uint256 => bytes32) public roundToMerkleRoot; /// @dev maps each round to the merkle root containing wallets allowed to mint during that round\\r\\n\\r\\n    constructor(\\r\\n        address _flowerFamNFT,\\r\\n        address _flowerFamMintPass,\\r\\n        address _flowerFamEcoSystem\\r\\n    ) Ownable() {\\r\\n        flowerFam = IFlowerFam(_flowerFamNFT);\\r\\n        flowerFamMintPass = IFlowerFamMintPass(_flowerFamMintPass);\\r\\n        flowerFamEcoSystem = IFlowerFamEcoSystem(_flowerFamEcoSystem);\\r\\n\\r\\n        roundToMintLimits[whitelistRound] = 2;\\r\\n        roundToMintLimits[giveawaysRound] = 1;\\r\\n        roundToMintLimits[raffleRound] = 2;\\r\\n        roundToMintLimits[publicRound] = 6969;\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n    function whitelistMint(uint256 amount, bytes32[] calldata proof, bool stake) external payable {\\r\\n        require(block.timestamp >= startTimeWL, \\\"Whitelist mint not started\\\");\\r\\n        require(block.timestamp < startTimeWL + mintDuration, \\\"Whitelist mint closed\\\");\\r\\n        require(msg.value >= amount * price, \\\"Not enough eth sent\\\");\\r\\n\\r\\n        uint256 mintAmount = amount;\\r\\n        uint256 passesLeft = flowerFamMintPass.userPassesLeft(msg.sender); /// @dev passes left = mints left from passes ( each pass = 2 mints )\\r\\n\\r\\n        if (passesLeft > 0) {\\r\\n            uint256 amountFromPasses = passesLeft < mintAmount ? passesLeft : mintAmount;\\r\\n\\r\\n            mintAmount -= amountFromPasses;\\r\\n            flowerFamMintPass.redeemPasses(msg.sender, amountFromPasses);\\r\\n            _mintFromMintPass(msg.sender, amountFromPasses);\\r\\n        }\\r\\n        \\r\\n        if (mintAmount > 0)\\r\\n            _merkleProofMint(msg.sender, mintAmount, proof, whitelistRound);\\r\\n        \\r\\n        if (stake)\\r\\n            _stakeMintedFlowers(amount);\\r\\n    }\\r\\n\\r\\n    function giveawayMint(uint256 amount, bytes32[] calldata proof, bool stake) external payable {\\r\\n        require(block.timestamp >= startTimeGiveaway, \\\"Giveaway mint not started\\\");\\r\\n        require(block.timestamp < startTimeGiveaway + mintDuration, \\\"Giveaway mint closed\\\");\\r\\n        require(msg.value >= amount * price, \\\"Not enough eth sent\\\");\\r\\n\\r\\n        _merkleProofMint(msg.sender, amount, proof, giveawaysRound);\\r\\n\\r\\n        if (stake)\\r\\n            _stakeMintedFlowers(amount);\\r\\n    }\\r\\n\\r\\n    function raffleMint(uint256 amount, bytes32[] calldata proof, bool stake) external payable {\\r\\n        require(block.timestamp >= startTimeRaffle, \\\"Raffle mint not started\\\");\\r\\n        require(block.timestamp < startTimeRaffle + mintDuration, \\\"Raffle mint closed\\\");\\r\\n        require(msg.value >= amount * price, \\\"Not enough eth sent\\\");\\r\\n       \\r\\n        _merkleProofMint(msg.sender, amount, proof, raffleRound);\\r\\n\\r\\n        if (stake)\\r\\n            _stakeMintedFlowers(amount);\\r\\n    }\\r\\n\\r\\n    function publicMint(uint256 amount, bool stake) external payable {\\r\\n        require(block.timestamp >= startTimePublic, \\\"Public mint not started\\\");        \\r\\n        require(flowerFam.totalSupply() + amount <= maxSupply, \\\"Flower Fam NFT is sold out\\\");\\r\\n        require(msg.value >= amount * price, \\\"Not enough eth sent\\\");\\r\\n\\r\\n        flowerFam.mint(msg.sender, amount);  \\r\\n\\r\\n        if (stake)\\r\\n            _stakeMintedFlowers(amount);      \\r\\n    }\\r\\n\\r\\n    function totalMintsOfUser(address user) external view returns (uint256) {\\r\\n        return  roundToMinted[user][whitelistRound] + \\r\\n                roundToMinted[user][giveawaysRound] + \\r\\n                roundToMinted[user][raffleRound] + \\r\\n                roundToMinted[user][publicRound];\\r\\n    }\\r\\n\\r\\n    function getActiveRound() external view returns (uint256) {\\r\\n        uint256 activeRound = 0;\\r\\n        bool hasActiveRound = false;\\r\\n\\r\\n        if(block.timestamp >= startTimeWL && block.timestamp < startTimeWL + mintDuration) {\\r\\n            activeRound = 0;\\r\\n            hasActiveRound = true;\\r\\n        }\\r\\n\\r\\n        if(block.timestamp >= startTimeGiveaway && block.timestamp < startTimeGiveaway + mintDuration) {\\r\\n            activeRound = 1;\\r\\n            hasActiveRound = true;\\r\\n        }\\r\\n\\r\\n        if(block.timestamp >= startTimeRaffle && block.timestamp < startTimeRaffle + mintDuration) {\\r\\n            activeRound = 2;\\r\\n            hasActiveRound = true;\\r\\n        }\\r\\n\\r\\n        if(block.timestamp >= startTimePublic && block.timestamp < startTimePublic + mintDuration) {\\r\\n            activeRound = 3;\\r\\n            hasActiveRound = true;\\r\\n        }\\r\\n\\r\\n        if(hasActiveRound) {\\r\\n            return activeRound;\\r\\n        }\\r\\n        else {\\r\\n            revert(\\\"No active round running\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getSupplyLeft() external view returns (uint256) {\\r\\n        uint256 totalSupply = flowerFam.totalSupply();\\r\\n        if (totalSupply > maxSupply)\\r\\n            return 0;\\r\\n        return maxSupply - totalSupply;\\r\\n    }\\r\\n\\r\\n    function getUserMintedAtRound(address sender, uint256 round) external view returns (uint256) {\\r\\n        return roundToMintLimits[round] - roundToMinted[sender][round];\\r\\n    }\\r\\n\\r\\n    function setMintDuration(uint256 newduration) external onlyOwner {\\r\\n        mintDuration = newduration;\\r\\n    }\\r\\n\\r\\n    function setStartTimeWL(uint256 newStartTimeWL) external onlyOwner {\\r\\n        startTimeWL = newStartTimeWL;\\r\\n    }\\r\\n\\r\\n    function setStartTimeGiveaway(uint256 newStartTimeGiveaway) external onlyOwner {\\r\\n        startTimeGiveaway = newStartTimeGiveaway;\\r\\n    }\\r\\n\\r\\n    function setStartTimeRaffle(uint256 newStartTimeRaffle) external onlyOwner {\\r\\n        startTimeRaffle = newStartTimeRaffle;\\r\\n    }\\r\\n\\r\\n    function setStartTimeWaitlist(uint256 newStartTimeWaitlist) external onlyOwner {\\r\\n        startTimePublic = newStartTimeWaitlist;\\r\\n    }\\r\\n\\r\\n    function setMintLimitOfRound(uint256 round, uint256 limit) external onlyOwner {\\r\\n        roundToMintLimits[round] = limit;\\r\\n    }\\r\\n\\r\\n    function setMerkleRootOfRound(uint256 round, bytes32 root) external onlyOwner {\\r\\n        roundToMerkleRoot[round] = root;\\r\\n    }\\r\\n\\r\\n    function setMaxSupply(uint256 newMaxSupply) external onlyOwner {\\r\\n        maxSupply = newMaxSupply;\\r\\n    }\\r\\n\\r\\n    function setPrice(uint256 newPrice) external onlyOwner {\\r\\n        price = newPrice;\\r\\n    }\\r\\n\\r\\n    function withdraw(address _to) external onlyOwner {\\r\\n        uint256 balance = address(this).balance;\\r\\n        require(balance > 0, \\\"Balance zero\\\");\\r\\n        require(_to != address(0), \\\"Cannot transfer to null address\\\");\\r\\n        payable(_to).transfer(balance);\\r\\n    }\\r\\n\\r\\n    \\r\\n    function _stakeMintedFlowers(uint256 amount) internal {\\r\\n        uint256 lastMinted = flowerFam.getLastMintedId(); /// @dev the id of the flower last minted, if we use this in the same tx as minting then it gives us the last minted id we minted\\r\\n        uint256 firstMinted = lastMinted + 1 - amount;  \\r\\n        if (amount == 1)\\r\\n            flowerFamEcoSystem.mintAndStakeFlowerFamFlower(msg.sender, lastMinted);\\r\\n        else {\\r\\n            uint256[] memory ids = new uint256[](amount);\\r\\n            for (uint i = 0; i < amount; i++) {\\r\\n                ids[i] = firstMinted + i;\\r\\n            }\\r\\n            flowerFamEcoSystem.mintAndBatchStakeFlowerFamFlowers(msg.sender, ids);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _merkleProofMint(address sender, uint256 amount, bytes32[] calldata proof, uint256 round) internal {\\r\\n        require(amount > 0, \\\"Invalid mint amount\\\");\\r\\n        \\r\\n        bytes32 root = roundToMerkleRoot[round];\\r\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender));\\r\\n        require(MerkleProof.verify(proof, root, leaf), \\\"Sender not allowed to mint in this round\\\");\\r\\n\\r\\n        require(roundToMinted[sender][round] + amount <= roundToMintLimits[round], \\\"Sender exceeds max mint limit of this round\\\");\\r\\n        require(flowerFam.totalSupply() + amount <= maxSupply, \\\"Flower Fam NFT is sold out\\\");\\r\\n\\r\\n        roundToMinted[sender][round] += amount;\\r\\n\\r\\n        flowerFam.mint(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _mintFromMintPass(address sender, uint256 amount) internal {\\r\\n        require(amount > 0, \\\"Invalid mint amount\\\");\\r\\n        require(flowerFam.totalSupply() + amount <= maxSupply, \\\"Flower Fam NFT is sold out\\\");\\r\\n        \\r\\n        flowerFam.mint(sender, amount);\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n *\\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\\n * hashing, or use a hash function other than keccak256 for hashing leaves.\\n * This is because the concatenation of a sorted pair of internal nodes in\\n * the merkle tree could be reinterpreted as a leaf value.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_flowerFamNFT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_flowerFamMintPass\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_flowerFamEcoSystem\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"flowerFam\",\"outputs\":[{\"internalType\":\"contract IFlowerFam\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flowerFamEcoSystem\",\"outputs\":[{\"internalType\":\"contract IFlowerFamEcoSystem\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flowerFamMintPass\",\"outputs\":[{\"internalType\":\"contract IFlowerFamMintPass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSupplyLeft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"getUserMintedAtRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"giveawayMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveawaysRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"raffleMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raffleRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundToMerkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundToMintLimits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundToMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxSupply\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRootOfRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newduration\",\"type\":\"uint256\"}],\"name\":\"setMintDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"round\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setMintLimitOfRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"setPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartTimeGiveaway\",\"type\":\"uint256\"}],\"name\":\"setStartTimeGiveaway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartTimeRaffle\",\"type\":\"uint256\"}],\"name\":\"setStartTimeRaffle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartTimeWL\",\"type\":\"uint256\"}],\"name\":\"setStartTimeWL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStartTimeWaitlist\",\"type\":\"uint256\"}],\"name\":\"setStartTimeWaitlist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimeGiveaway\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimePublic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimeRaffle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTimeWL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"totalMintsOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"stake\",\"type\":\"bool\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FlowerFamMinter", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "00000000000000000000000014ce6900b9ed6023ea47e16cc1656affdb0a40c7000000000000000000000000f7536ed6ddd7dcf749dddae0e8fcb3d9a3f665ee000000000000000000000000f36f33ca39985945c3042646e013b46ff3b1d5f5", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}