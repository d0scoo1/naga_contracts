{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PlayerHousing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"openzeppelin/utils/Strings.sol\\\";\\nimport \\\"solmate/tokens/ERC1155B.sol\\\";\\n\\nimport \\\"./IAchievements.sol\\\";\\nimport \\\"./ILockManager.sol\\\";\\nimport \\\"./Owned.sol\\\";\\n\\n/// @title Solarbots Player Housing\\n/// @author Solarbots (https://solarbots.io)\\ncontract PlayerHousing is ERC1155B, Owned {\\n    // ---------- CONSTANTS ----------\\n\\n    /// @notice Maximum amount of tokens per faction that can be minted in total\\n    /// Arboria tokens use IDs 0-5999, Illskagaard tokens use IDs 6000-11999,\\n    /// and Lacrean Empire tokens use IDs 12000-17999 for a total of 18000 tokens\\n    uint256 public constant MAX_SUPPLY_PER_FACTION = 6000;\\n\\n    /// @notice Maximum amount of tokens that can be minted per transaction\\n    uint256 public constant MAX_MINT_AMOUNT_PER_TX = 5;\\n\\n    /// @notice Price to mint one token\\n    uint256 public constant MINT_PRICE = 0.1 ether;\\n\\n    /// @notice FOA rewards emitted per second per token\\n    /// @dev 600_000_000*1e18/18_000/10/365/24/60/60\\n    uint256 public constant REWARDS_PER_SECOND = 105699306612548;\\n\\n    /// @notice End of FOA rewards emittance\\n    uint256 public immutable rewardsEndTimestamp;\\n\\n    /// @notice Start of whitelist sale\\n    uint256 public immutable whitelistSaleDate;\\n\\n    /// @notice Start of public sale\\n    uint256 public immutable publicSaleDate;\\n\\n    /// @notice Achievements contract\\n    address public immutable achievements;\\n\\n    /// @notice Token ID of whitelist ticket in achievements contract\\n    uint256 public immutable whitelistTicketTokenID;\\n\\n    /// @dev First 16 bits are all 1, remaining 240 bits are all 0\\n    uint256 private constant _TOTAL_SUPPLY_BITMASK = type(uint16).max;\\n\\n    // ---------- STATE ----------\\n\\n    mapping(address => uint256) public rewardsBitField;\\n    mapping(address => bool) public isApprovedForRewards;\\n\\n    address public lockManager;\\n\\n    /// @notice Metadata base URI\\n    string public baseURI;\\n\\n    /// @notice Metadata URI suffix\\n    string public uriSuffix;\\n\\n    /// @dev First 16 bits contain total supply of Arboria tokens,\\n    /// second 16 bits contain total supply of Illskagard tokens,\\n    /// and third 16 bits contain total supply of Lacrean Empire tokens\\n    uint256 private _totalSupplyBitField;\\n\\n    // ---------- EVENTS ----------\\n\\n    event ApprovalForRewards(address indexed operator, bool approved);\\n\\n    event LockManagerTransfer(address indexed previousLockManager, address indexed newLockManager);\\n\\n    // ---------- CONSTRUCTOR ----------\\n\\n    /// @param owner Contract owner\\n    /// @param _whitelistSaleDate Start of whitelist sale\\n    /// @param _publicSaleDate Start of public sale\\n    /// @param _rewardsEndTimestamp End of FOA rewards emittance\\n    /// @param _achievements Address of Achievements contract\\n    /// @param _whitelistTicketTokenID Token ID of whitelist ticket in Achievements contract\\n    /// @param _lockManager Address of Lock Manager contract\\n    constructor(\\n        address owner,\\n        uint256 _whitelistSaleDate,\\n        uint256 _publicSaleDate,\\n        uint256 _rewardsEndTimestamp,\\n        address _achievements,\\n        uint256 _whitelistTicketTokenID,\\n        address _lockManager\\n    ) Owned(owner) {\\n        whitelistSaleDate = _whitelistSaleDate;\\n        publicSaleDate = _publicSaleDate;\\n        rewardsEndTimestamp = _rewardsEndTimestamp;\\n        achievements = _achievements;\\n        whitelistTicketTokenID = _whitelistTicketTokenID;\\n        lockManager = _lockManager;\\n    }\\n\\n    // ---------- METADATA ----------\\n\\n    /// @notice Get metadata URI\\n    /// @param id Token ID\\n    /// @return Metadata URI of token ID `id`\\n    function uri(uint256 id) public view override returns (string memory) {\\n        require(bytes(baseURI).length > 0, \\\"NO_METADATA\\\");\\n\\t\\treturn string(abi.encodePacked(baseURI, Strings.toString(id), uriSuffix));\\n    }\\n\\n    /// @notice Set metadata base URI\\n    /// @param _baseURI New metadata base URI\\n    /// @dev Doesn't emit URI event, because `id` argument isn't used\\n    function setBaseURI(string calldata _baseURI) public onlyOwner {\\n        baseURI = _baseURI;\\n    }\\n\\n    /// @notice Set metadata URI suffix\\n    /// @param _uriSuffix New metadata URI suffix\\n    /// @dev Doesn't emit URI event, because `id` argument isn't used\\n    function setURISuffix(string calldata _uriSuffix) public onlyOwner {\\n        uriSuffix = _uriSuffix;\\n    }\\n\\n    // ---------- TOTAL SUPPLY ----------\\n\\n    function totalSupplyArboria() public view returns (uint256) {\\n        return _totalSupplyBitField & _TOTAL_SUPPLY_BITMASK;\\n    }\\n\\n    function totalSupplyIllskagaard() public view returns (uint256) {\\n        return _totalSupplyBitField >> 16 & _TOTAL_SUPPLY_BITMASK;\\n    }\\n\\n    function totalSupplyLacrean() public view returns (uint256) {\\n        return _totalSupplyBitField >> 32;\\n    }\\n\\n    function totalSupply() public view returns (uint256) {\\n        return totalSupplyArboria() + totalSupplyIllskagaard() + totalSupplyLacrean();\\n    }\\n\\n    // ---------- LOCK MANAGER ----------\\n\\n    function setLockManager(address _lockManager) public onlyOwner {\\n        emit LockManagerTransfer(lockManager, _lockManager);\\n        lockManager = _lockManager;\\n    }\\n\\n    // ---------- REWARDS ----------\\n\\n    function setApprovalForRewards(address operator, bool approved) public onlyOwner {\\n        isApprovedForRewards[operator] = approved;\\n        emit ApprovalForRewards(operator, approved);\\n    }\\n\\n    function setRewardsBitField(address owner, uint256 _rewardsBitField) public {\\n        require(isApprovedForRewards[msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        rewardsBitField[owner] = _rewardsBitField;\\n    }\\n\\n    /// @notice Returns the token balance of the given address\\n    /// @param owner Address to check\\n    function balanceOf(address owner) public view returns (uint256) {\\n        return rewardsBitField[owner] & type(uint16).max;\\n    }\\n\\n    /// @notice Returns the FOA rewards balance of the given address\\n    /// @param owner Address to check\\n    function rewardsOf(address owner) public view returns (uint256 rewardsBalance) {\\n        rewardsBalance = rewardsBitField[owner] >> 48;\\n        uint256 lastUpdated = rewardsBitField[owner] >> 16 & type(uint32).max;\\n\\n        if (lastUpdated != rewardsEndTimestamp) {\\n            // Use current block timestamp or rewards end timestamp if reached\\n            uint256 timestamp = block.timestamp < rewardsEndTimestamp ? block.timestamp : rewardsEndTimestamp;\\n            uint256 tokenBalance = balanceOf(owner);\\n\\n            // Calculate rewards collected since last update and add them to balance\\n            if (lastUpdated > 0) {\\n                uint256 secondsSinceLastUpdate = timestamp - lastUpdated;\\n                rewardsBalance += secondsSinceLastUpdate * REWARDS_PER_SECOND * tokenBalance;\\n            }\\n        }\\n    }\\n\\n    function _updateRewardsForTransfer(address from, address to, uint256 tokenAmount) internal {\\n        // Use current block timestamp or rewards end timestamp if reached\\n        uint256 timestamp = block.timestamp < rewardsEndTimestamp ? block.timestamp : rewardsEndTimestamp;\\n\\n        // Store bit field in memory to reduce number of SLOADs\\n        uint256 _rewardsBitField = rewardsBitField[from];\\n        uint256 lastUpdated = _rewardsBitField >> 16 & type(uint32).max;\\n\\n        if (lastUpdated != rewardsEndTimestamp) {\\n            uint256 tokenBalance = _rewardsBitField & type(uint16).max;\\n            uint256 rewardsBalance = _rewardsBitField >> 48;\\n\\n            // Calculate rewards collected since last update and add them to balance\\n            if (lastUpdated > 0) {\\n                uint256 secondsSinceLastUpdate = timestamp - lastUpdated;\\n                unchecked {\\n                    rewardsBalance += secondsSinceLastUpdate * REWARDS_PER_SECOND * tokenBalance;\\n                }\\n            }\\n\\n            unchecked {\\n                rewardsBitField[from] = tokenBalance - tokenAmount | timestamp << 16 | rewardsBalance << 48;\\n            }\\n        }\\n\\n        // Store bit field in memory to reduce number of SLOADs\\n        _rewardsBitField = rewardsBitField[to];\\n        lastUpdated = _rewardsBitField >> 16 & type(uint32).max;\\n\\n        if (lastUpdated != rewardsEndTimestamp) {\\n            uint256 tokenBalance = _rewardsBitField & type(uint16).max;\\n            uint256 rewardsBalance = _rewardsBitField >> 48;\\n\\n            // Calculate rewards collected since last update and add them to balance\\n            if (lastUpdated > 0) {\\n                uint256 secondsSinceLastUpdate = timestamp - lastUpdated;\\n                unchecked {\\n                    rewardsBalance += secondsSinceLastUpdate * REWARDS_PER_SECOND * tokenBalance;\\n                }\\n            }\\n\\n            unchecked {\\n                rewardsBitField[to] = tokenBalance + tokenAmount | timestamp << 16 | rewardsBalance << 48;\\n            }\\n        }\\n    }\\n\\n    function _updateRewardsForMint(address owner, uint256 tokenAmount) internal {\\n        // Store bit field in memory to reduce number of SLOADs\\n        uint256 _rewardsBitField = rewardsBitField[owner];\\n        uint256 tokenBalance = _rewardsBitField & type(uint16).max;\\n        uint256 lastUpdated = _rewardsBitField >> 16 & type(uint32).max;\\n        uint256 rewardsBalance = _rewardsBitField >> 48;\\n\\n        // Calculate rewards collected since last update and add them to balance\\n        if (lastUpdated > 0) {\\n            uint256 secondsSinceLastUpdate = block.timestamp - lastUpdated;\\n            unchecked {\\n                rewardsBalance += secondsSinceLastUpdate * REWARDS_PER_SECOND * tokenBalance;\\n            }\\n        }\\n\\n        unchecked {\\n            rewardsBitField[owner] = tokenBalance + tokenAmount | block.timestamp << 16 | rewardsBalance << 48;\\n        }\\n    }\\n\\n    // ---------- TRANSFER ----------\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public override {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        require(from == ownerOf[id], \\\"NOT_TOKEN_OWNER\\\");\\n        require(amount == 1, \\\"INVALID_AMOUNT\\\");\\n        require(!ILockManager(lockManager).isLocked(from, to, id), \\\"TOKEN_LOCKED\\\");\\n\\n        ownerOf[id] = to;\\n        _updateRewardsForTransfer(from, to, amount);\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public override {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n        require(!ILockManager(lockManager).isLocked(from, to, ids), \\\"TOKEN_LOCKED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                uint256 id;\\n                uint256 amount;\\n\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    // Load current array elements by adding offset of current\\n                    // array index to start of each array's data area inside calldata\\n                    let indexOffset := mul(i, 0x20)\\n                    id := calldataload(add(ids.offset, indexOffset))\\n                    amount := calldataload(add(amounts.offset, indexOffset))\\n                }\\n\\n                // Can only transfer from the owner.\\n                require(from == ownerOf[id], \\\"NOT_TOKEN_OWNER\\\");\\n\\n                // Can only transfer 1 with ERC1155B.\\n                require(amount == 1, \\\"INVALID_AMOUNT\\\");\\n\\n                ownerOf[id] = to;\\n            }\\n        }\\n\\n        _updateRewardsForTransfer(from, to, ids.length);\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    // ---------- WHITELIST SALE ----------\\n\\n    /// @notice Mint a single Arboria token during whitelist sale\\n    function mintWhitelistArboria() external payable {\\n        require(block.timestamp >= whitelistSaleDate, \\\"Whitelist sale not ready\\\");\\n\\n        // Burn whitelist ticket\\n        IAchievements(achievements).burn(msg.sender, whitelistTicketTokenID, 1);\\n\\n        _mintArboria();\\n    }\\n\\n    /// @notice Mint a single Illskagaard token during whitelist sale\\n    function mintWhitelistIllskagaard() external payable {\\n        require(block.timestamp >= whitelistSaleDate, \\\"Whitelist sale not ready\\\");\\n\\n        // Burn whitelist ticket\\n        IAchievements(achievements).burn(msg.sender, whitelistTicketTokenID, 1);\\n\\n        _mintIllskagaard();\\n    }\\n\\n    /// @notice Mint a single Lacrean Empire token during whitelist sale\\n    function mintWhitelistLacrean() external payable {\\n        require(block.timestamp >= whitelistSaleDate, \\\"Whitelist sale not ready\\\");\\n\\n        // Burn whitelist ticket\\n        IAchievements(achievements).burn(msg.sender, whitelistTicketTokenID, 1);\\n\\n        _mintLacrean();\\n    }\\n\\n    /// @notice Batch mint specified amount of tokens during whitelist sale\\n    /// @param arboriaAmount Amount of Arboria tokens to mint\\n    /// @param illskagaardAmount Amount of Illskagaard tokens to mint\\n    /// @param lacreanAmount Amount of Lacrean tokens to mint\\n    function batchMintWhitelist(uint256 arboriaAmount, uint256 illskagaardAmount, uint256 lacreanAmount) external payable {\\n        require(block.timestamp >= whitelistSaleDate, \\\"Whitelist sale not ready\\\");\\n\\n        // Burn whitelist tickets\\n        IAchievements(achievements).burn(msg.sender, whitelistTicketTokenID, arboriaAmount + illskagaardAmount + lacreanAmount);\\n\\n        _batchMint(arboriaAmount, illskagaardAmount, lacreanAmount);\\n    }\\n\\n    // ---------- PUBLIC SALE ----------\\n\\n    /// @notice Mint a single Arboria token during public sale\\n    function mintPublicArboria() external payable {\\n        require(block.timestamp >= publicSaleDate, \\\"Public sale not ready\\\");\\n        _mintArboria();\\n    }\\n\\n    /// @notice Mint a single Illskagaard token during public sale\\n    function mintPublicIllskagaard() external payable {\\n        require(block.timestamp >= publicSaleDate, \\\"Public sale not ready\\\");\\n        _mintIllskagaard();\\n    }\\n\\n    /// @notice Mint a single Lacrean Empire token during public sale\\n    function mintPublicLacrean() external payable {\\n        require(block.timestamp >= publicSaleDate, \\\"Public sale not ready\\\");\\n        _mintLacrean();\\n    }\\n\\n    /// @notice Batch mint specified amount of tokens during public sale\\n    /// @param arboriaAmount Amount of Arboria tokens to mint\\n    /// @param illskagaardAmount Amount of Illskagaard tokens to mint\\n    /// @param lacreanAmount Amount of Lacrean tokens to mint\\n    function batchMintPublic(uint256 arboriaAmount, uint256 illskagaardAmount, uint256 lacreanAmount) external payable {\\n        require(block.timestamp >= publicSaleDate, \\\"Public sale not ready\\\");\\n        _batchMint(arboriaAmount, illskagaardAmount, lacreanAmount);\\n    }\\n\\n    // ---------- MINT ----------\\n\\n    /// @dev Mint a single Arboria token\\n    function _mintArboria() internal {\\n        require(msg.sender == tx.origin, \\\"Smart contract minting not allowed\\\");\\n        require(msg.value == MINT_PRICE, \\\"Wrong price\\\");\\n        // Total supply of Arboria tokens is stored in the first 16 bits of the bit field\\n        uint256 tokenId = _totalSupplyBitField & _TOTAL_SUPPLY_BITMASK;\\n        require(tokenId < MAX_SUPPLY_PER_FACTION, \\\"Reached max Arboria supply\\\");\\n\\n        ownerOf[tokenId] = msg.sender;\\n        unchecked {\\n            // Incrementing the whole bit field increments just the total supply of\\n            // Arboria tokens, because only the value stored in the first bits gets updated\\n            _totalSupplyBitField++;\\n        }\\n\\n        _updateRewardsForMint(msg.sender, 1);\\n        emit TransferSingle(msg.sender, address(0), msg.sender, tokenId, 1);\\n    }\\n\\n    /// @dev Mint a single Illskagaard token\\n    function _mintIllskagaard() internal {\\n        require(msg.sender == tx.origin, \\\"Smart contract minting not allowed\\\");\\n        require(msg.value == MINT_PRICE, \\\"Wrong price\\\");\\n        // Store bit field in memory to reduce number of SLOADs\\n        uint256 totalSupplyBitField = _totalSupplyBitField;\\n        // Total supply of Illskagaard tokens is stored in the second 16 bits of the bit field\\n        uint256 _totalSupplyIllskagaard = totalSupplyBitField >> 16 & _TOTAL_SUPPLY_BITMASK;\\n        require(_totalSupplyIllskagaard < MAX_SUPPLY_PER_FACTION, \\\"Reached max Illskagaard supply\\\");\\n\\n        unchecked {\\n            // Illskagaard token IDs start at 6000\\n            uint256 tokenId = MAX_SUPPLY_PER_FACTION + _totalSupplyIllskagaard;\\n            ownerOf[tokenId] = msg.sender;\\n\\n            // Second 16 bits need to be all set to 0 before the new total supply of\\n            // Illskagaard tokens can be stored\\n            _totalSupplyBitField = totalSupplyBitField & ~(uint256(type(uint16).max) << 16) | ++_totalSupplyIllskagaard << 16;\\n\\n            _updateRewardsForMint(msg.sender, 1);\\n            emit TransferSingle(msg.sender, address(0), msg.sender, tokenId, 1);\\n        }\\n    }\\n\\n    /// @dev Mint a single Lacrean Empire token\\n    function _mintLacrean() internal {\\n        require(msg.sender == tx.origin, \\\"Smart contract minting not allowed\\\");\\n        require(msg.value == MINT_PRICE, \\\"Wrong price\\\");\\n        // Store bit field in memory to reduce number of SLOADs\\n        uint256 totalSupplyBitField = _totalSupplyBitField;\\n        // Total supply of Lacrean Empire tokens is stored in the third 16 bits of the bit field\\n        uint256 _totalSupplyLacrean = totalSupplyBitField >> 32;\\n        require(_totalSupplyLacrean < MAX_SUPPLY_PER_FACTION, \\\"Reached max Lacrean supply\\\");\\n\\n        unchecked {\\n            // Lacrean Empire token IDs start at 12000\\n            uint256 tokenId = MAX_SUPPLY_PER_FACTION * 2 + _totalSupplyLacrean;\\n            ownerOf[tokenId] = msg.sender;\\n\\n            // Third 16 bits need to be all set to 0 before the new total supply of\\n            // Lacrean Empire tokens can be stored\\n            _totalSupplyBitField = totalSupplyBitField & ~(uint256(type(uint16).max) << 32) | ++_totalSupplyLacrean << 32;\\n\\n            _updateRewardsForMint(msg.sender, 1);\\n            emit TransferSingle(msg.sender, address(0), msg.sender, tokenId, 1);\\n        }\\n    }\\n\\n    /// @notice Batch mint specified amount of tokens\\n    /// @param arboriaAmount Amount of Arboria tokens to mint\\n    /// @param illskagaardAmount Amount of Illskagaard tokens to mint\\n    /// @param lacreanAmount Amount of Lacrean tokens to mint\\n    function _batchMint(uint256 arboriaAmount, uint256 illskagaardAmount, uint256 lacreanAmount) internal {\\n        require(msg.sender == tx.origin, \\\"Smart contract minting not allowed\\\");\\n        // Doing these checks and later calculating the total amount unchecked costs less gas\\n        // than not doing these checks and calculating the total amount checked\\n        require(arboriaAmount <= MAX_MINT_AMOUNT_PER_TX, \\\"Arboria amount over maximum allowed per transaction\\\");\\n        require(illskagaardAmount <= MAX_MINT_AMOUNT_PER_TX, \\\"Illskagaard amount over maximum allowed per transaction\\\");\\n        require(lacreanAmount <= MAX_MINT_AMOUNT_PER_TX, \\\"Lacrean amount over maximum allowed per transaction\\\");\\n\\n        // Once the supplied amounts are known to be under certain limits,\\n        // all following calculations are safe and can be performed unchecked\\n        unchecked {\\n            uint256 totalAmount = arboriaAmount + illskagaardAmount + lacreanAmount;\\n            require(totalAmount > 1, \\\"Total amount must be at least 2\\\");\\n            require(totalAmount <= MAX_MINT_AMOUNT_PER_TX, \\\"Total amount over maximum allowed per transaction\\\");\\n            require(msg.value == totalAmount * MINT_PRICE, \\\"Wrong price\\\");\\n\\n            // Token IDs and amounts are collected in arrays to later emit the TransferBatch event\\n            uint256[] memory tokenIds = new uint256[](totalAmount);\\n            // Token amounts are all 1\\n            uint256[] memory amounts = new uint256[](totalAmount);\\n            // Keeps track of the current index of both arrays\\n            uint256 currentArrayIndex;\\n\\n            // Store bit field in memory to reduce number of SLOADs\\n            uint256 totalSupplyBitField = _totalSupplyBitField;\\n            // New bit field gets updated in memory to reduce number of SSTOREs\\n            // _totalSupplyBitField is only updated once after all tokens are minted\\n            uint256 newTotalSupplyBitField = totalSupplyBitField;\\n\\n            if (arboriaAmount > 0) {\\n                // Total supply of Arboria tokens is stored in the first 16 bits of the bit field\\n                uint256 _totalSupplyArboria = totalSupplyBitField & _TOTAL_SUPPLY_BITMASK;\\n                uint256 newTotalSupplyArboria = _totalSupplyArboria + arboriaAmount;\\n                require(newTotalSupplyArboria <= MAX_SUPPLY_PER_FACTION, \\\"Reached max Arboria supply\\\");\\n\\n                for (uint256 i = 0; i < arboriaAmount; i++) {\\n                    uint256 tokenId = _totalSupplyArboria + i;\\n                    ownerOf[tokenId] = msg.sender;\\n\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        // Store token ID and amount in the\\n                        // corresponding memory arrays\\n                        let indexOffset := mul(i, 0x20)\\n                        mstore(add(add(tokenIds, 0x20), indexOffset), tokenId)\\n                        mstore(add(add(amounts, 0x20), indexOffset), 1)\\n                    }\\n                }\\n                currentArrayIndex = arboriaAmount;\\n\\n                // First 16 bits need to be all set to 0 before the new total supply of Arboria tokens can be stored\\n                newTotalSupplyBitField = newTotalSupplyBitField & uint16(0) | newTotalSupplyArboria;\\n            }\\n\\n            if (illskagaardAmount > 0) {\\n                // Total supply of Illskagaard tokens is stored in the second 16 bits of the bit field\\n                uint256 _totalSupplyIllskagaard = totalSupplyBitField >> 16 & _TOTAL_SUPPLY_BITMASK;\\n                uint256 newTotalSupplyIllskagaard = _totalSupplyIllskagaard + illskagaardAmount;\\n                require(newTotalSupplyIllskagaard <= MAX_SUPPLY_PER_FACTION, \\\"Reached max Illskagaard supply\\\");\\n\\n                for (uint256 i = 0; i < illskagaardAmount; i++) {\\n                    // Illskagaard token IDs start at 6000\\n                    uint256 tokenId = MAX_SUPPLY_PER_FACTION + _totalSupplyIllskagaard + i;\\n                    ownerOf[tokenId] = msg.sender;\\n\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        // Store token ID and amount in the\\n                        // corresponding memory arrays\\n                        let indexOffset := mul(currentArrayIndex, 0x20)\\n                        mstore(add(add(tokenIds, 0x20), indexOffset), tokenId)\\n                        mstore(add(add(amounts, 0x20), indexOffset), 1)\\n                    }\\n\\n                    currentArrayIndex++;\\n                }\\n\\n                // Second 16 bits need to be all set to 0 before the new total supply of Illskagaard tokens can be stored\\n                newTotalSupplyBitField = newTotalSupplyBitField & ~(uint256(type(uint16).max) << 16) | newTotalSupplyIllskagaard << 16;\\n            }\\n\\n            if (lacreanAmount > 0) {\\n                // Total supply of Lacrean Empire tokens is stored in the third 16 bits of the bit field\\n                uint256 _totalSupplyLacrean = totalSupplyBitField >> 32;\\n                uint256 newTotalSupplyLacrean = _totalSupplyLacrean + lacreanAmount;\\n                require(newTotalSupplyLacrean <= MAX_SUPPLY_PER_FACTION, \\\"Reached max Lacrean supply\\\");\\n\\n                for (uint256 i = 0; i < lacreanAmount; i++) {\\n                    // Lacrean Empire token IDs start at 12000\\n                    uint256 tokenId = MAX_SUPPLY_PER_FACTION * 2 + _totalSupplyLacrean + i;\\n                    ownerOf[tokenId] = msg.sender;\\n\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        // Store token ID and amount in the\\n                        // corresponding memory arrays\\n                        let indexOffset := mul(currentArrayIndex, 0x20)\\n                        mstore(add(add(tokenIds, 0x20), indexOffset), tokenId)\\n                        mstore(add(add(amounts, 0x20), indexOffset), 1)\\n                    }\\n\\n                    currentArrayIndex++;\\n                }\\n\\n                // Third 16 bits need to be all set to 0 before the new total supply of Lacrean Empire tokens can be stored\\n                newTotalSupplyBitField = newTotalSupplyBitField & ~(uint256(type(uint16).max) << 32) | newTotalSupplyLacrean << 32;\\n            }\\n\\n            _totalSupplyBitField = newTotalSupplyBitField;\\n            _updateRewardsForMint(msg.sender, totalAmount);\\n            emit TransferBatch(msg.sender, address(0), msg.sender, tokenIds, amounts);\\n        }\\n    }\\n\\n    // ---------- ALL OWNERS ----------\\n\\n    function allOwners() public view returns (address[] memory owners) {\\n        uint256 maxSupply = MAX_SUPPLY_PER_FACTION * 3;\\n        owners = new address[](maxSupply);\\n\\n        for (uint256 i = 0; i < maxSupply;) {\\n            owners[i] = ownerOf[i];\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    // ---------- WITHDRAW ----------\\n\\n    /// @notice Withdraw all Ether stored in this contract to address of contract owner\\n    function withdraw() external onlyOwner {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155B.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\nimport {ERC1155TokenReceiver} from \\\"./ERC1155.sol\\\";\\n\\n/// @notice Minimalist and gas efficient ERC1155 implementation optimized for single supply ids.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155B.sol)\\nabstract contract ERC1155B {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC1155B STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    function balanceOf(address owner, uint256 id) public view virtual returns (uint256 bal) {\\n        address idOwner = ownerOf[id];\\n\\n        assembly {\\n            // We avoid branching by using assembly to take\\n            // the bool output of eq() and use it as a uint.\\n            bal := eq(idOwner, owner)\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\"); // Can only transfer from the owner.\\n\\n        // Can only transfer 1 with ERC1155B.\\n        require(amount == 1, \\\"INVALID_AMOUNT\\\");\\n\\n        ownerOf[id] = to;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < ids.length; i++) {\\n                id = ids[i];\\n                amount = amounts[i];\\n\\n                // Can only transfer from the owner.\\n                require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n                // Can only transfer 1 with ERC1155B.\\n                require(amount == 1, \\\"INVALID_AMOUNT\\\");\\n\\n                ownerOf[id] = to;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf(owners[i], ids[i]);\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        // Minting twice would effectively be a force transfer.\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        ownerOf[id] = to;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, 1);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, 1, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        // Generate an amounts array locally to use in the event below.\\n        uint256[] memory amounts = new uint256[](idsLength);\\n\\n        uint256 id; // Storing outside the loop saves ~7 gas per iteration.\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < idsLength; ++i) {\\n                id = ids[i];\\n\\n                // Minting twice would effectively be a force transfer.\\n                require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n                ownerOf[id] = to;\\n\\n                amounts[i] = 1;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchBurn(address from, uint256[] memory ids) internal virtual {\\n        // Burning unminted tokens makes no sense.\\n        require(from != address(0), \\\"INVALID_FROM\\\");\\n\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        // Generate an amounts array locally to use in the event below.\\n        uint256[] memory amounts = new uint256[](idsLength);\\n\\n        uint256 id; // Storing outside the loop saves ~7 gas per iteration.\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < idsLength; ++i) {\\n                id = ids[i];\\n\\n                require(ownerOf[id] == from, \\\"WRONG_FROM\\\");\\n\\n                ownerOf[id] = address(0);\\n\\n                amounts[i] = 1;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        ownerOf[id] = address(0);\\n\\n        emit TransferSingle(msg.sender, owner, address(0), id, 1);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/IAchievements.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/// @title Solarbots Achievements Interface\\n/// @author Solarbots (https://solarbots.io)\\ninterface IAchievements {\\n    function burn(address from, uint256 id, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/ILockManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/// @title Solarbots Lock Manager Interface\\n/// @author Solarbots (https://solarbots.io)\\ninterface ILockManager {\\n    function isLocked(address from, address to, uint256 id) external returns (bool);\\n    function isLocked(address from, address to, uint256[] calldata ids) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/Owned.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\n/// @notice Simple contract ownership module\\n/// @author Solarbots (https://solarbots.io)\\nabstract contract Owned {\\n    address public owner;\\n\\n    event OwnershipTransfer(address indexed previousOwner, address indexed newOwner);\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"NOT_OWNER\\\");\\n\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        owner = _owner;\\n\\n        emit OwnershipTransfer(address(0), _owner);\\n    }\\n\\n    function setOwner(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"INVALID_OWNER\\\");\\n\\n        owner = newOwner;\\n\\n        emit OwnershipTransfer(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public virtual {\\n        require(ids.length == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i = 0; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function balanceOfBatch(address[] calldata owners, uint256[] calldata ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        require(owners.length == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i < owners.length; ++i) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            require(\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n                \\\"UNSAFE_RECIPIENT\\\"\\n            );\\n        } else require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i < idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"script/=script/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\",\r\n      \"script/=script/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistSaleDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_publicSaleDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsEndTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_achievements\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_whitelistTicketTokenID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lockManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousLockManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newLockManager\",\"type\":\"address\"}],\"name\":\"LockManagerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"TransferBatch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TransferSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"URI\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MINT_AMOUNT_PER_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY_PER_FACTION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINT_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_PER_SECOND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"achievements\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allOwners\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bal\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"owners\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"balanceOfBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"balances\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arboriaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"illskagaardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lacreanAmount\",\"type\":\"uint256\"}],\"name\":\"batchMintPublic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"arboriaAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"illskagaardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lacreanAmount\",\"type\":\"uint256\"}],\"name\":\"batchMintWhitelist\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForRewards\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublicArboria\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublicIllskagaard\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPublicLacrean\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWhitelistArboria\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWhitelistIllskagaard\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintWhitelistLacrean\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicSaleDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewardsBitField\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsEndTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"rewardsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardsBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeBatchTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lockManager\",\"type\":\"address\"}],\"name\":\"setLockManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_rewardsBitField\",\"type\":\"uint256\"}],\"name\":\"setRewardsBitField\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_uriSuffix\",\"type\":\"string\"}],\"name\":\"setURISuffix\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyArboria\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyIllskagaard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupplyLacrean\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"uri\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uriSuffix\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistSaleDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistTicketTokenID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PlayerHousing", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "0000000000000000000000005a5fe90cd115d691ee99d90d3607f7005ea817e50000000000000000000000000000000000000000000000000000000062af80400000000000000000000000000000000000000000000000000000000062b2234000000000000000000000000000000000000000000000000000000000757f77c0000000000000000000000000544d219c227856935bf9678e21a2cd012bcc8bd80000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f058480504c3451fb45e9f68241b500440da0831", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}