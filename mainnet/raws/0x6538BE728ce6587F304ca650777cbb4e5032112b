{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/market/handlers/facets/SaleBuilderFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"../../../interfaces/IEscrowTicketer.sol\\\";\\nimport \\\"../../../interfaces/ISaleBuilder.sol\\\";\\nimport \\\"../../../interfaces/ISaleHandler.sol\\\";\\nimport \\\"../../../interfaces/ISaleRunner.sol\\\";\\nimport \\\"../../../interfaces/ISeenHausNFT.sol\\\";\\nimport \\\"../MarketHandlerBase.sol\\\";\\n\\n/**\\n * @title SaleBuilderFacet\\n *\\n * @notice Handles the operation of Seen.Haus sales.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SaleBuilderFacet is ISaleBuilder, MarketHandlerBase {\\n\\n    /**\\n     * @dev Modifier to protect initializer function from being invoked twice.\\n     */\\n    modifier onlyUnInitialized()\\n    {\\n        MarketHandlerLib.MarketHandlerInitializers storage mhi = MarketHandlerLib.marketHandlerInitializers();\\n        require(!mhi.saleBuilderFacet, \\\"Initializer: contract is already initialized\\\");\\n        mhi.saleBuilderFacet = true;\\n        _;\\n    }\\n\\n    /**\\n     * @notice Facet Initializer\\n     *\\n     * Register supported interfaces\\n     */\\n    function initialize()\\n    public\\n    onlyUnInitialized\\n    {\\n        DiamondLib.addSupportedInterface(type(ISaleBuilder).interfaceId);  // when combined with ISaleRunner ...\\n        DiamondLib.addSupportedInterface(type(ISaleBuilder).interfaceId ^ type(ISaleRunner).interfaceId); // ... supports ISaleHandler\\n    }\\n\\n    /**\\n     * @notice The sale getter\\n     */\\n    function getSale(uint256 _consignmentId)\\n    external\\n    override\\n    view\\n    returns (Sale memory)\\n    {\\n        // Get Market Handler Storage struct\\n        MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n\\n        // Return sale\\n        return mhs.sales[_consignmentId];\\n    }\\n\\n    /**\\n     * @notice Create a new sale.\\n     *\\n     * For some lot size of one ERC-1155 token.\\n     *\\n     * Ownership of the consigned inventory is transferred to this contract\\n     * for the duration of the sale.\\n     *\\n     * Reverts if:\\n     *  - Sale start is zero\\n     *  - Sale exists for consignment\\n     *  - Consignment has already been marketed\\n     *\\n     * Emits a SalePending event.\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     * @param _start - the scheduled start time of the sale\\n     * @param _price - the price of each item in the lot\\n     * @param _perTxCap - the maximum amount that can be bought in a single transaction\\n     * @param _audience - the initial audience that can participate. See {SeenTypes.Audience}\\n     */\\n    function createPrimarySale (\\n        uint256 _consignmentId,\\n        uint256 _start,\\n        uint256 _price,\\n        uint256 _perTxCap,\\n        Audience _audience\\n    )\\n    external\\n    override\\n    onlyRole(SELLER)\\n    onlyConsignor(_consignmentId)\\n    {\\n        require(_start > 0, \\\"_start may not be zero\\\");\\n\\n        // Get Market Handler Storage slot\\n        MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n\\n        // Fetch the consignment\\n        Consignment memory consignment = getMarketController().getConsignment(_consignmentId);\\n\\n        // Make sure the consignment hasn't been marketed\\n        require(consignment.marketHandler == MarketHandler.Unhandled, \\\"Consignment has already been marketed\\\");\\n\\n        // Get the storage location for the sale\\n        Sale storage sale = mhs.sales[consignment.id];\\n\\n        // Make sure sale doesn't exist (start would always be non-zero on an actual sale)\\n        require(sale.start == 0, \\\"Sale exists\\\");\\n\\n        // Set up the sale\\n        setAudience(_consignmentId, _audience);\\n        sale.consignmentId = _consignmentId;\\n        sale.start = _start;\\n        sale.price = _price;\\n        sale.perTxCap = _perTxCap;\\n        sale.state = State.Pending;\\n        sale.outcome = Outcome.Pending;\\n\\n        // Notify MarketController the consignment has been marketed\\n        getMarketController().marketConsignment(consignment.id, MarketHandler.Sale);\\n\\n        // Notify listeners of state change\\n        emit SalePending(msg.sender, consignment.seller, sale);\\n    }\\n\\n    /**\\n     * @notice Create a new sale.\\n     *\\n     * For some lot size of one ERC-1155 token.\\n     *\\n     * Ownership of the consigned inventory is transferred to this contract\\n     * for the duration of the sale.\\n     *\\n     * Reverts if:\\n     *  - Sale start is zero\\n     *  - Supply is zero\\n     *  - Sale exists for consignment\\n     *  - This contract isn't approved to transfer seller's tokens\\n     *  - Token contract does not implement either IERC1155 or IERC721\\n     *\\n     * Emits a SalePending event.\\n     *\\n     * @param _seller - the address that procedes of the sale should go to\\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\\n     * @param _tokenId - the id of the token being consigned\\n     * @param _start - the scheduled start time of the sale\\n     * @param _supply - the supply of the given consigned token being sold\\n     * @param _price - the price of each item in the lot\\n     * @param _perTxCap - the maximum amount that can be bought in a single transaction\\n     * @param _audience - the initial audience that can participate. See {SeenTypes.Audience}\\n     */\\n    function createSecondarySale (\\n        address payable _seller,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _start,\\n        uint256 _supply,\\n        uint256 _price,\\n        uint256 _perTxCap,\\n        Audience _audience\\n    )\\n    external\\n    override\\n    {\\n        // Make sure sale start is not set to zero\\n        require(_start > 0, \\\"_start may not be zero\\\");\\n\\n        // Get Market Handler Storage slot\\n        MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n\\n        // Get the MarketController\\n        IMarketController marketController = getMarketController();\\n\\n        // Determine if consignment is physical\\n        address nft = marketController.getNft();\\n        if (nft == _tokenAddress && ISeenHausNFT(nft).isPhysical(_tokenId)) {\\n            // Is physical NFT, require that msg.sender has ESCROW_AGENT role\\n            require(checkHasRole(msg.sender, ESCROW_AGENT), \\\"Physical NFT secondary listings require ESCROW_AGENT role\\\");\\n        } else if (nft != _tokenAddress) {\\n            // Is external NFT, require that listing external NFTs is enabled\\n            bool isEnabled = marketController.getAllowExternalTokensOnSecondary();\\n            require(isEnabled, \\\"Listing external tokens is not currently enabled\\\");\\n        }\\n\\n        // Make sure supply is non-zero\\n        require (_supply > 0, \\\"Supply must be non-zero\\\");\\n\\n        // Make sure this contract is approved to transfer the token\\n        // N.B. The following will work because isApprovedForAll has the same signature on both IERC721 and IERC1155\\n        require(IERC1155Upgradeable(_tokenAddress).isApprovedForAll(msg.sender, address(this)), \\\"Not approved to transfer seller's tokens\\\");\\n\\n        // To register the consignment, tokens must first be in MarketController's possession\\n        if (IERC165Upgradeable(_tokenAddress).supportsInterface(type(IERC1155Upgradeable).interfaceId)) {\\n\\n            // Ensure seller owns sufficient supply of token\\n            require(IERC1155Upgradeable(_tokenAddress).balanceOf(msg.sender, _tokenId) >= _supply, \\\"Seller has insufficient balance of token\\\");\\n\\n            // Transfer supply to MarketController\\n            IERC1155Upgradeable(_tokenAddress).safeTransferFrom(\\n                msg.sender,\\n                address(getMarketController()),\\n                _tokenId,\\n                _supply,\\n                new bytes(0x0)\\n            );\\n\\n        } else {\\n\\n            require(_supply == 1, \\\"ERC721 listings must use a supply of 1\\\");\\n\\n            // Token must be a single token NFT\\n            require(IERC165Upgradeable(_tokenAddress).supportsInterface(type(IERC721Upgradeable).interfaceId), \\\"Invalid token type\\\");\\n\\n            // Transfer tokenId to MarketController\\n            IERC721Upgradeable(_tokenAddress).safeTransferFrom(\\n                msg.sender,\\n                address(getMarketController()),\\n                _tokenId\\n            );\\n\\n        }\\n\\n        // Register consignment\\n        Consignment memory consignment = getMarketController().registerConsignment(Market.Secondary, msg.sender, _seller, _tokenAddress, _tokenId, _supply);\\n        // Secondaries are marketed directly after registration\\n        getMarketController().marketConsignment(consignment.id, MarketHandler.Sale);\\n\\n        // Set up the sale\\n        setAudience(consignment.id, _audience);\\n        Sale storage sale = mhs.sales[consignment.id];\\n        sale.consignmentId = consignment.id;\\n        sale.start = _start;\\n        sale.price = _price;\\n        sale.perTxCap = _perTxCap;\\n        sale.state = State.Pending;\\n        sale.outcome = Outcome.Pending;\\n\\n        // Notify listeners of state change\\n        emit SalePending(msg.sender, consignment.seller, sale);\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IEscrowTicketer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IEscrowTicketer\\n *\\n * @notice Manages the issue and claim of escrow tickets.\\n *\\n * The ERC-165 identifier for this interface is: 0x73811679\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IEscrowTicketer {\\n\\n    event TicketIssued(uint256 ticketId, uint256 indexed consignmentId, address indexed buyer, uint256 amount);\\n    event TicketClaimed(uint256 ticketId, address indexed claimant, uint256 amount);\\n\\n    /**\\n     * @notice The nextTicket getter\\n     */\\n    function getNextTicket() external view returns (uint256);\\n\\n    /**\\n     * @notice Get info about the ticket\\n     */\\n    function getTicket(uint256 _ticketId) external view returns (SeenTypes.EscrowTicket memory);\\n\\n    /**\\n     * @notice Get how many claims can be made using tickets (does not change after ticket burns)\\n     */\\n    function getTicketClaimableCount(uint256 _consignmentId) external view returns (uint256);\\n\\n    /**\\n     * @notice Gets the URI for the ticket metadata\\n     *\\n     * This method normalizes how you get the URI,\\n     * since ERC721 and ERC1155 differ in approach\\n     *\\n     * @param _ticketId - the token id of the ticket\\n     */\\n    function getTicketURI(uint256 _ticketId) external view returns (string memory);\\n\\n    /**\\n     * Issue an escrow ticket to the buyer\\n     *\\n     * For physical consignments, Seen.Haus must hold the items in escrow\\n     * until the buyer(s) claim them.\\n     *\\n     * When a buyer wins an auction or makes a purchase in a sale, the market\\n     * handler contract they interacted with will call this method to issue an\\n     * escrow ticket, which is an NFT that can be sold, transferred, or claimed.\\n     *\\n     * @param _consignmentId - the id of the consignment being sold\\n     * @param _amount - the amount of the given token to escrow\\n     * @param _buyer - the buyer of the escrowed item(s) to whom the ticket is issued\\n     */\\n    function issueTicket(uint256 _consignmentId, uint256 _amount, address payable _buyer) external;\\n\\n    /**\\n     * Claim the holder's escrowed items associated with the ticket.\\n     *\\n     * @param _ticketId - the ticket representing the escrowed items\\n     */\\n    function claim(uint256 _ticketId) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISaleBuilder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\nimport \\\"./IMarketHandler.sol\\\";\\n\\n/**\\n * @title ISaleBuilder\\n *\\n * @notice Handles the creation of Seen.Haus sales.\\n *\\n * The ERC-165 identifier for this interface is: 0x4811411a\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface ISaleBuilder is IMarketHandler {\\n\\n    // Events\\n    event SalePending(address indexed consignor, address indexed seller, SeenTypes.Sale sale);\\n\\n    /**\\n     * @notice The sale getter\\n     */\\n    function getSale(uint256 _consignmentId) external view returns (SeenTypes.Sale memory);\\n\\n    /**\\n     * @notice Create a new sale.\\n     *\\n     * For some lot size of one ERC-1155 token.\\n     *\\n     * Ownership of the consigned inventory is transferred to this contract\\n     * for the duration of the sale.\\n     *\\n     * Reverts if:\\n     *  - Sale exists for consignment\\n     *  - Consignment has already been marketed\\n     *  - Sale start is zero\\n     *\\n     * Emits a SalePending event.\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     * @param _start - the scheduled start time of the sale\\n     * @param _price - the price of each item in the lot\\n     * @param _perTxCap - the maximum amount that can be bought in a single transaction\\n     * @param _audience - the initial audience that can participate. See {SeenTypes.Audience}\\n     */\\n    function createPrimarySale (\\n        uint256 _consignmentId,\\n        uint256 _start,\\n        uint256 _price,\\n        uint256 _perTxCap,\\n        SeenTypes.Audience _audience\\n    ) external;\\n\\n    /**\\n     * @notice Create a new sale.\\n     *\\n     * For some lot size of one ERC-1155 token.\\n     *\\n     * Ownership of the consigned inventory is transferred to this contract\\n     * for the duration of the sale.\\n     *\\n     * Reverts if:\\n     *  - Sale exists for consignment\\n     *  - Sale start is zero\\n     *  - This contract isn't approved to transfer seller's tokens\\n     *\\n     * Emits a SalePending event.\\n     *\\n     * @param _seller - the current owner of the consignment\\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\\n     * @param _tokenId - the id of the token being consigned\\n     * @param _start - the scheduled start time of the sale\\n     * @param _supply - the supply of the given consigned token being sold\\n     * @param _price - the price of each item in the lot\\n     * @param _perTxCap - the maximum amount that can be bought in a single transaction\\n     * @param _audience - the initial audience that can participate. See {SeenTypes.Audience}\\n     */\\n    function createSecondarySale (\\n        address payable _seller,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _start,\\n        uint256 _supply,\\n        uint256 _price,\\n        uint256 _perTxCap,\\n        SeenTypes.Audience _audience\\n    ) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISaleHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/ISaleBuilder.sol\\\";\\nimport \\\"../interfaces/ISaleRunner.sol\\\";\\nimport \\\"../interfaces/ISaleEnder.sol\\\";\\n\\n/**\\n * @title ISaleHandler\\n *\\n * @notice Handles the creation, running, and disposition of Seen.Haus sales.\\n *\\n * The ERC-165 identifier for this interface is: 0xa9ae54df\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface ISaleHandler is ISaleBuilder, ISaleRunner, ISaleEnder {}\"\r\n    },\r\n    \"contracts/interfaces/ISaleRunner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\nimport \\\"./IMarketHandler.sol\\\";\\n\\n/**\\n * @title ISaleRunner\\n *\\n * @notice Handles the operation of Seen.Haus sales.\\n *\\n * The ERC-165 identifier for this interface is: 0xe1bf15c5\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface ISaleRunner is IMarketHandler {\\n\\n    // Events\\n    event SaleStarted(uint256 indexed consignmentId);\\n    event Purchase(uint256 indexed consignmentId, address indexed buyer, uint256 amount, uint256 value);\\n    event TokenHistoryTracker(address indexed tokenAddress, uint256 indexed tokenId, address indexed buyer, uint256 value, uint256 amount, uint256 consignmentId);\\n\\n    /**\\n     * @notice Change the audience for a sale.\\n     *\\n     * Reverts if:\\n     *  - Caller does not have ADMIN role\\n     *  - Auction doesn't exist or has already been settled\\n     *\\n     * @param _consignmentId - the id of the consignment being sold\\n     * @param _audience - the new audience for the sale\\n     */\\n    function changeSaleAudience(uint256 _consignmentId, SeenTypes.Audience _audience) external;\\n\\n    /**\\n     * @notice Buy some amount of the remaining supply of the lot for sale.\\n     *\\n     * Ownership of the purchased inventory is transferred to the buyer.\\n     * The buyer's payment will be held for disbursement when sale is settled.\\n     *\\n     * Reverts if:\\n     *  - Caller is not in audience\\n     *  - Sale doesn't exist or hasn't started\\n     *  - Caller is a contract\\n     *  - The per-transaction buy limit is exceeded\\n     *  - Payment doesn't cover the order price\\n     *\\n     * Emits a Purchase event.\\n     * May emit a SaleStarted event, on the first purchase.\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     * @param _amount - the amount of the remaining supply to buy\\n     */\\n    function buy(uint256 _consignmentId, uint256 _amount) external payable;\\n\\n    /**\\n     * @notice Claim a pending payout on an ongoing sale without closing/cancelling\\n     *\\n     * Funds are disbursed as normal. See: {MarketHandlerBase.disburseFunds}\\n     *\\n     * Reverts if:\\n     * - Sale doesn't exist or hasn't started\\n     * - There is no pending payout\\n     * - Called by any address other than seller\\n     * - The sale is sold out (in which case closeSale should be called)\\n     *\\n     * Does not emit its own event, but disburseFunds emits an event\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     */\\n    function claimPendingPayout(uint256 _consignmentId) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISeenHausNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155Upgradeable.sol\\\";\\nimport \\\"../domain/SeenTypes.sol\\\";\\nimport \\\"./IERC2981.sol\\\";\\n\\n/**\\n * @title ISeenHausNFT\\n *\\n * @notice This is the interface for the Seen.Haus ERC-1155 NFT contract.\\n *\\n * The ERC-165 identifier for this interface is: 0x34d6028b\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n*/\\ninterface ISeenHausNFT is IERC2981, IERC1155Upgradeable {\\n\\n    /**\\n     * @notice The nextToken getter\\n     * @dev does not increment counter\\n     */\\n    function getNextToken() external view returns (uint256 nextToken);\\n\\n    /**\\n     * @notice Get the info about a given token.\\n     *\\n     * @param _tokenId - the id of the token to check\\n     * @return tokenInfo - the info about the token. See: {SeenTypes.Token}\\n     */\\n    function getTokenInfo(uint256 _tokenId) external view returns (SeenTypes.Token memory tokenInfo);\\n\\n    /**\\n     * @notice Check if a given token id corresponds to a physical lot.\\n     *\\n     * @param _tokenId - the id of the token to check\\n     * @return physical - true if the item corresponds to a physical lot\\n     */\\n    function isPhysical(uint256 _tokenId) external returns (bool);\\n\\n    /**\\n     * @notice Mint a given supply of a token, marking it as physical.\\n     *\\n     * Entire supply must be minted at once.\\n     * More cannot be minted later for the same token id.\\n     * Can only be called by an address with the ESCROW_AGENT role.\\n     * Token supply is sent to the caller.\\n     *\\n     * @param _supply - the supply of the token\\n     * @param _creator - the creator of the NFT (where the royalties will go)\\n     * @param _tokenURI - the URI of the token metadata\\n     *\\n     * @return consignment - the registered primary market consignment of the newly minted token\\n     */\\n    function mintPhysical(\\n        uint256 _supply,\\n        address payable _creator,\\n        string memory _tokenURI,\\n        uint16 _royaltyPercentage\\n    )\\n    external\\n    returns(SeenTypes.Consignment memory consignment);\\n\\n    /**\\n     * @notice Mint a given supply of a token.\\n     *\\n     * Entire supply must be minted at once.\\n     * More cannot be minted later for the same token id.\\n     * Can only be called by an address with the MINTER role.\\n     * Token supply is sent to the caller's address.\\n     *\\n     * @param _supply - the supply of the token\\n     * @param _creator - the creator of the NFT (where the royalties will go)\\n     * @param _tokenURI - the URI of the token metadata\\n     *\\n     * @return consignment - the registered primary market consignment of the newly minted token\\n     */\\n    function mintDigital(\\n        uint256 _supply,\\n        address payable _creator,\\n        string memory _tokenURI,\\n        uint16 _royaltyPercentage\\n    )\\n    external\\n    returns(SeenTypes.Consignment memory consignment);\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() external view returns (address);\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() external;\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) external;\\n\\n}\"\r\n    },\r\n    \"contracts/market/handlers/MarketHandlerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../../interfaces/IMarketController.sol\\\";\\nimport \\\"../../interfaces/IMarketHandler.sol\\\";\\nimport \\\"../../interfaces/ISeenHausNFT.sol\\\";\\nimport \\\"../../domain/SeenConstants.sol\\\";\\nimport \\\"../../interfaces/IERC2981.sol\\\";\\nimport \\\"../../domain/SeenTypes.sol\\\";\\nimport \\\"./MarketHandlerLib.sol\\\";\\n\\n/**\\n * @title MarketHandlerBase\\n *\\n * @notice Provides base functionality for common actions taken by market handlers.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nabstract contract MarketHandlerBase is IMarketHandler, SeenTypes, SeenConstants {\\n\\n    /**\\n     * @dev Modifier that checks that the caller has a specific role.\\n     *\\n     * Reverts if caller doesn't have role.\\n     *\\n     * See: {AccessController.hasRole}\\n     */\\n    modifier onlyRole(bytes32 _role) {\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        require(ds.accessController.hasRole(_role, msg.sender), \\\"Caller doesn't have role\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that the caller has a specific role or is a consignor.\\n     *\\n     * Reverts if caller doesn't have role or is not consignor.\\n     *\\n     * See: {AccessController.hasRole}\\n     */\\n    modifier onlyRoleOrConsignor(bytes32 _role, uint256 _consignmentId) {\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        require(ds.accessController.hasRole(_role, msg.sender) || getMarketController().getConsignor(_consignmentId) == msg.sender, \\\"Caller doesn't have role or is not consignor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Function that checks that the caller has a specific role.\\n     *\\n     * Reverts if caller doesn't have role.\\n     *\\n     * See: {AccessController.hasRole}\\n     */\\n    function checkHasRole(address _address, bytes32 _role) internal view returns (bool) {\\n        DiamondLib.DiamondStorage storage ds = DiamondLib.diamondStorage();\\n        return ds.accessController.hasRole(_role, _address);\\n    }\\n\\n    /**\\n     * @notice Gets the address of the Seen.Haus MarketController contract.\\n     *\\n     * @return marketController - the address of the MarketController contract\\n     */\\n    function getMarketController()\\n    internal\\n    view\\n    returns(IMarketController marketController)\\n    {\\n        return IMarketController(address(this));\\n    }\\n\\n    /**\\n     * @notice Sets the audience for a consignment at sale or auction.\\n     *\\n     * Emits an AudienceChanged event.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _audience - the new audience for the consignment\\n     */\\n    function setAudience(uint256 _consignmentId, Audience _audience)\\n    internal\\n    {\\n        MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n\\n        // Set the new audience\\n        mhs.audiences[_consignmentId] = _audience;\\n\\n        // Notify listeners of state change\\n        emit AudienceChanged(_consignmentId, _audience);\\n\\n    }\\n\\n    /**\\n     * @notice Check if the caller is a Staker.\\n     *\\n     * @return status - true if caller's xSEEN ERC-20 balance is non-zero.\\n     */\\n    function isStaker()\\n    internal\\n    view\\n    returns (bool status)\\n    {\\n        IMarketController marketController = getMarketController();\\n        status = IERC20Upgradeable(marketController.getStaking()).balanceOf(msg.sender) > 0;\\n    }\\n\\n    /**\\n     * @notice Check if the caller is a VIP Staker.\\n     *\\n     * See {MarketController:vipStakerAmount}\\n     *\\n     * @return status - true if caller's xSEEN ERC-20 balance is at least equal to the VIP Staker Amount.\\n     */\\n    function isVipStaker()\\n    internal\\n    view\\n    returns (bool status)\\n    {\\n        IMarketController marketController = getMarketController();\\n        status = IERC20Upgradeable(marketController.getStaking()).balanceOf(msg.sender) >= marketController.getVipStakerAmount();\\n    }\\n\\n    /**\\n     * @notice Modifier that checks that caller is in consignment's audience\\n     *\\n     * Reverts if user is not in consignment's audience\\n     */\\n    modifier onlyAudienceMember(uint256 _consignmentId) {\\n        MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n        Audience audience = mhs.audiences[_consignmentId];\\n        if (audience != Audience.Open) {\\n            if (audience == Audience.Staker) {\\n                require(isStaker());\\n            } else if (audience == Audience.VipStaker) {\\n                require(isVipStaker());\\n            }\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier that checks that the caller is the consignor\\n     *\\n     * Reverts if caller isn't the consignor\\n     *\\n     * See: {MarketController.getConsignor}\\n     */\\n    modifier onlyConsignor(uint256 _consignmentId) {\\n\\n        // Make sure the caller is the consignor\\n        require(getMarketController().getConsignor(_consignmentId) == msg.sender, \\\"Caller is not consignor\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @notice Get a percentage of a given amount.\\n     *\\n     * N.B. Represent ercentage values are stored\\n     * as unsigned integers, the result of multiplying the given percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     *\\n     * @param _amount - the amount to return a percentage of\\n     * @param _percentage - the percentage value represented as above\\n     */\\n    function getPercentageOf(uint256 _amount, uint16 _percentage)\\n    internal\\n    pure\\n    returns (uint256 share)\\n    {\\n        share = _amount * _percentage / 10000;\\n    }\\n\\n    /**\\n     * @notice Deduct and pay royalties on sold secondary market consignments.\\n     *\\n     * Does nothing is this is a primary market sale.\\n     *\\n     * If the consigned item's contract supports NFT Royalty Standard EIP-2981,\\n     * it is queried for the expected royalty amount and recipient.\\n     *\\n     * Deducts royalty and pays to recipient:\\n     * - entire expected amount, if below or equal to the marketplace's maximum royalty percentage\\n     * - the marketplace's maximum royalty percentage See: {MarketController.maxRoyaltyPercentage}\\n     *\\n     * Emits a RoyaltyDisbursed event with the amount actually paid.\\n     *\\n     * @param _consignment - the consigned item\\n     * @param _grossSale - the gross sale amount\\n     *\\n     * @return net - the net amount of the sale after the royalty has been paid\\n     */\\n    function deductRoyalties(Consignment memory _consignment, uint256 _grossSale)\\n    internal\\n    returns (uint256 net)\\n    {\\n        // Only pay royalties on secondary market sales\\n        uint256 royaltyAmount = 0;\\n        if (_consignment.market == Market.Secondary) {\\n            // Determine if NFT contract supports NFT Royalty Standard EIP-2981\\n            try IERC165Upgradeable(_consignment.tokenAddress).supportsInterface(type(IERC2981).interfaceId) returns (bool supported) {\\n\\n                // If so, find out the who to pay and how much\\n                if (supported) {\\n\\n                    // Get the MarketController\\n                    IMarketController marketController = getMarketController();\\n\\n                    // Get the royalty recipient and expected payment\\n                    (address recipient, uint256 expected) = IERC2981(_consignment.tokenAddress).royaltyInfo(_consignment.tokenId, _grossSale);\\n\\n                    // Determine the max royalty we will pay\\n                    uint256 maxRoyalty = getPercentageOf(_grossSale, marketController.getMaxRoyaltyPercentage());\\n\\n                    // If a royalty is expected...\\n                    if (expected > 0) {\\n\\n                        // Lets pay, but only up to our platform policy maximum\\n                        royaltyAmount = (expected <= maxRoyalty) ? expected : maxRoyalty;\\n                        sendValueOrCreditAccount(payable(recipient), royaltyAmount);\\n\\n                        // Notify listeners of payment\\n                        emit RoyaltyDisbursed(_consignment.id, recipient, royaltyAmount);\\n                    }\\n\\n                }\\n\\n            // Any case where the check for interface support fails can be ignored\\n            } catch Error(string memory) {\\n            } catch (bytes memory) {\\n            }\\n\\n        }\\n\\n        // Return the net amount after royalty deduction\\n        net = _grossSale - royaltyAmount;\\n    }\\n\\n    /**\\n     * @notice Deduct and pay escrow agent fees on sold physical secondary market consignments.\\n     *\\n     * Does nothing if this is a primary market sale.\\n     *\\n     * Deducts escrow agent fee and pays to consignor\\n     * - entire expected amount\\n     *\\n     * Emits a EscrowAgentFeeDisbursed event with the amount actually paid.\\n     *\\n     * @param _consignment - the consigned item\\n     * @param _grossSale - the gross sale amount\\n     * @param _netAfterRoyalties - the funds left to be distributed\\n     *\\n     * @return net - the net amount of the sale after the royalty has been paid\\n     */\\n    function deductEscrowAgentFee(Consignment memory _consignment, uint256 _grossSale, uint256 _netAfterRoyalties)\\n    internal\\n    returns (uint256 net)\\n    {\\n        // Only pay royalties on secondary market sales\\n        uint256 escrowAgentFeeAmount = 0;\\n        if (_consignment.market == Market.Secondary) {\\n            // Get the MarketController\\n            IMarketController marketController = getMarketController();\\n            address consignor = marketController.getConsignor(_consignment.id);\\n            if(consignor != _consignment.seller) {\\n                uint16 escrowAgentBasisPoints = marketController.getEscrowAgentFeeBasisPoints(consignor);\\n                if(escrowAgentBasisPoints > 0) {\\n                    // Determine if consignment is physical\\n                    address nft = marketController.getNft();\\n                    if (nft == _consignment.tokenAddress && ISeenHausNFT(nft).isPhysical(_consignment.tokenId)) {\\n                        // Consignor is not seller, consigner has a positive escrowAgentBasisPoints value, consignment is of a physical item\\n                        // Therefore, pay consignor the escrow agent fees\\n                        escrowAgentFeeAmount = getPercentageOf(_grossSale, escrowAgentBasisPoints);\\n\\n                        // If escrow agent fee is expected...\\n                        if (escrowAgentFeeAmount > 0) {\\n                            require(escrowAgentFeeAmount <= _netAfterRoyalties, \\\"escrowAgentFeeAmount exceeds remaining funds\\\");\\n                            sendValueOrCreditAccount(payable(consignor), escrowAgentFeeAmount);\\n                            // Notify listeners of payment\\n                            emit EscrowAgentFeeDisbursed(_consignment.id, consignor, escrowAgentFeeAmount);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the net amount after royalty deduction\\n        net = _netAfterRoyalties - escrowAgentFeeAmount;\\n    }\\n\\n    /**\\n     * @notice Deduct and pay fee on a sold consignment.\\n     *\\n     * Deducts marketplace fee and pays:\\n     * - Half to the staking contract\\n     * - Half to the multisig contract\\n     *\\n     * Emits a FeeDisbursed event for staking payment.\\n     * Emits a FeeDisbursed event for multisig payment.\\n     *\\n     * @param _consignment - the consigned item\\n     * @param _grossSale - the gross sale amount\\n     * @param _netAmount - the net amount after royalties (total remaining to be distributed as part of payout process)\\n     *\\n     * @return payout - the payout amount for the seller\\n     */\\n    function deductFee(Consignment memory _consignment, uint256 _grossSale, uint256 _netAmount)\\n    internal\\n    returns (uint256 payout)\\n    {\\n        // Get the MarketController\\n        IMarketController marketController = getMarketController();\\n\\n        // With the net after royalties, calculate and split\\n        // the auction fee between SEEN staking and multisig,\\n        uint256 feeAmount;\\n        if(_consignment.customFeePercentageBasisPoints > 0) {\\n            feeAmount = getPercentageOf(_grossSale, _consignment.customFeePercentageBasisPoints);\\n        } else {\\n            feeAmount = getPercentageOf(_grossSale, marketController.getFeePercentage(_consignment.market));\\n        }\\n        require(feeAmount <= _netAmount, \\\"feeAmount exceeds remaining funds\\\");\\n        uint256 splitStaking = feeAmount / 2;\\n        uint256 splitMultisig = feeAmount - splitStaking;\\n        address payable staking = marketController.getStaking();\\n        address payable multisig = marketController.getMultisig();\\n        sendValueOrCreditAccount(staking, splitStaking);\\n        sendValueOrCreditAccount(multisig, splitMultisig);\\n\\n        // Return the seller payout amount after fee deduction\\n        payout = _netAmount - feeAmount;\\n\\n        // Notify listeners of payment\\n        emit FeeDisbursed(_consignment.id, staking, splitStaking);\\n        emit FeeDisbursed(_consignment.id, multisig, splitMultisig);\\n    }\\n\\n    /**\\n     * @notice Disburse funds for a sale or auction, primary or secondary.\\n     *\\n     * Disburses funds in this order\\n     * - Pays any necessary royalties first. See {deductRoyalties}\\n     * - Deducts and distributes marketplace fee. See {deductFee}\\n     * - Pays the remaining amount to the seller.\\n     *\\n     * Emits a PayoutDisbursed event on success.\\n     *\\n     * @param _consignmentId - the id of the consignment being sold\\n     * @param _saleAmount - the gross sale amount\\n     */\\n    function disburseFunds(uint256 _consignmentId, uint256 _saleAmount)\\n    internal\\n    {\\n        // Get the MarketController\\n        IMarketController marketController = getMarketController();\\n\\n        // Get consignment\\n        SeenTypes.Consignment memory consignment = marketController.getConsignment(_consignmentId);\\n\\n        // Pay royalties if needed\\n        uint256 netAfterRoyalties = deductRoyalties(consignment, _saleAmount);\\n\\n        // Pay escrow agent fees if needed\\n        uint256 netAfterEscrowAgentFees = deductEscrowAgentFee(consignment, _saleAmount, netAfterRoyalties);\\n\\n        // Pay marketplace fee\\n        uint256 payout = deductFee(consignment, _saleAmount, netAfterEscrowAgentFees);\\n\\n        // Pay seller\\n        sendValueOrCreditAccount(consignment.seller, payout);\\n\\n        // Notify listeners of payment\\n        emit PayoutDisbursed(_consignmentId, consignment.seller, payout);\\n    }\\n\\n    /**\\n     * @notice Attempts an ETH transfer, else adds a pull-able credit\\n     *\\n     * In cases where ETH is unable to be transferred to a particular address\\n     * either due to malicious agents or bugs in receiver addresses\\n     * the payout process should not fail for all parties involved \\n     * (or funds can become stuck for benevolent parties)\\n     *\\n     * @param _recipient - the recipient of the transfer\\n     * @param _value - the transfer value\\n     */\\n    function sendValueOrCreditAccount(address payable _recipient, uint256 _value)\\n    internal\\n    {\\n        // Attempt to send funds to recipient\\n        require(address(this).balance >= _value);\\n        (bool success, ) = _recipient.call{value: _value}(\\\"\\\");\\n        if(!success) {\\n            // Credit the account\\n            MarketHandlerLib.MarketHandlerStorage storage mhs = MarketHandlerLib.marketHandlerStorage();\\n            mhs.addressToEthCredit[_recipient] += _value;\\n            emit EthCredited(_recipient, _value);\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/domain/SeenTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SeenTypes\\n *\\n * @notice Enums and structs used by the Seen.Haus contract ecosystem.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SeenTypes {\\n\\n    enum Market {\\n        Primary,\\n        Secondary\\n    }\\n\\n    enum MarketHandler {\\n        Unhandled,\\n        Auction,\\n        Sale\\n    }\\n\\n    enum Clock {\\n        Live,\\n        Trigger\\n    }\\n\\n    enum Audience {\\n        Open,\\n        Staker,\\n        VipStaker\\n    }\\n\\n    enum Outcome {\\n        Pending,\\n        Closed,\\n        Canceled\\n    }\\n\\n    enum State {\\n        Pending,\\n        Running,\\n        Ended\\n    }\\n\\n    enum Ticketer {\\n        Default,\\n        Lots,\\n        Items\\n    }\\n\\n    struct Token {\\n        address payable creator;\\n        uint16 royaltyPercentage;\\n        bool isPhysical;\\n        uint256 id;\\n        uint256 supply;\\n        string uri;\\n    }\\n\\n    struct Consignment {\\n        Market market;\\n        MarketHandler marketHandler;\\n        address payable seller;\\n        address tokenAddress;\\n        uint256 tokenId;\\n        uint256 supply;\\n        uint256 id;\\n        bool multiToken;\\n        bool released;\\n        uint256 releasedSupply;\\n        uint16 customFeePercentageBasisPoints;\\n        uint256 pendingPayout;\\n    }\\n\\n    struct Auction {\\n        address payable buyer;\\n        uint256 consignmentId;\\n        uint256 start;\\n        uint256 duration;\\n        uint256 reserve;\\n        uint256 bid;\\n        Clock clock;\\n        State state;\\n        Outcome outcome;\\n    }\\n\\n    struct Sale {\\n        uint256 consignmentId;\\n        uint256 start;\\n        uint256 price;\\n        uint256 perTxCap;\\n        State state;\\n        Outcome outcome;\\n    }\\n\\n    struct EscrowTicket {\\n        uint256 amount;\\n        uint256 consignmentId;\\n        uint256 id;\\n        string itemURI;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMarketHandler.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IMarketHandler\\n *\\n * @notice Provides no functions, only common events to market handler facets.\\n *\\n * No ERC-165 identifier for this interface, not checked or supported.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketHandler {\\n\\n    // Events\\n    event RoyaltyDisbursed(uint256 indexed consignmentId, address indexed recipient, uint256 amount);\\n    event EscrowAgentFeeDisbursed(uint256 indexed consignmentId, address indexed recipient, uint256 amount);\\n    event FeeDisbursed(uint256 indexed consignmentId, address indexed recipient, uint256 amount);\\n    event PayoutDisbursed(uint256 indexed consignmentId, address indexed recipient, uint256 amount);\\n    event AudienceChanged(uint256 indexed consignmentId, SeenTypes.Audience indexed audience);\\n    event EthCredited(address indexed recipient, uint256 amount);\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISaleEnder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\nimport \\\"./IMarketHandler.sol\\\";\\n\\n/**\\n * @title ISaleEnder\\n *\\n * @notice Handles the finalization of Seen.Haus sales.\\n *\\n * The ERC-165 identifier for this interface is: 0x19b68d56\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface ISaleEnder is IMarketHandler {\\n\\n    // Events\\n    event SaleEnded(uint256 indexed consignmentId, SeenTypes.Outcome indexed outcome);\\n\\n    /**\\n     * @notice Close out a successfully completed sale.\\n     *\\n     * Funds are disbursed as normal. See: {MarketHandlerBase.disburseFunds}\\n     *\\n     * Reverts if:\\n     * - Sale doesn't exist or hasn't started\\n     * - There is remaining inventory\\n     *\\n     * Emits a SaleEnded event.\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     */\\n    function closeSale(uint256 _consignmentId) external;\\n\\n    /**\\n     * @notice Cancel a sale that has remaining inventory.\\n     *\\n     * Remaining tokens are returned to seller. If there have been any purchases,\\n     * the funds are distributed normally.\\n     *\\n     * Reverts if:\\n     * - Caller doesn't have ADMIN role\\n     * - Sale doesn't exist or has already been settled\\n     *\\n     * Emits a SaleEnded event\\n     *\\n     * @param _consignmentId - id of the consignment being sold\\n     */\\n    function cancelSale(uint256 _consignmentId) external;\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @title IERC2981 interface\\n *\\n * @notice NFT Royalty Standard.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2981\\n */\\ninterface IERC2981 is IERC165Upgradeable {\\n\\n    /**\\n     * @notice Determine how much royalty is owed (if any) and to whom.\\n     * @param _tokenId - the NFT asset queried for royalty information\\n     * @param _salePrice - the sale price of the NFT asset specified by _tokenId\\n     * @return receiver - address of who should be sent the royalty payment\\n     * @return royaltyAmount - the royalty payment amount for _salePrice\\n     */\\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\\n    external\\n    view\\n    returns (\\n        address receiver,\\n        uint256 royaltyAmount\\n    );\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMarketController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IMarketConfig.sol\\\";\\nimport \\\"./IMarketConfigAdditional.sol\\\";\\nimport \\\"./IMarketClerk.sol\\\";\\n\\n/**\\n * @title IMarketController\\n *\\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\\n *\\n * The ERC-165 identifier for this interface is: 0xbb8dba77\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketController is IMarketClerk, IMarketConfig, IMarketConfigAdditional {}\"\r\n    },\r\n    \"contracts/domain/SeenConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title SeenConstants\\n *\\n * @notice Constants used by the Seen.Haus contract ecosystem.\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ncontract SeenConstants {\\n\\n    // Endpoint will serve dynamic metadata composed of ticket and ticketed item's info\\n    string internal constant ESCROW_TICKET_URI = \\\"https://api.seen.haus/ticket/metadata/\\\";\\n\\n    // Access Control Roles\\n    bytes32 internal constant ADMIN = keccak256(\\\"ADMIN\\\");                   // Deployer and any other admins as needed\\n    bytes32 internal constant SELLER = keccak256(\\\"SELLER\\\");                 // Approved sellers amd Seen.Haus reps\\n    bytes32 internal constant MINTER = keccak256(\\\"MINTER\\\");                 // Approved artists and Seen.Haus reps\\n    bytes32 internal constant ESCROW_AGENT = keccak256(\\\"ESCROW_AGENT\\\");     // Seen.Haus Physical Item Escrow Agent\\n    bytes32 internal constant MARKET_HANDLER = keccak256(\\\"MARKET_HANDLER\\\"); // Market Handler contracts\\n    bytes32 internal constant UPGRADER = keccak256(\\\"UPGRADER\\\");             // Performs contract upgrades\\n    bytes32 internal constant MULTISIG = keccak256(\\\"MULTISIG\\\");             // Admin role of MARKET_HANDLER & UPGRADER\\n\\n}\"\r\n    },\r\n    \"contracts/market/handlers/MarketHandlerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/IMarketController.sol\\\";\\nimport \\\"../../domain/SeenTypes.sol\\\";\\nimport \\\"../diamond/DiamondLib.sol\\\";\\n\\n/**\\n * @title MarketHandlerLib\\n *\\n * @dev Provides access to the the MarketHandler Storage and Intitializer slots for MarketHandler facets\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary MarketHandlerLib {\\n\\n    bytes32 constant MARKET_HANDLER_STORAGE_POSITION = keccak256(\\\"seen.haus.market.handler.storage\\\");\\n    bytes32 constant MARKET_HANDLER_INITIALIZERS_POSITION = keccak256(\\\"seen.haus.market.handler.initializers\\\");\\n\\n    struct MarketHandlerStorage {\\n\\n        // map a consignment id to an audience\\n        mapping(uint256 => SeenTypes.Audience) audiences;\\n\\n        //s map a consignment id to a sale\\n        mapping(uint256 => SeenTypes.Sale) sales;\\n\\n        // @dev map a consignment id to an auction\\n        mapping(uint256 => SeenTypes.Auction) auctions;\\n\\n        // map an address to ETH credit available to withdraw\\n        mapping(address => uint256) addressToEthCredit;\\n\\n    }\\n\\n    struct MarketHandlerInitializers {\\n\\n        // AuctionBuilderFacet initialization state\\n        bool auctionBuilderFacet;\\n\\n        // AuctionRunnerFacet initialization state\\n        bool auctionRunnerFacet;\\n\\n        // AuctionEnderFacet initialization state\\n        bool auctionEnderFacet;\\n\\n        // SaleBuilderFacet initialization state\\n        bool saleBuilderFacet;\\n\\n        // SaleRunnerFacet initialization state\\n        bool saleRunnerFacet;\\n\\n        // SaleRunnerFacet initialization state\\n        bool saleEnderFacet;\\n\\n        // EthCreditFacet initialization state\\n        bool ethCreditRecoveryFacet;\\n\\n    }\\n\\n    function marketHandlerStorage() internal pure returns (MarketHandlerStorage storage mhs) {\\n        bytes32 position = MARKET_HANDLER_STORAGE_POSITION;\\n        assembly {\\n            mhs.slot := position\\n        }\\n    }\\n\\n    function marketHandlerInitializers() internal pure returns (MarketHandlerInitializers storage mhi) {\\n        bytes32 position = MARKET_HANDLER_INITIALIZERS_POSITION;\\n        assembly {\\n            mhi.slot := position\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMarketConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IMarketController\\n *\\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\\n * @dev Contributes its events and functions to the IMarketController interface\\n *\\n * The ERC-165 identifier for this interface is: 0x57f9f26d\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketConfig {\\n\\n    /// Events\\n    event NFTAddressChanged(address indexed nft);\\n    event EscrowTicketerAddressChanged(address indexed escrowTicketer, SeenTypes.Ticketer indexed ticketerType);\\n    event StakingAddressChanged(address indexed staking);\\n    event MultisigAddressChanged(address indexed multisig);\\n    event VipStakerAmountChanged(uint256 indexed vipStakerAmount);\\n    event PrimaryFeePercentageChanged(uint16 indexed feePercentage);\\n    event SecondaryFeePercentageChanged(uint16 indexed feePercentage);\\n    event MaxRoyaltyPercentageChanged(uint16 indexed maxRoyaltyPercentage);\\n    event OutBidPercentageChanged(uint16 indexed outBidPercentage);\\n    event DefaultTicketerTypeChanged(SeenTypes.Ticketer indexed ticketerType);\\n\\n    /**\\n     * @notice Sets the address of the xSEEN ERC-20 staking contract.\\n     *\\n     * Emits a NFTAddressChanged event.\\n     *\\n     * @param _nft - the address of the nft contract\\n     */\\n    function setNft(address _nft) external;\\n\\n    /**\\n     * @notice The nft getter\\n     */\\n    function getNft() external view returns (address);\\n\\n    /**\\n     * @notice Sets the address of the Seen.Haus lots-based escrow ticketer contract.\\n     *\\n     * Emits a EscrowTicketerAddressChanged event.\\n     *\\n     * @param _lotsTicketer - the address of the items-based escrow ticketer contract\\n     */\\n    function setLotsTicketer(address _lotsTicketer) external;\\n\\n    /**\\n     * @notice The lots-based escrow ticketer getter\\n     */\\n    function getLotsTicketer() external view returns (address);\\n\\n    /**\\n     * @notice Sets the address of the Seen.Haus items-based escrow ticketer contract.\\n     *\\n     * Emits a EscrowTicketerAddressChanged event.\\n     *\\n     * @param _itemsTicketer - the address of the items-based escrow ticketer contract\\n     */\\n    function setItemsTicketer(address _itemsTicketer) external;\\n\\n    /**\\n     * @notice The items-based escrow ticketer getter\\n     */\\n    function getItemsTicketer() external view returns (address);\\n\\n    /**\\n     * @notice Sets the address of the xSEEN ERC-20 staking contract.\\n     *\\n     * Emits a StakingAddressChanged event.\\n     *\\n     * @param _staking - the address of the staking contract\\n     */\\n    function setStaking(address payable _staking) external;\\n\\n    /**\\n     * @notice The staking getter\\n     */\\n    function getStaking() external view returns (address payable);\\n\\n    /**\\n     * @notice Sets the address of the Seen.Haus multi-sig wallet.\\n     *\\n     * Emits a MultisigAddressChanged event.\\n     *\\n     * @param _multisig - the address of the multi-sig wallet\\n     */\\n    function setMultisig(address payable _multisig) external;\\n\\n    /**\\n     * @notice The multisig getter\\n     */\\n    function getMultisig() external view returns (address payable);\\n\\n    /**\\n     * @notice Sets the VIP staker amount.\\n     *\\n     * Emits a VipStakerAmountChanged event.\\n     *\\n     * @param _vipStakerAmount - the minimum amount of xSEEN ERC-20 a caller must hold to participate in VIP events\\n     */\\n    function setVipStakerAmount(uint256 _vipStakerAmount) external;\\n\\n    /**\\n     * @notice The vipStakerAmount getter\\n     */\\n    function getVipStakerAmount() external view returns (uint256);\\n\\n    /**\\n     * @notice Sets the marketplace fee percentage.\\n     * Emits a PrimaryFeePercentageChanged event.\\n     *\\n     * @param _primaryFeePercentage - the percentage that will be taken as a fee from the net of a Seen.Haus primary sale or auction\\n     *\\n     * N.B. Represent percentage value as an unsigned int by multiplying the percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     */\\n    function setPrimaryFeePercentage(uint16 _primaryFeePercentage) external;\\n\\n    /**\\n     * @notice Sets the marketplace fee percentage.\\n     * Emits a SecondaryFeePercentageChanged event.\\n     *\\n     * @param _secondaryFeePercentage - the percentage that will be taken as a fee from the net of a Seen.Haus secondary sale or auction (after royalties)\\n     *\\n     * N.B. Represent percentage value as an unsigned int by multiplying the percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     */\\n    function setSecondaryFeePercentage(uint16 _secondaryFeePercentage) external;\\n\\n    /**\\n     * @notice The primaryFeePercentage and secondaryFeePercentage getter\\n     */\\n    function getFeePercentage(SeenTypes.Market _market) external view returns (uint16);\\n\\n    /**\\n     * @notice Sets the external marketplace maximum royalty percentage.\\n     *\\n     * Emits a MaxRoyaltyPercentageChanged event.\\n     *\\n     * @param _maxRoyaltyPercentage - the maximum percentage of a Seen.Haus sale or auction that will be paid as a royalty\\n     */\\n    function setMaxRoyaltyPercentage(uint16 _maxRoyaltyPercentage) external;\\n\\n    /**\\n     * @notice The maxRoyaltyPercentage getter\\n     */\\n    function getMaxRoyaltyPercentage() external view returns (uint16);\\n\\n    /**\\n     * @notice Sets the marketplace auction outbid percentage.\\n     *\\n     * Emits a OutBidPercentageChanged event.\\n     *\\n     * @param _outBidPercentage - the minimum percentage a Seen.Haus auction bid must be above the previous bid to prevail\\n     */\\n    function setOutBidPercentage(uint16 _outBidPercentage) external;\\n\\n    /**\\n     * @notice The outBidPercentage getter\\n     */\\n    function getOutBidPercentage() external view returns (uint16);\\n\\n    /**\\n     * @notice Sets the default escrow ticketer type.\\n     *\\n     * Emits a DefaultTicketerTypeChanged event.\\n     *\\n     * Reverts if _ticketerType is Ticketer.Default\\n     * Reverts if _ticketerType is already the defaultTicketerType\\n     *\\n     * @param _ticketerType - the new default escrow ticketer type.\\n     */\\n    function setDefaultTicketerType(SeenTypes.Ticketer _ticketerType) external;\\n\\n    /**\\n     * @notice The defaultTicketerType getter\\n     */\\n    function getDefaultTicketerType() external view returns (SeenTypes.Ticketer);\\n\\n    /**\\n     * @notice Get the Escrow Ticketer to be used for a given consignment\\n     *\\n     * If a specific ticketer has not been set for the consignment,\\n     * the default escrow ticketer will be returned.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return ticketer = the address of the escrow ticketer to use\\n     */\\n    function getEscrowTicketer(uint256 _consignmentId) external view returns (address ticketer);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMarketConfigAdditional.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IMarketController\\n *\\n * @notice Manages configuration and consignments used by the Seen.Haus contract suite.\\n * @dev Contributes its events and functions to the IMarketController interface\\n *\\n * The ERC-165 identifier for this interface is: 0x57f9f26d\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketConfigAdditional {\\n\\n    /// Events\\n    event AllowExternalTokensOnSecondaryChanged(bool indexed status);\\n    event EscrowAgentFeeChanged(address indexed escrowAgent, uint16 fee);\\n    \\n    /**\\n     * @notice Sets whether or not external tokens can be listed on secondary market\\n     *\\n     * Emits an AllowExternalTokensOnSecondaryChanged event.\\n     *\\n     * @param _status - boolean of whether or not external tokens are allowed\\n     */\\n    function setAllowExternalTokensOnSecondary(bool _status) external;\\n\\n    /**\\n     * @notice The allowExternalTokensOnSecondary getter\\n     */\\n    function getAllowExternalTokensOnSecondary() external view returns (bool status);\\n\\n        /**\\n     * @notice The escrow agent fee getter\\n     */\\n    function getEscrowAgentFeeBasisPoints(address _escrowAgentAddress) external view returns (uint16);\\n\\n    /**\\n     * @notice The escrow agent fee setter\\n     */\\n    function setEscrowAgentFeeBasisPoints(address _escrowAgentAddress, uint16 _basisPoints) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IMarketClerk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"../domain/SeenTypes.sol\\\";\\n\\n/**\\n * @title IMarketClerk\\n *\\n * @notice Manages consignments for the Seen.Haus contract suite.\\n *\\n * The ERC-165 identifier for this interface is: 0xec74481a\\n *\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\ninterface IMarketClerk is IERC1155ReceiverUpgradeable, IERC721ReceiverUpgradeable {\\n\\n    /// Events\\n    event ConsignmentTicketerChanged(uint256 indexed consignmentId, SeenTypes.Ticketer indexed ticketerType);\\n    event ConsignmentFeeChanged(uint256 indexed consignmentId, uint16 customConsignmentFee);\\n    event ConsignmentPendingPayoutSet(uint256 indexed consignmentId, uint256 amount);\\n    event ConsignmentRegistered(address indexed consignor, address indexed seller, SeenTypes.Consignment consignment);\\n    event ConsignmentMarketed(address indexed consignor, address indexed seller, uint256 indexed consignmentId);\\n    event ConsignmentReleased(uint256 indexed consignmentId, uint256 amount, address releasedTo);\\n\\n    /**\\n     * @notice The nextConsignment getter\\n     */\\n    function getNextConsignment() external view returns (uint256);\\n\\n    /**\\n     * @notice The consignment getter\\n     */\\n    function getConsignment(uint256 _consignmentId) external view returns (SeenTypes.Consignment memory);\\n\\n    /**\\n     * @notice Get the remaining supply of the given consignment.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return uint256 - the remaining supply held by the MarketController\\n     */\\n    function getUnreleasedSupply(uint256 _consignmentId) external view returns(uint256);\\n\\n    /**\\n     * @notice Get the consignor of the given consignment\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @return  address - consigner's address\\n     */\\n    function getConsignor(uint256 _consignmentId) external view returns(address);\\n\\n    /**\\n     * @notice Registers a new consignment for sale or auction.\\n     *\\n     * Emits a ConsignmentRegistered event.\\n     *\\n     * @param _market - the market for the consignment. See {SeenTypes.Market}\\n     * @param _consignor - the address executing the consignment transaction\\n     * @param _seller - the seller of the consignment\\n     * @param _tokenAddress - the contract address issuing the NFT behind the consignment\\n     * @param _tokenId - the id of the token being consigned\\n     * @param _supply - the amount of the token being consigned\\n     *\\n     * @return Consignment - the registered consignment\\n     */\\n    function registerConsignment(\\n        SeenTypes.Market _market,\\n        address _consignor,\\n        address payable _seller,\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _supply\\n    )\\n    external\\n    returns(SeenTypes.Consignment memory);\\n\\n    /**\\n      * @notice Update consignment to indicate it has been marketed\\n      *\\n      * Emits a ConsignmentMarketed event.\\n      *\\n      * Reverts if consignment has already been marketed.\\n      * A consignment is considered as marketed if it has a marketHandler other than Unhandled. See: {SeenTypes.MarketHandler}\\n      *\\n      * @param _consignmentId - the id of the consignment\\n      */\\n    function marketConsignment(uint256 _consignmentId, SeenTypes.MarketHandler _marketHandler) external;\\n\\n    /**\\n     * @notice Release the consigned item to a given address\\n     *\\n     * Emits a ConsignmentReleased event.\\n     *\\n     * Reverts if caller is does not have MARKET_HANDLER role.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of the consigned supply to release\\n     * @param _releaseTo - the address to transfer the consigned token balance to\\n     */\\n    function releaseConsignment(uint256 _consignmentId, uint256 _amount, address _releaseTo) external;\\n\\n    /**\\n     * @notice Clears the pending payout value of a consignment\\n     *\\n     * Emits a ConsignmentPayoutSet event.\\n     *\\n     * Reverts if:\\n     *  - caller is does not have MARKET_HANDLER role.\\n     *  - consignment doesn't exist\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _amount - the amount of that the consignment's pendingPayout must be set to\\n     */\\n    function setConsignmentPendingPayout(uint256 _consignmentId, uint256 _amount) external;\\n\\n    /**\\n     * @notice Set the type of Escrow Ticketer to be used for a consignment\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentTicketerSet event.\\n     * Reverts if consignment is not registered.\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _ticketerType - the type of ticketer to use. See: {SeenTypes.Ticketer}\\n     */\\n    function setConsignmentTicketer(uint256 _consignmentId, SeenTypes.Ticketer _ticketerType) external;\\n\\n    /**\\n     * @notice Set a custom fee percentage on a consignment (e.g. for \\\"official\\\" SEEN x Artist drops)\\n     *\\n     * Default escrow ticketer is Ticketer.Lots. This only needs to be called\\n     * if overriding to Ticketer.Items for a given consignment.\\n     *\\n     * Emits a ConsignmentFeeChanged event.\\n     *\\n     * Reverts if consignment doesn't exist     *\\n     *\\n     * @param _consignmentId - the id of the consignment\\n     * @param _customFeePercentageBasisPoints - the custom fee percentage basis points to use\\n     *\\n     * N.B. _customFeePercentageBasisPoints percentage value as an unsigned int by multiplying the percentage by 100:\\n     * e.g, 1.75% = 175, 100% = 10000\\n     */\\n    function setConsignmentCustomFee(uint256 _consignmentId, uint16 _customFeePercentageBasisPoints) external;\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/market/diamond/DiamondLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IAccessControlUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\\\";\\nimport { IDiamondCut } from \\\"../../interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title DiamondLib\\n *\\n * @notice Diamond storage slot and supported interfaces\\n *\\n * @notice Based on Nick Mudge's gas-optimized diamond-2 reference,\\n * with modifications to support role-based access and management of\\n * supported interfaces.\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * N.B. Facet management functions from original `DiamondLib` were refactor/extracted\\n * to JewelerLib, since business facets also use this library for access control and\\n * managing supported interfaces.\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n * @author Cliff Hall <cliff@futurescale.com> (https://twitter.com/seaofarrows)\\n */\\nlibrary DiamondLib {\\n\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct DiamondStorage {\\n\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n\\n        // The Seen.Haus AccessController\\n        IAccessControlUpgradeable accessController;\\n\\n    }\\n\\n    /**\\n     * @notice Get the Diamond storage slot\\n     *\\n     * @return ds - Diamond storage slot cast to DiamondStorage\\n     */\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @notice Add a supported interface to the Diamond\\n     *\\n     * @param _interfaceId - the interface to add\\n     */\\n    function addSupportedInterface(bytes4 _interfaceId) internal {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Flag the interfaces as supported\\n        ds.supportedInterfaces[_interfaceId] = true;\\n    }\\n\\n    /**\\n     * @notice Implementation of ERC-165 interface detection standard.\\n     *\\n     * @param _interfaceId - the sighash of the given interface\\n     */\\n    function supportsInterface(bytes4 _interfaceId) internal view returns (bool) {\\n\\n        // Get the DiamondStorage struct\\n        DiamondStorage storage ds = diamondStorage();\\n\\n        // Return the value\\n        return ds.supportedInterfaces[_interfaceId] || false;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControlUpgradeable {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title IDiamondCut\\n *\\n * @notice Diamond Facet management\\n *\\n * Reference Implementation  : https://github.com/mudgen/diamond-2-hardhat\\n * EIP-2535 Diamond Standard : https://eips.ethereum.org/EIPS/eip-2535\\n *\\n * The ERC-165 identifier for this interface is: 0x1f931c1c\\n *\\n * @author Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n */\\ninterface IDiamondCut {\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    enum FacetCutAction {Add, Replace, Remove}\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and\\n     * optionally execute a function with delegatecall\\n     *\\n     * _calldata is executed with delegatecall on _init\\n     *\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata\\n     * @param _calldata A function call, including function selector and arguments\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"enum SeenTypes.Audience\",\"name\":\"audience\",\"type\":\"uint8\"}],\"name\":\"AudienceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EscrowAgentFeeDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EthCredited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FeeDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayoutDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RoyaltyDisbursed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consignor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perTxCap\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum SeenTypes.Outcome\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"indexed\":false,\"internalType\":\"struct SeenTypes.Sale\",\"name\":\"sale\",\"type\":\"tuple\"}],\"name\":\"SalePending\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perTxCap\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.Audience\",\"name\":\"_audience\",\"type\":\"uint8\"}],\"name\":\"createPrimarySale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_perTxCap\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.Audience\",\"name\":\"_audience\",\"type\":\"uint8\"}],\"name\":\"createSecondarySale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_consignmentId\",\"type\":\"uint256\"}],\"name\":\"getSale\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"consignmentId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"perTxCap\",\"type\":\"uint256\"},{\"internalType\":\"enum SeenTypes.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"enum SeenTypes.Outcome\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"internalType\":\"struct SeenTypes.Sale\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SaleBuilderFacet", "CompilerVersion": "v0.8.2+commit.661d1103", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}