{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface AggregatorV3Interface {\r\n    function decimals() external view returns (uint8);\r\n    function description() external view returns (string memory);\r\n    function version() external view returns (uint256);\r\n    function getRoundData(uint80 _roundId) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n    function latestRoundData() external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\r\n}\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface IERC721 is IERC165 {\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n    function approve(address to, uint256 tokenId) external;\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\r\n}\r\n\r\ninterface IERC721Metadata is IERC721 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function tokenURI(uint256 tokenId) external view returns (string memory);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            if (returndata.length > 0) {\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\nabstract contract AC {\r\n    address internal owner;\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n    }\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender), \"!OWNER\");\r\n        _;\r\n    }\r\n    function isOwner(address account) public view returns (bool) {\r\n        return account == owner;\r\n    }\r\n    function transferOwnership(address payable adr) public onlyOwner {\r\n        owner = adr;\r\n        emit OwnershipTransferred(adr);\r\n    }\r\n    event OwnershipTransferred(address owner);\r\n}\r\n\r\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata, AC {\r\n    using Address for address;\r\n    using Strings for uint256;\r\n\r\n    string private _name;\r\n\r\n    string private _symbol;\r\n\r\n    string private _base = \"https://cdn.theannuity.io/\";\r\n\r\n    mapping(uint256 => address) internal _owners;\r\n\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    mapping(uint256 => address) private _tokenApprovals;\r\n\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    constructor(string memory name_, string memory symbol_, address _owner) AC(_owner) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\r\n        return interfaceId == type(IERC721).interfaceId || interfaceId == type(IERC721Metadata).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOf(address owner) public view virtual override returns (uint256) {\r\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\r\n        return _balances[owner];\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\r\n        address owner = _owners[tokenId];\r\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\r\n        return owner;\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\r\n        string memory baseURI = _baseURI();\r\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\r\n    }\r\n\r\n    function _baseURI() internal view virtual returns (string memory) {\r\n        return _base;\r\n    }\r\n\r\n    function changeBaseURI(string memory _baseNew) external onlyOwner {\r\n        _base = _baseNew;\r\n    }\r\n\r\n    function approve(address to, uint256 tokenId) public virtual override {\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        require(to != owner, \"ERC721: approval to current owner\");\r\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \"ERC721: approve caller is not owner nor approved for all\");\r\n        _approve(to, tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\r\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\r\n        return _tokenApprovals[tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[owner][operator];\r\n    }\r\n\r\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\r\n        return _owners[tokenId] != address(0);\r\n    }\r\n\r\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\r\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\r\n        address owner = ERC721.ownerOf(tokenId);\r\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId) internal virtual {\r\n        _safeMint(to, tokenId, \"\");\r\n    }\r\n\r\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\r\n        _mint(to, tokenId);\r\n        require(_checkOnERC721Received(address(0), to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\r\n    }\r\n\r\n    function _mint(address to, uint256 tokenId) internal virtual {\r\n        require(to != address(0), \"ERC721: mint to the zero address\");\r\n        require(!_exists(tokenId), \"ERC721: token already minted\");\r\n        _balances[to] += 1;\r\n        _owners[tokenId] = to;\r\n    }\r\n\r\n    function _approve(address to, uint256 tokenId) internal virtual {\r\n        _tokenApprovals[tokenId] = to;\r\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\r\n    }\r\n\r\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\r\n        require(owner != operator, \"ERC721: approve to caller\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) internal returns (bool) {\r\n        if (to.isContract()) {\r\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\r\n                return retval == IERC721Receiver.onERC721Received.selector;\r\n            } catch (bytes memory reason) {\r\n                if (reason.length == 0) {\r\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\r\n                } else {\r\n                    assembly {\r\n                        revert(add(32, reason), mload(reason))\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Counters {\r\n    struct Counter {\r\n        uint256 _value;\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\nabstract contract ERC721URIStorage is ERC721 {\r\n    using Strings for uint256;\r\n    mapping(uint256 => string) private _tokenURIs;\r\n\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\r\n        string memory _tokenURI = _tokenURIs[tokenId];\r\n        string memory base = _baseURI();\r\n        if (bytes(base).length == 0) {\r\n            return _tokenURI;\r\n        }\r\n        if (bytes(_tokenURI).length > 0) {\r\n            return string(abi.encodePacked(base, _tokenURI));\r\n        }\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\r\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\r\n        _tokenURIs[tokenId] = _tokenURI;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            uint256 c = a + b;\r\n            if (c < a) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b > a) return (false, 0);\r\n            return (true, a - b);\r\n        }\r\n    }\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (a == 0) return (true, 0);\r\n            uint256 c = a * b;\r\n            if (c / a != b) return (false, 0);\r\n            return (true, c);\r\n        }\r\n    }\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a % b);\r\n        }\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a * b;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a % b;\r\n    }\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b <= a, errorMessage);\r\n            return a - b;\r\n        }\r\n    }\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a / b;\r\n        }\r\n    }\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        unchecked {\r\n            require(b > 0, errorMessage);\r\n            return a % b;\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(uint256 amountIn, uint256 amountOutMin, address[] calldata path, address to, uint256 deadline) external;\r\n}\r\n\r\ninterface INetwork {\r\n    function setShare(address shareholder, uint256 amount) external;\r\n    function deposit() external payable;\r\n}\r\n\r\ncontract Network1 is INetwork, AC {\r\n    using SafeMath for uint256;\r\n    uint256 internal constant max = 2**256 - 1;\r\n    address _token;\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    IERC20 BASE;\r\n    IUniswapV2Router router;\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) public totalRewardsDistributed;\r\n    mapping (address => mapping (address => uint256)) public totalRewardsToUser;\r\n    mapping (address => bool) public allowed;\r\n    mapping (address => Share) public shares;\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor (address _router, address _owner, address _weth) AC(_owner) {\r\n        router = _router != address(0) ? IUniswapV2Router(_router) : IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _token = msg.sender;\r\n        allowed[_weth] = true;\r\n        BASE = IERC20(_weth);\r\n        BASE.approve(_router, max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getClaimedDividendsTotal(address token) public view returns (uint256) {\r\n        return totalRewardsDistributed[token];\r\n    }\r\n\r\n    function getClaimedDividends(address token, address user) public view returns (uint256) {\r\n        return totalRewardsToUser[token][user];\r\n    }\r\n\r\n    function changeRouterVersion(address _router) external onlyOwner {\r\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(_router);\r\n        router = _uniswapV2Router;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if (amount > 0 && shares[shareholder].amount == 0) addShareholder(shareholder);\r\n        else if (amount == 0 && shares[shareholder].amount > 0) removeShareholder(shareholder);\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 amount = msg.value;\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeDividend(address shareholder, address rewardAddress) internal {\r\n        require(allowed[rewardAddress], \"Invalid reward address!\");\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n        uint256 amount = getPendingDividend(shareholder);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n            if (rewardAddress == address(BASE)) {\r\n                payable(shareholder).transfer(amount);\r\n                totalRewardsDistributed[rewardAddress] = totalRewardsDistributed[rewardAddress].add(amount);  \r\n                totalRewardsToUser[rewardAddress][shareholder] = totalRewardsToUser[rewardAddress][shareholder].add(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimDividend(address claimer, address rewardAddress) external onlyToken {\r\n        distributeDividend(claimer, rewardAddress);\r\n    }\r\n\r\n    function getPendingDividend(address shareholder) public view returns (uint256) {\r\n        if (shares[shareholder].amount == 0) return 0;\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\r\n        shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function changeBASE(address _BASE) external onlyOwner {\r\n        BASE = IERC20(_BASE);\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _address, address _to) external onlyOwner {\r\n        IERC20(_address).transfer(_to, IERC20(_address).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract Network2 is INetwork, AC {\r\n    using SafeMath for uint256;\r\n    uint256 internal constant max = 2**256 - 1;\r\n    address _token;\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    IERC20 BASE;\r\n    IUniswapV2Router router;\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) public totalRewardsDistributed;\r\n    mapping (address => mapping (address => uint256)) public totalRewardsToUser;\r\n    mapping (address => bool) public allowed;\r\n    mapping (address => Share) public shares;\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor (address _router, address _owner, address _weth) AC(_owner) {\r\n        router = _router != address(0) ? IUniswapV2Router(_router) : IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _token = msg.sender;\r\n        allowed[_weth] = true;\r\n        BASE = IERC20(_weth);\r\n        BASE.approve(_router, max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getClaimedDividendsTotal(address token) public view returns (uint256) {\r\n        return totalRewardsDistributed[token];\r\n    }\r\n\r\n    function getClaimedDividends(address token, address user) public view returns (uint256) {\r\n        return totalRewardsToUser[token][user];\r\n    }\r\n\r\n    function changeRouterVersion(address _router) external onlyOwner {\r\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(_router);\r\n        router = _uniswapV2Router;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if (amount > 0 && shares[shareholder].amount == 0) addShareholder(shareholder);\r\n        else if (amount == 0 && shares[shareholder].amount > 0) removeShareholder(shareholder);\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 amount = msg.value;\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeDividend(address shareholder, address rewardAddress) internal {\r\n        require(allowed[rewardAddress], \"Invalid reward address!\");\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n        uint256 amount = getPendingDividend(shareholder);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n            if (rewardAddress == address(BASE)) {\r\n                payable(shareholder).transfer(amount);\r\n                totalRewardsDistributed[rewardAddress] = totalRewardsDistributed[rewardAddress].add(amount);  \r\n                totalRewardsToUser[rewardAddress][shareholder] = totalRewardsToUser[rewardAddress][shareholder].add(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimDividend(address claimer, address rewardAddress) external onlyToken {\r\n        distributeDividend(claimer, rewardAddress);\r\n    }\r\n\r\n    function getPendingDividend(address shareholder) public view returns (uint256) {\r\n        if (shares[shareholder].amount == 0) return 0;\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\r\n        shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function changeBASE(address _BASE) external onlyOwner {\r\n        BASE = IERC20(_BASE);\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _address, address _to) external onlyOwner {\r\n        IERC20(_address).transfer(_to, IERC20(_address).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract Network3 is INetwork, AC {\r\n    using SafeMath for uint256;\r\n    uint256 internal constant max = 2**256 - 1;\r\n    address _token;\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    IERC20 BASE;\r\n    IUniswapV2Router router;\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) public totalRewardsDistributed;\r\n    mapping (address => mapping (address => uint256)) public totalRewardsToUser;\r\n    mapping (address => bool) public allowed;\r\n    mapping (address => Share) public shares;\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor (address _router, address _owner, address _weth) AC(_owner) {\r\n        router = _router != address(0) ? IUniswapV2Router(_router) : IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _token = msg.sender;\r\n        allowed[_weth] = true;\r\n        BASE = IERC20(_weth);\r\n        BASE.approve(_router, max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getClaimedDividendsTotal(address token) public view returns (uint256) {\r\n        return totalRewardsDistributed[token];\r\n    }\r\n\r\n    function getClaimedDividends(address token, address user) public view returns (uint256) {\r\n        return totalRewardsToUser[token][user];\r\n    }\r\n\r\n    function changeRouterVersion(address _router) external onlyOwner {\r\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(_router);\r\n        router = _uniswapV2Router;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if (amount > 0 && shares[shareholder].amount == 0) addShareholder(shareholder);\r\n        else if (amount == 0 && shares[shareholder].amount > 0) removeShareholder(shareholder);\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 amount = msg.value;\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeDividend(address shareholder, address rewardAddress) internal {\r\n        require(allowed[rewardAddress], \"Invalid reward address!\");\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n        uint256 amount = getPendingDividend(shareholder);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n            if (rewardAddress == address(BASE)) {\r\n                payable(shareholder).transfer(amount);\r\n                totalRewardsDistributed[rewardAddress] = totalRewardsDistributed[rewardAddress].add(amount);  \r\n                totalRewardsToUser[rewardAddress][shareholder] = totalRewardsToUser[rewardAddress][shareholder].add(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimDividend(address claimer, address rewardAddress) external onlyToken {\r\n        distributeDividend(claimer, rewardAddress);\r\n    }\r\n\r\n    function getPendingDividend(address shareholder) public view returns (uint256) {\r\n        if (shares[shareholder].amount == 0) return 0;\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\r\n        shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function changeBASE(address _BASE) external onlyOwner {\r\n        BASE = IERC20(_BASE);\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _address, address _to) external onlyOwner {\r\n        IERC20(_address).transfer(_to, IERC20(_address).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\ncontract Network4 is INetwork, AC {\r\n    using SafeMath for uint256;\r\n    uint256 internal constant max = 2**256 - 1;\r\n    address _token;\r\n    struct Share {\r\n        uint256 amount;\r\n        uint256 totalExcluded;\r\n        uint256 totalRealised;\r\n    }\r\n    IERC20 BASE;\r\n    IUniswapV2Router router;\r\n    address[] shareholders;\r\n    mapping (address => uint256) shareholderIndexes;\r\n    mapping (address => uint256) public totalRewardsDistributed;\r\n    mapping (address => mapping (address => uint256)) public totalRewardsToUser;\r\n    mapping (address => bool) public allowed;\r\n    mapping (address => Share) public shares;\r\n    uint256 public totalShares;\r\n    uint256 public totalDividends;\r\n    uint256 public totalDistributed;\r\n    uint256 public dividendsPerShare;\r\n    uint256 public dividendsPerShareAccuracyFactor = 10 ** 36;\r\n\r\n    modifier onlyToken() {\r\n        require(msg.sender == _token);\r\n        _;\r\n    }\r\n\r\n    constructor (address _router, address _owner, address _weth) AC(_owner) {\r\n        router = _router != address(0) ? IUniswapV2Router(_router) : IUniswapV2Router(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\r\n        _token = msg.sender;\r\n        allowed[_weth] = true;\r\n        BASE = IERC20(_weth);\r\n        BASE.approve(_router, max);\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    function getClaimedDividendsTotal(address token) public view returns (uint256) {\r\n        return totalRewardsDistributed[token];\r\n    }\r\n\r\n    function getClaimedDividends(address token, address user) public view returns (uint256) {\r\n        return totalRewardsToUser[token][user];\r\n    }\r\n\r\n    function changeRouterVersion(address _router) external onlyOwner {\r\n        IUniswapV2Router _uniswapV2Router = IUniswapV2Router(_router);\r\n        router = _uniswapV2Router;\r\n    }\r\n\r\n    function setShare(address shareholder, uint256 amount) external override onlyToken {\r\n        if (amount > 0 && shares[shareholder].amount == 0) addShareholder(shareholder);\r\n        else if (amount == 0 && shares[shareholder].amount > 0) removeShareholder(shareholder);\r\n        totalShares = totalShares.sub(shares[shareholder].amount).add(amount);\r\n        shares[shareholder].amount = amount;\r\n        shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n    }\r\n\r\n    function deposit() external payable override onlyToken {\r\n        uint256 amount = msg.value;\r\n        totalDividends = totalDividends.add(amount);\r\n        dividendsPerShare = dividendsPerShare.add(dividendsPerShareAccuracyFactor.mul(amount).div(totalShares));\r\n    }\r\n\r\n    function distributeDividend(address shareholder, address rewardAddress) internal {\r\n        require(allowed[rewardAddress], \"Invalid reward address!\");\r\n        if (shares[shareholder].amount == 0) {\r\n            return;\r\n        }\r\n        uint256 amount = getPendingDividend(shareholder);\r\n        if (amount > 0) {\r\n            totalDistributed = totalDistributed.add(amount);\r\n            shares[shareholder].totalRealised = shares[shareholder].totalRealised.add(amount);\r\n            shares[shareholder].totalExcluded = getCumulativeDividends(shares[shareholder].amount);\r\n            if (rewardAddress == address(BASE)) {\r\n                payable(shareholder).transfer(amount);\r\n                totalRewardsDistributed[rewardAddress] = totalRewardsDistributed[rewardAddress].add(amount);  \r\n                totalRewardsToUser[rewardAddress][shareholder] = totalRewardsToUser[rewardAddress][shareholder].add(amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function claimDividend(address claimer, address rewardAddress) external onlyToken {\r\n        distributeDividend(claimer, rewardAddress);\r\n    }\r\n\r\n    function getPendingDividend(address shareholder) public view returns (uint256) {\r\n        if (shares[shareholder].amount == 0) return 0;\r\n        uint256 shareholderTotalDividends = getCumulativeDividends(shares[shareholder].amount);\r\n        uint256 shareholderTotalExcluded = shares[shareholder].totalExcluded;\r\n        if (shareholderTotalDividends <= shareholderTotalExcluded) return 0;\r\n        return shareholderTotalDividends.sub(shareholderTotalExcluded);\r\n    }\r\n\r\n    function getCumulativeDividends(uint256 share) internal view returns (uint256) {\r\n        return share.mul(dividendsPerShare).div(dividendsPerShareAccuracyFactor);\r\n    }\r\n\r\n    function addShareholder(address shareholder) internal {\r\n        shareholderIndexes[shareholder] = shareholders.length;\r\n        shareholders.push(shareholder);\r\n    }\r\n\r\n    function removeShareholder(address shareholder) internal {\r\n        shareholders[shareholderIndexes[shareholder]] = shareholders[shareholders.length - 1];\r\n        shareholderIndexes[shareholders[shareholders.length - 1]] = shareholderIndexes[shareholder];\r\n        shareholders.pop();\r\n    }\r\n\r\n    function changeBASE(address _BASE) external onlyOwner {\r\n        BASE = IERC20(_BASE);\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _address, address _to) external onlyOwner {\r\n        IERC20(_address).transfer(_to, IERC20(_address).balanceOf(address(this)));\r\n    }\r\n}\r\n\r\nabstract contract ReentrancyGuard {\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n    uint256 private _status;\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n    modifier nonReentrant() {\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n        _status = _ENTERED;\r\n        _;\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\ncontract MicroValidator is AC, ERC721URIStorage, ReentrancyGuard {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private _tokenIds;\r\n    address public microvAddress;\r\n    IERC20 microv;\r\n    Network1 private _network1;\r\n    address public network1Address;\r\n    Network2 private _network2;\r\n    address public network2Address;\r\n    Network3 private _network3;\r\n    address public network3Address;\r\n    Network4 private _network4;\r\n    address public network4Address;\r\n    address public renewals = 0xa1ed930901534A5eecCC37fE131362e3054c4a82;\r\n    address public claims = 0xa1ed930901534A5eecCC37fE131362e3054c4a82;\r\n    address public rewards = 0x000000000000000000000000000000000000dEaD;\r\n    address public liquidity = 0x4D939977da7D0d0C3239dd0415F13a35cC1664b4;\r\n    address public reserves = 0xa1ed930901534A5eecCC37fE131362e3054c4a82;\r\n    address public partnerships = 0xFf20C9736ac252014800782692d867B4C70656d1;\r\n    address public dead = 0x000000000000000000000000000000000000dEaD;\r\n    uint256 public rate0 = 700000000000;\r\n    uint256[20] public rates0 = [700000000000, 595000000000, 505750000000, 429887500000, 365404375000, 310593718750, 264004660937, 224403961797, 190743367527, 162131862398, 137812083039, 117140270583, 99569229995, 84633845496, 71938768672, 61147953371, 51975760365, 44179396311, 37552486864, 31919613834];\r\n    uint256 public amount1 = 21759840000000000000;\r\n    uint256 public amount2 = 135999000000000000000;\r\n    uint256 public amount3 = 326397600000000000000;\r\n    uint256 public amount4 = 658017561600000000000;\r\n    uint256 public seconds1 = 31536000;\r\n    uint256 public seconds2 = 94608000;\r\n    uint256 public seconds3 = 157680000;\r\n    uint256 public seconds4 = 504576000;\r\n    uint256 public gracePeriod = 2628000;\r\n    uint256 public gammaPeriod = 5443200;\r\n    uint256 public quarter = 7884000;\r\n    uint256 public month = 2628000;\r\n    uint256 public maxValidatorsPerMinter = 100;\r\n    address public weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    struct Validator {\r\n        uint256 id;\r\n        address minter;\r\n        uint256 created;\r\n        uint256 lastClaimMicrov;\r\n        uint256 lastClaimEth;\r\n        uint256 numClaimsMicrov;\r\n        uint256 renewalExpiry;\r\n        uint8 fuseProduct;\r\n        uint256 fuseCreated;\r\n        uint256 fuseUnlocks;\r\n        bool fuseUnlocked;\r\n    }\r\n    mapping (uint256 => Validator) public validators;\r\n    mapping (address => Validator[]) public validatorsByMinter;\r\n    mapping (address => uint256) public numValidatorsByMinter;\r\n    mapping (uint256 => uint256) public positions;\r\n    AggregatorV3Interface internal priceFeed = AggregatorV3Interface(0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\r\n    uint256 public renewalFee = 1000 * 1000000;\r\n    uint256 public claimMicrovFee = 6900 * 1000000;\r\n    uint256 public claimEthFee = 639 * 1000000;\r\n    uint256 public mintPrice = 10 * (10 ** 18);\r\n    uint256 public rewardsFee = 6 * (10 ** 18);\r\n    uint256 public liquidityFee = 10 ** 18;\r\n    uint256 public reservesFee = 10 ** 18;\r\n    uint256 public partnershipsFee = 10 ** 18;\r\n    uint256 public deadFee = 10 ** 18;\r\n\r\n    constructor(string memory _name, string memory _symbol, address _microvAddress, address _owner, address _priceFeed, address _weth) ERC721(_name, _symbol, _owner) {\r\n        rewards = address(this);\r\n        microvAddress = _microvAddress;\r\n        microv = IERC20(microvAddress);\r\n        address _router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        _network1 = new Network1(_router, _owner, _weth);\r\n        network1Address = address(_network1);\r\n        _network2 = new Network2(_router, _owner, _weth);\r\n        network2Address = address(_network2);\r\n        _network3 = new Network3(_router, _owner, _weth);\r\n        network3Address = address(_network3);\r\n        _network4 = new Network4(_router, _owner, _weth);\r\n        network4Address = address(_network4);\r\n        priceFeed = AggregatorV3Interface(_priceFeed);\r\n        weth = _weth;\r\n    }\r\n\r\n    function createToken(uint256 _months) external payable nonReentrant returns (uint) {\r\n        require(numValidatorsByMinter[msg.sender] < maxValidatorsPerMinter, \"Too many validators\");\r\n        require(_months < 193, \"Too many months\");\r\n        require(msg.value == getRenewalCost(_months), \"Invalid value\");\r\n        require(microv.allowance(msg.sender, address(this)) > mintPrice, \"Insufficient allowance\");\r\n        require(microv.balanceOf(msg.sender) > mintPrice, \"Insufficient balance\");\r\n        bool _success = microv.transferFrom(msg.sender, address(this), mintPrice);\r\n        require(_success, \"Transfer unsuccessful\");\r\n        payable(renewals).transfer(msg.value);\r\n        microv.transfer(rewards, rewardsFee);\r\n        microv.transfer(liquidity, liquidityFee);\r\n        microv.transfer(reserves, reservesFee);\r\n        microv.transfer(partnerships, partnershipsFee);\r\n        microv.transfer(dead, deadFee);\r\n        uint256 _newItemId = _tokenIds.current();\r\n        _tokenIds.increment();\r\n        _mint(msg.sender, _newItemId);\r\n        _setTokenURI(_newItemId, string(abi.encodePacked(_newItemId, \".json\")));\r\n        Validator memory _validator = Validator(_newItemId, msg.sender, block.timestamp, 0, 0, 0, block.timestamp + (2628000 * _months), 0, 0, 0, false);\r\n        validators[_newItemId] = _validator;\r\n        validatorsByMinter[msg.sender].push(_validator);\r\n        positions[_newItemId] = numValidatorsByMinter[msg.sender];\r\n        numValidatorsByMinter[msg.sender]++;\r\n        return _newItemId;\r\n    }\r\n\r\n    function fuseToken(uint256 _id, uint8 _tier) external nonReentrant {\r\n        require(ownerOf(_id) == msg.sender, \"Invalid ownership\");\r\n        require(_tier == 1 || _tier == 2 || _tier == 3 || _tier == 4, \"Invalid product\");\r\n        Validator memory _validator = validators[_id];\r\n        require(_validator.fuseProduct == 0 || _validator.fuseUnlocked, \"Already fused\");\r\n        require(_validator.renewalExpiry > block.timestamp, \"Expired\");\r\n        uint256 _seconds = seconds1;\r\n        uint256 _balance = 0;\r\n        uint256 _matches = numValidatorsByMinter[msg.sender];\r\n        Validator[] memory _array = validatorsByMinter[msg.sender];\r\n        for (uint256 _i = 0; _i < _matches; _i++) {\r\n            Validator memory _v = _array[_i];\r\n            if (_v.fuseProduct == _tier && !_v.fuseUnlocked && _v.renewalExpiry > block.timestamp && _v.fuseUnlocks < block.timestamp) _balance++;\r\n        }\r\n        if (_tier == 1) {\r\n            try _network1.setShare(msg.sender, _balance + 1) {} catch {}\r\n        } else if (_tier == 2) {\r\n            try _network2.setShare(msg.sender, _balance + 1) {} catch {}\r\n            _seconds = seconds2;\r\n        } else if (_tier == 3) {\r\n            try _network3.setShare(msg.sender, _balance + 1) {} catch {}\r\n            _seconds = seconds3;\r\n        } else if (_tier == 4) {\r\n            try _network4.setShare(msg.sender, _balance + 1) {} catch {}\r\n            _seconds = seconds4;\r\n        }\r\n        Validator memory _validatorNew = Validator(_id, _validator.minter, _validator.created, _validator.lastClaimMicrov, 0, _validator.numClaimsMicrov, _validator.renewalExpiry, _tier, block.timestamp, block.timestamp + _seconds, false);\r\n        validators[_id] = _validatorNew;\r\n        validatorsByMinter[msg.sender][positions[_id]] = _validatorNew;\r\n    }\r\n\r\n    function renewToken(uint256 _id, uint256 _months) external payable nonReentrant {\r\n        require(ownerOf(_id) == msg.sender, \"Invalid ownership\");\r\n        require(_months < 193, \"Too many months\");\r\n        uint256 _boost = 2628000 * _months;\r\n        require(msg.value == getRenewalCost(_months), \"Invalid value\");\r\n        Validator memory _validator = validators[_id];\r\n        require(_validator.renewalExpiry + gracePeriod > block.timestamp, \"Grace period expired\");\r\n        if (_validator.fuseProduct > 0) {\r\n            require(!_validator.fuseUnlocked, \"Must be unlocked\");\r\n            require(_validator.renewalExpiry + _boost <= _validator.fuseUnlocks + gracePeriod, \"Renewing too far\");\r\n        }\r\n        payable(renewals).transfer(msg.value);\r\n        Validator memory _validatorNew = Validator(_id, _validator.minter, _validator.created, _validator.lastClaimMicrov, _validator.lastClaimEth, _validator.numClaimsMicrov, _validator.renewalExpiry + _boost, _validator.fuseProduct, _validator.fuseCreated, _validator.fuseUnlocks, false);\r\n        validators[_id] = _validatorNew;\r\n        validatorsByMinter[msg.sender][positions[_id]] = _validatorNew;\r\n    }\r\n\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        unchecked {\r\n            if (b == 0) return (false, 0);\r\n            return (true, a / b);\r\n        }\r\n    }\r\n\r\n    function claimMicrov(uint256 _id) external payable nonReentrant {\r\n        require(ownerOf(_id) == msg.sender, \"Invalid ownership\");\r\n        Validator memory _validator = validators[_id];\r\n        uint8 _fuseProduct = _validator.fuseProduct;\r\n        require(_fuseProduct == 0, \"Must be fused\");\r\n        require(_validator.renewalExpiry > block.timestamp, \"Expired\");\r\n        require(msg.value == getClaimMicrovCost(), \"Invalid value\");\r\n        payable(claims).transfer(msg.value);\r\n        (, uint256 _amount) = getPendingMicrov(_id);\r\n        microv.transfer(msg.sender, _amount);\r\n        Validator memory _validatorNew = Validator(_id, _validator.minter, _validator.created, block.timestamp, _validator.lastClaimEth, _validator.numClaimsMicrov + 1, _validator.renewalExpiry, _validator.fuseProduct, _validator.fuseCreated, _validator.fuseUnlocks, _validator.fuseUnlocked);\r\n        validators[_id] = _validatorNew;\r\n        validatorsByMinter[msg.sender][positions[_id]] = _validatorNew;\r\n    }\r\n\r\n    function claimEth(uint256 _id) external payable nonReentrant {\r\n        require(ownerOf(_id) == msg.sender, \"Invalid ownership\");\r\n        Validator memory _validator = validators[_id];\r\n        require(_validator.fuseProduct == 1 || _validator.fuseProduct == 2 || _validator.fuseProduct == 3 || _validator.fuseProduct == 4, \"Invalid product\");\r\n        require(_validator.renewalExpiry > block.timestamp, \"Expired\");\r\n        require(!_validator.fuseUnlocked, \"Already unlocked\");\r\n        if (_validator.lastClaimEth == 0) {\r\n            require(_validator.lastClaimEth >= _validator.fuseCreated + quarter, \"Too early\");\r\n        } else {\r\n            require(_validator.lastClaimEth >= _validator.lastClaimEth + month, \"Too early\");\r\n        }\r\n        require(msg.value == getClaimEthCost(), \"Invalid value\");\r\n        payable(claims).transfer(msg.value);\r\n        _refresh(msg.sender, true, _validator.fuseProduct);\r\n        Validator memory _validatorNew = Validator(_id, _validator.minter, _validator.created, _validator.lastClaimMicrov, block.timestamp, _validator.numClaimsMicrov, _validator.renewalExpiry, _validator.fuseProduct, _validator.fuseCreated, _validator.fuseUnlocks, _validator.fuseUnlocked);\r\n        validators[_id] = _validatorNew;\r\n        validatorsByMinter[msg.sender][positions[_id]] = _validatorNew;\r\n    }\r\n\r\n    function _refresh(address _address, bool _claim, uint8 _tier) private {\r\n        uint256 _1balance = 0;\r\n        uint256 _2balance = 0;\r\n        uint256 _3balance = 0;\r\n        uint256 _4balance = 0;\r\n        uint256 _matches = numValidatorsByMinter[_address];\r\n        Validator[] memory _array = validatorsByMinter[_address];\r\n        for (uint256 _i = 0; _i < _matches; _i++) {\r\n            if (_array[_i].fuseProduct > 0 && !_array[_i].fuseUnlocked && _array[_i].renewalExpiry > block.timestamp && _array[_i].fuseUnlocks < block.timestamp) {\r\n                uint256 _fuseProduct = _array[_i].fuseProduct;\r\n                if (_fuseProduct == 1) _1balance++;\r\n                else if (_fuseProduct == 2) _2balance++;\r\n                else if (_fuseProduct == 3) _3balance++;\r\n                else if (_fuseProduct == 4) _4balance++;\r\n            }\r\n        }\r\n        if (_claim) {\r\n            if (_tier == 1) try _network1.claimDividend(_address, weth) {} catch {}\r\n            else if (_tier == 2) try _network2.claimDividend(_address, weth) {} catch {}\r\n            else if (_tier == 3) try _network3.claimDividend(_address, weth) {} catch {}\r\n            else if (_tier == 4) try _network4.claimDividend(_address, weth) {} catch {}\r\n        }\r\n        try _network1.setShare(_address, _1balance) {} catch {}\r\n        try _network2.setShare(_address, _2balance) {} catch {}\r\n        try _network3.setShare(_address, _3balance) {} catch {}\r\n        try _network4.setShare(_address, _4balance) {} catch {}\r\n    }\r\n\r\n    function unlockMicrov(uint256 _id) external nonReentrant {\r\n        require(ownerOf(_id) == msg.sender, \"Invalid ownership\");\r\n        Validator memory _validator = validators[_id];\r\n        require(_validator.fuseProduct == 1 || _validator.fuseProduct == 2 || _validator.fuseProduct == 3 || _validator.fuseProduct == 4, \"Invalid product\");\r\n        require(_validator.renewalExpiry > block.timestamp, \"Expired\");\r\n        require(_validator.fuseUnlocks >= block.timestamp, \"Too early\");\r\n        require(!_validator.fuseUnlocked, \"Already unlocked\");\r\n        _refresh(msg.sender, true, _validator.fuseProduct);\r\n        if (_validator.fuseProduct == 1) microv.transfer(msg.sender, amount1);\r\n        else if (_validator.fuseProduct == 2) microv.transfer(msg.sender, amount2);\r\n        else if (_validator.fuseProduct == 3) microv.transfer(msg.sender, amount3);\r\n        else if (_validator.fuseProduct == 4) microv.transfer(msg.sender, amount4);\r\n        Validator memory _validatorNew = Validator(_id, _validator.minter, _validator.created, _validator.lastClaimMicrov, _validator.lastClaimEth, _validator.numClaimsMicrov, _validator.renewalExpiry, _validator.fuseProduct, _validator.fuseCreated, _validator.fuseUnlocks, true);\r\n        validators[_id] = _validatorNew;\r\n        validatorsByMinter[msg.sender][positions[_id]] = _validatorNew;\r\n    }\r\n\r\n    function slash(uint256 _id) external nonReentrant onlyOwner {\r\n        Validator memory _validator = validators[_id];\r\n        require(_validator.fuseProduct == 1 || _validator.fuseProduct == 2 || _validator.fuseProduct == 3 || _validator.fuseProduct == 4, \"Invalid product\");\r\n        require(_validator.renewalExpiry + gracePeriod <= block.timestamp, \"Not expired\");\r\n        _refresh(_validator.minter, false, 0);\r\n    }\r\n\r\n    function changeRatesAmounts(uint256 _rate0, uint256 _amount1, uint256 _amount2, uint256 _amount3, uint256 _amount4) external nonReentrant onlyOwner {\r\n        rate0 = _rate0;\r\n        amount1 = _amount1;\r\n        amount2 = _amount2;\r\n        amount3 = _amount3;\r\n        amount4 = _amount4;\r\n    }\r\n\r\n    function configureMinting(uint256 _mintPrice, uint256 _rewardsFee, uint256 _liquidityFee, uint256 _reservesFee, uint256 _partnershipsFee, uint256 _deadFee) external nonReentrant onlyOwner {\r\n        require(_mintPrice == _rewardsFee + _liquidityFee + _reservesFee + _partnershipsFee + _deadFee, \"\");\r\n        mintPrice = _mintPrice;\r\n        rewardsFee = _rewardsFee;\r\n        liquidityFee = _liquidityFee;\r\n        reservesFee = _reservesFee;\r\n        partnershipsFee = _partnershipsFee;\r\n        deadFee = _deadFee;\r\n    }\r\n\r\n    function changeRenewalFee(uint256 _renewalFee) external nonReentrant onlyOwner {\r\n        renewalFee = _renewalFee;\r\n    }\r\n\r\n    function changeClaimMicrovFee(uint256 _claimMicrovFee) external nonReentrant onlyOwner {\r\n        claimMicrovFee = _claimMicrovFee;\r\n    }\r\n\r\n    function changeClaimEthFee(uint256 _claimEthFee) external nonReentrant onlyOwner {\r\n        claimEthFee = _claimEthFee;\r\n    }\r\n\r\n    function setGracePeriod(uint256 _gracePeriod) external nonReentrant onlyOwner {\r\n        gracePeriod = _gracePeriod;\r\n    }\r\n\r\n    function setQuarter(uint256 _quarter) external nonReentrant onlyOwner {\r\n        quarter = _quarter;\r\n    }\r\n\r\n    function setMonth(uint256 _month) external nonReentrant onlyOwner {\r\n        month = _month;\r\n    }\r\n\r\n    function setMaxValidatorsPerMinter(uint256 _maxValidatorsPerMinter) external nonReentrant onlyOwner {\r\n        maxValidatorsPerMinter = _maxValidatorsPerMinter;\r\n    }\r\n\r\n    function changeMicrov(address _microvAddress) external nonReentrant onlyOwner {\r\n        microvAddress = _microvAddress;\r\n        microv = IERC20(microvAddress);\r\n    }\r\n\r\n    function changeWeth(address _weth) external nonReentrant onlyOwner {\r\n        weth = _weth;\r\n    }\r\n\r\n    function switchPriceFeed(address _priceFeed) external nonReentrant onlyOwner {\r\n        priceFeed = AggregatorV3Interface(_priceFeed);\r\n    }\r\n\r\n    function getNetworks() external view returns (address, address, address, address) {\r\n        return (network1Address, network2Address, network3Address, network4Address);\r\n    }\r\n\r\n    function getGracePeriod() external view returns (uint256) {\r\n        return gracePeriod;\r\n    }\r\n\r\n    function getQuarter() external view returns (uint256) {\r\n        return quarter;\r\n    }\r\n\r\n    function getMaxValidatorsPerMinter() external view returns (uint256) {\r\n        return maxValidatorsPerMinter;\r\n    }\r\n\r\n    function getClaimMicrovCost() public view returns (uint256) {\r\n        return (claimMicrovFee * (10 ** 18)) / uint(getLatestPrice());\r\n    }\r\n\r\n    function getClaimEthCost() public view returns (uint256) {\r\n        return (claimEthFee * (10 ** 18)) / uint(getLatestPrice());\r\n    }\r\n\r\n    function getRenewalCost(uint256 _months) public view returns (uint256) {\r\n        return (renewalFee * (10 ** 18)) / uint(getLatestPrice()) * _months;\r\n    }\r\n\r\n    function getLatestPrice() public view returns (int256) {\r\n        (, int256 _price, , , ) = priceFeed.latestRoundData();\r\n        return _price;\r\n    }\r\n\r\n    function getBlockTimestamp() external view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function getPendingMicrov(uint256 _id) public view returns (uint256, uint256) {\r\n        Validator memory _validator = validators[_id];\r\n        uint8 _fuseProduct = _validator.fuseProduct;\r\n        require(_fuseProduct == 0, \"Must be fused\");\r\n        uint256 _newRate = rates0[_validator.numClaimsMicrov];\r\n        uint256 _amount = (block.timestamp - (_validator.numClaimsMicrov > 0 ? _validator.lastClaimMicrov : _validator.created)) * (_newRate);\r\n        if (_validator.created < block.timestamp + gammaPeriod) {\r\n            uint256 _seconds = (block.timestamp + gammaPeriod) - _validator.created;\r\n            uint256 _percent = 100;\r\n            if (_seconds >= 4838400) _percent = 900;\r\n            else if (_seconds >= 4233600) _percent = 800;\r\n            else if (_seconds >= 3628800) _percent = 700;\r\n            else if (_seconds >= 3024000) _percent = 600;\r\n            else if (_seconds >= 2419200) _percent = 500;\r\n            else if (_seconds >= 1814400) _percent = 400;\r\n            else if (_seconds >= 1209600) _percent = 300;\r\n            else if (_seconds >= 604800) _percent = 200;\r\n            uint256 _divisor = _amount * _percent;\r\n            (bool _divisible, ) = tryDiv(_divisor, 10000);\r\n            _amount = _amount - (_divisible ? (_divisor / 10000) : 0);\r\n        }\r\n        return (_newRate, _amount);\r\n    }\r\n\r\n    function setRecipients(address _renewals, address _claims, address _rewards, address _liquidity, address _reserves, address _partnerships, address _dead) external onlyOwner {\r\n        renewals = _renewals;\r\n        claims = _claims;\r\n        rewards = _rewards;\r\n        liquidity = _liquidity;\r\n        reserves = _reserves;\r\n        partnerships = _partnerships;\r\n        dead = _dead;\r\n    }\r\n\r\n    function getValidator(uint256 _id) external view returns (Validator memory) {\r\n        return validators[_id];\r\n    }\r\n\r\n    function getValidatorsByMinter(address _minter) external view returns (Validator[] memory) {\r\n        return validatorsByMinter[_minter];\r\n    }\r\n\r\n    function getNumValidatorsByMinter(address _minter) external view returns (uint256) {\r\n        return numValidatorsByMinter[_minter];\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _token, address _recipient) external onlyOwner {\r\n        IERC20(_token).transfer(_recipient, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n\r\n    function deposit1() external payable onlyOwner {\r\n        if (msg.value > 0) {\r\n            try _network1.deposit{value: msg.value}() {} catch {}\r\n        }\r\n    }\r\n\r\n    function deposit2() external payable onlyOwner {\r\n        if (msg.value > 0) {\r\n            try _network2.deposit{value: msg.value}() {} catch {}\r\n        }\r\n    }\r\n\r\n    function deposit3() external payable onlyOwner {\r\n        if (msg.value > 0) {\r\n            try _network3.deposit{value: msg.value}() {} catch {}\r\n        }\r\n    }\r\n\r\n    function deposit4() external payable onlyOwner {\r\n        if (msg.value > 0) {\r\n            try _network4.deposit{value: msg.value}() {} catch {}\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n\r\ncontract MICROV is IERC20, AC {\r\n    using SafeMath for uint256;\r\n    address public BASE = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\r\n    address public USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\r\n    address public constant DEAD = 0x000000000000000000000000000000000000dEaD;\r\n    string private constant _name = \"MicroValidator\";\r\n    string private constant _symbol = \"MICROV\";\r\n    uint8 private constant _decimals = 18;\r\n    uint256 private _totalSupply = 1000000 * (10 ** _decimals);\r\n    uint256 public maxWallet = _totalSupply;\r\n    uint256 public minAmountToTriggerSwap = 0;\r\n    mapping (address => uint256) private _balances;\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n    mapping (address => bool) public isDisabledExempt;\r\n    mapping (address => bool) public isFeeExempt;\r\n    mapping (address => bool) public isMaxExempt;\r\n    mapping (address => bool) public isUniswapPair;\r\n    uint256 public buyFeeOp = 300;\r\n    uint256 public buyFeeValidator = 0;\r\n    uint256 public buyFeeTotal = 300;\r\n    uint256 public sellFeeOp = 0;\r\n    uint256 public sellFeeValidator = 800;\r\n    uint256 public sellFeeTotal = 800;\r\n    uint256 public bps = 10000;\r\n    uint256 public _opTokensToSwap;\r\n    uint256 public _validatorTokensToSwap;\r\n    address public opFeeRecipient1 = 0xb8d7dA7E64271E274e132001F9865Ad8De5001C8;\r\n    address public opFeeRecipient2 = 0x21CcABc78FC240892a54106bC7a8dC3880536347;\r\n    address public opFeeRecipient3 = 0xd703f7b098262B0751c9A654eea332183D199A69;\r\n    address public validatorFeeRecipient = 0x58917027C0648086f85Cd208E289095731cFDE1B;\r\n    IUniswapV2Router public router;\r\n    address public pair;\r\n    bool public contractSellEnabled = true;\r\n    uint256 public contractSellThreshold = _totalSupply / 5000;\r\n    bool public mintingEnabled = true;\r\n    bool public tradingEnabled = false;\r\n    bool public isContractSelling = false;\r\n    MicroValidator public microvalidator;\r\n    address public microvalidatorAddress;\r\n    bool public swapForETH = true;\r\n    IERC20 public usdt = IERC20(USDT);\r\n    uint256 public taxDistOp = 2700;\r\n    uint256 public taxDistValidator = 7300;\r\n    uint256 public taxDistBps = 10000;\r\n\r\n    modifier contractSelling() {\r\n        isContractSelling = true;\r\n        _;\r\n        isContractSelling = false;\r\n    }\r\n\r\n    constructor (address _priceFeed) AC(msg.sender) {\r\n        address _router = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\r\n        router = IUniswapV2Router(_router);\r\n        pair = IUniswapV2Factory(router.factory()).createPair(USDT, address(this));\r\n        _allowances[address(this)][address(router)] = _totalSupply;\r\n        WETH = router.WETH();\r\n        microvalidator = new MicroValidator(\"Annuity MicroValidators\", \"MicroValidator\", address(this), msg.sender, _priceFeed, WETH);\r\n        microvalidatorAddress = address(microvalidator);\r\n        isDisabledExempt[msg.sender] = true;\r\n        isFeeExempt[msg.sender] = true;\r\n        isMaxExempt[msg.sender] = true;\r\n        isDisabledExempt[microvalidatorAddress] = true;\r\n        isFeeExempt[microvalidatorAddress] = true;\r\n        isMaxExempt[microvalidatorAddress] = true;\r\n        isDisabledExempt[address(0)] = true;\r\n        isFeeExempt[address(0)] = true;\r\n        isMaxExempt[address(0)] = true;\r\n        isDisabledExempt[DEAD] = true;\r\n        isFeeExempt[DEAD] = true;\r\n        isMaxExempt[DEAD] = true;\r\n        isMaxExempt[address(this)] = true;\r\n        isUniswapPair[pair] = true;\r\n        approve(_router, _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        uint256 _toEmissions = 237000 * (10 ** _decimals);\r\n        uint256 _toDeployer = _totalSupply - _toEmissions;\r\n        _balances[msg.sender] = _toDeployer;\r\n        emit Transfer(address(0), msg.sender, _toDeployer);\r\n        _balances[microvalidatorAddress] = _toEmissions;\r\n        emit Transfer(address(0), microvalidatorAddress, _toEmissions);\r\n    }\r\n\r\n    function mint(uint256 _amount) external onlyOwner {\r\n        require(mintingEnabled, \"Minting is disabled\");\r\n        _totalSupply += _amount;\r\n        approve(address(router), _totalSupply);\r\n        approve(address(pair), _totalSupply);\r\n        _balances[msg.sender] += _amount;\r\n        emit Transfer(address(0), msg.sender, _amount);\r\n    }\r\n\r\n    function burn(uint256 _amount) external onlyOwner {\r\n        require(_balances[msg.sender] >= _amount);\r\n        _totalSupply -= _amount;\r\n        _balances[msg.sender] -= _amount;\r\n        emit Transfer(msg.sender, address(0), _amount);\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) public override returns (bool) {\r\n        _allowances[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function approveMax(address _spender) external returns (bool) {\r\n        return approve(_spender, _totalSupply);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\r\n        return _transferFrom(msg.sender, recipient, amount);\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        if (_allowances[sender][msg.sender] != _totalSupply) _allowances[sender][msg.sender] = _allowances[sender][msg.sender].sub(amount, \"Insufficient Allowance\");\r\n        return _transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    function _transferFrom(address _sender, address _recipient, uint256 _amount) private returns (bool) {\r\n        if (isContractSelling) return _simpleTransfer(_sender, _recipient, _amount);\r\n        require(tradingEnabled || isDisabledExempt[_sender], \"Trading is currently disabled\");\r\n        address _routerAddress = address(router);\r\n        bool _sell = isUniswapPair[_recipient] || _recipient == _routerAddress;\r\n        if (!_sell && !isMaxExempt[_recipient]) require((_balances[_recipient] + _amount) < maxWallet, \"Max wallet has been triggered\");\r\n        if (_sell && _amount >= minAmountToTriggerSwap) {\r\n            if (!isUniswapPair[msg.sender] && !isContractSelling && contractSellEnabled && _balances[address(this)] >= contractSellThreshold) _contractSell();\r\n        }\r\n        _balances[_sender] = _balances[_sender].sub(_amount, \"Insufficient balance\");\r\n        uint256 _amountAfterFees = _amount;\r\n        if (((isUniswapPair[_sender] || _sender == _routerAddress) || (isUniswapPair[_recipient]|| _recipient == _routerAddress)) ? !isFeeExempt[_sender] && !isFeeExempt[_recipient] : false) _amountAfterFees = _collectFee(_sender, _recipient, _amount);\r\n        _balances[_recipient] = _balances[_recipient].add(_amountAfterFees);\r\n        emit Transfer(_sender, _recipient, _amountAfterFees);\r\n        return true;\r\n    }\r\n\r\n    function _simpleTransfer(address _sender, address _recipient, uint256 _amount) private returns (bool) {\r\n        _balances[_sender] = _balances[_sender].sub(_amount, \"Insufficient Balance\");\r\n        _balances[_recipient] = _balances[_recipient].add(_amount);\r\n        return true;\r\n    }\r\n\r\n    function _collectFee(address _sender, address _recipient, uint256 _amount) private returns (uint256) {\r\n        bool _sell = isUniswapPair[_recipient] || _recipient == address(router);\r\n        uint256 _feeDividend = _sell ? sellFeeTotal : buyFeeTotal;\r\n        uint256 _feeDivisor = _amount.mul(_feeDividend).div(bps);\r\n        if (_feeDividend > 0) {\r\n            if (_sell) {\r\n                if (sellFeeOp > 0) _opTokensToSwap += _feeDivisor * sellFeeOp / _feeDividend;\r\n                if (sellFeeValidator > 0) _validatorTokensToSwap += _feeDivisor * sellFeeValidator / _feeDividend;\r\n            } else {\r\n                if (buyFeeOp > 0) _opTokensToSwap += _feeDivisor * buyFeeOp / _feeDividend;\r\n                if (buyFeeValidator > 0) _validatorTokensToSwap += _feeDivisor * buyFeeValidator / _feeDividend;\r\n            }\r\n        }\r\n        _balances[address(this)] = _balances[address(this)].add(_feeDivisor);\r\n        emit Transfer(_sender, address(this), _feeDivisor);\r\n        return _amount.sub(_feeDivisor);\r\n    }\r\n\r\n    function _contractSell() private contractSelling {\r\n        uint256 _tokensTotal = _opTokensToSwap.add(_validatorTokensToSwap);\r\n        if (swapForETH) {\r\n            address[] memory path = new address[](3);\r\n            path[0] = address(this);\r\n            path[1] = USDT;\r\n            path[2] = WETH;\r\n            uint256 _ethBefore = address(this).balance;\r\n            router.swapExactTokensForETHSupportingFeeOnTransferTokens(balanceOf(address(this)), 0, path, address(this), block.timestamp);\r\n            uint256 _ethAfter = address(this).balance.sub(_ethBefore);\r\n            uint256 _ethOp = _ethAfter.mul(_opTokensToSwap).div(_tokensTotal);\r\n            uint256 _ethValidator = _ethAfter.mul(_validatorTokensToSwap).div(_tokensTotal);\r\n            _opTokensToSwap = 0;\r\n            _validatorTokensToSwap = 0;\r\n            if (_ethOp > 0) {\r\n                payable(opFeeRecipient1).transfer((_ethOp * 3400) / 10000);\r\n                payable(opFeeRecipient2).transfer((_ethOp * 3300) / 10000);\r\n                payable(opFeeRecipient3).transfer((_ethOp * 3300) / 10000);\r\n            }\r\n            if (_ethValidator > 0) payable(validatorFeeRecipient).transfer(_ethValidator);\r\n        } else {\r\n            address[] memory path = new address[](2);\r\n            path[0] = address(this);\r\n            path[1] = USDT;\r\n            uint256 _usdtBefore = usdt.balanceOf(address(this));\r\n            router.swapExactTokensForTokensSupportingFeeOnTransferTokens(balanceOf(address(this)), 0, path, address(this), block.timestamp);\r\n            uint256 _usdtAfter = usdt.balanceOf(address(this)).sub(_usdtBefore);\r\n            uint256 _usdtOp = _usdtAfter.mul(taxDistOp).div(taxDistBps);\r\n            uint256 _usdtValidator = _usdtAfter.mul(taxDistValidator).div(taxDistBps);\r\n            _opTokensToSwap = 0;\r\n            _validatorTokensToSwap = 0;\r\n            if (_usdtOp > 0) {\r\n                usdt.transfer(opFeeRecipient1, (_usdtOp * 3400) / 10000);\r\n                usdt.transfer(opFeeRecipient2, (_usdtOp * 3300) / 10000);\r\n                usdt.transfer(opFeeRecipient3, (_usdtOp * 3300) / 10000);\r\n            }\r\n            if (_usdtValidator > 0) usdt.transfer(validatorFeeRecipient, _usdtValidator);\r\n        }\r\n    }\r\n\r\n    function changeSwapForETH(bool _swapForETH) external onlyOwner {\r\n        swapForETH = _swapForETH;\r\n    }\r\n\r\n    function changeTaxDist(uint256 _taxDistOp, uint256 _taxDistValidator, uint256 _taxDistBps) external onlyOwner {\r\n        taxDistOp = _taxDistOp;\r\n        taxDistValidator = _taxDistValidator;\r\n        taxDistBps = _taxDistBps;\r\n    }\r\n\r\n    function changeWETH(address _WETH) external onlyOwner {\r\n        WETH = _WETH;\r\n    }\r\n\r\n    function changeUSDT(address _USDT) external onlyOwner {\r\n        USDT = _USDT;\r\n        usdt = IERC20(USDT);\r\n    }\r\n\r\n    function setMaxWallet(uint256 _maxWallet) external onlyOwner {\r\n        maxWallet = _maxWallet;\r\n    }\r\n\r\n    function setMinAmountToTriggerSwap(uint256 _minAmountToTriggerSwap) external onlyOwner {\r\n        minAmountToTriggerSwap = _minAmountToTriggerSwap;\r\n    }\r\n\r\n    function toggleIsDisabledExempt(address _holder, bool _exempt) external onlyOwner {\r\n        isDisabledExempt[_holder] = _exempt;\r\n    }\r\n\r\n    function getIsDisabledExempt(address _holder) external view returns (bool) {\r\n        return isDisabledExempt[_holder];\r\n    }\r\n\r\n    function toggleIsFeeExempt(address _holder, bool _exempt) external onlyOwner {\r\n        isFeeExempt[_holder] = _exempt;\r\n    }\r\n\r\n    function getIsFeeExempt(address _holder) external view returns (bool) {\r\n        return isFeeExempt[_holder];\r\n    }\r\n\r\n    function toggleIsMaxExempt(address _holder, bool _exempt) external onlyOwner {\r\n        isMaxExempt[_holder] = _exempt;\r\n    }\r\n\r\n    function getIsMaxExempt(address _holder) external view returns (bool) {\r\n        return isMaxExempt[_holder];\r\n    }\r\n\r\n    function toggleIsUniswapPair(address _pair, bool _isPair) external onlyOwner {\r\n        isUniswapPair[_pair] = _isPair;\r\n    }\r\n\r\n    function getIsUniswapPair(address _pair) external view returns (bool) {\r\n        return isUniswapPair[_pair];\r\n    }\r\n\r\n    function configureContractSelling(bool _contractSellEnabled, uint256 _contractSellThreshold) external onlyOwner {\r\n        contractSellEnabled = _contractSellEnabled;\r\n        contractSellThreshold = _contractSellThreshold;\r\n    }\r\n\r\n    function setTransferTaxes(uint256 _buyFeeOp, uint256 _buyFeeValidator, uint256 _sellFeeOp, uint256 _sellFeeValidator, uint256 _bps) external onlyOwner {\r\n        buyFeeOp = _buyFeeOp;\r\n        buyFeeValidator = _buyFeeValidator;\r\n        buyFeeTotal = _buyFeeOp.add(_buyFeeValidator);\r\n        sellFeeOp = _sellFeeOp;\r\n        sellFeeValidator = _sellFeeValidator;\r\n        sellFeeTotal = _sellFeeOp.add(_sellFeeValidator);\r\n        bps = _bps;\r\n    }\r\n\r\n    function setTransferTaxRecipients(address _opFeeRecipient1, address _opFeeRecipient2, address _opFeeRecipient3, address _validatorFeeRecipient) external onlyOwner {\r\n        opFeeRecipient1 = _opFeeRecipient1;\r\n        opFeeRecipient2 = _opFeeRecipient2;\r\n        opFeeRecipient3 = _opFeeRecipient3;\r\n        validatorFeeRecipient = _validatorFeeRecipient;\r\n    }\r\n\r\n    function updateRouting(address _router, address _pair, address _USDT) external onlyOwner {\r\n        router = IUniswapV2Router(_router);\r\n        pair = _pair == address(0) ? IUniswapV2Factory(router.factory()).createPair(address(this), _USDT) : IUniswapV2Factory(router.factory()).getPair(address(this), _USDT);\r\n        _allowances[address(this)][_router] = _totalSupply;\r\n    }\r\n\r\n    function permanentlyDisableMinting() external onlyOwner {\r\n        mintingEnabled = false;\r\n    }\r\n\r\n    function toggleTrading(bool _enabled) external onlyOwner {\r\n        tradingEnabled = _enabled;\r\n    }\r\n\r\n    function drainGas() external onlyOwner {\r\n        payable(msg.sender).transfer(address(this).balance);\r\n    }\r\n\r\n    function drainToken(address _token, address _recipient) external onlyOwner {\r\n        IERC20(_token).transfer(_recipient, IERC20(_token).balanceOf(address(this)));\r\n    }\r\n\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function decimals() external pure override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function getOwner() external view override returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function allowance(address holder, address spender) external view override returns (uint256) {\r\n        return _allowances[holder][spender];\r\n    }\r\n\r\n    receive() external payable {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceFeed\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEAD\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"USDT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_opTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_validatorTokensToSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"approveMax\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeeOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFeeValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_swapForETH\",\"type\":\"bool\"}],\"name\":\"changeSwapForETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_taxDistOp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_taxDistValidator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_taxDistBps\",\"type\":\"uint256\"}],\"name\":\"changeTaxDist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_USDT\",\"type\":\"address\"}],\"name\":\"changeUSDT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"}],\"name\":\"changeWETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_contractSellEnabled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"_contractSellThreshold\",\"type\":\"uint256\"}],\"name\":\"configureContractSelling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSellEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractSellThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"drainGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"drainToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getIsDisabledExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getIsFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"getIsMaxExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"}],\"name\":\"getIsUniswapPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isContractSelling\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isDisabledExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFeeExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMaxExempt\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUniswapPair\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"microvalidator\",\"outputs\":[{\"internalType\":\"contract MicroValidator\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"microvalidatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAmountToTriggerSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opFeeRecipient1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opFeeRecipient2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"opFeeRecipient3\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permanentlyDisableMinting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFeeOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFeeTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFeeValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWallet\",\"type\":\"uint256\"}],\"name\":\"setMaxWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmountToTriggerSwap\",\"type\":\"uint256\"}],\"name\":\"setMinAmountToTriggerSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_opFeeRecipient1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_opFeeRecipient2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_opFeeRecipient3\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_validatorFeeRecipient\",\"type\":\"address\"}],\"name\":\"setTransferTaxRecipients\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyFeeOp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_buyFeeValidator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFeeOp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sellFeeValidator\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bps\",\"type\":\"uint256\"}],\"name\":\"setTransferTaxes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapForETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDistBps\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDistOp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"taxDistValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"toggleIsDisabledExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"toggleIsFeeExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_holder\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_exempt\",\"type\":\"bool\"}],\"name\":\"toggleIsMaxExempt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isPair\",\"type\":\"bool\"}],\"name\":\"toggleIsUniswapPair\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"toggleTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tradingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_router\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_USDT\",\"type\":\"address\"}],\"name\":\"updateRouting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MICROV", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000005f4ec3df9cbd43714fe2740f5e3616155c5b8419", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://18c9bac039f90ae20a1c6368660439fb9066ec07a14e63d067c9586bb4d6199a"}]}