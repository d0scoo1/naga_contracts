{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.0;\r\n\r\n// Sources flattened with hardhat v2.9.1 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/vendor/BufferChainlink.sol@v0.4.0\r\n\r\n\r\n/**\r\n * @dev A library for working with mutable byte buffers in Solidity.\r\n *\r\n * Byte buffers are mutable and expandable, and provide a variety of primitives\r\n * for writing to them. At any time you can fetch a bytes object containing the\r\n * current contents of the buffer. The bytes object should not be stored between\r\n * operations, as it may change due to resizing of the buffer.\r\n */\r\nlibrary BufferChainlink {\r\n  /**\r\n   * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n   *      a capacity. The capacity may be longer than the current value, in\r\n   *      which case it can be extended without the need to allocate more memory.\r\n   */\r\n  struct buffer {\r\n    bytes buf;\r\n    uint256 capacity;\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a buffer with an initial capacity.\r\n   * @param buf The buffer to initialize.\r\n   * @param capacity The number of bytes of space to allocate the buffer.\r\n   * @return The buffer, for chaining.\r\n   */\r\n  function init(buffer memory buf, uint256 capacity) internal pure returns (buffer memory) {\r\n    if (capacity % 32 != 0) {\r\n      capacity += 32 - (capacity % 32);\r\n    }\r\n    // Allocate space for the buffer data\r\n    buf.capacity = capacity;\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(buf, ptr)\r\n      mstore(ptr, 0)\r\n      mstore(0x40, add(32, add(ptr, capacity)))\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Initializes a new buffer from an existing bytes object.\r\n   *      Changes to the buffer may mutate the original value.\r\n   * @param b The bytes object to initialize the buffer with.\r\n   * @return A new buffer.\r\n   */\r\n  function fromBytes(bytes memory b) internal pure returns (buffer memory) {\r\n    buffer memory buf;\r\n    buf.buf = b;\r\n    buf.capacity = b.length;\r\n    return buf;\r\n  }\r\n\r\n  function resize(buffer memory buf, uint256 capacity) private pure {\r\n    bytes memory oldbuf = buf.buf;\r\n    init(buf, capacity);\r\n    append(buf, oldbuf);\r\n  }\r\n\r\n  function max(uint256 a, uint256 b) private pure returns (uint256) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets buffer length to 0.\r\n   * @param buf The buffer to truncate.\r\n   * @return The original buffer, for chaining..\r\n   */\r\n  function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n    assembly {\r\n      let bufptr := mload(buf)\r\n      mstore(bufptr, 0)\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The start offset to write to.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to copy.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function write(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes memory data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    require(len <= data.length);\r\n\r\n    if (off + len > buf.capacity) {\r\n      resize(buf, max(buf.capacity, len + off) * 2);\r\n    }\r\n\r\n    uint256 dest;\r\n    uint256 src;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Start address = buffer address + offset + sizeof(buffer length)\r\n      dest := add(add(bufptr, 32), off)\r\n      // Update buffer length if we're extending it\r\n      if gt(add(len, off), buflen) {\r\n        mstore(bufptr, add(len, off))\r\n      }\r\n      src := add(data, 32)\r\n    }\r\n\r\n    // Copy word-length chunks while possible\r\n    for (; len >= 32; len -= 32) {\r\n      assembly {\r\n        mstore(dest, mload(src))\r\n      }\r\n      dest += 32;\r\n      src += 32;\r\n    }\r\n\r\n    // Copy remaining bytes\r\n    unchecked {\r\n      uint256 mask = (256**(32 - len)) - 1;\r\n      assembly {\r\n        let srcpart := and(mload(src), not(mask))\r\n        let destpart := and(mload(dest), mask)\r\n        mstore(dest, or(destpart, srcpart))\r\n      }\r\n    }\r\n\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to copy.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function append(\r\n    buffer memory buf,\r\n    bytes memory data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, len);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function append(buffer memory buf, bytes memory data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, data.length);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write the byte at.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeUint8(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    uint8 data\r\n  ) internal pure returns (buffer memory) {\r\n    if (off >= buf.capacity) {\r\n      resize(buf, buf.capacity * 2);\r\n    }\r\n\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Length of existing buffer data\r\n      let buflen := mload(bufptr)\r\n      // Address = buffer address + sizeof(buffer length) + off\r\n      let dest := add(add(bufptr, off), 32)\r\n      mstore8(dest, data)\r\n      // Update buffer length if we extended it\r\n      if eq(off, buflen) {\r\n        mstore(bufptr, add(buflen, 1))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function appendUint8(buffer memory buf, uint8 data) internal pure returns (buffer memory) {\r\n    return writeUint8(buf, buf.buf.length, data);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n   *      exceed the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to write (left-aligned).\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function write(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes32 data,\r\n    uint256 len\r\n  ) private pure returns (buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    unchecked {\r\n      uint256 mask = (256**len) - 1;\r\n      // Right-align data\r\n      data = data >> (8 * (32 - len));\r\n      assembly {\r\n        // Memory address of the buffer data\r\n        let bufptr := mload(buf)\r\n        // Address = buffer address + sizeof(buffer length) + off + len\r\n        let dest := add(add(bufptr, off), len)\r\n        mstore(dest, or(and(mload(dest), not(mask)), data))\r\n        // Update buffer length if we extended it\r\n        if gt(add(off, len), mload(bufptr)) {\r\n          mstore(bufptr, add(off, len))\r\n        }\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n   *      capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeBytes20(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    bytes20 data\r\n  ) internal pure returns (buffer memory) {\r\n    return write(buf, off, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chhaining.\r\n   */\r\n  function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, bytes32(data), 20);\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n    return write(buf, buf.buf.length, data, 32);\r\n  }\r\n\r\n  /**\r\n   * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n   *      the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param off The offset to write at.\r\n   * @param data The data to append.\r\n   * @param len The number of bytes to write (right-aligned).\r\n   * @return The original buffer, for chaining.\r\n   */\r\n  function writeInt(\r\n    buffer memory buf,\r\n    uint256 off,\r\n    uint256 data,\r\n    uint256 len\r\n  ) private pure returns (buffer memory) {\r\n    if (len + off > buf.capacity) {\r\n      resize(buf, (len + off) * 2);\r\n    }\r\n\r\n    uint256 mask = (256**len) - 1;\r\n    assembly {\r\n      // Memory address of the buffer data\r\n      let bufptr := mload(buf)\r\n      // Address = buffer address + off + sizeof(buffer length) + len\r\n      let dest := add(add(bufptr, off), len)\r\n      mstore(dest, or(and(mload(dest), not(mask)), data))\r\n      // Update buffer length if we extended it\r\n      if gt(add(off, len), mload(bufptr)) {\r\n        mstore(bufptr, add(off, len))\r\n      }\r\n    }\r\n    return buf;\r\n  }\r\n\r\n  /**\r\n   * @dev Appends a byte to the end of the buffer. Resizes if doing so would\r\n   * exceed the capacity of the buffer.\r\n   * @param buf The buffer to append to.\r\n   * @param data The data to append.\r\n   * @return The original buffer.\r\n   */\r\n  function appendInt(\r\n    buffer memory buf,\r\n    uint256 data,\r\n    uint256 len\r\n  ) internal pure returns (buffer memory) {\r\n    return writeInt(buf, buf.buf.length, data, len);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/vendor/CBORChainlink.sol@v0.4.0\r\n\r\n\r\nlibrary CBORChainlink {\r\n  using BufferChainlink for BufferChainlink.buffer;\r\n\r\n  uint8 private constant MAJOR_TYPE_INT = 0;\r\n  uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n  uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n  uint8 private constant MAJOR_TYPE_STRING = 3;\r\n  uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n  uint8 private constant MAJOR_TYPE_MAP = 5;\r\n  uint8 private constant MAJOR_TYPE_TAG = 6;\r\n  uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n  uint8 private constant TAG_TYPE_BIGNUM = 2;\r\n  uint8 private constant TAG_TYPE_NEGATIVE_BIGNUM = 3;\r\n\r\n  function encodeFixedNumeric(BufferChainlink.buffer memory buf, uint8 major, uint64 value) private pure {\r\n    if(value <= 23) {\r\n      buf.appendUint8(uint8((major << 5) | value));\r\n    } else if (value <= 0xFF) {\r\n      buf.appendUint8(uint8((major << 5) | 24));\r\n      buf.appendInt(value, 1);\r\n    } else if (value <= 0xFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 25));\r\n      buf.appendInt(value, 2);\r\n    } else if (value <= 0xFFFFFFFF) {\r\n      buf.appendUint8(uint8((major << 5) | 26));\r\n      buf.appendInt(value, 4);\r\n    } else {\r\n      buf.appendUint8(uint8((major << 5) | 27));\r\n      buf.appendInt(value, 8);\r\n    }\r\n  }\r\n\r\n  function encodeIndefiniteLengthType(BufferChainlink.buffer memory buf, uint8 major) private pure {\r\n    buf.appendUint8(uint8((major << 5) | 31));\r\n  }\r\n\r\n  function encodeUInt(BufferChainlink.buffer memory buf, uint value) internal pure {\r\n    if(value > 0xFFFFFFFFFFFFFFFF) {\r\n      encodeBigNum(buf, value);\r\n    } else {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(value));\r\n    }\r\n  }\r\n\r\n  function encodeInt(BufferChainlink.buffer memory buf, int value) internal pure {\r\n    if(value < -0x10000000000000000) {\r\n      encodeSignedBigNum(buf, value);\r\n    } else if(value > 0xFFFFFFFFFFFFFFFF) {\r\n      encodeBigNum(buf, uint(value));\r\n    } else if(value >= 0) {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_INT, uint64(uint256(value)));\r\n    } else {\r\n      encodeFixedNumeric(buf, MAJOR_TYPE_NEGATIVE_INT, uint64(uint256(-1 - value)));\r\n    }\r\n  }\r\n\r\n  function encodeBytes(BufferChainlink.buffer memory buf, bytes memory value) internal pure {\r\n    encodeFixedNumeric(buf, MAJOR_TYPE_BYTES, uint64(value.length));\r\n    buf.append(value);\r\n  }\r\n\r\n  function encodeBigNum(BufferChainlink.buffer memory buf, uint value) internal pure {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(value));\r\n  }\r\n\r\n  function encodeSignedBigNum(BufferChainlink.buffer memory buf, int input) internal pure {\r\n    buf.appendUint8(uint8((MAJOR_TYPE_TAG << 5) | TAG_TYPE_NEGATIVE_BIGNUM));\r\n    encodeBytes(buf, abi.encode(uint256(-1 - input)));\r\n  }\r\n\r\n  function encodeString(BufferChainlink.buffer memory buf, string memory value) internal pure {\r\n    encodeFixedNumeric(buf, MAJOR_TYPE_STRING, uint64(bytes(value).length));\r\n    buf.append(bytes(value));\r\n  }\r\n\r\n  function startArray(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n  }\r\n\r\n  function startMap(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n  }\r\n\r\n  function endSequence(BufferChainlink.buffer memory buf) internal pure {\r\n    encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/Chainlink.sol@v0.4.0\r\n\r\n\r\n\r\n/**\r\n * @title Library for common Chainlink functions\r\n * @dev Uses imported CBOR library for encoding to buffer\r\n */\r\nlibrary Chainlink {\r\n  uint256 internal constant defaultBufferSize = 256; // solhint-disable-line const-name-snakecase\r\n\r\n  using CBORChainlink for BufferChainlink.buffer;\r\n\r\n  struct Request {\r\n    bytes32 id;\r\n    address callbackAddress;\r\n    bytes4 callbackFunctionId;\r\n    uint256 nonce;\r\n    BufferChainlink.buffer buf;\r\n  }\r\n\r\n  /**\r\n   * @notice Initializes a Chainlink request\r\n   * @dev Sets the ID, callback address, and callback function signature on the request\r\n   * @param self The uninitialized request\r\n   * @param jobId The Job Specification ID\r\n   * @param callbackAddr The callback address\r\n   * @param callbackFunc The callback function signature\r\n   * @return The initialized request\r\n   */\r\n  function initialize(\r\n    Request memory self,\r\n    bytes32 jobId,\r\n    address callbackAddr,\r\n    bytes4 callbackFunc\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    BufferChainlink.init(self.buf, defaultBufferSize);\r\n    self.id = jobId;\r\n    self.callbackAddress = callbackAddr;\r\n    self.callbackFunctionId = callbackFunc;\r\n    return self;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the data for the buffer without encoding CBOR on-chain\r\n   * @dev CBOR can be closed with curly-brackets {} or they can be left off\r\n   * @param self The initialized request\r\n   * @param data The CBOR data\r\n   */\r\n  function setBuffer(Request memory self, bytes memory data) internal pure {\r\n    BufferChainlink.init(self.buf, data.length);\r\n    BufferChainlink.append(self.buf, data);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a string value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The string value to add\r\n   */\r\n  function add(\r\n    Request memory self,\r\n    string memory key,\r\n    string memory value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeString(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a bytes value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The bytes value to add\r\n   */\r\n  function addBytes(\r\n    Request memory self,\r\n    string memory key,\r\n    bytes memory value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeBytes(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a int256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The int256 value to add\r\n   */\r\n  function addInt(\r\n    Request memory self,\r\n    string memory key,\r\n    int256 value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a uint256 value to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param value The uint256 value to add\r\n   */\r\n  function addUint(\r\n    Request memory self,\r\n    string memory key,\r\n    uint256 value\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.encodeUInt(value);\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an array of strings to the request with a given key name\r\n   * @param self The initialized request\r\n   * @param key The name of the key\r\n   * @param values The array of string values to add\r\n   */\r\n  function addStringArray(\r\n    Request memory self,\r\n    string memory key,\r\n    string[] memory values\r\n  ) internal pure {\r\n    self.buf.encodeString(key);\r\n    self.buf.startArray();\r\n    for (uint256 i = 0; i < values.length; i++) {\r\n      self.buf.encodeString(values[i]);\r\n    }\r\n    self.buf.endSequence();\r\n  }\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/ENSInterface.sol@v0.4.0\r\n\r\n\r\ninterface ENSInterface {\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(bytes32 indexed node, address owner);\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n  function setSubnodeOwner(\r\n    bytes32 node,\r\n    bytes32 label,\r\n    address owner\r\n  ) external;\r\n\r\n  function setResolver(bytes32 node, address resolver) external;\r\n\r\n  function setOwner(bytes32 node, address owner) external;\r\n\r\n  function setTTL(bytes32 node, uint64 ttl) external;\r\n\r\n  function owner(bytes32 node) external view returns (address);\r\n\r\n  function resolver(bytes32 node) external view returns (address);\r\n\r\n  function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol@v0.4.0\r\n\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n\r\n  function name() external view returns (string memory tokenName);\r\n\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n\r\n  function transferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) external returns (bool success);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/ChainlinkRequestInterface.sol@v0.4.0\r\n\r\n\r\ninterface ChainlinkRequestInterface {\r\n  function oracleRequest(\r\n    address sender,\r\n    uint256 requestPrice,\r\n    bytes32 serviceAgreementID,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function cancelOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration\r\n  ) external;\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/OracleInterface.sol@v0.4.0\r\n\r\n\r\ninterface OracleInterface {\r\n  function fulfillOracleRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes32 data\r\n  ) external returns (bool);\r\n\r\n  function isAuthorizedSender(address node) external view returns (bool);\r\n\r\n  function withdraw(address recipient, uint256 amount) external;\r\n\r\n  function withdrawable() external view returns (uint256);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/OperatorInterface.sol@v0.4.0\r\n\r\n\r\n\r\ninterface OperatorInterface is OracleInterface, ChainlinkRequestInterface {\r\n  function operatorRequest(\r\n    address sender,\r\n    uint256 payment,\r\n    bytes32 specId,\r\n    bytes4 callbackFunctionId,\r\n    uint256 nonce,\r\n    uint256 dataVersion,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  function fulfillOracleRequest2(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    address callbackAddress,\r\n    bytes4 callbackFunctionId,\r\n    uint256 expiration,\r\n    bytes calldata data\r\n  ) external returns (bool);\r\n\r\n  function ownerTransferAndCall(\r\n    address to,\r\n    uint256 value,\r\n    bytes calldata data\r\n  ) external returns (bool success);\r\n\r\n  function distributeFunds(address payable[] calldata receivers, uint256[] calldata amounts) external payable;\r\n\r\n  function getAuthorizedSenders() external returns (address[] memory);\r\n\r\n  function setAuthorizedSenders(address[] calldata senders) external;\r\n\r\n  function getForwarder() external returns (address);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/interfaces/PointerInterface.sol@v0.4.0\r\n\r\n\r\ninterface PointerInterface {\r\n  function getAddress() external view returns (address);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/vendor/ENSResolver.sol@v0.4.0\r\n\r\n\r\nabstract contract ENSResolver_Chainlink {\r\n  function addr(bytes32 node) public view virtual returns (address);\r\n}\r\n\r\n\r\n// File @chainlink/contracts/src/v0.8/ChainlinkClient.sol@v0.4.0\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title The ChainlinkClient contract\r\n * @notice Contract writers can inherit this contract in order to create requests for the\r\n * Chainlink network\r\n */\r\nabstract contract ChainlinkClient {\r\n  using Chainlink for Chainlink.Request;\r\n\r\n  uint256 internal constant LINK_DIVISIBILITY = 10**18;\r\n  uint256 private constant AMOUNT_OVERRIDE = 0;\r\n  address private constant SENDER_OVERRIDE = address(0);\r\n  uint256 private constant ORACLE_ARGS_VERSION = 1;\r\n  uint256 private constant OPERATOR_ARGS_VERSION = 2;\r\n  bytes32 private constant ENS_TOKEN_SUBNAME = keccak256(\"link\");\r\n  bytes32 private constant ENS_ORACLE_SUBNAME = keccak256(\"oracle\");\r\n  address private constant LINK_TOKEN_POINTER = 0xC89bD4E1632D3A43CB03AAAd5262cbe4038Bc571;\r\n\r\n  ENSInterface private s_ens;\r\n  bytes32 private s_ensNode;\r\n  LinkTokenInterface private s_link;\r\n  OperatorInterface private s_oracle;\r\n  uint256 private s_requestCount = 1;\r\n  mapping(bytes32 => address) private s_pendingRequests;\r\n\r\n  event ChainlinkRequested(bytes32 indexed id);\r\n  event ChainlinkFulfilled(bytes32 indexed id);\r\n  event ChainlinkCancelled(bytes32 indexed id);\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param specId The Job Specification ID that the request will be created for\r\n   * @param callbackAddr address to operate the callback on\r\n   * @param callbackFunctionSignature function signature to use for the callback\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildChainlinkRequest(\r\n    bytes32 specId,\r\n    address callbackAddr,\r\n    bytes4 callbackFunctionSignature\r\n  ) internal pure returns (Chainlink.Request memory) {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(specId, callbackAddr, callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a request that can hold additional parameters\r\n   * @param specId The Job Specification ID that the request will be created for\r\n   * @param callbackFunctionSignature function signature to use for the callback\r\n   * @return A Chainlink Request struct in memory\r\n   */\r\n  function buildOperatorRequest(bytes32 specId, bytes4 callbackFunctionSignature)\r\n    internal\r\n    view\r\n    returns (Chainlink.Request memory)\r\n  {\r\n    Chainlink.Request memory req;\r\n    return req.initialize(specId, address(this), callbackFunctionSignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev Calls `chainlinkRequestTo` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\r\n    return sendChainlinkRequestTo(address(s_oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendChainlinkRequestTo(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  ) internal returns (bytes32 requestId) {\r\n    uint256 nonce = s_requestCount;\r\n    s_requestCount = nonce + 1;\r\n    bytes memory encodedRequest = abi.encodeWithSelector(\r\n      ChainlinkRequestInterface.oracleRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      req.id,\r\n      address(this),\r\n      req.callbackFunctionId,\r\n      nonce,\r\n      ORACLE_ARGS_VERSION,\r\n      req.buf.buf\r\n    );\r\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the stored oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Calls `sendOperatorRequestTo` with the stored oracle address\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendOperatorRequest(Chainlink.Request memory req, uint256 payment) internal returns (bytes32) {\r\n    return sendOperatorRequestTo(address(s_oracle), req, payment);\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a Chainlink request to the specified oracle address\r\n   * @dev This function supports multi-word response\r\n   * @dev Generates and stores a request ID, increments the local nonce, and uses `transferAndCall` to\r\n   * send LINK which creates a request on the target oracle contract.\r\n   * Emits ChainlinkRequested event.\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param req The initialized Chainlink Request\r\n   * @param payment The amount of LINK to send for the request\r\n   * @return requestId The request ID\r\n   */\r\n  function sendOperatorRequestTo(\r\n    address oracleAddress,\r\n    Chainlink.Request memory req,\r\n    uint256 payment\r\n  ) internal returns (bytes32 requestId) {\r\n    uint256 nonce = s_requestCount;\r\n    s_requestCount = nonce + 1;\r\n    bytes memory encodedRequest = abi.encodeWithSelector(\r\n      OperatorInterface.operatorRequest.selector,\r\n      SENDER_OVERRIDE, // Sender value - overridden by onTokenTransfer by the requesting contract's address\r\n      AMOUNT_OVERRIDE, // Amount value - overridden by onTokenTransfer by the actual amount of LINK sent\r\n      req.id,\r\n      req.callbackFunctionId,\r\n      nonce,\r\n      OPERATOR_ARGS_VERSION,\r\n      req.buf.buf\r\n    );\r\n    return _rawRequest(oracleAddress, nonce, payment, encodedRequest);\r\n  }\r\n\r\n  /**\r\n   * @notice Make a request to an oracle\r\n   * @param oracleAddress The address of the oracle for the request\r\n   * @param nonce used to generate the request ID\r\n   * @param payment The amount of LINK to send for the request\r\n   * @param encodedRequest data encoded for request type specific format\r\n   * @return requestId The request ID\r\n   */\r\n  function _rawRequest(\r\n    address oracleAddress,\r\n    uint256 nonce,\r\n    uint256 payment,\r\n    bytes memory encodedRequest\r\n  ) private returns (bytes32 requestId) {\r\n    requestId = keccak256(abi.encodePacked(this, nonce));\r\n    s_pendingRequests[requestId] = oracleAddress;\r\n    emit ChainlinkRequested(requestId);\r\n    require(s_link.transferAndCall(oracleAddress, payment, encodedRequest), \"unable to transferAndCall to oracle\");\r\n  }\r\n\r\n  /**\r\n   * @notice Allows a request to be cancelled if it has not been fulfilled\r\n   * @dev Requires keeping track of the expiration value emitted from the oracle contract.\r\n   * Deletes the request from the `pendingRequests` mapping.\r\n   * Emits ChainlinkCancelled event.\r\n   * @param requestId The request ID\r\n   * @param payment The amount of LINK sent for the request\r\n   * @param callbackFunc The callback function specified for the request\r\n   * @param expiration The time of the expiration for the request\r\n   */\r\n  function cancelChainlinkRequest(\r\n    bytes32 requestId,\r\n    uint256 payment,\r\n    bytes4 callbackFunc,\r\n    uint256 expiration\r\n  ) internal {\r\n    OperatorInterface requested = OperatorInterface(s_pendingRequests[requestId]);\r\n    delete s_pendingRequests[requestId];\r\n    emit ChainlinkCancelled(requestId);\r\n    requested.cancelOracleRequest(requestId, payment, callbackFunc, expiration);\r\n  }\r\n\r\n  /**\r\n   * @notice the next request count to be used in generating a nonce\r\n   * @dev starts at 1 in order to ensure consistent gas cost\r\n   * @return returns the next request count to be used in a nonce\r\n   */\r\n  function getNextRequestCount() internal view returns (uint256) {\r\n    return s_requestCount;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle address\r\n   * @param oracleAddress The address of the oracle contract\r\n   */\r\n  function setChainlinkOracle(address oracleAddress) internal {\r\n    s_oracle = OperatorInterface(oracleAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the LINK token address\r\n   * @param linkAddress The address of the LINK token contract\r\n   */\r\n  function setChainlinkToken(address linkAddress) internal {\r\n    s_link = LinkTokenInterface(linkAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the Chainlink token address for the public\r\n   * network as given by the Pointer contract\r\n   */\r\n  function setPublicChainlinkToken() internal {\r\n    setChainlinkToken(PointerInterface(LINK_TOKEN_POINTER).getAddress());\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the LINK token\r\n   * @return The address of the LINK token\r\n   */\r\n  function chainlinkTokenAddress() internal view returns (address) {\r\n    return address(s_link);\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves the stored address of the oracle contract\r\n   * @return The address of the oracle contract\r\n   */\r\n  function chainlinkOracleAddress() internal view returns (address) {\r\n    return address(s_oracle);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows for a request which was created on another contract to be fulfilled\r\n   * on this contract\r\n   * @param oracleAddress The address of the oracle contract that will fulfill the request\r\n   * @param requestId The request ID used for the response\r\n   */\r\n  function addChainlinkExternalRequest(address oracleAddress, bytes32 requestId) internal notPendingRequest(requestId) {\r\n    s_pendingRequests[requestId] = oracleAddress;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle and LINK token contracts with the addresses resolved by ENS\r\n   * @dev Accounts for subnodes having different resolvers\r\n   * @param ensAddress The address of the ENS contract\r\n   * @param node The ENS node hash\r\n   */\r\n  function useChainlinkWithENS(address ensAddress, bytes32 node) internal {\r\n    s_ens = ENSInterface(ensAddress);\r\n    s_ensNode = node;\r\n    bytes32 linkSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_TOKEN_SUBNAME));\r\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(linkSubnode));\r\n    setChainlinkToken(resolver.addr(linkSubnode));\r\n    updateChainlinkOracleWithENS();\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the stored oracle contract with the address resolved by ENS\r\n   * @dev This may be called on its own as long as `useChainlinkWithENS` has been called previously\r\n   */\r\n  function updateChainlinkOracleWithENS() internal {\r\n    bytes32 oracleSubnode = keccak256(abi.encodePacked(s_ensNode, ENS_ORACLE_SUBNAME));\r\n    ENSResolver_Chainlink resolver = ENSResolver_Chainlink(s_ens.resolver(oracleSubnode));\r\n    setChainlinkOracle(resolver.addr(oracleSubnode));\r\n  }\r\n\r\n  /**\r\n   * @notice Ensures that the fulfillment is valid for this contract\r\n   * @dev Use if the contract developer prefers methods instead of modifiers for validation\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  function validateChainlinkCallback(bytes32 requestId)\r\n    internal\r\n    recordChainlinkFulfillment(requestId)\r\n  // solhint-disable-next-line no-empty-blocks\r\n  {\r\n\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the sender is not the oracle of the request.\r\n   * Emits ChainlinkFulfilled event.\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier recordChainlinkFulfillment(bytes32 requestId) {\r\n    require(msg.sender == s_pendingRequests[requestId], \"Source must be the oracle of the request\");\r\n    delete s_pendingRequests[requestId];\r\n    emit ChainlinkFulfilled(requestId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the request is already pending\r\n   * @param requestId The request ID for fulfillment\r\n   */\r\n  modifier notPendingRequest(bytes32 requestId) {\r\n    require(s_pendingRequests[requestId] == address(0), \"Request is already pending\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n// File contracts/Math/BokkyPooBahsDateTimeLibrary.sol\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.01\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\nlibrary BokkyPooBahsDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        require(year >= 1970);\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) internal pure returns (bool valid) {\r\n        if (year >= 1970 && month > 0 && month <= 12) {\r\n            uint daysInMonth = _getDaysInMonth(year, month);\r\n            if (day > 0 && day <= daysInMonth) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (bool valid) {\r\n        if (isValidDate(year, month, day)) {\r\n            if (hour < 24 && minute < 60 && second < 60) {\r\n                valid = true;\r\n            }\r\n        }\r\n    }\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        (uint year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        (uint year, uint month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        (year,,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        (,month,) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        (,,day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        (uint year, uint month, uint day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear,,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear,,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        (uint fromYear, uint fromMonth,) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (uint toYear, uint toMonth,) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Math/BokkyPooBahsDateTimeContract.sol\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// BokkyPooBah's DateTime Library v1.00 - Contract Instance\r\n//\r\n// A gas-efficient Solidity date and time library\r\n//\r\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018.\r\n//\r\n// GNU Lesser General Public License 3.0\r\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract BokkyPooBahsDateTimeContract {\r\n    uint public constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint public constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint public constant SECONDS_PER_MINUTE = 60;\r\n    int public constant OFFSET19700101 = 2440588;\r\n\r\n    uint public constant DOW_MON = 1;\r\n    uint public constant DOW_TUE = 2;\r\n    uint public constant DOW_WED = 3;\r\n    uint public constant DOW_THU = 4;\r\n    uint public constant DOW_FRI = 5;\r\n    uint public constant DOW_SAT = 6;\r\n    uint public constant DOW_SUN = 7;\r\n\r\n    function _now() public view returns (uint timestamp) {\r\n        timestamp = block.timestamp;\r\n    }\r\n    function _nowDateTime() public view returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(block.timestamp);\r\n    }\r\n    function _daysFromDate(uint year, uint month, uint day) public pure returns (uint _days) {\r\n        return BokkyPooBahsDateTimeLibrary._daysFromDate(year, month, day);\r\n    }\r\n    function _daysToDate(uint _days) public pure returns (uint year, uint month, uint day) {\r\n        return BokkyPooBahsDateTimeLibrary._daysToDate(_days);\r\n    }\r\n    function timestampFromDate(uint year, uint month, uint day) public pure returns (uint timestamp) {\r\n        return BokkyPooBahsDateTimeLibrary.timestampFromDate(year, month, day);\r\n    }\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) public pure returns (uint timestamp) {\r\n        return BokkyPooBahsDateTimeLibrary.timestampFromDateTime(year, month, day, hour, minute, second);\r\n    }\r\n    function timestampToDate(uint timestamp) public pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = BokkyPooBahsDateTimeLibrary.timestampToDate(timestamp);\r\n    }\r\n    function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day, hour, minute, second) = BokkyPooBahsDateTimeLibrary.timestampToDateTime(timestamp);\r\n    }\r\n\r\n    function isValidDate(uint year, uint month, uint day) public pure returns (bool valid) {\r\n        valid = BokkyPooBahsDateTimeLibrary.isValidDate(year, month, day);\r\n    }\r\n    function isValidDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) public pure returns (bool valid) {\r\n        valid = BokkyPooBahsDateTimeLibrary.isValidDateTime(year, month, day, hour, minute, second);\r\n    }\r\n    function isLeapYear(uint timestamp) public pure returns (bool leapYear) {\r\n        leapYear = BokkyPooBahsDateTimeLibrary.isLeapYear(timestamp);\r\n    }\r\n    function _isLeapYear(uint year) public pure returns (bool leapYear) {\r\n        leapYear = BokkyPooBahsDateTimeLibrary._isLeapYear(year);\r\n    }\r\n    function isWeekDay(uint timestamp) public pure returns (bool weekDay) {\r\n        weekDay = BokkyPooBahsDateTimeLibrary.isWeekDay(timestamp);\r\n    }\r\n    function isWeekEnd(uint timestamp) public pure returns (bool weekEnd) {\r\n        weekEnd = BokkyPooBahsDateTimeLibrary.isWeekEnd(timestamp);\r\n    }\r\n\r\n    function getDaysInMonth(uint timestamp) public pure returns (uint daysInMonth) {\r\n        daysInMonth = BokkyPooBahsDateTimeLibrary.getDaysInMonth(timestamp);\r\n    }\r\n    function _getDaysInMonth(uint year, uint month) public pure returns (uint daysInMonth) {\r\n        daysInMonth = BokkyPooBahsDateTimeLibrary._getDaysInMonth(year, month);\r\n    }\r\n    function getDayOfWeek(uint timestamp) public pure returns (uint dayOfWeek) {\r\n        dayOfWeek = BokkyPooBahsDateTimeLibrary.getDayOfWeek(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint year) {\r\n        year = BokkyPooBahsDateTimeLibrary.getYear(timestamp);\r\n    }\r\n    function getMonth(uint timestamp) public pure returns (uint month) {\r\n        month = BokkyPooBahsDateTimeLibrary.getMonth(timestamp);\r\n    }\r\n    function getDay(uint timestamp) public pure returns (uint day) {\r\n        day = BokkyPooBahsDateTimeLibrary.getDay(timestamp);\r\n    }\r\n    function getHour(uint timestamp) public pure returns (uint hour) {\r\n        hour = BokkyPooBahsDateTimeLibrary.getHour(timestamp);\r\n    }\r\n    function getMinute(uint timestamp) public pure returns (uint minute) {\r\n        minute = BokkyPooBahsDateTimeLibrary.getMinute(timestamp);\r\n    }\r\n    function getSecond(uint timestamp) public pure returns (uint second) {\r\n        second = BokkyPooBahsDateTimeLibrary.getSecond(timestamp);\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addYears(timestamp, _years);\r\n    }\r\n    function addMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMonths(timestamp, _months);\r\n    }\r\n    function addDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addDays(timestamp, _days);\r\n    }\r\n    function addHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addHours(timestamp, _hours);\r\n    }\r\n    function addMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addMinutes(timestamp, _minutes);\r\n    }\r\n    function addSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.addSeconds(timestamp, _seconds);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subYears(timestamp, _years);\r\n    }\r\n    function subMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMonths(timestamp, _months);\r\n    }\r\n    function subDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subDays(timestamp, _days);\r\n    }\r\n    function subHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subHours(timestamp, _hours);\r\n    }\r\n    function subMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subMinutes(timestamp, _minutes);\r\n    }\r\n    function subSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\r\n        newTimestamp = BokkyPooBahsDateTimeLibrary.subSeconds(timestamp, _seconds);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) public pure returns (uint _years) {\r\n        _years = BokkyPooBahsDateTimeLibrary.diffYears(fromTimestamp, toTimestamp);\r\n    }\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) public pure returns (uint _months) {\r\n        _months = BokkyPooBahsDateTimeLibrary.diffMonths(fromTimestamp, toTimestamp);\r\n    }\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) public pure returns (uint _days) {\r\n        _days = BokkyPooBahsDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\r\n    }\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) public pure returns (uint _hours) {\r\n        _hours = BokkyPooBahsDateTimeLibrary.diffHours(fromTimestamp, toTimestamp);\r\n    }\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) public pure returns (uint _minutes) {\r\n        _minutes = BokkyPooBahsDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\r\n    }\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) public pure returns (uint _seconds) {\r\n        _seconds = BokkyPooBahsDateTimeLibrary.diffSeconds(fromTimestamp, toTimestamp);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Staking/Owned.sol\r\n\r\n\r\n// https://docs.synthetix.io/contracts/Owned\r\ncontract Owned {\r\n    address public owner;\r\n    address public nominatedOwner;\r\n\r\n    constructor (address _owner) public {\r\n        require(_owner != address(0), \"Owner address cannot be 0\");\r\n        owner = _owner;\r\n        emit OwnerChanged(address(0), _owner);\r\n    }\r\n\r\n    function nominateNewOwner(address _owner) external onlyOwner {\r\n        nominatedOwner = _owner;\r\n        emit OwnerNominated(_owner);\r\n    }\r\n\r\n    function acceptOwnership() external {\r\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\r\n        emit OwnerChanged(owner, nominatedOwner);\r\n        owner = nominatedOwner;\r\n        nominatedOwner = address(0);\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\r\n        _;\r\n    }\r\n\r\n    event OwnerNominated(address newOwner);\r\n    event OwnerChanged(address oldOwner, address newOwner);\r\n}\r\n\r\n\r\n// File contracts/Uniswap/TransferHelper.sol\r\n\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Oracle/CPITrackerOracle.sol\r\n\r\n\r\n// ====================================================================\r\n// |     ______                   _______                             |\r\n// |    / _____________ __  __   / ____(_____  ____ _____  ________   |\r\n// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \\/ __ `/ __ \\/ ___/ _ \\  |\r\n// |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |\r\n// | /_/   /_/   \\__,_/_/|_|  /_/   /_/_/ /_/\\__,_/_/ /_/\\___/\\___/   |\r\n// |                                                                  |\r\n// ====================================================================\r\n// ========================= CPITrackerOracle =========================\r\n// ====================================================================\r\n// Pull in CPI data and track it in 2022 dollars\r\n\r\n// Frax Finance: https://github.com/FraxFinance\r\n\r\n// Primary Author(s)\r\n// Travis Moore: https://github.com/FortisFortuna\r\n\r\n// Reviewer(s) / Contributor(s)\r\n// Sam Kazemian: https://github.com/samkazemian\r\n// Rich Gee: https://github.com/zer0blockchain\r\n// Dennis: https://github.com/denett\r\n\r\n// References\r\n// https://docs.chain.link/docs/make-a-http-get-request/#api-consumer-example\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract CPITrackerOracle is Owned, ChainlinkClient {\r\n    using Chainlink for Chainlink.Request;\r\n  \r\n    // Core\r\n    BokkyPooBahsDateTimeContract public time_contract;\r\n    address public timelock_address;\r\n    address public bot_address;\r\n\r\n    // Data\r\n    uint256 public cpi_last = 28012600000; // Dec 2021 CPI-U, 280.126 * 100000000\r\n    uint256 public cpi_target = 28193300000; // Jan 2022 CPI-U, 281.933 * 100000000\r\n    uint256 public peg_price_last = 1e18; // Use currPegPrice(). Will always be in Dec 2021 dollars\r\n    uint256 public peg_price_target = 1006450668627688968; // Will always be in Dec 2021 dollars\r\n\r\n    // Chainlink\r\n    address public oracle; // Chainlink CPI oracle address\r\n    bytes32 public jobId; // Job ID for the CPI-U date\r\n    uint256 public fee; // LINK token fee\r\n\r\n    // Tracking\r\n    uint256 public stored_year = 2022; // Last time (year) the stored CPI data was updated\r\n    uint256 public stored_month = 1; // Last time (month) the stored CPI data was updated\r\n    uint256 public lastUpdateTime = 1644886800; // Last time the stored CPI data was updated.\r\n    uint256 public ramp_period = 28 * 86400; // Apply the CPI delta to the peg price over a set period\r\n    uint256 public future_ramp_period = 28 * 86400;\r\n    CPIObservation[] public cpi_observations; // Historical tracking of CPI data\r\n\r\n    // Safety\r\n    uint256 public max_delta_frac = 25000; // 2.5%. Max month-to-month CPI delta. \r\n\r\n    // Misc\r\n    string[13] public month_names; // English names of the 12 months\r\n    uint256 public fulfill_ready_day = 15; // Date of the month that CPI data is expected to by ready by\r\n\r\n\r\n    /* ========== STRUCTS ========== */\r\n    \r\n    struct CPIObservation {\r\n        uint256 result_year;\r\n        uint256 result_month;\r\n        uint256 cpi_target;\r\n        uint256 peg_price_target;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /* ========== MODIFIERS ========== */\r\n\r\n    modifier onlyByOwnGov() {\r\n        require(msg.sender == owner || msg.sender == timelock_address, \"Not owner or timelock\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyByOwnGovBot() {\r\n        require(msg.sender == owner || msg.sender == timelock_address || msg.sender == bot_address, \"Not owner, tlck, or bot\");\r\n        _;\r\n    }\r\n\r\n    /* ========== CONSTRUCTOR ========== */\r\n\r\n    constructor (\r\n        address _creator_address,\r\n        address _timelock_address\r\n    ) Owned(_creator_address) {\r\n        timelock_address = _timelock_address;\r\n\r\n        // Initialize the array. Cannot be done in the declaration\r\n        month_names = [\r\n            '',\r\n            'January',\r\n            'February',\r\n            'March',\r\n            'April',\r\n            'May',\r\n            'June',\r\n            'July',\r\n            'August',\r\n            'September',\r\n            'October',\r\n            'November',\r\n            'December'\r\n        ];\r\n\r\n        // CPI [Ethereum]\r\n        // =================================\r\n        setPublicChainlinkToken();\r\n        time_contract = BokkyPooBahsDateTimeContract(0x90503D86E120B3B309CEBf00C2CA013aB3624736);\r\n        oracle = 0x049Bd8C3adC3fE7d3Fc2a44541d955A537c2A484;\r\n        jobId = \"74295b9df3264781bf904d9e596a2e57\";\r\n        fee = 1e18; // 1 LINK\r\n\r\n        // CPI [Polygon Mainnet]\r\n        // =================================\r\n        // setChainlinkToken(0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39);\r\n        // time_contract = BokkyPooBahsDateTimeContract(0x998da4fCB229Db1AA84395ef6f0c6be6Ef3dbE58);\r\n        // oracle = 0x9B44870bcc35734c08e40F847cC068c0bA618194;\r\n        // jobId = \"8107f18343a24980b2fe7d3c8f32630f\";\r\n        // fee = 1e17; // 0.1 LINK\r\n\r\n        // CPI [Polygon Mumbai]\r\n        // =================================\r\n        // setChainlinkToken(0x326C977E6efc84E512bB9C30f76E30c160eD06FB);\r\n        // time_contract = BokkyPooBahsDateTimeContract(0x2Dd1B4D4548aCCeA497050619965f91f78b3b532);\r\n        // oracle = 0x3c30c5c415B2410326297F0f65f5Cbb32f3aefCc;\r\n        // jobId = \"32c3e7b12fe44665a4e2bb87aa9779af\";\r\n        // fee = 1e17; // 0.1 LINK\r\n\r\n        // Add the first observation\r\n        cpi_observations.push(CPIObservation(\r\n            2021,\r\n            12,\r\n            cpi_last,\r\n            peg_price_last,\r\n            1642208400 // Dec data observed on Jan 15 2021\r\n        ));\r\n\r\n        // Add the second observation\r\n        cpi_observations.push(CPIObservation(\r\n            2022,\r\n            1,\r\n            cpi_target,\r\n            peg_price_target,\r\n            1644886800 // Jan data observed on Feb 15 2022\r\n        ));\r\n    }\r\n\r\n    /* ========== VIEWS ========== */\r\n    function upcomingCPIParams() public view returns (\r\n        uint256 upcoming_year,\r\n        uint256 upcoming_month, \r\n        uint256 upcoming_timestamp\r\n    ) {\r\n        if (stored_month == 12) {\r\n            upcoming_year = stored_year + 1;\r\n            upcoming_month = 1;\r\n        }\r\n        else {\r\n            upcoming_year = stored_year;\r\n            upcoming_month = stored_month + 1;\r\n        }\r\n\r\n        // Data is usually released by the 15th day of the next month (fulfill_ready_day)\r\n        // https://www.usinflationcalculator.com/inflation/consumer-price-index-release-schedule/\r\n        upcoming_timestamp = time_contract.timestampFromDate(upcoming_year, upcoming_month, fulfill_ready_day);\r\n    }\r\n\r\n    // Display the upcoming CPI month\r\n    function upcomingSerie() external view returns (string memory serie_name) {\r\n        // Get the upcoming CPI params\r\n        (uint256 upcoming_year, uint256 upcoming_month, ) = upcomingCPIParams();\r\n\r\n        // Convert to a string\r\n        return string(abi.encodePacked(\"CUSR0000SA0\", \" \", month_names[upcoming_month], \" \", Strings.toString(upcoming_year)));\r\n    }\r\n\r\n    // Delta between the current and previous peg prices\r\n    function currDeltaFracE6() public view returns (int256) {\r\n        return int256(((peg_price_target - peg_price_last) * 1e6) / peg_price_last);\r\n    }\r\n\r\n    // Absolute value of the delta between the current and previous peg prices\r\n    function currDeltaFracAbsE6() public view returns (uint256) {\r\n        int256 curr_delta_frac = currDeltaFracE6();\r\n        if (curr_delta_frac > 0) return uint256(curr_delta_frac);\r\n        else return uint256(-curr_delta_frac);\r\n    }\r\n\r\n    // Current peg price, accounting for the ramping\r\n    function currPegPrice() external view returns (uint256) {\r\n        uint256 elapsed_time = block.timestamp - lastUpdateTime;\r\n        if (elapsed_time >= ramp_period) {\r\n            return peg_price_target;\r\n        }\r\n        else {\r\n            // Calculate the fraction of the delta to use, based on the elapsed time\r\n            // Can be negative in case of deflation (that never happens right :])\r\n            int256 fractional_price_delta = (int256(peg_price_target - peg_price_last) * int256(elapsed_time)) / int256(ramp_period);\r\n            return uint256(int256(peg_price_last) + int256(fractional_price_delta));\r\n        }\r\n    }\r\n\r\n    /* ========== MUTATIVE ========== */\r\n\r\n    // Fetch the CPI data from the Chainlink oracle\r\n    function requestCPIData() external onlyByOwnGovBot returns (bytes32 requestId) \r\n    {\r\n        Chainlink.Request memory request = buildChainlinkRequest(jobId, address(this), this.fulfill.selector);\r\n\r\n        // Get the upcoming CPI params\r\n        (uint256 upcoming_year, uint256 upcoming_month, uint256 upcoming_timestamp) = upcomingCPIParams();\r\n\r\n        // Don't update too fast\r\n        require(block.timestamp >= upcoming_timestamp, \"Too early\");\r\n\r\n        request.add(\"serie\", \"CUSR0000SA0\"); // CPI-U: https://data.bls.gov/timeseries/CUSR0000SA0\r\n        request.add(\"month\", month_names[upcoming_month]);\r\n        request.add(\"year\", Strings.toString(upcoming_year)); \r\n        return sendChainlinkRequestTo(oracle, request, fee);\r\n    }\r\n\r\n    /**\r\n     * Callback function\r\n     */\r\n    //  Called by the Chainlink oracle\r\n    function fulfill(bytes32 _requestId, uint256 result) public recordChainlinkFulfillment(_requestId)\r\n    {\r\n        // Set the stored CPI and price to the old targets\r\n        cpi_last = cpi_target;\r\n        peg_price_last = peg_price_target;\r\n\r\n        // Set the target CPI and price based on the results\r\n        cpi_target = result;\r\n        peg_price_target = (peg_price_last * cpi_target) / cpi_last;\r\n\r\n        // Make sure the delta isn't too large\r\n        require(currDeltaFracAbsE6() <= max_delta_frac, \"Delta too high\");\r\n\r\n        // Update the timestamp\r\n        lastUpdateTime = block.timestamp;\r\n\r\n        // Update the year and month\r\n        (uint256 result_year, uint256 result_month, ) = upcomingCPIParams();\r\n        stored_year = result_year;\r\n        stored_month = result_month;\r\n\r\n        // Update the future ramp period, if applicable\r\n        // A ramp cannot be updated mid-month as it will mess up the last_price math;\r\n        ramp_period = future_ramp_period;\r\n\r\n        // Add the observation\r\n        cpi_observations.push(CPIObservation(\r\n            result_year,\r\n            result_month,\r\n            cpi_target,\r\n            peg_price_target,\r\n            block.timestamp\r\n        ));\r\n\r\n        emit CPIUpdated(result_year, result_month, result, peg_price_target, ramp_period);\r\n    }\r\n    \r\n    /* ========== RESTRICTED FUNCTIONS ========== */\r\n\r\n    function setTimelock(address _new_timelock_address) external onlyByOwnGov {\r\n        timelock_address = _new_timelock_address;\r\n    }\r\n\r\n    function setBot(address _new_bot_address) external onlyByOwnGov {\r\n        bot_address = _new_bot_address;\r\n    }\r\n\r\n    function setMaxDeltaFrac(uint256 _max_delta_frac) external onlyByOwnGov {\r\n        max_delta_frac = _max_delta_frac; \r\n    }\r\n\r\n    function setFulfillReadyDay(uint256 _fulfill_ready_day) external onlyByOwnGov {\r\n        fulfill_ready_day = _fulfill_ready_day; \r\n    }\r\n\r\n    function setFutureRampPeriod(uint256 _future_ramp_period) external onlyByOwnGov {\r\n        future_ramp_period = _future_ramp_period; // In sec\r\n    }\r\n\r\n    // Mainly for recovering LINK\r\n    function recoverERC20(address tokenAddress, uint256 tokenAmount) external onlyByOwnGov {\r\n        // Only the owner address can ever receive the recovery withdrawal\r\n        TransferHelper.safeTransfer(tokenAddress, owner, tokenAmount);\r\n    }\r\n\r\n    /* ========== EVENTS ========== */\r\n    \r\n    event CPIUpdated(uint256 year, uint256 month, uint256 result, uint256 peg_price_target, uint256 ramp_period);\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_creator_address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_timelock_address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"peg_price_target\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ramp_period\",\"type\":\"uint256\"}],\"name\":\"CPIUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"name\":\"ChainlinkRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bot_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cpi_last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cpi_observations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result_year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"result_month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cpi_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"peg_price_target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cpi_target\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currDeltaFracAbsE6\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currDeltaFracE6\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currPegPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"name\":\"fulfill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fulfill_ready_day\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"future_ramp_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"jobId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"max_delta_frac\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"month_names\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peg_price_last\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peg_price_target\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ramp_period\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestCPIData\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_bot_address\",\"type\":\"address\"}],\"name\":\"setBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fulfill_ready_day\",\"type\":\"uint256\"}],\"name\":\"setFulfillReadyDay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_future_ramp_period\",\"type\":\"uint256\"}],\"name\":\"setFutureRampPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max_delta_frac\",\"type\":\"uint256\"}],\"name\":\"setMaxDeltaFrac\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_new_timelock_address\",\"type\":\"address\"}],\"name\":\"setTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stored_month\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stored_year\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"time_contract\",\"outputs\":[{\"internalType\":\"contract BokkyPooBahsDateTimeContract\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timelock_address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upcomingCPIParams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"upcoming_year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upcoming_month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upcoming_timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"upcomingSerie\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"serie_name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CPITrackerOracle", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "100000", "ConstructorArguments": "000000000000000000000000a448833bece66fd8803ac0c390936c79b5fd6edf000000000000000000000000510b35338c8e3b53f12aa109c38995acd9127ae0", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://93a913ea1eae111e9b2d0eed6131193c2d26485ee16d61fd36908e0d67f39631"}]}