{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.2;\r\n\r\ncontract SOCToken {\r\n    /* This creates an array with all balances */\r\n    mapping (address => uint256) public balanceOf;\r\n\r\n    /* Initializes contract with initial supply tokens to the creator of the contract */\r\n    function SOCToken(\r\n        uint256 initialSupply\r\n        ) {\r\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\r\n    }\r\n\r\n    /* Send coins */\r\n    function transfer(address _to, uint256 _value) {\r\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\r\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\r\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\r\n        balanceOf[_to] += _value;                            // Add the same to the recipient\r\n    }\r\n}\r\n\r\n\r\ncontract SOCTokenSale {\r\n    address public beneficiary;\r\n    uint public fundingGoal; \r\n\tuint public amountRaised; \r\n\tuint public deadline; \r\n\tuint public price;\r\n    SOCToken public tokenReward;\r\n    mapping(address => uint256) public balanceOf;\r\n    bool fundingGoalReached = false;\r\n    uint softMarketingLimit = 25 * 1 ether;\t\r\n    event GoalReached(address beneficiary, uint amountRaised);\r\n    event FundTransfer(address backer, uint amount, bool isContribution);\r\n    bool crowdsaleClosed = false;\r\n\r\n    /* data structure to hold information about campaign contributors */\r\n\r\n    /*  at initialization, setup the owner */\r\n    function SOCTokenSale(\r\n        address ifSuccessfulSendTo,\r\n        uint fundingGoalInEthers,\r\n        uint durationInMinutes,\r\n        uint pricePerEther,\r\n        SOCToken addressOfTokenUsedAsReward\r\n    ) {\r\n        beneficiary = ifSuccessfulSendTo;\r\n        fundingGoal = fundingGoalInEthers * 1 ether;\r\n        deadline = now + durationInMinutes * 1 minutes;\r\n        price = 1 ether / pricePerEther;\r\n        tokenReward = SOCToken(addressOfTokenUsedAsReward);\r\n    }\r\n\r\n    /* The function without name is the default function that is called whenever anyone sends funds to a contract */\r\n    function () payable {\r\n        if (crowdsaleClosed) throw;\r\n        uint amount = msg.value;\r\n        balanceOf[msg.sender] = amount;\r\n        amountRaised += amount;\r\n        tokenReward.transfer(msg.sender, amount / price);\r\n        FundTransfer(msg.sender, amount, true);\r\n    }\r\n\r\n    modifier afterDeadline() { if (now >= deadline) _; }\r\n\r\n    /* checks if the goal or time limit has been reached and ends the campaign */\r\n    function checkGoalReached() afterDeadline {\r\n        if (amountRaised >= fundingGoal){\r\n            fundingGoalReached = true;\r\n            GoalReached(beneficiary, amountRaised);\r\n        }\r\n        crowdsaleClosed = true;\r\n    }\r\n\r\n\r\n    function withdrawal(uint amount) {\r\n        if (msg.sender == beneficiary) {\r\n            if (beneficiary.send(amount * 1 finney)) {\r\n    \t\t\tFundTransfer(beneficiary, amount * 1 finney, false);\r\n            }\r\n        }\r\n    }\t\r\n\t\r\n    function safeWithdrawal() afterDeadline {\r\n        if (amountRaised < softMarketingLimit) {\r\n            uint amount = balanceOf[msg.sender];\r\n            balanceOf[msg.sender] = 0;\r\n            if (amount > 0) {\r\n                if (msg.sender.send(amount)) {\r\n                    FundTransfer(msg.sender, amount, false);\r\n                } else {\r\n                    balanceOf[msg.sender] = amount;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (fundingGoalReached && beneficiary == msg.sender) {\r\n            if (beneficiary.send(this.balance)) {\r\n                FundTransfer(beneficiary, this.balance, false);\r\n            } else {\r\n                fundingGoalReached = false;\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"initialSupply\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"constructor\"}]", "ContractName": "SOCToken", "CompilerVersion": "v0.4.11+commit.68ef5810", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000007A3140", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://8178e3d2af971f2d0be5efd06acde233d74d4e37417448c0bc6766ee3b19a71f"}]}