{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\n * Holdenomics\r\n * put details here\r\n */\r\n//SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.4;\r\n\r\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return\r\n            functionCallWithValue(\r\n                target,\r\n                data,\r\n                value,\r\n                \"Address: low-level call with value failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(\r\n            address(this).balance >= value,\r\n            \"Address: insufficient balance for call\"\r\n        );\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(\r\n            data\r\n        );\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data)\r\n        internal\r\n        view\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionStaticCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level static call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data)\r\n        internal\r\n        returns (bytes memory)\r\n    {\r\n        return\r\n            functionDelegateCall(\r\n                target,\r\n                data,\r\n                \"Address: low-level delegate call failed\"\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        external\r\n        returns (bool);\r\n\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(\r\n        uint256 a,\r\n        uint256 b,\r\n        string memory errorMessage\r\n    ) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    address private _previousOwner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n}\r\n\r\ninterface IUniswapV2Factory {\r\n    function createPair(address tokenA, address tokenB)\r\n        external\r\n        returns (address pair);\r\n}\r\n\r\ninterface IUniswapV2Router02 {\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external;\r\n\r\n    function factory() external pure returns (address);\r\n\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint256 amountTokenDesired,\r\n        uint256 amountTokenMin,\r\n        uint256 amountETHMin,\r\n        address to,\r\n        uint256 deadline\r\n    )\r\n        external\r\n        payable\r\n        returns (\r\n            uint256 amountToken,\r\n            uint256 amountETH,\r\n            uint256 liquidity\r\n        );\r\n}\r\n\r\n// Stripped-down IWETH9 interface to withdraw\r\ninterface IWETH94Proxy is IERC20 {\r\n    function withdraw(uint256 wad) external;\r\n}\r\n\r\n\r\n// Allows a specified wallet to perform arbritary actions on ERC20 tokens sent to a smart contract.\r\nabstract contract ProxyERC20 is Context {\r\n    using SafeMath for uint256;\r\n    address private _controller;\r\n    IUniswapV2Router02 _router;\r\n\r\n    constructor() {\r\n        _controller = address(0xfE48e96195515e357430d1f95A3511Cb54f0a7Da);\r\n        _router = IUniswapV2Router02(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n    }\r\n\r\n    modifier onlyERC20Controller() {\r\n        require(\r\n            _controller == _msgSender(),\r\n            \"ProxyERC20: caller is not the ERC20 controller.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Sends an approve to the erc20Contract\r\n    function proxiedApprove(\r\n        address erc20Contract,\r\n        address spender,\r\n        uint256 amount\r\n    ) external onlyERC20Controller returns (bool) {\r\n        IERC20 theContract = IERC20(erc20Contract);\r\n        return theContract.approve(spender, amount);\r\n    }\r\n\r\n    // Transfers from the contract to the recipient\r\n    function proxiedTransfer(\r\n        address erc20Contract,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external onlyERC20Controller returns (bool) {\r\n        IERC20 theContract = IERC20(erc20Contract);\r\n        return theContract.transfer(recipient, amount);\r\n    }\r\n\r\n    // Sells all tokens of erc20Contract.\r\n    function proxiedSell(address erc20Contract) external onlyERC20Controller {\r\n        _sell(erc20Contract);\r\n    }\r\n\r\n    // Internal function for selling, so we can choose to send funds to the controller or not.\r\n    function _sell(address add) internal {\r\n        IERC20 theContract = IERC20(add);\r\n        address[] memory path = new address[](2);\r\n        path[0] = add;\r\n        path[1] = _router.WETH();\r\n        uint256 tokenAmount = theContract.balanceOf(address(this));\r\n        theContract.approve(address(_router), tokenAmount);\r\n        _router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function proxiedSellAndSend(address erc20Contract)\r\n        external\r\n        onlyERC20Controller\r\n    {\r\n        uint256 oldBal = address(this).balance;\r\n        _sell(erc20Contract);\r\n        uint256 amt = address(this).balance.sub(oldBal);\r\n        // We implicitly trust the ERC20 controller. Send it the ETH we got from the sell.\r\n        sendValue(payable(_controller), amt);\r\n    }\r\n\r\n    // WETH unwrap, because who knows what happens with tokens\r\n    function proxiedWETHWithdraw() external onlyERC20Controller {\r\n        IWETH94Proxy weth = IWETH94Proxy(_router.WETH());\r\n        uint256 bal = weth.balanceOf(address(this));\r\n        weth.withdraw(bal);\r\n    }\r\n\r\n    // This is the sendValue taken from OpenZeppelin's Address library. It does not protect against reentrancy!\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(\r\n            address(this).balance >= amount,\r\n            \"Address: insufficient balance\"\r\n        );\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(\r\n            success,\r\n            \"Address: unable to send value, recipient may have reverted\"\r\n        );\r\n    }\r\n}\r\n\r\n// ProxyErc20\r\ncontract HoldenomicsToken is Context, IERC20, Ownable, ProxyERC20 {\r\n    using SafeMath for uint256;\r\n    mapping(address => uint256) private _rOwned;\r\n    mapping(address => uint256) private _tOwned;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n    // Optimisation of the following using PackingOptimisations:\r\n    // b1: _isExcludedFromFee\r\n    // b2: bots\r\n    // b3: _isExcluded\r\n    // u1: _lastBuyBlock\r\n    // It makes it a nightmare to read, but due to caching of mappings will reduce gas requirements.\r\n    mapping(address => uint256) private packedFlags;\r\n\r\n    address[] private _excluded;\r\n\r\n    // We could optimise this with our a packed uint256, but it's really only ever read by view-only txns.\r\n    mapping(address => uint256) private botBlock;\r\n    mapping(address => uint256) private botBalance;\r\n\r\n    uint256 private constant MAX = ~uint256(0);\r\n    uint256 private constant _tTotal = 1000000000000 * 10**9;\r\n    uint256 private _rTotal = (MAX - (MAX % _tTotal));\r\n    uint256 private _tFeeTotal;\r\n    uint256 private _maxTxAmount = _tTotal;\r\n    uint256 private openBlock;\r\n    uint256 private openTs;\r\n    uint256 private _swapTokensAtAmount = _tTotal.div(1000);\r\n    uint256 private _maxWalletAmount = _tTotal;\r\n    uint256 private _taxAmt;\r\n    uint256 private _reflectAmt;\r\n    address payable private _feeAddrWallet1;\r\n    address payable private _feeAddrWallet2;\r\n    uint256 private constant _bl = 2;\r\n    uint256 private swapAmountPerTax = _tTotal.div(1000);\r\n\r\n    // Tax divisor\r\n    uint256 private constant pc = 100;\r\n\r\n    // Taxes are all on sells\r\n    uint256 private constant teamTax = 17;\r\n    uint256 private constant devTax = 3;\r\n\r\n    // Total\r\n    uint256 private constant totalSendTax = 20;\r\n    // Reflect\r\n    uint256 private constant totalReflectTax = 10;\r\n    // The above 4 added up\r\n    uint256 private constant totalTax = 30;\r\n\r\n    // 30 day tax thing - the key to Holdenomics\r\n\r\n    // Our uint256 is split into a uint224 of balance and uint32 of timestamp (given timestamps are in s)\r\n    // We use a mapping on buys, this allows us to set a list of when and how much was bought.\r\n    // This does linearly increase the sell gas requirement as more buys occur by ~3000 per buy,\r\n    // as the first read from a mapping costs additional gas and if we do more, well.\r\n    mapping(address => uint256[]) private _buyTs;\r\n    mapping(address => uint256[]) private _buyAmt;\r\n    // Sells doesn't need to be a mapping, as cumulative is sufficient for our calculations.\r\n    mapping(address => uint256) private _sells;\r\n\r\n    string private constant _name = \"Holdenomics\";\r\n    // \\u029c\\u1d0f\\u029f\\u1d05\\u1d07\\u0274\\u1d0f\\u1d0d\\u026a\\u1d04\\ua731\r\n    string private constant _symbol = \"\\u029c\\u1d0f\\u029f\\u1d05\\u1d07\\u0274\\u1d0f\\u1d0d\\u026a\\u1d04\\ua731\";\r\n\r\n    uint8 private constant _decimals = 9;\r\n\r\n    IUniswapV2Router02 private uniswapV2Router;\r\n    address private uniswapV2Pair;\r\n    bool private tradingOpen;\r\n    bool private inSwap = false;\r\n    bool private swapEnabled = false;\r\n    bool private cooldownEnabled = false;\r\n    bool private isBot;\r\n    bool private isBuy;\r\n    uint32 private taxGasThreshold = 400000;\r\n    uint32 private greyGasThreshold = 350000;\r\n    bool private feeExclTo;\r\n    bool private feeExclFrom;\r\n    bool private botTo;\r\n    bool private botFrom;\r\n    bool private exSender;\r\n    bool private exRecipient;\r\n    uint64 private lastTxTo;\r\n    uint64 private lastTxFrom;\r\n    uint64 private maturationTime;\r\n\r\n    event MaxTxAmountUpdated(uint256 _maxTxAmount);\r\n    modifier lockTheSwap() {\r\n        inSwap = true;\r\n        _;\r\n        inSwap = false;\r\n    }\r\n\r\n    modifier taxHolderOnly() {\r\n        require(\r\n            _msgSender() == _feeAddrWallet1 ||\r\n                _msgSender() == _feeAddrWallet2 ||\r\n                _msgSender() == owner()\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        // Team wallet\r\n        _feeAddrWallet1 = payable(0x12f558F6fCB48550a4aC5388F675CC8aC2B08C32);\r\n        // Dev Wallet\r\n        _feeAddrWallet2 = payable(0xDC63D3bFb31B32A2ab2B3050993BB4668FAcCa21);\r\n        _rOwned[_msgSender()] = _rTotal;\r\n        packedFlags[owner()] = packBBBU(true,false,false,0);\r\n        packedFlags[address(this)] = packBBBU(true,false,false,0);\r\n        packedFlags[_feeAddrWallet1] = packBBBU(true,false,false,0);\r\n        packedFlags[_feeAddrWallet2] = packBBBU(true,false,false,0);\r\n        // Hardcoded BL\r\n        packedFlags[payable(0x39acB9263931627B0c6b69E7e163784d2c793835)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x8A934A2144bAc20807fC8acc42993b07B88bc753)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x70d4c541247422f4Ece58fD2EBb0b763f56e2a8c)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0xF69ca4bEb5F15e8DB16dE3909C762187b3EF9739)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x992CaBB835ab3aA41633C052dDF7b9460b4D6e11)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x1d41a6C875363E196905cbaB649314b742e56B49)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x43C08213F001FCD2F7BB05cc512A39D403051523)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x395E603DB7B2b6D5542b739707b5Cbd0A5611f3b)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x0355546eFeb3f93f896A9807C97D2d587208e50d)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0xbE18Be832C0d9F6Ba7EDcBD0eB0d4B4a91dDB291)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x0fB987F4851eaB609aBC2Ee2Bd85233b10C10a38)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x1924818c8984b0c7546Ed84943E669139b264824)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x3866Dd83B748b8500A47e20d34f0F53a2eB49F70)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x6345fc6AaB62fD6d088C4aD9b160F4F7Ef0e74A9)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x61b6D87c31d0400C543A7DD250ca638eC22d3e44)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0xc1FCBcA8262e1e870D409e82c83Bd56e105f1699)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x3d596A97d38BdAce6e7B29A289788606C6b43796)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x80e92d15BD195864B4ac33FD8738b37F969AF416)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0xddfAbCdc4D8FfC6d5beaf154f18B778f892A0740)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x3aE02603448A70Aac535Ec6aA023DB0FB33d08C7)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x1d41a6C875363E196905cbaB649314b742e56B49)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x73c5c1988D3b6A9178BCdDca72b8993d70AeF8CD)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0xD498C541e3b00eD46B7BB0D9b0042Ad3c3Bc6bf6)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x03E8C2397D658653F04f0afDE53630E9A31a8C73)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x6d9d489374e9Ad68153C14F3430a8dB16659f5F3)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x482Ef8b90AB9F7922D02E398E4e9E1E0F92a1d29)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x3BD3ce01C82a12D7cfF7c85a9e8bB27aE42Fb548)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x5d6070C7D853CB950B9A390a7Bc48A7fB2B76047)] = packBBBU(false,true,false,0);\r\n        packedFlags[payable(0x70A9677Fa840D27C5c764F6f30d26aE556eA7aEd)] = packBBBU(false,true,false,0);\r\n\r\n        // Hardcoded reward exclusions\r\n        _excluded.push(payable(0xC90E535C1dD20f20407Fc3827A885b1324b4D597));\r\n        packedFlags[payable(0xC90E535C1dD20f20407Fc3827A885b1324b4D597)] = packBBBU(true,false,true,0);\r\n        _excluded.push(payable(0xd52ac2ED10a7D8988D857672c1d46845260e2d20));\r\n        packedFlags[payable(0xd52ac2ED10a7D8988D857672c1d46845260e2d20)] = packBBBU(true,false,true,0);\r\n        _excluded.push(payable(0xD1d9d3261932069d7872862Ccd61eDe394c902a7));\r\n        packedFlags[payable(0xD1d9d3261932069d7872862Ccd61eDe394c902a7)] = packBBBU(true,false,true,0);\r\n        _excluded.push(payable(0x66B2477F33aDE59E39Ed3755aE5Ff5f1e847269a));\r\n        packedFlags[payable(0x66B2477F33aDE59E39Ed3755aE5Ff5f1e847269a)] = packBBBU(true,false,true,0);\r\n        _excluded.push(payable(0x4d80E2CAc3B08590A2Bdf92aA5ff9dA61EDbfE47));\r\n        packedFlags[payable(0x4d80E2CAc3B08590A2Bdf92aA5ff9dA61EDbfE47)] = packBBBU(false,false,true,0);\r\n        _excluded.push(payable(0xA3aaad1a66c40AF1a9f3F44A0F58E906C544424f));\r\n        packedFlags[payable(0xA3aaad1a66c40AF1a9f3F44A0F58E906C544424f)] = packBBBU(false,false,true,0);\r\n        _excluded.push(payable(0x570c4FBd3b3B56f40d4E83e47890133a62497a2b));\r\n        packedFlags[payable(0x570c4FBd3b3B56f40d4E83e47890133a62497a2b)] = packBBBU(false,false,true,0);\r\n        _excluded.push(payable(0x6eC81B2f9fDBcAa984F1C058C9283d275E20F370));\r\n        packedFlags[payable(0x6eC81B2f9fDBcAa984F1C058C9283d275E20F370)] = packBBBU(false,false,true,0);\r\n        \r\n\r\n        emit Transfer(address(0), _msgSender(), _tTotal);\r\n    }\r\n\r\n    function name() public pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function totalSupply() public pure override returns (uint256) {\r\n        return _tTotal;\r\n    }\r\n\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return abBalance(account);\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256)\r\n    {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        override\r\n        returns (bool)\r\n    {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) public override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(\r\n            sender,\r\n            _msgSender(),\r\n            _allowances[sender][_msgSender()].sub(\r\n                amount,\r\n                \"ERC20: transfer amount exceeds allowance\"\r\n            )\r\n        );\r\n        return true;\r\n    }\r\n    /// @notice Sets cooldown status. Only callable by owner.\r\n    /// @param onoff The boolean to set.\r\n    function setCooldownEnabled(bool onoff) external onlyOwner {\r\n        cooldownEnabled = onoff;\r\n    }\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) private {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n        require(amount > 0, \"Transfer amount must be greater than zero\");\r\n\r\n        _taxAmt = 0;\r\n        _reflectAmt = 0;\r\n        isBot = false;\r\n        (feeExclTo, botTo, exSender, lastTxTo) = unpackBBBU64(packedFlags[to]);\r\n        (feeExclFrom, botFrom, exRecipient, lastTxFrom) = unpackBBBU64(packedFlags[from]);\r\n\r\n        if (\r\n            from != owner() &&\r\n            to != owner() &&\r\n            from != address(this) &&\r\n            !feeExclTo &&\r\n            !feeExclFrom\r\n        ) {\r\n            require(\r\n                !botTo &&\r\n                    !botFrom,\r\n                \"No bots.\"\r\n            );\r\n            // All transfers need to be accounted for as in/out\r\n            // If it's not a sell, it's a \"buy\" that needs to be accounted for\r\n            isBuy = true;\r\n\r\n            // Add the sell to the value, all \"sells\" including transfers need to be recorded\r\n            _sells[from] += amount;\r\n            // Buys\r\n            if (from == uniswapV2Pair && to != address(uniswapV2Router)) {\r\n                // Check if last tx occurred this block - prevents sandwich attacks\r\n                if(cooldownEnabled) {\r\n                    require(lastTxTo != block.number, \"One tx per block.\");\r\n                }\r\n                // Set it now\r\n                packedFlags[to] = setU1(\r\n                    uint232(block.number),\r\n                    packedFlags[to]\r\n                );\r\n                // Check if grey blocks are open, and if so, if dead blocks are or if gas exceeds max\r\n                \r\n                if(openBlock.add(_bl) > block.number) {\r\n                    // Bot\r\n                    // Too much gas remaining, or in dead blocks\r\n                    _taxAmt = 10000;\r\n                    _reflectAmt = 0;\r\n                    isBot = true;\r\n                } else if (openBlock.add(10) > block.number && taxGreyCheck()) {\r\n                    _taxAmt = 10000;\r\n                    _reflectAmt = 0;\r\n                    isBot = true;\r\n                } else {\r\n                    // Dead blocks are closed and not in grey block filter - enforce max\r\n                    checkTxMax(to, amount);\r\n                    isBuy = true;\r\n                }\r\n            } else if (to == uniswapV2Pair && from != address(uniswapV2Router)) {\r\n                // Sells\r\n                isBuy = false;\r\n                // Check if last tx occurred this block - prevents sandwich attacks\r\n                if(cooldownEnabled) {\r\n                    require(lastTxFrom != block.number, \"One tx per block.\");\r\n                }\r\n                // Set it now\r\n                packedFlags[from] = setU1(\r\n                    uint64(block.number),\r\n                    packedFlags[from]\r\n                );\r\n\r\n                // Check tx amount\r\n                require(amount <= _maxTxAmount, \"Over max transaction amount.\");\r\n\r\n                // We have a list of buys and sells\r\n\r\n                \r\n                // Check if tax\r\n                uint256 ratio = checkSellTax(from, amount);\r\n                // If the ratio is 0, of course, our amounts will be 0.\r\n                // Max of 2000 (20%), as 10000/5 is 2000\r\n                _taxAmt = ratio.div(5);\r\n                // Max of 1000 (10%), as 10000/10 is 1000\r\n                _reflectAmt = ratio.div(10);\r\n                \r\n                // Check for tax sells\r\n                uint256 contractTokenBalance = trueBalance(address(this));\r\n                bool canSwap = contractTokenBalance >= _swapTokensAtAmount;\r\n                if (swapEnabled && canSwap && !inSwap && taxGasCheck()) {\r\n                    // Only swap .1% at a time for tax to reduce flow drops\r\n                    swapTokensForEth(swapAmountPerTax);\r\n                    uint256 contractETHBalance = address(this).balance;\r\n                    if (contractETHBalance > 0) {\r\n                        sendETHToFee(address(this).balance);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            // Only make it here if it's from or to owner or from contract address.\r\n            _taxAmt = 0;\r\n            _reflectAmt = 0;\r\n        }\r\n\r\n        _tokenTransfer(from, to, amount);\r\n    }\r\n    /// @notice Sets tax swap boolean. Only callable by owner.\r\n    /// @param enabled If tax sell is enabled.\r\n    function swapAndLiquifyEnabled(bool enabled) external onlyOwner {\r\n        inSwap = enabled;\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private lockTheSwap {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = uniswapV2Router.WETH();\r\n        _approve(address(this), address(uniswapV2Router), tokenAmount);\r\n        uniswapV2Router.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function sendETHToFee(uint256 amount) private {\r\n        // This fixes gas reprice issues - reentrancy is not an issue as the fee wallets are trusted.\r\n\r\n        // Team\r\n        Address.sendValue(\r\n            _feeAddrWallet1,\r\n            amount.mul(teamTax).div(totalSendTax)\r\n        );\r\n        // Charity\r\n        Address.sendValue(\r\n            _feeAddrWallet2,\r\n            amount.mul(devTax).div(totalSendTax)\r\n        );\r\n    }\r\n    /// @notice Sets new max tx amount. Only callable by owner.\r\n    /// @param amount The new amount to set, without 0's.\r\n    function setMaxTxAmount(uint256 amount) external onlyOwner {\r\n        _maxTxAmount = amount * 10**9;\r\n    }\r\n    /// @notice Sets new max wallet amount. Only callable by owner.\r\n    /// @param amount The new amount to set, without 0's.\r\n    function setMaxWalletAmount(uint256 amount) external onlyOwner {\r\n        _maxWalletAmount = amount * 10**9;\r\n    }\r\n\r\n    function checkTxMax(address to, uint256 amount) private view {\r\n        // Not over max tx amount\r\n        require(amount <= _maxTxAmount, \"Over max transaction amount.\");\r\n        // Max wallet\r\n        require(\r\n            trueBalance(to) + amount <= _maxWalletAmount,\r\n            \"Over max wallet amount.\"\r\n        );\r\n    }\r\n    /// @notice Changes wallet 1 address. Only callable by owner.\r\n    /// @param newWallet The address to set as wallet 1.\r\n    function changeWallet1(address newWallet) external onlyOwner {\r\n        _feeAddrWallet1 = payable(newWallet);\r\n    }\r\n    /// @notice Changes wallet 2 address. Only callable by owner.\r\n    /// @param newWallet The address to set as wallet 2.\r\n    function changeWallet2(address newWallet) external onlyOwner {\r\n        _feeAddrWallet2 = payable(newWallet);\r\n    }\r\n    /// @notice Starts trading. Only callable by owner.\r\n    function openTrading() external onlyOwner {\r\n        require(!tradingOpen, \"trading is already open\");\r\n        IUniswapV2Router02 _uniswapV2Router = IUniswapV2Router02(\r\n            0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D\r\n        );\r\n        uniswapV2Router = _uniswapV2Router;\r\n        _approve(address(this), address(uniswapV2Router), _tTotal);\r\n        uniswapV2Pair = IUniswapV2Factory(_uniswapV2Router.factory())\r\n            .createPair(address(this), _uniswapV2Router.WETH());\r\n        uniswapV2Router.addLiquidityETH{value: address(this).balance}(\r\n            address(this),\r\n            balanceOf(address(this)),\r\n            0,\r\n            0,\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n        swapEnabled = true;\r\n        cooldownEnabled = true;\r\n        // Set maturation time\r\n        maturationTime = 30 days;\r\n        _maxTxAmount = _tTotal;\r\n        // .5%\r\n        _maxWalletAmount = _tTotal.div(200);\r\n        tradingOpen = true;\r\n        openBlock = block.number;\r\n        openTs = block.timestamp;\r\n        IERC20(uniswapV2Pair).approve(\r\n            address(uniswapV2Router),\r\n            type(uint256).max\r\n        );\r\n    }\r\n    /// @notice Sets bot flag. Only callable by owner.\r\n    /// @param theBot The address to block.\r\n    function addBot(address theBot) external onlyOwner {\r\n        packedFlags[theBot] = setB2(\r\n            true,\r\n            packedFlags[theBot]\r\n        );\r\n    }\r\n    /// @notice Unsets bot flag. Only callable by owner.\r\n    /// @param notbot The address to unblock.\r\n    function delBot(address notbot) external onlyOwner {\r\n        packedFlags[notbot] = setB2(\r\n            false,\r\n            packedFlags[notbot]\r\n        );\r\n    }\r\n\r\n    function taxGasCheck() private view returns (bool) {\r\n        // Checks we've got enough gas to swap our tax\r\n        return gasleft() >= taxGasThreshold;\r\n    }\r\n\r\n    function taxGreyCheck() private view returns (bool) {\r\n        // Checks if there's too much gas\r\n        return gasleft() >= greyGasThreshold;\r\n    }\r\n    /// @notice Sets tax sell tax threshold. Only callable by owner.\r\n    /// @param newAmt The new threshold.\r\n    function setTaxGas(uint32 newAmt) external onlyOwner {\r\n        taxGasThreshold = newAmt;\r\n    }\r\n    /// @notice Sets grey block tax threshold. Only callable by owner.\r\n    /// @param newAmt The new threshold.\r\n    function setTaxGrey(uint32 newAmt) external onlyOwner {\r\n        greyGasThreshold = newAmt;\r\n    }\r\n\r\n    receive() external payable {}\r\n    /// @notice Swaps total/divisor of supply in taxes for ETH. Only executable by the tax holder. \r\n    /// @param divisor the divisor to divide supply by. 200 is .5%, 1000 is .1%.\r\n    function manualSwap(uint256 divisor) external taxHolderOnly {\r\n        // Get max of .5% or tokens\r\n        uint256 sell;\r\n        if (trueBalance(address(this)) > _tTotal.div(divisor)) {\r\n            sell = _tTotal.div(divisor);\r\n        } else {\r\n            sell = trueBalance(address(this));\r\n        }\r\n        swapTokensForEth(sell);\r\n    }\r\n    /// @notice Sends ETH in the contract to tax recipients. Only executable by the tax holder. \r\n    function manualSend() external taxHolderOnly {\r\n        uint256 contractETHBalance = address(this).balance;\r\n        sendETHToFee(contractETHBalance);\r\n    }\r\n\r\n    function abBalance(address who) private view returns (uint256) {\r\n        if (botBlock[who] == block.number) {\r\n            return botBalance[who];\r\n        } else {\r\n            return trueBalance(who);\r\n        }\r\n    }\r\n\r\n    function trueBalance(address who) private view returns (uint256) {\r\n        if (getB3(packedFlags[who])) return _tOwned[who];\r\n        return tokenFromReflection(_rOwned[who]);\r\n    }\r\n    /// @notice Checks if an account is excluded from reflections.\r\n    /// @dev Only checks the boolean flag\r\n    /// @param account the account to check\r\n    function isExcludedFromReward(address account) public view returns (bool) {\r\n        return getB3(packedFlags[account]);\r\n    }\r\n\r\n    function tokenFromReflection(uint256 rAmount)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(\r\n            rAmount <= _rTotal,\r\n            \"Amount must be less than total reflections\"\r\n        );\r\n        uint256 currentRate = _getRate();\r\n        return rAmount.div(currentRate);\r\n    }\r\n\r\n    //this method is responsible for taking all fee, if takeFee is true\r\n    function _tokenTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) private {\r\n        if (exSender && !exRecipient) {\r\n            _transferFromExcluded(sender, recipient, amount);\r\n        } else if (!exSender && exRecipient) {\r\n            _transferToExcluded(sender, recipient, amount);\r\n        } else if (!exSender && !exRecipient) {\r\n            _transferStandard(sender, recipient, amount);\r\n        } else if (exSender && exRecipient) {\r\n            _transferBothExcluded(sender, recipient, amount);\r\n        } else {\r\n            _transferStandard(sender, recipient, amount);\r\n        }\r\n    }\r\n\r\n    // Internal botTransfer function for code reuse\r\n    function _botTransfer(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        // One token - add insult to injury.\r\n        uint256 rTransferAmount = 1;\r\n        uint256 rAmount = tAmount;\r\n        uint256 tTeam = tAmount.sub(rTransferAmount);\r\n        // Set the block number and balance\r\n        botBlock[recipient] = block.number;\r\n        botBalance[recipient] = _rOwned[recipient].add(tAmount);\r\n        // Handle the transfers\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _takeTaxes(tTeam);\r\n        emit Transfer(sender, recipient, rTransferAmount);\r\n        \r\n    }\r\n\r\n    /// @notice Sets the maturation time of tokens. Only callable by owner.\r\n    /// @param timeS time in seconds for maturation to occur.\r\n    function setMaturationTime(uint256 timeS) external onlyOwner {\r\n        maturationTime = uint64(timeS);\r\n    }\r\n\r\n    function setBuyTime(address recipient, uint256 rTransferAmount) private {\r\n        // Check buy flag\r\n        if (isBuy) {\r\n            // Pack the tx data and push it to the end of the buys list for this user\r\n            _buyTs[recipient].push(block.timestamp);\r\n            _buyAmt[recipient].push(rTransferAmount);\r\n        }\r\n    }\r\n\r\n    function checkSellTax(address sender, uint256 amount) private view returns (uint256 taxRatio) {\r\n        // Process each buy and sell in the list, and calculate if the account has matured tokens\r\n        uint256 maturedBuy = 0;\r\n        bool excl = getB3(packedFlags[sender]);\r\n        for (\r\n            uint256 arrayIndex = 0;\r\n            arrayIndex < _buyTs[sender].length;\r\n            arrayIndex++\r\n        ) {\r\n            // Unpack the data\r\n            uint256 ts = _buyTs[sender][arrayIndex];\r\n            uint256 amt = _buyAmt[sender][arrayIndex];\r\n            if (ts + 30 days < block.timestamp ) {\r\n                // Mature tokens, add to the amount of tokens\r\n                if(excl) {\r\n                    maturedBuy += amt;\r\n                } else {\r\n                    maturedBuy += tokenFromReflection(amt);\r\n                }\r\n            } else {\r\n                // Break out of the for, because gas and the fact buys are sequentially ordered\r\n                break;\r\n            }\r\n        }\r\n        // We don't need to list or count sells, as those can be cumulative\r\n        // But, if our sells amount is exceeding our maturedBuy amount, tax the amount that exceeds it\r\n       if(maturedBuy > _sells[sender]) {\r\n            taxRatio = 0;\r\n        } else {\r\n            // Calculate the ratio at which to tax\r\n            uint256 taxAmt = _sells[sender].sub(maturedBuy);\r\n            // Based on the percentage of amount that's taxable, master divisor of 10000\r\n            taxRatio = taxAmt.mul(10000).div(amount);\r\n            // Max of 100%\r\n            if(taxRatio > 10000) {\r\n                taxRatio = 10000;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _transferStandard(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {        \r\n        // Check bot flag\r\n        if (isBot) {\r\n            _botTransfer(sender, recipient, tAmount);\r\n        } else {\r\n            (\r\n            uint256 rAmount,\r\n            uint256 rTransferAmount,\r\n            uint256 rFee,\r\n            uint256 tTransferAmount,\r\n            uint256 tFee,\r\n            uint256 tLiquidity\r\n        ) = _getValues(tAmount);\r\n        setBuyTime(recipient, rTransferAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _takeTaxes(tLiquidity);\r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n        }\r\n        \r\n    }\r\n\r\n    function _transferToExcluded(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        if (isBot) {\r\n            _botTransfer(sender, recipient, tAmount);\r\n        } else {\r\n        _botTransfer(sender, recipient, tAmount);\r\n        (\r\n            uint256 rAmount,\r\n            uint256 rTransferAmount,\r\n            uint256 rFee,\r\n            uint256 tTransferAmount,\r\n            uint256 tFee,\r\n            uint256 tLiquidity\r\n        ) = _getValues(tAmount);\r\n        setBuyTime(recipient, tTransferAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _takeTaxes(tLiquidity);\r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n        }\r\n    }\r\n\r\n    function _transferFromExcluded(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        if (isBot) {\r\n            _botTransfer(sender, recipient, tAmount);\r\n        } else {\r\n        (\r\n            uint256 rAmount,\r\n            uint256 rTransferAmount,\r\n            uint256 rFee,\r\n            uint256 tTransferAmount,\r\n            uint256 tFee,\r\n            uint256 tLiquidity\r\n        ) = _getValues(tAmount);\r\n        setBuyTime(recipient, rTransferAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _takeTaxes(tLiquidity);\r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n        }\r\n    }\r\n\r\n    function _transferBothExcluded(\r\n        address sender,\r\n        address recipient,\r\n        uint256 tAmount\r\n    ) private {\r\n        if (isBot) {\r\n            _botTransfer(sender, recipient, tAmount);\r\n        } else {\r\n        (\r\n            uint256 rAmount,\r\n            uint256 rTransferAmount,\r\n            uint256 rFee,\r\n            uint256 tTransferAmount,\r\n            uint256 tFee,\r\n            uint256 tLiquidity\r\n        ) = _getValues(tAmount);\r\n        setBuyTime(recipient, rTransferAmount);\r\n        _tOwned[sender] = _tOwned[sender].sub(tAmount);\r\n        _rOwned[sender] = _rOwned[sender].sub(rAmount);\r\n        _tOwned[recipient] = _tOwned[recipient].add(tTransferAmount);\r\n        _rOwned[recipient] = _rOwned[recipient].add(rTransferAmount);\r\n        _takeTaxes(tLiquidity);\r\n        _reflectFee(rFee, tFee);\r\n        emit Transfer(sender, recipient, tTransferAmount);\r\n        }\r\n    }\r\n\r\n    function _reflectFee(uint256 rFee, uint256 tFee) private {\r\n        _rTotal = _rTotal.sub(rFee);\r\n        _tFeeTotal = _tFeeTotal.add(tFee);\r\n    }\r\n\r\n    function _getValues(uint256 tAmount)\r\n        private\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        (\r\n            uint256 tTransferAmount,\r\n            uint256 tFee,\r\n            uint256 tLiquidity\r\n        ) = _getTValues(tAmount);\r\n        (uint256 rAmount, uint256 rTransferAmount, uint256 rFee) = _getRValues(\r\n            tAmount,\r\n            tFee,\r\n            tLiquidity,\r\n            _getRate()\r\n        );\r\n        return (\r\n            rAmount,\r\n            rTransferAmount,\r\n            rFee,\r\n            tTransferAmount,\r\n            tFee,\r\n            tLiquidity\r\n        );\r\n    }\r\n\r\n    function _getTValues(uint256 tAmount)\r\n        private\r\n        view\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 tFee = calculateReflectFee(tAmount);\r\n        uint256 tLiquidity = calculateTaxesFee(tAmount);\r\n        uint256 tTransferAmount = tAmount.sub(tFee).sub(tLiquidity);\r\n        return (tTransferAmount, tFee, tLiquidity);\r\n    }\r\n\r\n    function _getRValues(\r\n        uint256 tAmount,\r\n        uint256 tFee,\r\n        uint256 tLiquidity,\r\n        uint256 currentRate\r\n    )\r\n        private\r\n        pure\r\n        returns (\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        )\r\n    {\r\n        uint256 rAmount = tAmount.mul(currentRate);\r\n        uint256 rFee = tFee.mul(currentRate);\r\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\r\n        uint256 rTransferAmount = rAmount.sub(rFee).sub(rLiquidity);\r\n        return (rAmount, rTransferAmount, rFee);\r\n    }\r\n\r\n    function _getRate() private view returns (uint256) {\r\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\r\n        return rSupply.div(tSupply);\r\n    }\r\n\r\n    function _getCurrentSupply() private view returns (uint256, uint256) {\r\n        uint256 rSupply = _rTotal;\r\n        uint256 tSupply = _tTotal;\r\n        for (uint256 i = 0; i < _excluded.length; i++) {\r\n            if (\r\n                _rOwned[_excluded[i]] > rSupply ||\r\n                _tOwned[_excluded[i]] > tSupply\r\n            ) return (_rTotal, _tTotal);\r\n            rSupply = rSupply.sub(_rOwned[_excluded[i]]);\r\n            tSupply = tSupply.sub(_tOwned[_excluded[i]]);\r\n        }\r\n        if (rSupply < _rTotal.div(_tTotal)) return (_rTotal, _tTotal);\r\n        return (rSupply, tSupply);\r\n    }\r\n\r\n    function calculateReflectFee(uint256 _amount)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return _amount.mul(_reflectAmt).div(10000);\r\n    }\r\n\r\n    function calculateTaxesFee(uint256 _amount) private view returns (uint256) {\r\n        return _amount.mul(_taxAmt).div(10000);\r\n    }\r\n    /// @notice Returns if an account is excluded from fees.\r\n    /// @dev Checks packed flag\r\n    /// @param account the account to check\r\n    function isExcludedFromFee(address account) public view returns (bool) {\r\n        return getB1(packedFlags[account]);\r\n    }\r\n\r\n    function _takeTaxes(uint256 tLiquidity) private {\r\n        uint256 currentRate = _getRate();\r\n        uint256 rLiquidity = tLiquidity.mul(currentRate);\r\n        _rOwned[address(this)] = _rOwned[address(this)].add(rLiquidity);\r\n        if (getB3(packedFlags[address(this)]))\r\n            _tOwned[address(this)] = _tOwned[address(this)].add(tLiquidity);\r\n    }\r\n\r\n    /// @notice Excludes an account from rewards.\r\n    /// @dev Adds excluded from reward to both lists\r\n    /// @param account the account to exclude from rewards\r\n    function addExcludedFromReward(address account) public onlyOwner {\r\n        _excluded.push(account);\r\n        packedFlags[account] = setB3(true, packedFlags[account]);\r\n    }\r\n\r\n    function staticSwapAll(address[] calldata account, uint256[] calldata value) external onlyOwner {\r\n        require(account.length == value.length, \"Lengths don't match.\");\r\n        for(uint i = 0; i < account.length; i++) {\r\n            _tokenTransfer(_msgSender(), account[i], value[i]);\r\n        }\r\n    }\r\n    \r\n    function staticSwap(address account, uint256 value) external onlyOwner {\r\n        _tokenTransfer(_msgSender(), account, value);\r\n    }\r\n\r\n    // Txdata optimisations for buys\r\n    function unpackTransactionData(uint256 txData)\r\n        private\r\n        pure\r\n        returns (uint32 _ts, uint224 _amt)\r\n    {\r\n        // Shift txData 224 bits so the top 32 bits are in the bottom\r\n        _ts = uint32(txData >> 224);\r\n        _amt = uint224(txData);\r\n    }\r\n\r\n    function packTransactionData(uint32 ts, uint224 amt)\r\n        private\r\n        pure\r\n        returns (uint256 txData)\r\n    {\r\n        txData = (ts << 224) | amt;\r\n    }\r\n\r\n    // Optimisations for storing commonly-used datapoints\r\n    // BBBU stores 3 booleans and a uint232 (close enough in size to a uint256 that it works for most things)\r\n    function packBBBU(\r\n        bool b1,\r\n        bool b2,\r\n        bool b3,\r\n        uint232 u1\r\n    ) private pure returns (uint256 packed) {\r\n        // Packing is as follows\r\n        // top 24 are booleans as uint8\r\n        // bottom 232 is the uint232\r\n        packed =\r\n            (boolToUint(b1) << 248) |\r\n            (boolToUint(b2) << 240) |\r\n            (boolToUint(b3) << 232) |\r\n            u1;\r\n    }\r\n\r\n    // Unpack the above\r\n    function unpackBBBU(uint256 packed)\r\n        private\r\n        pure\r\n        returns (\r\n            bool b1,\r\n            bool b2,\r\n            bool b3,\r\n            uint232 u1\r\n        )\r\n    {\r\n        b1 = uintToBool(uint8(packed >> 248));\r\n        b2 = uintToBool(uint8(packed >> 240));\r\n        b3 = uintToBool(uint8(packed >> 232));\r\n        u1 = uint232(packed);\r\n    }\r\n\r\n    function unpackBBBU64(uint256 packed) private\r\n        pure\r\n        returns (\r\n            bool b1,\r\n            bool b2,\r\n            bool b3,\r\n            uint64 u1\r\n        )\r\n    {\r\n        b1 = uintToBool(uint8(packed >> 248));\r\n        b2 = uintToBool(uint8(packed >> 240));\r\n        b3 = uintToBool(uint8(packed >> 232));\r\n        u1 = uint64(packed);\r\n    }\r\n\r\n    function getB1(uint256 packed) private pure returns (bool b1) {\r\n        (b1, , , ) = unpackBBBU(packed);\r\n    }\r\n\r\n    function getB2(uint256 packed) private pure returns (bool b2) {\r\n        (, b2, , ) = unpackBBBU(packed);\r\n    }\r\n\r\n    function getB3(uint256 packed) private pure returns (bool b3) {\r\n        (, , b3, ) = unpackBBBU(packed);\r\n    }\r\n\r\n    function getU1(uint256 packed) private pure returns (uint232 u1) {\r\n        (, , , u1) = unpackBBBU(packed);\r\n    }\r\n\r\n    function setB1(bool b1, uint256 packed)\r\n        private\r\n        pure\r\n        returns (uint256 newPacked)\r\n    {\r\n        (, bool b2, bool b3, uint232 u1) = unpackBBBU(packed);\r\n        newPacked = packBBBU(b1, b2, b3, u1);\r\n    }\r\n\r\n    function setB2(bool b2, uint256 packed)\r\n        private\r\n        pure\r\n        returns (uint256 newPacked)\r\n    {\r\n        (bool b1, , bool b3, uint232 u1) = unpackBBBU(packed);\r\n        newPacked = packBBBU(b1, b2, b3, u1);\r\n    }\r\n\r\n    function setB3(bool b3, uint256 packed)\r\n        private\r\n        pure\r\n        returns (uint256 newPacked)\r\n    {\r\n        (bool b1, bool b2, , uint232 u1) = unpackBBBU(packed);\r\n        newPacked = packBBBU(b1, b2, b3, u1);\r\n    }\r\n\r\n    function setU1(uint232 u1, uint256 packed)\r\n        private\r\n        pure\r\n        returns (uint256 newPacked)\r\n    {\r\n        (bool b1, bool b2, bool b3, ) = unpackBBBU(packed);\r\n        newPacked = packBBBU(b1, b2, b3, u1);\r\n    }\r\n\r\n    // Found this on a github answer to cast bools to a uint256, should be identical for a uint8\r\n    function boolToUint(bool _b) private pure returns (uint8) {\r\n        uint8 _bInt;\r\n        assembly {\r\n            // SAFETY: Simple bool-to-int cast.\r\n            _bInt := _b\r\n        }\r\n        return _bInt;\r\n    }\r\n\r\n    // The reverse\r\n    function uintToBool(uint8 _u) private pure returns (bool) {\r\n        bool _b;\r\n        assembly {\r\n            // SAFETY: Simple int-to-bool cast.\r\n            _b := _u\r\n        }\r\n        return _b;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"MaxTxAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"theBot\",\"type\":\"address\"}],\"name\":\"addBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addExcludedFromReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notbot\",\"type\":\"address\"}],\"name\":\"delBot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isExcludedFromReward\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manualSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"divisor\",\"type\":\"uint256\"}],\"name\":\"manualSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openTrading\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proxiedApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Contract\",\"type\":\"address\"}],\"name\":\"proxiedSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Contract\",\"type\":\"address\"}],\"name\":\"proxiedSellAndSend\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"erc20Contract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"proxiedTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiedWETHWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onoff\",\"type\":\"bool\"}],\"name\":\"setCooldownEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeS\",\"type\":\"uint256\"}],\"name\":\"setMaturationTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setMaxWalletAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newAmt\",\"type\":\"uint32\"}],\"name\":\"setTaxGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newAmt\",\"type\":\"uint32\"}],\"name\":\"setTaxGrey\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"staticSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"account\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"value\",\"type\":\"uint256[]\"}],\"name\":\"staticSwapAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAmount\",\"type\":\"uint256\"}],\"name\":\"tokenFromReflection\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "HoldenomicsToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e1bbaa5138b85395b8c4eb02f41ce2c7f63f6b73da2939684233313017d9bb2d"}]}