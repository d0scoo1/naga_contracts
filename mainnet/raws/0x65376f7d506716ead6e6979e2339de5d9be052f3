{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\ninterface NFT {\r\n    function ownerOf(uint256 id) external view returns(address);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n}\r\n\r\ncontract QuantumMachine is Context {\r\n\r\n    address public metahelmet; \r\n\r\n    event Merge(uint256 indexed tokenId, address indexed nftContract, uint256 indexed nftId);\r\n\r\n    event Unmerge(uint256 indexed tokenId);\r\n\r\n    constructor(address _metahelmet) {\r\n        metahelmet = _metahelmet;\r\n    }\r\n\r\n    function checkTokenOwnership(address nft, address holder, uint256 id) internal view returns(bool) {\r\n        bool success;\r\n        bytes memory data;\r\n        \r\n        /** Check ERC721 */\r\n        (success, data) = nft.staticcall(abi.encodeWithSignature(\"ownerOf(uint256)\", id));\r\n        if (success) {\r\n            address owner = abi.decode(data, (address));\r\n            if (owner == holder) {\r\n                return true;\r\n            }\r\n        } else {\r\n            (success, data) = nft.staticcall(abi.encodeWithSignature(\"balanceOf(address,uint256)\", holder, id));\r\n            if (success) {\r\n                uint256 n = abi.decode(data, (uint256));\r\n                if (n > 0) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function merge(uint256 id, address _contract, uint256 nft) public {\r\n        require(NFT(metahelmet).ownerOf(id) == _msgSender(), \"Only owner can merge tokens\");\r\n        require(checkTokenOwnership(_contract, _msgSender(), nft), \"Only owner can merge tokens\");\r\n    \r\n        emit Merge(id, address(_contract), nft);\r\n    }\r\n\r\n    function unmerge(uint256 id) public {\r\n        require(NFT(metahelmet).ownerOf(id) == _msgSender(), \"Only owner can unmerge tokens\");\r\n        emit Unmerge(id);\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_metahelmet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"Merge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Unmerge\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_contract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nft\",\"type\":\"uint256\"}],\"name\":\"merge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"metahelmet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"unmerge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "QuantumMachine", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000bd888e50969748805cdf77bcf283febe493f190c", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://88c0b947a76eccdbf3ed3f3193dcdb014e8946b45a42808ea1cdda0c4e462055"}]}