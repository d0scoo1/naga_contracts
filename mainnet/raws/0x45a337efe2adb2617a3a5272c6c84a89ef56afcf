{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity ^0.4.23;\r\n\r\n// converting to bech32/base32 w/ no checksum\r\nlibrary Base32Lib {\r\n    // see https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki#bech32 for alphabet\r\n    bytes constant ALPHABET = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\r\n\r\n    // modified toBase58 impl from https://github.com/MrChico/verifyIPFS/blob/b4bfb3df52e7e012a4ef668c6b3dbc038f881fd9/contracts/verifyIPFS.sol\r\n    // MIT Licensed - https://github.com/MrChico/verifyIPFS/blob/b4bfb3df52e7e012a4ef668c6b3dbc038f881fd9/LICENSE\r\n    function toBase32(bytes source) internal pure returns (bytes) {\r\n        if (source.length == 0) return new bytes(0);\r\n        uint8[] memory digits = new uint8[](40); //TODO: figure out exactly how much is needed\r\n        digits[0] = 0;\r\n        uint8 digitlength = 1;\r\n        for (uint8 i = 0; i < source.length; ++i) {\r\n            uint carry = uint8(source[i]);\r\n            for (uint8 j = 0; j < digitlength; ++j) {\r\n                carry += uint(digits[j]) * 256;\r\n                digits[j] = uint8(carry % 32);\r\n                carry = carry / 32;\r\n            }\r\n\r\n            while (carry > 0) {\r\n                digits[digitlength] = uint8(carry % 32);\r\n                digitlength++;\r\n                carry = carry / 32;\r\n            }\r\n        }\r\n        //return digits;\r\n        return toAlphabet(reverse(truncate(digits, digitlength)));\r\n    }\r\n\r\n    function truncate(uint8[] array, uint8 length) pure internal returns (uint8[]) {\r\n        uint8[] memory output = new uint8[](length);\r\n        for (uint8 i = 0; i<length; i++) {\r\n            output[i] = array[i];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    function reverse(uint8[] input) pure internal returns (uint8[]) {\r\n        uint8[] memory output = new uint8[](input.length);\r\n        for (uint8 i = 0; i<input.length; i++) {\r\n            output[i] = input[input.length-1-i];\r\n        }\r\n        return output;\r\n    }\r\n\r\n    function toAlphabet(uint8[] indices) pure internal returns (bytes) {\r\n        bytes memory output = new bytes(indices.length);\r\n        for (uint8 i = 0; i<indices.length; i++) {\r\n            output[i] = ALPHABET[indices[i]];\r\n        }\r\n        return output;\r\n    }\r\n}", "ABI": "[]", "ContractName": "Base32Lib", "CompilerVersion": "v0.4.23+commit.124ca40d", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://54f064936acce2fd12c597e508ff95e055e3d0fcc9e774d281781ff65ead2e41"}]}