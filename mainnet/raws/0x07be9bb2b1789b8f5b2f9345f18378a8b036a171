{"status": "1", "message": "OK", "result": [{"SourceCode": "# @version 0.2.12\r\n# @author skozin <info@lido.fi>\r\n# @licence MIT\r\nfrom vyper.interfaces import ERC20\r\n\r\n\r\ninterface BridgeConnector:\r\n    def forward_beth(terra_address: bytes32, amount: uint256, extra_data: Bytes[1024]): nonpayable\r\n    def forward_ust(terra_address: bytes32, amount: uint256, extra_data: Bytes[1024]): nonpayable\r\n    def adjust_amount(amount: uint256, decimals: uint256) -> uint256: view\r\n\r\n\r\ninterface RewardsLiquidator:\r\n    def liquidate(ust_recipient: address) -> uint256: nonpayable\r\n\r\n\r\ninterface InsuranceConnector:\r\n    def total_shares_burnt() -> uint256: view\r\n\r\n\r\ninterface Mintable:\r\n    def mint(owner: address, amount: uint256): nonpayable\r\n    def burn(owner: address, amount: uint256): nonpayable\r\n\r\n\r\ninterface Lido:\r\n    def submit(referral: address) -> uint256: payable\r\n    def totalSupply() -> uint256: view\r\n    def getTotalShares() -> uint256: view\r\n    def sharesOf(owner: address) -> uint256: view\r\n    def getPooledEthByShares(shares_amount: uint256) -> uint256: view\r\n\r\n\r\nevent Deposited:\r\n    sender: indexed(address)\r\n    amount: uint256\r\n    terra_address: bytes32\r\n    beth_amount_received: uint256\r\n\r\n\r\nevent Withdrawn:\r\n    recipient: indexed(address)\r\n    amount: uint256\r\n    steth_amount_received: uint256\r\n\r\n\r\nevent Refunded:\r\n    recipient: indexed(address)\r\n    beth_amount: uint256\r\n    steth_amount: uint256\r\n    comment: String[1024]\r\n\r\n\r\nevent RefundedBethBurned:\r\n    beth_amount: uint256\r\n\r\n\r\nevent RewardsCollected:\r\n    steth_amount: uint256\r\n    ust_amount: uint256\r\n\r\n\r\nevent AdminChanged:\r\n    new_admin: address\r\n\r\n\r\nevent EmergencyAdminChanged:\r\n    new_emergency_admin: address\r\n\r\n\r\nevent BridgeConnectorUpdated:\r\n    bridge_connector: address\r\n\r\n\r\nevent RewardsLiquidatorUpdated:\r\n    rewards_liquidator: address\r\n\r\n\r\nevent InsuranceConnectorUpdated:\r\n    insurance_connector: address\r\n\r\n\r\nevent LiquidationConfigUpdated:\r\n    liquidations_admin: address\r\n    no_liquidation_interval: uint256\r\n    restricted_liquidation_interval: uint256\r\n\r\n\r\nevent AnchorRewardsDistributorUpdated:\r\n    anchor_rewards_distributor: bytes32\r\n\r\n\r\nevent VersionIncremented:\r\n    new_version: uint256\r\n\r\n\r\nevent OperationsStopped:\r\n    pass\r\n\r\n\r\nevent OperationsResumed:\r\n    pass\r\n\r\n\r\nBETH_DECIMALS: constant(uint256) = 18\r\n\r\n# A constant used in `_can_deposit_or_withdraw` when comparing Lido share prices.\r\n#\r\n# Due to integer rounding, Lido.getPooledEthByShares(10**18) may return slightly\r\n# different numbers even if there were no oracle reports between two calls. This\r\n# might happen if someone submits ETH before the second call. It can be mathematically\r\n# proven that this difference won't be more than 10 wei given that Lido holds at least\r\n# 0.1 ETH and the share price is of the same order of magnitude as the amount of ETH\r\n# held. Both of these conditions are true if Lido operates normally\u2014and if it doesn't,\r\n# it's desirable for AnchorVault operations to be suspended. See:\r\n#\r\n# https://github.com/lidofinance/lido-dao/blob/eb33eb8/contracts/0.4.24/Lido.sol#L445\r\n# https://github.com/lidofinance/lido-dao/blob/eb33eb8/contracts/0.4.24/StETH.sol#L288\r\n#\r\nSTETH_SHARE_PRICE_MAX_ERROR: constant(uint256) = 10\r\n\r\n# Aragon Agent contract of the Lido DAO\r\nLIDO_DAO_AGENT: constant(address) = 0x3e40D73EB977Dc6a537aF587D48316feE66E9C8c\r\n\r\n# WARNING: since this contract is behind a proxy, don't change the order of the variables\r\n# and don't remove variables during the code upgrades. You can only append new variables\r\n# to the end of the list.\r\n\r\nadmin: public(address)\r\n\r\nbeth_token: public(address)\r\nsteth_token: public(address)\r\nbridge_connector: public(address)\r\nrewards_liquidator: public(address)\r\ninsurance_connector: public(address)\r\nanchor_rewards_distributor: public(bytes32)\r\n\r\nliquidations_admin: public(address)\r\nno_liquidation_interval: public(uint256)\r\nrestricted_liquidation_interval: public(uint256)\r\n\r\nlast_liquidation_time: public(uint256)\r\nlast_liquidation_share_price: public(uint256)\r\nlast_liquidation_shares_burnt: public(uint256)\r\n\r\n# The contract version. Used to mark backwards-incompatible changes to the contract\r\n# logic, including installing delegates with an incompatible API. Can be changed both\r\n# in `_initialize_vX` after implementation code changes and by calling `bump_version`\r\n# after installing a new delegate.\r\n#\r\n# The following functions revert unless the value of the `_expected_version` argument\r\n# matches the one stored in this state variable:\r\n#\r\n# * `deposit`\r\n# * `withdraw`\r\n#\r\n# It's recommended for any external code interacting with this contract, both onchain\r\n# and offchain, to have the current version set as a configurable parameter to make\r\n# sure any incompatible change to the contract logic won't produce unexpected results,\r\n# reverting the transactions instead until the compatibility is manually checked and\r\n# the configured version is updated.\r\n#\r\nversion: public(uint256)\r\n\r\nemergency_admin: public(address)\r\noperations_allowed: public(bool)\r\n\r\ntotal_beth_refunded: public(uint256)\r\n\r\n\r\n@internal\r\ndef _assert_version(_expected_version: uint256):\r\n    assert _expected_version == self.version, \"unexpected contract version\"\r\n\r\n\r\n@internal\r\ndef _assert_not_stopped():\r\n    assert self.operations_allowed, \"contract stopped\"\r\n\r\n\r\n@internal\r\ndef _assert_admin(addr: address):\r\n    assert addr == self.admin # dev: unauthorized\r\n\r\n\r\n@internal\r\ndef _assert_dao_governance(addr: address):\r\n    assert addr == LIDO_DAO_AGENT # dev: unauthorized\r\n\r\n\r\n@internal\r\ndef _initialize_v3(emergency_admin: address):\r\n    self.emergency_admin = emergency_admin\r\n    log EmergencyAdminChanged(emergency_admin)\r\n    self.version = 3\r\n    log VersionIncremented(3)\r\n\r\n\r\n@external\r\ndef initialize(beth_token: address, steth_token: address, admin: address, emergency_admin: address):\r\n    assert self.beth_token == ZERO_ADDRESS # dev: already initialized\r\n    assert self.version == 0 # dev: already initialized\r\n\r\n    assert beth_token != ZERO_ADDRESS # dev: invalid bETH address\r\n    assert steth_token != ZERO_ADDRESS # dev: invalid stETH address\r\n\r\n    assert ERC20(beth_token).totalSupply() == 0 # dev: non-zero bETH total supply\r\n\r\n    self.beth_token = beth_token\r\n    self.steth_token = steth_token\r\n    # we're explicitly allowing zero admin address for ossification\r\n    self.admin = admin\r\n    self.last_liquidation_share_price = Lido(steth_token).getPooledEthByShares(10**18)\r\n    self._initialize_v3(emergency_admin)\r\n\r\n    log AdminChanged(admin)\r\n\r\n\r\n@external\r\ndef petrify_impl():\r\n    \"\"\"\r\n    @dev Prevents initialization of an implementation sitting behind a proxy.\r\n    \"\"\"\r\n    assert self.version == 0 # dev: already initialized\r\n    self.version = MAX_UINT256\r\n\r\n\r\n@external\r\ndef emergency_stop():\r\n    \"\"\"\r\n    @dev Performs emergency stop of the contract. Can only be called\r\n    by the current emergency admin or by the current admin.\r\n\r\n    While contract is in the stopped state, the following functions revert:\r\n\r\n    * `submit`\r\n    * `withdraw`\r\n    * `collect_rewards`\r\n\r\n    See `resume`, `set_emergency_admin`.\r\n    \"\"\"\r\n    assert msg.sender == self.emergency_admin or msg.sender == self.admin # dev: unauthorized\r\n    self._assert_not_stopped()\r\n    self.operations_allowed = False\r\n    log OperationsStopped()\r\n\r\n\r\n@external\r\ndef resume():\r\n    \"\"\"\r\n    @dev Resumes normal operations of the contract. Can only be called\r\n    by the Lido DAO governance contract.\r\n\r\n    See `emergency_stop`.\r\n    \"\"\"\r\n    self._assert_dao_governance(msg.sender)\r\n    assert not self.operations_allowed # dev: not stopped\r\n    self.operations_allowed = True\r\n    log OperationsResumed()\r\n\r\n\r\n@external\r\ndef change_admin(new_admin: address):\r\n    \"\"\"\r\n    @dev Changes the admin address. Can only be called by the current admin address.\r\n\r\n    Setting the admin to zero ossifies the contract, i.e. makes it irreversibly non-administrable.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    # we're explicitly allowing zero admin address for ossification\r\n    self.admin = new_admin\r\n    log AdminChanged(new_admin)\r\n\r\n\r\n@external\r\ndef set_emergency_admin(new_emergency_admin: address):\r\n    \"\"\"\r\n    @dev Sets the address allowed to perform an emergency stop and having no other privileges.\r\n\r\n    Can only be called by the Lido DAO governance contract.\r\n\r\n    See `emergency_stop`, `resume`.\r\n    \"\"\"\r\n    self._assert_dao_governance(msg.sender)\r\n    # we're explicitly allowing zero address\r\n    self.emergency_admin = new_emergency_admin\r\n    log EmergencyAdminChanged(new_emergency_admin)\r\n\r\n\r\n@external\r\ndef bump_version():\r\n    \"\"\"\r\n    @dev Increments contract version. Can only be called by the current admin address.\r\n\r\n    Due to the usage of replaceable delegates, contract version cannot be compiled to\r\n    the AnchorVault implementation as a constant. Instead, the governance should call\r\n    this function when backwards-incompatible changes are made to the contract or its\r\n    delegates.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    new_version: uint256 = self.version + 1\r\n    self.version = new_version\r\n    log VersionIncremented(new_version)\r\n\r\n\r\n@internal\r\ndef _set_bridge_connector(_bridge_connector: address):\r\n    self.bridge_connector = _bridge_connector\r\n    log BridgeConnectorUpdated(_bridge_connector)\r\n\r\n\r\n@external\r\ndef set_bridge_connector(_bridge_connector: address):\r\n    \"\"\"\r\n    @dev Sets the bridge connector contract: an adapter contract for communicating\r\n         with the Terra bridge.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_bridge_connector(_bridge_connector)\r\n\r\n\r\n@internal\r\ndef _set_rewards_liquidator(_rewards_liquidator: address):\r\n    self.rewards_liquidator = _rewards_liquidator # dev: unauthorized\r\n    log RewardsLiquidatorUpdated(_rewards_liquidator)\r\n\r\n\r\n@external\r\ndef set_rewards_liquidator(_rewards_liquidator: address):\r\n    \"\"\"\r\n    @dev Sets the rewards liquidator contract: a contract for selling stETH rewards to UST.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_rewards_liquidator(_rewards_liquidator)\r\n\r\n\r\n@internal\r\ndef _set_insurance_connector(_insurance_connector: address):\r\n    self.insurance_connector = _insurance_connector\r\n    log InsuranceConnectorUpdated(_insurance_connector)\r\n\r\n\r\n@external\r\ndef set_insurance_connector(_insurance_connector: address):\r\n    \"\"\"\r\n    @dev Sets the insurance connector contract: a contract for obtaining the total number of\r\n         shares burnt for the purpose of insurance/cover application from the Lido protocol.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_insurance_connector(_insurance_connector)\r\n\r\n\r\n@internal\r\ndef _set_liquidation_config(\r\n    _liquidations_admin: address,\r\n    _no_liquidation_interval: uint256,\r\n    _restricted_liquidation_interval: uint256\r\n):\r\n    assert _restricted_liquidation_interval >= _no_liquidation_interval\r\n\r\n    self.liquidations_admin = _liquidations_admin\r\n    self.no_liquidation_interval = _no_liquidation_interval\r\n    self.restricted_liquidation_interval = _restricted_liquidation_interval\r\n\r\n    log LiquidationConfigUpdated(\r\n        _liquidations_admin,\r\n        _no_liquidation_interval,\r\n        _restricted_liquidation_interval\r\n    )\r\n\r\n\r\n@external\r\ndef set_liquidation_config(\r\n    _liquidations_admin: address,\r\n    _no_liquidation_interval: uint256,\r\n    _restricted_liquidation_interval: uint256,\r\n):\r\n    \"\"\"\r\n    @dev Sets the liquidation config consisting of liquidation admin, the address that is allowed\r\n         to sell stETH rewards to UST during after the no-liquidation interval ends and before\r\n         the restricted liquidation interval ends, as well as both intervals.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_liquidation_config(\r\n        _liquidations_admin,\r\n        _no_liquidation_interval,\r\n        _restricted_liquidation_interval\r\n    )\r\n\r\n\r\n@internal\r\ndef _set_anchor_rewards_distributor(_anchor_rewards_distributor: bytes32):\r\n    self.anchor_rewards_distributor = _anchor_rewards_distributor\r\n    log AnchorRewardsDistributorUpdated(_anchor_rewards_distributor)\r\n\r\n\r\n@external\r\ndef set_anchor_rewards_distributor(_anchor_rewards_distributor: bytes32):\r\n    \"\"\"\r\n    @dev Sets the Terra-side UST rewards distributor contract allowing Terra-side bETH holders\r\n         to claim their staking rewards in the UST form.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_anchor_rewards_distributor(_anchor_rewards_distributor)\r\n\r\n\r\n@external\r\ndef configure(\r\n    _bridge_connector: address,\r\n    _rewards_liquidator: address,\r\n    _insurance_connector: address,\r\n    _liquidations_admin: address,\r\n    _no_liquidation_interval: uint256,\r\n    _restricted_liquidation_interval: uint256,\r\n    _anchor_rewards_distributor: bytes32,\r\n):\r\n    \"\"\"\r\n    @dev A shortcut function for setting all admin-configurable settings at once.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    self._set_bridge_connector(_bridge_connector)\r\n    self._set_rewards_liquidator(_rewards_liquidator)\r\n    self._set_insurance_connector(_insurance_connector)\r\n    self._set_liquidation_config(\r\n        _liquidations_admin,\r\n        _no_liquidation_interval,\r\n        _restricted_liquidation_interval\r\n    )\r\n    self._set_anchor_rewards_distributor(_anchor_rewards_distributor)\r\n\r\n\r\n@internal\r\n@view\r\ndef _get_rate(_is_withdraw_rate: bool) -> uint256:\r\n    steth_balance: uint256 = ERC20(self.steth_token).balanceOf(self)\r\n    beth_supply: uint256 = ERC20(self.beth_token).totalSupply() - self.total_beth_refunded\r\n    if steth_balance >= beth_supply:\r\n        return 10**18\r\n    elif _is_withdraw_rate:\r\n        return (steth_balance * 10**18) / beth_supply\r\n    elif steth_balance == 0:\r\n        return 10**18\r\n    else:\r\n        return (beth_supply * 10**18) / steth_balance\r\n\r\n\r\n@external\r\n@view\r\ndef get_rate() -> uint256:\r\n    \"\"\"\r\n    @dev How much bETH one receives for depositing one stETH, and how much bETH one needs\r\n         to provide to withdraw one stETH, 10**18 being the 1:1 rate.\r\n\r\n    This rate is notmally 10**18 (1:1) but might be different after severe penalties inflicted\r\n    on the Lido validators.\r\n    \"\"\"\r\n    return self._get_rate(False)\r\n\r\n\r\n@pure\r\n@internal\r\ndef _diff_abs(new: uint256, old: uint256) -> uint256:\r\n    if new > old :\r\n        return new - old\r\n    else:\r\n        return old - new\r\n\r\n\r\n@view\r\n@internal\r\ndef _can_deposit_or_withdraw() -> bool:\r\n    share_price: uint256 = Lido(self.steth_token).getPooledEthByShares(10**18)\r\n    return self._diff_abs(share_price, self.last_liquidation_share_price) <= STETH_SHARE_PRICE_MAX_ERROR\r\n\r\n\r\n@view\r\n@external\r\ndef can_deposit_or_withdraw() -> bool:\r\n    \"\"\"\r\n    @dev Whether deposits and withdrawals are enabled.\r\n\r\n    Deposits and withdrawals are disabled if stETH token has rebased (e.g. Lido\r\n    oracle reported Beacon chain rewards/penalties or insurance was applied) but\r\n    vault rewards accrued since the last rewards sell operation are not sold to\r\n    UST yet. Normally, this period should not last more than a couple of minutes\r\n    each 24h.\r\n    \"\"\"\r\n    return self.operations_allowed and self._can_deposit_or_withdraw()\r\n\r\n\r\n@external\r\n@payable\r\ndef submit(\r\n    _amount: uint256,\r\n    _terra_address: bytes32,\r\n    _extra_data: Bytes[1024],\r\n    _expected_version: uint256\r\n) -> (uint256, uint256):\r\n    \"\"\"\r\n    @dev Locks the `_amount` of provided ETH or stETH tokens in return for bETH tokens\r\n         minted to the `_terra_address` address on the Terra blockchain.\r\n\r\n    When ETH is provided, it will be deposited to Lido and converted to stETH first.\r\n    In this case, transaction value must be the same as `_amount` argument.\r\n\r\n    To provide stETH, set the transavtion value to zero and approve this contract for spending\r\n    the `_amount` of stETH on your behalf.\r\n\r\n    The call fails if `AnchorVault.can_deposit_or_withdraw()` is false.\r\n\r\n    The conversion rate from stETH to bETH should normally be 1 but might be different after\r\n    severe penalties inflicted on the Lido validators. You can obtain the current conversion\r\n    rate by calling `AnchorVault.get_rate()`.\r\n    \"\"\"\r\n    self._assert_not_stopped()\r\n    self._assert_version(_expected_version)\r\n    assert self._can_deposit_or_withdraw() # dev: share price changed\r\n\r\n    steth_token: address = self.steth_token\r\n    steth_amount: uint256 = _amount\r\n\r\n    if msg.value != 0:\r\n        assert msg.value == _amount # dev: unexpected ETH amount sent\r\n        shares_minted: uint256 = Lido(steth_token).submit(self, value=_amount)\r\n        steth_amount = Lido(steth_token).getPooledEthByShares(shares_minted)\r\n\r\n    connector: address = self.bridge_connector\r\n\r\n    beth_rate: uint256 = self._get_rate(False)\r\n    beth_amount: uint256 = (steth_amount * beth_rate) / 10**18\r\n    # the bridge might not support full precision amounts\r\n    beth_amount = BridgeConnector(connector).adjust_amount(beth_amount, BETH_DECIMALS)\r\n\r\n    steth_amount_adj: uint256 = (beth_amount * 10**18) / beth_rate\r\n    assert steth_amount_adj <= steth_amount # dev: invalid adjusted amount\r\n\r\n    if msg.value == 0:\r\n        ERC20(steth_token).transferFrom(msg.sender, self, steth_amount_adj)\r\n    elif steth_amount_adj < steth_amount:\r\n        ERC20(steth_token).transfer(msg.sender, steth_amount - steth_amount_adj)\r\n\r\n    Mintable(self.beth_token).mint(connector, beth_amount)\r\n    BridgeConnector(connector).forward_beth(_terra_address, beth_amount, _extra_data)\r\n\r\n    log Deposited(msg.sender, steth_amount_adj, _terra_address, beth_amount)\r\n\r\n    return (steth_amount_adj, beth_amount)\r\n\r\n\r\n@internal\r\ndef _withdraw(recipient: address, beth_amount: uint256, steth_rate: uint256) -> uint256:\r\n    assert self._can_deposit_or_withdraw() # dev: share price changed\r\n    steth_amount: uint256 = (beth_amount * steth_rate) / 10**18\r\n    ERC20(self.steth_token).transfer(recipient, steth_amount)\r\n    return steth_amount\r\n\r\n\r\n\r\n@external\r\ndef withdraw(\r\n    _beth_amount: uint256,\r\n    _expected_version: uint256,\r\n    _recipient: address = msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @dev Burns the `_beth_amount` of provided Ethereum-side bETH tokens in return for stETH\r\n         tokens transferred to the `_recipient` Ethereum address.\r\n\r\n    To withdraw Terra-side bETH, you should firstly transfer the tokens to the Ethereum\r\n    blockchain.\r\n\r\n    The call fails if `AnchorVault.can_deposit_or_withdraw()` returns false.\r\n\r\n    The conversion rate from stETH to bETH should normally be 1 but might be different after\r\n    severe penalties inflicted on the Lido validators. You can obtain the current conversion\r\n    rate by calling `AnchorVault.get_rate()`.\r\n    \"\"\"\r\n    self._assert_not_stopped()\r\n    self._assert_version(_expected_version)\r\n\r\n    steth_rate: uint256 = self._get_rate(True)\r\n    Mintable(self.beth_token).burn(msg.sender, _beth_amount)\r\n    steth_amount: uint256 = self._withdraw(_recipient, _beth_amount, steth_rate)\r\n\r\n    log Withdrawn(_recipient, _beth_amount, steth_amount)\r\n\r\n    return steth_amount\r\n\r\n\r\n@internal\r\ndef _withdraw_for_refunding_burned_beth(\r\n    _burned_beth_amount: uint256,\r\n    _recipient: address,\r\n    _comment: String[1024]\r\n) -> uint256:\r\n    \"\"\"\r\n    @dev Withdraws stETH without burning the corresponding bETH, assuming that\r\n         the corresponding bETH was already effectively burned, i.e. that it\r\n         cannot be moved from the address it currently belongs to. Returns\r\n         the amount of stETH withdrawn.\r\n\r\n    Can be used by the DAO governance to refund bETH that became locked as the\r\n    result of a contract or user error, e.g. by using an incorrect encoding of\r\n    the Terra recipient address. The governance takes the responsibility for\r\n    verifying the immobility of the bETH being refunded and for taking all\r\n    required actions should the refunded bETH become movable again.\r\n\r\n    The call fails if `AnchorVault.can_deposit_or_withdraw()` returns false.\r\n\r\n    The same conversion rate from bETH to stETH as in the `withdraw` method\r\n    is applied. The call doesn't change the conversion rate.\r\n\r\n    See: `withdraw`, `burn_refunded_beth`.\r\n    \"\"\"\r\n    steth_rate: uint256 = self._get_rate(True)\r\n    self.total_beth_refunded += _burned_beth_amount\r\n    steth_amount: uint256 = self._withdraw(_recipient, _burned_beth_amount, steth_rate)\r\n\r\n    log Refunded(_recipient, _burned_beth_amount, steth_amount, _comment)\r\n\r\n    return steth_amount\r\n\r\n\r\n@external\r\ndef burn_refunded_beth(beth_amount: uint256):\r\n    \"\"\"\r\n    @dev Burns bETH belonging to the AnchorVault contract address, assuming that\r\n         the corresponding stETH amount was already withdrawn from the vault\r\n         via the `_withdraw_for_refunding_burned_beth` method.\r\n\r\n    Can only be called by the current admin address.\r\n\r\n    Used by the governance to actually burn bETH that previously became locked as\r\n    the result of a contract or user error and was subsequently refunded.\r\n\r\n    Reverts unless at least the specified bETH amount was refunded and wasn't\r\n    burned yet.\r\n\r\n    See: `_withdraw_for_refunding_burned_beth`.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n\r\n    # this will revert if beth_amount exceeds total_beth_refunded\r\n    self.total_beth_refunded -= beth_amount\r\n\r\n    Mintable(self.beth_token).burn(self, beth_amount)\r\n\r\n    log RefundedBethBurned(beth_amount)\r\n\r\n\r\n@internal\r\ndef _perform_refund_for_2022_01_26_incident():\r\n    \"\"\"\r\n    @dev Withdraws stETH corresponding to bETH irreversibly locked at inaccessible Terra\r\n         addresses as the result of the 2022-01-26 incident caused by incorrect address\r\n         encoding produced by cached UI code after onchain migration to the Wormhole bridge.\r\n\r\n    Tx 1: 0xc875f85f525d9bc47314eeb8dc13c288f0814cf06865fc70531241e21f5da09d\r\n    bETH burned: 4449999990000000000\r\n\r\n    Tx 2: 0x7abe086dd5619a577f50f87660a03ea0a1934c4022cd432ddf00734771019951\r\n    bETH burned: 439111118580000000000\r\n    \"\"\"\r\n    # prevent this funciton from being called after the v3 upgrade (see `finalize_upgrade_v3`)\r\n    self._assert_version(0)\r\n    LIDO_DAO_FINANCE_MULTISIG: address = 0x48F300bD3C52c7dA6aAbDE4B683dEB27d38B9ABb\r\n    BETH_AMOUNT_BURNED: uint256 = 4449999990000000000 + 439111118580000000000\r\n    self._withdraw_for_refunding_burned_beth(\r\n        BETH_AMOUNT_BURNED,\r\n        LIDO_DAO_FINANCE_MULTISIG,\r\n        \"refund for 2022-01-26 incident, txid 0x7abe086dd5619a577f50f87660a03ea0a1934c4022cd432ddf00734771019951 and 0xc875f85f525d9bc47314eeb8dc13c288f0814cf06865fc70531241e21f5da09d\"\r\n    )\r\n\r\n\r\n@external\r\ndef finalize_upgrade_v3(emergency_admin: address):\r\n    \"\"\"\r\n    @dev Performs state changes required for proxy upgrade from version 2 to version 3.\r\n\r\n    Can only be called by the current admin address.\r\n    \"\"\"\r\n    self._assert_admin(msg.sender)\r\n    # in v2, the version() function returned constant value of 2; in the upgraded impl,\r\n    # the same function reads a storage slot that's zero until this function is called\r\n    self._assert_version(0)\r\n    self._perform_refund_for_2022_01_26_incident()\r\n    self._initialize_v3(emergency_admin)\r\n    self.operations_allowed = True\r\n\r\n\r\n@external\r\ndef collect_rewards() -> uint256:\r\n    \"\"\"\r\n    @dev Sells stETH rewards and transfers them to the distributor contract in the\r\n         Terra blockchain.\r\n    \"\"\"\r\n    self._assert_not_stopped()\r\n\r\n    time_since_last_liquidation: uint256 = block.timestamp - self.last_liquidation_time\r\n\r\n    if msg.sender == self.liquidations_admin:\r\n        assert time_since_last_liquidation > self.no_liquidation_interval # dev: too early to sell\r\n    else:\r\n        assert time_since_last_liquidation > self.restricted_liquidation_interval # dev: too early to sell\r\n\r\n    # The code below sells all rewards accrued by stETH held in the vault to UST\r\n    # and forwards the outcome to the rewards distributor contract in Terra.\r\n    #\r\n    # To calculate the amount of rewards, we need to take the amount of stETH shares\r\n    # the vault holds and determine how these shares' price increased since the last\r\n    # rewards sell operation. We know that each shares that was transferred to the\r\n    # vault since then was worth the same amount of stETH because the vault reverts\r\n    # any deposits and withdrawals if the current share price is different from the\r\n    # one actual at the last rewards sell time (see `can_deposit_or_withdraw` fn).\r\n    #\r\n    # When calculating the difference in share price, we need to account for possible\r\n    # insurance applications that might have occured since the last rewards sell operation.\r\n    # Insurance is applied by burning stETH shares, and the resulting price increase of\r\n    # a single share shouldn't be considered as rewards and should recover bETH/stETH\r\n    # peg instead:\r\n    #\r\n    # rewards = vault_shares_bal * (new_share_price - prev_share_price)\r\n    #\r\n    # new_share_price = new_total_ether / new_total_shares\r\n    # new_total_ether = prev_total_ether + d_ether_io + d_rewards\r\n    # new_total_shares = prev_total_shares + d_shares_io - d_shares_insurance_burnt\r\n    #\r\n    # rewards_corrected = vault_shares_bal * (new_share_price_corrected - prev_share_price)\r\n    # new_share_price_corrected = new_total_ether / new_total_shares_corrected\r\n    # new_total_shares_corrected = prev_total_shares + d_shares_io\r\n    # new_share_price_corrected = new_total_ether / (new_total_shares + d_shares_insurance_burnt)\r\n\r\n    steth_token: address = self.steth_token\r\n    total_pooled_eth: uint256 = Lido(steth_token).totalSupply()\r\n    total_shares: uint256 = Lido(steth_token).getTotalShares()\r\n\r\n    share_price: uint256 = (10**18 * total_pooled_eth) / total_shares\r\n    shares_burnt: uint256 = InsuranceConnector(self.insurance_connector).total_shares_burnt()\r\n\r\n    prev_share_price: uint256 = self.last_liquidation_share_price\r\n    prev_shares_burnt: uint256 = self.last_liquidation_shares_burnt\r\n\r\n    self.last_liquidation_time = block.timestamp\r\n    self.last_liquidation_share_price = share_price\r\n    self.last_liquidation_shares_burnt = shares_burnt\r\n\r\n    shares_burnt_since: uint256 = shares_burnt - prev_shares_burnt\r\n    share_price_corrected: uint256 = (10**18 * total_pooled_eth) / (total_shares + shares_burnt_since)\r\n    shares_balance: uint256 = Lido(steth_token).sharesOf(self)\r\n\r\n    if share_price_corrected <= prev_share_price or shares_balance == 0:\r\n        log RewardsCollected(0, 0)\r\n        return 0\r\n\r\n    steth_to_sell: uint256 = shares_balance * (share_price_corrected - prev_share_price) / 10**18\r\n\r\n    connector: address = self.bridge_connector\r\n    liquidator: address = self.rewards_liquidator\r\n\r\n    ERC20(steth_token).transfer(liquidator, steth_to_sell)\r\n    ust_amount: uint256 = RewardsLiquidator(liquidator).liquidate(connector)\r\n\r\n    BridgeConnector(connector).forward_ust(self.anchor_rewards_distributor, ust_amount, b\"\")\r\n\r\n    log RewardsCollected(steth_to_sell, ust_amount)\r\n\r\n    return ust_amount", "ABI": "[{\"name\":\"Deposited\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"terra_address\",\"type\":\"bytes32\",\"indexed\":false},{\"name\":\"beth_amount_received\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdrawn\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"steth_amount_received\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Refunded\",\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\",\"indexed\":true},{\"name\":\"beth_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"steth_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"comment\",\"type\":\"string\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RefundedBethBurned\",\"inputs\":[{\"name\":\"beth_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsCollected\",\"inputs\":[{\"name\":\"steth_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"ust_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AdminChanged\",\"inputs\":[{\"name\":\"new_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"EmergencyAdminChanged\",\"inputs\":[{\"name\":\"new_emergency_admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"BridgeConnectorUpdated\",\"inputs\":[{\"name\":\"bridge_connector\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RewardsLiquidatorUpdated\",\"inputs\":[{\"name\":\"rewards_liquidator\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"InsuranceConnectorUpdated\",\"inputs\":[{\"name\":\"insurance_connector\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidationConfigUpdated\",\"inputs\":[{\"name\":\"liquidations_admin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"no_liquidation_interval\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"restricted_liquidation_interval\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"AnchorRewardsDistributorUpdated\",\"inputs\":[{\"name\":\"anchor_rewards_distributor\",\"type\":\"bytes32\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"VersionIncremented\",\"inputs\":[{\"name\":\"new_version\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OperationsStopped\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"OperationsResumed\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"initialize\",\"inputs\":[{\"name\":\"beth_token\",\"type\":\"address\"},{\"name\":\"steth_token\",\"type\":\"address\"},{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"emergency_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":224647},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"petrify_impl\",\"inputs\":[],\"outputs\":[],\"gas\":37470},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"emergency_stop\",\"inputs\":[],\"outputs\":[],\"gas\":27928},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"resume\",\"inputs\":[],\"outputs\":[],\"gas\":38745},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"change_admin\",\"inputs\":[{\"name\":\"new_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39375},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_emergency_admin\",\"inputs\":[{\"name\":\"new_emergency_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":37305},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"bump_version\",\"inputs\":[],\"outputs\":[],\"gas\":41617},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_bridge_connector\",\"inputs\":[{\"name\":\"_bridge_connector\",\"type\":\"address\"}],\"outputs\":[],\"gas\":40092},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_rewards_liquidator\",\"inputs\":[{\"name\":\"_rewards_liquidator\",\"type\":\"address\"}],\"outputs\":[],\"gas\":40152},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_insurance_connector\",\"inputs\":[{\"name\":\"_insurance_connector\",\"type\":\"address\"}],\"outputs\":[],\"gas\":40212},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_liquidation_config\",\"inputs\":[{\"name\":\"_liquidations_admin\",\"type\":\"address\"},{\"name\":\"_no_liquidation_interval\",\"type\":\"uint256\"},{\"name\":\"_restricted_liquidation_interval\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":111639},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_anchor_rewards_distributor\",\"inputs\":[{\"name\":\"_anchor_rewards_distributor\",\"type\":\"bytes32\"}],\"outputs\":[],\"gas\":40232},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"configure\",\"inputs\":[{\"name\":\"_bridge_connector\",\"type\":\"address\"},{\"name\":\"_rewards_liquidator\",\"type\":\"address\"},{\"name\":\"_insurance_connector\",\"type\":\"address\"},{\"name\":\"_liquidations_admin\",\"type\":\"address\"},{\"name\":\"_no_liquidation_interval\",\"type\":\"uint256\"},{\"name\":\"_restricted_liquidation_interval\",\"type\":\"uint256\"},{\"name\":\"_anchor_rewards_distributor\",\"type\":\"bytes32\"}],\"outputs\":[],\"gas\":260141},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_rate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":13257},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"can_deposit_or_withdraw\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":12394},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"submit\",\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_terra_address\",\"type\":\"bytes32\"},{\"name\":\"_extra_data\",\"type\":\"bytes\"},{\"name\":\"_expected_version\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":98743},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_beth_amount\",\"type\":\"uint256\"},{\"name\":\"_expected_version\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"_beth_amount\",\"type\":\"uint256\"},{\"name\":\"_expected_version\",\"type\":\"uint256\"},{\"name\":\"_recipient\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn_refunded_beth\",\"inputs\":[{\"name\":\"beth_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":51105},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"finalize_upgrade_v3\",\"inputs\":[{\"name\":\"emergency_admin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":389011},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"collect_rewards\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":154775},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2988},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"beth_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3018},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"steth_token\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3048},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bridge_connector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3078},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"rewards_liquidator\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3108},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"insurance_connector\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3138},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"anchor_rewards_distributor\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"gas\":3168},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"liquidations_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3198},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"no_liquidation_interval\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3228},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"restricted_liquidation_interval\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3258},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_liquidation_time\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3288},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_liquidation_share_price\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3318},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"last_liquidation_shares_burnt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3348},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3378},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"emergency_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3408},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"operations_allowed\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_beth_refunded\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3468}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.12", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}