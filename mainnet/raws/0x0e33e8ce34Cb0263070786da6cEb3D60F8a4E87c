{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/AuctionHouse.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM`MMM NMM MMM MMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMhMMMMMMM  MMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MM-MMMMM   MMMM    MMMM   lMMMDMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM jMMMMl   MM    MMM  M  MMM   M   MMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMM  , `     M   Y   MM  MMM  BMMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMMMMMMMM  IM  MM  l  MMM  X   MM.  MMMMMMMMMM MMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.nlMMMMMMMMMMMMMMMMM]._  MMMMMMMMMMMMMMMNMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM TMMMMMMMMMMMMMMMMMM          +MMMMMMMMMMMM:  rMMMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMM                  MMMMMM           MMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMM^                   MMMb              .MMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMM                     MM                  MMMMMMM MMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                     M                   gMMMMMMMMMMMMMMMMM\\n// MMMMMMMMu MMMMMMMMMMMMMMM                                           MMMMMMM .MMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           :MMMMMMMMMMMMMMMM\\n// MMMMMMM^ MMMMMMMMMMMMMMMl                                            MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMM                                             MMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMM                                             MMMMMMMMMMMMMMMM\\n// MMMMMMr MMMMMMMMMMMMMMMM                                             MMMMMMMM .MMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMM                                           MMMMMMMMMMMMMMMMM\\n// MMMMMMM MMMMMMMMMMMMMMMMM                                         DMMMMMMMMMM MMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM                              MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMM|`MMMMMMMMMMMMMMMM         q                      MMMMMMMMMMMMMMMMMMM  MMMMMMM\\n// MMMMMMMMMTMMMMMMMMMMMMMMM                               qMMMMMMMMMMMMMMMMMMgMMMMMMMMM\\n// MMMMMMMMq MMMMMMMMMMMMMMMh                             jMMMMMMMMMMMMMMMMMMM nMMMMMMMM\\n// MMMMMMMMMM MMMMMMMMMMMMMMMQ      nc    -MMMMMn        MMMMMMMMMMMMMMMMMMMM MMMMMMMMMM\\n// MMMMMMMMMM.MMMMMMMMMMMMMMMMMMl            M1       `MMMMMMMMMMMMMMMMMMMMMMrMMMMMMMMMM\\n// MMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMM               :MMMMMMMMMM MMMMMMMMMMMM qMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM  MMMMMMX       MMMMMMMMMMMMMMM  uMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMM DMMMMMMMMM   IMMMMMMMMMMMMMMMMMMMMMMM   M   Y  MMMMMMMN MMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMM MMMMMM    ``    M      MM  MMM   , MMMM    Mv  MMM MMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMM MMh  Ml  .   M  MMMM  I  MMMT  M     :M   ,MMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMM MMMMMMMMt  MM  MMMMB m  ]MMM  MMMM   MMMMMM MMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMM MMMMM  MMM   TM   MM  9U  .MM  _MMMMM MMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMM YMMMMMMMn     MMMM    +MMMMMMM1`MMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMM MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM.`MMM MMM MMMMM`.MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\\n// MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM author: phaze MMM\\n\\nimport {Ownable} from \\\"./lib/Ownable.sol\\\";\\nimport {IGouda} from \\\"./lib/interfaces.sol\\\";\\nimport {IMadMouse} from \\\"./lib/interfaces.sol\\\";\\n\\nimport {IERC721} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\\\";\\nimport {IERC20} from \\\"../lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\\\";\\n\\nerror AuctionOngoing();\\nerror AuctionInactive();\\nerror AuctionCancelled();\\n\\nerror ContractCallNotAllowed();\\n\\nerror InvalidTimestamp();\\nerror BidTooLow();\\nerror NoBidPlaced();\\nerror CannotWithdrawWinningBid();\\nerror IncorrectWinner();\\nerror RequirementNotFulfilled();\\n\\nerror QualifierMaxEntrantsReached();\\nerror QualifierInactive();\\nerror QualifierSeedNotSet();\\nerror QualifierNotEntered();\\nerror QualifierAlreadyEntered();\\nerror QualifierNotRequired();\\nerror QualifierRevealInvalidTimeFrame();\\nerror QualifierRandomSeedSet();\\n\\ncontract AuctionHouse is Ownable {\\n    event BidPlaced(uint256 indexed auctionId, address sender, uint256 price);\\n\\n    struct Auction {\\n        uint16 qualifierNumEntrants;\\n        uint16 qualifierMaxEntrants;\\n        uint40 qualifierDuration;\\n        uint16 qualifierChance;\\n        uint16 qualifierRandomSeed;\\n        uint8 requirement;\\n        uint40 start;\\n        uint40 duration;\\n        uint40 currentBid; // in multiples of 1e18\\n        bool cancelled;\\n        address prizeNFT;\\n        uint40 prizeTokenId;\\n    }\\n\\n    uint256 public numAuctions;\\n    mapping(uint256 => Auction) public auctions;\\n    mapping(uint256 => mapping(address => uint256)) public bids;\\n\\n    IGouda constant gouda = IGouda(0x3aD30C5E3496BE07968579169a96f00D56De4C1A);\\n    IMadMouse constant genesis = IMadMouse(0x3aD30c5e2985e960E89F4a28eFc91BA73e104b77);\\n    IMadMouse constant troupe = IMadMouse(0x74d9d90a7fc261FBe92eD47B606b6E0E00d75E70);\\n\\n    uint256 constant ONE_MONTH = 3600 * 24 * 7 * 4;\\n    uint256 constant AUCTION_EXTEND_DURATION = 5 * 60;\\n\\n    /* ------------- External ------------- */\\n\\n    function placeBid(\\n        uint256 auctionId,\\n        uint40 bid,\\n        uint256 requirementData\\n    ) external noContract {\\n        Auction storage auction = auctions[auctionId];\\n\\n        if (bid <= auction.currentBid) revert BidTooLow();\\n\\n        uint256 qualifierDuration = auction.qualifierDuration;\\n\\n        unchecked {\\n            uint256 start = uint256(auction.start) + auction.qualifierDuration;\\n            uint256 duration = auction.duration;\\n\\n            if (duration < block.timestamp - start) revert AuctionInactive();\\n\\n            uint256 end = start + duration;\\n            if (end - block.timestamp < AUCTION_EXTEND_DURATION) {\\n                auction.duration = uint40(duration + AUCTION_EXTEND_DURATION);\\n            }\\n        }\\n\\n        if (auction.cancelled) revert AuctionCancelled();\\n\\n        uint256 callerBid = bids[auctionId][msg.sender];\\n\\n        // if callerBid is > qualifierDownpayment,\\n        // we don't have to re-evaluate qualifications,\\n        // since this check has already been performed\\n        if (callerBid <= 1) {\\n            uint256 requirement = auction.requirement;\\n            if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\\n                revert RequirementNotFulfilled();\\n\\n            if (qualifierDuration != 0) {\\n                uint256 qualifierRandomSeed = auction.qualifierRandomSeed;\\n                if (qualifierRandomSeed == 0) revert QualifierSeedNotSet();\\n                if (callerBid == 0) revert QualifierNotEntered(); // non-zero for valid entry because of downpayment when entering qualifier\\n                uint256 roll = uint256(keccak256(abi.encodePacked(msg.sender, qualifierRandomSeed)));\\n                if (roll & 0xFFFF > auction.qualifierChance) revert QualifierNotEntered();\\n            }\\n        }\\n\\n        unchecked {\\n            // type(uint40).max * 1e18 < 2^256: can't overflow\\n            // underflow assumption: callerBid <= auction.currentBid < bid\\n            gouda.burnFrom(msg.sender, (uint256(bid) - callerBid) * 1e18);\\n            emit BidPlaced(auctionId, msg.sender, uint256(bid) * 1e18);\\n        }\\n\\n        bids[auctionId][msg.sender] = bid;\\n        auction.currentBid = bid;\\n    }\\n\\n    function fulfillsRequirement(\\n        address user,\\n        uint256 requirement,\\n        uint256 data\\n    ) public returns (bool) {\\n        unchecked {\\n            if (requirement == 1 && genesis.numOwned(user) > 0) return true;\\n            else if (requirement == 2 && troupe.numOwned(user) > 0) return true;\\n            else if (\\n                requirement == 3 &&\\n                // specify data == 1 to direct that user is holding troupe and potentially save an sload;\\n                // or leave unspecified and worst-case check both\\n                ((data != 2 && troupe.numOwned(user) > 0) || (data != 1 && genesis.numOwned(user) > 0))\\n            ) return true;\\n            else if (\\n                requirement == 4 &&\\n                (\\n                    data > 5000 // specify owner-held id: data > 5000 refers to genesis collection\\n                        ? genesis.getLevel(data - 5000) > 1 && genesis.ownerOf(data - 5000) == user\\n                        : troupe.getLevel(data) > 1 && troupe.ownerOf(data) == user\\n                )\\n            ) return true;\\n            else if (\\n                requirement == 5 &&\\n                (\\n                    data > 5000\\n                        ? genesis.getLevel(data - 5000) > 2 && genesis.ownerOf(data - 5000) == user\\n                        : troupe.getLevel(data) > 2 && troupe.ownerOf(data) == user\\n                )\\n            ) return true;\\n            return false;\\n        }\\n    }\\n\\n    function claimPrize(uint256 auctionId) external noContract {\\n        resolveBid(auctionId);\\n    }\\n\\n    function reclaimGouda(uint256 auctionId) external noContract {\\n        resolveBid(auctionId);\\n    }\\n\\n    function enterQualifier(uint256 auctionId, uint256 requirementData) external noContract {\\n        Auction storage auction = auctions[auctionId];\\n        unchecked {\\n            if (++auction.qualifierNumEntrants > auction.qualifierMaxEntrants) revert QualifierMaxEntrantsReached();\\n            if (auction.qualifierDuration < block.timestamp - auction.start) revert QualifierInactive();\\n        }\\n\\n        uint256 requirement = auction.requirement;\\n        if (requirement != 0 && !fulfillsRequirement(msg.sender, requirement, requirementData))\\n            revert RequirementNotFulfilled();\\n\\n        if (bids[auctionId][msg.sender] >= 1) revert QualifierAlreadyEntered();\\n\\n        gouda.burnFrom(msg.sender, 1e18);\\n        bids[auctionId][msg.sender] = 1;\\n    }\\n\\n    /* ------------- View ------------- */\\n\\n    function qualifierChosen(uint256 auctionId, address user) external view returns (bool) {\\n        Auction storage auction = auctions[auctionId];\\n\\n        if (auction.duration == 0) return false; // no qualifier required\\n\\n        uint256 callerBid = bids[auctionId][user];\\n        if (callerBid == 0) return false; // downpayment signals successful qualifier entry\\n\\n        uint256 qualifierRandomSeed = auction.qualifierRandomSeed;\\n        if (qualifierRandomSeed == 0) return false;\\n\\n        uint256 roll = uint256(keccak256(abi.encodePacked(user, qualifierRandomSeed)));\\n        if (roll & 0xFFFF > auction.qualifierChance) return false;\\n\\n        return true;\\n    }\\n\\n    /* ------------- Private ------------- */\\n\\n    function resolveBid(uint256 auctionId) private {\\n        unchecked {\\n            Auction storage auction = auctions[auctionId];\\n            uint256 qualifierDuration = auction.qualifierDuration;\\n            uint256 end = auction.start + qualifierDuration + auction.duration;\\n\\n            bool cancelled = auction.cancelled;\\n\\n            if (block.timestamp <= end && !cancelled) revert AuctionOngoing();\\n\\n            uint256 callerBid = bids[auctionId][msg.sender];\\n            delete bids[auctionId][msg.sender];\\n\\n            if (callerBid == 0) revert NoBidPlaced();\\n\\n            if (auction.currentBid == callerBid && !cancelled) {\\n                IERC721(auction.prizeNFT).transferFrom(address(this), msg.sender, auction.prizeTokenId);\\n            } else {\\n                // callerBid >= 1\\n                if (qualifierDuration != 0) callerBid -= 1; // keep the qualifier downpayment\\n                if (callerBid == 0) revert NoBidPlaced();\\n                gouda.mint(msg.sender, callerBid * 1e18);\\n            }\\n        }\\n    }\\n\\n    /* ------------- Owner ------------- */\\n\\n    function createAuction(\\n        address nft,\\n        uint40 tokenId,\\n        uint16 qualifierMaxEntrants,\\n        uint40 qualifierDuration,\\n        uint16 qualifierChance,\\n        uint8 requirement,\\n        uint40 start,\\n        uint40 duration\\n    ) external onlyOwner {\\n        uint256 auctionId;\\n        unchecked {\\n            auctionId = ++numAuctions;\\n        }\\n\\n        if (start < block.timestamp || duration > ONE_MONTH || qualifierDuration > ONE_MONTH) revert InvalidTimestamp();\\n\\n        IERC721(nft).transferFrom(msg.sender, address(this), tokenId);\\n\\n        Auction storage auction = auctions[auctionId];\\n\\n        auction.qualifierMaxEntrants = qualifierMaxEntrants;\\n        auction.qualifierDuration = qualifierDuration;\\n        auction.qualifierChance = qualifierChance;\\n\\n        auction.requirement = requirement;\\n        auction.start = start;\\n        auction.duration = duration;\\n\\n        auction.prizeNFT = nft;\\n        auction.prizeTokenId = tokenId;\\n    }\\n\\n    function cancelAuction(uint256 auctionId) external onlyOwner {\\n        Auction storage auction = auctions[auctionId];\\n        auction.cancelled = true;\\n\\n        IERC721(auction.prizeNFT).transferFrom(address(this), msg.sender, auction.prizeTokenId);\\n    }\\n\\n    function revealQualifier(uint256 auctionId) external onlyOwner {\\n        Auction storage auction = auctions[auctionId];\\n\\n        uint256 qualifierDuration = auction.qualifierDuration;\\n        if (qualifierDuration == 0) revert QualifierNotRequired();\\n\\n        unchecked {\\n            if (block.timestamp < auction.start + qualifierDuration) revert QualifierRevealInvalidTimeFrame();\\n            if (auction.qualifierRandomSeed != 0) revert QualifierRandomSeedSet();\\n\\n            auction.qualifierRandomSeed = uint16(uint256(blockhash(block.number - 1)));\\n        }\\n    }\\n\\n    function rescueToys(IERC721 toy, uint256[] calldata toyIds) external onlyOwner {\\n        unchecked {\\n            for (uint256 i; i < toyIds.length; ++i) toy.transferFrom(address(this), msg.sender, toyIds[i]);\\n        }\\n    }\\n\\n    /* ------------- Modifier ------------- */\\n\\n    modifier noContract() {\\n        if (msg.sender != tx.origin) revert ContractCallNotAllowed();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nerror CallerNotOwner();\\n\\nabstract contract Ownable {\\n    address _owner = msg.sender;\\n\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        _owner = newOwner;\\n    }\\n\\n    modifier onlyOwner() {\\n        if (msg.sender != _owner) revert CallerNotOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/lib/interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\ninterface IGouda {\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    function transfer(address to, uint256 amount) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function mint(address user, uint256 amount) external;\\n\\n    function burnFrom(address account, uint256 amount) external;\\n}\\n\\ninterface IMadMouse {\\n    function numStaked(address user) external returns (uint256);\\n\\n    function numOwned(address user) external returns (uint256);\\n\\n    function balanceOf(address user) external returns (uint256);\\n\\n    function ownerOf(uint256 tokenId) external returns (address);\\n\\n    function getLevel(uint256 tokenId) external view returns (uint256);\\n\\n    function getDNA(uint256 tokenId) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20.sol\\\";\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AuctionCancelled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"AuctionOngoing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BidTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ContractCallNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTimestamp\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoBidPlaced\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierAlreadyEntered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierInactive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierMaxEntrantsReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierNotEntered\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierNotRequired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierRandomSeedSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierRevealInvalidTimeFrame\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"QualifierSeedNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RequirementNotFulfilled\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"BidPlaced\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"auctions\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"qualifierNumEntrants\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"qualifierMaxEntrants\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"qualifierDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"qualifierChance\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"qualifierRandomSeed\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"requirement\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"currentBid\",\"type\":\"uint40\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"prizeNFT\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"prizeTokenId\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"claimPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nft\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"tokenId\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"qualifierMaxEntrants\",\"type\":\"uint16\"},{\"internalType\":\"uint40\",\"name\":\"qualifierDuration\",\"type\":\"uint40\"},{\"internalType\":\"uint16\",\"name\":\"qualifierChance\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"requirement\",\"type\":\"uint8\"},{\"internalType\":\"uint40\",\"name\":\"start\",\"type\":\"uint40\"},{\"internalType\":\"uint40\",\"name\":\"duration\",\"type\":\"uint40\"}],\"name\":\"createAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requirementData\",\"type\":\"uint256\"}],\"name\":\"enterQualifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"requirement\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"data\",\"type\":\"uint256\"}],\"name\":\"fulfillsRequirement\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numAuctions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"bid\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"requirementData\",\"type\":\"uint256\"}],\"name\":\"placeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"qualifierChosen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"reclaimGouda\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"toy\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"toyIds\",\"type\":\"uint256[]\"}],\"name\":\"rescueToys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"auctionId\",\"type\":\"uint256\"}],\"name\":\"revealQualifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AuctionHouse", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}