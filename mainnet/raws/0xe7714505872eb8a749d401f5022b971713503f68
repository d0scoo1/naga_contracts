{"status": "1", "message": "OK", "result": [{"SourceCode": "// File: @chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface KeeperCompatibleInterface {\r\n  /**\r\n   * @notice method that is simulated by the keepers to see if any work actually\r\n   * needs to be performed. This method does does not actually need to be\r\n   * executable, and since it is only ever simulated it can consume lots of gas.\r\n   * @dev To ensure that it is never called, you may want to add the\r\n   * cannotExecute modifier from KeeperBase to your implementation of this\r\n   * method.\r\n   * @param checkData specified in the upkeep registration so it is always the\r\n   * same for a registered upkeep. This can easily be broken down into specific\r\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\r\n   * same contract and easily differentiated by the contract.\r\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\r\n   * performUpkeep or not.\r\n   * @return performData bytes that the keeper should call performUpkeep with, if\r\n   * upkeep is needed. If you would like to encode data to decode later, try\r\n   * `abi.encode`.\r\n   */\r\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\r\n\r\n  /**\r\n   * @notice method that is actually executed by the keepers, via the registry.\r\n   * The data returned by the checkUpkeep simulation will be passed into\r\n   * this method to actually be executed.\r\n   * @dev The input to this method should not be trusted, and the caller of the\r\n   * method should not even be restricted to any single registry. Anyone should\r\n   * be able call it, and the input should be validated, there is no guarantee\r\n   * that the data passed in is the performData returned from checkUpkeep. This\r\n   * could happen due to malicious keepers, racing keepers, or simply a state\r\n   * change while the performUpkeep transaction is waiting for confirmation.\r\n   * Always validate the data passed in.\r\n   * @param performData is the data which was passed back from the checkData\r\n   * simulation. If it is encoded, it can easily be decoded into other types by\r\n   * calling `abi.decode`. This data should not be trusted, and should be\r\n   * validated against the contract's current state.\r\n   */\r\n  function performUpkeep(bytes calldata performData) external;\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/KeeperBase.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract KeeperBase {\r\n  error OnlySimulatedBackend();\r\n\r\n  /**\r\n   * @notice method that allows it to be simulated via eth_call by checking that\r\n   * the sender is the zero address.\r\n   */\r\n  function preventExecution() internal view {\r\n    if (tx.origin != address(0)) {\r\n      revert OnlySimulatedBackend();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice modifier that allows it to be simulated via eth_call by checking\r\n   * that the sender is the zero address.\r\n   */\r\n  modifier cannotExecute() {\r\n    preventExecution();\r\n    _;\r\n  }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/KeeperCompatible.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\nabstract contract KeeperCompatible is KeeperBase, KeeperCompatibleInterface {}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Counters.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Counters\r\n * @author Matt Condon (@shrugs)\r\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\r\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\r\n *\r\n * Include with `using Counters for Counters.Counter;`\r\n */\r\nlibrary Counters {\r\n    struct Counter {\r\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\r\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\r\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\r\n        uint256 _value; // default: 0\r\n    }\r\n\r\n    function current(Counter storage counter) internal view returns (uint256) {\r\n        return counter._value;\r\n    }\r\n\r\n    function increment(Counter storage counter) internal {\r\n        unchecked {\r\n            counter._value += 1;\r\n        }\r\n    }\r\n\r\n    function decrement(Counter storage counter) internal {\r\n        uint256 value = counter._value;\r\n        require(value > 0, \"Counter: decrement overflow\");\r\n        unchecked {\r\n            counter._value = value - 1;\r\n        }\r\n    }\r\n\r\n    function reset(Counter storage counter) internal {\r\n        counter._value = 0;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: EGBurnParty.sol\r\n\r\n\r\npragma solidity ^0.8.9;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n *  _______  ______      ______  _     _  ______ __   _       _____  _______  ______ _______ __   __\r\n *  |______ |  ____      |_____] |     | |_____/ | \\  |      |_____] |_____| |_____/    |      \\_/  \r\n *  |______ |_____|      |_____] |_____| |    \\_ |  \\_|      |       |     | |    \\_    |       |   \r\n *                                                                                                  \r\n */\r\n\r\ncontract EGBurnParty is Ownable, KeeperCompatibleInterface {\r\n\r\n    using Counters for Counters.Counter;\r\n\r\n    struct BurnToken {\r\n        uint256 index;\r\n        address token;\r\n        address burnAddress;\r\n        uint256 minStakeAmount;\r\n        uint256 maxStakeAmount;\r\n        bool enabled;\r\n    }\r\n\r\n    struct BurnParty {\r\n        uint256 partyId;\r\n        string partyAPI;\r\n        address creator;\r\n        address token;\r\n        uint256 burnDate;\r\n        uint256 period;\r\n        uint256 currentQuantity;\r\n        uint256 requiredQuantity;\r\n        uint256 maxStakeAmount;\r\n        uint256 stakeCounter;\r\n        bool started;\r\n        bool cancelled;\r\n        bool ended;\r\n    }\r\n\r\n    struct StakingPeriod{\r\n        uint256 index;\r\n        uint256 period;\r\n        uint256 partyCount;\r\n        uint256 currentPartyIndex;\r\n        bool enabled;\r\n    }\r\n\r\n    struct StakeInfo{\r\n        uint256 amount;\r\n        bool unstaked;\r\n    }\r\n\r\n    // gas fee to pay LINK to ChainLink for automation of burning\r\n    uint256 public gasFeeAmount;\r\n    \r\n    // `burnTokenCounter` detail: number of burn token\r\n    Counters.Counter public burnTokenCounter;\r\n\r\n    // `burnTokens` detail: tokenAddress => token information\r\n    mapping (address => BurnToken) public burnTokens;\r\n\r\n    // `burnTokenIndices` detail: token index => token address\r\n    mapping (uint256 => address) public burnTokenIndices;\r\n\r\n    \r\n    // `partyCounter` detail: number of parties\r\n    Counters.Counter public partyCounter;\r\n    \r\n    // `burnParties` detail: id => BurnParty\r\n    mapping (uint256 => BurnParty) public burnParties;\r\n\r\n    // `Stakes List` detail: Client_Address => Party_Id => Token_Amount\r\n    mapping (address => mapping (uint256 => StakeInfo)) public stakesList;\r\n    \r\n    \r\n    // `periodCounter` detail: number of staking periods\r\n    Counters.Counter public periodCounter;\r\n    \r\n    // `stakingPeriods` detail: period day => staking period\r\n    mapping(uint256 => StakingPeriod) public stakingPeriods;\r\n\r\n    // `periodIndexToDay` detail: period index => period day\r\n    mapping(uint256 => uint256) public periodIndices;\r\n\r\n    // period => index => party ID\r\n    mapping(uint256 => mapping(uint256 => uint256)) public periodBurnParties;\r\n\r\n    event SetMinStakeAmount(address indexed tokenAddress, uint256 minStakeAmount);\r\n    event SetMaxStakeAmount(address indexed tokenAddress, uint256 maxStakeAmount);\r\n    event AddBurnToken(address indexed tokenAddress, address indexed burnAddress, uint256 minStakeAmount, uint256 maxStakeAmount);\r\n    event SetBurnTokenStatus(address indexed tokenAddress, bool status);\r\n    \r\n    event CreateBurnParty(\r\n        uint256 partyId, \r\n        string partyAPI,\r\n        address indexed creator,\r\n        address indexed token, \r\n        uint256 startDate,\r\n        uint256 period,\r\n        uint256 indexed requiredQuantity, \r\n        uint256 stakeAmount,\r\n        uint256 minStakeAmount,\r\n        uint256 maxStakeAmount, \r\n        uint256 gasFeeAmount\r\n    );\r\n    event EndBurnParty(uint256 partyId, address indexed caller, address indexed burnToken, uint256 indexed amount, address burnAddress);\r\n    event CancelBurnParty(uint256 partyId, address indexed caller, address indexed burnToken, uint256 indexed amount);\r\n    event StakeBurnParty(uint256 indexed partyId, address indexed staker, uint256 indexed amount, uint256 gasFeeAmount);\r\n    event UnstakeFromBurnParty(uint256 indexed partyId, address indexed staker, uint256 indexed amount);\r\n\r\n    event RemovePeriod(uint256 period);\r\n    event AddPeriod(uint256 period);\r\n    event SetPeriodStatus(uint256 period, bool status);\r\n    \r\n    event SetGasFeeAmount(uint256 feeAmount);\r\n    event WithdrawGasFee(address indexed feeAddress, uint256 amount);\r\n\r\n    constructor() {\r\n\r\n    }\r\n\r\n    /**\r\n    * @param  feeAmount this is amount of fee tokens\r\n    *\r\n    **/\r\n    function setGasFeeAmount(uint256 feeAmount) external onlyOwner {\r\n        require(feeAmount > 0, \"EGBurnParty: Fee amount should be positive number\");\r\n\r\n        gasFeeAmount = feeAmount;\r\n\r\n        emit SetGasFeeAmount(feeAmount);\r\n    }\r\n\r\n    /**\r\n    * @param  feeAddress address to receive fee\r\n    *\r\n    **/\r\n    function withdrawGasFee(address payable feeAddress) external onlyOwner {\r\n        uint256 balance = address(this).balance;\r\n        require(feeAddress != address(0), \"EGBurnParty: The zero address should not be the fee address\");\r\n        require(balance > 0, \"EGBurnParty: No balance to withdraw\");\r\n\r\n        (bool success, ) = feeAddress.call{value: balance}(\"\");\r\n        require(success, \"EGBurnParty: Withdraw failed\");\r\n\r\n        emit WithdrawGasFee(feeAddress, balance);\r\n    }\r\n\r\n    function existPeriod(uint256 period) public view returns (bool){\r\n        require(period > 0, \"EGBurnParty: Period should be a positive number\");\r\n        return period == periodIndices[stakingPeriods[period].index];\r\n    }\r\n\r\n    /**\r\n    * @param period date \r\n    *\r\n    **/\r\n    function addPeriod(uint256 period) external onlyOwner {\r\n        require(period > 0, \"EGBurnParty: Period should be a positive number\");\r\n        require(existPeriod(period) == false, \"EGBurnParty: Period has been already added.\");\r\n        \r\n        StakingPeriod memory _stakingPeriod = StakingPeriod({\r\n            index: periodCounter.current(),\r\n            period: period,\r\n            partyCount: 0,\r\n            currentPartyIndex: 0,\r\n            enabled: true\r\n        });\r\n        stakingPeriods[period] = _stakingPeriod;\r\n        periodIndices[periodCounter.current()] = period;\r\n\r\n        periodCounter.increment();\r\n\r\n        emit AddPeriod(period);\r\n    }\r\n\r\n    /**\r\n    * @param period date\r\n    *\r\n    **/\r\n    function removePeriod(uint256 period) external onlyOwner {\r\n        require(period > 0, \"EGBurnParty: Period should be a positive number\");\r\n        require(existPeriod(period) == true, \"EGBurnParty: Period is not added.\");\r\n        require(stakingPeriods[period].partyCount == stakingPeriods[period].currentPartyIndex, \"EGBurnParty: You cannot remove a period that has parties created against it\");\r\n        \r\n        uint256 _lastIndex = periodCounter.current() - 1;\r\n        uint256 _currentIndex = stakingPeriods[period].index;\r\n\r\n        if(_currentIndex != _lastIndex){\r\n            uint256 _lastPeriod = periodIndices[_lastIndex];\r\n            periodIndices[_currentIndex] = _lastPeriod;\r\n            stakingPeriods[_lastPeriod].index = _currentIndex;\r\n            stakingPeriods[_lastPeriod].period = _lastPeriod;\r\n        }\r\n\r\n        delete stakingPeriods[period];\r\n        delete periodIndices[_lastIndex];\r\n\r\n        periodCounter.decrement();\r\n\r\n        emit RemovePeriod(period);\r\n    }\r\n\r\n    /**\r\n    * @param period date\r\n    *\r\n    **/\r\n    function setPeriodStatus(uint256 period, bool status) external onlyOwner {\r\n        require(period > 0, \"EGBurnParty: Period should be a positive number\");\r\n        require(existPeriod(period) == true, \"EGBurnParty: Period is not added.\");\r\n\r\n        stakingPeriods[period].enabled = status;\r\n\r\n        emit SetPeriodStatus(period, status);\r\n    }\r\n\r\n    /**\r\n    * method called from offchain - chainlink\r\n    * call performUnkeep with partyId if returns true\r\n    **/\r\n    function checkUpkeep(bytes calldata /*checkData*/) external override view returns (bool, bytes memory) {\r\n        for(uint256 i = 0; i < periodCounter.current(); i ++){\r\n            uint256  _period = periodIndices[i];\r\n            StakingPeriod storage _stakingPeriod = stakingPeriods[_period];\r\n            if(_stakingPeriod.currentPartyIndex < _stakingPeriod.partyCount){\r\n                uint256 _partyId = periodBurnParties[_period][_stakingPeriod.currentPartyIndex];\r\n                if (\r\n                    burnParties[_partyId].started == true && \r\n                    burnParties[_partyId].ended == false && \r\n                    block.timestamp >= burnParties[_partyId].burnDate\r\n                )\r\n                {\r\n                    return (true, abi.encode(_partyId));\r\n                }    \r\n            }\r\n        }\r\n        return (false, abi.encode(\"\"));\r\n    }\r\n    \r\n    /**\r\n    * method called from offchain - chainlink\r\n    * call performUnkeep with partyId if returns true\r\n    **/\r\n    function performUpkeep(bytes calldata performData) external override {\r\n        (uint256 partyId) = abi.decode(performData, (uint256));\r\n        BurnParty storage party = burnParties[partyId];\r\n        require(party.started == true, \"EGBurnParty: Party has not started.\");\r\n        require(party.ended == false, \"EGBurnParty: Party has already ended.\");\r\n        require(block.timestamp >= party.burnDate, \"EGBurnParty: You can cancel a burn party only after burn date.\");\r\n        \r\n        if(party.currentQuantity >= party.requiredQuantity)\r\n            endBurnParty(partyId);\r\n        else\r\n            cancelBurnParty(partyId);\r\n    }\r\n\r\n\r\n    function existBurnToken(address tokenAddress) public view returns (bool){\r\n        require(tokenAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn token\");\r\n\r\n        return tokenAddress == burnTokenIndices[burnTokens[tokenAddress].index];\r\n    }\r\n\r\n    /**\r\n    * @param tokenAddress       burn token address\r\n    * @param burnAddress        burning address\r\n    * @param minStakeAmount     init stake amount\r\n    * @param maxStakeAmount     max stake amount\r\n    * @dev  add burn token\r\n    *       fire `AddBurnToken` event\r\n    */\r\n    function addBurnToken(address tokenAddress, address burnAddress, uint256 minStakeAmount, uint256 maxStakeAmount) external onlyOwner {\r\n        require(tokenAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn token\");\r\n        require(burnAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn address\");\r\n        require(minStakeAmount > 0, \"EGBurnParty: Stake amount should be a positive number.\");\r\n        if(maxStakeAmount > 0){ // if zero maxStakeAmount means no limit of transactions\r\n            require(maxStakeAmount >= minStakeAmount, \"EGBurnParty: Max stake amount should be zero or bigger than the minimum stake amount.\");\r\n        }\r\n        require(existBurnToken(tokenAddress) == false, \"EGBurnParty: Token has been already added.\");\r\n        \r\n        BurnToken memory burnToken = BurnToken({\r\n            index: burnTokenCounter.current(),\r\n            token: tokenAddress,\r\n            burnAddress: burnAddress,\r\n            minStakeAmount: minStakeAmount,\r\n            maxStakeAmount: maxStakeAmount,\r\n            enabled: true\r\n        });\r\n        burnTokens[tokenAddress] = burnToken;\r\n        burnTokenIndices[burnTokenCounter.current()] = tokenAddress;\r\n\r\n        burnTokenCounter.increment();\r\n\r\n        emit AddBurnToken(tokenAddress, burnAddress, minStakeAmount, maxStakeAmount);\r\n    }\r\n\r\n    /**\r\n    * @param tokenAddress       burn token address\r\n    * @param minStakeAmount    initial stake amount\r\n    * @dev  set the initial stake amount\r\n    *       fire `SetMinStakeAmount` event\r\n    */\r\n    function setMinStakeAmount(address tokenAddress, uint256 minStakeAmount) external onlyOwner {\r\n        require(tokenAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn token\");\r\n        require(minStakeAmount > 0, \"EGBurnParty: Initial stake amount should be a positive number.\");\r\n        if(burnTokens[tokenAddress].maxStakeAmount > 0){ // if zero maxStakeAmount means no limit of transactions\r\n            require(minStakeAmount <= burnTokens[tokenAddress].maxStakeAmount, \"EGBurnParty: Stake amount should be smaller than the max stake amount.\");\r\n        }\r\n        require(existBurnToken(tokenAddress) == true, \"EGBurnParty: The token is not added as a burn token.\");\r\n\r\n        burnTokens[tokenAddress].minStakeAmount = minStakeAmount;\r\n\r\n        emit SetMinStakeAmount(tokenAddress, minStakeAmount);\r\n    }\r\n\r\n    /**\r\n    * @param tokenAddress       burn token address\r\n    * @param maxStakeAmount     max stake amount\r\n    * @dev  set the max stake amount\r\n    *       fire `SetMaxStakeAmount` event\r\n    */\r\n    function setMaxStakeAmount(address tokenAddress, uint256 maxStakeAmount) external onlyOwner {\r\n        require(tokenAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn token\");\r\n        if(maxStakeAmount > 0){ // if zero maxStakeAmount means no limit of transactions\r\n            require(maxStakeAmount >= burnTokens[tokenAddress].minStakeAmount, \"EGBurnParty: Max stake amount should be zero or bigger than the minimum stake amount.\");\r\n        }\r\n        require(existBurnToken(tokenAddress) == true, \"EGBurnParty: The token is not added as a burn token.\");\r\n\r\n        burnTokens[tokenAddress].maxStakeAmount = maxStakeAmount;\r\n\r\n        emit SetMaxStakeAmount(tokenAddress, maxStakeAmount);\r\n    }\r\n\r\n    /**\r\n    * @param tokenAddress       burn token address\r\n    * @param status    burn token status\r\n    * @dev  enable or disable this burn token\r\n    *       fire `SetMinStakeAmount` event\r\n    */\r\n    function setBurnTokenStatus(address tokenAddress, bool status) external onlyOwner {\r\n        require(tokenAddress != address(0), \"EGBurnParty: The zero address should not be added as a burn token\");\r\n        require(existBurnToken(tokenAddress) == true, \"EGBurnParty: The token is not added as a burn token.\");\r\n\r\n        burnTokens[tokenAddress].enabled = status;\r\n\r\n        emit SetBurnTokenStatus(tokenAddress, status);\r\n    }\r\n\r\n    /**\r\n    * @param token burn token\r\n    * @param requiredQuantity minium amount for burnning\r\n    *\r\n    * @dev  create burn party object\r\n    *       insert object into `burnParties`\r\n    *       fire `CreateBurnParty` event\r\n    */\r\n    function createBurnParty(\r\n        string calldata partyAPI,\r\n        address token,\r\n        uint256 period,\r\n        uint256 requiredQuantity,\r\n        uint256 stakeAmount\r\n    )\r\n        external payable\r\n    {\r\n        BurnToken storage _burnToken = burnTokens[token];\r\n         require( bytes(partyAPI).length > 0, \r\n            \"EGBurnParty: Empty string should not be added as a partyAPI\");\r\n        require( token != address(0), \r\n            \"EGBurnParty: The zero address should not be a party token\");\r\n        require(existBurnToken(token) == true, \r\n            \"EGBurnParty: The token is not added as a burn token.\");\r\n        require(_burnToken.enabled == true, \r\n            \"EGBurnParty: The token is not enabled\");\r\n        require(period > 0, \r\n            \"EGBurnParty: The period should be a positive number\");\r\n        require(existPeriod(period) == true, \r\n            \"EGBurnParty: The period is not added.\");\r\n        require(stakingPeriods[period].enabled == true, \r\n            \"EGBurnParty: The period is not enabled.\");\r\n        require(requiredQuantity > 0, \r\n            \"EGBurnParty: Required quantity should be a positive number.\");\r\n        require(stakeAmount >= _burnToken.minStakeAmount,\r\n            \"EGBurnParty: Stake amount should be greater than the min stake amount.\");\r\n        if(_burnToken.maxStakeAmount > 0){ // if zero maxStakeAmount means no limit of transactions\r\n            require(requiredQuantity <= _burnToken.maxStakeAmount, \r\n            \"EGBurnParty: Required quantity should be smaller than the max stake amount.\");\r\n            require(stakeAmount <= _burnToken.maxStakeAmount,\r\n            \"EGBurnParty: Stake amount should be smaller than the max stake amount.\");\r\n        }\r\n        require(msg.value >= gasFeeAmount,\r\n            \"EGBurnParty: Insufficent value for gas fee\");\r\n        require(IERC20(token).balanceOf(msg.sender) >= stakeAmount,\r\n            \"EGBurnParty: There is not the enough tokens in your wallet to create burn party.\");\r\n\r\n        uint256 _burnDate = block.timestamp + period * 60;\r\n        uint256 _partyId = partyCounter.current();\r\n\r\n        BurnParty memory party = BurnParty({\r\n            partyId: _partyId,\r\n            partyAPI: partyAPI,\r\n            creator: msg.sender,\r\n            token: token,\r\n            burnDate: _burnDate,\r\n            period: period,\r\n            currentQuantity: stakeAmount,\r\n            requiredQuantity: requiredQuantity,\r\n            maxStakeAmount: _burnToken.maxStakeAmount,\r\n            stakeCounter: 1,\r\n            started: true,\r\n            cancelled: false,\r\n            ended: false\r\n        });\r\n\r\n        burnParties[_partyId] = party;\r\n        StakeInfo memory _stakeInfo = StakeInfo({\r\n            amount: stakeAmount,\r\n            unstaked: false\r\n        });\r\n        stakesList[msg.sender][_partyId] = _stakeInfo;\r\n        periodBurnParties[period][stakingPeriods[period].partyCount] = _partyId;\r\n        stakingPeriods[period].partyCount ++;\r\n        partyCounter.increment();\r\n\r\n        IERC20(token).transferFrom(msg.sender, address(this), stakeAmount);\r\n\r\n        emit CreateBurnParty(\r\n            _partyId, \r\n            partyAPI,\r\n            msg.sender,\r\n            token, \r\n            block.timestamp,\r\n            period,\r\n            requiredQuantity, \r\n            stakeAmount,\r\n            _burnToken.minStakeAmount,\r\n            _burnToken.maxStakeAmount,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @param partyId burn party id\r\n    * @dev end burn party by id\r\n    *      fire `EndBurnParty` event\r\n    */\r\n    function endBurnParty(uint256 partyId) public {\r\n        BurnParty storage _party = burnParties[partyId];\r\n        require(_party.started == true, \"EGBurnParty: Party is not started.\");\r\n        require(_party.ended == false, \"EGBurnParty: Party has already ended.\");\r\n        require(block.timestamp >= _party.burnDate, \r\n                \"EGBurnParty: You can end burn party after burn date.\");\r\n        require(IERC20(_party.token).balanceOf(address(this)) >= _party.currentQuantity, \r\n                \"EGBurnParty: Current balance of token is not enough to end the burn party.\");\r\n        require(_party.currentQuantity >= _party.requiredQuantity, \r\n            \"EGBurnParty: Tokens currently staked are less than the quantity required for the burn\");\r\n\r\n        _party.ended = true;\r\n        stakingPeriods[_party.period].currentPartyIndex ++;\r\n\r\n        IERC20(_party.token)\r\n            .transfer(burnTokens[_party.token].burnAddress, _party.currentQuantity);\r\n\r\n        emit EndBurnParty(partyId, msg.sender, _party.token, _party.currentQuantity, burnTokens[_party.token].burnAddress);\r\n    }\r\n\r\n    /**\r\n    * @param partyId burn party id\r\n    * @dev cancel burn party by id\r\n    *      fire `CancelBurnParty` event\r\n    */\r\n    function cancelBurnParty(uint256 partyId) public {\r\n        BurnParty storage _party = burnParties[partyId];\r\n        require(_party.started == true, \"EGBurnParty: Party is not started.\");\r\n        require(_party.ended == false, \"EGBurnParty: Party has already ended.\");\r\n        require(block.timestamp >= _party.burnDate, \"EGBurnParty: You can cancel a burn party only after burn date.\");\r\n        require(_party.currentQuantity < _party.requiredQuantity, \r\n                \"EGBurnParty: You cannot cancel a burn party which has collected the required amount of tokens.\");\r\n\r\n        _party.ended = true;\r\n        _party.cancelled = true;\r\n\r\n        stakingPeriods[_party.period].currentPartyIndex ++;\r\n\r\n        emit CancelBurnParty(partyId, msg.sender, _party.token, _party.currentQuantity);\r\n    }\r\n\r\n    /**\r\n    * @param partyId burn party id\r\n    * @param tokenAmount stake token amount\r\n    * @dev  fire `StakeBurnParty` event\r\n    */\r\n    function stakeBurnParty(uint256 partyId, uint256 tokenAmount) external payable{\r\n        BurnParty storage _party = burnParties[partyId];\r\n        require(tokenAmount > 0, \"EGBurnParty: Amount required to burn should be a positive number.\");\r\n        if(_party.maxStakeAmount > 0){ // if zero maxStakeAmount means no limit of transactions\r\n            require(tokenAmount + _party.currentQuantity <= _party.maxStakeAmount, \"EGBurnParty: Amount required to burn should be smaller than the available stake amount.\");\r\n        }\r\n        require(_party.started == true, \"EGBurnParty: Burn Party has not started.\");\r\n        require(_party.ended == false, \"EGBurnParty: Burn Party has ended.\");\r\n        require(msg.value >= gasFeeAmount,\r\n            \"EGBurnParty: Not insufficent value for gas fee\");\r\n        require(IERC20(_party.token).balanceOf(msg.sender) >= tokenAmount, \"EGBurnParty: Your token balance is insufficient for this burn party stake.\");\r\n\r\n        if(stakesList[msg.sender][partyId].amount == 0){\r\n            _party.stakeCounter ++;\r\n        }\r\n\r\n        _party.currentQuantity += tokenAmount;\r\n        stakesList[msg.sender][partyId].amount += tokenAmount;\r\n\r\n        IERC20(_party.token).transferFrom(msg.sender, address(this), tokenAmount);   \r\n\r\n        emit StakeBurnParty(partyId, msg.sender, tokenAmount, msg.value);\r\n    }\r\n\r\n    /**\r\n    * @param partyId burn party id\r\n    * @dev fire `UnstakeFromBurnParty` event\r\n    */\r\n    function unstakeFromBurnParty(uint256 partyId) external {\r\n        BurnParty storage _party = burnParties[partyId];\r\n        StakeInfo storage _stakeInfo = stakesList[msg.sender][partyId];\r\n        require(_stakeInfo.amount > 0, \"EGBurnParty: You have not participated in this burn party.\");\r\n        require(!_stakeInfo.unstaked, \"EGBurnParty: You have already unstaked from this burn party.\");\r\n        require( _party.cancelled == true, \r\n                 \"EGBurnParty: You can unstake when the burn party is cancelled or after burn date.\");\r\n        require(IERC20(_party.token).balanceOf(address(this)) >= _stakeInfo.amount, \r\n                \"EGBurnParty: Out of balance.\");\r\n        \r\n        _party.currentQuantity -= _stakeInfo.amount;\r\n        _party.stakeCounter--;\r\n        \r\n        stakesList[msg.sender][partyId].unstaked = true;\r\n        \r\n        IERC20(_party.token).transfer(msg.sender, _stakeInfo.amount);\r\n\r\n        emit UnstakeFromBurnParty(partyId, msg.sender, _stakeInfo.amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"AddBurnToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"AddPeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CancelBurnParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"partyAPI\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"requiredQuantity\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFeeAmount\",\"type\":\"uint256\"}],\"name\":\"CreateBurnParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"burnAddress\",\"type\":\"address\"}],\"name\":\"EndBurnParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"RemovePeriod\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetBurnTokenStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"SetGasFeeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"SetMaxStakeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"}],\"name\":\"SetMinStakeAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetPeriodStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasFeeAmount\",\"type\":\"uint256\"}],\"name\":\"StakeBurnParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeFromBurnParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawGasFee\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"addBurnToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"addPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnParties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"partyAPI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"burnDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeCounter\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"started\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"cancelled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"ended\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnTokenCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"burnTokenIndices\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"burnAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"}],\"name\":\"cancelBurnParty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"checkUpkeep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"partyAPI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requiredQuantity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"createBurnParty\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"}],\"name\":\"endBurnParty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"existBurnToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"existPeriod\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"partyCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"performData\",\"type\":\"bytes\"}],\"name\":\"performUpkeep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodBurnParties\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"periodCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"periodIndices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"removePeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setBurnTokenStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"}],\"name\":\"setGasFeeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minStakeAmount\",\"type\":\"uint256\"}],\"name\":\"setMinStakeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPeriodStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"stakeBurnParty\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakesList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"unstaked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakingPeriods\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"partyCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPartyIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"partyId\",\"type\":\"uint256\"}],\"name\":\"unstakeFromBurnParty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"feeAddress\",\"type\":\"address\"}],\"name\":\"withdrawGasFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EGBurnParty", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://27913ab4aa671a2e2a8d1050864b55d0f915cc090ed1220585ccc345b9c496d0"}]}