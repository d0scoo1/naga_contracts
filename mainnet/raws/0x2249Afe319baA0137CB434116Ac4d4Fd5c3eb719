{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/mainnet/connectors/dsa-spell/main.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title DSA Spell.\\n * @dev Cast spells on DSA.\\n */\\n\\nimport { AccountInterface } from \\\"../../common/interfaces.sol\\\";\\nimport { Stores } from \\\"../../common/stores.sol\\\";\\nimport { Events } from \\\"./events.sol\\\";\\n\\nabstract contract DSASpellsResolver is Events, Stores {\\n\\t/**\\n\\t *@dev Casts spells on a DSA, caller DSA should be an auth of the target DSA. Reverts if any spell failed.\\n\\t *@notice Interact with a target DSA by casting spells on it.\\n\\t *@param targetDSA target DSA to cast spells on.\\n\\t *@param connectors Array of connector names (For example, [\\\"1INCH-A\\\", \\\"BASIC-A\\\"]).\\n\\t *@param datas Array of connector calldatas (function selectors encoded with parameters).\\n\\t */\\n\\tfunction castOnDSA(\\n\\t\\taddress targetDSA,\\n\\t\\tstring[] memory connectors,\\n\\t\\tbytes[] memory datas\\n\\t)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory _eventName, bytes memory _eventParam)\\n\\t{\\n\\t\\trequire(instaList.accountID(targetDSA) != 0, \\\"not-a-DSA\\\");\\n\\n\\t\\tAccountInterface(targetDSA).cast(connectors, datas, address(this));\\n\\n\\t\\t_eventName = \\\"LogCastOnDSA(address,string[],bytes[])\\\";\\n\\t\\t_eventParam = abi.encode(targetDSA, connectors, datas);\\n\\t}\\n\\n\\t/**\\n\\t *@dev Casts spell on caller DSA. Stops casting further spells as soon as a spell gets casted successfully.\\n\\t * Reverts if none of the spells is successful.\\n\\t *@notice Casts the first successful spell on the DSA.\\n\\t *@param connectors Array of connector names, in preference order, if any (For example, [\\\"1INCH-A\\\", \\\"ZEROX-A\\\"]).\\n\\t *@param datas Array of connector calldatas (function selectors encoded with parameters).\\n\\t */\\n\\tfunction castAny(string[] memory connectors, bytes[] memory datas)\\n\\t\\texternal\\n\\t\\tpayable\\n\\t\\treturns (string memory eventName, bytes memory eventParam)\\n\\t{\\n\\t\\tuint256 _length = connectors.length;\\n\\t\\trequire(_length > 0, \\\"zero-length-not-allowed\\\");\\n\\t\\trequire(datas.length == _length, \\\"calldata-length-invalid\\\");\\n\\n\\t\\t(bool isOk, address[] memory _connectors) = instaConnectors\\n\\t\\t\\t.isConnectors(connectors);\\n\\t\\trequire(isOk, \\\"connector-names-invalid\\\");\\n\\n\\t\\tstring memory _connectorName;\\n\\t\\tstring memory _eventName;\\n\\t\\tbytes memory _eventParam;\\n\\t\\tbytes memory returnData;\\n\\t\\tbool success;\\n\\n\\t\\tfor (uint256 i = 0; i < _length; i++) {\\n\\t\\t\\t(success, returnData) = _connectors[i].delegatecall(datas[i]);\\n\\n\\t\\t\\tif (success) {\\n\\t\\t\\t\\t_connectorName = connectors[i];\\n\\t\\t\\t\\t(_eventName, _eventParam) = abi.decode(\\n\\t\\t\\t\\t\\treturnData,\\n\\t\\t\\t\\t\\t(string, bytes)\\n\\t\\t\\t\\t);\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trequire(success, \\\"dsa-spells-failed\\\");\\n\\n\\t\\teventName = \\\"LogCastAny(string[],string,string,bytes)\\\";\\n\\t\\teventParam = abi.encode(\\n\\t\\t\\tconnectors,\\n\\t\\t\\t_connectorName,\\n\\t\\t\\t_eventName,\\n\\t\\t\\t_eventParam\\n\\t\\t);\\n\\t}\\n}\\n\\ncontract ConnectV2DSASpell is DSASpellsResolver {\\n\\tstring public name = \\\"DSA-Spell-v1.0\\\";\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/common/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\ninterface TokenInterface {\\n    function approve(address, uint256) external;\\n    function transfer(address, uint) external;\\n    function transferFrom(address, address, uint) external;\\n    function deposit() external payable;\\n    function withdraw(uint) external;\\n    function balanceOf(address) external view returns (uint);\\n    function decimals() external view returns (uint);\\n    function totalSupply() external view returns (uint);\\n}\\n\\ninterface MemoryInterface {\\n    function getUint(uint id) external returns (uint num);\\n    function setUint(uint id, uint val) external;\\n}\\n\\ninterface InstaMapping {\\n    function cTokenMapping(address) external view returns (address);\\n    function gemJoinMapping(bytes32) external view returns (address);\\n}\\n\\ninterface AccountInterface {\\n    function enable(address) external;\\n    function disable(address) external;\\n    function isAuth(address) external view returns (bool);\\n    function cast(\\n        string[] calldata _targetNames,\\n        bytes[] calldata _datas,\\n        address _origin\\n    ) external payable returns (bytes32[] memory responses);\\n}\\n\\ninterface ListInterface {\\n    function accountID(address) external returns (uint64);\\n}\\n\\ninterface InstaConnectors {\\n    function isConnectors(string[] calldata) external returns (bool, address[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/common/stores.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\n\\nimport { MemoryInterface, InstaMapping, ListInterface, InstaConnectors } from \\\"./interfaces.sol\\\";\\n\\n\\nabstract contract Stores {\\n\\n  /**\\n   * @dev Return ethereum address\\n   */\\n  address constant internal ethAddr = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n  /**\\n   * @dev Return Wrapped ETH address\\n   */\\n  address constant internal wethAddr = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\n  /**\\n   * @dev Return memory variable address\\n   */\\n  MemoryInterface constant internal instaMemory = MemoryInterface(0x8a5419CfC711B2343c17a6ABf4B2bAFaBb06957F);\\n\\n  /**\\n   * @dev Return InstaDApp Mapping Addresses\\n   */\\n  InstaMapping constant internal instaMapping = InstaMapping(0xe81F70Cc7C0D46e12d70efc60607F16bbD617E88);\\n\\n  /**\\n   * @dev Return InstaList Address\\n   */\\n  ListInterface internal constant instaList = ListInterface(0x4c8a1BEb8a87765788946D6B19C6C6355194AbEb);\\n\\n  /**\\n\\t * @dev Return connectors registry address\\n\\t */\\n\\tInstaConnectors internal constant instaConnectors = InstaConnectors(0x97b0B3A8bDeFE8cB9563a3c610019Ad10DB8aD11);\\n\\n  /**\\n   * @dev Get Uint value from InstaMemory Contract.\\n   */\\n  function getUint(uint getId, uint val) internal returns (uint returnVal) {\\n    returnVal = getId == 0 ? val : instaMemory.getUint(getId);\\n  }\\n\\n  /**\\n  * @dev Set Uint value in InstaMemory Contract.\\n  */\\n  function setUint(uint setId, uint val) virtual internal {\\n    if (setId != 0) instaMemory.setUint(setId, val);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/mainnet/connectors/dsa-spell/events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.7.0;\\npragma abicoder v2;\\n\\ncontract Events {\\n\\tevent LogCastOnDSA(\\n\\t\\taddress indexed targetDSA,\\n\\t\\tstring[] connectors,\\n\\t\\tbytes[] datas\\n\\t);\\n\\tevent LogCastAny(\\n\\t\\tstring[] connectors,\\n\\t\\tstring connectorName,\\n\\t\\tstring eventName,\\n\\t\\tbytes eventParam\\n\\t);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"connectors\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"connectorName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"eventParam\",\"type\":\"bytes\"}],\"name\":\"LogCastAny\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"targetDSA\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"connectors\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"LogCastOnDSA\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"connectors\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"castAny\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"targetDSA\",\"type\":\"address\"},{\"internalType\":\"string[]\",\"name\":\"connectors\",\"type\":\"string[]\"},{\"internalType\":\"bytes[]\",\"name\":\"datas\",\"type\":\"bytes[]\"}],\"name\":\"castOnDSA\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"_eventName\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"_eventParam\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ConnectV2DSASpell", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}