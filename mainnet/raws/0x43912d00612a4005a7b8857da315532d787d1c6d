{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n\\npragma solidity ^0.6.0;\\n\\n\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\ninterface ILoyaltyPool {\\n\\tfunction enter(uint256 amount) external;\\n\\tfunction leave(uint256 shares) external;\\n}\\n\\ninterface ISimpleUniswap {\\n    function swapExactTokensForTokens(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint256 deadline\\n    ) external;\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n\\n\\npragma solidity ^0.6.0;\\n\\n\\ncontract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = msg.sender;\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"},\"\uc5f0\uc2b5\uc6a9 \uac70\ub798 \ucee8\ud2b8\ub799\ud2b8.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\npragma solidity ^0.6.0;\\n\\n\\n\\ncontract ADXLoyaltyArb is Ownable {\\n\\tISimpleUniswap public constant uniswap = ISimpleUniswap(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);\\n\\tIERC20 public constant ADX = IERC20(0xADE00C28244d5CE17D72E40330B1c318cD12B7c3);\\n\\tIERC20 public constant ADXL = IERC20(0xd9A4cB9dc9296e111c66dFACAb8Be034EE2E1c2C);\\n\\n\\tconstructor() public {\\n\\t\\tADX.approve(address(uniswap), uint(-1));\\n\\t\\tADX.approve(address(ADXL), uint(-1));\\n\\t\\tADXL.approve(address(uniswap), uint(-1));\\n\\t\\tADXL.approve(address(ADXL), uint(-1));\\n\\t}\\n\\n\\t// No need to check success here, no safeerc20\\n\\tfunction withdrawTokens(IERC20 token, uint amount) onlyOwner external {\\n\\t\\ttoken.transfer(msg.sender, amount);\\n\\t}\\n\\n\\tfunction tradeOnUni(address input, address output, uint amount) internal {\\n\\t\\taddress[] memory path = new address[](3);\\n\\t\\tpath[0] = input;\\n\\t\\t// WETH\\n\\t\\tpath[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n\\t\\tpath[2] = output;\\n\\t\\tuniswap.swapExactTokensForTokens(amount, uint(0), path, address(this), block.timestamp);\\n\\t}\\n\\n\\tfunction loyaltyTradesHigher(uint amountToSell) external {\\n\\t\\trequire(ADX.balanceOf(address(this)) == 0, \\u0027must not have adx\\u0027);\\n\\t\\tuint initial = ADXL.balanceOf(address(this));\\n\\t\\t// sell adx-loyalty on uniswap\\n\\t\\ttradeOnUni(address(ADXL), address(ADX), amountToSell);\\n\\t\\t// mint adx-loyalty with the ADX (profit adx-loyalty)\\n\\t\\tILoyaltyPool(address(ADXL)).enter(ADX.balanceOf(address(this)));\\n\\t\\t// safety check\\n\\t\\trequire(ADXL.balanceOf(address(this)) \\u003e initial, \\u0027did not make profit\\u0027);\\n\\t}\\n\\n\\tfunction loyaltyTradesLower(uint amountToBurn) external {\\n\\t\\trequire(ADX.balanceOf(address(this)) == 0, \\u0027must not have adx\\u0027);\\n\\t\\tuint initial = ADXL.balanceOf(address(this));\\n\\t\\t// burn adx-loyalty to receive adx\\n\\t\\tILoyaltyPool(address(ADXL)).leave(amountToBurn);\\n\\t\\t// buy adx-loyalty with adx (profit adx-loyalty)\\n\\t\\ttradeOnUni(address(ADX), address(ADXL), ADX.balanceOf(address(this)));\\n\\t\\t// safety check\\n\\t\\trequire(ADXL.balanceOf(address(this)) \\u003e initial, \\u0027did not make profit\\u0027);\\n\\t}\\n}\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ADX\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ADXL\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToSell\",\"type\":\"uint256\"}],\"name\":\"loyaltyTradesHigher\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountToBurn\",\"type\":\"uint256\"}],\"name\":\"loyaltyTradesLower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract ISimpleUniswap\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ADXLoyaltyArb", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://841c25e1b304b6ed554d64b8d36632dae578ea3b9755d2f9cd77e33b8ae58693"}]}