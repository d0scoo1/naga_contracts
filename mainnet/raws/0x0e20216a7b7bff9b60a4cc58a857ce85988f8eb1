{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: BUSL-1.1\r\n\r\npragma solidity 0.8.6;\r\n\r\n\r\n\r\n// Part: IBetaInterestModel\r\n\r\ninterface IBetaInterestModel {\r\n  /// @dev Returns the initial interest rate per year (times 1e18).\r\n  function initialRate() external view returns (uint);\r\n\r\n  /// @dev Returns the next interest rate for the market.\r\n  /// @param prevRate The current interest rate.\r\n  /// @param totalAvailable The current available liquidity.\r\n  /// @param totalLoan The current outstanding loan.\r\n  /// @param timePast The time past since last interest rate rebase in seconds.\r\n  function getNextInterestRate(\r\n    uint prevRate,\r\n    uint totalAvailable,\r\n    uint totalLoan,\r\n    uint timePast\r\n  ) external view returns (uint);\r\n}\r\n\r\n// Part: OpenZeppelin/openzeppelin-contracts@4.2.0/Math\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute.\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\n// File: BetaInterestModelV1.sol\r\n\r\ncontract BetaInterestModelV1 is IBetaInterestModel {\r\n  uint public immutable override initialRate;\r\n  uint public immutable minRate;\r\n  uint public immutable maxRate;\r\n  uint public immutable adjustRate; // between 0 and 1e18, the higher the more aggressive\r\n\r\n  constructor(\r\n    uint _initialRate,\r\n    uint _minRate,\r\n    uint _maxRate,\r\n    uint _adjustRate\r\n  ) {\r\n    require(_minRate < _maxRate, 'constructor/bad-min-max-rate');\r\n    require(_adjustRate < 1e18, 'constructor/bad-adjust-rate');\r\n    initialRate = _initialRate;\r\n    minRate = _minRate;\r\n    maxRate = _maxRate;\r\n    adjustRate = _adjustRate;\r\n  }\r\n\r\n  /// @dev Returns the next interest rate for the market.\r\n  /// @param prevRate The current interest rate.\r\n  /// @param totalAvailable The current available liquidity.\r\n  /// @param totalLoan The current outstanding loan.\r\n  /// @param timePassed The time passed since last interest rate rebase in seconds.\r\n  /// @notice At utilization 0-50%, the interest rate will decrease at half-per-day rate\r\n  ///         At utilization 50-70%, the interest rate will decrease linearly from 0 to half-per-day rate\r\n  ///         At utilization 70-80%, the interest rate will stay the same.\r\n  ///         At utilization 80-100%, the interest rate will increase linearly from 0 to twice-per-day rate.\r\n  function getNextInterestRate(\r\n    uint prevRate,\r\n    uint totalAvailable,\r\n    uint totalLoan,\r\n    uint timePassed\r\n  ) external view override returns (uint) {\r\n    uint totalLiquidity = totalAvailable + totalLoan;\r\n    if (totalLiquidity == 0) {\r\n      return prevRate;\r\n    }\r\n    uint utilRate = (totalLoan * 1e18) / totalLiquidity;\r\n    uint cappedtimePassed = Math.min(timePassed, 1 days);\r\n    uint multRate;\r\n    if (utilRate < 0.5e18) {\r\n      // utilization 0-50%, decrease at half-per-day rate\r\n      multRate = 1e18 - (adjustRate * cappedtimePassed) / 1 days;\r\n    } else if (utilRate < 0.7e18) {\r\n      // utilization 50-70%, decrease linearly from 0 to half-per-day rate, depending on how far the utilization is from 70%\r\n      uint downScale = (0.7e18 - utilRate) * 5; // *5 is equivalent to /0.2\r\n      multRate = 1e18 - (adjustRate * downScale * cappedtimePassed) / 1 days / 1e18;\r\n    } else if (utilRate < 0.8e18) {\r\n      // utilization 70-80%, stay the same\r\n      multRate = 1e18;\r\n    } else {\r\n      // utilization 80-100%, increase linearly from 0 to twice-per-day rate, depending on how far the utilization is from 80%\r\n      uint upScale = (utilRate - 0.8e18) * 5; // *5 is equivalent to /0.2\r\n      uint upMaxRate = 1e36 / (1e18 - adjustRate) - 1e18;\r\n      multRate = 1e18 + (upMaxRate * upScale * cappedtimePassed) / 1 days / 1e18;\r\n    }\r\n    uint targetRate = (prevRate * multRate) / 1e18;\r\n    return Math.min(Math.max(targetRate, minRate), maxRate);\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_initialRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_adjustRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"adjustRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prevRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAvailable\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalLoan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timePassed\",\"type\":\"uint256\"}],\"name\":\"getNextInterestRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BetaInterestModelV1", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000004563918244f40000000000000000000000000000000000000000000000000000002386f26fc100000000000000000000000000000000000000000000000000008ac7230489e8000000000000000000000000000000000000000000000000000006f05b59d3b20000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3b2d112513ffadd691ec6e8e32803a0f70f1406834c1b36cd2fdee55523e22f6"}]}