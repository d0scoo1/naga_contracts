{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\npragma solidity >=0.8.4;\r\n\r\n/// @notice Safe ETH and ERC-20 transfer library that gracefully handles missing return values\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\nlibrary SafeTransferLib {\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error ETHtransferFailed();\r\n    error TransferFailed();\r\n    error TransferFromFailed();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ETH Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // transfer the ETH and store if it succeeded or not\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        if (!success) revert ETHtransferFailed();\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// ERC-20 Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function _safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n            // write the abi-encoded calldata into memory, beginning with the function selector\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // append the 'to' argument\r\n            mstore(add(freeMemoryPointer, 36), amount) // append the 'amount' argument\r\n\r\n            success := and(\r\n                // set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // we use 68 because the length of our calldata totals up like so: 4 + 32 * 2\r\n                // we use 0 and 32 to copy up to 32 bytes of return data into the scratch space\r\n                // counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        if (!success) revert TransferFailed();\r\n    }\r\n\r\n    function _safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // get a pointer to some free memory\r\n            let freeMemoryPointer := mload(0x40)\r\n            // write the abi-encoded calldata into memory, beginning with the function selector\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), from) // append the 'from' argument\r\n            mstore(add(freeMemoryPointer, 36), to) // append the 'to' argument\r\n            mstore(add(freeMemoryPointer, 68), amount) // append the 'amount' argument\r\n\r\n            success := and(\r\n                // set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // we use 100 because the length of our calldata totals up like so: 4 + 32 * 3\r\n                // we use 0 and 32 to copy up to 32 bytes of return data into the scratch space\r\n                // counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        if (!success) revert TransferFromFailed();\r\n    }\r\n}\r\n\r\n/// @notice Kali DAO access manager interface\r\ninterface IKaliAccessManager {\r\n    function balanceOf(address account, uint256 id) external returns (uint256);\r\n\r\n    function joinList(\r\n        address account,\r\n        uint256 id,\r\n        bytes32[] calldata merkleProof\r\n    ) external payable;\r\n}\r\n\r\n/// @notice Kali DAO share manager interface\r\ninterface IKaliShareManager {\r\n    function mintShares(address to, uint256 amount) external payable;\r\n\r\n    function burnShares(address from, uint256 amount) external payable;\r\n}\r\n\r\n/// @notice EIP-2612 interface\r\ninterface IERC20Permit {\r\n    function permit(\r\n        address owner, \r\n        address spender, \r\n        uint256 value, \r\n        uint256 deadline, \r\n        uint8 v, \r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n/// @notice Single owner access control contract\r\nabstract contract KaliOwnable {\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event ClaimTransferred(address indexed from, address indexed to);\r\n\r\n    error NotOwner();\r\n    error NotPendingOwner();\r\n\r\n    address public owner;\r\n    address public pendingOwner;\r\n\r\n    modifier onlyOwner() {\r\n        if (msg.sender != owner) revert NotOwner();\r\n        _;\r\n    }\r\n\r\n    function _init(address owner_) internal {\r\n        owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner_);\r\n    }\r\n\r\n    function claimOwner() external payable {\r\n        if (msg.sender != pendingOwner) revert NotPendingOwner();\r\n\r\n        emit OwnershipTransferred(owner, msg.sender);\r\n\r\n        owner = msg.sender;\r\n        delete pendingOwner;\r\n    }\r\n\r\n    function transferOwner(address to, bool direct) external payable onlyOwner {\r\n        if (direct) {\r\n            owner = to;\r\n            emit OwnershipTransferred(msg.sender, to);\r\n        } else {\r\n            pendingOwner = to;\r\n            emit ClaimTransferred(msg.sender, to);\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Helper utility that enables calling multiple local methods in a single call\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/v3-periphery/blob/main/contracts/base/Multicall.sol)\r\n/// License-Identifier: GPL-2.0-or-later\r\nabstract contract Multicall {\r\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\r\n        results = new bytes[](data.length);\r\n        \r\n        for (uint256 i; i < data.length; ) {\r\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\r\n\r\n            if (!success) {\r\n                if (result.length < 68) revert();\r\n                    \r\n                assembly {\r\n                    result := add(result, 0x04)\r\n                }\r\n                    \r\n                revert(abi.decode(result, (string)));\r\n            }\r\n\r\n            results[i] = result;\r\n\r\n            // cannot realistically overflow on human timescales\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Gas optimized reentrancy protection for smart contracts\r\n/// @author Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\r\n/// License-Identifier: AGPL-3.0-only\r\nabstract contract ReentrancyGuard {\r\n    error Reentrancy();\r\n    \r\n    uint256 private locked = 1;\r\n\r\n    modifier nonReentrant() {\r\n        if (locked != 1) revert Reentrancy();\r\n        \r\n        locked = 2;\r\n        _;\r\n        locked = 1;\r\n    }\r\n}\r\n\r\n/// @notice Crowdsale contract that receives ETH or ERC-20 to mint registered DAO tokens, including merkle access lists\r\ncontract KaliDAOcrowdsale is KaliOwnable, Multicall, ReentrancyGuard {\r\n    /// -----------------------------------------------------------------------\r\n    /// Library Usage\r\n    /// -----------------------------------------------------------------------\r\n\r\n    using SafeTransferLib for address;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Events\r\n    /// -----------------------------------------------------------------------\r\n\r\n    event ExtensionSet(\r\n        address indexed dao, \r\n        uint256 listId, \r\n        uint8 purchaseMultiplier, \r\n        address purchaseAsset, \r\n        uint32 saleEnds, \r\n        uint96 purchaseLimit, \r\n        uint96 personalLimit,\r\n        string details\r\n    );\r\n    event ExtensionCalled(address indexed dao, address indexed purchaser, uint256 amountOut);\r\n    event KaliRateSet(uint8 kaliRate);\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Errors\r\n    /// -----------------------------------------------------------------------\r\n\r\n    error NullMultiplier();\r\n    error SaleEnded();\r\n    error NotListed();\r\n    error PurchaseLimit();\r\n    error PersonalLimit();\r\n    error RateLimit();\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Sale Storage\r\n    /// -----------------------------------------------------------------------\r\n \r\n    uint8 private kaliRate;\r\n    IKaliAccessManager private immutable accessManager;\r\n    address private immutable wETH;\r\n\r\n    mapping(address => Crowdsale) public crowdsales;\r\n\r\n    struct Crowdsale {\r\n        uint256 listId;\r\n        uint8 purchaseMultiplier;\r\n        address purchaseAsset;\r\n        uint32 saleEnds;\r\n        uint96 purchaseLimit;\r\n        uint96 personalLimit;\r\n        uint256 purchaseTotal;\r\n        string details;\r\n        mapping(address => uint256) personalPurchased;\r\n    }\r\n\r\n    function checkPersonalPurchased(address account, address dao) external view returns (uint256) {\r\n        return crowdsales[dao].personalPurchased[account];\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(IKaliAccessManager accessManager_, address wETH_) {\r\n        accessManager = accessManager_;\r\n        KaliOwnable._init(msg.sender);\r\n        wETH = wETH_;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Multicall Utilities\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function joinList(uint256 id, bytes32[] calldata merkleProof) external payable {\r\n        accessManager.joinList(\r\n            msg.sender,\r\n            id,\r\n            merkleProof\r\n        );\r\n    }\r\n\r\n    function setPermit(\r\n        IERC20Permit token, \r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r, \r\n        bytes32 s\r\n    ) external payable {\r\n        token.permit(\r\n            msg.sender,\r\n            address(this),\r\n            value,\r\n            deadline,\r\n            v,\r\n            r,\r\n            s\r\n        );\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Sale Settings\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function setExtension(bytes calldata extensionData) external payable {\r\n        (\r\n            uint256 listId, \r\n            uint8 purchaseMultiplier,\r\n            address purchaseAsset, \r\n            uint32 saleEnds, \r\n            uint96 purchaseLimit, \r\n            uint96 personalLimit,\r\n            string memory details\r\n        ) \r\n            = abi.decode(extensionData, (uint256, uint8, address, uint32, uint96, uint96, string));\r\n        \r\n        if (purchaseMultiplier == 0) revert NullMultiplier();\r\n\r\n        // caller is stored as `dao` target for sale\r\n        Crowdsale storage sale = crowdsales[msg.sender];\r\n        // we use this format as we have nested mapping\r\n        sale.listId = listId;\r\n        sale.purchaseMultiplier = purchaseMultiplier;\r\n        sale.purchaseAsset = purchaseAsset;\r\n        sale.saleEnds = saleEnds;\r\n        sale.purchaseLimit = purchaseLimit;\r\n        sale.personalLimit = personalLimit;\r\n        sale.details = details;\r\n\r\n        emit ExtensionSet(msg.sender, listId, purchaseMultiplier, purchaseAsset, saleEnds, purchaseLimit, personalLimit, details);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Sale Logic\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function callExtension(address dao, uint256 amount) external payable nonReentrant returns (uint256 amountOut) {\r\n        Crowdsale storage sale = crowdsales[dao];\r\n\r\n        if (block.timestamp > sale.saleEnds) revert SaleEnded();\r\n\r\n        if (sale.listId != 0) \r\n            if (accessManager.balanceOf(msg.sender, sale.listId) == 0) revert NotListed();\r\n\r\n        uint256 total;\r\n        uint256 payment;\r\n\r\n        if (sale.purchaseAsset == address(0) || sale.purchaseAsset == address(0xDead)) {\r\n            total = msg.value;\r\n        } else {\r\n            total = amount;\r\n        }\r\n\r\n        if (kaliRate != 0) {\r\n            uint256 fee = (total * kaliRate) / 100;\r\n            // cannot underflow since fee will be less than total\r\n            unchecked { \r\n                payment = total - fee;\r\n            }\r\n        } else {\r\n            payment = total;\r\n        }\r\n\r\n        amountOut = total * sale.purchaseMultiplier;\r\n\r\n        if (sale.purchaseTotal + amountOut > sale.purchaseLimit) revert PurchaseLimit();\r\n        if (sale.personalPurchased[msg.sender] + amountOut > sale.personalLimit) revert PersonalLimit();\r\n    \r\n        if (sale.purchaseAsset == address(0)) {\r\n            // send ETH to DAO\r\n            dao._safeTransferETH(payment);\r\n        } else if (sale.purchaseAsset == address(0xDead)) {\r\n            // send ETH to wETH\r\n            wETH._safeTransferETH(payment);\r\n            // send wETH to DAO\r\n            wETH._safeTransfer(dao, payment);\r\n        } else {\r\n            // send tokens to DAO\r\n            sale.purchaseAsset._safeTransferFrom(msg.sender, dao, payment);\r\n        }\r\n        \r\n        sale.purchaseTotal += amountOut;\r\n        sale.personalPurchased[msg.sender] += amountOut;\r\n            \r\n        IKaliShareManager(dao).mintShares(msg.sender, amountOut);\r\n\r\n        emit ExtensionCalled(dao, msg.sender, amountOut);\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Sale Management\r\n    /// -----------------------------------------------------------------------\r\n\r\n    function setKaliRate(uint8 kaliRate_) external payable onlyOwner {\r\n        if (kaliRate_ > 100) revert RateLimit();\r\n        kaliRate = kaliRate_;\r\n        emit KaliRateSet(kaliRate_);\r\n    }\r\n\r\n    function claimKaliFees(\r\n        address to, \r\n        address asset, \r\n        uint256 amount\r\n    ) external payable onlyOwner {\r\n        if (asset == address(0)) {\r\n            to._safeTransferETH(amount);\r\n        } else {\r\n            asset._safeTransfer(to, amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IKaliAccessManager\",\"name\":\"accessManager_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wETH_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ETHtransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotListed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotPendingOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NullMultiplier\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PersonalLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PurchaseLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RateLimit\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Reentrancy\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SaleEnded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFromFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"ClaimTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"ExtensionCalled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"purchaseMultiplier\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"purchaseAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"saleEnds\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"purchaseLimit\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"personalLimit\",\"type\":\"uint96\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"name\":\"ExtensionSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"kaliRate\",\"type\":\"uint8\"}],\"name\":\"KaliRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"callExtension\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dao\",\"type\":\"address\"}],\"name\":\"checkPersonalPurchased\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"claimKaliFees\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"crowdsales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"purchaseMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"purchaseAsset\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"saleEnds\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"purchaseLimit\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"personalLimit\",\"type\":\"uint96\"},{\"internalType\":\"uint256\",\"name\":\"purchaseTotal\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"details\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"joinList\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"extensionData\",\"type\":\"bytes\"}],\"name\":\"setExtension\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"kaliRate_\",\"type\":\"uint8\"}],\"name\":\"setKaliRate\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Permit\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"setPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"direct\",\"type\":\"bool\"}],\"name\":\"transferOwner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "KaliDAOcrowdsale", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "000000000000000000000000772e8423e2c90835b85126f67d33e89df792de29000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://59f50870bb4e63b29ebb32beeb08ae4a411b182f54684799dfa6efd6cf4b35e9"}]}