{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TinyKingdomsMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/**\\n * @title TinyKingdoms\\n * @dev Metadata contract for 0x788defd1AE1e2299D54CF9aC3658285Ab1dA0900 by @emrecolako\\n */\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract TinyKingdomsMetadata is Ownable{\\n\\n    using strings for string;\\n    using strings for strings.slice;\\n\\n    address public immutable TinyKingdoms = 0x788defd1AE1e2299D54CF9aC3658285Ab1dA0900;\\n    string public description = \\\"Tiny Kingdoms Metadata\\\";\\n\\n    // Tiny Kingdoms Flags\\n    string private constant Flags=\\\"Rising Sun_Vertical Triband_Chevron_Nordic Cross_Spanish Fess_Five Stripes_Hinomaru_Vertical Bicolor_Saltire_Horizontal Bicolor_Vertical Misplaced Bicolor_Bordure_Inverted Pall_Twenty-four squared_Diagonal Bicolor_Horizontal Triband_Diagonal Bicolor Inverse_Quadrisection_Diagonal Tricolor Inverse_Rising Split Sun_Lonely Star_Diagonal Bicolor Right_Horizontal Bicolor with a star_Bonnie Star_Jolly Roger\\\";\\n    string private constant Nouns=\\\"Eagle_Meditation_Folklore_Star_Light_Play_Palace_Wildflower_Rescue_Fish_Painting_Shadow_Revolution_Planet_Storm_Land_Surrounding_Spirit_Ocean_Night_Snow_River_Sheep_Poison_State_Flame_River_Cloud_Pattern_Water_Forest_Tactic_Fire_Strategy_Space_Time_Art_Stream_Spectrum_Fleet_Ship_Spring_Shore_Plant_Meadow_System_Past_Parrot_Throne_Ken_Buffalo_Perspective_Tear_Moon_Moon_Wing_Summer_Broad_Owls_Serpent_Desert_Fools_Spirit_Crystal_Persona_Dove_Rice_Crow_Ruin_Voice_Destiny_Seashell_Structure_Toad_Shadow_Sparrow_Sun_Sky_Mist_Wind_Smoke_Division_Oasis_Tundra_Blossom_Dune_Tree_Petal_Peach_Birch_Space_Flower_Valley_Cattail_Bulrush_Wilderness_Ginger_Sunset_Riverbed_Fog_Leaf_Fruit_Country_Pillar_Bird_Reptile_Melody_Universe_Majesty_Mirage_Lakes_Harvest_Warmth_Fever_Stirred_Orchid_Rock_Pine_Hill_Stone_Scent_Ocean_Tide_Dream_Bog_Moss_Canyon_Grave_Dance_Hill_Valley_Cave_Meadow_Blackthorn_Mushroom_Bluebell_Water_Dew_Mud_Family_Garden_Stork_Butterfly_Seed_Birdsong_Lullaby_Cupcake_Wish_Laughter_Ghost_Gardenia_Lavender_Sage_Strawberry_Peaches_Pear_Rose_Thistle_Tulip_Wheat_Thorn_Violet_Chrysanthemum_Amaranth_Corn_Sunflower_Sparrow_Sky_Daisy_Apple_Oak_Bear_Pine_Poppy_Nightingale_Mockingbird_Ice_Daybreak_Coral_Daffodil_Butterfly_Plum_Fern_Sidewalk_Lilac_Egg_Hummingbird_Heart_Creek_Bridge_Falling Leaf_Lupine_Creek_Iris Amethyst_Ruby_Diamond_Saphire_Quartz_Clay_Coal_Briar_Dusk_Sand_Scale_Wave_Rapid_Pearl_Opal_Dust_Sanctuary_Phoenix_Moonstone_Agate_Opal_Malachite_Jade_Peridot_Topaz_Turquoise_Aquamarine_Amethyst_Garnet_Diamond_Emerald_Ruby_Sapphire_Typha_Sedge_Wood\\\";\\n    string private constant Adjectives=\\\"Central_Free_United_Socialist_Ancient Republic of_Third Republic of_Eastern_Cyber_Northern_Northwestern_Galactic Empire of_Southern_Solar_Islands of_Kingdom of_State of_Federation of_Confederation of_Alliance of_Assembly of_Region of_Ruins of_Caliphate of_Republic of_Province of_Grand_Duchy of_Capital Federation of_Autonomous Province of_Free Democracy of_Federal Republic of_Unitary Republic of_Autonomous Regime of_New_Old Empire of\\\";\\n    string private constant Suffixes=\\\"Beach_Center_City_Coast_Creek_Estates_Falls_Grove_Heights_Hill_Hills_Island_Lake_Lakes_Park_Point_Ridge_River_Springs_Valley_Village_Woods_Waters_Rivers_Points_ Mountains_Volcanic Ridges_Dunes_Cliffs_Summit\\\";\\n    \\n    uint256[21] colorPalettes = [ \\n        0x006d7783c5beffddd2faf2e5, //[\\\"#006d77\\\", \\\"#83c5be\\\", \\\"#ffddd2\\\", \\\"#faf2e5\\\"], \\n        0x351f39726a95719fb0f6f417, //[\\\"#351f39\\\", \\\"#726a95\\\", \\\"#719fb0\\\", \\\"#f6f4ed\\\"]\\n        0x472e2ae78a46fac459fcefdf, //[\\\"#472e2a\\\", \\\"#e78a46\\\", \\\"#fac459\\\", \\\"#fcefdf\\\"]\\n        0x0d1b2a2f48657b88a7fff8e7, //[\\\"#0d1b2a\\\", \\\"#2f4865\\\", \\\"#7b88a7\\\", \\\"#fff8e7\\\"]\\n        0xe95145f8b917ffb2a2f0f0e8, //[\\\"#e95145\\\", \\\"#f8b917\\\", \\\"#ffb2a2\\\", \\\"#f0f0e8\\\"]\\n        0xc54e84f0bf363a67c2f6f1ec, //[\\\"#c54e84\\\", \\\"#f0bf36\\\", \\\"#3a67c2\\\", \\\"#f6f1ec\\\"]\\n        0xe66357497fe38ea5fff1f0f0, //[\\\"#e66357\\\", \\\"#497fe3\\\", \\\"#8ea5ff\\\", \\\"#f1f0f0\\\"]\\n        0xed7e62f4b6744d598bf3eded, //[\\\"#ed7e62\\\", \\\"#f4b674\\\", \\\"#4d598b\\\", \\\"#f3eded\\\"]\\n        0xd3ee9e00683896cf24fbfbf8, //[\\\"#d3ee9e\\\", \\\"#006838\\\", \\\"#96cf24\\\", \\\"#fbfbf8\\\"]\\n        0xffe8f58756d1d8709cfaf2e5, //[\\\"#ffe8f5\\\", \\\"#8756d1\\\", \\\"#d8709c\\\", \\\"#faf2e5\\\"]\\n        0x533549f6b042f9ed4ef6f4ed, //[\\\"#533549\\\", \\\"#f6b042\\\", \\\"#f9ed4e\\\", \\\"#f6f4ed\\\"]\\n        0x8175a3a3759e443c5bfcefdf, //[\\\"#8175a3\\\", \\\"#a3759e\\\", \\\"#443c5b\\\", \\\"#fcefdf\\\"]\\n        0x788ea53d4c5c7b5179fff8e7, //[\\\"#788ea5\\\", \\\"#3d4c5c\\\", \\\"#7b5179\\\", \\\"#fff8e7\\\"]\\n        0x553c60ffb0a0ff6749f0f0e8, //[\\\"#553c60\\\", \\\"#ffb0a0\\\", \\\"#ff6749\\\", \\\"#f0f0e8\\\"]\\n        0x99c1b249c293467462f6f1ec, //[\\\"#99c1b2\\\", \\\"#49c293\\\", \\\"#467462\\\", \\\"#f6f1ec\\\"]\\n        0xecbfaf0177240e2733f1f0f0, //[\\\"#ecbfaf\\\", \\\"#017724\\\", \\\"#0e2733\\\", \\\"#f1f0f0\\\"]\\n        0xd2deb1567bae60bf3cf3eded, //[\\\"#d2deb1\\\", \\\"#567bae\\\", \\\"#60bf3c\\\", \\\"#f3eded\\\"]\\n        0xfde50058bdbceff0ddfbfbf8, //[\\\"#fde500\\\", \\\"#58bdbc\\\", \\\"#eff0dd\\\", \\\"#fbfbf8\\\"]\\n        0x2f2043f76975e7e8cbfaf2e5, //[\\\"#2f2043\\\", \\\"#f76975\\\", \\\"#e7e8cb\\\", \\\"#faf2e5\\\"]\\n        0x5ec227302f3563bdb3f6f4ed, //[\\\"#5ec227\\\", \\\"#302f35\\\", \\\"#63bdb3\\\", \\\"#f6f4ed\\\"]\\n        0x75974ac83e3cf39140fcefdf  //[\\\"#75974a\\\", \\\"#c83e3c\\\", \\\"#f39140\\\", \\\"#fcefdf\\\"]\\n        ];\\n\\n    /**\\n     * @notice Get Flag names for each Kingdom\\n     */\\n    \\n     function getFlag(uint256 index) internal pure returns (string memory) {\\n        strings.slice memory strSlice = Flags.toSlice();\\n        string memory separatorStr = \\\"_\\\";\\n        strings.slice memory separator = separatorStr.toSlice();\\n        strings.slice memory item;\\n\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    /**\\n     * @notice Getter functions for constructing Kingdom names\\n     */\\n\\n    function getNoun(uint256 index) internal pure returns (string memory) {\\n        strings.slice memory strSlice = Nouns.toSlice();\\n        string memory separatorStr = \\\"_\\\";\\n        strings.slice memory separator = separatorStr.toSlice();\\n        strings.slice memory item;\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    function getAdjective(uint256 index) internal pure returns (string memory) {\\n        strings.slice memory strSlice = Adjectives.toSlice();\\n        string memory separatorStr = \\\"_\\\";\\n        strings.slice memory separator = separatorStr.toSlice();\\n        strings.slice memory item;\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    function getSuffix(uint256 index) internal pure returns (string memory) {\\n        strings.slice memory strSlice = Suffixes.toSlice();\\n        string memory separatorStr = \\\"_\\\";\\n        strings.slice memory separator = separatorStr.toSlice();\\n        strings.slice memory item;\\n        for (uint256 i = 0; i <= index; i++) {\\n            item = strSlice.split(separator);\\n        }\\n        return item.toString();\\n    }\\n\\n    /**\\n     * @notice Get flag index \\n     */\\n\\n    function getFlagIndex(uint256 tokenId) public pure returns (string memory) {\\n        uint256 rand = random(tokenId,\\\"FLAG\\\") % 1000;\\n        uint256 flagIndex =0;\\n\\n        if (rand>980){flagIndex=24;}\\n        else {flagIndex = rand/40;}\\n        \\n        return getFlag(flagIndex);\\n    }\\n\\n    /**\\n     * @notice Check if flag is Jolly Roger\\n     */\\n    \\n    function isPirate(uint256 tokenId) public pure returns (bool flag){\\n        require(tokenId> 0 && tokenId<4097,\\\"tokenId is invalid\\\");\\n        if (keccak256(bytes(getFlagIndex(tokenId))) == keccak256(bytes(\\\"Jolly Roger\\\"))){\\n            flag=true;\\n        } else {\\n            flag=false;\\n        }\\n        return flag;\\n    }\\n\\n    /**\\n     * @notice Returns Kingdom name\\n     */\\n\\n    function getKingdom(uint256 tokenId) public pure returns (string memory){\\n        require(tokenId> 0 && tokenId<4097,\\\"tokenId is invalid\\\");\\n        \\n        uint256 rand = random(tokenId,\\\"PLACE\\\");\\n        string memory a1= (getAdjective((rand / 7) % 35));\\n        string memory n1= (getNoun((rand / 200) % 229));\\n        string memory s1;\\n\\n        if (keccak256(bytes(getFlagIndex(tokenId))) == keccak256(bytes(\\\"Jolly Roger\\\"))) {\\n            s1 = \\\"Pirate Ship\\\";\\n        } else {\\n            s1= (getSuffix((rand/11)%30));\\n        }\\n\\n        string memory output = string(abi.encodePacked(a1,' ',n1,' ',s1));\\n        \\n        return output;\\n    }\\n\\n    function getPalette(uint256 tokenId) public view returns (string memory){\\n        uint256 rand = random(tokenId,\\\"THEME\\\") % 1050;\\n        uint256 themeIndex;\\n        uint256 palette;\\n\\n        if (rand<1000){themeIndex=rand/50;}\\n        else {themeIndex = 20;}\\n        \\n        palette=colorPalettes[themeIndex];        \\n        \\n        return uint2hexstr(palette);\\n\\n    }\\n\\n      function random(uint256 tokenId, string memory seed) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encodePacked(seed, toString(tokenId))));\\n    }\\n\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT license\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n    // https://stackoverflow.com/questions/69301408/solidity-convert-hex-number-to-hex-string\\n    function uint2hexstr(uint i) internal pure returns (string memory) {\\n        if (i == 0) return \\\"0\\\";\\n        uint j = i;\\n        uint length;\\n        while (j != 0) {\\n            length++;\\n            j = j >> 4;\\n        }\\n        uint mask = 15;\\n        bytes memory bstr = new bytes(length);\\n        uint k = length;\\n        while (i != 0) {\\n            uint curr = (i & mask);\\n            bstr[--k] = curr > 9 ?\\n                bytes1(uint8(55 + curr)) :\\n                bytes1(uint8(48 + curr)); // 55 = 65 - 10\\n            i = i >> 4;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\\n/*\\n * @title String & slice utility library for Solidity contracts.\\n * @author Nick Johnson <arachnid@notdot.net>\\n *\\n * @dev Functionality in this library is largely implemented using an\\n *      abstraction called a 'slice'. A slice represents a part of a string -\\n *      anything from the entire string to a single character, or even no\\n *      characters at all (a 0-length slice). Since a slice only has to specify\\n *      an offset and a length, copying and manipulating slices is a lot less\\n *      expensive than copying and manipulating the strings they reference.\\n *\\n *      To further reduce gas costs, most functions on slice that need to return\\n *      a slice modify the original one instead of allocating a new one; for\\n *      instance, `s.split(\\\".\\\")` will return the text up to the first '.',\\n *      modifying s to only contain the remainder of the string after the '.'.\\n *      In situations where you do not want to modify the original slice, you\\n *      can make a copy first with `.copy()`, for example:\\n *      `s.copy().split(\\\".\\\")`. Try and avoid using this idiom in loops; since\\n *      Solidity has no memory management, it will result in allocating many\\n *      short-lived slices that are later discarded.\\n *\\n *      Functions that return two slices come in two versions: a non-allocating\\n *      version that takes the second slice as an argument, modifying it in\\n *      place, and an allocating version that allocates and returns the second\\n *      slice; see `nextRune` for example.\\n *\\n *      Functions that have to copy string data will return strings rather than\\n *      slices; these can be cast back to slices for further processing if\\n *      required.\\n *\\n *      For convenience, some functions are provided with non-modifying\\n *      variants that create a new slice and return both; for instance,\\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\\n *      corresponding to the left and right parts of the string.\\n */\\n\\nlibrary strings {\\n    struct slice {\\n        uint256 _len;\\n        uint256 _ptr;\\n    }\\n\\n    function memcpy(\\n        uint256 dest,\\n        uint256 src,\\n        uint256 len\\n    ) private pure {\\n        // Copy word-length chunks while possible\\n        for (; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        // Copy remaining bytes\\n        uint256 mask = 256**(32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /*\\n     * @dev Returns a slice containing the entire string.\\n     * @param self The string to make a slice from.\\n     * @return A newly allocated slice containing the entire string.\\n     */\\n    function toSlice(string memory self) internal pure returns (slice memory) {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(self, 0x20)\\n        }\\n        return slice(bytes(self).length, ptr);\\n    }\\n\\n    /*\\n     * @dev Copies a slice to a new string.\\n     * @param self The slice to copy.\\n     * @return A newly allocated string containing the slice's text.\\n     */\\n    function toString(slice memory self) internal pure returns (string memory) {\\n        string memory ret = new string(self._len);\\n        uint256 retptr;\\n        assembly {\\n            retptr := add(ret, 32)\\n        }\\n\\n        memcpy(retptr, self._ptr, self._len);\\n        return ret;\\n    }\\n    \\n\\n    // Returns the memory address of the first byte of the first occurrence of\\n    // `needle` in `self`, or the first byte after `self` if not found.\\n    function findPtr(\\n        uint256 selflen,\\n        uint256 selfptr,\\n        uint256 needlelen,\\n        uint256 needleptr\\n    ) private pure returns (uint256) {\\n        uint256 ptr = selfptr;\\n        uint256 idx;\\n\\n        if (needlelen <= selflen) {\\n            if (needlelen <= 32) {\\n                bytes32 mask = bytes32(~(2**(8 * (32 - needlelen)) - 1));\\n\\n                bytes32 needledata;\\n                assembly {\\n                    needledata := and(mload(needleptr), mask)\\n                }\\n\\n                uint256 end = selfptr + selflen - needlelen;\\n                bytes32 ptrdata;\\n                assembly {\\n                    ptrdata := and(mload(ptr), mask)\\n                }\\n\\n                while (ptrdata != needledata) {\\n                    if (ptr >= end) return selfptr + selflen;\\n                    ptr++;\\n                    assembly {\\n                        ptrdata := and(mload(ptr), mask)\\n                    }\\n                }\\n                return ptr;\\n            } else {\\n                // For long needles, use hashing\\n                bytes32 hash;\\n                assembly {\\n                    hash := keccak256(needleptr, needlelen)\\n                }\\n\\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\\n                    bytes32 testHash;\\n                    assembly {\\n                        testHash := keccak256(ptr, needlelen)\\n                    }\\n                    if (hash == testHash) return ptr;\\n                    ptr += 1;\\n                }\\n            }\\n        }\\n        return selfptr + selflen;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and `token` to everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and `token` is set to the entirety of `self`.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @param token An output parameter to which the first token is written.\\n     * @return `token`.\\n     */\\n    function split(\\n        slice memory self,\\n        slice memory needle,\\n        slice memory token\\n    ) internal pure returns (slice memory) {\\n        uint256 ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\\n        token._ptr = self._ptr;\\n        token._len = ptr - self._ptr;\\n        if (ptr == self._ptr + self._len) {\\n            // Not found\\n            self._len = 0;\\n        } else {\\n            self._len -= token._len + needle._len;\\n            self._ptr = ptr + needle._len;\\n        }\\n        return token;\\n    }\\n\\n    /*\\n     * @dev Splits the slice, setting `self` to everything after the first\\n     *      occurrence of `needle`, and returning everything before it. If\\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\\n     *      and the entirety of `self` is returned.\\n     * @param self The slice to split.\\n     * @param needle The text to search for in `self`.\\n     * @return The part of `self` up to the first occurrence of `delim`.\\n     */\\n    function split(slice memory self, slice memory needle)\\n        internal\\n        pure\\n        returns (slice memory token)\\n    {\\n        split(self, needle, token);\\n    }\\n\\n    \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TinyKingdoms\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFlagIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getKingdom\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPalette\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isPirate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TinyKingdomsMetadata", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}