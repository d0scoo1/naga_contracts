{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/interfaces/IBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IBridge {\\n    function send(\\n        address _receiver,\\n        address _token,\\n        uint256 _amount,\\n        uint64 _dstChainId,\\n        uint64 _nonce,\\n        uint32 _maxSlippage\\n    ) external;\\n\\n    function relay(\\n        bytes calldata _relayRequest,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external;\\n\\n    function transfers(bytes32 transferId) external view returns (bool);\\n\\n    function withdraws(bytes32 withdrawId) external view returns (bool);\\n\\n    /**\\n     * @notice Verifies that a message is signed by a quorum among the signers.\\n     * @param _msg signed message\\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\\n     * @param _signers sorted list of current signers\\n     * @param _powers powers of current signers\\n     */\\n    function verifySigs(\\n        bytes memory _msg,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOriginalTokenVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IOriginalTokenVault {\\n    /**\\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\\n     * @param _token local token address\\n     * @param _amount locked token amount\\n     * @param _mintChainId destination chainId to mint tokens\\n     * @param _mintAccount destination account to receive minted tokens\\n     * @param _nonce user input to guarantee unique depositId\\n     */\\n    function deposit(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _mintChainId,\\n        address _mintAccount,\\n        uint64 _nonce\\n    ) external;\\n\\n    function records(bytes32 recordId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOriginalTokenVaultV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IOriginalTokenVaultV2 {\\n    /**\\n     * @notice Lock original tokens to trigger mint at a remote chain's PeggedTokenBridge\\n     * @param _token local token address\\n     * @param _amount locked token amount\\n     * @param _mintChainId destination chainId to mint tokens\\n     * @param _mintAccount destination account to receive minted tokens\\n     * @param _nonce user input to guarantee unique depositId\\n     */\\n    function deposit(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _mintChainId,\\n        address _mintAccount,\\n        uint64 _nonce\\n    ) external returns (bytes32);\\n\\n    function records(bytes32 recordId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPeggedTokenBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IPeggedTokenBridge {\\n    /**\\n     * @notice Burn tokens to trigger withdrawal at a remote chain's OriginalTokenVault\\n     * @param _token local token address\\n     * @param _amount locked token amount\\n     * @param _withdrawAccount account who withdraw original tokens on the remote chain\\n     * @param _nonce user input to guarantee unique depositId\\n     */\\n    function burn(\\n        address _token,\\n        uint256 _amount,\\n        address _withdrawAccount,\\n        uint64 _nonce\\n    ) external;\\n\\n    function records(bytes32 recordId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPeggedTokenBridgeV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IPeggedTokenBridgeV2 {\\n    /**\\n     * @notice Burn pegged tokens to trigger a cross-chain withdrawal of the original tokens at a remote chain's\\n     * OriginalTokenVault, or mint at another remote chain\\n     * @param _token The pegged token address.\\n     * @param _amount The amount to burn.\\n     * @param _toChainId If zero, withdraw from original vault; otherwise, the remote chain to mint tokens.\\n     * @param _toAccount The account to receive tokens on the remote chain\\n     * @param _nonce A number to guarantee unique depositId. Can be timestamp in practice.\\n     */\\n    function burn(\\n        address _token,\\n        uint256 _amount,\\n        uint64 _toChainId,\\n        address _toAccount,\\n        uint64 _nonce\\n    ) external returns (bytes32);\\n\\n    function records(bytes32 recordId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISigsVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\ninterface ISigsVerifier {\\n    /**\\n     * @notice Verifies that a message is signed by a quorum among the signers.\\n     * @param _msg signed message\\n     * @param _sigs list of signatures sorted by signer addresses in ascending order\\n     * @param _signers sorted list of current signers\\n     * @param _powers powers of current signers\\n     */\\n    function verifySigs(\\n        bytes memory _msg,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/message/interfaces/IMessageReceiverApp.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity >=0.8.0;\\n\\ninterface IMessageReceiverApp {\\n    /**\\n     * @notice Called by MessageBus (MessageBusReceiver) if the process is originated from MessageBus (MessageBusSender)'s\\n     *         sendMessageWithTransfer it is only called when the tokens are checked to be arrived at this contract's address.\\n     * @param _sender The address of the source app contract\\n     * @param _token The address of the token that comes out of the bridge\\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\\n     *        the contract that implements this contract can safely assume that the tokens will arrive before this\\n     *        function is called.\\n     * @param _srcChainId The source chain ID where the transfer is originated from\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     */\\n    function executeMessageWithTransfer(\\n        address _sender,\\n        address _token,\\n        uint256 _amount,\\n        uint64 _srcChainId,\\n        bytes calldata _message\\n    ) external payable returns (bool);\\n\\n    /**\\n     * @notice Only called by MessageBus (MessageBusReceiver) if\\n     *         1. executeMessageWithTransfer reverts, or\\n     *         2. executeMessageWithTransfer returns false\\n     * @param _sender The address of the source app contract\\n     * @param _token The address of the token that comes out of the bridge\\n     * @param _amount The amount of tokens received at this contract through the cross-chain bridge.\\n     *        the contract that implements this contract can safely assume that the tokens will arrive before this\\n     *        function is called.\\n     * @param _srcChainId The source chain ID where the transfer is originated from\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     */\\n    function executeMessageWithTransferFallback(\\n        address _sender,\\n        address _token,\\n        uint256 _amount,\\n        uint64 _srcChainId,\\n        bytes calldata _message\\n    ) external payable returns (bool);\\n\\n    /**\\n     * @notice Called by MessageBus (MessageBusReceiver) to process refund of the original transfer from this contract\\n     * @param _token The token address of the original transfer\\n     * @param _amount The amount of the original transfer\\n     * @param _message The same message associated with the original transfer\\n     */\\n    function executeMessageWithTransferRefund(\\n        address _token,\\n        uint256 _amount,\\n        bytes calldata _message\\n    ) external payable returns (bool);\\n\\n    /**\\n     * @notice Called by MessageBus (MessageBusReceiver)\\n     * @param _sender The address of the source app contract\\n     * @param _srcChainId The source chain ID where the transfer is originated from\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     */\\n    function executeMessage(\\n        address _sender,\\n        uint64 _srcChainId,\\n        bytes calldata _message\\n    ) external payable returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/message/messagebus/MessageBus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"./MessageBusSender.sol\\\";\\nimport \\\"./MessageBusReceiver.sol\\\";\\n\\ncontract MessageBus is MessageBusSender, MessageBusReceiver {\\n    constructor(\\n        ISigsVerifier _sigsVerifier,\\n        address _liquidityBridge,\\n        address _pegBridge,\\n        address _pegVault,\\n        address _pegBridgeV2,\\n        address _pegVaultV2\\n    )\\n        MessageBusSender(_sigsVerifier)\\n        MessageBusReceiver(_liquidityBridge, _pegBridge, _pegVault, _pegBridgeV2, _pegVaultV2)\\n    {}\\n\\n    // this is only to be called by Proxy via delegateCall as initOwner will require _owner is 0.\\n    // so calling init on this contract directly will guarantee to fail\\n    function init(\\n        address _liquidityBridge,\\n        address _pegBridge,\\n        address _pegVault,\\n        address _pegBridgeV2,\\n        address _pegVaultV2\\n    ) external {\\n        // MUST manually call ownable init and must only call once\\n        initOwner();\\n        // we don't need sender init as _sigsVerifier is immutable so already in the deployed code\\n        initReceiver(_liquidityBridge, _pegBridge, _pegVault, _pegBridgeV2, _pegVaultV2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/message/messagebus/MessageBusReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../../interfaces/IBridge.sol\\\";\\nimport \\\"../../interfaces/IOriginalTokenVault.sol\\\";\\nimport \\\"../../interfaces/IOriginalTokenVaultV2.sol\\\";\\nimport \\\"../../interfaces/IPeggedTokenBridge.sol\\\";\\nimport \\\"../../interfaces/IPeggedTokenBridgeV2.sol\\\";\\nimport \\\"../interfaces/IMessageReceiverApp.sol\\\";\\nimport \\\"../../safeguard/Ownable.sol\\\";\\n\\ncontract MessageBusReceiver is Ownable {\\n    enum TransferType {\\n        Null,\\n        LqSend, // send through liquidity bridge\\n        LqWithdraw, // withdraw from liquidity bridge\\n        PegMint, // mint through pegged token bridge\\n        PegWithdraw, // withdraw from original token vault\\n        PegMintV2, // mint through pegged token bridge v2\\n        PegWithdrawV2 // withdraw from original token vault v2\\n    }\\n\\n    struct TransferInfo {\\n        TransferType t;\\n        address sender;\\n        address receiver;\\n        address token;\\n        uint256 amount;\\n        uint64 seqnum; // only needed for LqWithdraw\\n        uint64 srcChainId;\\n        bytes32 refId;\\n    }\\n\\n    struct RouteInfo {\\n        address sender;\\n        address receiver;\\n        uint64 srcChainId;\\n    }\\n\\n    enum TxStatus {\\n        Null,\\n        Success,\\n        Fail,\\n        Fallback,\\n        Pending\\n    }\\n    mapping(bytes32 => TxStatus) public executedMessages;\\n\\n    address public liquidityBridge; // liquidity bridge address\\n    address public pegBridge; // peg bridge address\\n    address public pegVault; // peg original vault address\\n    address public pegBridgeV2; // peg bridge address\\n    address public pegVaultV2; // peg original vault address\\n\\n    enum MsgType {\\n        MessageWithTransfer,\\n        MessageOnly\\n    }\\n    event Executed(MsgType msgType, bytes32 id, TxStatus status);\\n    event LiquidityBridgeUpdated(address liquidityBridge);\\n    event PegBridgeUpdated(address pegBridge);\\n    event PegVaultUpdated(address pegVault);\\n    event PegBridgeV2Updated(address pegBridgeV2);\\n    event PegVaultV2Updated(address pegVaultV2);\\n\\n    constructor(\\n        address _liquidityBridge,\\n        address _pegBridge,\\n        address _pegVault,\\n        address _pegBridgeV2,\\n        address _pegVaultV2\\n    ) {\\n        liquidityBridge = _liquidityBridge;\\n        pegBridge = _pegBridge;\\n        pegVault = _pegVault;\\n        pegBridgeV2 = _pegBridgeV2;\\n        pegVaultV2 = _pegVaultV2;\\n    }\\n\\n    function initReceiver(\\n        address _liquidityBridge,\\n        address _pegBridge,\\n        address _pegVault,\\n        address _pegBridgeV2,\\n        address _pegVaultV2\\n    ) internal {\\n        require(liquidityBridge == address(0), \\\"liquidityBridge already set\\\");\\n        liquidityBridge = _liquidityBridge;\\n        pegBridge = _pegBridge;\\n        pegVault = _pegVault;\\n        pegBridgeV2 = _pegBridgeV2;\\n        pegVaultV2 = _pegVaultV2;\\n    }\\n\\n    // ============== functions called by executor ==============\\n\\n    /**\\n     * @notice Execute a message with a successful transfer.\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     * @param _transfer The transfer info.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function executeMessageWithTransfer(\\n        bytes calldata _message,\\n        TransferInfo calldata _transfer,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external payable {\\n        // For message with token transfer, message Id is computed through transfer info\\n        // in order to guarantee that each transfer can only be used once.\\n        // This also indicates that different transfers can carry the exact same messages.\\n        bytes32 messageId = verifyTransfer(_transfer);\\n        require(executedMessages[messageId] == TxStatus.Null, \\\"transfer already executed\\\");\\n        executedMessages[messageId] = TxStatus.Pending;\\n\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"MessageWithTransfer\\\"));\\n        IBridge(liquidityBridge).verifySigs(abi.encodePacked(domain, messageId, _message), _sigs, _signers, _powers);\\n        TxStatus status;\\n        bool success = executeMessageWithTransfer(_transfer, _message);\\n        if (success) {\\n            status = TxStatus.Success;\\n        } else {\\n            success = executeMessageWithTransferFallback(_transfer, _message);\\n            if (success) {\\n                status = TxStatus.Fallback;\\n            } else {\\n                status = TxStatus.Fail;\\n            }\\n        }\\n        executedMessages[messageId] = status;\\n        emit Executed(MsgType.MessageWithTransfer, messageId, status);\\n    }\\n\\n    /**\\n     * @notice Execute a message with a refunded transfer.\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     * @param _transfer The transfer info.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function executeMessageWithTransferRefund(\\n        bytes calldata _message, // the same message associated with the original transfer\\n        TransferInfo calldata _transfer,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external payable {\\n        // similar to executeMessageWithTransfer\\n        bytes32 messageId = verifyTransfer(_transfer);\\n        require(executedMessages[messageId] == TxStatus.Null, \\\"transfer already executed\\\");\\n        executedMessages[messageId] = TxStatus.Pending;\\n\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"MessageWithTransferRefund\\\"));\\n        IBridge(liquidityBridge).verifySigs(abi.encodePacked(domain, messageId, _message), _sigs, _signers, _powers);\\n        TxStatus status;\\n        bool success = executeMessageWithTransferRefund(_transfer, _message);\\n        if (success) {\\n            status = TxStatus.Success;\\n        } else {\\n            status = TxStatus.Fail;\\n        }\\n        executedMessages[messageId] = status;\\n        emit Executed(MsgType.MessageWithTransfer, messageId, status);\\n    }\\n\\n    /**\\n     * @notice Execute a message not associated with a transfer.\\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A relay must be signed-off by\\n     * +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function executeMessage(\\n        bytes calldata _message,\\n        RouteInfo calldata _route,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external payable {\\n        // For message without associated token transfer, message Id is computed through message info,\\n        // in order to guarantee that each message can only be applied once\\n        bytes32 messageId = computeMessageOnlyId(_route, _message);\\n        require(executedMessages[messageId] == TxStatus.Null, \\\"message already executed\\\");\\n        executedMessages[messageId] = TxStatus.Pending;\\n\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"Message\\\"));\\n        IBridge(liquidityBridge).verifySigs(abi.encodePacked(domain, messageId), _sigs, _signers, _powers);\\n        TxStatus status;\\n        bool success = executeMessage(_route, _message);\\n        if (success) {\\n            status = TxStatus.Success;\\n        } else {\\n            status = TxStatus.Fail;\\n        }\\n        executedMessages[messageId] = status;\\n        emit Executed(MsgType.MessageOnly, messageId, status);\\n    }\\n\\n    // ================= utils (to avoid stack too deep) =================\\n\\n    function executeMessageWithTransfer(TransferInfo calldata _transfer, bytes calldata _message)\\n        private\\n        returns (bool)\\n    {\\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\\n            abi.encodeWithSelector(\\n                IMessageReceiverApp.executeMessageWithTransfer.selector,\\n                _transfer.sender,\\n                _transfer.token,\\n                _transfer.amount,\\n                _transfer.srcChainId,\\n                _message\\n            )\\n        );\\n        if (ok) {\\n            bool success = abi.decode((res), (bool));\\n            return success;\\n        }\\n        return false;\\n    }\\n\\n    function executeMessageWithTransferFallback(TransferInfo calldata _transfer, bytes calldata _message)\\n        private\\n        returns (bool)\\n    {\\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\\n            abi.encodeWithSelector(\\n                IMessageReceiverApp.executeMessageWithTransferFallback.selector,\\n                _transfer.sender,\\n                _transfer.token,\\n                _transfer.amount,\\n                _transfer.srcChainId,\\n                _message\\n            )\\n        );\\n        if (ok) {\\n            bool success = abi.decode((res), (bool));\\n            return success;\\n        }\\n        return false;\\n    }\\n\\n    function executeMessageWithTransferRefund(TransferInfo calldata _transfer, bytes calldata _message)\\n        private\\n        returns (bool)\\n    {\\n        (bool ok, bytes memory res) = address(_transfer.receiver).call{value: msg.value}(\\n            abi.encodeWithSelector(\\n                IMessageReceiverApp.executeMessageWithTransferRefund.selector,\\n                _transfer.token,\\n                _transfer.amount,\\n                _message\\n            )\\n        );\\n        if (ok) {\\n            bool success = abi.decode((res), (bool));\\n            return success;\\n        }\\n        return false;\\n    }\\n\\n    function verifyTransfer(TransferInfo calldata _transfer) private view returns (bytes32) {\\n        bytes32 transferId;\\n        address bridgeAddr;\\n        if (_transfer.t == TransferType.LqSend) {\\n            transferId = keccak256(\\n                abi.encodePacked(\\n                    _transfer.sender,\\n                    _transfer.receiver,\\n                    _transfer.token,\\n                    _transfer.amount,\\n                    _transfer.srcChainId,\\n                    uint64(block.chainid),\\n                    _transfer.refId\\n                )\\n            );\\n            bridgeAddr = liquidityBridge;\\n            require(IBridge(bridgeAddr).transfers(transferId) == true, \\\"bridge relay not exist\\\");\\n        } else if (_transfer.t == TransferType.LqWithdraw) {\\n            transferId = keccak256(\\n                abi.encodePacked(\\n                    uint64(block.chainid),\\n                    _transfer.seqnum,\\n                    _transfer.receiver,\\n                    _transfer.token,\\n                    _transfer.amount\\n                )\\n            );\\n            bridgeAddr = liquidityBridge;\\n            require(IBridge(bridgeAddr).withdraws(transferId) == true, \\\"bridge withdraw not exist\\\");\\n        } else if (_transfer.t == TransferType.PegMint || _transfer.t == TransferType.PegWithdraw) {\\n            transferId = keccak256(\\n                abi.encodePacked(\\n                    _transfer.receiver,\\n                    _transfer.token,\\n                    _transfer.amount,\\n                    _transfer.sender,\\n                    _transfer.srcChainId,\\n                    _transfer.refId\\n                )\\n            );\\n            if (_transfer.t == TransferType.PegMint) {\\n                bridgeAddr = pegBridge;\\n                require(IPeggedTokenBridge(bridgeAddr).records(transferId) == true, \\\"mint record not exist\\\");\\n            } else {\\n                // _transfer.t == TransferType.PegWithdraw\\n                bridgeAddr = pegVault;\\n                require(IOriginalTokenVault(bridgeAddr).records(transferId) == true, \\\"withdraw record not exist\\\");\\n            }\\n        } else if (_transfer.t == TransferType.PegMintV2 || _transfer.t == TransferType.PegWithdrawV2) {\\n            if (_transfer.t == TransferType.PegMintV2) {\\n                bridgeAddr = pegBridgeV2;\\n            } else {\\n                // TransferType.PegWithdrawV2\\n                bridgeAddr = pegVaultV2;\\n            }\\n            transferId = keccak256(\\n                abi.encodePacked(\\n                    _transfer.receiver,\\n                    _transfer.token,\\n                    _transfer.amount,\\n                    _transfer.sender,\\n                    _transfer.srcChainId,\\n                    _transfer.refId,\\n                    bridgeAddr\\n                )\\n            );\\n            if (_transfer.t == TransferType.PegMintV2) {\\n                require(IPeggedTokenBridgeV2(bridgeAddr).records(transferId) == true, \\\"mint record not exist\\\");\\n            } else {\\n                // TransferType.PegWithdrawV2\\n                require(IOriginalTokenVaultV2(bridgeAddr).records(transferId) == true, \\\"withdraw record not exist\\\");\\n            }\\n        }\\n        return keccak256(abi.encodePacked(MsgType.MessageWithTransfer, bridgeAddr, transferId));\\n    }\\n\\n    function computeMessageOnlyId(RouteInfo calldata _route, bytes calldata _message) private pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(MsgType.MessageOnly, _route.sender, _route.receiver, _route.srcChainId, _message)\\n            );\\n    }\\n\\n    function executeMessage(RouteInfo calldata _route, bytes calldata _message) private returns (bool) {\\n        (bool ok, bytes memory res) = address(_route.receiver).call{value: msg.value}(\\n            abi.encodeWithSelector(\\n                IMessageReceiverApp.executeMessage.selector,\\n                _route.sender,\\n                _route.srcChainId,\\n                _message\\n            )\\n        );\\n        if (ok) {\\n            bool success = abi.decode((res), (bool));\\n            return success;\\n        }\\n        return false;\\n    }\\n\\n    // ================= contract addr config =================\\n\\n    function setLiquidityBridge(address _addr) public onlyOwner {\\n        require(_addr != address(0), \\\"invalid address\\\");\\n        liquidityBridge = _addr;\\n        emit LiquidityBridgeUpdated(liquidityBridge);\\n    }\\n\\n    function setPegBridge(address _addr) public onlyOwner {\\n        require(_addr != address(0), \\\"invalid address\\\");\\n        pegBridge = _addr;\\n        emit PegBridgeUpdated(pegBridge);\\n    }\\n\\n    function setPegVault(address _addr) public onlyOwner {\\n        require(_addr != address(0), \\\"invalid address\\\");\\n        pegVault = _addr;\\n        emit PegVaultUpdated(pegVault);\\n    }\\n\\n    function setPegBridgeV2(address _addr) public onlyOwner {\\n        require(_addr != address(0), \\\"invalid address\\\");\\n        pegBridgeV2 = _addr;\\n        emit PegBridgeV2Updated(pegBridgeV2);\\n    }\\n\\n    function setPegVaultV2(address _addr) public onlyOwner {\\n        require(_addr != address(0), \\\"invalid address\\\");\\n        pegVaultV2 = _addr;\\n        emit PegVaultV2Updated(pegVaultV2);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/message/messagebus/MessageBusSender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity 0.8.9;\\n\\nimport \\\"../../safeguard/Ownable.sol\\\";\\nimport \\\"../../interfaces/ISigsVerifier.sol\\\";\\n\\ncontract MessageBusSender is Ownable {\\n    ISigsVerifier public immutable sigsVerifier;\\n\\n    uint256 public feeBase;\\n    uint256 public feePerByte;\\n    mapping(address => uint256) public withdrawnFees;\\n\\n    event Message(address indexed sender, address receiver, uint256 dstChainId, bytes message, uint256 fee);\\n\\n    event MessageWithTransfer(\\n        address indexed sender,\\n        address receiver,\\n        uint256 dstChainId,\\n        address bridge,\\n        bytes32 srcTransferId,\\n        bytes message,\\n        uint256 fee\\n    );\\n\\n    event FeeBaseUpdated(uint256 feeBase);\\n    event FeePerByteUpdated(uint256 feePerByte);\\n\\n    constructor(ISigsVerifier _sigsVerifier) {\\n        sigsVerifier = _sigsVerifier;\\n    }\\n\\n    /**\\n     * @notice Sends a message to an app on another chain via MessageBus without an associated transfer.\\n     * A fee is charged in the native gas token.\\n     * @param _receiver The address of the destination app contract.\\n     * @param _dstChainId The destination chain ID.\\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\\n     */\\n    function sendMessage(\\n        address _receiver,\\n        uint256 _dstChainId,\\n        bytes calldata _message\\n    ) external payable {\\n        uint256 minFee = calcFee(_message);\\n        require(msg.value >= minFee, \\\"Insufficient fee\\\");\\n        emit Message(msg.sender, _receiver, _dstChainId, _message, msg.value);\\n    }\\n\\n    /**\\n     * @notice Sends a message associated with a transfer to an app on another chain via MessageBus without an associated transfer.\\n     * A fee is charged in the native token.\\n     * @param _receiver The address of the destination app contract.\\n     * @param _dstChainId The destination chain ID.\\n     * @param _srcBridge The bridge contract to send the transfer with.\\n     * @param _srcTransferId The transfer ID.\\n     * @param _dstChainId The destination chain ID.\\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\\n     */\\n    function sendMessageWithTransfer(\\n        address _receiver,\\n        uint256 _dstChainId,\\n        address _srcBridge,\\n        bytes32 _srcTransferId,\\n        bytes calldata _message\\n    ) external payable {\\n        uint256 minFee = calcFee(_message);\\n        require(msg.value >= minFee, \\\"Insufficient fee\\\");\\n        // SGN needs to verify\\n        // 1. msg.sender matches sender of the src transfer\\n        // 2. dstChainId matches dstChainId of the src transfer\\n        // 3. bridge is either liquidity bridge, peg src vault, or peg dst bridge\\n        emit MessageWithTransfer(msg.sender, _receiver, _dstChainId, _srcBridge, _srcTransferId, _message, msg.value);\\n    }\\n\\n    /**\\n     * @notice Withdraws message fee in the form of native gas token.\\n     * @param _account The address receiving the fee.\\n     * @param _cumulativeFee The cumulative fee credited to the account. Tracked by SGN.\\n     * @param _sigs The list of signatures sorted by signing addresses in ascending order. A withdrawal must be\\n     * signed-off by +2/3 of the sigsVerifier's current signing power to be delivered.\\n     * @param _signers The sorted list of signers.\\n     * @param _powers The signing powers of the signers.\\n     */\\n    function withdrawFee(\\n        address _account,\\n        uint256 _cumulativeFee,\\n        bytes[] calldata _sigs,\\n        address[] calldata _signers,\\n        uint256[] calldata _powers\\n    ) external {\\n        bytes32 domain = keccak256(abi.encodePacked(block.chainid, address(this), \\\"withdrawFee\\\"));\\n        sigsVerifier.verifySigs(abi.encodePacked(domain, _account, _cumulativeFee), _sigs, _signers, _powers);\\n        uint256 amount = _cumulativeFee - withdrawnFees[_account];\\n        require(amount > 0, \\\"No new amount to withdraw\\\");\\n        withdrawnFees[_account] = _cumulativeFee;\\n        (bool sent, ) = _account.call{value: amount, gas: 50000}(\\\"\\\");\\n        require(sent, \\\"failed to withdraw fee\\\");\\n    }\\n\\n    /**\\n     * @notice Calculates the required fee for the message.\\n     * @param _message Arbitrary message bytes to be decoded by the destination app contract.\\n     @ @return The required fee.\\n     */\\n    function calcFee(bytes calldata _message) public view returns (uint256) {\\n        return feeBase + _message.length * feePerByte;\\n    }\\n\\n    // -------------------- Admin --------------------\\n\\n    function setFeePerByte(uint256 _fee) external onlyOwner {\\n        feePerByte = _fee;\\n        emit FeePerByteUpdated(feePerByte);\\n    }\\n\\n    function setFeeBase(uint256 _fee) external onlyOwner {\\n        feeBase = _fee;\\n        emit FeeBaseUpdated(feeBase);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/safeguard/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n *\\n * This adds a normal func that setOwner if _owner is address(0). So we can't allow\\n * renounceOwnership. So we can support Proxy based upgradable contract\\n */\\nabstract contract Ownable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Only to be called by inherit contracts, in their init func called by Proxy\\n     * we require _owner == address(0), which is only possible when it's a delegateCall\\n     * because constructor sets _owner in contract state.\\n     */\\n    function initOwner() internal {\\n        require(_owner == address(0), \\\"owner already set\\\");\\n        _setOwner(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISigsVerifier\",\"name\":\"_sigsVerifier\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_liquidityBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegBridgeV2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegVaultV2\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"enum MessageBusReceiver.MsgType\",\"name\":\"msgType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum MessageBusReceiver.TxStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feeBase\",\"type\":\"uint256\"}],\"name\":\"FeeBaseUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"feePerByte\",\"type\":\"uint256\"}],\"name\":\"FeePerByteUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"liquidityBridge\",\"type\":\"address\"}],\"name\":\"LiquidityBridgeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"Message\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bridge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"srcTransferId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"MessageWithTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegBridge\",\"type\":\"address\"}],\"name\":\"PegBridgeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegBridgeV2\",\"type\":\"address\"}],\"name\":\"PegBridgeV2Updated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegVault\",\"type\":\"address\"}],\"name\":\"PegVaultUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pegVaultV2\",\"type\":\"address\"}],\"name\":\"PegVaultV2Updated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"calcFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"}],\"internalType\":\"struct MessageBusReceiver.RouteInfo\",\"name\":\"_route\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"executeMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"enum MessageBusReceiver.TransferType\",\"name\":\"t\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"seqnum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"}],\"internalType\":\"struct MessageBusReceiver.TransferInfo\",\"name\":\"_transfer\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"executeMessageWithTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"components\":[{\"internalType\":\"enum MessageBusReceiver.TransferType\",\"name\":\"t\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"seqnum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"srcChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"refId\",\"type\":\"bytes32\"}],\"internalType\":\"struct MessageBusReceiver.TransferInfo\",\"name\":\"_transfer\",\"type\":\"tuple\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"executeMessageWithTransferRefund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"executedMessages\",\"outputs\":[{\"internalType\":\"enum MessageBusReceiver.TxStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeBase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePerByte\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_liquidityBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegBridge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegBridgeV2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pegVaultV2\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidityBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pegBridge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pegBridgeV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pegVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pegVaultV2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_srcBridge\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_srcTransferId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sendMessageWithTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeePerByte\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setLiquidityBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPegBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPegBridgeV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPegVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setPegVaultV2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sigsVerifier\",\"outputs\":[{\"internalType\":\"contract ISigsVerifier\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cumulativeFee\",\"type\":\"uint256\"},{\"internalType\":\"bytes[]\",\"name\":\"_sigs\",\"type\":\"bytes[]\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_powers\",\"type\":\"uint256[]\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawnFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MessageBus", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000009b36f165bab9ebe611d491180418d8de4b8f3a1f0000000000000000000000009b36f165bab9ebe611d491180418d8de4b8f3a1f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}