{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TheForest/TheForest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Omnus Contracts (contracts/ether-tree/TheForest.sol)\\r\\n// https://omnuslab.com/ethertree\\r\\n// https://ethertree.org\\r\\n\\r\\n// EtherTree 100 total supply ERC721\\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev EtherTree\\r\\n*\\r\\n* Distribution contract for the ether tree project. This token implements a few innovations:\\r\\n* - Pre minted token supply. The total supply was minted on contract creation (which saves gas). \\r\\n* - All metadata is revealed, opensea site is up etc. so people know exactly what they are buying in to.\\r\\n* - Which creates the issue of random assignment, which is solved by RandomlyAlloacted and IceRing, in their first mainnet incarnation.\\r\\n*   For more details see  https://omnuslab.com/RandomlyAllocated and https://omnuslab.com/IceRing\\r\\n*/\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\r\\nimport \\\"@omnus/contracts/token/RandomlyAllocated/RandomlyAllocatedEtherTree.sol\\\"; \\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev Contract implements RandomlyAllocated and IceRing (which is in RandomlyAllocated)\\r\\n*\\r\\n*/\\r\\ncontract TheForest is Ownable, RandomlyAllocated, IERC721Receiver {\\r\\n\\r\\n  IERC721 public immutable etherTree; \\r\\n  IERC721 public immutable wassiesByWassies;\\r\\n  address payable public immutable etherTreesury; \\r\\n  address public immutable ice; \\r\\n  address public immutable oat; \\r\\n\\r\\n  uint256 public constant PRICE        =  5000000000000000; // 0.005 eth\\r\\n  uint256 public constant WASSIE_PRICE =  1000000000000000; // 0.001 eth\\r\\n\\r\\n  mapping(address => bool) private youveGotOneAlready;\\r\\n\\r\\n  constructor(address etherTree_, address wassiesByWassies_, address payable etherTreesury_, address ice_, address oat_) \\r\\n    RandomlyAllocated(100, oat_, ice_, 0, 0, 0) {\\r\\n    \\r\\n    etherTree = IERC721(etherTree_);\\r\\n    wassiesByWassies = IERC721(wassiesByWassies_);\\r\\n    etherTreesury = etherTreesury_;\\r\\n    ice = ice_;\\r\\n    oat = oat_;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Events\\r\\n  *\\r\\n  */\\r\\n  event EthWithdrawal(uint256 indexed withdrawal);\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Do not accept random calls:\\r\\n  *\\r\\n  */\\r\\n  \\r\\n  receive() external payable {\\r\\n    revert();\\r\\n  }\\r\\n\\r\\n  fallback() external payable {\\r\\n    revert();\\r\\n  }\\r\\n\\r\\n  /** \\r\\n  *\\r\\n  * @dev owner can withdraw eth to treasury:\\r\\n  *\\r\\n  */ \\r\\n  function withdrawEth(uint256 _amount) external onlyOwner returns (bool) {\\r\\n    (bool success, ) = etherTreesury.call{value: _amount}(\\\"\\\");\\r\\n    require(success, \\\"Transfer failed.\\\");\\r\\n    emit EthWithdrawal(_amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev claimTree\\r\\n  *\\r\\n  */\\r\\n  function claimTree(bool wassie) payable external {\\r\\n\\r\\n    uint256 requiredPrice;\\r\\n    if (wassie) {\\r\\n      requiredPrice = WASSIE_PRICE;\\r\\n    }\\r\\n    else {\\r\\n      requiredPrice = PRICE;\\r\\n    }\\r\\n\\r\\n    bool isEligible;\\r\\n    string memory reason;\\r\\n\\r\\n    (isEligible, reason) = canClaimATree(wassie, msg.value, requiredPrice);\\r\\n\\r\\n    require(isEligible, reason);\\r\\n\\r\\n    // Send them their randomly selected tree!\\r\\n    etherTree.safeTransferFrom(address(this), msg.sender, _getItem(0));\\r\\n\\r\\n    youveGotOneAlready[msg.sender] = true;\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev canClaimATree - check is the caller address is eligible\\r\\n  *\\r\\n  */\\r\\n  function canClaimATree(bool wassie, uint256 payment, uint256 price) public view returns(bool isEligible, string memory message) {\\r\\n\\r\\n    // 1) See if they have already claimed one - it's one per address:\\r\\n    if (youveGotOneAlready[msg.sender]) {\\r\\n      return(false, \\\"Hey, one each please!\\\");\\r\\n    }\\r\\n\\r\\n    // 2) Check passed payment:\\r\\n    if (payment != price) {\\r\\n      return(false, \\\"Incorrect ETH amount passed.\\\");\\r\\n    }\\r\\n\\r\\n    // 3) If claiming to be a wassie, check for a wassie:\\r\\n    if (wassie && wassiesByWassies.balanceOf(msg.sender) < 1) {\\r\\n      return(false, \\\"Must have a wassie for this price. Pay normie price, or checkout yellowbird.ethertree.org\\\");\\r\\n    }\\r\\n\\r\\n    // 3) If claiming to not be a wassie, check for a wassie:\\r\\n    if (!wassie && wassiesByWassies.balanceOf(msg.sender) > 0) {\\r\\n      return(false, \\\"You have a wassie! Press the other button it's cheaper!\\\");\\r\\n    }\\r\\n\\r\\n    // 4) We got here? Good to go:\\r\\n    return(true, \\\"\\\");\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev onERC721Received: Always returns `IERC721Receiver.onERC721Received.selector`. We need this to custody NFTs on the contract:\\r\\n  *\\r\\n  */\\r\\n  function onERC721Received(\\r\\n    address,\\r\\n    address,\\r\\n    uint256,\\r\\n    bytes memory\\r\\n  ) external virtual override returns (bytes4) {\\r\\n    return this.onERC721Received.selector;\\r\\n  }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@omnus/contracts/token/RandomlyAllocated/RandomlyAllocatedEtherTree.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Omnus Contracts (contracts/token/RandomlyAllocated/RandomlyAllocated.sol)\\r\\n// https://omnuslab.com/randomallocation\\r\\n\\r\\n// RandomlyAllocated (Allocate the items in a fixed length collection, calling IceRing to randomly assign each ID.\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev RandomlyAllocated\\r\\n*\\r\\n* This contract extension allows the selection of items from a finite collection, each selection using the IceRing\\r\\n* entropy source and removing the assigned item from selection. Intended for use with random token mints etc.\\r\\n*\\r\\n*/\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";  \\r\\nimport \\\"@omnus/contracts/entropy/IceRing.sol\\\";\\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev Contract module which allows children to randomly allocated items from a decaying array.\\r\\n* You must pass in:\\r\\n* 1) The length of the collection you wish to select from (e.g. 1,000)\\r\\n* 2) The IceRing contract address for this chain.\\r\\n* 3) The ERC20Payable contract acting as relay.\\r\\n* \\r\\n* The contract will pass back the item from the array that has been selected and remove that item from the array,\\r\\n* hence you have a decaying list of items to select from.\\r\\n*\\r\\n*/\\r\\n\\r\\nabstract contract RandomlyAllocated is Context, IceRing {\\r\\n\\r\\n  // The parent array holds an index addressing each of the underlying 32 entry uint8 children arrays. The number of each\\r\\n  // entry in the parentArray denotes how many times 32 we elevate the number in the child array when it is selected, with \\r\\n  // each child array running from 0 to 32 (one slot). For example, if we have parentArray 4 then every number in childArray\\r\\n  // 4 is elevated by 4*32, position 0 in childArray 4 therefore representing number 128 (4 * 32 + 0)\\r\\n  uint16[] public parentArray; \\r\\n  // Mapping of parentArray to childArray:\\r\\n  mapping (uint16 => uint8[]) childArray;\\r\\n\\r\\n  uint256 public continueLoadFromArray;\\r\\n  \\r\\n  uint256 public immutable entropyMode;\\r\\n  \\r\\n  // In theory this approach could handle a collection of 2,097,120 items. But as that would required 65,535 parentArray entries\\r\\n  // we would need to load these items in batches. Set a notional parent array max size of 1,600 items, which gives a collection\\r\\n  // max size of 51,200 (1,600 * 32):\\r\\n  uint256 private constant COLLECTION_LIMIT = 51200; \\r\\n  // Each child array holds 32 items (1 slot wide):\\r\\n  uint256 private constant CHILD_ARRAY_WIDTH = 32;\\r\\n  // Max number of child arrays that can be loaded in one block\\r\\n  uint16 private constant LOAD_LIMIT = 125;\\r\\n  // Save a small amount of gas by holding these values as constants:\\r\\n  uint256 private constant EXPONENT_18 = 10 ** 18;\\r\\n  uint256 private constant EXPONENT_36 = 10 ** 36;\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev must be passed supply details, ERC20 payable contract and ice contract addresses, as well as entropy mode and fee (if any)\\r\\n  *\\r\\n  */\\r\\n  constructor(uint16 supply_, address ERC20SpendableContract_, address iceContract_, uint256 entropyMode_, uint256 ethFee_, uint256 oatFee_)\\r\\n    IceRing(ERC20SpendableContract_, iceContract_, ethFee_, oatFee_) {\\r\\n    \\r\\n    require(supply_ < (COLLECTION_LIMIT + 1),\\\"Max supply of 51,200\\\");\\r\\n\\r\\n    entropyMode = entropyMode_;\\r\\n\\r\\n    uint256 numberOfParentEntries = supply_ / CHILD_ARRAY_WIDTH;\\r\\n\\r\\n    uint256 finalChildWidth = supply_ % CHILD_ARRAY_WIDTH;\\r\\n\\r\\n    // If the supply didn't divide perfectly by the child width we have a remainder child at the end. We will load this now\\r\\n    // so that all subsequent child loads can safely assume a full width load:\\r\\n    if (finalChildWidth != 0) {\\r\\n\\r\\n      // Set the final child array now:\\r\\n      // Exclude 98 (yellow bird) as that is available for free at yellowbird.ethertree.org:\\r\\n      childArray[uint16(numberOfParentEntries)] = [0,1,3];\\r\\n\\r\\n      // Add one to the numberOfParentEntries to include the finalChild (as this will have been truncated off the calc above):\\r\\n      numberOfParentEntries += 1;\\r\\n\\r\\n    }\\r\\n\\r\\n    // Now load the parent array:\\r\\n    for(uint256 i = 0; i < numberOfParentEntries;) {\\r\\n      parentArray.push(uint16(i));\\r\\n      unchecked{ i++; }\\r\\n    }\\r\\n\\r\\n    // Load complete, all set up and ready to go.\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev View total remaining items left in the array\\r\\n  *\\r\\n  */\\r\\n  function remainingParentItems() external view returns(uint256) {\\r\\n    return(parentArray.length);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev View parent array\\r\\n  *\\r\\n  */\\r\\n  function parentItemsArray() external view returns(uint16[] memory) {\\r\\n    return(parentArray);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev View items array\\r\\n  *\\r\\n  */\\r\\n  function childItemsArray(uint16 index_) external view returns(uint8[] memory) {\\r\\n    return(childArray[index_]);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev View total remaining IDs\\r\\n  *\\r\\n  */\\r\\n  function countOfRemainingIds() external view returns(uint256 totalRemainingIds) {\\r\\n        \\r\\n    for (uint16 i = 0; i < parentArray.length; i++) {\\r\\n      // A child array with a length of 0 means that this entry in the parent array has yet to \\r\\n      // have the child array created. If the child array was fully depleted to 0 Ids the parent\\r\\n      // array will have been deleted. Therefore a parent array with no corresponding child array\\r\\n      // needs to increase the total count by the full 32 items that will be loaded into the child\\r\\n      // array when it is instantiate.\\r\\n      if (childArray[i].length == 0) {\\r\\n        totalRemainingIds += 32;\\r\\n      }\\r\\n      else {\\r\\n        totalRemainingIds += uint256(childArray[i].length);\\r\\n      }\\r\\n    }\\r\\n          \\r\\n    return(totalRemainingIds);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Allocate item from array:\\r\\n  *\\r\\n  */\\r\\n  function _getItem(uint256 accessMode_) internal returns(uint256 allocatedItem_) { //mode: 0 = light, 1 = standard, 2 = heavy\\r\\n    \\r\\n    require(parentArray.length != 0, \\\"ID allocation exhausted\\\");\\r\\n\\r\\n    // Retrieve a uint256 of entropy from IceRing. We will use separate parts of this entropy uint for number in range\\r\\n    // calcs for array selection:\\r\\n    uint256 entropy = _getEntropy(accessMode_);\\r\\n\\r\\n    // First select the entry from the parent array, using the left most 18 entropy digits:\\r\\n    uint16 parentIndex = uint16(((entropy % EXPONENT_18) * parentArray.length) / EXPONENT_18);\\r\\n\\r\\n    uint16 parent = parentArray[parentIndex];\\r\\n\\r\\n    // Check if we need to load the child (we will the first time it is accessed):\\r\\n    if (childArray[parent].length == 0) {\\r\\n      // Exclude blueberrybird5:\\r\\n      if (parent == 0) {\\r\\n        childArray[parent] = [0,1,2,3,4,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31];  \\r\\n      }\\r\\n      else {\\r\\n        childArray[parent] = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31];\\r\\n      }  \\r\\n    }\\r\\n\\r\\n    // Select the item from the child array, using the a different 18 entropy digits, and add on the elevation factor from the parent:\\r\\n    uint256 childIndex = (((entropy % EXPONENT_36) / EXPONENT_18) * childArray[parent].length) / EXPONENT_18;\\r\\n    \\r\\n    allocatedItem_ = uint256(childArray[parent][childIndex]) + (parent * CHILD_ARRAY_WIDTH);\\r\\n\\r\\n    // Pop this item from the child array. First set the last item index:\\r\\n    uint256 lastChildIndex = childArray[parent].length - 1;\\r\\n\\r\\n    // When the item to remove from the array is the last item, the swap operation is unnecessary\\r\\n    if (childIndex != lastChildIndex) {\\r\\n      childArray[parent][childIndex] = childArray[parent][lastChildIndex];\\r\\n    }\\r\\n\\r\\n    // Remove the last position of the array:\\r\\n    childArray[parent].pop();\\r\\n\\r\\n    // Check if the childArray is no more:\\r\\n    if (childArray[parent].length == 0) {\\r\\n      // Remove the parent as the child allocation is exhausted. First set the last index:\\r\\n      uint256 lastParentIndex = parentArray.length - 1;\\r\\n\\r\\n      // When the item to remove from the array is the last item, the swap operation is unnecessary\\r\\n      if (parentIndex != lastParentIndex) {\\r\\n        parentArray[parentIndex] = parentArray[lastParentIndex];\\r\\n      }\\r\\n\\r\\n      parentArray.pop();\\r\\n\\r\\n    }\\r\\n\\r\\n    return(allocatedItem_);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Retrieve Entropy\\r\\n  *\\r\\n  */\\r\\n  function _getEntropy(uint256 accessMode_) internal returns(uint256 entropy_) { \\r\\n    \\r\\n    // Access mode of 0 is direct access, ETH payment may be required:\\r\\n    if (accessMode_ == 0) { \\r\\n      if (entropyMode == 0) entropy_ = (_getEntropyETH(ENTROPY_LIGHT));\\r\\n      else if (entropyMode == 1) entropy_ = (_getEntropyETH(ENTROPY_STANDARD));\\r\\n      else if (entropyMode == 2) entropy_ = (_getEntropyETH(ENTROPY_HEAVY));\\r\\n      else revert(\\\"Unrecognised entropy mode\\\");\\r\\n    }\\r\\n    // Access mode of 0 is token relayed access, OAT payment may be required:\\r\\n    else {\\r\\n      if (entropyMode == 0) entropy_ = (_getEntropyOAT(ENTROPY_LIGHT));\\r\\n      else if (entropyMode == 1) entropy_ = (_getEntropyOAT(ENTROPY_STANDARD));\\r\\n      else if (entropyMode == 2) entropy_ = (_getEntropyOAT(ENTROPY_HEAVY));\\r\\n      else revert(\\\"Unrecognised entropy mode\\\");\\r\\n    }\\r\\n\\r\\n    return(entropy_);\\r\\n\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev _loadChildren: Optional function that can be used to pre-load child arrays. This can be used to shift gas costs out of\\r\\n  * execution by pre-loading some or all of the child arrays.\\r\\n  *\\r\\n  */\\r\\n  function _loadChildren() internal {\\r\\n\\r\\n    require(continueLoadFromArray < parentArray.length, \\\"Load Children: load already complete\\\");\\r\\n        \\r\\n    // Determine how many arrays we will be checking and loading on this call:\\r\\n    uint256 loadUntil;\\r\\n\\r\\n    // Example: Parent array length is 300 (index 0 to 299). On the first call to this function\\r\\n    // the storage var continueLoadFromArray will be 0. Therefore the statement below will be\\r\\n    // if (300 - 0) > 125, which it is. We therefore set loadUntil to 0 + 125 (the load limit)\\r\\n    // which is 125.\\r\\n    // On the second call to this function continueLoadFromArray will be 125 (we set it to the loadUntil\\r\\n    // value at the end of this function). (300 - 125) is 175, so still greater than the load limit of 125.\\r\\n    // We therefore set loadUntil to 125 + 125 = 250.\\r\\n    // On the third call to this function continueLoadFromArray will be 250. (300 - 250) = 50, which is less \\r\\n    // that our load limit. We therefore set loadUntil to the length of the parent array, which is 300. Note\\r\\n    // that when processing the parent array items we terminate the look when i < loadUntil, meaning that in \\r\\n    // are example we will load index 0 all the way to 299, which is as it should be.\\r\\n    if ((parentArray.length - continueLoadFromArray) > LOAD_LIMIT) {\\r\\n      loadUntil = continueLoadFromArray + LOAD_LIMIT;\\r\\n    }\\r\\n    else {\\r\\n      loadUntil = parentArray.length;\\r\\n    }\\r\\n\\r\\n    for(uint256 i = continueLoadFromArray; i < loadUntil;) {\\r\\n      if (childArray[uint16(i)].length == 0) {\\r\\n        childArray[uint16(i)] = [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31];\\r\\n      }\\r\\n      unchecked{ i++; }\\r\\n    }\\r\\n\\r\\n    continueLoadFromArray = loadUntil;\\r\\n\\r\\n  }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@omnus/contracts/entropy/IceRing.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Omnus Contracts (contracts/entropy/IceRing.sol)\\r\\n// https://omnuslab.com/icering\\r\\n\\r\\n// ICERiNG (In Chain Entropy - Randomised Number Generator)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n* @dev ICE - In-Chain Entropy\\r\\n*\\r\\n* This protocol generates in-chain entropy (OK, ON-chain not in-chain, but that didn't make a cool acronym...).\\r\\n* Solidity and blockchains are deterministic, so standard warnings apply, this produces pseudorandomness. For very strict levels of \\r\\n* randomness the answer remains to go off-chain, but that carries a cost and also introduces an off-chain dependency that could fail or,\\r\\n* worse, some day be tampered with or become vulnerable. \\r\\n* \\r\\n* The core premise of this protocol is that we aren't chasing true random (does that even exist? Philosophers?). What we are chasing \\r\\n* is a source or sources of entropy that are unpredictable in that they can't practically be controlled or predicted by a single entity.\\r\\n*\\r\\n* A key source of entropy in this protocol is contract balances, namely the balances of contracts that change with every block. Think large \\r\\n* value wallets, like exchange wallets. We store a list of these contract addresses and every request combine the eth value of these addresses\\r\\n* with the current block time and a modulo and hash it. \\r\\n* \\r\\n* Block.timestamp has been used as entropy before, but it has a significant drawback in that it can be controlled by miners. If the incentive is\\r\\n* high enough a miner could look to control the outcome by controlling the timestamp. \\r\\n* \\r\\n* When we add into this a variable contract balance we require a single entity be able to control both the block.timestamp and, for example, the \\r\\n* eth balance of a binance hot wallet. In the same block. To make it even harder, we loop through our available entropy sources, so the one that\\r\\n* a transaction uses depends on where in the order we are, which depends on any other txns using this protocol before it. So to be sure of the \\r\\n* outcome an entity needs to control the block.timestamp, either control other txns using this in the block or make sure it's the first txn in \\r\\n* the block, control the balance of another parties wallet than changes with every block, then be able to hash those known variables to see if the\\r\\n* outcome is a positive one for them. Whether any entity could achieve that is debatable, but you would imagine that if it is possible it \\r\\n* would come at significant cost.\\r\\n*\\r\\n* The protocol can be used in two ways: to return a full uin256 of entropy or a number within a given range. Each of these can be called in light,\\r\\n* standard or heavy mode:\\r\\n*   Light    - uses the balance of the last contract loaded into the entropy list for every generation. This reduces storage reads\\r\\n*              at the disadvantage of reducing the variability of the seed.\\r\\n*   Standard - increments through our list of sources using a different one as the seed each time, returning to the first item at the end of the \\r\\n*              loop and so on.\\r\\n*   Heavy    - creates a hash of hashes using ALL of the entropy seed sources. In principle this would require a single entity to control both\\r\\n*              the block timestamp and the precise balances of a range of addresses within that block. \\r\\n*\\r\\n*                                                             D I S C L A I M E R\\r\\n*                                                             ===================    \\r\\n*                   Use at your own risk, obvs. I've tried hard to make this good quality entropy, but whether random exists is\\r\\n*                   a question for philosophers not solidity devs. If there is a lot at stake on whatever it is you are doing \\r\\n*                   please DYOR on what option is best for you. There are no guarantees the entropy seeds here will be maintained\\r\\n*                   (I mean, no one might ever use this). No liability is accepted etc.\\r\\n*/\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";  \\r\\nimport \\\"@omnus/contracts/token/ERC20Spendable/IERC20Spendable.sol\\\";\\r\\nimport \\\"@omnus/contracts/entropy/IIce.sol\\\"; \\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev - library contract for Ice access\\r\\n*\\r\\n*/\\r\\nabstract contract IceRing is Context {\\r\\n\\r\\n  uint256 constant NUMBER_IN_RANGE_LIGHT = 0;\\r\\n  uint256 constant NUMBER_IN_RANGE_STANDARD = 1;\\r\\n  uint256 constant NUMBER_IN_RANGE_HEAVY = 2;\\r\\n  uint256 constant ENTROPY_LIGHT = 3;\\r\\n  uint256 constant ENTROPY_STANDARD = 4;\\r\\n  uint256 constant ENTROPY_HEAVY = 5;\\r\\n  \\r\\n  uint256 public ethFee;\\r\\n  uint256 public oatFee;\\r\\n\\r\\n  IERC20Spendable public immutable ERC20SpendableContract; \\r\\n  address public immutable IceAddress; \\r\\n  IIce public immutable IceContract;\\r\\n\\r\\n  event ETHFeeUpdated(uint256 oldFee, uint256 newFee);\\r\\n  event OATFeeUpdated(uint256 oldFee, uint256 newFee);\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev - Constructor - both the ICE contract and the ERC20Spendable contract need to be provided:\\r\\n  *\\r\\n  */\\r\\n  constructor(address _ERC20SpendableContract, address _IceAddress, uint256 _ethFee, uint256 _oatFee) {\\r\\n    ERC20SpendableContract = IERC20Spendable(_ERC20SpendableContract); \\r\\n    IceAddress = _IceAddress;\\r\\n    IceContract = IIce(IceAddress);\\r\\n    ethFee = _ethFee;\\r\\n    oatFee = _oatFee;\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Update fee. Implement an external call that calls this in child contract, likely ownerOnly.\\r\\n  *\\r\\n  */\\r\\n  function _updateETHFee(uint256 _ethFee) internal {\\r\\n    uint256 oldETHFee = ethFee;\\r\\n    ethFee = _ethFee;\\r\\n    emit ETHFeeUpdated(oldETHFee, _ethFee);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Update fee. Implement an external call that calls this in child contract, likely ownerOnly.\\r\\n  *\\r\\n  */\\r\\n  function _updateOATFee(uint256 _oatFee) internal {\\r\\n    uint256 oldOATFee = oatFee;\\r\\n    oatFee = _oatFee;\\r\\n    emit OATFeeUpdated(oldOATFee, oatFee);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Get entropy, access direct:\\r\\n  *\\r\\n  */\\r\\n  function _getEntropyETH(uint256 _mode) internal returns(uint256 ice_) {\\r\\n\\r\\n    (bool success, uint256 result) = IceContract.iceRingEntropy{value: ethFee}(_mode);\\r\\n    \\r\\n    require(success, \\\"Ice call failed\\\"); \\r\\n\\r\\n    return(result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Get number in range, access direct:\\r\\n  *\\r\\n  */\\r\\n  function _getNumberInRangeETH(uint256 _mode, uint256 _upperBound) internal returns(uint256 ice_) {\\r\\n\\r\\n    (bool success, uint256 result) = IceContract.iceRingNumberInRange{value: ethFee}(_mode, _upperBound);\\r\\n    \\r\\n    require(success, \\\"Ice call failed\\\"); \\r\\n\\r\\n    return(result);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev Get entropy, access through the ERC20 payable relay:\\r\\n  *\\r\\n  */\\r\\n  function _getEntropyOAT(uint256 _mode) internal returns(uint256 ice_) {\\r\\n\\r\\n    uint256[] memory arguments = new uint256[](1);\\r\\n    arguments[0] = _mode;\\r\\n\\r\\n    ice_ = ERC20SpendableContract.spendToken(IceAddress, oatFee, arguments)[0]; \\r\\n\\r\\n    return(ice_);\\r\\n  }\\r\\n  \\r\\n  /**\\r\\n  *\\r\\n  * @dev Get number in range, access through the ERC20 payable relay:\\r\\n  *\\r\\n  */\\r\\n  function _getNumberInRangeOAT(uint256 _mode, uint256 _upperBound) internal returns(uint256 ice_) {\\r\\n\\r\\n    uint256[] memory arguments = new uint256[](2);\\r\\n    arguments[0] = _mode;\\r\\n    arguments[1] = _upperBound;\\r\\n\\r\\n    ice_ = ERC20SpendableContract.spendToken(IceAddress, oatFee, arguments)[0]; \\r\\n\\r\\n    return(ice_);\\r\\n  }\\r\\n\\r\\n}\"\r\n    },\r\n    \"@omnus/contracts/entropy/IIce.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Omnus Contracts (contracts/entropy/IIce.sol)\\r\\n// https://omnuslab.com/icering\\r\\n\\r\\n// IIce (In Chain Entropy - Interface)\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n* @dev ICE - In-Chain Entropy\\r\\n*\\r\\n* This protocol generates in-chain entropy (OK, ON-chain not in-chain, but that didn't make a cool acronym...).\\r\\n* Solidity and blockchains are deterministic, so standard warnings apply, this produces pseudorandomness. For very strict levels of \\r\\n* randomness the answer remains to go off-chain, but that carries a cost and also introduces an off-chain dependency that could fail or,\\r\\n* worse, some day be tampered with or become vulnerable. \\r\\n* \\r\\n* The core premise of this protocol is that we aren't chasing true random (does that even exist? Philosophers?). What we are chasing \\r\\n* is a source or sources of entropy that are unpredictable in that they can't practically be controlled or predicted by a single entity.\\r\\n*\\r\\n* A key source of entropy in this protocol is contract balances, namely the balances of contracts that change with every block. Think large \\r\\n* value wallets, like exchange wallets. We store a list of these contract addresses and every request combine the eth value of these addresses\\r\\n* with the current block time and a modulo and hash it. \\r\\n* \\r\\n* Block.timestamp has been used as entropy before, but it has a significant drawback in that it can be controlled by miners. If the incentive is\\r\\n* high enough a miner could look to control the outcome by controlling the timestamp. \\r\\n* \\r\\n* When we add into this a variable contract balance we require a single entity be able to control both the block.timestamp and, for example, the \\r\\n* eth balance of a binance hot wallet. In the same block. To make it even harder, we loop through our available entropy sources, so the one that\\r\\n* a transaction uses depends on where in the order we are, which depends on any other txns using this protocol before it. So to be sure of the \\r\\n* outcome an entity needs to control the block.timestamp, either control other txns using this in the block or make sure it's the first txn in \\r\\n* the block, control the balance of another parties wallet than changes with every block, then be able to hash those known variables to see if the\\r\\n* outcome is a positive one for them. Whether any entity could achieve that is debatable, but you would imagine that if it is possible it \\r\\n* would come at significant cost.\\r\\n*\\r\\n* The protocol can be used in two ways: to return a full uin256 of entropy or a number within a given range. Each of these can be called in light,\\r\\n* standard or heavy mode:\\r\\n*   Light    - uses the balance of the last contract loaded into the entropy list for every generation. This reduces storage reads\\r\\n*              at the disadvantage of reducing the variability of the seed.\\r\\n*   Standard - increments through our list of sources using a different one as the seed each time, returning to the first item at the end of the \\r\\n*              loop and so on.\\r\\n*   Heavy    - creates a hash of hashes using ALL of the entropy seed sources. In principle this would require a single entity to control both\\r\\n*              the block timestamp and the precise balances of a range of addresses within that block. \\r\\n*\\r\\n*                                                             D I S C L A I M E R\\r\\n*                                                             ===================    \\r\\n*                   Use at your own risk, obvs. I've tried hard to make this good quality entropy, but whether random exists is\\r\\n*                   a question for philosophers not solidity devs. If there is a lot at stake on whatever it is you are doing \\r\\n*                   please DYOR on what option is best for you. No liability is accepted etc.\\r\\n*/\\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev Implementation of the Ice interface.\\r\\n*\\r\\n*/\\r\\n\\r\\ninterface IIce {\\r\\n  event EntropyAdded (address _entropyAddress);\\r\\n  event EntropyUpdated (uint256 _index, address _newAddress, address _oldAddress); \\r\\n  event EntropyCleared (); \\r\\n  event EntropyServed(address seedAddress, uint256 seedValue, uint256 timeStamp, uint256 modulo, uint256 entropy);\\r\\n  event BaseFeeUpdated(uint256 oldFee, uint256 newFee);\\r\\n  event ETHExponentUpdated(uint256 oldETHExponent, uint256 newETHExponent);\\r\\n  event OATExponentUpdated(uint256 oldOATExponent, uint256 newOATExponent);\\r\\n  event TreasurySet(address treasury);\\r\\n  event TokenWithdrawal(uint256 indexed withdrawal, address indexed tokenAddress);\\r\\n  event EthWithdrawal(uint256 indexed withdrawal);\\r\\n\\r\\n  function iceRingEntropy(uint256 _mode) external payable returns(bool, uint256 entropy_);\\r\\n  function iceRingNumberInRange(uint256 _mode, uint256 _upperBound) external payable returns(bool, uint256 numberInRange_);\\r\\n  function viewEntropyAddress(uint256 _index) external view returns (address entropyAddress);\\r\\n  function addEntropy(address _entropyAddress) external;\\r\\n  function updateEntropy(uint256 _index, address _newAddress) external;\\r\\n  function deleteAllEntropy() external;\\r\\n  function updateBaseFee(uint256 _newBasefee) external;\\r\\n  function updateOATFeeExponent(uint256 _newOatExponent) external;\\r\\n  function updateETHFeeExponent(uint256 _newEthExponent) external;\\r\\n  function getConfig() external view returns(uint256 seedIndex_, uint256 counter_, uint256 modulo_, address seedAddress_, uint256 baseFee_, uint256 ethExponent_, uint256 oatExponent_);\\r\\n  function getEthFee() external view returns (uint256 ethFee);\\r\\n  function getOatFee() external view returns (uint256 oatFee); \\r\\n  function validateProof(uint256 _seedValue, uint256 _modulo, uint256 _timeStamp, uint256 _entropy) external pure returns(bool valid);\\r\\n}\"\r\n    },\r\n    \"@omnus/contracts/token/ERC20Spendable/IERC20Spendable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// Omnus Contracts (contracts/token/ERC20Spendable/ISpendableERC20.sol)\\r\\n// https://omnuslab.com/spendable\\r\\n\\r\\n// IERC20Spendable - Interface definition for contracts to implement spendable ERC20 functionality\\r\\n\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\n/**\\r\\n*\\r\\n* @dev ERC20Spendable - library contract for an ERC20 extension to allow ERC20s to \\r\\n* operate as 'spendable' items, i.e. a token that can trigger an action on another contract\\r\\n* at the same time as being transfered. Similar to ERC677 and the hooks in ERC777, but with more\\r\\n* of an empasis on interoperability (returned values) than ERC677 and specifically scoped interaction\\r\\n* rather than the general hooks of ERC777. \\r\\n*\\r\\n* Interface Definition IERC20Spendable\\r\\n*\\r\\n*/\\r\\n\\r\\ninterface IERC20Spendable{\\r\\n\\r\\n  /**\\r\\n  *\\r\\n  * @dev New function, spendToken, that allows the transfer of the owners token to the receiver, a call on the receiver, and \\r\\n  * the return of information from the receiver back up the call stack:\\r\\n  *\\r\\n  */\\r\\n  function spendToken(address receiver, uint256 _tokenPaid, uint256[] memory _arguments) external returns(uint256[] memory);\\r\\n\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"etherTree_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wassiesByWassies_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"etherTreesury_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ice_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oat_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ETHFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"withdrawal\",\"type\":\"uint256\"}],\"name\":\"EthWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"OATFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ERC20SpendableContract\",\"outputs\":[{\"internalType\":\"contract IERC20Spendable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IceAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IceContract\",\"outputs\":[{\"internalType\":\"contract IIce\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WASSIE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"wassie\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"canClaimATree\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEligible\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"message\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"index_\",\"type\":\"uint16\"}],\"name\":\"childItemsArray\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"wassie\",\"type\":\"bool\"}],\"name\":\"claimTree\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"continueLoadFromArray\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"countOfRemainingIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalRemainingIds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"entropyMode\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ethFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherTree\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"etherTreesury\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ice\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oat\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oatFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"parentArray\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"parentItemsArray\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingParentItems\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wassiesByWassies\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TheForest", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e77c4e5e17ea350993cac2eb48bb50dbcccc956b0000000000000000000000001d20a51f088492a0f1c57f047a9e30c9ab5c07ea00000000000000000000000028b918b11d28ac3f28c363cede2cc816dca11b8a0000000000000000000000007257b57cc14a749b75e1f073c15132f7ac893e57000000000000000000000000400a524420c464b9a8eba65614f297b5478ad6f3", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}