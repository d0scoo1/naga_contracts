{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/allocators/tokemak/GeneralizedTokemak.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.13;\\n\\n// solmate\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\n// olympus\\nimport \\\"../../types/BaseAllocator.sol\\\";\\n\\n// tokemak\\nimport {UserVotePayload} from \\\"./interfaces/UserVotePayload.sol\\\";\\nimport {ILiquidityPool} from \\\"./interfaces/ILiquidityPool.sol\\\";\\nimport {IRewardHash} from \\\"./interfaces/IRewardHash.sol\\\";\\nimport {IStaking} from \\\"./interfaces/IStaking.sol\\\";\\nimport {IManager} from \\\"./interfaces/IManager.sol\\\";\\nimport {IRewards} from \\\"./interfaces/IRewards.sol\\\";\\n\\n/// INLINE\\n\\ninterface ITokemakVoting {\\n    function vote(UserVotePayload memory userVotePayload) external;\\n}\\n\\nuint256 constant nmax = type(uint256).max;\\n\\nlibrary TokemakAllocatorLib {\\n    function deposit(address reactor, uint256 amount) internal {\\n        ILiquidityPool(reactor).deposit(amount);\\n    }\\n\\n    function requestWithdrawal(address reactor, uint256 amount) internal {\\n        ILiquidityPool(reactor).requestWithdrawal(amount);\\n    }\\n\\n    function withdraw(address reactor, uint256 amount) internal {\\n        ILiquidityPool(reactor).withdraw(amount);\\n    }\\n\\n    function requestedWithdrawals(address reactor)\\n        internal\\n        view\\n        returns (uint256 minCycle, uint256 amount)\\n    {\\n        (minCycle, amount) = ILiquidityPool(reactor).requestedWithdrawals(\\n            address(this)\\n        );\\n    }\\n\\n    function balanceOf(address reactor, address owner)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ERC20(reactor).balanceOf(owner);\\n    }\\n\\n    function nmaxarr(uint256 l) internal pure returns (uint256[] memory arr) {\\n        arr = new uint256[](l);\\n\\n        for (uint256 i; i < l; i++) {\\n            arr[i] = nmax;\\n        }\\n    }\\n}\\n\\nstruct TokemakData {\\n    address voting;\\n    address staking;\\n    address rewards;\\n    address manager;\\n}\\n\\nstruct PayloadData {\\n    uint128 amount;\\n    uint64 cycle;\\n    uint64 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\nerror GeneralizedTokemak_ArbitraryCallFailed();\\nerror GeneralizedTokemak_MustInitializeTotalWithdraw();\\nerror GeneralizedTokemak_WithdrawalNotReady(uint256 tAssetIndex_);\\n\\ncontract GeneralizedTokemak is BaseAllocator {\\n    using SafeTransferLib for ERC20;\\n    using TokemakAllocatorLib for address;\\n\\n    address immutable self;\\n\\n    ITokemakVoting public voting;\\n    IStaking public staking;\\n    IRewards public rewards;\\n    IManager public manager;\\n\\n    ERC20 public toke;\\n\\n    address[] public reactors;\\n\\n    PayloadData public nextPayloadData;\\n\\n    bool public mayClaim;\\n\\n    bool public totalWithdrawInitialized;\\n\\n    // done for ease of verif at time of deployment\\n    // if you are intending ANYTHING doublecheck these addr\\n    constructor()\\n        BaseAllocator(\\n            AllocatorInitData(\\n                IOlympusAuthority(0x1c21F8EA7e39E2BA00BC12d2968D63F4acb38b7A),\\n                ITreasuryExtender(0xb32Ad041f23eAfd682F57fCe31d3eA4fd92D17af),\\n                new ERC20[](0)\\n            )\\n        )\\n    {\\n        self = address(this);\\n\\n        toke = ERC20(0x2e9d63788249371f1DFC918a52f8d799F4a38C94);\\n\\n        _setTokemakData(\\n            TokemakData(\\n                0x43094eD6D6d214e43C31C38dA91231D2296Ca511, // voting\\n                0x96F98Ed74639689C3A11daf38ef86E59F43417D3, // staking\\n                0x79dD22579112d8a5F7347c5ED7E609e60da713C5, // rewards\\n                0xA86e412109f77c45a3BC1c5870b880492Fb86A14 // manager\\n            )\\n        );\\n    }\\n\\n    // ######################## ~ SAFETY ~ ########################\\n\\n    function executeArbitrary(address target, bytes memory data)\\n        external\\n        onlyGuardian\\n    {\\n        (bool success, ) = target.call(data);\\n        if (!success) revert GeneralizedTokemak_ArbitraryCallFailed();\\n    }\\n\\n    // ######################## ~ IMPORTANT OVERRIDES ~ ########################\\n\\n    function _update(uint256 id)\\n        internal\\n        override\\n        returns (uint128 gain, uint128 loss)\\n    {\\n        uint256 index = tokenIds[id];\\n        address reactor = reactors[index];\\n        ERC20 underl = _tokens[index];\\n\\n        if (mayClaim) {\\n            PayloadData memory payData = nextPayloadData;\\n\\n            rewards.claim(\\n                IRewards.Recipient(1, payData.cycle, self, payData.amount),\\n                uint8(payData.v),\\n                payData.r,\\n                payData.s\\n            );\\n\\n            mayClaim = false;\\n        }\\n\\n        uint256 bal = toke.balanceOf(self);\\n\\n        if (0 < bal) {\\n            toke.approve(address(staking), bal);\\n            staking.deposit(bal);\\n        }\\n\\n        bal = underl.balanceOf(self);\\n\\n        if (0 < bal) {\\n            underl.approve(reactor, bal);\\n            reactor.deposit(bal);\\n        }\\n\\n        uint128 current = uint128(reactor.balanceOf(self));\\n        uint128 last = extender.getAllocatorPerformance(id).gain +\\n            uint128(extender.getAllocatorAllocated(id));\\n\\n        if (last <= current) gain = current - last;\\n        else loss = last - current;\\n    }\\n\\n    /// @dev If amounts.length is == _tokens.length then you are requestingWithdrawals,\\n    /// otherwise you are withdrawing. amount beyond _tokens.length does not matter.\\n    /// @param amounts amounts to withdraw, if amount for one index is type(uint256).max, then take all\\n    function deallocate(uint256[] memory amounts) public override onlyGuardian {\\n        uint256 lt = _tokens.length;\\n        uint256 la = amounts.length;\\n\\n        for (uint256 i; i <= lt; i++) {\\n            if (amounts[i] != 0) {\\n                address reactor;\\n\\n                if (i < lt) reactor = reactors[i];\\n\\n                if (lt + 1 < la) {\\n                    if (amounts[i] == nmax)\\n                        amounts[i] = i < lt\\n                            ? reactor.balanceOf(self)\\n                            : staking.balanceOf(self);\\n\\n                    if (0 < amounts[i])\\n                        if (i < lt) reactor.requestWithdrawal(amounts[i]);\\n                        else staking.requestWithdrawal(amounts[i], 0);\\n                } else {\\n                    uint256 cycle = manager.getCurrentCycleIndex();\\n\\n                    (uint256 minCycle, uint256 amount) = i < lt\\n                        ? reactor.requestedWithdrawals()\\n                        : staking.withdrawalRequestsByIndex(self, 0);\\n\\n                    if (amounts[i] == nmax) amounts[i] = amount;\\n\\n                    if (cycle < minCycle)\\n                        revert GeneralizedTokemak_WithdrawalNotReady(i);\\n\\n                    if (0 < amounts[i])\\n                        if (i < lt) reactor.withdraw(amounts[i]);\\n                        else staking.withdraw(amounts[i]);\\n                }\\n            }\\n        }\\n    }\\n\\n    function _prepareMigration() internal override {\\n        if (!totalWithdrawInitialized) {\\n            revert GeneralizedTokemak_MustInitializeTotalWithdraw();\\n        } else {\\n            deallocate(TokemakAllocatorLib.nmaxarr(reactors.length + 1));\\n        }\\n    }\\n\\n    function _deactivate(bool panic) internal override {\\n        if (panic) {\\n            deallocate(TokemakAllocatorLib.nmaxarr(reactors.length + 2));\\n            totalWithdrawInitialized = true;\\n        }\\n    }\\n\\n    function _activate() internal override {\\n        totalWithdrawInitialized = false;\\n    }\\n\\n    // ######################## ~ SETTERS ~ ########################\\n\\n    function vote(UserVotePayload calldata payload) external onlyGuardian {\\n        voting.vote(payload);\\n    }\\n\\n    function updateClaimPayload(PayloadData calldata data)\\n        external\\n        onlyGuardian\\n    {\\n        nextPayloadData = data;\\n        mayClaim = true;\\n    }\\n\\n    function addToken(address token, address reactor) external onlyGuardian {\\n        ERC20(token).safeApprove(address(extender), type(uint256).max);\\n        ERC20(reactor).safeApprove(address(extender), type(uint256).max);\\n        _tokens.push(ERC20(token));\\n        reactors.push(reactor);\\n    }\\n\\n    function setTokemakData(TokemakData memory tokeData) external onlyGuardian {\\n        _setTokemakData(tokeData);\\n    }\\n\\n    // ######################## ~ GETTERS ~ ########################\\n\\n    function tokeAvailable(uint256 scheduleIndex)\\n        public\\n        view\\n        virtual\\n        returns (uint256)\\n    {\\n        return staking.availableForWithdrawal(self, scheduleIndex);\\n    }\\n\\n    function tokeDeposited() public view virtual returns (uint256) {\\n        return staking.balanceOf(self);\\n    }\\n\\n    // ######################## ~ GETTER OVERRIDES ~ ########################\\n\\n    function amountAllocated(uint256 id)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return reactors[tokenIds[id]].balanceOf(self);\\n    }\\n\\n    function name() external pure override returns (string memory) {\\n        return \\\"GeneralizedTokemak\\\";\\n    }\\n\\n    function utilityTokens() public view override returns (ERC20[] memory) {\\n        uint256 l = reactors.length + 1;\\n        ERC20[] memory utils = new ERC20[](l);\\n\\n        for (uint256 i; i < l - 1; i++) {\\n            utils[i] = ERC20(reactors[i]);\\n        }\\n\\n        utils[l - 1] = toke;\\n        return utils;\\n    }\\n\\n    function rewardTokens() public view override returns (ERC20[] memory) {\\n        ERC20[] memory reward = new ERC20[](1);\\n        reward[0] = toke;\\n        return reward;\\n    }\\n\\n    // ######################## ~ INTERNAL SETTERS ~ ########################\\n\\n    function _setTokemakData(TokemakData memory tokeData) internal {\\n        voting = ITokemakVoting(tokeData.voting);\\n        staking = IStaking(tokeData.staking);\\n        rewards = IRewards(tokeData.rewards);\\n        manager = IManager(tokeData.manager);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"src/types/BaseAllocator.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\n// interfaces\\nimport \\\"../interfaces/IAllocator.sol\\\";\\nimport \\\"olympus/interfaces/ITreasury.sol\\\";\\n\\n// types\\nimport \\\"olympus/types/OlympusAccessControlledV2.sol\\\";\\n\\n// libraries\\nimport \\\"solmate/utils/SafeTransferLib.sol\\\";\\n\\nerror BaseAllocator_AllocatorNotActivated();\\nerror BaseAllocator_AllocatorNotOffline();\\nerror BaseAllocator_Migrating();\\nerror BaseAllocator_NotMigrating();\\nerror BaseAllocator_OnlyExtender(address sender);\\n\\n/**\\n * @title BaseAllocator\\n * @notice\\n *  This abstract contract serves as a template for writing new Olympus Allocators.\\n *  Many of the functionalities regarding handling of Treasury funds by the Guardian have\\n *  been delegated to the `TreasuryExtender` contract, and thus an explanation for them can be found\\n *  in `TreasuryExtender.sol`.\\n *\\n *  The main purpose of this abstract contract and the `IAllocator` interface is to provide\\n *  a unified framework for how an Allocator should behave. Below an explanation of how\\n *  we expect an Allocator to behave in general, mentioning the most important points.\\n *\\n *  Activation:\\n *   - An Allocator is first deployed with all necessary arguments.\\n *     Thereafter, each deposit is registered with the `TreasuryExtender`.\\n *     This assigns a unique id for each deposit (set of allocations) in an Allocator.\\n *   - Next, the Allocators allocation and loss limits are set via the extender function.\\n *   - Finally, the Allocator is activated by calling `activate`.\\n *\\n *  Runtime:\\n *   The Allocator is in communication with the Extender, it must inform the Extender\\n *   what the status of the tokens is which were allocated. We only care about noting down\\n *   their status in the Extender. A quick summary of the important functions on this topic:\\n *\\n *   - `update(uint256 id)` is the main function that deals with state reporting, where\\n *     `_update(uint256 id)` is the internal function to implement, which should update Allocator\\n *     internal state. `update(uint256 id)` then continues to report the Allocators state via `report`\\n *     to the extender. `_update(uint256 id)` should handle _investment_ of funds present in Contract.\\n *\\n *   - `deallocate` should handle allocated token withdrawal, preparing the tokens to be withdrawn\\n *     by the Extender. It is not necessary to handle approvals for this token, because it is automatically\\n *     approved in the constructor. For other token withdrawals, it is assumed that reward tokens will\\n *     either be sold into underlying (allocated) or that they will simply rest in the Contract, being reward tokens.\\n *     Please also check function documentation.\\n *\\n *   - `rewardTokens` and `utilityTokens` should return the above mentioned simple reward tokens for the former case,\\n *     while utility tokens should be those tokens which are continously reinvested or otherwise used by the contract\\n *     in order to accrue more rewards. A reward token can also be a utility token, but then one must prepare them\\n *     separately for withdrawal if they are to be returned to the treasury.\\n *\\n *  Migration & Deactivation:\\n *   - `prepareMigration()` together with the virtual `_prepareMigration()` sets the state of the Allocator into\\n *     MIGRATING, disabling further token deposits, enabling only withdrawals, and preparing all funds for withdrawal.\\n *\\n *   - `migrate` then executes the migration and also deactivates the Allocator.\\n *\\n *   - `deactivate` sets `status` to OFFLINE, meaning it simply deactivates the Allocator. It can be passed\\n *     a panic boolean, meaning it handles deactivation logic in `deactivate`. The Allocator panic deactivates if\\n *     this state if the loss limit is reached via `update`. The Allocator can otherwise also simply be deactivated\\n *     and funds transferred back to the Treasury.\\n *\\n *  This was a short summary of the Allocator lifecycle.\\n */\\nabstract contract BaseAllocator is OlympusAccessControlledV2, IAllocator {\\n    using SafeTransferLib for ERC20;\\n\\n    // Indices which represent the ids of the deposits in the `TreasuryExtender`\\n    uint256[] internal _ids;\\n\\n    // The allocated (underlying) tokens of the Allocator\\n    ERC20[] internal _tokens;\\n\\n    // From deposit id to the token's id\\n    mapping(uint256 => uint256) public tokenIds;\\n\\n    // Allocator status: OFFLINE, ACTIVATED, MIGRATING\\n    AllocatorStatus public status;\\n\\n    // The extender with which the Allocator communicates.\\n    ITreasuryExtender public immutable extender;\\n\\n    constructor(AllocatorInitData memory data)\\n        OlympusAccessControlledV2(data.authority)\\n    {\\n        _tokens = data.tokens;\\n        extender = data.extender;\\n\\n        for (uint256 i; i < data.tokens.length; i++) {\\n            data.tokens[i].approve(address(data.extender), type(uint256).max);\\n        }\\n\\n        emit AllocatorDeployed(address(data.authority), address(data.extender));\\n    }\\n\\n    /////// MODIFIERS\\n\\n    modifier onlyExtender() {\\n        _onlyExtender(msg.sender);\\n        _;\\n    }\\n\\n    modifier onlyActivated() {\\n        _onlyActivated(status);\\n        _;\\n    }\\n\\n    modifier onlyOffline() {\\n        _onlyOffline(status);\\n        _;\\n    }\\n\\n    modifier notMigrating() {\\n        _notMigrating(status);\\n        _;\\n    }\\n\\n    modifier isMigrating() {\\n        _isMigrating(status);\\n        _;\\n    }\\n\\n    /////// VIRTUAL FUNCTIONS WHICH NEED TO BE IMPLEMENTED\\n    /////// SORTED BY EXPECTED COMPLEXITY AND DEPENDENCY\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state.\\n     * @dev\\n     *  This function should be implemented by the developer of the Allocator.\\n     *  This function should fulfill the following purposes:\\n     *   - invest token specified by deposit id\\n     *   - handle rebalancing / harvesting for token as needed\\n     *   - calculate gain / loss for token and return those values\\n     *   - handle any other necessary runtime calculations, such as fees etc.\\n     *\\n     *  In essence, this function should update the main runtime state of the Allocator\\n     *  so that everything is properly invested, harvested, accounted for.\\n     * @param id the id of the deposit in the `TreasuryExtender`\\n     */\\n    function _update(uint256 id)\\n        internal\\n        virtual\\n        returns (uint128 gain, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Deallocates tokens, prepares tokens for return to the Treasury.\\n     * @dev\\n     *  This function should deallocate (withdraw) `amounts` of each token so that they may be withdrawn\\n     *  by the TreasuryExtender. Otherwise, this function may also prepare the withdraw if it is time-bound.\\n     * @param amounts is the amount of each of token from `_tokens` to withdraw\\n     */\\n    function deallocate(uint256[] memory amounts) public virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles deactivation logic for the Allocator.\\n     */\\n    function _deactivate(bool panic) internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Handles migration preparatory logic.\\n     * @dev\\n     *  Within this function, the developer should arrange the withdrawal of all assets for migration.\\n     *  A useful function, say, to be passed into this could be `deallocate` with all of the amounts,\\n     *  so with n places for n-1 utility tokens + 1 allocated token, maxed out.\\n     */\\n    function _prepareMigration() internal virtual;\\n\\n    /**\\n     * @notice\\n     *  Should estimate total amount of Allocated tokens\\n     * @dev\\n     *  The difference between this and `treasury.getAllocatorAllocated`, is that the latter is a static\\n     *  value recorded during reporting, but no data is available on _new_ amounts after reporting.\\n     *  Thus, this should take into consideration the new amounts. This can be used for say aTokens.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function amountAllocated(uint256 id) public view virtual returns (uint256);\\n\\n    /**\\n     * @notice\\n     *  Should return all reward token addresses\\n     */\\n    function rewardTokens() public view virtual returns (ERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return all utility token addresses\\n     */\\n    function utilityTokens() public view virtual returns (ERC20[] memory);\\n\\n    /**\\n     * @notice\\n     *  Should return the Allocator name\\n     */\\n    function name() external view virtual returns (string memory);\\n\\n    /////// IMPLEMENTATION OPTIONAL\\n\\n    /**\\n     * @notice\\n     *  Should handle activation logic\\n     * @dev\\n     *  If there is a need to handle any logic during activation, this is the function you should implement it into\\n     */\\n    function _activate() internal virtual {}\\n\\n    /////// FUNCTIONS\\n\\n    /**\\n     * @notice\\n     *  Updates an Allocators state and reports to `TreasuryExtender` if necessary.\\n     * @dev\\n     *  Can only be called by the Guardian.\\n     *  Can only be called while the Allocator is activated.\\n     *\\n     *  This function should update the Allocators internal state via `_update`, which should in turn\\n     *  return the `gain` and `loss` the Allocator has sustained in underlying allocated `token` from `_tokens`\\n     *  decided by the `id`.\\n     *  Please check the docs on `_update` to see what its function should be.\\n     *\\n     *  `_lossLimitViolated` checks if the Allocators is above its loss limit and deactivates it in case\\n     *  of serious losses. The loss limit should be set to some value which is unnacceptable to be lost\\n     *  in the case of normal runtime and thus require a panic shutdown, whatever it is defined to be.\\n     *\\n     *  Lastly, the Allocator reports its state to the Extender, which handles gain, loss, allocated logic.\\n     *  The documentation on this can be found in `TreasuryExtender.sol`.\\n     * @param id the id of the deposit in `TreasuryExtender`\\n     */\\n    function update(uint256 id) external override onlyGuardian onlyActivated {\\n        // effects\\n        // handle depositing, harvesting, compounding logic inside of _update()\\n        // if gain is in allocated then gain > 0 otherwise gain == 0\\n        // we only use so we know initia\\n        // loss always in allocated\\n        (uint128 gain, uint128 loss) = _update(id);\\n\\n        if (_lossLimitViolated(id, loss)) {\\n            deactivate(true);\\n            return;\\n        }\\n\\n        // interactions\\n        // there is no interactions happening inside of report\\n        // so allocator has no state changes to make after it\\n        if (gain + loss > 0) extender.report(id, gain, loss);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Prepares the Allocator for token migration.\\n     * @dev\\n     *  This function prepares the Allocator for token migration by calling the to-be-implemented\\n     *  `_prepareMigration`, which should logically withdraw ALL allocated (1) + utility AND reward tokens\\n     *  from the contract. The ALLOCATED token and THE UTILITY TOKEN is going to be migrated, while the REWARD\\n     *  tokens can be withdrawn by the Extender to the Treasury.\\n     */\\n    function prepareMigration() external override onlyGuardian notMigrating {\\n        // effects\\n        _prepareMigration();\\n\\n        status = AllocatorStatus.MIGRATING;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Migrates the allocated and all utility tokens to the next Allocator.\\n     * @dev\\n     *  The allocated token and the utility tokens will be migrated by this function, while it is\\n     *  assumed that the reward tokens are either simply kept or already harvested into the underlying\\n     *  essentially being the edge case of this contract. This contract is also going to report to the\\n     *  Extender that a migration happened and as such it is important to follow the proper sequence of\\n     *  migrating.\\n     *\\n     *  Steps to migrate:\\n     *   - FIRST call `_prepareMigration()` to prepare funds for migration.\\n     *   - THEN deploy the new Allocator and activate it according to the normal procedure.\\n     *     NOTE: This is to be done RIGHT BEFORE migration as to avoid allocating to the wrong allocator.\\n     *   - FINALLY call migrate. This is going to migrate the funds to the LAST allocator registered.\\n     *   - Check if everything went fine.\\n     *\\n     *  End state should be that allocator amounts have been swapped for allocators, that gain + loss is netted out 0\\n     *  for original allocator, and that the new allocators gain has been set to the original allocators gain.\\n     *  We don't transfer the loss because we have the information how much was initially invested + gain,\\n     *  and the new allocator didn't cause any loss thus we don't really need to add to it.\\n     */\\n    function migrate() external override onlyGuardian isMigrating {\\n        // reads\\n        ERC20[] memory utilityTokensArray = utilityTokens();\\n        address newAllocator = extender.getAllocatorByID(\\n            extender.getTotalAllocatorCount() - 1\\n        );\\n        uint256 idLength = _ids.length;\\n        uint256 utilLength = utilityTokensArray.length;\\n\\n        // interactions\\n        for (uint256 i; i < idLength; i++) {\\n            ERC20 token = _tokens[i];\\n\\n            token.safeTransfer(newAllocator, token.balanceOf(address(this)));\\n            extender.report(_ids[i], type(uint128).max, type(uint128).max);\\n        }\\n\\n        for (uint256 i; i < utilLength; i++) {\\n            ERC20 utilityToken = utilityTokensArray[i];\\n            utilityToken.safeTransfer(\\n                newAllocator,\\n                utilityToken.balanceOf(address(this))\\n            );\\n        }\\n\\n        // turn off Allocator\\n        deactivate(false);\\n\\n        emit MigrationExecuted(newAllocator);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Activates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during activation, say interactions with Extender or something else,\\n     *  in the virtual method `_activate`.\\n     */\\n    function activate() external override onlyGuardian onlyOffline {\\n        // effects\\n        _activate();\\n        status = AllocatorStatus.ACTIVATED;\\n\\n        emit AllocatorActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Adds a deposit ID to the Allocator.\\n     * @dev\\n     *  Only the Extender calls this.\\n     * @param id id to add to the allocator\\n     */\\n    function addId(uint256 id) external override onlyExtender {\\n        _ids.push(id);\\n        tokenIds[id] = _ids.length - 1;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all deposit IDs registered with the Allocator.\\n     * @return the deposit IDs registered\\n     */\\n    function ids() external view override returns (uint256[] memory) {\\n        return _ids;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Returns all tokens registered with the Allocator.\\n     * @return the tokens\\n     */\\n    function tokens() external view override returns (ERC20[] memory) {\\n        return _tokens;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Deactivates the Allocator.\\n     * @dev\\n     *  Only the Guardian can call this.\\n     *\\n     *  Add any logic you need during deactivation, say interactions with Extender or something else,\\n     *  in the virtual method `_deactivate`. Be careful to specifically use the internal or public function\\n     *  depending on what you need.\\n     * @param panic should panic logic be executed\\n     */\\n    function deactivate(bool panic) public override onlyGuardian {\\n        // effects\\n        _deactivate(panic);\\n        status = AllocatorStatus.OFFLINE;\\n\\n        emit AllocatorDeactivated(panic);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Getter for Allocator version.\\n     * @return Returns the Allocators version.\\n     */\\n    function version() public pure override returns (string memory) {\\n        return \\\"v2.0.0\\\";\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check if the loss limit has been violated by the Allocator.\\n     * @dev\\n     *  Called as part of `update`. The rule is that the already sustained loss + newly sustained\\n     *  has to be larger or equal to the limit to break the contract.\\n     * @param id deposit id as in `TreasuryExtender`\\n     * @param loss the amount of newly sustained loss\\n     * @return true if the the loss limit has been broken\\n     */\\n    function _lossLimitViolated(uint256 id, uint128 loss)\\n        internal\\n        returns (bool)\\n    {\\n        // read\\n        uint128 lastLoss = extender.getAllocatorPerformance(id).loss;\\n\\n        // events\\n        if ((loss + lastLoss) >= extender.getAllocatorLimits(id).loss) {\\n            emit LossLimitViolated(\\n                lastLoss,\\n                loss,\\n                amountAllocated(tokenIds[id])\\n            );\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if sender is extender.\\n     */\\n    function _onlyExtender(address sender) internal view {\\n        if (sender != address(extender))\\n            revert BaseAllocator_OnlyExtender(sender);\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is activated.\\n     */\\n    function _onlyActivated(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.ACTIVATED)\\n            revert BaseAllocator_AllocatorNotActivated();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is offline.\\n     */\\n    function _onlyOffline(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.OFFLINE)\\n            revert BaseAllocator_AllocatorNotOffline();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is not migrating.\\n     */\\n    function _notMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus == AllocatorStatus.MIGRATING)\\n            revert BaseAllocator_Migrating();\\n    }\\n\\n    /**\\n     * @notice\\n     *  Internal check to see if allocator is migrating.\\n     */\\n    function _isMigrating(AllocatorStatus inputStatus) internal pure {\\n        if (inputStatus != AllocatorStatus.MIGRATING)\\n            revert BaseAllocator_NotMigrating();\\n    }\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/UserVotePayload.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct UserVotePayload {\\n    address account;\\n    bytes32 voteSessionKey;\\n    uint256 nonce;\\n    uint256 chainId;\\n    uint256 totalVotes;\\n    UserVoteAllocationItem[] allocations;\\n}\\n\\nstruct UserVoteAllocationItem {\\n    bytes32 reactorKey; //asset-default, in actual deployment could be asset-exchange\\n    uint256 amount; //18 Decimals\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/ILiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IManager.sol\\\";\\n\\n/// @title Interface for Pool\\n/// @notice Allows users to deposit ERC-20 tokens to be deployed to market makers.\\n/// @notice Mints 1:1 tAsset on deposit, represeting an IOU for the undelrying token that is freely transferable.\\n/// @notice Holders of tAsset earn rewards based on duration their tokens were deployed and the demand for that asset.\\n/// @notice Holders of tAsset can redeem for underlying asset after issuing requestWithdrawal and waiting for the next cycle.\\ninterface ILiquidityPool {\\n    struct WithdrawalInfo {\\n        uint256 minCycle;\\n        uint256 amount;\\n    }\\n\\n    event WithdrawalRequested(address requestor, uint256 amount);\\n    event DepositsPaused();\\n    event DepositsUnpaused();\\n\\n    /// @notice Transfers amount of underlying token from user to this pool and mints fToken to the msg.sender.\\n    /// @notice Depositor must have previously granted transfer approval to the pool via underlying token contract.\\n    /// @notice Liquidity deposited is deployed on the next cycle - unless a withdrawal request is submitted, in which case the liquidity will be withheld.\\n    function deposit(uint256 amount) external;\\n\\n    /// @notice Transfers amount of underlying token from user to this pool and mints fToken to the account.\\n    /// @notice Depositor must have previously granted transfer approval to the pool via underlying token contract.\\n    /// @notice Liquidity deposited is deployed on the next cycle - unless a withdrawal request is submitted, in which case the liquidity will be withheld.\\n    function depositFor(address account, uint256 amount) external;\\n\\n    /// @notice Requests that the manager prepare funds for withdrawal next cycle\\n    /// @notice Invoking this function when sender already has a currently pending request will overwrite that requested amount and reset the cycle timer\\n    /// @param amount Amount of fTokens requested to be redeemed\\n    function requestWithdrawal(uint256 amount) external;\\n\\n    function approveManager(uint256 amount) external;\\n\\n    /// @notice Sender must first invoke requestWithdrawal in a previous cycle\\n    /// @notice This function will burn the fAsset and transfers underlying asset back to sender\\n    /// @notice Will execute a partial withdrawal if either available liquidity or previously requested amount is insufficient\\n    /// @param amount Amount of fTokens to redeem, value can be in excess of available tokens, operation will be reduced to maximum permissible\\n    function withdraw(uint256 amount) external;\\n\\n    /// @return Amount of liquidity that should not be deployed for market making (this liquidity will be used for completing requested withdrawals)\\n    function withheldLiquidity() external view returns (uint256);\\n\\n    /// @notice Get withdraw requests for an account\\n    /// @param account User account to check\\n    /// @return minCycle Cycle - block number - that must be active before withdraw is allowed, amount Token amount requested\\n    function requestedWithdrawals(address account)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    /// @notice Pause deposits on the pool. Withdraws still allowed\\n    function pause() external;\\n\\n    /// @notice Unpause deposits on the pool.\\n    function unpause() external;\\n\\n    // @notice Pause deposits only on the pool.\\n    function pauseDeposit() external;\\n\\n    // @notice Unpause deposits only on the pool.\\n    function unpauseDeposit() external;\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/IRewardHash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n *  @title Tracks the IPFS hashes that are generated for rewards\\n */\\ninterface IRewardHash {\\n    struct CycleHashTuple {\\n        string latestClaimable; // hash of last claimable cycle before/including this cycle\\n        string cycle; // cycleHash of this cycle\\n    }\\n\\n    event CycleHashAdded(\\n        uint256 cycleIndex,\\n        string latestClaimableHash,\\n        string cycleHash\\n    );\\n\\n    /// @notice Sets a new (claimable, cycle) hash tuple for the specified cycle\\n    /// @param index Cycle index to set. If index >= LatestCycleIndex, CycleHashAdded is emitted\\n    /// @param latestClaimableIpfsHash IPFS hash of last claimable cycle before/including this cycle\\n    /// @param cycleIpfsHash IPFS hash of this cycle\\n    function setCycleHashes(\\n        uint256 index,\\n        string calldata latestClaimableIpfsHash,\\n        string calldata cycleIpfsHash\\n    ) external;\\n\\n    ///@notice Gets hashes for the specified cycle\\n    ///@return latestClaimable lastest claimable hash for specified cycle, cycle latest hash (possibly non-claimable) for specified cycle\\n    function cycleHashes(uint256 index)\\n        external\\n        view\\n        returns (string memory latestClaimable, string memory cycle);\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/IStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n *  @title Allows for the staking and vesting of TOKE for\\n *  liquidity directors. Schedules can be added to enable various\\n *  cliff+duration/interval unlock periods for vesting tokens.\\n */\\ninterface IStaking {\\n    struct StakingSchedule {\\n        uint256 cliff; // Duration in seconds before staking starts\\n        uint256 duration; // Seconds it takes for entire amount to stake\\n        uint256 interval; // Seconds it takes for a chunk to stake\\n        bool setup; //Just so we know its there\\n        bool isActive; //Whether we can setup new stakes with the schedule\\n        uint256 hardStart; //Stakings will always start at this timestamp if set\\n        bool isPublic; //Schedule can be written to by any account\\n    }\\n\\n    struct StakingScheduleInfo {\\n        StakingSchedule schedule;\\n        uint256 index;\\n    }\\n\\n    struct StakingDetails {\\n        uint256 initial; //Initial amount of asset when stake was created, total amount to be staked before slashing\\n        uint256 withdrawn; //Amount that was staked and subsequently withdrawn\\n        uint256 slashed; //Amount that has been slashed\\n        uint256 started; //Timestamp at which the stake started\\n        uint256 scheduleIx;\\n    }\\n\\n    struct WithdrawalInfo {\\n        uint256 minCycleIndex;\\n        uint256 amount;\\n    }\\n\\n    struct QueuedTransfer {\\n        address from;\\n        uint256 scheduleIdxFrom;\\n        uint256 scheduleIdxTo;\\n        uint256 amount;\\n        address to;\\n    }\\n\\n    event ScheduleAdded(\\n        uint256 scheduleIndex,\\n        uint256 cliff,\\n        uint256 duration,\\n        uint256 interval,\\n        bool setup,\\n        bool isActive,\\n        uint256 hardStart,\\n        address notional\\n    );\\n    event ScheduleRemoved(uint256 scheduleIndex);\\n    event WithdrawalRequested(\\n        address account,\\n        uint256 scheduleIdx,\\n        uint256 amount\\n    );\\n    event WithdrawCompleted(\\n        address account,\\n        uint256 scheduleIdx,\\n        uint256 amount\\n    );\\n    event Deposited(address account, uint256 amount, uint256 scheduleIx);\\n    event Slashed(address account, uint256 amount, uint256 scheduleIx);\\n    event PermissionedDepositorSet(address depositor, bool allowed);\\n    event UserSchedulesSet(address account, uint256[] userSchedulesIdxs);\\n    event NotionalAddressesSet(uint256[] scheduleIdxs, address[] addresses);\\n    event ScheduleStatusSet(uint256 scheduleId, bool isActive);\\n    event StakeTransferred(\\n        address from,\\n        uint256 scheduleFrom,\\n        uint256 scheduleTo,\\n        uint256 amount,\\n        address to\\n    );\\n    event ZeroSweep(address user, uint256 amount, uint256 scheduleFrom);\\n    event TransferApproverSet(address approverAddress);\\n    event TransferQueued(\\n        address from,\\n        uint256 scheduleFrom,\\n        uint256 scheduleTo,\\n        uint256 amount,\\n        address to\\n    );\\n    event QueuedTransferRemoved(\\n        address from,\\n        uint256 scheduleFrom,\\n        uint256 scheduleTo,\\n        uint256 amount,\\n        address to\\n    );\\n    event QueuedTransferRejected(\\n        address from,\\n        uint256 scheduleFrom,\\n        uint256 scheduleTo,\\n        uint256 amount,\\n        address to\\n    );\\n\\n    ///@notice Allows for checking of user address in permissionedDepositors mapping\\n    ///@param account Address of account being checked\\n    ///@return Boolean, true if address exists in mapping\\n    function permissionedDepositors(address account) external returns (bool);\\n\\n    ///@notice Allows owner to set a multitude of schedules that an address has access to\\n    ///@param account User address\\n    ///@param userSchedulesIdxs Array of schedule indexes\\n    function setUserSchedules(\\n        address account,\\n        uint256[] calldata userSchedulesIdxs\\n    ) external;\\n\\n    ///@notice Allows owner to add schedule\\n    ///@param schedule A StakingSchedule struct that contains all info needed to make a schedule\\n    ///@param notional Notional addrss for schedule, used to send balances to L2 for voting purposes\\n    function addSchedule(StakingSchedule memory schedule, address notional)\\n        external;\\n\\n    ///@notice Gets all info on all schedules\\n    ///@return retSchedules An array of StakingScheduleInfo struct\\n    function getSchedules()\\n        external\\n        view\\n        returns (StakingScheduleInfo[] memory retSchedules);\\n\\n    ///@notice Allows owner to set a permissioned depositor\\n    ///@param account User address\\n    ///@param canDeposit Boolean representing whether user can deposit\\n    function setPermissionedDepositor(address account, bool canDeposit)\\n        external;\\n\\n    function withdrawalRequestsByIndex(address account, uint256 index)\\n        external\\n        view\\n        returns (uint256 minCycle, uint256 amount);\\n\\n    ///@notice Allows a user to get the stakes of an account\\n    ///@param account Address that is being checked for stakes\\n    ///@return stakes StakingDetails array containing info about account's stakes\\n    function getStakes(address account)\\n        external\\n        view\\n        returns (StakingDetails[] memory stakes);\\n\\n    ///@notice Gets total value staked for an address across all schedules\\n    ///@param account Address for which total stake is being calculated\\n    ///@return value uint256 total of account\\n    function balanceOf(address account) external view returns (uint256 value);\\n\\n    ///@notice Returns amount available to withdraw for an account and schedule Index\\n    ///@param account Address that is being checked for withdrawals\\n    ///@param scheduleIndex Index of schedule that is being checked for withdrawals\\n    function availableForWithdrawal(address account, uint256 scheduleIndex)\\n        external\\n        view\\n        returns (uint256);\\n\\n    ///@notice Returns unvested amount for certain address and schedule index\\n    ///@param account Address being checked for unvested amount\\n    ///@param scheduleIndex Schedule index being checked for unvested amount\\n    ///@return value Uint256 representing unvested amount\\n    function unvested(address account, uint256 scheduleIndex)\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    ///@notice Returns vested amount for address and schedule index\\n    ///@param account Address being checked for vested amount\\n    ///@param scheduleIndex Schedule index being checked for vested amount\\n    ///@return value Uint256 vested\\n    function vested(address account, uint256 scheduleIndex)\\n        external\\n        view\\n        returns (uint256 value);\\n\\n    ///@notice Allows user to deposit token to specific vesting / staking schedule\\n    ///@param amount Uint256 amount to be deposited\\n    ///@param scheduleIndex Uint256 representing schedule to user\\n    function deposit(uint256 amount, uint256 scheduleIndex) external;\\n\\n    /// @notice Allows users to deposit into 0 schedule\\n    /// @param amount Deposit amount\\n    function deposit(uint256 amount) external;\\n\\n    ///@notice Allows account to deposit on behalf of other account\\n    ///@param account Account to be deposited for\\n    ///@param amount Amount to be deposited\\n    ///@param scheduleIndex Index of schedule to be used for deposit\\n    function depositFor(\\n        address account,\\n        uint256 amount,\\n        uint256 scheduleIndex\\n    ) external;\\n\\n    ///@notice Allows permissioned depositors to deposit into custom schedule\\n    ///@param account Address of account being deposited for\\n    ///@param amount Uint256 amount being deposited\\n    ///@param schedule StakingSchedule struct containing details needed for new schedule\\n    ///@param notional Notional address attached to schedule, allows for different voting weights on L2\\n    function depositWithSchedule(\\n        address account,\\n        uint256 amount,\\n        StakingSchedule calldata schedule,\\n        address notional\\n    ) external;\\n\\n    ///@notice User can request withdrawal from staking contract at end of cycle\\n    ///@notice Performs checks to make sure amount <= amount available\\n    ///@param amount Amount to withdraw\\n    ///@param scheduleIdx Schedule index for withdrawal Request\\n    function requestWithdrawal(uint256 amount, uint256 scheduleIdx) external;\\n\\n    ///@notice Allows for withdrawal after successful withdraw request and proper amount of cycles passed\\n    ///@param amount Amount to withdraw\\n    ///@param scheduleIdx Schedule to withdraw from\\n    function withdraw(uint256 amount, uint256 scheduleIdx) external;\\n\\n    /// @notice Allows owner to set schedule to active or not\\n    /// @param scheduleIndex Schedule index to set isActive boolean\\n    /// @param activeBoolean Bool to set schedule active or not\\n    function setScheduleStatus(uint256 scheduleIndex, bool activeBoolean)\\n        external;\\n\\n    /// @notice Pause deposits on the pool. Withdraws still allowed\\n    function pause() external;\\n\\n    /// @notice Unpause deposits on the pool.\\n    function unpause() external;\\n\\n    /// @notice Used to slash user funds when needed\\n    /// @notice accounts and amounts arrays must be same length\\n    /// @notice Only one scheduleIndex can be slashed at a time\\n    /// @dev Implementation must be restructed to owner account\\n    /// @param accounts Array of accounts to slash\\n    /// @param amounts Array of amounts that corresponds with accounts\\n    /// @param scheduleIndex scheduleIndex of users that are being slashed\\n    function slash(\\n        address[] calldata accounts,\\n        uint256[] calldata amounts,\\n        uint256 scheduleIndex\\n    ) external;\\n\\n    /// @notice Set the address used to denote the token amount for a particular schedule\\n    /// @dev Relates to the Balance Tracker tracking of tokens and balances. Each schedule is tracked separately\\n    function setNotionalAddresses(\\n        uint256[] calldata scheduleIdxArr,\\n        address[] calldata addresses\\n    ) external;\\n\\n    /// @notice Withdraw from the default schedule. Must have a request in previously\\n    /// @param amount Amount to withdraw\\n    function withdraw(uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/IManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n *  @title Controls the transition and execution of liquidity deployment cycles.\\n *  Accepts instructions that can move assets from the Pools to the Exchanges\\n *  and back. Can also move assets to the treasury when appropriate.\\n */\\ninterface IManager {\\n    // bytes can take on the form of deploying or recovering liquidity\\n    struct ControllerTransferData {\\n        bytes32 controllerId; // controller to target\\n        bytes data; // data the controller will pass\\n    }\\n\\n    struct PoolTransferData {\\n        address pool; // pool to target\\n        uint256 amount; // amount to transfer\\n    }\\n\\n    struct MaintenanceExecution {\\n        ControllerTransferData[] cycleSteps;\\n    }\\n\\n    struct RolloverExecution {\\n        PoolTransferData[] poolData;\\n        ControllerTransferData[] cycleSteps;\\n        address[] poolsForWithdraw; //Pools to target for manager -> pool transfer\\n        bool complete; //Whether to mark the rollover complete\\n        string rewardsIpfsHash;\\n    }\\n\\n    event ControllerRegistered(bytes32 id, address controller);\\n    event ControllerUnregistered(bytes32 id, address controller);\\n    event PoolRegistered(address pool);\\n    event PoolUnregistered(address pool);\\n    event CycleDurationSet(uint256 duration);\\n    event LiquidityMovedToManager(address pool, uint256 amount);\\n    event DeploymentStepExecuted(\\n        bytes32 controller,\\n        address adapaterAddress,\\n        bytes data\\n    );\\n    event LiquidityMovedToPool(address pool, uint256 amount);\\n    event CycleRolloverStarted(uint256 timestamp);\\n    event CycleRolloverComplete(uint256 timestamp);\\n    event NextCycleStartSet(uint256 nextCycleStartTime);\\n    event ManagerSwept(address[] addresses, uint256[] amounts);\\n\\n    /// @notice Registers controller\\n    /// @param id Bytes32 id of controller\\n    /// @param controller Address of controller\\n    function registerController(bytes32 id, address controller) external;\\n\\n    /// @notice Registers pool\\n    /// @param pool Address of pool\\n    function registerPool(address pool) external;\\n\\n    /// @notice Unregisters controller\\n    /// @param id Bytes32 controller id\\n    function unRegisterController(bytes32 id) external;\\n\\n    /// @notice Unregisters pool\\n    /// @param pool Address of pool\\n    function unRegisterPool(address pool) external;\\n\\n    ///@notice Gets addresses of all pools registered\\n    ///@return Memory array of pool addresses\\n    function getPools() external view returns (address[] memory);\\n\\n    ///@notice Gets ids of all controllers registered\\n    ///@return Memory array of Bytes32 controller ids\\n    function getControllers() external view returns (bytes32[] memory);\\n\\n    ///@notice Allows for owner to set cycle duration\\n    ///@param duration Block durtation of cycle\\n    function setCycleDuration(uint256 duration) external;\\n\\n    ///@notice Starts cycle rollover\\n    ///@dev Sets rolloverStarted state boolean to true\\n    function startCycleRollover() external;\\n\\n    ///@notice Allows for controller commands to be executed midcycle\\n    ///@param params Contains data for controllers and params\\n    function executeMaintenance(MaintenanceExecution calldata params) external;\\n\\n    ///@notice Allows for withdrawals and deposits for pools along with liq deployment\\n    ///@param params Contains various data for executing against pools and controllers\\n    function executeRollover(RolloverExecution calldata params) external;\\n\\n    ///@notice Completes cycle rollover, publishes rewards hash to ipfs\\n    ///@param rewardsIpfsHash rewards hash uploaded to ipfs\\n    function completeRollover(string calldata rewardsIpfsHash) external;\\n\\n    ///@notice Gets reward hash by cycle index\\n    ///@param index Cycle index to retrieve rewards hash\\n    ///@return String memory hash\\n    function cycleRewardsHashes(uint256 index)\\n        external\\n        view\\n        returns (string memory);\\n\\n    ///@notice Gets current starting block\\n    ///@return uint256 with block number\\n    function getCurrentCycle() external view returns (uint256);\\n\\n    ///@notice Gets current cycle index\\n    ///@return uint256 current cycle number\\n    function getCurrentCycleIndex() external view returns (uint256);\\n\\n    ///@notice Gets current cycle duration\\n    ///@return uint256 in block of cycle duration\\n    function getCycleDuration() external view returns (uint256);\\n\\n    ///@notice Gets cycle rollover status, true for rolling false for not\\n    ///@return Bool representing whether cycle is rolling over or not\\n    function getRolloverStatus() external view returns (bool);\\n\\n    /// @notice Sets next cycle start time manually\\n    /// @param nextCycleStartTime uint256 that represents start of next cycle\\n    function setNextCycleStartTime(uint256 nextCycleStartTime) external;\\n\\n    /// @notice Sweeps amanager contract for any leftover funds\\n    /// @param addresses array of addresses of pools to sweep funds into\\n    function sweep(address[] calldata addresses) external;\\n\\n    /// @notice Setup a role using internal function _setupRole\\n    /// @param role keccak256 of the role keccak256(\\\"MY_ROLE\\\");\\n    function setupRole(bytes32 role) external;\\n}\\n\"\r\n    },\r\n    \"src/allocators/tokemak/interfaces/IRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n *  @title Validates and distributes TOKE rewards based on the\\n *  the signed and submitted payloads\\n */\\ninterface IRewards {\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        uint256 chainId;\\n        address verifyingContract;\\n    }\\n\\n    struct Recipient {\\n        uint256 chainId;\\n        uint256 cycle;\\n        address wallet;\\n        uint256 amount;\\n    }\\n\\n    event SignerSet(address newSigner);\\n    event Claimed(uint256 cycle, address recipient, uint256 amount);\\n\\n    /// @notice Get the current payload signer;\\n    /// @return Signer address\\n    function rewardsSigner() external view returns (address);\\n\\n    /// @notice Check the amount an account has already claimed\\n    /// @param account Account to check\\n    /// @return Amount already claimed\\n    function claimedAmounts(address account) external view returns (uint256);\\n\\n    /// @notice Get the amount that is claimable based on the provided payload\\n    /// @param recipient Published rewards payload\\n    /// @return Amount claimable if the payload is signed\\n    function getClaimableAmount(Recipient calldata recipient)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @notice Change the signer used to validate payloads\\n    /// @param newSigner The new address that will be signing rewards payloads\\n    function setSigner(address newSigner) external;\\n\\n    /// @notice Claim your rewards\\n    /// @param recipient Published rewards payload\\n    /// @param v v component of the payload signature\\n    /// @param r r component of the payload signature\\n    /// @param s s component of the payload signature\\n    function claim(\\n        Recipient calldata recipient,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAllocator.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0;\\n\\n// interfaces\\nimport \\\"solmate/tokens/ERC20.sol\\\";\\n\\n// interfaces\\nimport \\\"olympus/interfaces/ITreasuryExtender.sol\\\";\\nimport \\\"olympus/interfaces/IOlympusAuthority.sol\\\";\\n\\nenum AllocatorStatus {\\n    OFFLINE,\\n    ACTIVATED,\\n    MIGRATING\\n}\\n\\nstruct AllocatorInitData {\\n    IOlympusAuthority authority;\\n    ITreasuryExtender extender;\\n    ERC20[] tokens;\\n}\\n\\n/**\\n * @title Interface for the BaseAllocator\\n * @dev\\n *  These are the standard functions that an Allocator should implement. A subset of these functions\\n *  is implemented in the `BaseAllocator`. Similar to those implemented, if for some reason the developer\\n *  decides to implement a dedicated base contract, or not at all and rather a dedicated Allocator contract\\n *  without base, imitate the functionalities implemented in it.\\n */\\ninterface IAllocator {\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deployed.\\n     */\\n    event AllocatorDeployed(address authority, address extender);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is activated.\\n     */\\n    event AllocatorActivated();\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocator is deactivated.\\n     */\\n    event AllocatorDeactivated(bool panic);\\n\\n    /**\\n     * @notice\\n     *  Emitted when the Allocators loss limit is violated.\\n     */\\n    event LossLimitViolated(\\n        uint128 lastLoss,\\n        uint128 dloss,\\n        uint256 estimatedTotalAllocated\\n    );\\n\\n    /**\\n     * @notice\\n     *  Emitted when a Migration is executed.\\n     * @dev\\n     *  After this also `AllocatorDeactivated` should follow.\\n     */\\n    event MigrationExecuted(address allocator);\\n\\n    /**\\n     * @notice\\n     *  Emitted when Ether is received by the contract.\\n     * @dev\\n     *  Only the Guardian is able to send the ether.\\n     */\\n    event EtherReceived(uint256 amount);\\n\\n    function update(uint256 id) external;\\n\\n    function deallocate(uint256[] memory amounts) external;\\n\\n    function prepareMigration() external;\\n\\n    function migrate() external;\\n\\n    function activate() external;\\n\\n    function deactivate(bool panic) external;\\n\\n    function addId(uint256 id) external;\\n\\n    function name() external view returns (string memory);\\n\\n    function ids() external view returns (uint256[] memory);\\n\\n    function tokenIds(uint256 id) external view returns (uint256);\\n\\n    function version() external view returns (string memory);\\n\\n    function status() external view returns (AllocatorStatus);\\n\\n    function tokens() external view returns (ERC20[] memory);\\n\\n    function utilityTokens() external view returns (ERC20[] memory);\\n\\n    function rewardTokens() external view returns (ERC20[] memory);\\n\\n    function amountAllocated(uint256 id) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/olympus-contracts/contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/olympus-contracts/contracts/types/OlympusAccessControlledV2.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nerror UNAUTHORIZED();\\nerror AUTHORITY_INITIALIZED();\\n\\n/// @dev Reasoning for this contract = modifiers literaly copy code\\n/// instead of pointing towards the logic to execute. Over many\\n/// functions this bloats contract size unnecessarily.\\n/// imho modifiers are a meme.\\nabstract contract OlympusAccessControlledV2 {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority authority);\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== \\\"MODIFIERS\\\" ========== */\\n\\n    modifier onlyGovernor {\\n\\t_onlyGovernor();\\n\\t_;\\n    }\\n\\n    modifier onlyGuardian {\\n\\t_onlyGuardian();\\n\\t_;\\n    }\\n\\n    modifier onlyPolicy {\\n\\t_onlyPolicy();\\n\\t_;\\n    }\\n\\n    modifier onlyVault {\\n\\t_onlyVault();\\n\\t_;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function initializeAuthority(IOlympusAuthority _newAuthority) internal {\\n        if (authority != IOlympusAuthority(address(0))) revert AUTHORITY_INITIALIZED();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external {\\n        _onlyGovernor();\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n\\n    /* ========== INTERNAL CHECKS ========== */\\n\\n    function _onlyGovernor() internal view {\\n        if (msg.sender != authority.governor()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyGuardian() internal view {\\n        if (msg.sender != authority.guardian()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyPolicy() internal view {\\n        if (msg.sender != authority.policy()) revert UNAUTHORIZED();\\n    }\\n\\n    function _onlyVault() internal view {\\n        if (msg.sender != authority.vault()) revert UNAUTHORIZED();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/olympus-contracts/contracts/interfaces/ITreasuryExtender.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.10;\\n\\nstruct AllocatorPerformance {\\n    uint128 gain;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorLimits {\\n    uint128 allocated;\\n    uint128 loss;\\n}\\n\\nstruct AllocatorHoldings {\\n    uint256 allocated;\\n}\\n\\nstruct AllocatorData {\\n    AllocatorHoldings holdings;\\n    AllocatorLimits limits;\\n    AllocatorPerformance performance;\\n}\\n\\n/**\\n * @title Interface for the TreasuryExtender\\n */\\ninterface ITreasuryExtender {\\n    /**\\n     * @notice\\n     *  Emitted when a new Deposit is registered.\\n     */\\n    event NewDepositRegistered(address allocator, address token, uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator is funded\\n     */\\n    event AllocatorFunded(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when allocated funds are withdrawn from an Allocator\\n     */\\n    event AllocatorWithdrawal(uint256 id, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when rewards are withdrawn from an Allocator\\n     */\\n    event AllocatorRewardsWithdrawal(address allocator, uint256 amount, uint256 value);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a gain\\n     */\\n    event AllocatorReportedGain(uint256 id, uint128 gain);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a loss\\n     */\\n    event AllocatorReportedLoss(uint256 id, uint128 loss);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator reports a migration\\n     */\\n    event AllocatorReportedMigration(uint256 id);\\n\\n    /**\\n     * @notice\\n     *  Emitted when an Allocator limits are modified\\n     */\\n    event AllocatorLimitsChanged(uint256 id, uint128 allocationLimit, uint128 lossLimit);\\n\\n    function registerDeposit(address newAllocator) external;\\n\\n    function setAllocatorLimits(uint256 id, AllocatorLimits memory limits) external;\\n\\n    function report(\\n        uint256 id,\\n        uint128 gain,\\n        uint128 loss\\n    ) external;\\n\\n    function requestFundsFromTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnFundsToTreasury(uint256 id, uint256 amount) external;\\n\\n    function returnRewardsToTreasury(\\n        uint256 id,\\n        address token,\\n        uint256 amount\\n    ) external;\\n\\n    function getTotalAllocatorCount() external view returns (uint256);\\n\\n    function getAllocatorByID(uint256 id) external view returns (address);\\n\\n    function getAllocatorAllocated(uint256 id) external view returns (uint256);\\n\\n    function getAllocatorLimits(uint256 id) external view returns (AllocatorLimits memory);\\n\\n    function getAllocatorPerformance(uint256 id) external view returns (AllocatorPerformance memory);\\n}\\n\"\r\n    },\r\n    \"lib/olympus-contracts/contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"olympus-contracts/=lib/olympus-contracts/contracts/\",\r\n      \"olympus/=lib/olympus-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"test-utils/=lib/test-utils/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\"\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotActivated\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_AllocatorNotOffline\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_Migrating\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BaseAllocator_NotMigrating\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"BaseAllocator_OnlyExtender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GeneralizedTokemak_ArbitraryCallFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GeneralizedTokemak_MustInitializeTotalWithdraw\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAssetIndex_\",\"type\":\"uint256\"}],\"name\":\"GeneralizedTokemak_WithdrawalNotReady\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"AllocatorActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"AllocatorDeactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"authority\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extender\",\"type\":\"address\"}],\"name\":\"AllocatorDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lastLoss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"dloss\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"estimatedTotalAllocated\",\"type\":\"uint256\"}],\"name\":\"LossLimitViolated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"allocator\",\"type\":\"address\"}],\"name\":\"MigrationExecuted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"addId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reactor\",\"type\":\"address\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"amountAllocated\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"panic\",\"type\":\"bool\"}],\"name\":\"deactivate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"deallocate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeArbitrary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extender\",\"outputs\":[{\"internalType\":\"contract ITreasuryExtender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"contract IManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mayClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextPayloadData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"cycle\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"v\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"prepareMigration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reactors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"contract IRewards\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"voting\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"staking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"manager\",\"type\":\"address\"}],\"internalType\":\"struct TokemakData\",\"name\":\"tokeData\",\"type\":\"tuple\"}],\"name\":\"setTokemakData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"contract IStaking\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"internalType\":\"enum AllocatorStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"toke\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"scheduleIndex\",\"type\":\"uint256\"}],\"name\":\"tokeAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokeDeposited\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWithdrawInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"cycle\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"v\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct PayloadData\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"updateClaimPayload\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"utilityTokens\",\"outputs\":[{\"internalType\":\"contract ERC20[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"voteSessionKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"reactorKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct UserVoteAllocationItem[]\",\"name\":\"allocations\",\"type\":\"tuple[]\"}],\"internalType\":\"struct UserVotePayload\",\"name\":\"payload\",\"type\":\"tuple\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voting\",\"outputs\":[{\"internalType\":\"contract ITokemakVoting\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GeneralizedTokemak", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}