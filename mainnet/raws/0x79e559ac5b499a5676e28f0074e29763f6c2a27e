{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/hyphen/token/TokenManager.sol\": {\r\n      \"content\": \"// $$$$$$$$\\\\        $$\\\\                                 $$\\\\      $$\\\\\\n// \\\\__$$  __|       $$ |                                $$$\\\\    $$$ |\\n//    $$ | $$$$$$\\\\  $$ |  $$\\\\  $$$$$$\\\\  $$$$$$$\\\\        $$$$\\\\  $$$$ | $$$$$$\\\\  $$$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\   $$$$$$\\\\\\n//    $$ |$$  __$$\\\\ $$ | $$  |$$  __$$\\\\ $$  __$$\\\\       $$\\\\$$\\\\$$ $$ | \\\\____$$\\\\ $$  __$$\\\\  \\\\____$$\\\\ $$  __$$\\\\ $$  __$$\\\\ $$  __$$\\\\\\n//    $$ |$$ /  $$ |$$$$$$  / $$$$$$$$ |$$ |  $$ |      $$ \\\\$$$  $$ | $$$$$$$ |$$ |  $$ | $$$$$$$ |$$ /  $$ |$$$$$$$$ |$$ |  \\\\__|\\n//    $$ |$$ |  $$ |$$  _$$<  $$   ____|$$ |  $$ |      $$ |\\\\$  /$$ |$$  __$$ |$$ |  $$ |$$  __$$ |$$ |  $$ |$$   ____|$$ |\\n//    $$ |\\\\$$$$$$  |$$ | \\\\$$\\\\ \\\\$$$$$$$\\\\ $$ |  $$ |      $$ | \\\\_/ $$ |\\\\$$$$$$$ |$$ |  $$ |\\\\$$$$$$$ |\\\\$$$$$$$ |\\\\$$$$$$$\\\\ $$ |\\n//    \\\\__| \\\\______/ \\\\__|  \\\\__| \\\\_______|\\\\__|  \\\\__|      \\\\__|     \\\\__| \\\\_______|\\\\__|  \\\\__| \\\\_______| \\\\____$$ | \\\\_______|\\\\__|\\n//                                                                                                 $$\\\\   $$ |\\n//                                                                                                 \\\\$$$$$$  |\\n//                                                                                                  \\\\______/\\n// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"../../security/Pausable.sol\\\";\\nimport \\\"../metatx/ERC2771ContextUpgradeable.sol\\\";\\nimport \\\"../interfaces/ITokenManager.sol\\\";\\n\\ncontract TokenManager is ITokenManager, ERC2771ContextUpgradeable, OwnableUpgradeable, Pausable {\\n    mapping(address => TokenInfo) public override tokensInfo;\\n\\n    // Excess State Transfer Fee Percentage\\n    mapping(address => uint256) public override excessStateTransferFeePerc;\\n\\n    event FeeChanged(address indexed tokenAddress, uint256 indexed equilibriumFee, uint256 indexed maxFee);\\n    event ExcessStateTransferFeePercChanged(address indexed tokenAddress, uint256 indexed fee);\\n\\n    modifier tokenChecks(address tokenAddress) {\\n        require(tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(tokensInfo[tokenAddress].supportedToken, \\\"Token not supported\\\");\\n\\n        _;\\n    }\\n\\n    /**\\n     * First key is toChainId and second key is token address being deposited on current chain\\n     */\\n    mapping(uint256 => mapping(address => TokenConfig)) public depositConfig;\\n\\n    /**\\n     * Store min/max amount of token to transfer based on token address\\n     */\\n    mapping(address => TokenConfig) public transferConfig;\\n\\n    function initialize(address trustedForwarder, address pauser) external initializer {\\n        __ERC2771Context_init(trustedForwarder);\\n        __Ownable_init();\\n        __Pausable_init(pauser);\\n    }\\n\\n    function getEquilibriumFee(address tokenAddress) public view override returns (uint256) {\\n        return tokensInfo[tokenAddress].equilibriumFee;\\n    }\\n\\n    function getMaxFee(address tokenAddress) public view override returns (uint256) {\\n        return tokensInfo[tokenAddress].maxFee;\\n    }\\n\\n    function changeFee(\\n        address tokenAddress,\\n        uint256 _equilibriumFee,\\n        uint256 _maxFee\\n    ) external override onlyOwner whenNotPaused {\\n        require(_equilibriumFee != 0, \\\"Equilibrium Fee cannot be 0\\\");\\n        require(_maxFee != 0, \\\"Max Fee cannot be 0\\\");\\n        require(_equilibriumFee <= _maxFee && _maxFee <= 10000000000, \\\"Max Fee cannot be greater than 100%\\\");\\n        tokensInfo[tokenAddress].equilibriumFee = _equilibriumFee;\\n        tokensInfo[tokenAddress].maxFee = _maxFee;\\n        emit FeeChanged(tokenAddress, tokensInfo[tokenAddress].equilibriumFee, tokensInfo[tokenAddress].maxFee);\\n    }\\n\\n    function changeExcessStateFee(address _tokenAddress, uint256 _excessStateFeePer)\\n        external\\n        override\\n        onlyOwner\\n        whenNotPaused\\n    {\\n        require(_tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(_excessStateFeePer != 0, \\\"Excess State Fee Percentage cannot be 0\\\");\\n        excessStateTransferFeePerc[_tokenAddress] = _excessStateFeePer;\\n        emit ExcessStateTransferFeePercChanged(_tokenAddress, _excessStateFeePer);\\n    }\\n\\n    function setTokenTransferOverhead(address tokenAddress, uint256 gasOverhead)\\n        external\\n        tokenChecks(tokenAddress)\\n        onlyOwner\\n    {\\n        tokensInfo[tokenAddress].transferOverhead = gasOverhead;\\n    }\\n\\n    /**\\n     * Set DepositConfig for the given combination of toChainId, tokenAddress.\\n     * This is used while depositing token in Liquidity Pool. Based on the destination chainid\\n     * min and max deposit amount is checked.\\n     */\\n    function setDepositConfig(\\n        uint256[] memory toChainId,\\n        address[] memory tokenAddresses,\\n        TokenConfig[] memory tokenConfig\\n    ) external onlyOwner {\\n        require(\\n            (toChainId.length == tokenAddresses.length) && (tokenAddresses.length == tokenConfig.length),\\n            \\\" ERR_ARRAY_LENGTH_MISMATCH\\\"\\n        );\\n        uint256 length = tokenConfig.length;\\n        for (uint256 index; index < length; ) {\\n            depositConfig[toChainId[index]][tokenAddresses[index]].min = tokenConfig[index].min;\\n            depositConfig[toChainId[index]][tokenAddresses[index]].max = tokenConfig[index].max;\\n            unchecked {\\n                ++index;\\n            }\\n        }\\n    }\\n\\n    function addSupportedToken(\\n        address tokenAddress,\\n        uint256 minCapLimit,\\n        uint256 maxCapLimit,\\n        uint256 equilibriumFee,\\n        uint256 maxFee,\\n        uint256 transferOverhead\\n    ) external onlyOwner {\\n        require(tokenAddress != address(0), \\\"Token address cannot be 0\\\");\\n        require(maxCapLimit > minCapLimit, \\\"maxCapLimit > minCapLimit\\\");\\n        tokensInfo[tokenAddress].supportedToken = true;\\n        transferConfig[tokenAddress].min = minCapLimit;\\n        transferConfig[tokenAddress].max = maxCapLimit;\\n        tokensInfo[tokenAddress].tokenConfig = transferConfig[tokenAddress];\\n        tokensInfo[tokenAddress].equilibriumFee = equilibriumFee;\\n        tokensInfo[tokenAddress].maxFee = maxFee;\\n        tokensInfo[tokenAddress].transferOverhead = transferOverhead;\\n    }\\n\\n    function removeSupportedToken(address tokenAddress) external tokenChecks(tokenAddress) onlyOwner {\\n        tokensInfo[tokenAddress].supportedToken = false;\\n    }\\n\\n    function updateTokenCap(\\n        address tokenAddress,\\n        uint256 minCapLimit,\\n        uint256 maxCapLimit\\n    ) external tokenChecks(tokenAddress) onlyOwner {\\n        require(maxCapLimit > minCapLimit, \\\"maxCapLimit > minCapLimit\\\");\\n        transferConfig[tokenAddress].min = minCapLimit;\\n        transferConfig[tokenAddress].max = maxCapLimit;\\n    }\\n\\n    function getTokensInfo(address tokenAddress) public view override returns (TokenInfo memory) {\\n        TokenInfo memory tokenInfo = TokenInfo(\\n            tokensInfo[tokenAddress].transferOverhead,\\n            tokensInfo[tokenAddress].supportedToken,\\n            tokensInfo[tokenAddress].equilibriumFee,\\n            tokensInfo[tokenAddress].maxFee,\\n            transferConfig[tokenAddress]\\n        );\\n        return tokenInfo;\\n    }\\n\\n    function getDepositConfig(uint256 toChainId, address tokenAddress)\\n        public\\n        view\\n        override\\n        returns (TokenConfig memory)\\n    {\\n        return depositConfig[toChainId][tokenAddress];\\n    }\\n\\n    function getTransferConfig(address tokenAddress) public view override returns (TokenConfig memory) {\\n        return transferConfig[tokenAddress];\\n    }\\n\\n    function _msgSender()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (address sender)\\n    {\\n        return ERC2771ContextUpgradeable._msgSender();\\n    }\\n\\n    function _msgData()\\n        internal\\n        view\\n        virtual\\n        override(ContextUpgradeable, ERC2771ContextUpgradeable)\\n        returns (bytes calldata)\\n    {\\n        return ERC2771ContextUpgradeable._msgData();\\n    }\\n\\n    function setTrustedForwarder(address _tf) external onlyOwner {\\n        _setTrustedForwarder(_tf);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Initializable, PausableUpgradeable {\\n    address private _pauser;\\n\\n    event PauserChanged(address indexed previousPauser, address indexed newPauser);\\n\\n    /**\\n     * @dev The pausable constructor sets the original `pauser` of the contract to the sender\\n     * account & Initializes the contract in unpaused state..\\n     */\\n    function __Pausable_init(address pauser) internal initializer {\\n        require(pauser != address(0), \\\"Pauser Address cannot be 0\\\");\\n        __Pausable_init();\\n        _pauser = pauser;\\n    }\\n\\n    /**\\n     * @return true if `msg.sender` is the owner of the contract.\\n     */\\n    function isPauser(address pauser) public view returns (bool) {\\n        return pauser == _pauser;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the pauser.\\n     */\\n    modifier onlyPauser() {\\n        require(isPauser(msg.sender), \\\"Only pauser is allowed to perform this operation\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Allows the current pauser to transfer control of the contract to a newPauser.\\n     * @param newPauser The address to transfer pauserShip to.\\n     */\\n    function changePauser(address newPauser) public onlyPauser whenNotPaused {\\n        _changePauser(newPauser);\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a newPauser.\\n     * @param newPauser The address to transfer ownership to.\\n     */\\n    function _changePauser(address newPauser) internal {\\n        require(newPauser != address(0));\\n        emit PauserChanged(_pauser, newPauser);\\n        _pauser = newPauser;\\n    }\\n\\n    function renouncePauser() external virtual onlyPauser whenNotPaused {\\n        emit PauserChanged(_pauser, address(0));\\n        _pauser = address(0);\\n    }\\n\\n    function pause() public onlyPauser {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyPauser {\\n        _unpause();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/metatx/ERC2771ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.0;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n * Here _trustedForwarder is made internal instead of private\\n * so it can be changed via Child contracts with a setter method.\\n */\\nabstract contract ERC2771ContextUpgradeable is Initializable, ContextUpgradeable {\\n    event TrustedForwarderChanged(address indexed _tf);\\n\\n    address internal _trustedForwarder;\\n\\n    function __ERC2771Context_init(address trustedForwarder) internal initializer {\\n        __Context_init_unchained();\\n        __ERC2771Context_init_unchained(trustedForwarder);\\n    }\\n\\n    function __ERC2771Context_init_unchained(address trustedForwarder) internal initializer {\\n        _trustedForwarder = trustedForwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual override returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return super._msgSender();\\n        }\\n    }\\n\\n    function _msgData() internal view virtual override returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return super._msgData();\\n        }\\n    }\\n\\n    function _setTrustedForwarder(address _tf) internal virtual {\\n        require(_tf != address(0), \\\"TrustedForwarder can't be 0\\\");\\n        _trustedForwarder = _tf;\\n        emit TrustedForwarderChanged(_tf);\\n    }\\n\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/interfaces/ITokenManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nimport \\\"../structures/TokenConfig.sol\\\";\\n\\ninterface ITokenManager {\\n    function getEquilibriumFee(address tokenAddress) external view returns (uint256);\\n\\n    function getMaxFee(address tokenAddress) external view returns (uint256);\\n\\n    function changeFee(\\n        address tokenAddress,\\n        uint256 _equilibriumFee,\\n        uint256 _maxFee\\n    ) external;\\n\\n    function tokensInfo(address tokenAddress)\\n        external\\n        view\\n        returns (\\n            uint256 transferOverhead,\\n            bool supportedToken,\\n            uint256 equilibriumFee,\\n            uint256 maxFee,\\n            TokenConfig memory config\\n        );\\n\\n    function excessStateTransferFeePerc(address tokenAddress) external view returns (uint256);\\n\\n    function getTokensInfo(address tokenAddress) external view returns (TokenInfo memory);\\n\\n    function getDepositConfig(uint256 toChainId, address tokenAddress) external view returns (TokenConfig memory);\\n\\n    function getTransferConfig(address tokenAddress) external view returns (TokenConfig memory);\\n\\n    function changeExcessStateFee(address _tokenAddress, uint256 _excessStateFeePer) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/hyphen/structures/TokenConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.0;\\n\\nstruct TokenInfo {\\n    uint256 transferOverhead;\\n    bool supportedToken;\\n    uint256 equilibriumFee; // Percentage fee Represented in basis points\\n    uint256 maxFee; // Percentage fee Represented in basis points\\n    TokenConfig tokenConfig;\\n}\\n\\nstruct TokenConfig {\\n    uint256 min;\\n    uint256 max;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"ExcessStateTransferFeePercChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"FeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPauser\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"PauserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tf\",\"type\":\"address\"}],\"name\":\"TrustedForwarderChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"}],\"name\":\"addSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_excessStateFeePer\",\"type\":\"uint256\"}],\"name\":\"changeExcessStateFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxFee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPauser\",\"type\":\"address\"}],\"name\":\"changePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"excessStateTransferFeePerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getDepositConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getEquilibriumFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getMaxFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTokensInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportedToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"internalType\":\"struct TokenInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getTransferConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pauser\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"removeSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"toChainId\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"tokenAddresses\",\"type\":\"address[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig[]\",\"name\":\"tokenConfig\",\"type\":\"tuple[]\"}],\"name\":\"setDepositConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gasOverhead\",\"type\":\"uint256\"}],\"name\":\"setTokenTransferOverhead\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tf\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokensInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"transferOverhead\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"supportedToken\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"equilibriumFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenConfig\",\"name\":\"tokenConfig\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferConfig\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minCapLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCapLimit\",\"type\":\"uint256\"}],\"name\":\"updateTokenCap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenManager", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}