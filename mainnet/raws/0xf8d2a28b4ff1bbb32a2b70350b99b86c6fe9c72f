{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.0;\r\n\r\ncontract Solomonic {\r\n    enum ContractState { AWAITING_CLAIM, CLAIMED, CONTESTED, ABORTED, DISBURSED }\r\n\r\n    ContractState public contractState;\r\n\r\n    bytes32 public hash;\r\n    uint128 public claimPeriod;\r\n    uint128 public challengePeriod;\r\n\r\n    address[] public claimants;\r\n    mapping (address => bool) claimantMap;\r\n\r\n    // in UTC seconds\r\n    uint256 public claimUntil;\r\n    uint256 public challengeUntil;\r\n\r\n    constructor(\r\n        bytes32 _hash,\r\n        uint128 _claimPeriod,\r\n        uint128 _challengePeriod\r\n    ) payable {\r\n        hash = _hash;\r\n        claimPeriod = _claimPeriod;\r\n        challengePeriod = _challengePeriod;\r\n    }\r\n\r\n    function claim(string calldata _secret) checkSecret(_secret) external {\r\n        if (contractState == ContractState.AWAITING_CLAIM) {\r\n            contractState = ContractState.CLAIMED;\r\n            claimUntil = block.timestamp + claimPeriod;\r\n            challengeUntil = claimUntil + challengePeriod;\r\n            claimants.push(tx.origin);\r\n            claimantMap[tx.origin] = true;\r\n        } else if ((contractState == ContractState.CLAIMED || contractState == ContractState.CONTESTED) && block.timestamp < claimUntil) {\r\n            require(!claimantMap[tx.origin], 'claim exists');\r\n\r\n            if (contractState == ContractState.CLAIMED) {\r\n                contractState = ContractState.CONTESTED;\r\n            }\r\n\r\n            claimants.push(tx.origin);\r\n            claimantMap[tx.origin] = true;\r\n        } else {\r\n            revert('not claimable');\r\n        }\r\n    }\r\n\r\n    function abort() requireContested requireClaimant since(claimUntil) before(challengeUntil) external {\r\n        contractState = ContractState.ABORTED;\r\n    }\r\n\r\n    function withdraw() requireWithdrawable external {\r\n        payable(tx.origin).transfer(address(this).balance);\r\n        contractState = ContractState.DISBURSED;\r\n    }\r\n\r\n    modifier before(uint256 time) {\r\n        require(block.timestamp < time, 'too late');\r\n        _;\r\n    }\r\n\r\n    modifier since(uint256 time) {\r\n        require(block.timestamp >= time, 'too early');\r\n        _;\r\n    }\r\n\r\n    modifier checkSecret(string calldata _secret) {\r\n        require(keccak256(abi.encodePacked(_secret)) == hash, 'bad secret');\r\n        _;\r\n    }\r\n\r\n    modifier requireContested {\r\n        require(contractState == ContractState.CONTESTED, 'not contested');\r\n        _;\r\n    }\r\n\r\n    modifier requireWithdrawable {\r\n        require(\r\n            contractState == ContractState.CLAIMED && block.timestamp >= claimUntil ||\r\n            contractState == ContractState.CONTESTED && block.timestamp >= challengeUntil,\r\n            'can\\'t withdraw'\r\n        );\r\n        require(\r\n            contractState == ContractState.CLAIMED && tx.origin == claimants[0] ||\r\n            contractState == ContractState.CONTESTED && tx.origin == claimants[claimants.length - 1],\r\n            'unauthorized'\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier requireClaimant {\r\n        require(claimantMap[tx.origin], 'unauthorized');\r\n        _;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"_claimPeriod\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_challengePeriod\",\"type\":\"uint128\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"abort\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengePeriod\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_secret\",\"type\":\"string\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimPeriod\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimants\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractState\",\"outputs\":[{\"internalType\":\"enum Solomonic.ContractState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Solomonic", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "25b23b59dcf176776a68019c64de893838ca9c49ec1dbc1321ebb0d7ada1d0d7000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000000003c", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://caec92d49cb8dbd0a812b1f5d1cd928beabb1207a8173dcbe4feebee6e3446bb"}]}