{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"Address.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n\\r\\nlibrary Address {\\r\\n\\r\\n    /**\\r\\n     * @dev Returns true if `account` is a contract.\\r\\n     *\\r\\n     * [IMPORTANT]\\r\\n     * ====\\r\\n     * It is unsafe to assume that an address for which this function returns\\r\\n     * false is an externally-owned account (EOA) and not a contract.\\r\\n     *\\r\\n     * Among others, `isContract` will return false for the following\\r\\n     * types of addresses:\\r\\n     *\\r\\n     *  - an externally-owned account\\r\\n     *  - a contract in construction\\r\\n     *  - an address where a contract will be created\\r\\n     *  - an address where a contract lived, but was destroyed\\r\\n     * ====\\r\\n     */\\r\\n    function isContract(address account) internal view returns (bool) {\\r\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\r\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\r\\n        // for accounts without code, i.e. `keccak256(\\u0027\\u0027)`\\r\\n        bytes32 codehash;\\r\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly { codehash := extcodehash(account) }\\r\\n        return (codehash != accountHash \\u0026\\u0026 codehash != 0x0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Replacement for Solidity\\u0027s `transfer`: sends `amount` wei to\\r\\n     * `recipient`, forwarding all available gas and reverting on errors.\\r\\n     *\\r\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\r\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\r\\n     * imposed by `transfer`, making them unable to receive funds via\\r\\n     * `transfer`. {sendValue} removes this limitation.\\r\\n     *\\r\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\r\\n     *\\r\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\r\\n     * taken to not create reentrancy vulnerabilities. Consider using\\r\\n     * {ReentrancyGuard} or the\\r\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\r\\n     */\\r\\n    function sendValue(address payable recipient, uint256 amount) internal {\\r\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\r\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\r\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs a Solidity function call using a low level `call`. A\\r\\n     * plain`call` is an unsafe replacement for a function call: use this\\r\\n     * function instead.\\r\\n     *\\r\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\r\\n     * function (like regular Solidity function calls).\\r\\n     *\\r\\n     * Returns the raw returned data. To convert to the expected return value,\\r\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `target` must be a contract.\\r\\n     * - calling `target` with `data` must not revert.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\r\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\r\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\r\\n        return _functionCallWithValue(target, data, 0, errorMessage);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\r\\n     * but also transferring `value` wei to `target`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the calling contract must have an ETH balance of at least `value`.\\r\\n     * - the called Solidity function must be `payable`.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\r\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\r\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\r\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\r\\n        return _functionCallWithValue(target, data, value, errorMessage);\\r\\n    }\\r\\n\\r\\n    function _functionCallWithValue(address target, bytes memory data, uint256 weiValue, string memory errorMessage) private returns (bytes memory) {\\r\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\r\\n\\r\\n        // solhint-disable-next-line avoid-low-level-calls\\r\\n        (bool success, bytes memory returndata) = target.call{ value: weiValue }(data);\\r\\n        if (success) {\\r\\n            return returndata;\\r\\n        } else {\\r\\n            // Look for revert reason and bubble it up if present\\r\\n            if (returndata.length \\u003e 0) {\\r\\n                // The easiest way to bubble the revert reason is using memory via assembly\\r\\n\\r\\n                // solhint-disable-next-line no-inline-assembly\\r\\n                assembly {\\r\\n                    let returndata_size := mload(returndata)\\r\\n                    revert(add(32, returndata), returndata_size)\\r\\n                }\\r\\n            } else {\\r\\n                revert(errorMessage);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n}\"},\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Implementation of the {IERC165} interface.\\r\\n *\\r\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\r\\n * for the additional interface id that will be supported. For example:\\r\\n *\\r\\n * ```solidity\\r\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\r\\n * }\\r\\n * ```\\r\\n *\\r\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\r\\n */\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\"},\"IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * Implementers can declare support of contract interfaces, which can then be\\r\\n * queried by others ({ERC165Checker}).\\r\\n *\\r\\n * For an implementation, see {ERC165}.\\r\\n */\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\"},\"IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./IERC165.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Required interface of an ERC721 compliant contract.\\r\\n */\\r\\ninterface IERC721 is IERC165 {\\r\\n    /**\\r\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\r\\n     */\\r\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\r\\n     */\\r\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the number of tokens in ``owner``\\u0027s account.\\r\\n     */\\r\\n    function balanceOf(address owner) external view returns (uint256 balance);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the owner of the `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\r\\n     * The approval is cleared when the token is transferred.\\r\\n     *\\r\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The caller must own the token or be an approved operator.\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the account approved for `tokenId` token.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\r\\n\\r\\n    /**\\r\\n     * @dev Approve or remove `operator` as an operator for the caller.\\r\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The `operator` cannot be the caller.\\r\\n     *\\r\\n     * Emits an {ApprovalForAll} event.\\r\\n     */\\r\\n    function setApprovalForAll(address operator, bool _approved) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\r\\n     *\\r\\n     * See {setApprovalForAll}\\r\\n     */\\r\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n}\"},\"IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n */\\r\\ninterface IERC721Metadata is IERC721 {\\r\\n    /**\\r\\n     * @dev Returns the token collection name.\\r\\n     */\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the token collection symbol.\\r\\n     */\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"},\"IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @title ERC721 token receiver interface\\r\\n * @dev Interface for any contract that wants to support safeTransfers\\r\\n * from ERC721 asset contracts.\\r\\n */\\r\\ninterface IERC721Receiver {\\r\\n    /**\\r\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\r\\n     * by `operator` from `from`, this function is called.\\r\\n     *\\r\\n     * It must return its Solidity selector to confirm the token transfer.\\r\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\r\\n     *\\r\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\r\\n     */\\r\\n    function onERC721Received(\\r\\n        address operator,\\r\\n        address from,\\r\\n        uint256 tokenId,\\r\\n        bytes calldata data\\r\\n    ) external returns (bytes4);\\r\\n}\\r\\n\"},\"IRNG.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n\\r\\ninterface IRNG {\\r\\n    function fetchRandom(uint256 seedOne, uint256 seedTwo) external returns (uint256);\\r\\n}\"},\"NobilityKnight.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nimport \\\"./IERC721.sol\\\";\\r\\nimport \\\"./IERC721Receiver.sol\\\";\\r\\nimport \\\"./IERC721Metadata.sol\\\";\\r\\nimport \\\"./Address.sol\\\";\\r\\nimport \\\"./Context.sol\\\";\\r\\nimport \\\"./ERC165.sol\\\";\\r\\nimport \\\"./IRNG.sol\\\";\\r\\nimport \\\"./Strings.sol\\\";\\r\\n\\r\\ncontract NobilityKnight is Context, ERC165, IERC721, IERC721Metadata {\\r\\n    using Address for address;\\r\\n    using Strings for uint256;\\r\\n\\r\\n    // Token name\\r\\n    string private _name;\\r\\n\\r\\n    // Token symbol\\r\\n    string private _symbol;\\r\\n\\r\\n    // total number of NFTs Minted\\r\\n    uint256 private _totalSupply;\\r\\n\\r\\n    // Mapping from token ID to owner address\\r\\n    mapping(uint256 =\\u003e address) private _owners;\\r\\n\\r\\n    // Mapping owner address to token count\\r\\n    mapping(address =\\u003e uint256) private _balances;\\r\\n\\r\\n    // Mapping from token ID to approved address\\r\\n    mapping(uint256 =\\u003e address) private _tokenApprovals;\\r\\n\\r\\n    // Mapping from owner to operator approvals\\r\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) private _operatorApprovals;\\r\\n\\r\\n    // name + bio of knight\\r\\n    struct KnightData {\\r\\n        string name;\\r\\n        string bio;\\r\\n    }\\r\\n\\r\\n    // knight data\\r\\n    mapping( uint256 =\\u003e KnightData ) knightData;\\r\\n\\r\\n    // token stats\\r\\n    mapping(uint256 =\\u003e uint256) idToLevel;\\r\\n\\r\\n    // maximum supply which can be minted\\r\\n    uint256 public constant maxSupply = 4444;\\r\\n\\r\\n    // nfts baseURL\\r\\n    string private baseURI = \\\"https://nftapi.nobilitytoken.com/nblknight/\\\";\\r\\n\\r\\n    // white list spots\\r\\n    uint256 public remainingWhitelist;\\r\\n    uint256 public remainingStaffMints;\\r\\n\\r\\n    // nobility white list nfts\\r\\n    address private constant whitelistOne = 0x8bA27DD2621ED0ff1fF5F3513ca7aEA81511677F;\\r\\n    address private constant whitelistTwo = 0x4F86eDcACD3B67Ab8786B030A3eEe4275c7Ca90d;\\r\\n    uint256 private constant whitelistOneCost = 3194 * 10**14;\\r\\n\\r\\n    // use wallet\\r\\n    address public useWallet = 0xcDe5525CF7971cc28759939481FEcc9E45941ff6;\\r\\n\\r\\n    // base cost to mint NFT\\r\\n    uint256 public cost = 4444 * 10**14;\\r\\n\\r\\n    // 6 month white list timeout\\r\\n    uint256 private constant whitelistTimeout = 5_200_000;\\r\\n    uint256 public immutable launchTime;\\r\\n\\r\\n    // time requirements to upgrade to level 2 or 3\\r\\n    uint256 public constant timeToUpgradeToLevel3 = 5_200_000;\\r\\n    uint256 public constant timeToUpgradeToDragon = 2_600_000;\\r\\n\\r\\n    // TokenID =\\u003e hasMinted\\r\\n    mapping ( uint256 =\\u003e bool ) public whitelistOneHasMinted;\\r\\n    mapping ( uint256 =\\u003e bool ) public whitelistTwoHasMinted;\\r\\n\\r\\n    // when the ownership of tokenIDs changes\\r\\n    mapping ( uint256 =\\u003e uint256 ) public timeOfAcquisition;\\r\\n\\r\\n    // Attacking ID -\\u003e Defending ID\\r\\n    mapping ( uint256 =\\u003e bool ) public lookingForDual;\\r\\n\\r\\n    // whether dualing is enabled or not\\r\\n    bool public dualingEnabled;\\r\\n\\r\\n    // RNG to fetch salt from\\r\\n    address private RNG;\\r\\n\\r\\n    // operator\\r\\n    address public operator;\\r\\n    modifier onlyOperator() {\\r\\n        require(msg.sender == operator, \\u0027Only Operator\\u0027);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    // has mint started\\r\\n    bool saleStarted;\\r\\n\\r\\n    // events\\r\\n    event Battle(uint256 attackerID, uint256 defenderID, uint256 winningID);\\r\\n    event SetUseWallet(address useWallet);\\r\\n\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\r\\n     */\\r\\n    constructor() {\\r\\n        // token stats\\r\\n        _name = \\u0027Noble Knights\\u0027;\\r\\n        _symbol = \\u0027NBLK\\u0027;\\r\\n\\r\\n        // split up mints between whitelist + non whitelisted\\r\\n        remainingStaffMints = 30;\\r\\n\\r\\n        // Remaining whitelist, no more will be minted that effect NobleKnights\\r\\n        remainingWhitelist = 242;\\r\\n\\r\\n        // time of launch\\r\\n        launchTime = block.number;\\r\\n\\r\\n        // operator\\r\\n        operator = msg.sender;\\r\\n    }\\r\\n\\r\\n\\r\\n    // owner functions\\r\\n\\r\\n    function transferOperator(address nOperator) external onlyOperator {\\r\\n        operator = nOperator;\\r\\n    }\\r\\n\\r\\n    function setRNG(address newRNG) external onlyOperator {\\r\\n        require(newRNG != address(0));\\r\\n        RNG = newRNG;\\r\\n    }\\r\\n\\r\\n    function setStaffMints(uint256 newStaffMints) external onlyOperator {\\r\\n        remainingStaffMints = newStaffMints;\\r\\n    }\\r\\n\\r\\n    function setWhiteListSpots(uint256 newWhiteListSpots) external onlyOperator {\\r\\n        remainingWhitelist = newWhiteListSpots;\\r\\n    }\\r\\n\\r\\n    function changeCost(uint256 newCost) external onlyOperator {\\r\\n        cost = newCost;\\r\\n    }\\r\\n\\r\\n    function startSale() external onlyOperator {\\r\\n        saleStarted = true;\\r\\n    }\\r\\n\\r\\n    function stopSale() external onlyOperator {\\r\\n        saleStarted = false;\\r\\n    }\\r\\n\\r\\n    function changeUseWallet(address newUseWallet) external onlyOperator {\\r\\n        useWallet = newUseWallet;\\r\\n        emit SetUseWallet(newUseWallet);\\r\\n    }\\r\\n\\r\\n    function enableDualing() external onlyOperator {\\r\\n        dualingEnabled = true;\\r\\n    }\\r\\n\\r\\n    function disableDualing() external onlyOperator {\\r\\n        dualingEnabled = false;\\r\\n    }\\r\\n\\r\\n    function withdraw(address recipient) external onlyOperator {\\r\\n        (bool s,) = payable(recipient).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(s);\\r\\n    }\\r\\n\\r\\n    function overrideWhitelistReservationSlots() external onlyOperator {\\r\\n        require(launchTime + whitelistTimeout \\u003c block.number, \\u0027Must Wait Until Timeout\\u0027);\\r\\n        remainingWhitelist = 0;\\r\\n    }\\r\\n\\r\\n    function staffMint(address recipient) external onlyOperator {\\r\\n        require(remainingStaffMints \\u003e 0, \\u0027Zero Staff Mints Left\\u0027);\\r\\n        // decrement staff mints\\r\\n        remainingStaffMints--;\\r\\n        // mint to recipient\\r\\n        _safeMint(recipient, _totalSupply);\\r\\n    }\\r\\n\\r\\n    function setBaseURI(string calldata uri) external onlyOperator {\\r\\n        baseURI = uri;\\r\\n    }\\r\\n\\r\\n    function _baseURI() internal view returns (string memory) {\\r\\n        return baseURI;\\r\\n    }\\r\\n\\r\\n\\r\\n    // external functions\\r\\n\\r\\n    function fetchIDSForOwner(bool _whitelistOne, address holder, uint256 whitelistTotalSupply) external view returns (uint256[] memory) {\\r\\n        uint256 count = 0;\\r\\n    \\r\\n        for (uint i = 0; i \\u003c whitelistTotalSupply; i++) {\\r\\n            if (IERC721(_whitelistOne ? whitelistOne : whitelistTwo).ownerOf(i) == holder) {\\r\\n                if (_whitelistOne \\u0026\\u0026 !whitelistOneHasMinted[i]) {\\r\\n                    count++;\\r\\n                } else if (!_whitelistOne \\u0026\\u0026 !whitelistTwoHasMinted[i]) {\\r\\n                    count++;\\r\\n                }                \\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256[] memory ids = new uint256[](count);\\r\\n        uint256 j;\\r\\n\\r\\n        if (count == 0) return ids;\\r\\n\\r\\n        for (uint i = 0; i \\u003c whitelistTotalSupply; i++) {\\r\\n            if (IERC721(_whitelistOne ? whitelistOne : whitelistTwo).ownerOf(i) == holder) {\\r\\n                if (_whitelistOne \\u0026\\u0026 !whitelistOneHasMinted[i]) {\\r\\n                    ids[j] = i;\\r\\n                    j++;\\r\\n                } else if (!_whitelistOne \\u0026\\u0026 !whitelistTwoHasMinted[i]) {\\r\\n                    ids[j] = i;\\r\\n                    j++;\\r\\n                }\\r\\n                \\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ids;\\r\\n    }\\r\\n\\r\\n    function burn(uint256 tokenID) external {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenID), \\\"caller not owner nor approved\\\");\\r\\n        _burn(tokenID);\\r\\n    }\\r\\n\\r\\n    function upgradeToLevel3(uint256 tokenID) external {\\r\\n        require(ownerOf(tokenID) == msg.sender, \\u0027Not Owner\\u0027);\\r\\n        require(idToLevel[tokenID] == 1,        \\u0027Must Be Level 2\\u0027);\\r\\n        require(timeOfAcquisition[tokenID] + timeToUpgradeToLevel3 \\u003c= block.number, \\u0027Hold Time Not Met\\u0027);\\r\\n\\r\\n        // reset token hold timer\\r\\n        timeOfAcquisition[tokenID] = block.number;\\r\\n\\r\\n        // upgrade token ID\\r\\n        _upgrade(tokenID);\\r\\n    }\\r\\n\\r\\n    function setLookingForDual(uint256 tokenID, bool canDual) external {\\r\\n        require(dualingEnabled,                 \\u0027Duals disabled\\u0027);\\r\\n        require(_levelOne(tokenID),             \\u0027Only LV One\\u0027);\\r\\n        require(ownerOf(tokenID) == msg.sender, \\u0027Not Owner\\u0027);\\r\\n\\r\\n        lookingForDual[tokenID] = canDual;\\r\\n    }\\r\\n\\r\\n    function battleKnight(uint256 attackingID, uint256 targetID) external {\\r\\n        require(dualingEnabled,                     \\u0027Duals disabled\\u0027);\\r\\n        require(ownerOf(attackingID) == msg.sender, \\u0027Not Owner\\u0027);\\r\\n        require(_exists(targetID),                  \\u0027Target Has No Owner\\u0027);\\r\\n        require(_levelOne(attackingID),             \\u0027Only LV One\\u0027);\\r\\n        require(_levelOne(targetID),                \\u0027Only LV One\\u0027);\\r\\n        require(lookingForDual[targetID],           \\u0027Target Not Looking To Dual\\u0027);\\r\\n\\r\\n        _battle(attackingID, targetID);\\r\\n    }\\r\\n\\r\\n    function battleOwnedKnights(uint256 attackingID, uint256 defendingID) external {\\r\\n        require(dualingEnabled,                     \\u0027Duals disabled\\u0027);\\r\\n        require(ownerOf(attackingID) == msg.sender, \\u0027Not Owner of Attacker\\u0027);\\r\\n        require(ownerOf(defendingID) == msg.sender, \\u0027Not Owner of Defender\\u0027);\\r\\n        require(_levelOne(attackingID),             \\u0027Only LV One\\u0027);\\r\\n        require(_levelOne(defendingID),             \\u0027Only LV One\\u0027);\\r\\n\\r\\n        _battle(attackingID, defendingID);\\r\\n    }\\r\\n\\r\\n    function _levelOne(uint256 tokenID) internal view returns (bool) {\\r\\n        return idToLevel[tokenID] == 0;\\r\\n    }\\r\\n\\r\\n    function setName(string calldata name_, uint256 tokenID) external {\\r\\n        require(ownerOf(tokenID) == msg.sender, \\u0027Invalid Owner\\u0027);\\r\\n        knightData[tokenID].name = name_;\\r\\n    }\\r\\n\\r\\n    function setBio(string calldata bio, uint256 tokenID) external {\\r\\n        require(ownerOf(tokenID) == msg.sender, \\u0027Invalid Owner\\u0027);\\r\\n        knightData[tokenID].bio = bio;\\r\\n    }\\r\\n    \\r\\n\\r\\n    // Minting Functions\\r\\n    //   Whitelist, Staff, and Regular\\r\\n    \\r\\n    function whitelistMint(bool whiteListContractOne, uint256 tokenID) external payable {\\r\\n        require(saleStarted, \\u0027Sale Not Started\\u0027);\\r\\n        require(remainingWhitelist \\u003e 0, \\u0027Zero Slots Left\\u0027);\\r\\n\\r\\n        if (whiteListContractOne) {\\r\\n            require(IERC721(whitelistOne).ownerOf(tokenID) == msg.sender, \\u0027Not Owner\\u0027);\\r\\n            require(!whitelistOneHasMinted[tokenID], \\u0027Whitelist Slot Already Used\\u0027);\\r\\n            require(msg.value \\u003e= whitelistOneCost, \\u0027Invalid ETH Sent\\u0027);\\r\\n\\r\\n            whitelistOneHasMinted[tokenID] = true;\\r\\n        } else {\\r\\n            require(IERC721(whitelistTwo).ownerOf(tokenID) == msg.sender, \\u0027Not Owner\\u0027);\\r\\n            require(!whitelistTwoHasMinted[tokenID], \\u0027Whitelist Slot Already Used\\u0027);\\r\\n            require(msg.value \\u003e= cost, \\u0027Invalid ETH Sent\\u0027);\\r\\n            whitelistTwoHasMinted[tokenID] = true;\\r\\n        }\\r\\n\\r\\n        // decrement remaining white list spots\\r\\n        remainingWhitelist--;\\r\\n\\r\\n        // mint to sender\\r\\n        _safeMint(msg.sender, _totalSupply);\\r\\n    }\\r\\n\\r\\n    /** \\r\\n     * Mints New NFT To Caller\\r\\n     */\\r\\n    function mint(uint256 nMints) external payable {\\r\\n        require(saleStarted, \\u0027Sale Not Started\\u0027);\\r\\n        require(nMints \\u003e 0 \\u0026\\u0026 nMints \\u003c= 10, \\u002710 Knights Max In One Mint\\u0027);\\r\\n        require(_totalSupply + remainingStaffMints + remainingWhitelist \\u003c maxSupply, \\u0027Max NFTs Minted\\u0027);\\r\\n        require(msg.value \\u003e= cost * nMints, \\u0027Invalid ETH Sent\\u0027);\\r\\n\\r\\n        for (uint i = 0; i \\u003c nMints; i++) {\\r\\n            _safeMint(msg.sender, _totalSupply);\\r\\n        }\\r\\n\\r\\n        (bool s,) = payable(useWallet).call{value: address(this).balance}(\\\"\\\");\\r\\n        require(s, \\u0027Failure On ETH Payment\\u0027);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n\\r\\n\\r\\n\\r\\n    // internal functions\\r\\n\\r\\n    function _battle(uint256 attackingID, uint256 defendingID) internal {\\r\\n\\r\\n        // calculate rng\\r\\n        uint256 rng = IRNG(RNG).fetchRandom(uint256(uint160(ownerOf(attackingID))), uint256(uint160(ownerOf(defendingID)))) % 2;\\r\\n        // remove dual\\r\\n        delete lookingForDual[attackingID];\\r\\n        delete lookingForDual[defendingID];\\r\\n\\r\\n        // upgrade winner\\r\\n        _upgrade( rng == 0 ? attackingID : defendingID);\\r\\n        // burn loser\\r\\n        _burn(    rng == 0 ? defendingID : attackingID);\\r\\n\\r\\n        // emit event\\r\\n        emit Battle(attackingID, defendingID, rng == 0 ? attackingID : defendingID);\\r\\n    }\\r\\n\\r\\n    function _upgrade(uint256 tokenId) internal {\\r\\n        require(idToLevel[tokenId] \\u003c 2, \\u0027Max Knight Level\\u0027);\\r\\n        idToLevel[tokenId]++;\\r\\n    }\\r\\n\\r\\n    \\r\\n    // read functions\\r\\n\\r\\n    function timeLeftUntilUpgrade(uint256 tokenID) external view returns (uint256) {\\r\\n        if (idToLevel[tokenID] == 0 || ownerOf(tokenID) == address(0)) return 0;\\r\\n        if (idToLevel[tokenID] == 1) {\\r\\n            return block.number \\u003e timeOfAcquisition[tokenID] + timeToUpgradeToLevel3 ? 0 :  \\r\\n                    timeOfAcquisition[tokenID] + timeToUpgradeToLevel3 - block.number;\\r\\n        } else {\\r\\n            return block.number \\u003e timeOfAcquisition[tokenID] + timeToUpgradeToDragon ? 0 :  \\r\\n                    timeOfAcquisition[tokenID] + timeToUpgradeToDragon - block.number;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function totalSupply() external view returns (uint256) {\\r\\n        return _totalSupply;\\r\\n    }\\r\\n\\r\\n    function soldOut() external view returns (bool) {\\r\\n        return _totalSupply == maxSupply;\\r\\n    }\\r\\n\\r\\n    function getIDsByOwner(address owner) external view returns (uint256[] memory) {\\r\\n        uint256[] memory ids = new uint256[](balanceOf(owner));\\r\\n        if (balanceOf(owner) == 0) return ids;\\r\\n        uint256 count = 0;\\r\\n        for (uint i = 0; i \\u003c _totalSupply; i++) {\\r\\n            if (ownerOf(i) == owner) {\\r\\n                ids[count] = i;\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n        return ids;\\r\\n    }\\r\\n\\r\\n    function fetchIDSLookingToDual() external view returns (uint256[] memory) {\\r\\n        uint256 count = 0;\\r\\n        for (uint i = 0; i \\u003c _totalSupply; i++) {\\r\\n            if (lookingForDual[i]) {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256[] memory ids = new uint256[](count);\\r\\n        uint256 j;\\r\\n\\r\\n        for (uint i = 0; i \\u003c _totalSupply; i++) {\\r\\n            if (lookingForDual[i]) {\\r\\n                ids[j] = i;\\r\\n                j++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ids;\\r\\n    }\\r\\n\\r\\n    function fetchIDSLookingToDualInIDRange(uint256 lowerBound, uint256 upperBound) external view returns (uint256[] memory) {\\r\\n        uint256 count = 0;\\r\\n        for (uint i = lowerBound; i \\u003c upperBound; i++) {\\r\\n            if (lookingForDual[i]) {\\r\\n                count++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256[] memory ids = new uint256[](count);\\r\\n        uint256 j;\\r\\n\\r\\n        for (uint i = lowerBound; i \\u003c upperBound; i++) {\\r\\n            if (lookingForDual[i]) {\\r\\n                ids[j] = i;\\r\\n                j++;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return ids;\\r\\n    }\\r\\n\\r\\n    function getLevel(uint256 tokenId) external view returns (uint256) {\\r\\n        return idToLevel[tokenId]+1;\\r\\n    }\\r\\n\\r\\n    function canUpgradeToDragon(uint256 tokenID) external view returns (bool) {\\r\\n        return \\r\\n            idToLevel[tokenID] == 2 \\u0026\\u0026\\r\\n            ownerOf(tokenID) != address(0) \\u0026\\u0026\\r\\n            timeOfAcquisition[tokenID] + timeToUpgradeToDragon \\u003c= block.number;\\r\\n    }\\r\\n\\r\\n    function getName(uint256 tokenID) external view returns (string memory) {\\r\\n        return knightData[tokenID].name;\\r\\n    }\\r\\n\\r\\n    function getBio(uint256 tokenID) external view returns (string memory) {\\r\\n        return knightData[tokenID].bio;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view override(ERC165, IERC165) returns (bool) {\\r\\n        return\\r\\n            interfaceId == type(IERC721).interfaceId ||\\r\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\r\\n            super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-balanceOf}.\\r\\n     */\\r\\n    function balanceOf(address wpowner) public view override returns (uint256) {\\r\\n        require(wpowner != address(0), \\\"query for the zero address\\\");\\r\\n        return _balances[wpowner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-ownerOf}.\\r\\n     */\\r\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\r\\n        address wpowner = _owners[tokenId];\\r\\n        require(wpowner != address(0), \\\"query for nonexistent token\\\");\\r\\n        return wpowner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-name}.\\r\\n     */\\r\\n    function name() public view override returns (string memory) {\\r\\n        return _name;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-symbol}.\\r\\n     */\\r\\n    function symbol() public view override returns (string memory) {\\r\\n        return _symbol;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721Metadata-tokenURI}.\\r\\n     */\\r\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\r\\n        require(_exists(tokenId), \\\"nonexistent token\\\");\\r\\n\\r\\n        string memory _base = _baseURI();\\r\\n        return string(abi.encodePacked(_base, tokenId.toString()));\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-approve}.\\r\\n     */\\r\\n    function approve(address to, uint256 tokenId) public override {\\r\\n        address wpowner = ownerOf(tokenId);\\r\\n        require(to != wpowner, \\\"ERC721: approval to current owner\\\");\\r\\n\\r\\n        require(\\r\\n            _msgSender() == wpowner || isApprovedForAll(wpowner, _msgSender()),\\r\\n            \\\"ERC721: not approved or owner\\\"\\r\\n        );\\r\\n\\r\\n        _approve(to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-getApproved}.\\r\\n     */\\r\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\r\\n        require(_exists(tokenId), \\\"ERC721: query for nonexistent token\\\");\\r\\n\\r\\n        return _tokenApprovals[tokenId];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-setApprovalForAll}.\\r\\n     */\\r\\n    function setApprovalForAll(address _operator, bool approved) public override {\\r\\n        _setApprovalForAll(_msgSender(), _operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-isApprovedForAll}.\\r\\n     */\\r\\n    function isApprovedForAll(address wpowner, address _operator) public view override returns (bool) {\\r\\n        return _operatorApprovals[wpowner][_operator];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Destroys `tokenId`.\\r\\n     * The approval is cleared when the token is burned.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _burn(uint256 tokenId) internal {\\r\\n        require(_exists(tokenId), \\u0027Token Does Not Exist\\u0027);\\r\\n\\r\\n        // owner of token\\r\\n        address owner = ownerOf(tokenId);\\r\\n\\r\\n        // Clear approvals\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        delete timeOfAcquisition[tokenId];\\r\\n        delete knightData[tokenId];\\r\\n        delete lookingForDual[tokenId];\\r\\n\\r\\n        // decrement balance\\r\\n        _balances[owner] -= 1;\\r\\n        delete _owners[tokenId];\\r\\n\\r\\n        // emit transfer\\r\\n        emit Transfer(owner, address(0), tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-transferFrom}.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public override {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"caller not owner nor approved\\\");\\r\\n        _transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) public override {\\r\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC721-safeTransferFrom}.\\r\\n     */\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) public override {\\r\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"caller not owner nor approved\\\");\\r\\n        _safeTransfer(from, to, tokenId, _data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\r\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\r\\n     *\\r\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\r\\n     *\\r\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\r\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `from` cannot be the zero address.\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must exist and be owned by `from`.\\r\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _safeTransfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) internal {\\r\\n        _transfer(from, to, tokenId);\\r\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: non ERC721Receiver implementer\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `tokenId` exists.\\r\\n     *\\r\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\r\\n     *\\r\\n     * Tokens start existing when they are minted (`_mint`),\\r\\n     * and stop existing when they are burned (`_burn`).\\r\\n     */\\r\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\r\\n        return _owners[tokenId] != address(0);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must exist.\\r\\n     */\\r\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\r\\n        require(_exists(tokenId), \\\"ERC721: nonexistent token\\\");\\r\\n        address wpowner = ownerOf(tokenId);\\r\\n        return (spender == wpowner || getApproved(tokenId) == spender || isApprovedForAll(wpowner, spender));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\r\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\r\\n     */\\r\\n    function _safeMint(\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal {\\r\\n        _mint(to, tokenId);\\r\\n        require(\\r\\n            _checkOnERC721Received(address(0), to, tokenId, \\\"\\\"),\\r\\n            \\\"ERC721: non ERC721Receiver implementer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Mints `tokenId` and transfers it to `to`.\\r\\n     *\\r\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `tokenId` must not exist.\\r\\n     * - `to` cannot be the zero address.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _mint(address to, uint256 tokenId) internal {\\r\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\r\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\r\\n        require(_totalSupply \\u003c maxSupply, \\u0027Max NFTs Minted\\u0027);\\r\\n\\r\\n        _balances[to] += 1;\\r\\n        _owners[tokenId] = to;\\r\\n        _totalSupply++;\\r\\n        timeOfAcquisition[tokenId] = block.number;\\r\\n\\r\\n        emit Transfer(address(0), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers `tokenId` from `from` to `to`.\\r\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - `to` cannot be the zero address.\\r\\n     * - `tokenId` token must be owned by `from`.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function _transfer(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) internal {\\r\\n        require(ownerOf(tokenId) == from, \\\"Incorrect owner\\\");\\r\\n        require(to != address(0), \\\"zero address\\\");\\r\\n        require(balanceOf(from) \\u003e 0, \\u0027Zero Balance\\u0027);\\r\\n\\r\\n        // Clear approvals from the previous owner\\r\\n        _approve(address(0), tokenId);\\r\\n\\r\\n        // reset name + bio\\r\\n        delete knightData[tokenId];\\r\\n        delete lookingForDual[tokenId];\\r\\n\\r\\n        // Allocate balances\\r\\n        _balances[from] -= 1;\\r\\n        _balances[to] += 1;\\r\\n        _owners[tokenId] = to;\\r\\n        timeOfAcquisition[tokenId] = block.number;\\r\\n\\r\\n        emit Transfer(from, to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `to` to operate on `tokenId`\\r\\n     *\\r\\n     * Emits a {Approval} event.\\r\\n     */\\r\\n    function _approve(address to, uint256 tokenId) internal {\\r\\n        _tokenApprovals[tokenId] = to;\\r\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\r\\n     *\\r\\n     * Emits a {ApprovalForAll} event.\\r\\n     */\\r\\n    function _setApprovalForAll(\\r\\n        address wpowner,\\r\\n        address _operator,\\r\\n        bool approved\\r\\n    ) internal {\\r\\n        require(wpowner != _operator, \\\"ERC721: approve to caller\\\");\\r\\n        _operatorApprovals[wpowner][_operator] = approved;\\r\\n        emit ApprovalForAll(wpowner, _operator, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\r\\n     * The call is not executed if the target address is not a contract.\\r\\n     *\\r\\n     * @param from address representing the previous owner of the given token ID\\r\\n     * @param to target address that will receive the tokens\\r\\n     * @param tokenId uint256 ID of the token to be transferred\\r\\n     * @param _data bytes optional data to send along with the call\\r\\n     * @return bool whether the call correctly returned the expected magic value\\r\\n     */\\r\\n    function _checkOnERC721Received(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) private returns (bool) {\\r\\n        if (to.isContract()) {\\r\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\r\\n                return retval == IERC721Receiver.onERC721Received.selector;\\r\\n            } catch (bytes memory reason) {\\r\\n                if (reason.length == 0) {\\r\\n                    revert(\\\"ERC721: non ERC721Receiver implementer\\\");\\r\\n                } else {\\r\\n                    assembly {\\r\\n                        revert(add(32, reason), mload(reason))\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n        } else {\\r\\n            return true;\\r\\n        }\\r\\n    }\\r\\n}\"},\"SafeMath.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.4;\\r\\n\\r\\nlibrary SafeMath {\\r\\n    /**\\r\\n     * @dev Returns the addition of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `+` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Addition cannot overflow.\\r\\n     */\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c \\u003e= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return sub(a, b, \\\"SafeMath: subtraction overflow\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\r\\n     * overflow (when the result is negative).\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `-` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Subtraction cannot overflow.\\r\\n     */\\r\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003c= a, errorMessage);\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\r\\n     * overflow.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `*` operator.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - Multiplication cannot overflow.\\r\\n     */\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        // Gas optimization: this is cheaper than requiring \\u0027a\\u0027 not being zero, but the\\r\\n        // benefit is lost if \\u0027b\\u0027 is also tested.\\r\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\\r\\n     * division by zero. The result is rounded towards zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `/` operator. Note: this function uses a\\r\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\r\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b \\u003e 0, errorMessage);\\r\\n        uint256 c = a / b;\\r\\n        // assert(a == b * c + a % b); // There is no case in which this doesn\\u0027t hold\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\r\\n     * Reverts with custom message when dividing by zero.\\r\\n     *\\r\\n     * Counterpart to Solidity\\u0027s `%` operator. This function uses a `revert`\\r\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\r\\n     * invalid opcode to revert (consuming all remaining gas).\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - The divisor cannot be zero.\\r\\n     */\\r\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\r\\n        require(b != 0, errorMessage);\\r\\n        return a % b;\\r\\n    }\\r\\n}\"},\"Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\r\\n\\r\\npragma solidity 0.8.4;\\r\\n\\r\\n/**\\r\\n * @dev String operations.\\r\\n */\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI\\u0027s implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp \\u003e\\u003e= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i \\u003e 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value \\u0026 0xf];\\r\\n            value \\u003e\\u003e= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n}\\r\\n\"}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"attackerID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"defenderID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningID\",\"type\":\"uint256\"}],\"name\":\"Battle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"useWallet\",\"type\":\"address\"}],\"name\":\"SetUseWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attackingID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetID\",\"type\":\"uint256\"}],\"name\":\"battleKnight\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"attackingID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defendingID\",\"type\":\"uint256\"}],\"name\":\"battleOwnedKnights\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"canUpgradeToDragon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newCost\",\"type\":\"uint256\"}],\"name\":\"changeCost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUseWallet\",\"type\":\"address\"}],\"name\":\"changeUseWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableDualing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dualingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableDualing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_whitelistOne\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"holder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"whitelistTotalSupply\",\"type\":\"uint256\"}],\"name\":\"fetchIDSForOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchIDSLookingToDual\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lowerBound\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"upperBound\",\"type\":\"uint256\"}],\"name\":\"fetchIDSLookingToDualInIDRange\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getBio\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getIDsByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wpowner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"launchTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lookingForDual\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nMints\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"overrideWhitelistReservationSlots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingStaffMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingWhitelist\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"bio\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setBio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"canDual\",\"type\":\"bool\"}],\"name\":\"setLookingForDual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRNG\",\"type\":\"address\"}],\"name\":\"setRNG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newStaffMints\",\"type\":\"uint256\"}],\"name\":\"setStaffMints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newWhiteListSpots\",\"type\":\"uint256\"}],\"name\":\"setWhiteListSpots\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"soldOut\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"staffMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"timeLeftUntilUpgrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"timeOfAcquisition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToUpgradeToDragon\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeToUpgradeToLevel3\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nOperator\",\"type\":\"address\"}],\"name\":\"transferOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"upgradeToLevel3\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"useWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"whiteListContractOne\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenID\",\"type\":\"uint256\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistOneHasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whitelistTwoHasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "NobilityKnight", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ac537982cb703da70aa8869edcfba1627a72dd9465ce453f9b727d03c62eef64"}]}