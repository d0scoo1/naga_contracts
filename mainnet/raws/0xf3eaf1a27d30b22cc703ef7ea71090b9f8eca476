{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.7.6;\r\n\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle trees (hash trees),\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(\r\n        bytes32[] memory proof,\r\n        bytes32 root,\r\n        bytes32 leaf\r\n    ) internal pure returns (bool) {\r\n        bytes32 computedHash = leaf;\r\n\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            bytes32 proofElement = proof[i];\r\n\r\n            if (computedHash <= proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(computedHash, proofElement)\r\n                );\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(\r\n                    abi.encodePacked(proofElement, computedHash)\r\n                );\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == root;\r\n    }\r\n}\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    function renounceOwnership() external virtual onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external virtual onlyOwner {\r\n        require(\r\n            newOwner != address(0),\r\n            \"Ownable: new owner is the zero address\"\r\n        );\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PT_Airdrop is Ownable {\r\n    uint256 internal constant ONE = 10**18;\r\n\r\n    using Strings for uint256;\r\n\r\n    address public platformToken;\r\n\r\n    mapping(address => bool) public claimed;\r\n\r\n    bytes32 merkleRoot =\r\n        0x3430b672b1f51479da9176524ddd0a41d13512128907c6d5321748299c23ed1f;\r\n\r\n    constructor(address _platformToken) {\r\n        platformToken = _platformToken;\r\n    }\r\n\r\n    function setPlatformToken(address _platformToken) external onlyOwner {\r\n        platformToken = _platformToken;\r\n    }\r\n\r\n    function setMerkleRoot(bytes32 _merkleRoot) external onlyOwner {\r\n        merkleRoot = _merkleRoot;\r\n    }\r\n\r\n    function verifyClaim(\r\n        address _account,\r\n        uint256 _vestedAmount,\r\n        uint256 _nonVestedAmount,\r\n        bytes32[] calldata _merkleProof\r\n    ) public view returns (bool) {\r\n        bytes32 node = keccak256(\r\n            abi.encodePacked(_vestedAmount, _account, _nonVestedAmount)\r\n        );\r\n        return MerkleProof.verify(_merkleProof, merkleRoot, node);\r\n    }\r\n\r\n    function showElements(\r\n        address _account,\r\n        uint256 _vestedAmount,\r\n        uint256 _nonVestedAmount\r\n    ) public pure returns (bytes memory) {\r\n        return abi.encodePacked(_vestedAmount, _account, _nonVestedAmount);\r\n    }\r\n\r\n    address[] internal vestedAddresses;\r\n\r\n    function claim(\r\n        uint256 _vestedAmount,\r\n        uint256 _nonVestedAmount,\r\n        bytes32[] calldata _merkleProof\r\n    ) external {\r\n        require(!claimed[_msgSender()], \"claimed\");\r\n        require(\r\n            verifyClaim(\r\n                _msgSender(),\r\n                _vestedAmount,\r\n                _nonVestedAmount,\r\n                _merkleProof\r\n            ),\r\n            \"not eligible for a claim\"\r\n        );\r\n        claimed[_msgSender()] = true;\r\n        PlatformToken(platformToken).autoAirdrop(\r\n            _msgSender(),\r\n            _nonVestedAmount\r\n        );\r\n\r\n        vestedAddresses.push(_msgSender());\r\n        PlatformToken(platformToken).distributeVest(\r\n            vestedAddresses,\r\n            _vestedAmount\r\n        );\r\n        delete vestedAddresses;\r\n    }\r\n}\r\n\r\ninterface PlatformToken {\r\n    function autoAirdrop(address _to, uint256 _amount) external;\r\n\r\n    function distributeVest(address[] calldata vestedAddresses, uint256 amount)\r\n        external;\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonVestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_platformToken\",\"type\":\"address\"}],\"name\":\"setPlatformToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonVestedAmount\",\"type\":\"uint256\"}],\"name\":\"showElements\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_vestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonVestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"_merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PT_Airdrop", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "00000000000000000000000033a6b5ac6df354b98189b5bef7d57653fb7e265b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8bb8b4a7bf586ff1d4d8eddc0573a3d546174be742775b73c620e707c837e3a5"}]}