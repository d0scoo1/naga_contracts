{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/Controller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n// extends\\r\\nimport \\\"./interfaces/IController.sol\\\";\\r\\nimport \\\"./shared/SpoolOwnable.sol\\\";\\r\\nimport \\\"./shared/Constants.sol\\\";\\r\\n\\r\\n// libraries\\r\\nimport \\\"./external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\\\";\\r\\nimport \\\"./libraries/Hash.sol\\\";\\r\\n\\r\\n// other imports\\r\\nimport \\\"./interfaces/ISpool.sol\\\";\\r\\nimport \\\"./interfaces/IRiskProviderRegistry.sol\\\";\\r\\nimport \\\"./interfaces/IBaseStrategy.sol\\\";\\r\\nimport \\\"./interfaces/IVault.sol\\\";\\r\\nimport \\\"./interfaces/vault/IVaultDetails.sol\\\";\\r\\nimport \\\"./vault/VaultNonUpgradableProxy.sol\\\";\\r\\nimport \\\"./external/@openzeppelin/security/Pausable.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice Implementation of the {IController} interface.\\r\\n *\\r\\n * @dev\\r\\n * This implementation joins the various contracts of the Spool\\r\\n * system together to allow the creation of new vaults in the system\\r\\n * as well as allow the Spool to validate that its incoming requests\\r\\n * are indeed from a vault in the system.\\r\\n *\\r\\n * The contract can be thought of as the central point of contract\\r\\n * for assessing the validity of data in the system (i.e. supported strategy, vault etc.).\\r\\n */\\r\\ncontract Controller is IController, SpoolOwnable, BaseConstants, Pausable {\\r\\n    using SafeERC20 for IERC20;\\r\\n\\r\\n    /* ========== CONSTANTS ========== */\\r\\n\\r\\n    /// @notice Maximum vault creator fee - 20%\\r\\n    uint256 public constant MAX_VAULT_CREATOR_FEE = 20_00;\\r\\n\\r\\n    /// @notice Maximum vault creator fee if the creator is the Spool DAO - 60%\\r\\n    uint256 public constant MAX_DAO_VAULT_CREATOR_FEE = 60_00;\\r\\n\\r\\n    /// @notice Maximum number of vault strategies\\r\\n    uint256 public constant MAX_VAULT_STRATEGIES = 18;\\r\\n\\r\\n    /// @notice Minimum vault risk tolerance\\r\\n    int8 public constant MIN_RISK_TOLERANCE = -10;\\r\\n\\r\\n    /// @notice Maximum vault risk tolerance\\r\\n    int8 public constant MAX_RISK_TOLERANCE = 10;\\r\\n\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice The central Spool contract\\r\\n    ISpool public immutable spool;\\r\\n    \\r\\n    /// @notice The risk provider registry\\r\\n    IRiskProviderRegistry public immutable riskRegistry;\\r\\n\\r\\n    /// @notice vault implementation address\\r\\n    address public immutable vaultImplementation;\\r\\n\\r\\n    /// @notice The list of strategies supported by the system\\r\\n    address[] public override strategies;\\r\\n\\r\\n    /// @notice Hash of strategies list\\r\\n    bytes32 public strategiesHash;\\r\\n\\r\\n    /// @notice The total vaults created in the system\\r\\n    uint256 public totalVaults;\\r\\n    \\r\\n    /// @notice Recipient address of emergency withdrawn funds\\r\\n    address public emergencyRecipient;\\r\\n\\r\\n    /// @notice Whether the specified token is supported as an underlying token for a vault\\r\\n    mapping(IERC20 => bool) public override supportedUnderlying;\\r\\n\\r\\n    /// @notice Whether the particular vault address is valid\\r\\n    mapping(address => bool) public override validVault;\\r\\n\\r\\n    /// @notice Whether the particular strategy address is valid\\r\\n    mapping(address => bool) public override validStrategy;\\r\\n\\r\\n    /// @notice Whether the address is the emergency withdrawer\\r\\n    mapping(address => bool) public isEmergencyWithdrawer;\\r\\n\\r\\n    /// @notice Whether the address is the pauser\\r\\n    mapping(address => bool) public isPauser;\\r\\n\\r\\n    /// @notice Whether the address is the unpauser\\r\\n    mapping(address => bool) public isUnpauser;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the contract initial values.\\r\\n     *\\r\\n     * @dev It performms certain pre-conditional validations to ensure the contract\\r\\n     * has been initialized properly, such as that both addresses are valid.\\r\\n     *\\r\\n     * Ownership of the contract beyond deployment should be transferred to\\r\\n     * the Spool DAO to avoid centralization of control.\\r\\n     * \\r\\n     * @param _spoolOwner the spool owner contract that owns this contract\\r\\n     * @param _riskRegistry the risk provider registry contract\\r\\n     * @param _spool the spool contract\\r\\n     * @param _vaultImplementation vault implementation contract address\\r\\n     */\\r\\n    constructor(\\r\\n        ISpoolOwner _spoolOwner,\\r\\n        IRiskProviderRegistry _riskRegistry,\\r\\n        ISpool _spool,\\r\\n        address _vaultImplementation\\r\\n    ) \\r\\n        SpoolOwnable(_spoolOwner)\\r\\n    {\\r\\n        require(\\r\\n            _riskRegistry != IRiskProviderRegistry(address(0)) &&\\r\\n            _spool != ISpool(address(0)) &&\\r\\n            _vaultImplementation != address(0),\\r\\n            \\\"Controller::constructor: Risk Provider, Spool or Vault Implementation addresses cannot be 0\\\"\\r\\n        );\\r\\n\\r\\n        riskRegistry = _riskRegistry;\\r\\n        spool = _spool;\\r\\n        vaultImplementation = _vaultImplementation;\\r\\n\\r\\n        _updateStrategiesHash(strategies);\\r\\n    }\\r\\n\\r\\n    /* ========== VIEWS ========== */\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if controller is paused.\\r\\n     */\\r\\n    function checkPaused() external view whenNotPaused {}\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all strategy contract addresses.\\r\\n     *\\r\\n     * @return array of strategy addresses\\r\\n     */\\r\\n    function getAllStrategies()\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (address[] memory)\\r\\n    {\\r\\n        return strategies;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the amount of strategies registered\\r\\n     *\\r\\n     * @return strategies count\\r\\n     */\\r\\n    function getStrategiesCount() external override view returns(uint8) {\\r\\n        return uint8(strategies.length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice hash strategies list, verify hash matches to storage hash.\\r\\n     *\\r\\n     * @dev\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - hash of input matches hash in storage\\r\\n     *\\r\\n     * @param _strategies list of strategies to check\\r\\n     */\\r\\n    function verifyStrategies(address[] calldata _strategies) external override view {\\r\\n        require(Hash.sameStrategies(_strategies, strategiesHash), \\\"Controller::verifyStrategies: Incorrect strategies\\\");\\r\\n    }\\r\\n\\r\\n    /* ========== MUTATIVE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n    * @notice Stops the controller.\\r\\n     */\\r\\n    function pause() onlyPauser external {\\r\\n        _pause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Resumes the controller.\\r\\n     */\\r\\n    function unpause() onlyUnpauser external {\\r\\n        _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the creation of a new vault.\\r\\n     *\\r\\n     * @dev\\r\\n     * The vault creator is immediately set as the allocation provider as well as\\r\\n     * reward token setter. These traits are all transferrable and should be transferred\\r\\n     * to another person beyond creation.\\r\\n     *\\r\\n     * Emits a {VaultCreated} event indicating the address of the vault. Parameters cannot\\r\\n     * be emitted due to reaching the stack limit and should instead be fetched from the\\r\\n     * vault directly.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the underlying currency must be supported by the system\\r\\n     * - the strategies and proportions must be equal in length\\r\\n     * - the sum of the strategy proportions must be 100%\\r\\n     * - the strategies must all be supported by the system\\r\\n     * - the strategies must be unique\\r\\n     * - the underlying asset of the strategies must match the desired one\\r\\n     * - the fee of the vault owner must not exceed 20% in basis points,\\r\\n     *   or 60% if creator is the Spool DAO\\r\\n     * - the risk provider must exist in the risk provider registry\\r\\n     * - the risk tolerance of the vault must be within the [-10, 10] range\\r\\n     *\\r\\n     * @param details details of the vault to be created (see VaultDetails)\\r\\n     *\\r\\n     * @return vault address of the newly created vault \\r\\n     */\\r\\n    function createVault(\\r\\n        VaultDetails calldata details\\r\\n    ) external returns (address vault) {\\r\\n        require(\\r\\n            details.creator != address(0),\\r\\n            \\\"Controller::createVault: Missing vault creator\\\"\\r\\n        );\\r\\n        require(\\r\\n            supportedUnderlying[IERC20(details.underlying)],\\r\\n            \\\"Controller::createVault: Unsupported currency\\\"\\r\\n        );\\r\\n        require(\\r\\n            details.strategies.length > 0 && details.strategies.length <= MAX_VAULT_STRATEGIES,\\r\\n            \\\"Controller::createVault: Invalid number of strategies\\\"\\r\\n        );\\r\\n        require(\\r\\n            details.strategies.length == details.proportions.length,\\r\\n            \\\"Controller::createVault: Improper setup\\\"\\r\\n        );\\r\\n\\r\\n        uint256 total;\\r\\n        for (uint256 i = 0; i < details.strategies.length; i++) {\\r\\n            // check if all strategies are unique\\r\\n            for (uint256 j = i+1; j < details.strategies.length; j++) {\\r\\n                require(details.strategies[i] != details.strategies[j], \\\"Controller::createVault: Strategies not unique\\\");\\r\\n            }\\r\\n\\r\\n            require(\\r\\n                validStrategy[details.strategies[i]],\\r\\n                \\\"Controller::createVault: Unsupported strategy\\\"\\r\\n            );\\r\\n            IBaseStrategy strategy = IBaseStrategy(details.strategies[i]);\\r\\n\\r\\n            require(\\r\\n                strategy.underlying() == IERC20(details.underlying),\\r\\n                \\\"Controller::createVault: Incorrect currency for strategy\\\"\\r\\n            );\\r\\n\\r\\n            total += details.proportions[i];\\r\\n        }\\r\\n\\r\\n        require(\\r\\n            total == FULL_PERCENT,\\r\\n            \\\"Controller::createVault: Improper allocations\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            details.vaultFee <= MAX_VAULT_CREATOR_FEE ||\\r\\n            // Spool DAO can set higher vault owner fee\\r\\n            (details.vaultFee <= MAX_DAO_VAULT_CREATOR_FEE && isSpoolOwner()),\\r\\n            \\\"Controller::createVault: High owner fee\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            riskRegistry.isProvider(details.riskProvider),\\r\\n            \\\"Controller::createVault: Invalid risk provider\\\"\\r\\n        );\\r\\n\\r\\n        require(\\r\\n            details.riskTolerance >= MIN_RISK_TOLERANCE &&\\r\\n            details.riskTolerance <= MAX_RISK_TOLERANCE,\\r\\n            \\\"Controller::createVault: Incorrect Risk Tolerance\\\"\\r\\n        );\\r\\n\\r\\n        vault = _createVault(details);\\r\\n\\r\\n        validVault[vault] = true;\\r\\n        totalVaults++;\\r\\n\\r\\n        _emitVaultCreated(vault, details);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Emit event with vault details on creation\\r\\n     * @param vault Vault address\\r\\n     * @param details Vault details\\r\\n     */\\r\\n    function _emitVaultCreated(address vault, VaultDetails calldata details) private {\\r\\n        emit VaultCreated(\\r\\n            vault,\\r\\n            details.underlying,\\r\\n            details.strategies,\\r\\n            details.proportions,\\r\\n            details.vaultFee,\\r\\n            details.riskProvider,\\r\\n            details.riskTolerance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows the creation of a new vault.\\r\\n     *\\r\\n     * @dev\\r\\n     * Creates an instance of the Vault proxy contract and returns the address to the Controller.\\r\\n     *\\r\\n     * @param vaultDetails details of the vault to be created (see VaultDetails)\\r\\n     * @return vault Address of newly created vault \\r\\n     */\\r\\n    function _createVault(\\r\\n        VaultDetails calldata vaultDetails\\r\\n    ) private returns (address vault) {\\r\\n        vault = address(\\r\\n            new VaultNonUpgradableProxy(\\r\\n                vaultImplementation,\\r\\n                _getVaultImmutables(vaultDetails)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        IVault(vault).initialize(_getVaultInitializable(vaultDetails));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return new vault immutable values\\r\\n     *\\r\\n     * @param vaultDetails details of the vault to be created\\r\\n     * @return Vault immutable values\\r\\n     */\\r\\n    function _getVaultImmutables(VaultDetails calldata vaultDetails) private pure returns (VaultImmutables memory) {\\r\\n        return VaultImmutables(\\r\\n            IERC20(vaultDetails.underlying),\\r\\n            vaultDetails.riskProvider,\\r\\n            vaultDetails.riskTolerance\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return new vault initializable values\\r\\n     *\\r\\n     * @param vaultDetails details of the vault to be created\\r\\n     * @return New vault initializable values\\r\\n     */\\r\\n    function _getVaultInitializable(VaultDetails calldata vaultDetails) private pure returns (VaultInitializable memory) {\\r\\n        return VaultInitializable(\\r\\n            vaultDetails.name,\\r\\n            vaultDetails.creator,\\r\\n            vaultDetails.vaultFee,\\r\\n            vaultDetails.strategies,\\r\\n            vaultDetails.proportions\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a user to claim their reward drip rewards across multiple vaults\\r\\n     * in a single transaction.\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have rewards in all the vaults specified\\r\\n     * - the vaults must be valid vaults in the Spool system\\r\\n     *\\r\\n     * @param vaults vaults for which to claim rewards for\\r\\n     */\\r\\n    function getRewards(IVault[] calldata vaults) external {\\r\\n        IVault vault;\\r\\n        for (uint256 i = 0; i < vaults.length; i++) {\\r\\n            vault = vaults[i];\\r\\n            if (!validVault[address(vault)]) {\\r\\n                emit VaultInvalid(address(vault));\\r\\n                continue;\\r\\n            }\\r\\n            vaults[i].getActiveRewards(msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* ========== RESTRICTED FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice transfer vault underlying tokens to the Spool contact, from a user.\\r\\n     *\\r\\n     * @dev\\r\\n     * Users of multiple vaults can choose to set allowance for the underlying token to this contract only, and then \\r\\n     * interact with any vault without having to set allowance to each vault induvidually.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be a vault\\r\\n     * - user (transferFrom address) must have given enough allowance to this contract \\r\\n     * - user (transferFrom address) must have enough tokens to transfer\\r\\n     *\\r\\n     * @param transferFrom address to transfer the tokens from (user address from vault)\\r\\n     * @param amount amount of underlying tokens to transfer to the Spool\\r\\n     */\\r\\n    function transferToSpool(address transferFrom, uint256 amount) external override onlyVault {\\r\\n        IVault(msg.sender).underlying().safeTransferFrom(transferFrom, address(spool), amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows a new strategy to be added to the Spool system.\\r\\n     *\\r\\n     * @dev\\r\\n     * Emits a {StrategyAdded} event indicating the newly added strategy\\r\\n     * and whether it is multi-collateral.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the contract owner (Spool DAO)\\r\\n     * - the provided strategies must either be all valid or an empty array\\r\\n     * - the strategy must not have already been added\\r\\n     * \\r\\n     * @param strategy the strategy to add to the system\\r\\n     * @param allStrategies All valid strategies in the system\\r\\n     */\\r\\n    function addStrategy(\\r\\n        address strategy,\\r\\n        address[] memory allStrategies\\r\\n    )\\r\\n        external\\r\\n        onlyOwner\\r\\n        validStrategiesOrEmpty(allStrategies)\\r\\n    {\\r\\n        require(\\r\\n            !validStrategy[strategy],\\r\\n            \\\"Controller::addStrategy: Strategy already registered\\\"\\r\\n        );\\r\\n\\r\\n        validStrategy[strategy] = true;\\r\\n\\r\\n        IERC20 underlying = IBaseStrategy(strategy).underlying();\\r\\n        supportedUnderlying[underlying] = true;\\r\\n\\r\\n        spool.addStrategy(strategy);\\r\\n\\r\\n        strategies.push(strategy);\\r\\n\\r\\n        // update strategies hash\\r\\n        // update can happen using stored strategies or provided ones\\r\\n        if (allStrategies.length == 0) {\\r\\n            _updateStrategiesHash(strategies);\\r\\n        } else {\\r\\n            allStrategies = _addStrategy(allStrategies, strategy);\\r\\n            _updateStrategiesHash(allStrategies);\\r\\n        }\\r\\n\\r\\n        emit StrategyAdded(strategy);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a strategy\\r\\n     * @param currentStrategies Array of current strategies\\r\\n     * @param strategy Address of the strategy to add\\r\\n     * @return Array with the given strategy added\\r\\n     */\\r\\n    function _addStrategy(address[] memory currentStrategies, address strategy) private pure returns(address[] memory) {\\r\\n        address[] memory newStrategies = new address[](currentStrategies.length + 1);\\r\\n        for(uint256 i = 0; i < currentStrategies.length; i++) {\\r\\n            newStrategies[i] = currentStrategies[i];\\r\\n        }\\r\\n\\r\\n        newStrategies[newStrategies.length - 1] = strategy;\\r\\n\\r\\n        return newStrategies;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows an existing strategy to be removed from the Spool system,\\r\\n     * withdrawing and liquidating any actively deployed funds in the strategy.\\r\\n     *\\r\\n     * @dev\\r\\n     * Withdrawn funds are sent to the `emergencyRecipient` address. If the address is 0\\r\\n     * Funds will be sent to the caller of this function. \\r\\n     *\\r\\n     * Emits a {StrategyRemoved} event indicating the removed strategy.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the emergency withdrawer\\r\\n     * - the strategy must already exist in the contract\\r\\n     * - the provided strategies array must be vaild or empty\\r\\n     *\\r\\n     * @param strategy the strategy to remove from the system\\r\\n     * @param skipDisable flag to skip execution of strategy specific disable (e.g cleanup tasks) function.\\r\\n     * @param data strategy specific data required to withdraw the funds from the strategy \\r\\n     * @param allStrategies current valid strategies or empty array\\r\\n     */\\r\\n    function removeStrategyAndWithdraw(\\r\\n        address strategy,\\r\\n        bool skipDisable,\\r\\n        uint256[] calldata data,\\r\\n        address[] calldata allStrategies\\r\\n    )\\r\\n        external\\r\\n        onlyEmergencyWithdrawer\\r\\n    {\\r\\n        _removeStrategy(strategy, skipDisable, allStrategies);\\r\\n        _emergencyWithdraw(strategy, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows an existing strategy to be removed from the Spool system.\\r\\n     *\\r\\n     * @dev\\r\\n     *\\r\\n     * Emits a {StrategyRemoved} event indicating the removed strategy.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the emergency withdrawer\\r\\n     * - the strategy must already exist in the contract\\r\\n     * - the provided strategies array must be vaild or empty\\r\\n     *\\r\\n     * @param strategy the strategy to remove from the system\\r\\n     * @param skipDisable flag to skip execution of strategy specific disable (e.g cleanup tasks) function.\\r\\n     * @param allStrategies current valid strategies or empty array\\r\\n     */\\r\\n    function removeStrategy(\\r\\n        address strategy,\\r\\n        bool skipDisable,\\r\\n        address[] calldata allStrategies\\r\\n    )\\r\\n        external\\r\\n        onlyEmergencyWithdrawer\\r\\n    {\\r\\n        _removeStrategy(strategy, skipDisable, allStrategies);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Withdraws and liquidates any actively deployed funds from already removed strategy.\\r\\n     *\\r\\n     * @dev\\r\\n     * Withdrawn funds are sent to the `emergencyRecipient` address. If the address is 0\\r\\n     * Funds will be sent to the caller of this function. \\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the emergency withdrawer\\r\\n     * - the strategy must already be removed\\r\\n     *\\r\\n     * @param strategy the strategy to remove from the system\\r\\n     * @param data strategy specific data required to withdraw the funds from the strategy \\r\\n     */\\r\\n    function emergencyWithdraw(\\r\\n        address strategy,\\r\\n        uint256[] calldata data\\r\\n    ) \\r\\n        external\\r\\n        onlyEmergencyWithdrawer\\r\\n    {\\r\\n        require(\\r\\n            !validStrategy[strategy],\\r\\n            \\\"VaultRegistry::removeStrategy: Strategy should not be valid\\\"\\r\\n        );\\r\\n\\r\\n        _emergencyWithdraw(strategy, data);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Allows an existing strategy to be removed from the Spool system.\\r\\n     *\\r\\n     * @dev\\r\\n     *\\r\\n     * Emits a {StrategyRemoved} event indicating the removed strategy.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the strategy must already exist in the contract\\r\\n     * - the provided strategies array must be vaild or empty\\r\\n     *\\r\\n     * @param strategy the strategy to remove from the system\\r\\n     * @param skipDisable flag to skip execution of strategy specific disable (e.g cleanup tasks) function.\\r\\n     * @param allStrategies current valid strategies or empty array\\r\\n     */\\r\\n    function _removeStrategy(\\r\\n        address strategy,\\r\\n        bool skipDisable,\\r\\n        address[] calldata allStrategies\\r\\n    )\\r\\n        private\\r\\n        validStrategiesOrEmpty(allStrategies)\\r\\n    {\\r\\n        require(\\r\\n            validStrategy[strategy],\\r\\n            \\\"Controller::removeStrategy: Strategy is not registered\\\"\\r\\n        );\\r\\n\\r\\n        spool.disableStrategy(strategy, skipDisable);\\r\\n\\r\\n        validStrategy[strategy] = false;\\r\\n\\r\\n        // update strategies storage array and hash\\r\\n        // update can happen using strategies from storage or from calldata\\r\\n        if (allStrategies.length == 0) {\\r\\n            _removeStrategyStorage(strategy);\\r\\n        } else {\\r\\n            _removeStrategyCalldata(allStrategies, strategy);\\r\\n        }\\r\\n\\r\\n        emit StrategyRemoved(strategy);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Remove strategy from storage array and update the strategies hash\\r\\n     *\\r\\n     * @param strategy strategy address to remove\\r\\n     */\\r\\n    function _removeStrategyStorage(address strategy) private {\\r\\n        uint256 lastEntry = strategies.length - 1;\\r\\n        for (uint256 i = 0; i < lastEntry; i++) {\\r\\n            if (strategies[i] == strategy) {\\r\\n                strategies[i] = strategies[lastEntry];\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        strategies.pop();\\r\\n\\r\\n        _updateStrategiesHash(strategies);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Remove strategy from storage array using calldata array and update the strategies hash\\r\\n     * @dev Should significantly lower the cost of removing a strategy\\r\\n     *\\r\\n     * @param allStrategies current valid strategies stored in calldata\\r\\n     * @param strategy strategy address to remove\\r\\n     */\\r\\n    function _removeStrategyCalldata(address[] calldata allStrategies, address strategy) private {\\r\\n        uint256 lastEntry = allStrategies.length - 1;\\r\\n        address[] memory newStrategies = allStrategies[0:lastEntry];\\r\\n\\r\\n        for (uint256 i = 0; i < lastEntry; i++) {\\r\\n            if (allStrategies[i] == strategy) {\\r\\n                strategies[i] = allStrategies[lastEntry];\\r\\n                newStrategies[i] = allStrategies[lastEntry];\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        strategies.pop();\\r\\n\\r\\n        _updateStrategiesHash(newStrategies);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Liquidating all actively deployed funds within a strategy after it was disabled.\\r\\n     *\\r\\n     * @param strategy strategy to withdraw from\\r\\n     * @param data data to perform the withdrawal\\r\\n     */\\r\\n    function _emergencyWithdraw(\\r\\n        address strategy,\\r\\n        uint256[] calldata data\\r\\n    )\\r\\n        private\\r\\n    {\\r\\n        spool.emergencyWithdraw(\\r\\n            strategy,\\r\\n            _getEmergencyRecipient(),\\r\\n            data\\r\\n        );\\r\\n\\r\\n        emit EmergencyWithdrawStrategy(strategy);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns address to send the emergency whithdrawn funds\\r\\n     * @dev if the address is not defined assets are sent to the caller address\\r\\n     * @param _emergencyRecipient Emergency recipient address\\r\\n     */\\r\\n    function _getEmergencyRecipient() private view returns(address _emergencyRecipient) {\\r\\n        _emergencyRecipient = emergencyRecipient;\\r\\n\\r\\n        if (_emergencyRecipient == address(0)) {\\r\\n            _emergencyRecipient = msg.sender;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Execute strategy disable function after it was removed.\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the emergency withdrawer\\r\\n     *\\r\\n     * @param strategy strategy to execute disable\\r\\n     */\\r\\n    function runDisableStrategy(address strategy)\\r\\n        external\\r\\n        onlyEmergencyWithdrawer\\r\\n    {\\r\\n        require(\\r\\n            !validStrategy[strategy],\\r\\n            \\\"Controller::runDisableStrategy: Strategy is still valid\\\"\\r\\n        );\\r\\n\\r\\n        spool.runDisableStrategy(strategy);\\r\\n        emit DisableStrategy(strategy);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add or remove the emergency withdrawer right\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the contract owner (Spool DAO)\\r\\n     * @param user Address for which to set the role\\r\\n     * @param _isEmergencyWithdrawer Flag to set the role to\\r\\n     */\\r\\n    function setEmergencyWithdrawer(address user, bool _isEmergencyWithdrawer) external onlyOwner {\\r\\n        isEmergencyWithdrawer[user] = _isEmergencyWithdrawer;\\r\\n        emit EmergencyWithdrawerUpdated(user, _isEmergencyWithdrawer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Add or remove the pauser role\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the contract owner (Spool DAO)\\r\\n     * @param user Address for which to set the role\\r\\n     * @param _set Flag to set the role to\\r\\n     */\\r\\n    function setPauser(address user, bool _set) external onlyOwner {\\r\\n        isPauser[user] = _set;\\r\\n        emit PauserUpdated(user, _set);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add or remove the unpauser role\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the contract owner (Spool DAO)\\r\\n     * @param user Address for which to set the role\\r\\n     * @param _set Flag to set the role to\\r\\n     */\\r\\n    function setUnpauser(address user, bool _set) external onlyOwner {\\r\\n        isUnpauser[user] = _set;\\r\\n        emit UnpauserUpdated(user, _set);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the emergency withdraw recipient\\r\\n     *\\r\\n     * @dev\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be the contract owner (Spool DAO)\\r\\n     * @param _emergencyRecipient Flag to set the role to\\r\\n     */\\r\\n    function setEmergencyRecipient(address _emergencyRecipient) external onlyOwner {\\r\\n        emergencyRecipient = _emergencyRecipient;\\r\\n        emit EmergencyRecipientUpdated(_emergencyRecipient);\\r\\n    }\\r\\n\\r\\n    /* ========== PRIVATE FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Following strategies change, update the strategies hash in storage.\\r\\n     *\\r\\n     * @param _strategies addresses of all valid strategies\\r\\n     */\\r\\n    function _updateStrategiesHash(address[] memory _strategies) private {\\r\\n        strategiesHash = Hash.hashStrategies(_strategies);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Verify caller is a valid vault contact\\r\\n     *\\r\\n     * @dev\\r\\n     * Only callable from onlyVault modifier.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - msg.sender is contained in validVault address mapping\\r\\n     */\\r\\n    function _onlyVault() private view {\\r\\n        require(\\r\\n            validVault[msg.sender],\\r\\n            \\\"Controller::_onlyVault: Can only be invoked by vault\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures that the caller is the emergency withdrawer\\r\\n     */\\r\\n    function _onlyEmergencyWithdrawer() private view {\\r\\n        require(\\r\\n            isEmergencyWithdrawer[msg.sender] || isSpoolOwner(),\\r\\n            \\\"Controller::_onlyEmergencyWithdrawer: Can only be invoked by the emergency withdrawer\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures the provided strategies are correct\\r\\n     * @dev Allow if array of strategies is empty\\r\\n     * @param _strategies Array of strategies to verify\\r\\n     */\\r\\n    function _validStrategiesOrEmpty(address[] memory _strategies) private view {\\r\\n        require(\\r\\n            _strategies.length == 0 ||\\r\\n            Hash.sameStrategies(_strategies, strategiesHash),\\r\\n            \\\"Controller::_validStrategiesOrEmpty: Strategies do not match\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n    * @notice Ensures that the caller is the pauser\\r\\n     */\\r\\n    function _onlyPauser() private view {\\r\\n        require(\\r\\n            isPauser[msg.sender] || isSpoolOwner(),\\r\\n            \\\"Controller::_onlyPauser: Can only be invoked by pauser\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Ensures that the caller is the unpauser\\r\\n     */\\r\\n    function _onlyUnpauser() private view {\\r\\n        require(\\r\\n            isUnpauser[msg.sender] || isSpoolOwner(),\\r\\n            \\\"Controller::_onlyUnpauser: Can only be invoked by unpauser\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /* ========== MODIFIERS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if called by a non-valid vault\\r\\n     */\\r\\n    modifier onlyVault() {\\r\\n        _onlyVault();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if the caller is not emergency withdraw\\r\\n     */\\r\\n    modifier onlyEmergencyWithdrawer() {\\r\\n        _onlyEmergencyWithdrawer();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if the strategies are not valid or empty array\\r\\n     * @param allStrategies Array of strategies\\r\\n     */\\r\\n    modifier validStrategiesOrEmpty(address[] memory allStrategies) {\\r\\n        _validStrategiesOrEmpty(allStrategies);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if the calling user is not pauser\\r\\n     */\\r\\n    modifier onlyPauser() {\\r\\n        _onlyPauser();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Throws if the calling user is not unpauser\\r\\n     */\\r\\n    modifier onlyUnpauser() {\\r\\n        _onlyUnpauser();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/proxy/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/Proxy.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\\n * be specified by overriding the virtual {_implementation} function.\\n *\\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\\n * different contract through the {_delegate} function.\\n *\\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\\n */\\nabstract contract Proxy {\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this inline assembly\\n            // block because it will not return to Solidity code. We overwrite the\\n            // Solidity scratch pad at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\\n     * and {_fallback} should delegate.\\n     */\\n    function _implementation() internal view virtual returns (address);\\n\\n    /**\\n     * @dev Delegates the current call to the address returned by `_implementation()`.\\n     *\\n     * This function does not return to its internall call site, it will return directly to the external caller.\\n     */\\n    function _fallback() internal virtual {\\n        _beforeFallback();\\n        _delegate(_implementation());\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\\n     * function in the contract matches the call data.\\n     */\\n    fallback() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\\n     * is empty.\\n     */\\n    receive() external payable virtual {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\\n     * call, or as part of the Solidity `fallback` or `receive` functions.\\n     *\\n     * If overriden should call `super._beforeFallback()`.\\n     */\\n    function _beforeFallback() internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBaseStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\nimport \\\"./ISwapData.sol\\\";\\n\\ninterface IBaseStrategy {\\n    function underlying() external view returns (IERC20);\\n\\n    function getStrategyBalance() external view returns (uint128);\\n\\n    function getStrategyUnderlyingWithRewards() external view returns(uint128);\\n\\n    function process(uint256[] calldata, bool, SwapData[] calldata) external;\\n\\n    function processReallocation(uint256[] calldata, ProcessReallocationData calldata) external returns(uint128);\\n\\n    function processDeposit(uint256[] calldata) external;\\n\\n    function fastWithdraw(uint128, uint256[] calldata, SwapData[] calldata) external returns(uint128);\\n\\n    function claimRewards(SwapData[] calldata) external;\\n\\n    function emergencyWithdraw(address recipient, uint256[] calldata data) external;\\n\\n    function initialize() external;\\n\\n    function disable() external;\\n}\\n\\nstruct ProcessReallocationData {\\n    uint128 sharesToWithdraw;\\n    uint128 optimizedShares;\\n    uint128 optimizedWithdrawnAmount;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IController {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function strategies(uint256 i) external view returns (address);\\n\\n    function validStrategy(address strategy) external view returns (bool);\\n\\n    function validVault(address vault) external view returns (bool);\\n\\n    function getStrategiesCount() external view returns(uint8);\\n\\n    function supportedUnderlying(IERC20 underlying)\\n        external\\n        view\\n        returns (bool);\\n\\n    function getAllStrategies() external view returns (address[] memory);\\n\\n    function verifyStrategies(address[] calldata _strategies) external view;\\n\\n    function transferToSpool(\\n        address transferFrom,\\n        uint256 amount\\n    ) external;\\n\\n    function checkPaused() external view;\\n\\n    /* ========== EVENTS ========== */\\n\\n    event EmergencyWithdrawStrategy(address indexed strategy);\\n    event EmergencyRecipientUpdated(address indexed recipient);\\n    event EmergencyWithdrawerUpdated(address indexed withdrawer, bool set);\\n    event PauserUpdated(address indexed user, bool set);\\n    event UnpauserUpdated(address indexed user, bool set);\\n    event VaultCreated(address indexed vault, address underlying, address[] strategies, uint256[] proportions,\\n        uint16 vaultFee, address riskProvider, int8 riskTolerance);\\n    event StrategyAdded(address strategy);\\n    event StrategyRemoved(address strategy);\\n    event VaultInvalid(address vault);\\n    event DisableStrategy(address strategy);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRiskProviderRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRiskProviderRegistry {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function isProvider(address provider) external view returns (bool);\\n\\n    function getRisk(address riskProvider, address strategy) external view returns (uint8);\\n\\n    function getRisks(address riskProvider, address[] memory strategies) external view returns (uint8[] memory);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event RiskAssessed(address indexed provider, address indexed strategy, uint8 riskScore);\\n    event ProviderAdded(address provider);\\n    event ProviderRemoved(address provider);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./spool/ISpoolExternal.sol\\\";\\nimport \\\"./spool/ISpoolReallocation.sol\\\";\\nimport \\\"./spool/ISpoolDoHardWork.sol\\\";\\nimport \\\"./spool/ISpoolStrategy.sol\\\";\\nimport \\\"./spool/ISpoolBase.sol\\\";\\n\\n/// @notice Utility Interface for central Spool implementation\\ninterface ISpool is ISpoolExternal, ISpoolReallocation, ISpoolDoHardWork, ISpoolStrategy, ISpoolBase {}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISpoolOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\ninterface ISpoolOwner {\\r\\n    function isSpoolOwner(address user) external view returns(bool);\\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/ISwapData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @notice Strict holding information how to swap the asset\\r\\n * @member slippage minumum output amount\\r\\n * @member path swap path, first byte represents an action (e.g. Uniswap V2 custom swap), rest is swap specific path\\r\\n */\\r\\nstruct SwapData {\\r\\n    uint256 slippage; // min amount out\\r\\n    bytes path; // 1st byte is action, then path \\r\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./vault/IVaultRestricted.sol\\\";\\nimport \\\"./vault/IVaultIndexActions.sol\\\";\\nimport \\\"./vault/IRewardDrip.sol\\\";\\nimport \\\"./vault/IVaultBase.sol\\\";\\nimport \\\"./vault/IVaultImmutable.sol\\\";\\n\\ninterface IVault is IVaultRestricted, IVaultIndexActions, IRewardDrip, IVaultBase, IVaultImmutable {}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolBase {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getCompletedGlobalIndex() external view returns(uint24);\\n\\n    function getActiveGlobalIndex() external view returns(uint24);\\n\\n    function isMidReallocation() external view returns (bool);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event ReallocationTableUpdated(\\n        uint24 indexed index,\\n        bytes32 reallocationTableHash\\n    );\\n\\n    event ReallocationTableUpdatedWithTable(\\n        uint24 indexed index,\\n        bytes32 reallocationTableHash,\\n        uint256[][] reallocationTable\\n    );\\n    \\n    event DoHardWorkCompleted(uint24 indexed index);\\n\\n    event SetAllocationProvider(address actor, bool isAllocationProvider);\\n    event SetIsDoHardWorker(address actor, bool isDoHardWorker);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolDoHardWork.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\ninterface ISpoolDoHardWork {\\r\\n    /* ========== EVENTS ========== */\\r\\n\\r\\n    event DoHardWorkStrategyCompleted(address indexed strat, uint256 indexed index);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../ISwapData.sol\\\";\\n\\ninterface ISpoolExternal {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function deposit(address strategy, uint128 amount, uint256 index) external;\\n\\n    function withdraw(address strategy, uint256 vaultProportion, uint256 index) external;\\n\\n    function fastWithdrawStrat(address strat, address underlying, uint256 shares, uint256[] calldata slippages, SwapData[] calldata swapData) external returns(uint128);\\n\\n    function redeem(address strat, uint256 index) external returns (uint128, uint128);\\n\\n    function redeemUnderlying(uint128 amount) external;\\n\\n    function redeemReallocation(address[] calldata vaultStrategies, uint256 depositProportions, uint256 index) external;\\n\\n    function removeShares(address[] calldata vaultStrategies, uint256 vaultProportion) external returns(uint128[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolReallocation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolReallocation {\\n    event StartReallocation(uint24 indexed index);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/spool/ISpoolStrategy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface ISpoolStrategy {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getUnderlying(address strat) external returns (uint128);\\n    \\n    function getVaultTotalUnderlyingAtIndex(address strat, uint256 index) external view returns(uint128);\\n\\n    function addStrategy(address strat) external;\\n\\n    function disableStrategy(address strategy, bool skipDisable) external;\\n\\n    function runDisableStrategy(address strategy) external;\\n\\n    function emergencyWithdraw(\\n        address strat,\\n        address withdrawRecipient,\\n        uint256[] calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IRewardDrip.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\ninterface IRewardDrip {\\n    /* ========== STRUCTS ========== */\\n\\n    // The reward configuration struct, containing all the necessary data of a typical Synthetix StakingReward contract\\n    struct RewardConfiguration {\\n        uint32 rewardsDuration;\\n        uint32 periodFinish;\\n        uint192 rewardRate; // rewards per second multiplied by accuracy\\n        uint32 lastUpdateTime;\\n        uint224 rewardPerTokenStored;\\n        mapping(address => uint256) userRewardPerTokenPaid;\\n        mapping(address => uint256) rewards;\\n    }\\n\\n    /* ========== FUNCTIONS ========== */\\n\\n    function getActiveRewards(address account) external;\\n    function tokenBlacklist(IERC20 token) view external returns(bool);\\n\\n    /* ========== EVENTS ========== */\\n    \\n    event RewardPaid(IERC20 token, address indexed user, uint256 reward);\\n    event RewardAdded(IERC20 indexed token, uint256 amount, uint256 duration);\\n    event RewardExtended(IERC20 indexed token, uint256 amount, uint256 leftover, uint256 duration, uint32 periodFinish);\\n    event RewardRemoved(IERC20 indexed token);\\n    event PeriodFinishUpdated(IERC20 indexed token, uint32 periodFinish);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"./IVaultDetails.sol\\\";\\n\\ninterface IVaultBase {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function initialize(VaultInitializable calldata vaultInitializable) external;\\n\\n    /* ========== STRUCTS ========== */\\n\\n    struct User {\\n        uint128 instantDeposit; // used for calculating rewards\\n        uint128 activeDeposit; // users deposit after deposit process and claim\\n        uint128 owed; // users owed underlying amount after withdraw has been processed and claimed\\n        uint128 withdrawnDeposits; // users withdrawn deposit, used to calculate performance fees\\n        uint128 shares; // users shares after deposit process and claim\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Claimed(address indexed member, uint256 claimAmount);\\n    event Deposit(address indexed member, uint256 indexed index, uint256 amount);\\n    event Withdraw(address indexed member, uint256 indexed index, uint256 shares);\\n    event WithdrawFast(address indexed member, uint256 shares);\\n    event StrategyRemoved(uint256 i, address strategy);\\n    event TransferVaultOwner(address owner);\\n    event LowerVaultFee(uint16 fee);\\n    event UpdateName(string name);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultDetails.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nstruct VaultDetails {\\n    address underlying;\\n    address[] strategies;\\n    uint256[] proportions;\\n    address creator;\\n    uint16 vaultFee;\\n    address riskProvider;\\n    int8 riskTolerance;\\n    string name;\\n}\\n\\nstruct VaultInitializable {\\n    string name;\\n    address owner;\\n    uint16 fee;\\n    address[] strategies;\\n    uint256[] proportions;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultImmutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\nimport \\\"../../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\n\\nstruct VaultImmutables {\\n    IERC20 underlying;\\n    address riskProvider;\\n    int8 riskTolerance;\\n}\\n\\ninterface IVaultImmutable {\\n    /* ========== FUNCTIONS ========== */\\n\\n    function underlying() external view returns (IERC20);\\n\\n    function riskProvider() external view returns (address);\\n\\n    function riskTolerance() external view returns (int8);\\n}\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultIndexActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface IVaultIndexActions {\\n\\n    /* ========== STRUCTS ========== */\\n\\n    struct IndexAction {\\n        uint128 depositAmount;\\n        uint128 withdrawShares;\\n    }\\n\\n    struct LastIndexInteracted {\\n        uint128 index1;\\n        uint128 index2;\\n    }\\n\\n    struct Redeem {\\n        uint128 depositShares;\\n        uint128 withdrawnAmount;\\n    }\\n\\n    /* ========== EVENTS ========== */\\n\\n    event VaultRedeem(uint indexed globalIndex);\\n    event UserRedeem(address indexed member, uint indexed globalIndex);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/vault/IVaultRestricted.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.11;\\n\\ninterface IVaultRestricted {\\n    /* ========== FUNCTIONS ========== */\\n    \\n    function reallocate(\\n        address[] calldata vaultStrategies,\\n        uint256 newVaultProportions,\\n        uint256 finishedIndex,\\n        uint24 activeIndex\\n    ) external returns (uint256[] memory, uint256);\\n\\n    function payFees(uint256 profit) external returns (uint256 feesPaid);\\n\\n    /* ========== EVENTS ========== */\\n\\n    event Reallocate(uint24 indexed index, uint256 newProportions);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Hash.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\n/**\\r\\n * @notice Library to provide utils for hashing and hash compatison of Spool related data\\r\\n */\\r\\nlibrary Hash {\\r\\n    function hashReallocationTable(uint256[][] memory reallocationTable) internal pure returns(bytes32) {\\r\\n        return keccak256(abi.encode(reallocationTable));\\r\\n    }\\r\\n\\r\\n    function hashStrategies(address[] memory strategies) internal pure returns(bytes32) {\\r\\n        return keccak256(abi.encodePacked(strategies));\\r\\n    }\\r\\n\\r\\n    function sameStrategies(address[] memory strategies1, address[] memory strategies2) internal pure returns(bool) {\\r\\n        return hashStrategies(strategies1) == hashStrategies(strategies2);\\r\\n    }\\r\\n\\r\\n    function sameStrategies(address[] memory strategies, bytes32 strategiesHash) internal pure returns(bool) {\\r\\n        return hashStrategies(strategies) == strategiesHash;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/shared/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/token/ERC20/IERC20.sol\\\";\\r\\n\\r\\n/// @title Common Spool contracts constants\\r\\nabstract contract BaseConstants {\\r\\n    /// @dev 2 digits precision\\r\\n    uint256 internal constant FULL_PERCENT = 100_00;\\r\\n\\r\\n    /// @dev Accuracy when doing shares arithmetics\\r\\n    uint256 internal constant ACCURACY = 10**30;\\r\\n}\\r\\n\\r\\n/// @title Contains USDC token related values\\r\\nabstract contract USDC {\\r\\n    /// @notice USDC token contract address\\r\\n    IERC20 internal constant USDC_ADDRESS = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);\\r\\n}\"\r\n    },\r\n    \"contracts/shared/SpoolOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../interfaces/ISpoolOwner.sol\\\";\\r\\n\\r\\n/// @title Logic to help check whether the caller is the Spool owner\\r\\nabstract contract SpoolOwnable {\\r\\n    /// @notice Contract that checks if address is Spool owner\\r\\n    ISpoolOwner internal immutable spoolOwner;\\r\\n\\r\\n    /**\\r\\n     * @notice Sets correct initial values\\r\\n     * @param _spoolOwner Spool owner contract address\\r\\n     */\\r\\n    constructor(ISpoolOwner _spoolOwner) {\\r\\n        require(\\r\\n            address(_spoolOwner) != address(0),\\r\\n            \\\"SpoolOwnable::constructor: Spool owner contract address cannot be 0\\\"\\r\\n        );\\r\\n\\r\\n        spoolOwner = _spoolOwner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if caller is Spool owner\\r\\n     * @return True if caller is Spool owner, false otherwise\\r\\n     */\\r\\n    function isSpoolOwner() internal view returns(bool) {\\r\\n        return spoolOwner.isSpoolOwner(msg.sender);\\r\\n    }\\r\\n\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    function _onlyOwner() private view {\\r\\n        require(isSpoolOwner(), \\\"SpoolOwnable::onlyOwner: Caller is not the Spool owner\\\");\\r\\n    }\\r\\n\\r\\n    /// @notice Checks and throws if caller is not Spool owner\\r\\n    modifier onlyOwner() {\\r\\n        _onlyOwner();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/vault/VaultNonUpgradableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\n\\r\\npragma solidity 0.8.11;\\r\\n\\r\\nimport \\\"../external/@openzeppelin/proxy/Proxy.sol\\\";\\r\\nimport \\\"../interfaces/vault/IVaultImmutable.sol\\\";\\r\\nimport \\\"../interfaces/vault/IVaultDetails.sol\\\";\\r\\n\\r\\n/**\\r\\n * @notice This contract is a non-upgradable proxy for Spool vault implementation.\\r\\n *\\r\\n * @dev\\r\\n * It is used to lower the gas cost of vault creation.\\r\\n * The contract holds vault specific immutable variables.\\r\\n */\\r\\ncontract VaultNonUpgradableProxy is Proxy, IVaultImmutable {\\r\\n    /* ========== STATE VARIABLES ========== */\\r\\n\\r\\n    /// @notice The address of vault implementation\\r\\n    address public immutable vaultImplementation;\\r\\n\\r\\n    /// @notice Vault underlying asset\\r\\n    IERC20 public override immutable underlying;\\r\\n\\r\\n    /// @notice Vault risk provider address\\r\\n    address public override immutable riskProvider;\\r\\n\\r\\n    /// @notice A number from -10 to 10 indicating the risk tolerance of the vault\\r\\n    int8 public override immutable riskTolerance;\\r\\n\\r\\n    /* ========== CONSTRUCTOR ========== */\\r\\n    \\r\\n    /**\\r\\n     * @notice Sets the vault specific immutable values.\\r\\n     *\\r\\n     * @param _vaultImplementation implementation contract address of the vault\\r\\n     * @param vaultImmutables vault immutable values\\r\\n     */\\r\\n    constructor(\\r\\n        address _vaultImplementation,\\r\\n        VaultImmutables memory vaultImmutables\\r\\n    ) {\\r\\n        vaultImplementation = _vaultImplementation;\\r\\n        underlying = vaultImmutables.underlying;\\r\\n        riskProvider = vaultImmutables.riskProvider;\\r\\n        riskTolerance = vaultImmutables.riskTolerance;\\r\\n    }\\r\\n\\r\\n    /* ========== INTERNAL FUNCTIONS ========== */\\r\\n\\r\\n    /**\\r\\n     * @notice Return contract address of vault implementation.\\r\\n     *\\r\\n     * @return vault implementation contract address\\r\\n     */\\r\\n    function _implementation() internal view override returns (address) {\\r\\n        return vaultImplementation;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISpoolOwner\",\"name\":\"_spoolOwner\",\"type\":\"address\"},{\"internalType\":\"contract IRiskProviderRegistry\",\"name\":\"_riskRegistry\",\"type\":\"address\"},{\"internalType\":\"contract ISpool\",\"name\":\"_spool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultImplementation\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"DisableStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"EmergencyRecipientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"EmergencyWithdrawStrategy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"EmergencyWithdrawerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"PauserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"StrategyRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"UnpauserUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"proportions\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"vaultFee\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"riskTolerance\",\"type\":\"int8\"}],\"name\":\"VaultCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"name\":\"VaultInvalid\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_DAO_VAULT_CREATOR_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RISK_TOLERANCE\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VAULT_CREATOR_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_VAULT_STRATEGIES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_RISK_TOLERANCE\",\"outputs\":[{\"internalType\":\"int8\",\"name\":\"\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"allStrategies\",\"type\":\"address[]\"}],\"name\":\"addStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkPaused\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"strategies\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"proportions\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"vaultFee\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"riskProvider\",\"type\":\"address\"},{\"internalType\":\"int8\",\"name\":\"riskTolerance\",\"type\":\"int8\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct VaultDetails\",\"name\":\"details\",\"type\":\"tuple\"}],\"name\":\"createVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"vault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllStrategies\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVault[]\",\"name\":\"vaults\",\"type\":\"address[]\"}],\"name\":\"getRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStrategiesCount\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isEmergencyWithdrawer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUnpauser\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"skipDisable\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"allStrategies\",\"type\":\"address[]\"}],\"name\":\"removeStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"skipDisable\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"allStrategies\",\"type\":\"address[]\"}],\"name\":\"removeStrategyAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"riskRegistry\",\"outputs\":[{\"internalType\":\"contract IRiskProviderRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategy\",\"type\":\"address\"}],\"name\":\"runDisableStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_emergencyRecipient\",\"type\":\"address\"}],\"name\":\"setEmergencyRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isEmergencyWithdrawer\",\"type\":\"bool\"}],\"name\":\"setEmergencyWithdrawer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"setPauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"setUnpauser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spool\",\"outputs\":[{\"internalType\":\"contract ISpool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"strategies\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategiesHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedUnderlying\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVaults\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"transferFrom\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToSpool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validStrategy\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validVault\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_strategies\",\"type\":\"address[]\"}],\"name\":\"verifyStrategies\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Controller", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000004f03f70a99e5c3b49d733ddd7458f80fa9b5a5b5000000000000000000000000f3b3db4271d28427a3c50c66d754a4a2596b32db000000000000000000000000a5bee0212d4013ba8b452faea2eb9d597d7c73b1000000000000000000000000295d53a5563cc71ff30071ffdd1622e994d827b5", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}