{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/JBProjectHandles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport '@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol';\\nimport '@jbx-protocol/contracts-v2/contracts/abstract/JBOperatable.sol';\\nimport '@openzeppelin/contracts/interfaces/IERC721.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport './interfaces/IJBProjectHandles.sol';\\nimport './libraries/JBOperations2.sol';\\n\\n/** \\n  @title \\n  JBProjectHandles\\n\\n  @author \\n  peri, jango, drgorilla\\n\\n  @notice \\n  Manages reverse records that point from JB project IDs to ENS nodes. If the reverse record of a project ID is pointed to an ENS node with a TXT record matching the ID of that project, then the ENS node will be considered the \\\"handle\\\" for that project.\\n\\n  @dev\\n  Adheres to -\\n  IJBProjectHandles: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\\n\\n  @dev\\n  Inherits from -\\n  JBOperatable: Several functions in this contract can only be accessed by a project owner, or an address that has been preconfifigured to be an operator of the project.\\n*/\\ncontract JBProjectHandles is IJBProjectHandles, JBOperatable {\\n  //*********************************************************************//\\n  // --------------------------- custom errors ------------------------- //\\n  //*********************************************************************//\\n  error EMPTY_NAME_PART();\\n  error NO_PARTS();\\n\\n  //*********************************************************************//\\n  // --------------------- internal stored properties ------------------ //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice\\n    Mapping of project ID to an array of strings that make up an ENS name and its subdomains.\\n\\n    @dev\\n    [\\\"jbx\\\", \\\"dao\\\", \\\"foo\\\"] represents foo.dao.jbx.eth.\\n\\n    _projectId The ID of the project to get an ENS name for.\\n  */\\n  mapping(uint256 => string[]) internal _ensNamePartsOf;\\n\\n  //*********************************************************************//\\n  // ---------------- public constant stored properties ---------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice\\n    The key of the ENS text record.\\n  */\\n  string public constant override TEXT_KEY = 'juicebox_project_id';\\n\\n  //*********************************************************************//\\n  // --------------- public immutable stored properties ---------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice\\n    A contract which mints ERC-721's that represent project ownership and transfers.\\n  */\\n  IJBProjects public immutable override projects;\\n\\n  /** \\n    @notice\\n    The ENS text resolver contract address.\\n  */\\n  ITextResolver public immutable override textResolver;\\n\\n  //*********************************************************************//\\n  // ------------------------- external views -------------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice \\n    Returns the handle for a project.\\n\\n    @dev \\n    Requires a TXT record for the `TEXT_KEY` that matches the `_projectId`.\\n\\n    @param _projectId The ID of the project to get the handle of.\\n\\n    @return The project's handle.\\n  */\\n  function handleOf(uint256 _projectId) external view override returns (string memory) {\\n    // Get a reference to the project's ENS name parts.\\n    string[] memory _ensNameParts = _ensNamePartsOf[_projectId];\\n\\n    // Return empty string if ENS isn't set.\\n    if (_ensNameParts.length == 0) return '';\\n\\n    // Find the projectId that the text record of the ENS name is mapped to.\\n    string memory textRecordProjectId = textResolver.text(_namehash(_ensNameParts), TEXT_KEY);\\n\\n    // Return empty string if text record from ENS name doesn't match projectId.\\n    if (keccak256(bytes(textRecordProjectId)) != keccak256(bytes(Strings.toString(_projectId))))\\n      return '';\\n\\n    // Format the handle from the name parts.\\n    return _formatHandle(_ensNameParts);\\n  }\\n\\n  /** \\n    @notice \\n    The parts of the stored ENS name of a project.\\n\\n    @param _projectId The ID of the project to get the ENS name of.\\n\\n    @return The parts of the ENS name parts of a project.\\n  */\\n  function ensNamePartsOf(uint256 _projectId) external view override returns (string[] memory) {\\n    return _ensNamePartsOf[_projectId];\\n  }\\n\\n  //*********************************************************************//\\n  // ---------------------------- constructor -------------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @param _projects A contract which mints ERC-721's that represent project ownership and transfers.\\n    @param _operatorStore A contract storing operator assignments.\\n    @param _textResolver The ENS text resolver contract address.\\n  */\\n  constructor(\\n    IJBProjects _projects,\\n    IJBOperatorStore _operatorStore,\\n    ITextResolver _textResolver\\n  ) JBOperatable(_operatorStore) {\\n    projects = _projects;\\n    textResolver = _textResolver;\\n  }\\n\\n  //*********************************************************************//\\n  // --------------------- external transactions ----------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice \\n    Associate an ENS name with a project.\\n\\n    @dev\\n    [\\\"jbx\\\", \\\"dao\\\", \\\"foo\\\"] represents foo.dao.jbx.eth.\\n\\n    @dev\\n    Only a project's owner or a designated operator can set its ENS name parts.\\n\\n    @param _projectId The ID of the project to set an ENS handle for.\\n    @param _parts The parts of the ENS domain to use as the project handle, excluding the trailing .eth.\\n  */\\n  function setEnsNamePartsFor(uint256 _projectId, string[] memory _parts)\\n    external\\n    override\\n    requirePermission(projects.ownerOf(_projectId), _projectId, JBOperations2.SET_ENS_NAME_FOR)\\n  {\\n    // Get a reference to the number of parts are in the ENS name.\\n    uint256 _partsLength = _parts.length;\\n\\n    // Make sure there are ens name parts.\\n    if (_parts.length == 0) revert NO_PARTS();\\n\\n    // Make sure no provided parts are empty.\\n    for (uint256 _i = 0; _i < _partsLength; ) {\\n      if (bytes(_parts[_i]).length == 0) revert EMPTY_NAME_PART();\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n\\n    // Store the parts.\\n    _ensNamePartsOf[_projectId] = _parts;\\n\\n    emit SetEnsNameParts(_projectId, _formatHandle(_parts), _parts, msg.sender);\\n  }\\n\\n  //*********************************************************************//\\n  // ------------------------ internal functions ----------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice \\n    Formats ENS name parts into a handle.\\n\\n    @param _ensNameParts The ENS name parts to format into a handle.\\n\\n    @return _handle The formatted ENS handle.\\n  */\\n  function _formatHandle(string[] memory _ensNameParts)\\n    internal\\n    pure\\n    returns (string memory _handle)\\n  {\\n    // Get a reference to the number of parts are in the ENS name.\\n    uint256 _partsLength = _ensNameParts.length;\\n\\n    // Concatenate each name part.\\n    for (uint256 _i = 1; _i <= _partsLength; ) {\\n      _handle = string(abi.encodePacked(_handle, _ensNameParts[_partsLength - _i]));\\n\\n      // Add a dot if this part isn't the last.\\n      if (_i < _partsLength) _handle = string(abi.encodePacked(_handle, '.'));\\n\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n\\n  /** \\n    @notice \\n    Returns a namehash for an ENS name.\\n\\n    @dev \\n    See https://eips.ethereum.org/EIPS/eip-137.\\n\\n    @param _ensNameParts The parts of an ENS name to hash.\\n\\n    @return namehash The namehash for an ENS name parts.\\n  */\\n  function _namehash(string[] memory _ensNameParts) internal pure returns (bytes32 namehash) {\\n    // Hash the trailing \\\"eth\\\" suffix.\\n    namehash = keccak256(abi.encodePacked(namehash, keccak256(abi.encodePacked('eth'))));\\n\\n    // Get a reference to the number of parts are in the ENS name.\\n    uint256 _nameLength = _ensNameParts.length;\\n\\n    // Hash each part.\\n    for (uint256 _i = 0; _i < _nameLength; ) {\\n      namehash = keccak256(\\n        abi.encodePacked(namehash, keccak256(abi.encodePacked(_ensNameParts[_i])))\\n      );\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.4;\\n\\ninterface ITextResolver {\\n    event TextChanged(bytes32 indexed node, string indexed indexedKey, string key);\\n\\n    /**\\n     * Returns the text data associated with an ENS node and key.\\n     * @param node The ENS node to query.\\n     * @param key The text data key to query.\\n     * @return The associated text data.\\n     */\\n    function text(bytes32 node, string calldata key) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/abstract/JBOperatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport './../interfaces/IJBOperatable.sol';\\n\\n/** \\n  @notice\\n  Modifiers to allow access to functions based on the message sender's operator status.\\n\\n  @dev\\n  Adheres to -\\n  IJBOperatable: General interface for the methods in this contract that interact with the blockchain's state according to the protocol's rules.\\n*/\\nabstract contract JBOperatable is IJBOperatable {\\n  //*********************************************************************//\\n  // --------------------------- custom errors -------------------------- //\\n  //*********************************************************************//\\n  error UNAUTHORIZED();\\n\\n  //*********************************************************************//\\n  // ---------------------------- modifiers ---------------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice\\n    Only allows the speficied account or an operator of the account to proceed. \\n\\n    @param _account The account to check for.\\n    @param _domain The domain namespace to look for an operator within. \\n    @param _permissionIndex The index of the permission to check for. \\n  */\\n  modifier requirePermission(\\n    address _account,\\n    uint256 _domain,\\n    uint256 _permissionIndex\\n  ) {\\n    _requirePermission(_account, _domain, _permissionIndex);\\n    _;\\n  }\\n\\n  /** \\n    @notice\\n    Only allows the speficied account, an operator of the account to proceed, or a truthy override flag. \\n\\n    @param _account The account to check for.\\n    @param _domain The domain namespace to look for an operator within. \\n    @param _permissionIndex The index of the permission to check for. \\n    @param _override A condition to force allowance for.\\n  */\\n  modifier requirePermissionAllowingOverride(\\n    address _account,\\n    uint256 _domain,\\n    uint256 _permissionIndex,\\n    bool _override\\n  ) {\\n    _requirePermissionAllowingOverride(_account, _domain, _permissionIndex, _override);\\n    _;\\n  }\\n\\n  //*********************************************************************//\\n  // ---------------- public immutable stored properties --------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice \\n    A contract storing operator assignments.\\n  */\\n  IJBOperatorStore public immutable override operatorStore;\\n\\n  //*********************************************************************//\\n  // -------------------------- constructor ---------------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @param _operatorStore A contract storing operator assignments.\\n  */\\n  constructor(IJBOperatorStore _operatorStore) {\\n    operatorStore = _operatorStore;\\n  }\\n\\n  //*********************************************************************//\\n  // -------------------------- internal views ------------------------- //\\n  //*********************************************************************//\\n\\n  /** \\n    @notice\\n    Require the message sender is either the account or has the specified permission.\\n\\n    @param _account The account to allow.\\n    @param _domain The domain namespace within which the permission index will be checked.\\n    @param _permissionIndex The permission index that an operator must have within the specified domain to be allowed.\\n  */\\n  function _requirePermission(\\n    address _account,\\n    uint256 _domain,\\n    uint256 _permissionIndex\\n  ) internal view {\\n    if (\\n      msg.sender != _account &&\\n      !operatorStore.hasPermission(msg.sender, _account, _domain, _permissionIndex) &&\\n      !operatorStore.hasPermission(msg.sender, _account, 0, _permissionIndex)\\n    ) revert UNAUTHORIZED();\\n  }\\n\\n  /** \\n    @notice\\n    Require the message sender is either the account, has the specified permission, or the override condition is true.\\n\\n    @param _account The account to allow.\\n    @param _domain The domain namespace within which the permission index will be checked.\\n    @param _domain The permission index that an operator must have within the specified domain to be allowed.\\n    @param _override The override condition to allow.\\n  */\\n  function _requirePermissionAllowingOverride(\\n    address _account,\\n    uint256 _domain,\\n    uint256 _permissionIndex,\\n    bool _override\\n  ) internal view {\\n    if (\\n      !_override &&\\n      msg.sender != _account &&\\n      !operatorStore.hasPermission(msg.sender, _account, _domain, _permissionIndex) &&\\n      !operatorStore.hasPermission(msg.sender, _account, 0, _permissionIndex)\\n    ) revert UNAUTHORIZED();\\n  }\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IJBProjectHandles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport '@ensdomains/ens-contracts/contracts/resolvers/profiles/ITextResolver.sol';\\nimport '@jbx-protocol/contracts-v2/contracts/interfaces/IJBProjects.sol';\\n\\ninterface IJBProjectHandles {\\n  event SetEnsNameParts(\\n    uint256 indexed projectId,\\n    string indexed handle,\\n    string[] parts,\\n    address caller\\n  );\\n\\n  function setEnsNamePartsFor(uint256 _projectId, string[] memory _parts) external;\\n\\n  function ensNamePartsOf(uint256 _projectId) external view returns (string[] memory);\\n\\n  function TEXT_KEY() external view returns (string memory);\\n\\n  function projects() external view returns (IJBProjects);\\n\\n  function textResolver() external view returns (ITextResolver);\\n\\n  function handleOf(uint256 _projectId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/JBOperations2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nlibrary JBOperations2 {\\n  uint256 public constant SET_ENS_NAME_FOR = 19;\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/interfaces/IJBOperatable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport './IJBOperatorStore.sol';\\n\\ninterface IJBOperatable {\\n  function operatorStore() external view returns (IJBOperatorStore);\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/interfaces/IJBProjects.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\nimport './../structs/JBProjectMetadata.sol';\\nimport './IJBTokenUriResolver.sol';\\n\\ninterface IJBProjects is IERC721 {\\n  event Create(\\n    uint256 indexed projectId,\\n    address indexed owner,\\n    JBProjectMetadata metadata,\\n    address caller\\n  );\\n\\n  event SetMetadata(uint256 indexed projectId, JBProjectMetadata metadata, address caller);\\n\\n  event SetTokenUriResolver(IJBTokenUriResolver indexed resolver, address caller);\\n\\n  function count() external view returns (uint256);\\n\\n  function metadataContentOf(uint256 _projectId, uint256 _domain)\\n    external\\n    view\\n    returns (string memory);\\n\\n  function tokenUriResolver() external view returns (IJBTokenUriResolver);\\n\\n  function createFor(address _owner, JBProjectMetadata calldata _metadata)\\n    external\\n    returns (uint256 projectId);\\n\\n  function setMetadataOf(uint256 _projectId, JBProjectMetadata calldata _metadata) external;\\n\\n  function setTokenUriResolver(IJBTokenUriResolver _newResolver) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/interfaces/IJBOperatorStore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\nimport './../structs/JBOperatorData.sol';\\n\\ninterface IJBOperatorStore {\\n  event SetOperator(\\n    address indexed operator,\\n    address indexed account,\\n    uint256 indexed domain,\\n    uint256[] permissionIndexes,\\n    uint256 packed\\n  );\\n\\n  function permissionsOf(\\n    address _operator,\\n    address _account,\\n    uint256 _domain\\n  ) external view returns (uint256);\\n\\n  function hasPermission(\\n    address _operator,\\n    address _account,\\n    uint256 _domain,\\n    uint256 _permissionIndex\\n  ) external view returns (bool);\\n\\n  function hasPermissions(\\n    address _operator,\\n    address _account,\\n    uint256 _domain,\\n    uint256[] calldata _permissionIndexes\\n  ) external view returns (bool);\\n\\n  function setOperator(JBOperatorData calldata _operatorData) external;\\n\\n  function setOperators(JBOperatorData[] calldata _operatorData) external;\\n}\\n\"\r\n    },\r\n    \"node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/structs/JBProjectMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/** \\n  @member content The metadata content.\\n  @member domain The domain within which the metadata applies.\\n*/\\nstruct JBProjectMetadata {\\n  string content;\\n  uint256 domain;\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/interfaces/IJBTokenUriResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\ninterface IJBTokenUriResolver {\\n  function getUri(uint256 _projectId) external view returns (string memory tokenUri);\\n}\\n\"\r\n    },\r\n    \"node_modules/@jbx-protocol/contracts-v2/contracts/structs/JBOperatorData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.6;\\n\\n/** \\n  @member operator The address of the operator.\\n  @member domain The domain within which the operator is being given permissions. A domain of 0 is a wildcard domain, which gives an operator access to all domains.\\n  @member permissionIndexes The indexes of the permissions the operator is being given.\\n*/\\nstruct JBOperatorData {\\n  address operator;\\n  uint256 domain;\\n  uint256[] permissionIndexes;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@contracts/=contracts/\",\r\n      \"@ensdomains/=node_modules/@ensdomains/\",\r\n      \"@jbx-protocol/=node_modules/@jbx-protocol/\",\r\n      \"@openzeppelin/=node_modules/@openzeppelin/\",\r\n      \"contracts/=contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"test/=test/\",\r\n      \"contracts/=contracts/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IJBProjects\",\"name\":\"_projects\",\"type\":\"address\"},{\"internalType\":\"contract IJBOperatorStore\",\"name\":\"_operatorStore\",\"type\":\"address\"},{\"internalType\":\"contract ITextResolver\",\"name\":\"_textResolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EMPTY_NAME_PART\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NO_PARTS\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UNAUTHORIZED\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"projectId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"handle\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string[]\",\"name\":\"parts\",\"type\":\"string[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"SetEnsNameParts\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"TEXT_KEY\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"ensNamePartsOf\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"}],\"name\":\"handleOf\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operatorStore\",\"outputs\":[{\"internalType\":\"contract IJBOperatorStore\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projects\",\"outputs\":[{\"internalType\":\"contract IJBProjects\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_projectId\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"_parts\",\"type\":\"string[]\"}],\"name\":\"setEnsNamePartsFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"textResolver\",\"outputs\":[{\"internalType\":\"contract ITextResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "JBProjectHandles", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000d8b4359143eda5b2d763e127ed27c77addbc47d30000000000000000000000006f3c5afca0c9edf3926ef2ddf17c8ae6391afefb0000000000000000000000004976fb03c32e5b8cfe2b6ccb31c09ba78ebaba41", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}