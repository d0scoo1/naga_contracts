{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/VoSPOOL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./external/@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"./external/spool-core/SpoolOwnable.sol\\\";\\nimport \\\"./interfaces/IVoSPOOL.sol\\\";\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice global tranche struct\\n * @dev used so it can be passed through functions as a struct\\n * @member amount amount minted in tranche\\n */\\nstruct Tranche {\\n\\tuint48 amount;\\n}\\n\\n/**\\n * @notice global tranches struct holding 5 tranches\\n * @dev made to pack multiple tranches in one word\\n * @member zero tranche in pack at position 0\\n * @member one tranche in pack at position 1\\n * @member two tranche in pack at position 2\\n * @member three tranche in pack at position 3\\n * @member four tranche in pack at position 4\\n */\\nstruct GlobalTranches {\\n\\tTranche zero;\\n\\tTranche one;\\n\\tTranche two;\\n\\tTranche three;\\n\\tTranche four;\\n}\\n\\n/**\\n * @notice user tranche struct\\n * @dev struct holds users minted amount at tranche at index\\n * @member amount users amount minted at tranche\\n * @member index tranche index\\n */\\nstruct UserTranche {\\n\\tuint48 amount;\\n\\tuint16 index;\\n}\\n\\n/**\\n * @notice user tranches struct, holding 4 user tranches\\n * @dev made to pack multiple tranches in one word\\n * @member zero user tranche in pack at position 0\\n * @member one user tranche in pack at position 1\\n * @member two user tranche in pack at position 2\\n * @member three user tranche in pack at position 3\\n */\\nstruct UserTranches {\\n\\tUserTranche zero;\\n\\tUserTranche one;\\n\\tUserTranche two;\\n\\tUserTranche three;\\n}\\n\\n/**\\n * @title Spool DAO Voting Token Implementation\\n *\\n * @notice The voting SPOOL pseudo-ERC20 Implementation\\n *\\n * An untransferable token implementation meant to be used by the\\n * Spool DAO to mint the voting equivalent of the staked token.\\n *\\n * @dev\\n * Users voting power consists of instant and gradual (maturing) voting power.\\n * voSPOOL contract assumes voting power comes from vesting or staking SPOOL tokens.\\n * As SPOOL tokens have a maximum supply of 210,000,000 * 10**18, we consider this\\n * limitation when storing data (e.g. storing amount divided by 10**12) to save on gas.\\n *\\n * Instant voting power can be used in the full amount as soon as minted.\\n *\\n * Gradual voting power:\\n *      Matures linearly over 156 weeks (3 years) up to the minted amount.\\n *      If a user burns gradual voting power, all accumulated voting power is\\n *      reset to zero. In case there is some amount left, it'll take another 3\\n *      years to achieve fully-matured power. Only gradual voting power is reset\\n *      and not instant one.\\n *      Gradual voting power updates at every new tranche, which lasts one week.\\n *\\n * Contract consists of:\\n *      - CONSTANTS\\n *      - STATE VARIABLES\\n *      - CONSTRUCTOR\\n *      - IERC20 FUNCTIONS\\n *      - INSTANT POWER FUNCTIONS\\n *      - GRADUAL POWER FUNCTIONS\\n *          - GRADUAL POWER: VIEW FUNCTIONS\\n *          - GRADUAL POWER: MINT FUNCTIONS\\n *          - GRADUAL POWER: BURN FUNCTIONS\\n *          - GRADUAL POWER: UPDATE GLOBAL FUNCTIONS\\n *          - GRADUAL POWER: UPDATE USER FUNCTIONS\\n *          - GRADUAL POWER: GLOBAL HELPER FUNCTIONS\\n *          - GRADUAL POWER: USER HELPER FUNCTIONS\\n *          - GRADUAL POWER: HELPER FUNCTIONS\\n *      - OWNER FUNCTIONS\\n *      - RESTRICTION FUNCTIONS\\n *      - MODIFIERS\\n */\\ncontract VoSPOOL is SpoolOwnable, IVoSPOOL, IERC20Metadata {\\n\\t/* ========== CONSTANTS ========== */\\n\\n\\t/// @notice trim size value of the mint amount\\n\\t/// @dev we trim gradual mint amount by `TRIM_SIZE`, so it takes less storage\\n\\tuint256 private constant TRIM_SIZE = 10**12;\\n\\t/// @notice number of tranche amounts stored in one 256bit word\\n\\tuint256 private constant TRANCHES_PER_WORD = 5;\\n\\n\\t/// @notice duration of one tranche\\n\\tuint256 public constant TRANCHE_TIME = 1 weeks;\\n\\t/// @notice amount of tranches to mature to full power\\n\\tuint256 public constant FULL_POWER_TRANCHES_COUNT = 52 * 3;\\n\\t/// @notice time until gradual power is fully-matured\\n\\t/// @dev full power time is 156 weeks (approximately 3 years)\\n\\tuint256 public constant FULL_POWER_TIME = TRANCHE_TIME * FULL_POWER_TRANCHES_COUNT;\\n\\n\\t/// @notice Token name full name\\n\\tstring public constant name = \\\"Spool DAO Voting Token\\\";\\n\\t/// @notice Token symbol\\n\\tstring public constant symbol = \\\"voSPOOL\\\";\\n\\t/// @notice Token decimals\\n\\tuint8 public constant decimals = 18;\\n\\n\\t/* ========== STATE VARIABLES ========== */\\n\\n\\t/// @notice tranche time for index 1\\n\\tuint256 public immutable firstTrancheStartTime;\\n\\n\\t/// @notice mapping holding instant minting privileges for addresses\\n\\tmapping(address => bool) public minters;\\n\\t/// @notice mapping holding gradual minting privileges for addresses\\n\\tmapping(address => bool) public gradualMinters;\\n\\n\\t/// @notice total instant voting power\\n\\tuint256 public totalInstantPower;\\n\\t/// @notice user instant voting power\\n\\tmapping(address => uint256) public userInstantPower;\\n\\n\\t/// @notice global gradual power values\\n\\tGlobalGradual private _globalGradual;\\n\\t/// @notice global tranches\\n\\t/// @dev mapping tranche index to a group of tranches (5 tranches per word)\\n\\tmapping(uint256 => GlobalTranches) public indexedGlobalTranches;\\n\\n\\t/// @notice user gradual power values\\n\\tmapping(address => UserGradual) private _userGraduals;\\n\\t/// @notice user tranches\\n\\t/// @dev mapping users to its tranches\\n\\tmapping(address => mapping(uint256 => UserTranches)) public userTranches;\\n\\n\\t/* ========== CONSTRUCTOR ========== */\\n\\n\\t/**\\n\\t * @notice Sets the value of _spoolOwner and first tranche end time\\n\\t * @dev With `_firstTrancheEndTime` you can set when the first tranche time\\n\\t * finishes and essentially users minted get the first foting power.\\n\\t * e.g. if we set it to Sunday 10pm and tranche time is 1 week,\\n\\t * all new tranches in the future will finish on Sunday 10pm and new\\n\\t * voSPOOL power will mature and be accrued.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - first tranche time must be in the future\\n\\t * - first tranche time must must be less than full tranche time in the future\\n\\t *\\n\\t * @param _spoolOwner address of spool owner contract\\n\\t * @param _firstTrancheEndTime first tranche end time after the deployment\\n\\t */\\n\\tconstructor(ISpoolOwner _spoolOwner, uint256 _firstTrancheEndTime) SpoolOwnable(_spoolOwner) {\\n\\t\\trequire(\\n\\t\\t\\t_firstTrancheEndTime > block.timestamp,\\n\\t\\t\\t\\\"voSPOOL::constructor: First tranche end time must be in the future\\\"\\n\\t\\t);\\n\\t\\trequire(\\n\\t\\t\\t_firstTrancheEndTime < block.timestamp + TRANCHE_TIME,\\n\\t\\t\\t\\\"voSPOOL::constructor: First tranche end time must be less than full tranche time in the future\\\"\\n\\t\\t);\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// set first tranche start time\\n\\t\\t\\tfirstTrancheStartTime = _firstTrancheEndTime - TRANCHE_TIME;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ========== IERC20 FUNCTIONS ========== */\\n\\n\\t/**\\n\\t * @notice Returns current total voting power\\n\\t */\\n\\tfunction totalSupply() external view override returns (uint256) {\\n\\t\\t(GlobalGradual memory global, ) = _getUpdatedGradual();\\n\\t\\treturn totalInstantPower + _getTotalGradualVotingPower(global);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns current user total voting power\\n\\t */\\n\\tfunction balanceOf(address account) external view override returns (uint256) {\\n\\t\\t(UserGradual memory _userGradual, ) = _getUpdatedGradualUser(account);\\n\\n\\t\\treturn userInstantPower[account] + _getUserGradualVotingPower(_userGradual);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Execution of function is prohibited to disallow token movement\\n\\t */\\n\\tfunction transfer(address, uint256) external pure override returns (bool) {\\n\\t\\trevert(\\\"voSPOOL::transfer: Prohibited Action\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Execution of function is prohibited to disallow token movement\\n\\t */\\n\\tfunction transferFrom(\\n\\t\\taddress,\\n\\t\\taddress,\\n\\t\\tuint256\\n\\t) external pure override returns (bool) {\\n\\t\\trevert(\\\"voSPOOL::transferFrom: Prohibited Action\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Execution of function is prohibited to disallow token movement\\n\\t */\\n\\tfunction approve(address, uint256) external pure override returns (bool) {\\n\\t\\trevert(\\\"voSPOOL::approve: Prohibited Action\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @dev Execution of function is prohibited to disallow token movement\\n\\t */\\n\\tfunction allowance(address, address) external pure override returns (uint256) {\\n\\t\\trevert(\\\"voSPOOL::allowance: Prohibited Action\\\");\\n\\t}\\n\\n\\t/* ========== INSTANT POWER FUNCTIONS ========== */\\n\\n\\t/**\\n\\t * @notice Mints the provided amount as instant voting power.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the autorized\\n\\t *\\n\\t * @param to mint to user\\n\\t * @param amount mint amount\\n\\t */\\n\\tfunction mint(address to, uint256 amount) external onlyMinter {\\n\\t\\ttotalInstantPower += amount;\\n\\t\\tunchecked {\\n\\t\\t\\tuserInstantPower[to] += amount;\\n\\t\\t}\\n\\t\\temit Minted(to, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Burns the provided amount of instant power from the specified user.\\n\\t * @dev only instant power is removed, gradual power stays the same\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the instant minter\\n\\t * - the user must posses at least the burning `amount` of instant voting power amount\\n\\t *\\n\\t * @param from burn from user\\n\\t * @param amount burn amount\\n\\t */\\n\\tfunction burn(address from, uint256 amount) external onlyMinter {\\n\\t\\trequire(userInstantPower[from] >= amount, \\\"voSPOOL:burn: User instant power balance too low\\\");\\n\\t\\tunchecked {\\n\\t\\t\\tuserInstantPower[from] -= amount;\\n\\t\\t\\ttotalInstantPower -= amount;\\n\\t\\t}\\n\\t\\temit Burned(from, amount);\\n\\t}\\n\\n\\t/* ========== GRADUAL POWER FUNCTIONS ========== */\\n\\n\\t/* ---------- GRADUAL POWER: VIEW FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice returns updated total gradual voting power (fully-matured and maturing)\\n\\t *\\n\\t * @return totalGradualVotingPower total gradual voting power (fully-matured + maturing)\\n\\t */\\n\\tfunction getTotalGradualVotingPower() external view returns (uint256) {\\n\\t\\t(GlobalGradual memory global, ) = _getUpdatedGradual();\\n\\t\\treturn _getTotalGradualVotingPower(global);\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns updated global gradual struct\\n\\t *\\n\\t * @return global updated global gradual struct\\n\\t */\\n\\tfunction getGlobalGradual() external view returns (GlobalGradual memory) {\\n\\t\\t(GlobalGradual memory global, ) = _getUpdatedGradual();\\n\\t\\treturn global;\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns not updated global gradual struct\\n\\t *\\n\\t * @return global updated global gradual struct\\n\\t */\\n\\tfunction getNotUpdatedGlobalGradual() external view returns (GlobalGradual memory) {\\n\\t\\treturn _globalGradual;\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns updated user gradual voting power (fully-matured and maturing)\\n\\t *\\n\\t * @param user address holding voting power\\n\\t * @return userGradualVotingPower user gradual voting power (fully-matured + maturing)\\n\\t */\\n\\tfunction getUserGradualVotingPower(address user) external view returns (uint256) {\\n\\t\\t(UserGradual memory _userGradual, ) = _getUpdatedGradualUser(user);\\n\\t\\treturn _getUserGradualVotingPower(_userGradual);\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns updated user gradual struct\\n\\t *\\n\\t * @param user user address\\n\\t * @return _userGradual user updated gradual struct\\n\\t */\\n\\tfunction getUserGradual(address user) external view returns (UserGradual memory) {\\n\\t\\t(UserGradual memory _userGradual, ) = _getUpdatedGradualUser(user);\\n\\t\\treturn _userGradual;\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns not updated user gradual struct\\n\\t *\\n\\t * @param user user address\\n\\t * @return _userGradual user updated gradual struct\\n\\t */\\n\\tfunction getNotUpdatedUserGradual(address user) external view returns (UserGradual memory) {\\n\\t\\treturn _userGraduals[user];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns current active tranche index\\n\\t *\\n\\t * @return trancheIndex current tranche index\\n\\t */\\n\\tfunction getCurrentTrancheIndex() public view returns (uint16) {\\n\\t\\treturn _getTrancheIndex(block.timestamp);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns tranche index based on `time`\\n\\t * @dev `time` can be any time inside the tranche\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - `time` must be equal to more than first tranche time\\n\\t *\\n\\t * @param time tranche time time to get the index for\\n\\t * @return trancheIndex tranche index at `time`\\n\\t */\\n\\tfunction getTrancheIndex(uint256 time) external view returns (uint256) {\\n\\t\\trequire(\\n\\t\\t\\ttime >= firstTrancheStartTime,\\n\\t\\t\\t\\\"voSPOOL::getTrancheIndex: Time must be more or equal to the first tranche time\\\"\\n\\t\\t);\\n\\n\\t\\treturn _getTrancheIndex(time);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns tranche index based at time\\n\\t *\\n\\t * @param time unix time\\n\\t * @return trancheIndex tranche index at `time`\\n\\t */\\n\\tfunction _getTrancheIndex(uint256 time) private view returns (uint16) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn uint16(((time - firstTrancheStartTime) / TRANCHE_TIME) + 1);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns next tranche end time\\n\\t *\\n\\t * @return trancheEndTime end time for next tranche\\n\\t */\\n\\tfunction getNextTrancheEndTime() external view returns (uint256) {\\n\\t\\treturn getTrancheEndTime(getCurrentTrancheIndex());\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns tranche end time for tranche index\\n\\t *\\n\\t * @param trancheIndex tranche index\\n\\t * @return trancheEndTime end time for `trancheIndex`\\n\\t */\\n\\tfunction getTrancheEndTime(uint256 trancheIndex) public view returns (uint256) {\\n\\t\\treturn firstTrancheStartTime + trancheIndex * TRANCHE_TIME;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns last finished tranche index\\n\\t *\\n\\t * @return trancheIndex last finished tranche index\\n\\t */\\n\\tfunction getLastFinishedTrancheIndex() public view returns (uint16) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn getCurrentTrancheIndex() - 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: MINT FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice Mints the provided amount of tokens to the specified user to gradually mature up to the amount.\\n\\t * @dev Saves the amount to tranche user index, so the voting power starts maturing.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the autorized\\n\\t *\\n\\t * @param to gradual mint to user\\n\\t * @param amount gradual mint amount\\n\\t */\\n\\tfunction mintGradual(address to, uint256 amount) external onlyGradualMinter updateGradual updateGradualUser(to) {\\n\\t\\tuint48 trimmedAmount = _trim(amount);\\n\\t\\t_mintGradual(to, trimmedAmount);\\n\\t\\temit GradualMinted(to, amount);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Mints the provided amount of tokens to the specified user to gradually mature up to the amount.\\n\\t * @dev Saves the amount to tranche user index, so the voting power starts maturing.\\n\\t *\\n\\t * @param to gradual mint to user\\n\\t * @param trimmedAmount gradual mint trimmed amount\\n\\t */\\n\\tfunction _mintGradual(address to, uint48 trimmedAmount) private {\\n\\t\\tif (trimmedAmount == 0) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tUserGradual memory _userGradual = _userGraduals[to];\\n\\n\\t\\t// add new maturing amount to user and global amount\\n\\t\\t_userGradual.maturingAmount += trimmedAmount;\\n\\t\\t_globalGradual.totalMaturingAmount += trimmedAmount;\\n\\n\\t\\t// add maturing amount to user tranche\\n\\t\\tUserTranche memory latestTranche = _getUserTranche(to, _userGradual.latestTranchePosition);\\n\\n\\t\\tuint16 currentTrancheIndex = getCurrentTrancheIndex();\\n\\n\\t\\tbool isFirstGradualMint = !_hasTranches(_userGradual);\\n\\n\\t\\t// if latest user tranche is not current index, update latest\\n\\t\\t// user can have first mint or last tranche deposited is finished\\n\\t\\tif (isFirstGradualMint || latestTranche.index < currentTrancheIndex) {\\n\\t\\t\\tUserTranchePosition memory nextTranchePosition = _getNextUserTranchePosition(\\n\\t\\t\\t\\t_userGradual.latestTranchePosition\\n\\t\\t\\t);\\n\\n\\t\\t\\t// if first time gradual minting set oldest tranche position\\n\\t\\t\\tif (isFirstGradualMint) {\\n\\t\\t\\t\\t_userGradual.oldestTranchePosition = nextTranchePosition;\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update latest tranche\\n\\t\\t\\t_userGradual.latestTranchePosition = nextTranchePosition;\\n\\n\\t\\t\\tlatestTranche = UserTranche(trimmedAmount, currentTrancheIndex);\\n\\t\\t} else {\\n\\t\\t\\t// if user already minted in current tranche, add additional amount\\n\\t\\t\\tlatestTranche.amount += trimmedAmount;\\n\\t\\t}\\n\\n\\t\\t// update global tranche amount\\n\\t\\t_addGlobalTranche(latestTranche.index, trimmedAmount);\\n\\n\\t\\t// store updated user values\\n\\t\\t_setUserTranche(to, _userGradual.latestTranchePosition, latestTranche);\\n\\t\\t_userGraduals[to] = _userGradual;\\n\\t}\\n\\n\\t/**\\n\\t * @notice add `amount` to global tranche `index`\\n\\t *\\n\\t * @param index tranche index\\n\\t * @param amount amount to add\\n\\t */\\n\\tfunction _addGlobalTranche(uint256 index, uint48 amount) private {\\n\\t\\tTranche storage tranche = _getTranche(index);\\n\\t\\ttranche.amount += amount;\\n\\t}\\n\\n\\t/**\\n\\t * @notice sets updated `user` `tranche` at position\\n\\t *\\n\\t * @param user user address to set tranche\\n\\t * @param userTranchePosition position to set the `tranche` at\\n\\t * @param tranche updated `user` tranche\\n\\t */\\n\\tfunction _setUserTranche(\\n\\t\\taddress user,\\n\\t\\tUserTranchePosition memory userTranchePosition,\\n\\t\\tUserTranche memory tranche\\n\\t) private {\\n\\t\\tUserTranches storage _userTranches = userTranches[user][userTranchePosition.arrayIndex];\\n\\n\\t\\tif (userTranchePosition.position == 0) {\\n\\t\\t\\t_userTranches.zero = tranche;\\n\\t\\t} else if (userTranchePosition.position == 1) {\\n\\t\\t\\t_userTranches.one = tranche;\\n\\t\\t} else if (userTranchePosition.position == 2) {\\n\\t\\t\\t_userTranches.two = tranche;\\n\\t\\t} else {\\n\\t\\t\\t_userTranches.three = tranche;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: BURN FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice Burns the provided amount of gradual power from the specified user.\\n\\t * @dev User loses all matured power accumulated till now.\\n\\t * Voting power starts maturing from the start if there is any amount left.\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the gradual minter\\n\\t *\\n\\t * @param from burn from user\\n\\t * @param amount burn amount\\n\\t * @param burnAll true to burn all user amount\\n\\t */\\n\\tfunction burnGradual(\\n\\t\\taddress from,\\n\\t\\tuint256 amount,\\n\\t\\tbool burnAll\\n\\t) external onlyGradualMinter updateGradual updateGradualUser(from) {\\n\\t\\tUserGradual memory _userGradual = _userGraduals[from];\\n\\t\\tuint48 userTotalGradualAmount = _userGradual.maturedVotingPower + _userGradual.maturingAmount;\\n\\n\\t\\t// remove user matured power\\n\\t\\tif (_userGradual.maturedVotingPower > 0) {\\n\\t\\t\\t_globalGradual.totalMaturedVotingPower -= _userGradual.maturedVotingPower;\\n\\t\\t\\t_userGradual.maturedVotingPower = 0;\\n\\t\\t}\\n\\n\\t\\t// remove user maturing\\n\\t\\tif (_userGradual.maturingAmount > 0) {\\n\\t\\t\\t_globalGradual.totalMaturingAmount -= _userGradual.maturingAmount;\\n\\t\\t\\t_userGradual.maturingAmount = 0;\\n\\t\\t}\\n\\n\\t\\t// remove user unmatured power\\n\\t\\tif (_userGradual.rawUnmaturedVotingPower > 0) {\\n\\t\\t\\t_globalGradual.totalRawUnmaturedVotingPower -= _userGradual.rawUnmaturedVotingPower;\\n\\t\\t\\t_userGradual.rawUnmaturedVotingPower = 0;\\n\\t\\t}\\n\\n\\t\\t// if user has any tranches, remove all of them from user and global\\n\\t\\tif (_hasTranches(_userGradual)) {\\n\\t\\t\\tuint256 fromIndex = _userGradual.oldestTranchePosition.arrayIndex;\\n\\t\\t\\tuint256 toIndex = _userGradual.latestTranchePosition.arrayIndex;\\n\\n\\t\\t\\t// loop over user tranches and delete all of them\\n\\t\\t\\tfor (uint256 i = fromIndex; i <= toIndex; i++) {\\n\\t\\t\\t\\t// delete from global tranches\\n\\t\\t\\t\\t_deleteUserTranchesFromGlobal(userTranches[from][i]);\\n\\t\\t\\t\\t// delete user tranches\\n\\t\\t\\t\\tdelete userTranches[from][i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// reset oldest tranche (meaning user has no tranches)\\n\\t\\t_userGradual.oldestTranchePosition = UserTranchePosition(0, 0);\\n\\n\\t\\t// apply changes to storage\\n\\t\\t_userGraduals[from] = _userGradual;\\n\\n\\t\\temit GradualBurned(from, amount, burnAll);\\n\\n\\t\\t// if we don't burn all gradual amount, restart maturing\\n\\t\\tif (!burnAll) {\\n\\t\\t\\tuint48 trimmedAmount = _trimRoundUp(amount);\\n\\n\\t\\t\\t// if user still has some amount left, mint gradual from start\\n\\t\\t\\tif (userTotalGradualAmount > trimmedAmount) {\\n\\t\\t\\t\\tunchecked {\\n\\t\\t\\t\\t\\tuint48 userAmountLeft = userTotalGradualAmount - trimmedAmount;\\n\\t\\t\\t\\t\\t// mint amount left\\n\\t\\t\\t\\t\\t_mintGradual(from, userAmountLeft);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice remove user tranches amounts from global tranches\\n\\t * @dev remove for all four user tranches in the struct\\n\\t *\\n\\t * @param _userTranches user tranches\\n\\t */\\n\\tfunction _deleteUserTranchesFromGlobal(UserTranches memory _userTranches) private {\\n\\t\\t_removeUserTrancheFromGlobal(_userTranches.zero);\\n\\t\\t_removeUserTrancheFromGlobal(_userTranches.one);\\n\\t\\t_removeUserTrancheFromGlobal(_userTranches.two);\\n\\t\\t_removeUserTrancheFromGlobal(_userTranches.three);\\n\\t}\\n\\n\\t/**\\n\\t * @notice remove user tranche amount from global tranche\\n\\t *\\n\\t * @param userTranche user tranche\\n\\t */\\n\\tfunction _removeUserTrancheFromGlobal(UserTranche memory userTranche) private {\\n\\t\\tif (userTranche.amount > 0) {\\n\\t\\t\\tTranche storage tranche = _getTranche(userTranche.index);\\n\\t\\t\\ttranche.amount -= userTranche.amount;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: UPDATE GLOBAL FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice updates global gradual voting power\\n\\t * @dev\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the gradual minter\\n\\t */\\n\\tfunction updateVotingPower() external override onlyGradualMinter {\\n\\t\\t_updateGradual();\\n\\t}\\n\\n\\t/**\\n\\t * @notice updates global gradual voting power\\n\\t * @dev updates only if changes occured\\n\\t */\\n\\tfunction _updateGradual() private {\\n\\t\\t(GlobalGradual memory global, bool didUpdate) = _getUpdatedGradual();\\n\\n\\t\\tif (didUpdate) {\\n\\t\\t\\t_globalGradual = global;\\n\\t\\t\\temit GlobalGradualUpdated(\\n\\t\\t\\t\\tglobal.lastUpdatedTrancheIndex,\\n\\t\\t\\t\\tglobal.totalMaturedVotingPower,\\n\\t\\t\\t\\tglobal.totalMaturingAmount,\\n\\t\\t\\t\\tglobal.totalRawUnmaturedVotingPower\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns updated global gradual values\\n\\t * @dev the update is in-memory\\n\\t *\\n\\t * @return global updated GlobalGradual struct\\n\\t * @return didUpdate flag if `global` was updated\\n\\t */\\n\\tfunction _getUpdatedGradual() private view returns (GlobalGradual memory global, bool didUpdate) {\\n\\t\\tuint256 lastFinishedTrancheIndex = getLastFinishedTrancheIndex();\\n\\t\\tglobal = _globalGradual;\\n\\n\\t\\t// update gradual until we reach last finished index\\n\\t\\twhile (global.lastUpdatedTrancheIndex < lastFinishedTrancheIndex) {\\n\\t\\t\\t// increment index before updating so we calculate based on finished index\\n\\t\\t\\tglobal.lastUpdatedTrancheIndex++;\\n\\t\\t\\t_updateGradualForTrancheIndex(global);\\n\\t\\t\\tdidUpdate = true;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice update global gradual values for tranche `index`\\n\\t * @dev the update is done in-memory on `global` struct\\n\\t *\\n\\t * @param global global gradual struct\\n\\t */\\n\\tfunction _updateGradualForTrancheIndex(GlobalGradual memory global) private view {\\n\\t\\t// update unmatured voting power\\n\\t\\t// every new tranche we add totalMaturingAmount to the _totalRawUnmaturedVotingPower\\n\\t\\tglobal.totalRawUnmaturedVotingPower += global.totalMaturingAmount;\\n\\n\\t\\t// move newly matured voting power to matured\\n\\t\\t// do only if contract is old enough so full power could be achieved\\n\\t\\tif (global.lastUpdatedTrancheIndex >= FULL_POWER_TRANCHES_COUNT) {\\n\\t\\t\\tuint256 maturedIndex = global.lastUpdatedTrancheIndex - FULL_POWER_TRANCHES_COUNT + 1;\\n\\n\\t\\t\\tuint48 newMaturedVotingPower = _getTranche(maturedIndex).amount;\\n\\n\\t\\t\\t// if there is any new fully-matured voting power, update\\n\\t\\t\\tif (newMaturedVotingPower > 0) {\\n\\t\\t\\t\\t// remove new fully matured voting power from non matured raw one\\n\\t\\t\\t\\tuint56 newMaturedAsRawUnmatured = _getMaturedAsRawUnmaturedAmount(newMaturedVotingPower);\\n\\t\\t\\t\\tglobal.totalRawUnmaturedVotingPower -= newMaturedAsRawUnmatured;\\n\\n\\t\\t\\t\\t// remove new fully-matured power from maturing amount\\n\\t\\t\\t\\tglobal.totalMaturingAmount -= newMaturedVotingPower;\\n\\t\\t\\t\\t// add new fully-matured voting power\\n\\t\\t\\t\\tglobal.totalMaturedVotingPower += newMaturedVotingPower;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: UPDATE USER FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice update gradual user voting power\\n\\t * @dev also updates global gradual voting power\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the gradual minter\\n\\t *\\n\\t * @param user user address to update\\n\\t */\\n\\tfunction updateUserVotingPower(address user) external override onlyGradualMinter {\\n\\t\\t_updateGradual();\\n\\t\\t_updateGradualUser(user);\\n\\t}\\n\\n\\t/**\\n\\t * @notice update gradual user struct storage\\n\\t *\\n\\t * @param user user address to update\\n\\t */\\n\\tfunction _updateGradualUser(address user) private {\\n\\t\\t(UserGradual memory _userGradual, bool didUpdate) = _getUpdatedGradualUser(user);\\n\\t\\tif (didUpdate) {\\n\\t\\t\\t_userGraduals[user] = _userGradual;\\n\\t\\t\\temit UserGradualUpdated(\\n\\t\\t\\t\\tuser,\\n\\t\\t\\t\\t_userGradual.lastUpdatedTrancheIndex,\\n\\t\\t\\t\\t_userGradual.maturedVotingPower,\\n\\t\\t\\t\\t_userGradual.maturingAmount,\\n\\t\\t\\t\\t_userGradual.rawUnmaturedVotingPower\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns updated user gradual struct\\n\\t * @dev the update is returned in-memory\\n\\t * The update is done in 3 steps:\\n\\t * 1. check if user ia alreas, update last updated undex\\n\\t * 2. update voting power for tranches that have fully-matured (if any)\\n\\t * 3. update voting power for tranches that are still maturing\\n\\t *\\n\\t * @param user updated for user address\\n\\t * @return _userGradual updated user gradual struct\\n\\t * @return didUpdate flag if user gradual has updated\\n\\t */\\n\\tfunction _getUpdatedGradualUser(address user) private view returns (UserGradual memory, bool) {\\n\\t\\tUserGradual memory _userGradual = _userGraduals[user];\\n\\t\\tuint16 lastFinishedTrancheIndex = getLastFinishedTrancheIndex();\\n\\n\\t\\t// 1. if user already updated in this tranche index, skip\\n\\t\\tif (_userGradual.lastUpdatedTrancheIndex == lastFinishedTrancheIndex) {\\n\\t\\t\\treturn (_userGradual, false);\\n\\t\\t}\\n\\n\\t\\t// update user if it has maturing power\\n\\t\\tif (_hasTranches(_userGradual)) {\\n\\t\\t\\t// 2. update fully-matured tranches\\n\\t\\t\\tuint16 lastMaturedIndex = _getLastMaturedIndex();\\n\\t\\t\\tif (lastMaturedIndex > 0) {\\n\\t\\t\\t\\tUserTranche memory oldestTranche = _getUserTranche(user, _userGradual.oldestTranchePosition);\\n\\t\\t\\t\\t// update all fully-matured user tranches\\n\\t\\t\\t\\twhile (_hasTranches(_userGradual) && oldestTranche.index <= lastMaturedIndex) {\\n\\t\\t\\t\\t\\t// mature\\n\\t\\t\\t\\t\\t_matureOldestUsersTranche(_userGradual, oldestTranche);\\n\\t\\t\\t\\t\\t// get new user oldest tranche\\n\\t\\t\\t\\t\\toldestTranche = _getUserTranche(user, _userGradual.oldestTranchePosition);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// 3. update still maturing tranches\\n\\t\\t\\tif (_isMaturing(_userGradual, lastFinishedTrancheIndex)) {\\n\\t\\t\\t\\t// get number of passed indexes\\n\\t\\t\\t\\tuint56 indexesPassed = lastFinishedTrancheIndex - _userGradual.lastUpdatedTrancheIndex;\\n\\n\\t\\t\\t\\t// add new user matured power\\n\\t\\t\\t\\t_userGradual.rawUnmaturedVotingPower += _userGradual.maturingAmount * indexesPassed;\\n\\t\\t\\t\\t// last synced index\\n\\t\\t\\t\\t_userGradual.lastUpdatedTrancheIndex = lastFinishedTrancheIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// update user last updated tranche index\\n\\t\\t_userGradual.lastUpdatedTrancheIndex = lastFinishedTrancheIndex;\\n\\n\\t\\treturn (_userGradual, true);\\n\\t}\\n\\n\\t/**\\n\\t * @notice mature users oldest tranche, and update oldest with next user tranche\\n\\t * @dev this is called only if we know `oldestTranche` is mature\\n\\t * Updates are done im-memory\\n\\t *\\n\\t * @param _userGradual user gradual struct to update\\n\\t * @param oldestTranche users oldest struct (fully matured one)\\n\\t */\\n\\tfunction _matureOldestUsersTranche(UserGradual memory _userGradual, UserTranche memory oldestTranche) private pure {\\n\\t\\tuint16 fullyMaturedFinishedIndex = _getFullyMaturedAtFinishedIndex(oldestTranche.index);\\n\\n\\t\\tuint48 newMaturedVotingPower = oldestTranche.amount;\\n\\n\\t\\t// add new matured voting power\\n\\t\\t// calculate number of passed indexes between last update until fully matured index\\n\\t\\tuint56 indexesPassed = fullyMaturedFinishedIndex - _userGradual.lastUpdatedTrancheIndex;\\n\\t\\t_userGradual.rawUnmaturedVotingPower += _userGradual.maturingAmount * indexesPassed;\\n\\n\\t\\t// update new fully-matured voting power\\n\\t\\tuint56 newMaturedAsRawUnmatured = _getMaturedAsRawUnmaturedAmount(newMaturedVotingPower);\\n\\n\\t\\t// update user gradual values in respect of new fully-matured amount\\n\\t\\t// remove new fully matured voting power from non matured raw one\\n\\t\\t_userGradual.rawUnmaturedVotingPower -= newMaturedAsRawUnmatured;\\n\\t\\t// add new fully-matured voting power\\n\\t\\t_userGradual.maturedVotingPower += newMaturedVotingPower;\\n\\t\\t// remove new fully-matured power from maturing amount\\n\\t\\t_userGradual.maturingAmount -= newMaturedVotingPower;\\n\\n\\t\\t// add next tranche as oldest\\n\\t\\t_setNextOldestUserTranchePosition(_userGradual);\\n\\n\\t\\t// update last updated index until fully matured index\\n\\t\\t_userGradual.lastUpdatedTrancheIndex = fullyMaturedFinishedIndex;\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns index at which the maturing will finish\\n\\t * @dev\\n\\t * e.g. if FULL_POWER_TRANCHES_COUNT=2 and passing index=1,\\n\\t * maturing will complete at the end of index 2.\\n\\t * This is the index we return, similar to last finished index.\\n\\t *\\n\\t * @param index index from which to derive fully matured finished index\\n\\t */\\n\\tfunction _getFullyMaturedAtFinishedIndex(uint256 index) private pure returns (uint16) {\\n\\t\\treturn uint16(index + FULL_POWER_TRANCHES_COUNT - 1);\\n\\t}\\n\\n\\t/**\\n\\t * @notice updates user oldest tranche position to next one in memory\\n\\t * @dev this is done after an oldest tranche position matures\\n\\t * If oldest tranch position is same as latest one, all user\\n\\t * tranches have matured. In this case we remove tranhe positions from the user\\n\\t *\\n\\t * @param _userGradual user gradual struct to update\\n\\t */\\n\\tfunction _setNextOldestUserTranchePosition(UserGradual memory _userGradual) private pure {\\n\\t\\t// if oldest tranche is same as latest, this was the last tranche and we remove it from the user\\n\\t\\tif (\\n\\t\\t\\t_userGradual.oldestTranchePosition.arrayIndex == _userGradual.latestTranchePosition.arrayIndex &&\\n\\t\\t\\t_userGradual.oldestTranchePosition.position == _userGradual.latestTranchePosition.position\\n\\t\\t) {\\n\\t\\t\\t// reset user tranches as all of them matured\\n\\t\\t\\t_userGradual.oldestTranchePosition = UserTranchePosition(0, 0);\\n\\t\\t} else {\\n\\t\\t\\t// set next user tranche as oldest\\n\\t\\t\\t_userGradual.oldestTranchePosition = _getNextUserTranchePosition(_userGradual.oldestTranchePosition);\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: GLOBAL HELPER FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice returns total gradual voting power from `global`\\n\\t * @dev the returned amount is untrimmed\\n\\t *\\n\\t * @param global global gradual struct\\n\\t * @return totalGradualVotingPower total gradual voting power (fully-matured + maturing)\\n\\t */\\n\\tfunction _getTotalGradualVotingPower(GlobalGradual memory global) private pure returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\t_untrim(global.totalMaturedVotingPower) +\\n\\t\\t\\t_getMaturingVotingPowerFromRaw(_untrim(global.totalRawUnmaturedVotingPower));\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns global tranche storage struct\\n\\t * @dev we return struct, so we can manipulate the storage in other functions\\n\\t *\\n\\t * @param index tranche index\\n\\t * @return tranche tranche storage struct\\n\\t */\\n\\tfunction _getTranche(uint256 index) private view returns (Tranche storage) {\\n\\t\\tuint256 arrayindex = index / TRANCHES_PER_WORD;\\n\\n\\t\\tGlobalTranches storage globalTranches = indexedGlobalTranches[arrayindex];\\n\\n\\t\\tuint256 globalTranchesPosition = index % TRANCHES_PER_WORD;\\n\\n\\t\\tif (globalTranchesPosition == 0) {\\n\\t\\t\\treturn globalTranches.zero;\\n\\t\\t} else if (globalTranchesPosition == 1) {\\n\\t\\t\\treturn globalTranches.one;\\n\\t\\t} else if (globalTranchesPosition == 2) {\\n\\t\\t\\treturn globalTranches.two;\\n\\t\\t} else if (globalTranchesPosition == 3) {\\n\\t\\t\\treturn globalTranches.three;\\n\\t\\t} else {\\n\\t\\t\\treturn globalTranches.four;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: USER HELPER FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice gets `user` `tranche` at position\\n\\t *\\n\\t * @param user user address to get tranche from\\n\\t * @param userTranchePosition position to get the `tranche` from\\n\\t * @return tranche `user` tranche\\n\\t */\\n\\tfunction _getUserTranche(address user, UserTranchePosition memory userTranchePosition)\\n\\t\\tprivate\\n\\t\\tview\\n\\t\\treturns (UserTranche memory tranche)\\n\\t{\\n\\t\\tUserTranches storage _userTranches = userTranches[user][userTranchePosition.arrayIndex];\\n\\n\\t\\tif (userTranchePosition.position == 0) {\\n\\t\\t\\ttranche = _userTranches.zero;\\n\\t\\t} else if (userTranchePosition.position == 1) {\\n\\t\\t\\ttranche = _userTranches.one;\\n\\t\\t} else if (userTranchePosition.position == 2) {\\n\\t\\t\\ttranche = _userTranches.two;\\n\\t\\t} else {\\n\\t\\t\\ttranche = _userTranches.three;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice return last matured tranche index\\n\\t *\\n\\t * @return lastMaturedIndex last matured tranche index\\n\\t */\\n\\tfunction _getLastMaturedIndex() private view returns (uint16 lastMaturedIndex) {\\n\\t\\tuint256 currentTrancheIndex = getCurrentTrancheIndex();\\n\\t\\tif (currentTrancheIndex > FULL_POWER_TRANCHES_COUNT) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\tlastMaturedIndex = uint16(currentTrancheIndex - FULL_POWER_TRANCHES_COUNT);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns the user gradual voting power (fully-matured and maturing)\\n\\t * @dev the returned amount is untrimmed\\n\\t *\\n\\t * @param _userGradual user gradual struct\\n\\t * @return userGradualVotingPower user gradual voting power (fully-matured + maturing)\\n\\t */\\n\\tfunction _getUserGradualVotingPower(UserGradual memory _userGradual) private pure returns (uint256) {\\n\\t\\treturn\\n\\t\\t\\t_untrim(_userGradual.maturedVotingPower) +\\n\\t\\t\\t_getMaturingVotingPowerFromRaw(_untrim(_userGradual.rawUnmaturedVotingPower));\\n\\t}\\n\\n\\t/**\\n\\t * @notice returns next user tranche position, based on current one\\n\\t *\\n\\t * @param currentTranchePosition current user tranche position\\n\\t * @return nextTranchePosition next tranche position of `currentTranchePosition`\\n\\t */\\n\\tfunction _getNextUserTranchePosition(UserTranchePosition memory currentTranchePosition)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (UserTranchePosition memory nextTranchePosition)\\n\\t{\\n\\t\\tif (currentTranchePosition.arrayIndex == 0) {\\n\\t\\t\\tnextTranchePosition.arrayIndex = 1;\\n\\t\\t} else {\\n\\t\\t\\tif (currentTranchePosition.position < 3) {\\n\\t\\t\\t\\tnextTranchePosition.arrayIndex = currentTranchePosition.arrayIndex;\\n\\t\\t\\t\\tnextTranchePosition.position = currentTranchePosition.position + 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnextTranchePosition.arrayIndex = currentTranchePosition.arrayIndex + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice check if user requires maturing\\n\\t *\\n\\t * @param _userGradual user gradual struct to update\\n\\t * @param lastFinishedTrancheIndex index of last finished tranche index\\n\\t * @return needsMaturing true if user needs maturing, else false\\n\\t */\\n\\tfunction _isMaturing(UserGradual memory _userGradual, uint256 lastFinishedTrancheIndex)\\n\\t\\tprivate\\n\\t\\tpure\\n\\t\\treturns (bool)\\n\\t{\\n\\t\\treturn _userGradual.lastUpdatedTrancheIndex < lastFinishedTrancheIndex && _hasTranches(_userGradual);\\n\\t}\\n\\n\\t/**\\n\\t * @notice check if user gradual has any non-matured tranches\\n\\t *\\n\\t * @param _userGradual user gradual struct\\n\\t * @return hasTranches true if user has non-matured tranches\\n\\t */\\n\\tfunction _hasTranches(UserGradual memory _userGradual) private pure returns (bool hasTranches) {\\n\\t\\tif (_userGradual.oldestTranchePosition.arrayIndex > 0) {\\n\\t\\t\\thasTranches = true;\\n\\t\\t}\\n\\t}\\n\\n\\t/* ---------- GRADUAL POWER: HELPER FUNCTIONS ---------- */\\n\\n\\t/**\\n\\t * @notice return trimmed amount\\n\\t * @dev `amount` is trimmed by `TRIM_SIZE`.\\n\\t * This is done so the amount can be represented in 48bits.\\n\\t * This still gives us enough accuracy so the core logic is not affected.\\n\\t *\\n\\t * @param amount amount to trim\\n\\t * @return trimmedAmount amount divided by `TRIM_SIZE`\\n\\t */\\n\\tfunction _trim(uint256 amount) private pure returns (uint48) {\\n\\t\\treturn uint48(amount / TRIM_SIZE);\\n\\t}\\n\\n\\t/**\\n\\t * @notice return trimmed amount rounding up if any dust left\\n\\t *\\n\\t * @param amount amount to trim\\n\\t * @return trimmedAmount amount divided by `TRIM_SIZE`, rounded up\\n\\t */\\n\\tfunction _trimRoundUp(uint256 amount) private pure returns (uint48 trimmedAmount) {\\n\\t\\ttrimmedAmount = _trim(amount);\\n\\t\\tif (_untrim(trimmedAmount) < amount) {\\n\\t\\t\\tunchecked {\\n\\t\\t\\t\\ttrimmedAmount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice untrim `trimmedAmount` in respect to `TRIM_SIZE`\\n\\t *\\n\\t * @param trimmedAmount amount previously trimemd\\n\\t * @return untrimmedAmount untrimmed amount\\n\\t */\\n\\tfunction _untrim(uint256 trimmedAmount) private pure returns (uint256) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn trimmedAmount * TRIM_SIZE;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n\\t * @notice calculates voting power from raw unmatured\\n\\t *\\n\\t * @param rawMaturingVotingPower raw maturing voting power amount\\n\\t * @return maturingVotingPower actual maturing power amount\\n\\t */\\n\\tfunction _getMaturingVotingPowerFromRaw(uint256 rawMaturingVotingPower) private pure returns (uint256) {\\n\\t\\treturn rawMaturingVotingPower / FULL_POWER_TRANCHES_COUNT;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns amount represented in raw unmatured value\\n\\t * @dev used to substract fully-matured amount from raw unmatured, when amount matures\\n\\t *\\n\\t * @param amount matured amount\\n\\t * @return asRawUnmatured `amount` multiplied by `FULL_POWER_TRANCHES_COUNT` (raw unmatured amount)\\n\\t */\\n\\tfunction _getMaturedAsRawUnmaturedAmount(uint48 amount) private pure returns (uint56) {\\n\\t\\tunchecked {\\n\\t\\t\\treturn uint56(amount * FULL_POWER_TRANCHES_COUNT);\\n\\t\\t}\\n\\t}\\n\\n\\t/* ========== OWNER FUNCTIONS ========== */\\n\\n\\t/**\\n\\t * @notice Sets or resets the instant minter address\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the owner of the contract\\n\\t * - the minter must not be the zero address\\n\\t *\\n\\t * @param _minter address to set\\n\\t * @param _set true to set, false to reset\\n\\t */\\n\\tfunction setMinter(address _minter, bool _set) external onlyOwner {\\n\\t\\trequire(_minter != address(0), \\\"voSPOOL::setMinter: minter cannot be the zero address\\\");\\n\\t\\tminters[_minter] = _set;\\n\\t\\temit MinterSet(_minter, _set);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Sets or resets the gradual minter address\\n\\t *\\n\\t * Requirements:\\n\\t *\\n\\t * - the caller must be the owner of the contract\\n\\t * - the minter must not be the zero address\\n\\t *\\n\\t * @param _gradualMinter address to set\\n\\t * @param _set true to set, false to reset\\n\\t */\\n\\tfunction setGradualMinter(address _gradualMinter, bool _set) external onlyOwner {\\n\\t\\trequire(_gradualMinter != address(0), \\\"voSPOOL::setGradualMinter: gradual minter cannot be the zero address\\\");\\n\\t\\tgradualMinters[_gradualMinter] = _set;\\n\\t\\temit GradualMinterSet(_gradualMinter, _set);\\n\\t}\\n\\n\\t/* ========== RESTRICTION FUNCTIONS ========== */\\n\\n\\t/**\\n\\t * @notice Ensures the caller is the instant minter\\n\\t */\\n\\tfunction _onlyMinter() private view {\\n\\t\\trequire(minters[msg.sender], \\\"voSPOOL::_onlyMinter: Insufficient Privileges\\\");\\n\\t}\\n\\n\\t/**\\n\\t * @notice Ensures the caller is the gradual minter\\n\\t */\\n\\tfunction _onlyGradualMinter() private view {\\n\\t\\trequire(gradualMinters[msg.sender], \\\"voSPOOL::_onlyGradualMinter: Insufficient Privileges\\\");\\n\\t}\\n\\n\\t/* ========== MODIFIERS ========== */\\n\\n\\t/**\\n\\t * @notice Throws if the caller is not the instant miter\\n\\t */\\n\\tmodifier onlyMinter() {\\n\\t\\t_onlyMinter();\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Throws if the caller is not the gradual minter\\n\\t */\\n\\tmodifier onlyGradualMinter() {\\n\\t\\t_onlyGradualMinter();\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Update global gradual values\\n\\t */\\n\\tmodifier updateGradual() {\\n\\t\\t_updateGradual();\\n\\t\\t_;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Update user gradual values\\n\\t */\\n\\tmodifier updateGradualUser(address user) {\\n\\t\\t_updateGradualUser(user);\\n\\t\\t_;\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/external/@openzeppelin/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/external/spool-core/SpoolOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\nimport \\\"./interfaces/ISpoolOwner.sol\\\";\\n\\nabstract contract SpoolOwnable {\\n    ISpoolOwner internal immutable spoolOwner;\\n    \\n    constructor(ISpoolOwner _spoolOwner) {\\n        require(\\n            address(_spoolOwner) != address(0),\\n            \\\"SpoolOwnable::constructor: Spool owner contract address cannot be 0\\\"\\n        );\\n\\n        spoolOwner = _spoolOwner;\\n    }\\n\\n    function isSpoolOwner() internal view returns(bool) {\\n        return spoolOwner.isSpoolOwner(msg.sender);\\n    }\\n\\n    function _onlyOwner() internal view {\\n        require(isSpoolOwner(), \\\"SpoolOwnable::onlyOwner: Caller is not the Spool owner\\\");\\n    }\\n\\n    modifier onlyOwner() {\\n        _onlyOwner();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/spool-core/interfaces/ISpoolOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\ninterface ISpoolOwner {\\n    function isSpoolOwner(address user) external view returns(bool);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IVoSPOOL.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.13;\\n\\n/* ========== STRUCTS ========== */\\n\\n/**\\n * @notice global gradual struct\\n * @member totalMaturedVotingPower total fully-matured voting power amount\\n * @member totalMaturingAmount total maturing amount (amount of power that is accumulating every week for 1/156 of the amount)\\n * @member totalRawUnmaturedVotingPower total raw voting power still maturing every tranche (totalRawUnmaturedVotingPower/156 is its voting power)\\n * @member lastUpdatedTrancheIndex last (finished) tranche index global gradual has updated\\n */\\nstruct GlobalGradual {\\n\\tuint48 totalMaturedVotingPower;\\n\\tuint48 totalMaturingAmount;\\n\\tuint56 totalRawUnmaturedVotingPower;\\n\\tuint16 lastUpdatedTrancheIndex;\\n}\\n\\n/**\\n * @notice user tranche position struct, pointing at user tranche\\n * @dev points at `userTranches` mapping\\n * @member arrayIndex points at `userTranches`\\n * @member position points at UserTranches position from zero to three (zero, one, two, or three)\\n */\\nstruct UserTranchePosition {\\n\\tuint16 arrayIndex;\\n\\tuint8 position;\\n}\\n\\n/**\\n * @notice user gradual struct, similar to global gradual holds user gragual voting power values\\n * @dev points at `userTranches` mapping\\n * @member maturedVotingPower users fully-matured voting power amount\\n * @member maturingAmount users maturing amount\\n * @member rawUnmaturedVotingPower users raw voting power still maturing every tranche\\n * @member oldestTranchePosition UserTranchePosition pointing at the oldest unmatured UserTranche\\n * @member latestTranchePosition UserTranchePosition pointing at the latest unmatured UserTranche\\n * @member lastUpdatedTrancheIndex last (finished) tranche index user gradual has updated\\n */\\nstruct UserGradual {\\n\\tuint48 maturedVotingPower; // matured voting amount, power accumulated and older than FULL_POWER_TIME, not accumulating anymore\\n\\tuint48 maturingAmount; // total maturing amount (also maximum matured)\\n\\tuint56 rawUnmaturedVotingPower; // current user raw unmatured voting power (increases every new tranche), actual unmatured voting power can be calculated as unmaturedVotingPower / FULL_POWER_TRANCHES_COUNT\\n\\tUserTranchePosition oldestTranchePosition; // if arrayIndex is 0, user has no tranches (even if `latestTranchePosition` is not empty)\\n\\tUserTranchePosition latestTranchePosition; // can only increment, in case of tranche removal, next time user gradually mints we point at tranche at next position\\n\\tuint16 lastUpdatedTrancheIndex;\\n}\\n\\n/**\\n * @title Spool DAO Voting Token interface\\n */\\ninterface IVoSPOOL {\\n\\t/* ========== FUNCTIONS ========== */\\n\\n\\tfunction mint(address, uint256) external;\\n\\n\\tfunction burn(address, uint256) external;\\n\\n\\tfunction mintGradual(address, uint256) external;\\n\\n\\tfunction burnGradual(\\n\\t\\taddress,\\n\\t\\tuint256,\\n\\t\\tbool\\n\\t) external;\\n\\n\\tfunction updateVotingPower() external;\\n\\n\\tfunction updateUserVotingPower(address user) external;\\n\\n\\tfunction getTotalGradualVotingPower() external returns (uint256);\\n\\n\\tfunction getUserGradualVotingPower(address user) external returns (uint256);\\n\\n\\tfunction getNotUpdatedUserGradual(address user) external view returns (UserGradual memory);\\n\\n\\tfunction getNotUpdatedGlobalGradual() external view returns (GlobalGradual memory);\\n\\n\\tfunction getCurrentTrancheIndex() external view returns (uint16);\\n\\n\\tfunction getLastFinishedTrancheIndex() external view returns (uint16);\\n\\n\\t/* ========== EVENTS ========== */\\n\\n\\tevent Minted(address indexed recipient, uint256 amount);\\n\\n\\tevent Burned(address indexed source, uint256 amount);\\n\\n\\tevent GradualMinted(address indexed recipient, uint256 amount);\\n\\n\\tevent GradualBurned(address indexed source, uint256 amount, bool burnAll);\\n\\n\\tevent GlobalGradualUpdated(\\n\\t\\tuint16 indexed lastUpdatedTrancheIndex,\\n\\t\\tuint48 totalMaturedVotingPower,\\n\\t\\tuint48 totalMaturingAmount,\\n\\t\\tuint56 totalRawUnmaturedVotingPower\\n\\t);\\n\\n\\tevent UserGradualUpdated(\\n\\t\\taddress indexed user,\\n\\t\\tuint16 indexed lastUpdatedTrancheIndex,\\n\\t\\tuint48 maturedVotingPower,\\n\\t\\tuint48 maturingAmount,\\n\\t\\tuint56 rawUnmaturedVotingPower\\n\\t);\\n\\n\\tevent MinterSet(address indexed minter, bool set);\\n\\n\\tevent GradualMinterSet(address indexed minter, bool set);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ISpoolOwner\",\"name\":\"_spoolOwner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_firstTrancheEndTime\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"totalMaturedVotingPower\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"totalMaturingAmount\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint56\",\"name\":\"totalRawUnmaturedVotingPower\",\"type\":\"uint56\"}],\"name\":\"GlobalGradualUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"burnAll\",\"type\":\"bool\"}],\"name\":\"GradualBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GradualMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"GradualMinterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"set\",\"type\":\"bool\"}],\"name\":\"MinterSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"maturedVotingPower\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint48\",\"name\":\"maturingAmount\",\"type\":\"uint48\"},{\"indexed\":false,\"internalType\":\"uint56\",\"name\":\"rawUnmaturedVotingPower\",\"type\":\"uint56\"}],\"name\":\"UserGradualUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"FULL_POWER_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FULL_POWER_TRANCHES_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANCHE_TIME\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"burnAll\",\"type\":\"bool\"}],\"name\":\"burnGradual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"firstTrancheStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTrancheIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGlobalGradual\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"totalMaturedVotingPower\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"totalMaturingAmount\",\"type\":\"uint48\"},{\"internalType\":\"uint56\",\"name\":\"totalRawUnmaturedVotingPower\",\"type\":\"uint56\"},{\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct GlobalGradual\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastFinishedTrancheIndex\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextTrancheEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNotUpdatedGlobalGradual\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"totalMaturedVotingPower\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"totalMaturingAmount\",\"type\":\"uint48\"},{\"internalType\":\"uint56\",\"name\":\"totalRawUnmaturedVotingPower\",\"type\":\"uint56\"},{\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct GlobalGradual\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getNotUpdatedUserGradual\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"maturedVotingPower\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturingAmount\",\"type\":\"uint48\"},{\"internalType\":\"uint56\",\"name\":\"rawUnmaturedVotingPower\",\"type\":\"uint56\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"arrayIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct UserTranchePosition\",\"name\":\"oldestTranchePosition\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"arrayIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct UserTranchePosition\",\"name\":\"latestTranchePosition\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct UserGradual\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalGradualVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trancheIndex\",\"type\":\"uint256\"}],\"name\":\"getTrancheEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"getTrancheIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserGradual\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"maturedVotingPower\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"maturingAmount\",\"type\":\"uint48\"},{\"internalType\":\"uint56\",\"name\":\"rawUnmaturedVotingPower\",\"type\":\"uint56\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"arrayIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct UserTranchePosition\",\"name\":\"oldestTranchePosition\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"arrayIndex\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"position\",\"type\":\"uint8\"}],\"internalType\":\"struct UserTranchePosition\",\"name\":\"latestTranchePosition\",\"type\":\"tuple\"},{\"internalType\":\"uint16\",\"name\":\"lastUpdatedTrancheIndex\",\"type\":\"uint16\"}],\"internalType\":\"struct UserGradual\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserGradualVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gradualMinters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexedGlobalTranches\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"}],\"internalType\":\"struct Tranche\",\"name\":\"zero\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"}],\"internalType\":\"struct Tranche\",\"name\":\"one\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"}],\"internalType\":\"struct Tranche\",\"name\":\"two\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"}],\"internalType\":\"struct Tranche\",\"name\":\"three\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"}],\"internalType\":\"struct Tranche\",\"name\":\"four\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintGradual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gradualMinter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"setGradualMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_set\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalInstantPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"updateUserVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateVotingPower\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInstantPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userTranches\",\"outputs\":[{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"internalType\":\"struct UserTranche\",\"name\":\"zero\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"internalType\":\"struct UserTranche\",\"name\":\"one\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"internalType\":\"struct UserTranche\",\"name\":\"two\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint48\",\"name\":\"amount\",\"type\":\"uint48\"},{\"internalType\":\"uint16\",\"name\":\"index\",\"type\":\"uint16\"}],\"internalType\":\"struct UserTranche\",\"name\":\"three\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VoSPOOL", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "0000000000000000000000004f03f70a99e5c3b49d733ddd7458f80fa9b5a5b50000000000000000000000000000000000000000000000000000000062464080", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}