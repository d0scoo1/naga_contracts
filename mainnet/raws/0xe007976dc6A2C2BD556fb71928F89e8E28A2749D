{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/Multi165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IERC165 {function supportsInterface(bytes4 interfaceId) external view returns (bool);}\\n\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n}\\n\\ncontract Multi165 {\\n\\n    function supportsInterface(IERC165[] calldata contracts, bytes4 interfaceId) public view returns (bool[] memory result) {\\n        result = new bool[](contracts.length);\\n        for(uint256 i = 0; i < contracts.length; i++) {\\n            if (!Address.isContract(address(contracts[i]))) {\\n                continue;\\n            }\\n            try contracts[i].supportsInterface{gas: 30000}(interfaceId) returns (bool a) {\\n                result[i] = a;\\n            } catch {\\n                // ensure there was enough gas ( >= 30,000) given to the `supportsInterface` call\\n                // Note that `{gas: 30000}` do not ensure that, it only protect the caller to not spend more than 30,000.\\n                assert(gasleft() > 476); // 30,000 / 63\\n            }\\n        }\\n    }\\n\\n    function supportsMultipleInterfaces(IERC165[] calldata contracts, bytes4[] calldata interfaceIds) public view returns (bool[] memory result) {\\n        result = new bool[](contracts.length);\\n        uint256 numI = contracts.length;\\n        for(uint256 i = 0; i < numI; i++) {\\n            if (!Address.isContract(address(contracts[i]))) {\\n                continue;\\n            }\\n\\n            // asume true and set to false once one interfaceId is found to be not supported.\\n            result[i] = true;\\n            uint256 numJ = interfaceIds.length;\\n            for (uint256 j = 0; j < numJ; j ++) {\\n                bytes4 interfaceId = interfaceIds[j];\\n                try contracts[i].supportsInterface{gas: 30000}(interfaceId) returns (bool a) {\\n                    if (!a) {\\n                        result[i] = false;\\n                        break;\\n                    }\\n                } catch {\\n                    // ensure there was enough gas ( >= 30,000) given to the `supportsInterface` call\\n                    // Note that `{gas: 30000}` do not ensure that, it only protect the caller to not spend more than 30,000.\\n                    assert(gasleft() > 476); // 30,000 / 63\\n                    result[i] = false;\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC165[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"result\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC165[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"bytes4[]\",\"name\":\"interfaceIds\",\"type\":\"bytes4[]\"}],\"name\":\"supportsMultipleInterfaces\",\"outputs\":[{\"internalType\":\"bool[]\",\"name\":\"result\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Multi165", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}