{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Renderer/ISuperglyphsRenderer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '../utils/Randomize.sol';\\n\\n/// @title ISuperglyphsRenderer\\n/// @author Simon Fremaux (@dievardump)\\ninterface ISuperglyphsRenderer {\\n    struct Configuration {\\n        uint256 seed;\\n        uint256 mod;\\n        int256 z1;\\n        int256 z2;\\n        bool randStroke;\\n        bool fullSymmetry;\\n        bool darkTheme;\\n        bytes9[2] colors;\\n        bytes16 symbols;\\n    }\\n\\n    function start(\\n        uint256 seed,\\n        uint256 colorSeed,\\n        bytes16 selectedColors,\\n        bytes16 selectedSymbols\\n    )\\n        external\\n        pure\\n        returns (Randomize.Random memory random, Configuration memory config);\\n\\n    /// @dev Rendering function\\n    /// @param name the token name\\n    /// @param tokenId the tokenId\\n    /// @param colorSeed the seed used for coloring, if no color selected\\n    /// @param selectedColors the user selected colors\\n    /// @param selectedSymbols the symbols selected by the user\\n    /// @param frozen if the token customization is frozen\\n    /// @return the json\\n    function render(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 colorSeed,\\n        bytes16 selectedColors,\\n        bytes16 selectedSymbols,\\n        bool frozen\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/Renderer/SuperglyphsRenderer.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\n\\nimport '../utils/Randomize.sol';\\nimport '../utils/DynamicBuffer.sol';\\nimport '../utils/Base64.sol';\\n\\nimport './ISuperglyphsRenderer.sol';\\n\\ninterface ISuperglyphs {\\n    function getSymbol(uint256 symbolId, Randomize.Random memory random)\\n        external\\n        view\\n        returns (bytes memory);\\n}\\n\\n/// @title SuperglyphsRenderer\\n/// @author Simon Fremaux (@dievardump)\\ncontract SuperglyphsRenderer is ISuperglyphsRenderer {\\n    using Strings for uint256;\\n    using Randomize for Randomize.Random;\\n\\n    int256 public constant HALF = 24;\\n    uint256 public constant CELL_SIZE = 44;\\n    uint256 public constant SEED_BOUND = 0xfffffff;\\n\\n    constructor() {}\\n\\n    function start(\\n        uint256 seed,\\n        uint256 colorSeed,\\n        bytes16 selectedColors,\\n        bytes16 selectedSymbols\\n    )\\n        public\\n        pure\\n        returns (Randomize.Random memory random, Configuration memory config)\\n    {\\n        random = Randomize.Random({seed: seed});\\n\\n        config = _getConfiguration(\\n            random,\\n            seed,\\n            colorSeed,\\n            selectedColors,\\n            selectedSymbols\\n        );\\n    }\\n\\n    /// @dev Rendering function\\n    /// @param name the token name\\n    /// @param tokenId the tokenId\\n    /// @param colorSeed the seed used for coloring, if no color selected\\n    /// @param selectedColors the user selected colors\\n    /// @param selectedSymbols the symbols selected by the user\\n    /// @param frozen if the token customization is frozen\\n    /// @return the json\\n    function render(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 colorSeed,\\n        bytes16 selectedColors,\\n        bytes16 selectedSymbols,\\n        bool frozen\\n    ) external view returns (string memory) {\\n        (Randomize.Random memory random, Configuration memory config) = start(\\n            tokenId,\\n            colorSeed,\\n            selectedColors,\\n            selectedSymbols\\n        );\\n\\n        (, bytes memory buffer) = DynamicBuffer.allocate(100000);\\n\\n        DynamicBuffer.appendBytes(\\n            buffer,\\n            \\\"%3Csvg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 2464 2464' width='2464' height='2464'%3E%3Cdefs%3E\\\"\\n        );\\n\\n        _addGradient(buffer, config, random);\\n        _addSymbols(buffer, config);\\n        _fill(buffer, config, random);\\n\\n        {\\n            bool yMirror = random.next(0, 10) < 8;\\n            DynamicBuffer.appendBytes(\\n                buffer,\\n                abi.encodePacked(\\n                    \\\"%3Cmask id='mask' stroke-width='\\\",\\n                    (config.randStroke ? random.next(4, 8).toString() : '4'),\\n                    \\\"'%3E\\\",\\n                    \\\"%3Cuse href='%23left'/%3E%3Cuse href='%23left' transform='translate(-352, \\\",\\n                    yMirror ? '-352' : '0',\\n                    ') scale(-1, ',\\n                    yMirror ? '-1' : '1',\\n                    \\\")' transform-origin='50%25 50%25'/%3E\\\",\\n                    '%3C/mask%3E',\\n                    '%3C/defs%3E'\\n                )\\n            );\\n        }\\n\\n        DynamicBuffer.appendBytes(\\n            buffer,\\n            abi.encodePacked(\\n                \\\"%3Crect width='100%25' height='100%25' fill='\\\",\\n                (config.darkTheme ? '%23000' : '%23fff'),\\n                \\\"'/%3E\\\",\\n                \\\"%3Cg transform='translate(176, 176)'%3E%3Crect width='2112' height='2112' fill='url(%23gr)' mask='url(%23mask)'/%3E%3C/g%3E\\\",\\n                '%3C/svg%3E'\\n            )\\n        );\\n\\n        // stack too deep \\\"quick fix\\\"\\n        string[6] memory data = [\\n            tokenId.toString(),\\n            config.mod.toString(),\\n            (tokenId % SEED_BOUND).toString(),\\n            string(\\n                abi.encodePacked(\\n                    '[{\\\"trait_type\\\":\\\"Customizable\\\",\\\"value\\\":\\\"',\\n                    ((frozen == false) ? 'Yes' : 'No'),\\n                    '\\\"},{\\\"trait_type\\\":\\\"Colors\\\",\\\"value\\\":\\\"',\\n                    ((selectedColors == 0) ? 'Auto' : 'Custom'),\\n                    '\\\"},{\\\"trait_type\\\":\\\"Symbols\\\",\\\"value\\\":\\\"',\\n                    ((selectedSymbols == 0) ? 'Auto' : 'Custom'),\\n                    '\\\"},{\\\"trait_type\\\":\\\"Last refresh\\\",\\\"value\\\":\\\"',\\n                    _getDateTime(),\\n                    '\\\"}]'\\n                )\\n            ),\\n            string(_getDescription(frozen, tokenId)),\\n            name\\n        ];\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    'data:application/json;base64,',\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            '{\\\"image\\\":\\\"data:image/svg+xml;utf8,',\\n                            buffer,\\n                            '\\\",\\\"seed\\\":\\\"',\\n                            data[0],\\n                            '\\\",\\\"mod\\\":\\\"',\\n                            data[1],\\n                            '\\\",\\\"base\\\":\\\"',\\n                            data[2],\\n                            '\\\",\\\"attributes\\\":',\\n                            data[3],\\n                            ',\\\"license\\\":\\\"Full ownership with unlimited commercial rights.\\\",\\\"creator\\\":\\\"dievardump\\\"'\\n                            ',\\\"description\\\":',\\n                            data[4],\\n                            ',\\\"name\\\":\\\"',\\n                            data[5],\\n                            '\\\"}'\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function _getDescription(bool frozen, uint256 tokenId)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                '\\\"Superglyphs.sol\\\\\\\\n\\\\\\\\n',\\n                (\\n                    frozen\\n                        ? 'This Superglyph has been frozen and can not be customized anymore.'\\n                        : string(\\n                            abi.encodePacked(\\n                                'Name, Symbols and Colors customizable at [https://solSeedlings.art](https://solSeedlings.art/superglyphs/',\\n                                tokenId.toString(),\\n                                '). Non-customized tokens will change colors when they change owner.'\\n                            )\\n                        )\\n                ),\\n                '\\\\\\\\n\\\\\\\\nSuperglyphs.sol is the third of the [sol]Seedlings, an experiment of art and collectible NFTs 100% generated with Solidity.\\\\\\\\n\\\\\\\\nLicense: Full ownership with unlimited commercial rights.\\\\\\\\n\\\\\\\\nMore info at [https://solSeedlings.art](https://solSeedlings.art)\\\\\\\\n\\\\\\\\nby @dievardump with <3\\\"'\\n            );\\n    }\\n\\n    function _getConfiguration(\\n        Randomize.Random memory random,\\n        uint256 seed,\\n        uint256 colorSeed,\\n        bytes16 selectedColors,\\n        bytes16 selectedSymbols\\n    ) internal pure returns (Configuration memory config) {\\n        config.seed = seed;\\n        config.mod = random.next(5, 16);\\n\\n        // z1 and z2 are kind of Z offsets\\n        config.z1 = int256(random.next(2, 500));\\n\\n        // z1 == z2 means full symmetry\\n        config.z2 = random.next(0, 10) < 3\\n            ? int256(random.next(501, 1000))\\n            : config.z1;\\n\\n        // 1 out of 10 have random stroke size\\n        config.randStroke = random.next(0, 10) < 1;\\n\\n        // 50 / 50 chance dark / light\\n        config.darkTheme = random.next(0, 10) < 5;\\n\\n        // colors and symbols can be modified by the owner of a token\\n        // therefore they do not use the main PRNG, as to not modify the other values\\n        // when they change\\n\\n        // get colors\\n        if (selectedColors != 0) {\\n            config.colors = [\\n                bytes9(\\n                    abi.encodePacked(\\n                        '%23',\\n                        selectedColors[1],\\n                        selectedColors[2],\\n                        selectedColors[3],\\n                        selectedColors[4],\\n                        selectedColors[5],\\n                        selectedColors[6]\\n                    )\\n                ),\\n                bytes9(\\n                    abi.encodePacked(\\n                        '%23',\\n                        selectedColors[8],\\n                        selectedColors[9],\\n                        selectedColors[10],\\n                        selectedColors[11],\\n                        selectedColors[12],\\n                        selectedColors[13]\\n                    )\\n                )\\n            ];\\n        } else {\\n            config.colors = _getColors(colorSeed, config.darkTheme);\\n        }\\n\\n        // those are simple preset symbols automatically selected when user doesn't custom\\n        if (selectedSymbols == 0) {\\n            // select symbols\\n            selectedSymbols = [\\n                bytes16(0x01020000000000000000000000000000), // vertical, horizontal\\n                bytes16(0x01020304050000000000000000000000), // vert, hor, diag1, diag2, cross\\n                bytes16(0x01020600000000000000000000000000), // vert, hor, circle\\n                bytes16(0x0C0D0700000000000000000000000000), // rounded 512Print 1, rounded 2, circle with dot\\n                bytes16(0x03040000000000000000000000000000), // diag 1, diag 2\\n                bytes16(0x1A0A0900000000000000000000000000), // circle with dot, square with square, square with cross\\n                bytes16(0x03040500000000000000000000000000), // diagonal 1, diagonal 2, cross\\n                bytes16(0x06050800000000000000000000000000), // cross, circle, square\\n                bytes16(0x01020B00000000000000000000000000), // plus, horizontal, vertical\\n                bytes16(0x01020B0C0D0000000000000000000000), // vert, hor, plus, rounded 512Print 1, rounded 2\\n                bytes16(0x0E0F1011000000000000000000000000), // sides\\n                bytes16(0x12131415000000000000000000000000), // triangles\\n                bytes16(0x1C1D1E00000000000000000000000000), // vert hor plus animated\\n                bytes16(0x1F1F1F00000000000000000000000000), // random squares\\n                bytes16(0x1B1B1B00000000000000000000000000), // animated squares\\n                bytes16(0x20030421000000000000000000000000), // longer (diagonals, verticals, horizontals)\\n                bytes16(0x22002200220000000000000000000000), // growing lines\\n                bytes16(0x23241A0A090000000000000000000000), // stroked square, stroked circle, circle with dot, square with square, square with cross\\n                bytes16(0x25002600270000000000000000000000), // 3 circles, barred circle, double triangle\\n                bytes16(0x28002800280000000000000000000000) // hashtags\\n            ][seed % 20];\\n\\n            // what follows is a simple way to \\\"shuffle\\\" the selected symbols\\n            // 1) create an array of indexes.\\n            // 2) pick an index randomly\\n            // 3) replace this index by last index available\\n            // 4) decrement size of the array\\n\\n            // create a PRNG specifically for symbols distribution\\n            // this way the random in symbol distribution does not affect the global random\\n            // else it will change the rendering when symbols are updated\\n            Randomize.Random memory random2 = Randomize.Random({\\n                seed: uint256(keccak256(abi.encode(seed)))\\n            });\\n\\n            // create an array containing indexes 0 - config.mod\\n            uint256 temp = config.mod;\\n            uint256[] memory available = new uint256[](config.mod);\\n            for (uint256 i; i < temp; i++) {\\n                available[i] = i;\\n            }\\n\\n            // shuffle the symbols using the array of indexes\\n            bytes memory selected = new bytes(config.mod);\\n            for (uint256 i; i < selected.length; i++) {\\n                // whenever there is a something to draw\\n                if (selectedSymbols[i] != 0) {\\n                    //select one of the remaining index\\n                    uint256 index = random2.next(0, temp);\\n                    // and set the element to draw for this index\\n                    selected[available[index]] = selectedSymbols[i];\\n\\n                    // remove the index from the list of remaining index\\n                    // by replacing it with the last index\\n                    available[index] = available[temp - 1];\\n\\n                    // decrement length of available index\\n                    temp--;\\n                }\\n            }\\n\\n            // we end up with bytes of config.mod length\\n            // where some bytes are non-zero and correspond to a symbol\\n            config.symbols = bytes16(selected);\\n        } else {\\n            // selectedSymbols should only have non-zero values\\n            // at indexes lesser than config.mod\\n            config.symbols = selectedSymbols;\\n        }\\n    }\\n\\n    function _fill(\\n        bytes memory buffer,\\n        Configuration memory config,\\n        Randomize.Random memory random\\n    ) internal pure {\\n        uint256 v;\\n        int256 y;\\n        int256 y2;\\n        int256 x;\\n        int256 base = int256(config.seed % SEED_BOUND);\\n\\n        // rotating elements in bottom to have some mirroring happening, \u00e0 la ModuloArt\\n        bool rot = random.next(0, 3) < 2;\\n        // invert top / bottom for a different effect\\n        bool invert = random.next(0, 2) == 0;\\n        // using [-HALF;HALF] grid instead of [1->HALF;HALF->1]\\n        bool translate = random.next(0, 2) == 0;\\n\\n        DynamicBuffer.appendBytes(buffer, \\\"%3Cg id='left'%3E\\\");\\n\\n        for (int256 i; i < HALF; i++) {\\n            if (translate) {\\n                y = (config.z1 * (i - HALF) + 1) * base;\\n                y2 = (config.z2 * (i + 1) - 1) * base;\\n            } else {\\n                y = (config.z1 * (i + 1)) * base;\\n                y2 = (config.z2 * (HALF - i)) * base;\\n            }\\n\\n            if (invert) {\\n                (y, y2) = (y2, y);\\n            }\\n\\n            for (int256 j; j < HALF; j++) {\\n                x = ((config.z1 * config.z2) * (j + 1)) * base;\\n\\n                v = ((uint256(x * y)) / SEED_BOUND) % config.mod;\\n\\n                bytes memory stroke = (\\n                    config.randStroke\\n                        ? abi.encodePacked(\\n                            \\\"stroke-width='\\\",\\n                            random.next(4, 8).toString(),\\n                            \\\"'\\\"\\n                        )\\n                        : bytes('')\\n                );\\n\\n                if (config.symbols[v] != 0) {\\n                    DynamicBuffer.appendBytes(\\n                        buffer,\\n                        abi.encodePacked(\\n                            \\\"%3Cuse x='\\\",\\n                            _getPosition(j, 0),\\n                            \\\"' y='\\\",\\n                            _getPosition(i, 0),\\n                            \\\"' href='%23s-\\\",\\n                            v.toString(),\\n                            \\\"' \\\",\\n                            stroke,\\n                            '/%3E'\\n                        )\\n                    );\\n                }\\n\\n                v = ((uint256(x * y2)) / SEED_BOUND) % config.mod;\\n\\n                if (config.symbols[v] != 0) {\\n                    DynamicBuffer.appendBytes(\\n                        buffer,\\n                        abi.encodePacked(\\n                            \\\"%3Cuse x='\\\",\\n                            _getPosition(j, 0),\\n                            \\\"' y='\\\",\\n                            _getPosition(i + HALF, 0),\\n                            \\\"' href='%23s-\\\",\\n                            v.toString(),\\n                            \\\"' \\\",\\n                            (\\n                                !rot\\n                                    ? bytes('')\\n                                    : abi.encodePacked(\\n                                        \\\"transform='rotate(180 \\\",\\n                                        _getPosition(j, 22),\\n                                        ' ',\\n                                        _getPosition(i + HALF, 22),\\n                                        \\\")'\\\"\\n                                    )\\n                            ),\\n                            ' ',\\n                            stroke,\\n                            '/%3E'\\n                        )\\n                    );\\n                }\\n            }\\n        }\\n\\n        DynamicBuffer.appendBytes(buffer, '%3C/g%3E');\\n    }\\n\\n    /// @dev get the position in pixels\\n    /// @param index the index to get the coord for\\n    /// @return the position\\n    function _getPosition(int256 index, uint256 offset)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return (uint256(index) * CELL_SIZE + offset).toString();\\n    }\\n\\n    /// @dev create the symbols that will be referenced by the cells\\n    /// @param buffer the buffer to add to\\n    /// @param config the full configuration object\\n    function _addSymbols(bytes memory buffer, Configuration memory config)\\n        internal\\n        view\\n    {\\n        // symbols can change depending on the user choice, so their rendering\\n        // has its own PRNG, to not modify the cells distribution\\n        Randomize.Random memory random = Randomize.Random({\\n            seed: uint256(keccak256(abi.encode(config.seed)))\\n        });\\n\\n        uint256 b;\\n        for (uint256 i; i < config.symbols.length; i++) {\\n            b = uint256(uint8(config.symbols[i]));\\n            if (b == 0) {\\n                // nothing.\\n                continue;\\n            } else if (b == 1) {\\n                // vertical line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,22L44,22' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 2) {\\n                // hor line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M22,0L22,44' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 3) {\\n                // diagonal line top left to bottom right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,0L44,44' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 4) {\\n                // diagonal line bottom left to top right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M44,0L0,44' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 5) {\\n                // cross\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,0L44,44M0,44L44,0' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 6) {\\n                // full circle\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Ccircle id='s-\\\",\\n                        i.toString(),\\n                        \\\"' cx='22' cy='22' r='22' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 7) {\\n                // circle with dot\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Ccircle cx='22' cy='22' r='18' fill='none' stroke='%23fff'/%3E%3Ccircle cx='22' cy='22' r='4' fill='%23fff'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 8) {\\n                // filled square\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Crect id='s-\\\",\\n                        i.toString(),\\n                        \\\"' x='7' y='7' width='30' height='30' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 9) {\\n                // square with cross\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Crect x='2' y='2' width='40' height='40' fill='%23fff'%3E%3C/rect%3E%3Cpath d='M18,18L26,26M18,26L26,18' stroke='%23000' stroke-width='4' stroke-linecap='round'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 10) {\\n                // square with square\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Crect x='2' y='2' width='40' height='40' fill='%23fff'/%3E%3Crect fill='%23000' x='18' y='18' width='8' height='8'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 11) {\\n                // plus\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Cpath d='M0,22L44,22M22,0L22,44' stroke='%23fff'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 12) {\\n                // rounded 512Print 1\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M22 0a22 22 0 0 1 -22 22m44 0a22 22 0 0 0 -22 22' stroke='%23fff' stroke-linecap='round'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 13) {\\n                // rounded 512Print 2\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M22 0a22 22 0 0 0 22 22m-44 0a22 22 0 0 1 22 22' stroke='%23fff' stroke-linecap='round'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 14) {\\n                // sides:top-right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0 0L44 0L44 44' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 15) {\\n                // sides:right-bottom\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M44 0L44 44L0 44' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 16) {\\n                // sides:bottom-left\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M44 44L0 44L0 0' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 17) {\\n                // sides:left-top\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0 44L0 0L44 0' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 18) {\\n                // triangles:top-right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0 0L44 0L44 44Z' \\\",\\n                        (\\n                            random.next(0, 100) < 50\\n                                ? \\\"fill='none' stroke='%23fff'\\\"\\n                                : \\\"fill='%23fff'\\\"\\n                        ),\\n                        '/%3E'\\n                    )\\n                );\\n            } else if (b == 19) {\\n                // triangles:right-bottom\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M44 0L44 44L0 44Z' \\\",\\n                        (\\n                            random.next(0, 100) < 50\\n                                ? \\\"fill='none' stroke='%23fff'\\\"\\n                                : \\\"fill='%23fff'\\\"\\n                        ),\\n                        '/%3E'\\n                    )\\n                );\\n            } else if (b == 20) {\\n                // triangles:bottom-left\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M44 44L0 44L0 0Z' \\\",\\n                        (\\n                            random.next(0, 100) < 50\\n                                ? \\\"fill='none' stroke='%23fff'\\\"\\n                                : \\\"fill='%23fff'\\\"\\n                        ),\\n                        '/%3E'\\n                    )\\n                );\\n            } else if (b == 21) {\\n                // triangles:left-top\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0 44L0 0L44 0Z' \\\",\\n                        (\\n                            random.next(0, 100) < 50\\n                                ? \\\"fill='none' stroke='%23fff'\\\"\\n                                : \\\"fill='%23fff'\\\"\\n                        ),\\n                        '/%3E'\\n                    )\\n                );\\n            } else if (b == 22) {\\n                // circle top-left\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath d='M0 0 h44 a44,44 0 0 1 -44,44z' id='s-\\\",\\n                        i.toString(),\\n                        \\\"' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 23) {\\n                // circle top-right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath d='M44 0 v44 a44,44 0 0 1 -44,-44z' id='s-\\\",\\n                        i.toString(),\\n                        \\\"' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 24) {\\n                // circle bottom right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath d='M44 44 h-44 a44,44 0 0 1 44,-44z' id='s-\\\",\\n                        i.toString(),\\n                        \\\"' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 25) {\\n                // circle bottom right\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath d='M0 44 v-44 a44,44 0 0 1 44,44z' id='s-\\\",\\n                        i.toString(),\\n                        \\\"' fill='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 26) {\\n                // full circle with empty dot\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Ccircle cx='22' cy='22' r='20' fill='%23fff'/%3E%3Ccircle cx='22' cy='22' r='4' fill='%23000'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 27) {\\n                // animated square\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Crect id='s-\\\",\\n                        i.toString(),\\n                        \\\"' x='7' y='7' width='30' height='30' fill='%23fff' transform='scale(1)' transform-origin='22 22' \\\",\\n                        \\\"%3E%3CanimateTransform attributeName='transform' type='scale' values='1;0;1' dur='8s' fill='freeze' repeatCount='indefinite' begin='\\\",\\n                        random.next(0, 5000).toString(),\\n                        \\\"ms'/%3E%3C/rect%3E\\\"\\n                    )\\n                );\\n            } else if (b == 28) {\\n                // animated vertical line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,22L44,22' stroke='%23fff' transform='scale(1)' transform-origin='22 22' \\\",\\n                        \\\"%3E%3CanimateTransform attributeName='transform' type='scale' values='1;0;1' dur='8s' fill='freeze' repeatCount='indefinite' begin='\\\",\\n                        random.next(0, 5000).toString(),\\n                        \\\"ms'/%3E%3C/path%3E\\\"\\n                    )\\n                );\\n            } else if (b == 29) {\\n                // animated hor line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M22,0L22,44' stroke='%23fff' transform='scale(1)' transform-origin='22 22' \\\",\\n                        \\\"%3E%3CanimateTransform attributeName='transform' type='scale' values='1;0;1' dur='8s' fill='freeze' repeatCount='indefinite' begin='\\\",\\n                        random.next(0, 5000).toString(),\\n                        \\\"ms'/%3E%3C/path%3E\\\"\\n                    )\\n                );\\n            } else if (b == 30) {\\n                // animated plus\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,22L44,22M22,0L22,44' stroke='%23fff' transform='scale(1)' transform-origin='22 22' \\\",\\n                        \\\"%3E%3CanimateTransform attributeName='transform' type='scale' values='1;0;1' dur='8s' fill='freeze' repeatCount='indefinite' begin='\\\",\\n                        random.next(0, 5000).toString(),\\n                        \\\"ms'/%3E%3C/path%3E\\\"\\n                    )\\n                );\\n            } else if (b == 31) {\\n                // random size square\\n                uint256 size = random.next(30, 44);\\n                if (size % 2 != 0) {\\n                    size++;\\n                }\\n\\n                uint256 offset = (44 - size) / 2;\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Crect id='s-\\\",\\n                        i.toString(),\\n                        \\\"' x='\\\",\\n                        offset.toString(),\\n                        \\\"' y='\\\",\\n                        offset.toString(),\\n                        \\\"' width='\\\",\\n                        size.toString(),\\n                        \\\"' height='\\\",\\n                        size.toString(),\\n                        \\\"' fill='%23fff' transform='scale(1)' transform-origin='22 22' \\\",\\n                        '%3E%3C/rect%3E'\\n                    )\\n                );\\n            } else if (b == 32) {\\n                // \\\"long\\\" horizontal line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,0L44,44' stroke='%23fff' transform='rotate(45 22 22)'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 33) {\\n                // \\\"long\\\" verticale line\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M0,0L44,44' stroke='%23fff' transform='rotate(-45 22 22)'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 34) {\\n                // growing line random direction\\n                uint256 length = 44 * random.next(1, 10);\\n                string memory delay = random.next(500, 4000).toString();\\n\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cline id='s-\\\",\\n                        i.toString(),\\n                        \\\"' x1='0' y1='0' x2='\\\",\\n                        (length.toString()),\\n                        \\\"' y2='0' stroke='%23fff' stroke-dasharray='\\\",\\n                        length.toString(),\\n                        \\\"' stroke-dashoffset='\\\",\\n                        (length - 1).toString(),\\n                        \\\"' stroke-linecap='round' transform='rotate(\\\",\\n                        (random.next(0, 4) * 90).toString(),\\n                        \\\" 22 22)' stroke-width='22'%3E%3Canimate attributeName='stroke-dashoffset' \\\"\\n                    )\\n                );\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\" values='\\\",\\n                        (length - 1).toString(),\\n                        ';0;',\\n                        (length - 1).toString(),\\n                        \\\"' dur='\\\",\\n                        random.next(4000, 15000).toString(),\\n                        \\\"ms' repeatCount='indefinite' begin='\\\",\\n                        delay,\\n                        'ms;op.end+',\\n                        delay,\\n                        \\\"ms'/%3E%3C/line%3E\\\"\\n                    )\\n                );\\n            } else if (b == 35) {\\n                // stroked square\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Crect id='s-\\\",\\n                        i.toString(),\\n                        \\\"' x='7' y='7' width='30' height='30' fill='none' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 36) {\\n                // stroked circle\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Ccircle id='s-\\\",\\n                        i.toString(),\\n                        \\\"' cx='22' cy='22' r='22' fill='none' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 37) {\\n                // 3 circles\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Ccircle cx='22' cy='22' r='20' fill='none' stroke='%23fff'/%3E%3Ccircle cx='22' cy='22' r='11' fill='none' stroke='%23fff'/%3E%3Ccircle cx='22' cy='22' r='4' fill='%23fff'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 38) {\\n                // barred circle\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cg transform='rotate(-45 22 22)' id='s-\\\",\\n                        i.toString(),\\n                        \\\"'%3E%3Ccircle cx='22' cy='22' r='20' fill='none' stroke='%23fff'/%3E%3Cpath d='M22 0L22 44' stroke='%23fff'/%3E%3Ccircle cx='22' cy='22' r='6' fill='%23fff'/%3E%3C/g%3E\\\"\\n                    )\\n                );\\n            } else if (b == 39) {\\n                // double triangle\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M4 4L40 4L22 40Z M22 4L40 40L4 40Z' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else if (b == 40) {\\n                // hashtag\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3Cpath id='s-\\\",\\n                        i.toString(),\\n                        \\\"' d='M14 6L14 38M30 6L30 38M6 14L38 14M6 30L38 30' stroke='%23fff'/%3E\\\"\\n                    )\\n                );\\n            } else {\\n                // this allows to someday, extend the list of available symbols\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    ISuperglyphs(msg.sender).getSymbol(b, random)\\n                );\\n            }\\n        }\\n    }\\n\\n    function _addGradient(\\n        bytes memory buffer,\\n        Configuration memory config,\\n        Randomize.Random memory random\\n    ) internal pure {\\n        // 50% chance linear gradient\\n        if (random.next(0, 10) < 5) {\\n            uint256 x1;\\n            uint256 y1;\\n            uint256 x2;\\n            uint256 y2;\\n            if (random.next(0, 10) < 5) {\\n                x1 = 0;\\n                x2 = 100;\\n                y1 = random.next(0, 100);\\n                y2 = 100 - y1;\\n            } else {\\n                y1 = 0;\\n                y2 = 100;\\n                x1 = random.next(0, 100);\\n                x2 = 100 - x1;\\n            }\\n            // 50% chance non-animated linear gradient\\n            if (random.next(0, 10) < 5) {\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3ClinearGradient id='gr' x1='\\\",\\n                        x1.toString(),\\n                        \\\"%25' y1='\\\",\\n                        y1.toString(),\\n                        \\\"%25' x2='\\\",\\n                        x2.toString(),\\n                        \\\"%25' y2='\\\"\\n                    )\\n                );\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        y2.toString(),\\n                        \\\"%25'%3E\\\",\\n                        \\\"%3Cstop offset='0%25' stop-color='\\\",\\n                        config.colors[0],\\n                        \\\"'/%3E\\\",\\n                        \\\"%3Cstop offset='100%25' stop-color='\\\",\\n                        config.colors[1],\\n                        \\\"'/%3E\\\",\\n                        '%3C/linearGradient%3E'\\n                    )\\n                );\\n            } else {\\n                // else animated linear\\n                string memory animation = random.next(10000, 20000).toString();\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3ClinearGradient id='gr' x1='\\\",\\n                        x1.toString(),\\n                        \\\"%25' y1='\\\",\\n                        y1.toString(),\\n                        \\\"%25' x2='\\\",\\n                        x2.toString(),\\n                        \\\"%25' y2='\\\"\\n                    )\\n                );\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        y2.toString(),\\n                        \\\"%25'%3E%3Cstop offset='0%25' stop-color='\\\",\\n                        config.colors[0],\\n                        \\\"'%3E\\\",\\n                        \\\"%3Canimate attributeName='stop-color' dur='\\\",\\n                        animation,\\n                        \\\"ms' values='\\\",\\n                        config.colors[0],\\n                        ';',\\n                        config.colors[1],\\n                        ';',\\n                        config.colors[0]\\n                    )\\n                );\\n\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"' repeatCount='indefinite'/%3E%3C/stop%3E%3Cstop offset='100%25' stop-color='\\\",\\n                        config.colors[1],\\n                        \\\"'%3E%3Canimate attributeName='stop-color' dur='\\\",\\n                        animation,\\n                        \\\"ms' values='\\\",\\n                        config.colors[1],\\n                        ';',\\n                        config.colors[0],\\n                        ';',\\n                        config.colors[1],\\n                        \\\"' repeatCount='indefinite'/%3E%3C/stop%3E%3C/linearGradient%3E\\\"\\n                    )\\n                );\\n            }\\n        } else {\\n            // 50 % non-animated radial\\n            if (random.next(0, 10) < 5) {\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3CradialGradient id='gr' cx='\\\",\\n                        (random.next(1, 4) * 25).toString(),\\n                        \\\"%25' cy='\\\",\\n                        (random.next(1, 4) * 25).toString(),\\n                        \\\"%25'%3E%3Cstop offset='0%25' stop-color='\\\",\\n                        config.colors[0],\\n                        \\\"'/%3E%3Cstop offset='100%25' stop-color='\\\",\\n                        config.colors[1],\\n                        \\\"'/%3E%3C/radialGradient%3E\\\"\\n                    )\\n                );\\n            } else {\\n                // animated radial gradient\\n                string memory animation = random.next(10000, 20000).toString();\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"%3CradialGradient id='gr' cx='\\\",\\n                        (random.next(1, 4) * 25).toString(),\\n                        \\\"%25' cy='\\\",\\n                        (random.next(1, 4) * 25).toString(),\\n                        \\\"%25'%3E%3Cstop offset='0%25' stop-color='\\\",\\n                        config.colors[0],\\n                        \\\"' %3E%3Canimate attributeName='stop-color' dur='\\\",\\n                        animation,\\n                        \\\"ms' values='\\\",\\n                        config.colors[0],\\n                        ';',\\n                        config.colors[1],\\n                        ';',\\n                        config.colors[0]\\n                    )\\n                );\\n\\n                DynamicBuffer.appendBytes(\\n                    buffer,\\n                    abi.encodePacked(\\n                        \\\"' repeatCount='indefinite'/%3E%3C/stop%3E%3Cstop offset='100%25' stop-color='\\\",\\n                        config.colors[1],\\n                        \\\"'%3E%3Canimate attributeName='stop-color' dur='\\\",\\n                        animation,\\n                        \\\"ms' values='\\\",\\n                        config.colors[1],\\n                        ';',\\n                        config.colors[0],\\n                        ';',\\n                        config.colors[1],\\n                        \\\"' repeatCount='indefinite'/%3E%3C/stop%3E%3C/radialGradient%3E\\\"\\n                    )\\n                );\\n            }\\n        }\\n    }\\n\\n    function _getColors(uint256 colorSeed, bool darkTheme)\\n        public\\n        pure\\n        returns (bytes9[2] memory)\\n    {\\n        string[14] memory colors;\\n        if (!darkTheme) {\\n            colors = [\\n                '%236a2c70',\\n                '%233f72af',\\n                '%23b83b5e',\\n                '%23112d4e',\\n                '%23a82ffc',\\n                '%23212121',\\n                '%23004a7c',\\n                '%233a0088',\\n                '%23364f6b',\\n                '%2353354a',\\n                '%23903749',\\n                '%232b2e4a',\\n                '%236639a6',\\n                '%23000000'\\n            ];\\n        } else {\\n            colors = [\\n                '%233fc1c9',\\n                '%23ffd3b5',\\n                '%23f9f7f7',\\n                '%23d6c8ff',\\n                '%2300bbf0',\\n                '%23ffde7d',\\n                '%23f6416c',\\n                '%23ff99fe',\\n                '%231891ac',\\n                '%23f8f3d4',\\n                '%2300b8a9',\\n                '%23f9ffea',\\n                '%23ff2e63',\\n                '%23ffffff'\\n            ];\\n        }\\n\\n        // make sure to have different colors\\n        uint256 length = colors.length;\\n        uint256 index1 = colorSeed % length;\\n        uint256 index2 = (index1 +\\n            1 +\\n            (uint256(keccak256(abi.encode(colorSeed))) % (length - 1))) %\\n            length;\\n\\n        return [bytes9(bytes(colors[index1])), bytes9(bytes(colors[index2]))];\\n    }\\n\\n    function _getDateTime() internal view returns (string memory) {\\n        uint256 chainId = block.chainid;\\n\\n        address bokky;\\n        if (chainId == 1) {\\n            bokky = address(0x23d23d8F243e57d0b924bff3A3191078Af325101);\\n        } else if (chainId == 4) {\\n            bokky = address(0x047C6386C30E785F7a8fd536945410802a605395);\\n        }\\n\\n        if (address(0) != bokky) {\\n            (\\n                uint256 year,\\n                uint256 month,\\n                uint256 day,\\n                uint256 hour,\\n                uint256 minute,\\n                uint256 second\\n            ) = IBokkyPooBahsDateTimeContract(bokky).timestampToDateTime(\\n                    block.timestamp\\n                );\\n\\n            return\\n                string(\\n                    abi.encodePacked(\\n                        year.toString(),\\n                        '/',\\n                        month.toString(),\\n                        '/',\\n                        day.toString(),\\n                        ' ',\\n                        hour.toString(),\\n                        ':',\\n                        minute.toString(),\\n                        ':',\\n                        second.toString(),\\n                        ' UTC'\\n                    )\\n                );\\n        }\\n\\n        return '';\\n    }\\n}\\n\\ninterface IBokkyPooBahsDateTimeContract {\\n    function timestampToDateTime(uint256 timestamp)\\n        external\\n        pure\\n        returns (\\n            uint256 year,\\n            uint256 month,\\n            uint256 day,\\n            uint256 hour,\\n            uint256 minute,\\n            uint256 second\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Base64.sol\": {\r\n      \"content\": \"pragma solidity ^0.8.0;\\n\\n// SPDX-License-Identifier: MIT\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides a function for encoding some bytes in base64\\nlibrary Base64 {\\n    string internal constant TABLE =\\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {\\n\\n            } lt(dataPtr, endPtr) {\\n\\n            } {\\n                dataPtr := add(dataPtr, 3)\\n\\n                // read 3 bytes\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(shr(6, input), 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n                mstore(\\n                    resultPtr,\\n                    shl(248, mload(add(tablePtr, and(input, 0x3F))))\\n                )\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/DynamicBuffer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title DynamicBuffer\\n/// @author David Huber (@cxkoda) and Simon Fremaux (@dievardump)\\n///         this library is just putting together code created by David Huber\\n///         that you can find in https://etherscan.io/address/0x1ca15ccdd91b55cd617a48dc9eefb98cae224757#code\\n///         he gave me the authorization to put it together into a single library\\n/// @notice This library is used to allocate a big amount of memory and then always update the buffer content\\n///         without needing to reallocate memory. This allows to save a lot of gas when manipulating bytes/strings\\n/// @dev First, allocate memory. Then use DynamicBuffer.appendBytes(buffer, theBytes);\\nlibrary DynamicBuffer {\\n    function allocate(uint256 capacity)\\n        internal\\n        pure\\n        returns (bytes memory container, bytes memory buffer)\\n    {\\n        assembly {\\n            // Get next-free memory address\\n            container := mload(0x40)\\n\\n            // Allocate memory by setting a new next-free address\\n            {\\n                // Add 2 x 32 bytes in size for the two length fields\\n                let size := add(capacity, 0x40)\\n                let newNextFree := add(container, size)\\n                mstore(0x40, newNextFree)\\n            }\\n\\n            // Set the correct container length\\n            {\\n                let length := add(capacity, 0x40)\\n                mstore(container, length)\\n            }\\n\\n            // The buffer starts at idx 1 in the container (0 is length)\\n            buffer := add(container, 0x20)\\n\\n            // Init content with length 0\\n            mstore(buffer, 0)\\n        }\\n\\n        return (container, buffer);\\n    }\\n\\n    /// @notice Appends data_ to buffer_, and update buffer_ length\\n    /// @param buffer_ the buffer to append the data to\\n    /// @param data_ the data to append\\n    function appendBytes(bytes memory buffer_, bytes memory data_)\\n        internal\\n        pure\\n    {\\n        assembly {\\n            let length := mload(data_)\\n            for {\\n                let data := add(data_, 32)\\n                let dataEnd := add(data, length)\\n                let buf := add(buffer_, add(mload(buffer_), 32))\\n            } lt(data, dataEnd) {\\n                data := add(data, 32)\\n                buf := add(buf, 32)\\n            } {\\n                // Copy 32B chunks from data to buffer.\\n                // This may read over data array boundaries and copy invalid\\n                // bytes, which doesn't matter in the end since we will\\n                // later set the correct buffer length.\\n                mstore(buf, mload(data))\\n            }\\n\\n            // Update buffer length\\n            mstore(buffer_, add(mload(buffer_), length))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Randomize.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// small library to randomize using (min, max, seed)\\n// all number returned are considered with 3 decimals\\nlibrary Randomize {\\n    struct Random {\\n        uint256 seed;\\n    }\\n\\n    /// @notice This function uses seed to return a pseudo random interger between [min and max[\\n    /// @param random the random seed\\n    /// @return the pseudo random number\\n    function next(Random memory random, uint256 min, uint256 max) internal pure returns (uint256) {\\n        random.seed ^= random.seed << 13;\\n        random.seed ^= random.seed >> 17;\\n        random.seed ^= random.seed << 5;\\n        return min + random.seed % (max - min);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CELL_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"HALF\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SEED_BOUND\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"colorSeed\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"darkTheme\",\"type\":\"bool\"}],\"name\":\"_getColors\",\"outputs\":[{\"internalType\":\"bytes9[2]\",\"name\":\"\",\"type\":\"bytes9[2]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colorSeed\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"selectedColors\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"selectedSymbols\",\"type\":\"bytes16\"},{\"internalType\":\"bool\",\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"colorSeed\",\"type\":\"uint256\"},{\"internalType\":\"bytes16\",\"name\":\"selectedColors\",\"type\":\"bytes16\"},{\"internalType\":\"bytes16\",\"name\":\"selectedSymbols\",\"type\":\"bytes16\"}],\"name\":\"start\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"internalType\":\"struct Randomize.Random\",\"name\":\"random\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mod\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"z1\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"z2\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"randStroke\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"fullSymmetry\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"darkTheme\",\"type\":\"bool\"},{\"internalType\":\"bytes9[2]\",\"name\":\"colors\",\"type\":\"bytes9[2]\"},{\"internalType\":\"bytes16\",\"name\":\"symbols\",\"type\":\"bytes16\"}],\"internalType\":\"struct ISuperglyphsRenderer.Configuration\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SuperglyphsRenderer", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}