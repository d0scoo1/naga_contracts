{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"src/contracts/AllocationModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8;\\n\\nimport \\\"./interface/CowProtocolTokens.sol\\\";\\nimport \\\"./vendored/Enum.sol\\\";\\nimport \\\"./vendored/ModuleController.sol\\\";\\n\\n/// @dev Gnosis Safe module used to distribute the Safe's vCOW allocation to other addresses. The module can add new\\n/// target addresses that will be assigned a linear token allocation. Claims can be reedemed at any time by the target\\n/// addresses and can be stopped at any time by the team controller.\\n/// @title COW Allocation Module\\n/// @author CoW Protocol Developers\\ncontract AllocationModule {\\n    /// @dev Parameters that describe a linear vesting position for a claimant.\\n    struct VestingPosition {\\n        /// @dev Full amount of COW that is to be vested linearly in the designated time.\\n        uint96 totalAmount;\\n        /// @dev Amount of COW that the claimant has already redeemed so far.\\n        uint96 claimedAmount;\\n        /// @dev Timestamp when this vesting position started.\\n        uint32 start;\\n        /// @dev Timespan between vesting start and end.\\n        uint32 duration;\\n    }\\n\\n    /// @dev Gnosis Safe that will enable this module. Its vCOW claims will be used to pay out each target address.\\n    ModuleController public immutable controller;\\n    /// @dev The COW token.\\n    CowProtocolToken public immutable cow;\\n    /// @dev The virtual COW token.\\n    CowProtocolVirtualToken public immutable vcow;\\n    /// @dev Maps each address to its vesting position. An address can have at most a single vesting position.\\n    mapping(address => VestingPosition) public allocation;\\n\\n    /// @dev Maximum value that can be stored in the type uint32.00\\n    uint256 private constant MAX_UINT_32 = (1 << (32)) - 1;\\n\\n    /// @dev Thrown when creating a vesting position of zero duration.\\n    error DurationMustNotBeZero();\\n    /// @dev Thrown when creating a vesting position for an address that already has a vesting position.\\n    error HasClaimAlready();\\n    /// @dev Thrown when computing the amount of vested COW of an address that has no allocation.\\n    error NoClaimAssigned();\\n    /// @dev Thrown when executing a function that is reserved to the Gnosis Safe that controls this module.\\n    error NotAController();\\n    /// @dev Thrown when a claimant tries to claim more COW tokens that the linear vesting allows at this point in time.\\n    error NotEnoughVestedTokens();\\n    /// @dev Thrown when the transfer of COW tokens did not succeed.\\n    error RevertedCowTransfer();\\n\\n    /// @dev A new linear vesting position is added to the module.\\n    event ClaimAdded(\\n        address indexed beneficiary,\\n        uint32 start,\\n        uint32 duration,\\n        uint96 amount\\n    );\\n    /// @dev A vesting position is removed from the module.\\n    event ClaimStopped(address indexed beneficiary);\\n    /// @dev A claimant redeems an amount of COW tokens from its vesting position.\\n    event ClaimRedeemed(address indexed beneficiary, uint96 amount);\\n\\n    /// @dev Restrict the message caller to be the controller of this module.\\n    modifier onlyController() {\\n        if (msg.sender != address(controller)) {\\n            revert NotAController();\\n        }\\n        _;\\n    }\\n\\n    constructor(address _controller, address _vcow) {\\n        controller = ModuleController(_controller);\\n        vcow = CowProtocolVirtualToken(_vcow);\\n        cow = CowProtocolToken(address(vcow.cowToken()));\\n    }\\n\\n    /// @dev Allocates a vesting claim for COW tokens to an address.\\n    /// @param beneficiary The address to which the new vesting claim will be assigned.\\n    /// @param duration How long it will take to the beneficiary to vest the entire amount of the claim.\\n    /// @param amount Amount of COW tokens that will be linearly vested to the beneficiary.\\n    function addClaim(\\n        address beneficiary,\\n        uint32 start,\\n        uint32 duration,\\n        uint96 amount\\n    ) external onlyController {\\n        if (duration == 0) {\\n            revert DurationMustNotBeZero();\\n        }\\n        if (allocation[beneficiary].totalAmount != 0) {\\n            revert HasClaimAlready();\\n        }\\n        allocation[beneficiary] = VestingPosition({\\n            totalAmount: amount,\\n            claimedAmount: 0,\\n            start: start,\\n            duration: duration\\n        });\\n\\n        emit ClaimAdded(beneficiary, start, duration, amount);\\n    }\\n\\n    /// @dev Stops the claim of an address. It first claims the entire amount of COW allocated so far on behalf of the\\n    /// former beneficiary.\\n    /// @param beneficiary The address that will see its vesting position stopped.\\n    function stopClaim(address beneficiary) external onlyController {\\n        // Note: claiming COW might fail, therefore making it impossible to stop the claim. This is not considered an\\n        // issue as a claiming failure can only occur in the following cases:\\n        // 1. No claim is available: then nothing needs to be stopped.\\n        // 2. This module is no longer enabled in the controller.\\n        // 3. The COW transfer reverts. This means that there weren't enough vCOW tokens to swap for COW and that there\\n        // aren't enough COW tokens available in the controller. Sending COW tokens to pay out the remaining claim would\\n        // allow to stop the claim.\\n        // 4. Math failures (overflow/underflows). No untrusted value is provided to this function, so this is not\\n        // expected to happen.\\n        // solhint-disable-next-line not-rely-on-time\\n        _claimAllCow(beneficiary, block.timestamp);\\n\\n        delete allocation[beneficiary];\\n\\n        emit ClaimStopped(beneficiary);\\n    }\\n\\n    /// @dev Computes and sends the entire amount of COW that have been vested so far to the caller.\\n    /// @return The amount of COW that has been claimed.\\n    function claimAllCow() external returns (uint96) {\\n        // solhint-disable-next-line not-rely-on-time\\n        return _claimAllCow(msg.sender, block.timestamp);\\n    }\\n\\n    /// @dev Sends the specified amount of COW to the caller, assuming enough COW has been vested so far.\\n    function claimCow(uint96 claimedAmount) external {\\n        address beneficiary = msg.sender;\\n\\n        (uint96 alreadyClaimedAmount, uint96 fullVestedAmount) = retrieveClaimedAmounts(\\n            beneficiary,\\n            // solhint-disable-next-line not-rely-on-time\\n            block.timestamp\\n        );\\n\\n        claimCowFromAmounts(\\n            beneficiary,\\n            claimedAmount,\\n            alreadyClaimedAmount,\\n            fullVestedAmount\\n        );\\n    }\\n\\n    /// @dev Returns how many COW tokens are claimable at the current point in time by the given address. Tokens that\\n    /// were already claimed by the user are not included in the output amount.\\n    /// @param beneficiary The address that owns the claim.\\n    /// @return The amount of COW that could be claimed by the beneficiary at this point in time.\\n    function claimableCow(address beneficiary) external view returns (uint256) {\\n        if (allocation[beneficiary].totalAmount == 0) {\\n            return 0;\\n        }\\n        (uint96 alreadyClaimedAmount, uint96 fullVestedAmount) = retrieveClaimedAmounts(\\n            beneficiary,\\n            // solhint-disable-next-line not-rely-on-time\\n            block.timestamp\\n        );\\n\\n        return fullVestedAmount - alreadyClaimedAmount;\\n    }\\n\\n    /// @dev Computes and sends the entire amount of COW that have been vested so far to the beneficiary.\\n    /// @param beneficiary The address that redeems its claim.\\n    /// @param timestampAtClaimingTime The timestamp at claiming time.\\n    /// @return claimedAmount The amount of COW that has been claimed.\\n    function _claimAllCow(address beneficiary, uint256 timestampAtClaimingTime)\\n        internal\\n        returns (uint96 claimedAmount)\\n    {\\n        (\\n            uint96 alreadyClaimedAmount,\\n            uint96 fullVestedAmount\\n        ) = retrieveClaimedAmounts(beneficiary, timestampAtClaimingTime);\\n\\n        claimedAmount = fullVestedAmount - alreadyClaimedAmount;\\n        claimCowFromAmounts(\\n            beneficiary,\\n            claimedAmount,\\n            alreadyClaimedAmount,\\n            fullVestedAmount\\n        );\\n    }\\n\\n    /// @dev Computes some values related to a vesting position: how much can be claimed at the specified point in time\\n    /// and how much has already been claimed.\\n    /// @param beneficiary The address that is assigned the vesting position to consider.\\n    /// @param timestampAtClaimingTime The timestamp at claiming time.\\n    /// @return alreadyClaimedAmount How much of the vesting position has already been claimed.\\n    /// @return fullVestedAmount How much of the vesting position has been vested at the specified point in time. This\\n    /// amount does not exclude the amount that has already been claimed.\\n    function retrieveClaimedAmounts(\\n        address beneficiary,\\n        uint256 timestampAtClaimingTime\\n    )\\n        internal\\n        view\\n        returns (uint96 alreadyClaimedAmount, uint96 fullVestedAmount)\\n    {\\n        // Destructure caller position as gas efficiently as possible without assembly.\\n        VestingPosition memory position = allocation[beneficiary];\\n        uint96 totalAmount = position.totalAmount;\\n        alreadyClaimedAmount = position.claimedAmount;\\n        uint32 start = position.start;\\n        uint32 duration = position.duration;\\n\\n        if (totalAmount == 0) {\\n            revert NoClaimAssigned();\\n        }\\n\\n        fullVestedAmount = computeClaimableAmount(\\n            start,\\n            timestampAtClaimingTime,\\n            duration,\\n            totalAmount\\n        );\\n    }\\n\\n    /// Given the parameters of a vesting position, computes how much of the total amount has been vested so far.\\n    /// @param start Timestamp when the vesting position was started.\\n    /// @param current Timestamp of the point in time when the vested amount should be computed.\\n    /// @param duration How long it takes for this vesting position to be fully vested.\\n    /// @param totalAmount The total amount that is being vested.\\n    /// @return The amount that has been vested at the specified point in time.\\n    function computeClaimableAmount(\\n        uint32 start,\\n        uint256 current,\\n        uint32 duration,\\n        uint96 totalAmount\\n    ) internal pure returns (uint96) {\\n        if (current <= start) {\\n            return 0;\\n        }\\n        uint256 elapsedTime = current - start;\\n        if (elapsedTime >= duration) {\\n            return totalAmount;\\n        }\\n        return uint96((uint256(totalAmount) * elapsedTime) / duration);\\n    }\\n\\n    /// @dev Takes the parameters of a vesting position from its input values and sends out the claimed COW to the\\n    /// beneficiary, taking care of updating the claimed amount.\\n    /// @param beneficiary The address that should receive the COW tokens.\\n    /// @param amount The amount of COW that is claimed by the beneficiary.\\n    /// @param alreadyClaimedAmount The amount that has already been claimed by the beneficiary.\\n    /// @param fullVestedAmount The total amount of COW that has been vested so far, which includes the amount that\\n    /// was already claimed.\\n    function claimCowFromAmounts(\\n        address beneficiary,\\n        uint96 amount,\\n        uint96 alreadyClaimedAmount,\\n        uint96 fullVestedAmount\\n    ) internal {\\n        uint96 claimedAfterPayout = alreadyClaimedAmount + amount;\\n        if (claimedAfterPayout > fullVestedAmount) {\\n            revert NotEnoughVestedTokens();\\n        }\\n\\n        allocation[beneficiary].claimedAmount = claimedAfterPayout;\\n        swapVcowIfAvailable(amount);\\n        transferCow(beneficiary, amount);\\n\\n        emit ClaimRedeemed(beneficiary, amount);\\n    }\\n\\n    /// @dev Swaps an exact amount of vCOW tokens that are held in the module controller in exchange for COW tokens. The\\n    /// COW tokens are left in the module controller. If swapping reverts (which means that not enough vCOW are\\n    /// available) then the failure is ignored.\\n    /// @param amount The amount of vCOW to swap.\\n    function swapVcowIfAvailable(uint256 amount) internal {\\n        // The success status is explicitely ignored. This means that the call to `swap` could revert without reverting\\n        // the execution of this function. Note that this function can still revert if the call to\\n        // `execTransactionFromModule` reverts, which could happen for example if this module is no longer enabled in\\n        // the controller.\\n        //bool success =\\n        controller.execTransactionFromModule(\\n            address(vcow),\\n            0,\\n            abi.encodeWithSelector(vcow.swap.selector, amount),\\n            Enum.Operation.Call\\n        );\\n    }\\n\\n    /// @dev Transfer the specified exact amount of COW tokens that are held in the module controller to the target.\\n    /// @param to The address that will receive transfer.\\n    /// @param amount The amount of COW to transfer.\\n    function transferCow(address to, uint256 amount) internal {\\n        // Note: the COW token reverts on failed transfer, there is no need to check the return value.\\n        bool success = controller.execTransactionFromModule(\\n            address(cow),\\n            0,\\n            abi.encodeWithSelector(cow.transfer.selector, to, amount),\\n            Enum.Operation.Call\\n        );\\n        if (!success) {\\n            revert RevertedCowTransfer();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/interface/CowProtocolTokens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity ^0.8;\\n\\n/// @dev Interface exposing some of the functions of the governance token for the CoW Protocol.\\n/// @title CoW Protocol Governance Token Minimal Interface\\n/// @author CoW Protocol Developers\\ninterface CowProtocolToken {\\n    /// @dev Moves `amount` tokens from the caller's account to `to`.\\n    /// Returns true. Reverts if the operation didn't succeed.\\n    function transfer(address to, uint256 amount) external returns (bool);\\n}\\n\\n/// @dev Interface exposing some of the functions of the virtual token for the CoW Protocol.\\n/// @title CoW Protocol Virtual Token Minimal Interface\\n/// @author CoW Protocol Developers\\ninterface CowProtocolVirtualToken {\\n    /// @dev Converts an amount of (virtual) tokens from this contract to real\\n    /// tokens based on the claims previously performed by the caller.\\n    /// @param amount How many virtual tokens to convert into real tokens.\\n    function swap(uint256 amount) external;\\n\\n    /// @dev Address of the real COW token. Tokens claimed by this contract can\\n    /// be converted to this token if this contract stores some balance of it.\\n    function cowToken() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n// Vendored from @gnosis.pm/safe-contracts v1.3.0, see:\\n// <https://raw.githubusercontent.com/gnosis/safe-contracts/v1.3.0/contracts/common/Enum.sol>\\n\\npragma solidity >=0.7.0 <0.9.0;\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract Enum {\\n    enum Operation {\\n        Call,\\n        DelegateCall\\n    }\\n}\\n\"\r\n    },\r\n    \"src/contracts/vendored/ModuleController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\n// A contract interface listing the functions that are exposed by a Gnosis Safe v1.3 to work with modules.\\n// Vendored from @gnosis.pm/zodiac v1.0.6, see:\\n// <https://raw.githubusercontent.com/gnosis/zodiac/d9b1180436609f6c0a1fc93009d9c28d214fd971/contracts/interfaces/IAvatar.sol>\\n// Changes:\\n// - Renamed contract to `ModuleController` to make the interface purpose clearer when imported.\\n// - Vendored imports.\\n\\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\\npragma solidity >=0.7.0 <0.9.0;\\n\\nimport \\\"./Enum.sol\\\";\\n\\ninterface ModuleController {\\n    /// @dev Enables a module on the avatar.\\n    /// @notice Can only be called by the avatar.\\n    /// @notice Modules should be stored as a linked list.\\n    /// @notice Must emit EnabledModule(address module) if successful.\\n    /// @param module Module to be enabled.\\n    function enableModule(address module) external;\\n\\n    /// @dev Disables a module on the avatar.\\n    /// @notice Can only be called by the avatar.\\n    /// @notice Must emit DisabledModule(address module) if successful.\\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(address prevModule, address module) external;\\n\\n    /// @dev Allows a Module to execute a transaction.\\n    /// @notice Can only be called by an enabled module.\\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success);\\n\\n    /// @dev Allows a Module to execute a transaction and return data\\n    /// @notice Can only be called by an enabled module.\\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) external returns (bool success, bytes memory returnData);\\n\\n    /// @dev Returns if an module is enabled\\n    /// @return True if the module is enabled\\n    function isModuleEnabled(address module) external view returns (bool);\\n\\n    /// @dev Returns array of modules.\\n    /// @param start Start of the page.\\n    /// @param pageSize Maximum number of modules that should be returned.\\n    /// @return array Array of modules.\\n    /// @return next Start of the next page.\\n    function getModulesPaginated(address start, uint256 pageSize)\\n        external\\n        view\\n        returns (address[] memory array, address next);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_controller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vcow\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DurationMustNotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HasClaimAlready\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoClaimAssigned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotAController\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughVestedTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RevertedCowTransfer\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"ClaimAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"ClaimRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"ClaimStopped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"}],\"name\":\"addClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allocation\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"totalAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"claimedAmount\",\"type\":\"uint96\"},{\"internalType\":\"uint32\",\"name\":\"start\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"duration\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAllCow\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"claimedAmount\",\"type\":\"uint96\"}],\"name\":\"claimCow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"claimableCow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"contract ModuleController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cow\",\"outputs\":[{\"internalType\":\"contract CowProtocolToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"stopClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vcow\",\"outputs\":[{\"internalType\":\"contract CowProtocolVirtualToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AllocationModule", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000ca07eaa4253638d286cad71cbceec11803f2709a000000000000000000000000d057b63f5e69cf1b929b356b579cba08d7688048", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}