{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//////////////////////////////////////////////////////////////////////////\r\n//     ___               __             _  __           __              //\r\n//    / _ \\___ ____  ___/ /__  __ _    / |/ /_ ____ _  / /  ___ ____    //\r\n//   / , _/ _ `/ _ \\/ _  / _ \\/  ' \\  /    / // /  ' \\/ _ \\/ -_) __/    //\r\n//  /_/|_|\\_,_/_//_/\\_,_/\\___/_/_/_/ /_/|_/\\_,_/_/_/_/_.__/\\__/_/       //\r\n//    _____                      __                                     //\r\n//   / ___/__ ___  ___ _______ _/ /____  ____                           //\r\n//  / (_ / -_) _ \\/ -_) __/ _ `/ __/ _ \\/ __/                           //\r\n//  \\___/\\__/_//_/\\__/_/  \\_,_/\\__/\\___/_/                              //\r\n//                                                 by: 0xInuarashi.eth  //\r\n//////////////////////////////////////////////////////////////////////////\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// RandomNumberGenerator is the second interface of RandomNumberConsumer\r\n// Made back in October 2021 by 0xInuarashi\r\n\r\n// That contract generates random numbers.\r\n// This contract interfaces that contract to return a fixed-array \r\n// Random number by using the random number from the RNC contract\r\n// As a seed and then using nonces to increase the randomness.\r\n\r\ninterface IRandomNumberConsumer {\r\n    function returnRandomNumber(uint256 maxNumber_, uint256 nonce_) external \r\n    view returns (uint256);\r\n}\r\n\r\ncontract RandomNumberGenerator {\r\n\r\n    // here, we define the event to store random numbers with a message and numbers\r\n    event RandomNumbersPulled(string message_, uint256[] numbers_);\r\n\r\n    // First, we define the contract interface.\r\n    IRandomNumberConsumer public RNC = \r\n        IRandomNumberConsumer(0x9eE37A86b73fC615322E71D281a350A51dF2B3c3);\r\n\r\n    // Now, we define a free view-only function for free usage\r\n    function returnRandomNumbers(uint256 maxNumber_, uint256 amount_) public\r\n    view returns (uint256[] memory) {\r\n        // First, we create a memory array with intended size\r\n        uint256[] memory _randomNumbers = new uint256[] (amount_);\r\n\r\n        // Then, we call the RNC contract to consume its number with nonces for seed\r\n        for (uint256 i = 0; i < amount_; i++) {\r\n            _randomNumbers[i] = RNC.returnRandomNumber(maxNumber_, i);\r\n        }\r\n\r\n        return _randomNumbers;\r\n    }\r\n\r\n    // Now, we define a cheap event emitter that emits the random numbers as a \r\n    // way to store it on the blockchain. Accompanied with a message_ argument\r\n    // so that you can define what the emitted numbers were for.\r\n    function emitRandomNumbers(string calldata message_, uint256 maxNumber_,\r\n    uint256 amount_) external returns (uint256[] memory) {\r\n        // First, we call returnRandomNumbers() to get the array\r\n        uint256[] memory _randomNumbers = returnRandomNumbers(maxNumber_, amount_);\r\n        \r\n        // Now, we emit the standard event.\r\n        emit RandomNumbersPulled(message_, _randomNumbers);\r\n\r\n        // Return it in case external contracts or functions want to interface this\r\n        return _randomNumbers;\r\n    }\r\n\r\n    // Non-duplicate methods\r\n\r\n    // Simple random number generating does not account for duplication.\r\n    // Thus, I created a method to account for duplication, at the cost of a loooooot\r\n    // (and I mean, a looooot) of processing cost as solidity does not have a \r\n    // native method to find duplicates.\r\n\r\n    // We create an internal function to check an array for duplicate numbers and return\r\n    // a bool value.\r\n    function _existsInArray(uint256[] memory randomNumbers_, uint256 lengthToCheck_,\r\n    uint256 numberToCheck_) internal pure returns (bool) {\r\n        // Run through the defined length on the array to check\r\n        for (uint256 i = 0; i <= lengthToCheck_; i++) {\r\n            // If the number to check exists in the randomNumbers_ array\r\n            if (numberToCheck_ == randomNumbers_[i]) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // If the loop runs and no if-statements hit then...\r\n        return false;\r\n    }\r\n\r\n    // Now, we define a free view-only function for free usage\r\n    function returnRandomNumbersNoDuplicates(uint256 maxNumber_, uint256 amount_) public\r\n    view returns (uint256[] memory) {\r\n        // First, we create a memory array with intended size\r\n        uint256[] memory _randomNumbers = new uint256[] (amount_);\r\n\r\n        // Then, here we create an internal nonce to use\r\n        uint256 _internalNonce;\r\n\r\n        // Then, we call the RNC contract to consume its number with nonces for seed\r\n        for (uint256 i = 0; i < amount_; i++) {\r\n\r\n            // NoDuplicates: we first loop through the entire memory array to check if \r\n            // the returned number exists in the array already. If so, pull a new number\r\n            // and run the check again.\r\n\r\n            uint256 _randomNumber = RNC.returnRandomNumber(maxNumber_, _internalNonce);\r\n            \r\n            // Keep doing this if _existsInArray returns true\r\n            while (_existsInArray(_randomNumbers, i, _randomNumber)) {\r\n                // Increase the nonce and reroll the number\r\n                _randomNumber = RNC.returnRandomNumber(maxNumber_, ++_internalNonce);\r\n            }\r\n\r\n            // If the doesn't exist in the array... Increase the _internalNonce \r\n            _internalNonce++;\r\n\r\n            // And set the _randomNumber into the array!\r\n            _randomNumbers[i] = _randomNumber;\r\n        }\r\n\r\n        // After the entire loop runs, return the _randomNumbers array.\r\n        return _randomNumbers;\r\n    }\r\n\r\n    // This function can get stupidly expensive. CHECK YOUR GAS COSTS FIRST.\r\n    // The cost grows exponentially with the number of items you want.\r\n    function emitRandomNumbersNoDuplicates(string calldata message_, uint256 maxNumber_,\r\n    uint256 amount_) external returns (uint256[] memory) {\r\n        // First, we call returnRandomNumbers() to get the array\r\n        uint256[] memory _randomNumbers = \r\n            returnRandomNumbersNoDuplicates(maxNumber_, amount_);\r\n        \r\n        // Now, we emit the standard event.\r\n        emit RandomNumbersPulled(message_, _randomNumbers);\r\n\r\n        // Return it in case external contracts or functions want to interface this\r\n        return _randomNumbers;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"message_\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"numbers_\",\"type\":\"uint256[]\"}],\"name\":\"RandomNumbersPulled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"RNC\",\"outputs\":[{\"internalType\":\"contract IRandomNumberConsumer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxNumber_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"emitRandomNumbers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"message_\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"maxNumber_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"emitRandomNumbersNoDuplicates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNumber_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"returnRandomNumbers\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxNumber_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"returnRandomNumbersNoDuplicates\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RandomNumberGenerator", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://101fd9f19977932d996483e764205affc3bcd92b118c3848e165c207553dfac2"}]}