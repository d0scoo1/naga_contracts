{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/timelocks/FixedQuadraticTimelockedDelegatorUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./FixedQuadraticTokenTimelockUpgradeable.sol\\\";\\n\\ninterface IVotingToken is IERC20 {\\n    function delegate(address delegatee) external;\\n}\\n\\n/// @title a timelock for tokens allowing for bulk delegation\\n/// @author Fei Protocol\\n/// @notice allows the timelocked tokens to be delegated by the beneficiary while locked\\ncontract FixedQuadraticTimelockedDelegatorUpgradeable is FixedQuadraticTokenTimelockUpgradeable {\\n    /// @notice accept beneficiary role over timelocked TRIBE\\n    function acceptBeneficiary() public override {\\n        _setBeneficiary(msg.sender);\\n    }\\n\\n    /// @notice delegate all held TRIBE to the `to` address\\n    function delegate(address to) public onlyBeneficiary {\\n        IVotingToken(address(lockedToken)).delegate(to);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/timelocks/FixedQuadraticTokenTimelockUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"./FixedTokenTimelockUpgradeable.sol\\\";\\n\\ncontract FixedQuadraticTokenTimelockUpgradeable is Initializable, FixedTokenTimelockUpgradeable {\\n\\n    function initialize(\\n        address _beneficiary,\\n        uint256 _duration,\\n        address _lockedToken,\\n        uint256 _cliffDuration,\\n        address _clawbackAdmin,\\n        uint256 _lockedAmount,\\n        uint256 _startTime\\n    ) external initializer {\\n        __FixedTokenTimelock_init(\\n            _beneficiary, \\n            _duration, \\n            _lockedToken, \\n            _cliffDuration,\\n            _clawbackAdmin,\\n            _lockedAmount\\n        );\\n\\n        if (_startTime != 0) {\\n            startTime = _startTime;\\n        }\\n    }\\n\\n    function _proportionAvailable(\\n        uint256 initialBalance,\\n        uint256 elapsed,\\n        uint256 duration\\n    ) internal pure override returns (uint256) {\\n        return initialBalance * elapsed * elapsed / duration / duration;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/timelocks/FixedTokenTimelockUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"./TokenTimelockUpgradeable.sol\\\";\\n\\nabstract contract FixedTokenTimelockUpgradeable is TokenTimelockUpgradeable {\\n    /// @notice amount of tokens already claimed\\n    uint256 public claimedAmount;\\n\\n    function __FixedTokenTimelock_init(\\n        address _beneficiary,\\n        uint256 _duration,\\n        address _lockedToken,\\n        uint256 _cliffDuration,\\n        address _clawbackAdmin,\\n        uint256 _lockedAmount\\n    ) internal onlyInitializing {\\n        __TokenTimelock_init(\\n            _beneficiary, \\n            _duration, \\n            _cliffDuration,\\n            _lockedToken, \\n            _clawbackAdmin\\n        );\\n\\n        require(_lockedAmount > 0, \\\"FixedTokenTimelock: no amount locked\\\");\\n        initialBalance = _lockedAmount;\\n    }\\n\\n    // Prevents incoming LP tokens from messing up calculations\\n    modifier balanceCheck() override {\\n        _;\\n    }\\n\\n    /// @notice amount of tokens released to beneficiary\\n    function alreadyReleasedAmount() public view override returns (uint256) {\\n        return claimedAmount;\\n    }\\n\\n    function _release(address to, uint256 amount) internal override {\\n        claimedAmount = claimedAmount + amount;\\n        lockedToken.transfer(to, amount);\\n        emit Release(beneficiary, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/timelocks/TokenTimelockUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\n// Inspired by OpenZeppelin TokenTimelock contract\\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/TokenTimelock.sol\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"../utils/TimedUpgradeable.sol\\\";\\nimport \\\"./ITokenTimelock.sol\\\";\\n\\nabstract contract TokenTimelockUpgradeable is Initializable, ITokenTimelock, TimedUpgradeable {\\n\\n    /// @notice ERC20 basic token contract being held in timelock\\n    IERC20 public override lockedToken;\\n\\n    /// @notice beneficiary of tokens after they are released\\n    address public override beneficiary;\\n\\n    /// @notice pending beneficiary appointed by current beneficiary\\n    address public override pendingBeneficiary;\\n\\n    /// @notice initial balance of lockedToken\\n    uint256 public override initialBalance;\\n\\n    uint256 internal lastBalance;\\n\\n    /// @notice number of seconds before releasing is allowed\\n    uint256 public cliffSeconds;\\n\\n    address public clawbackAdmin;\\n\\n    function __TokenTimelock_init(\\n        address _beneficiary,\\n        uint256 _duration,\\n        uint256 _cliffSeconds,\\n        address _lockedToken,\\n        address _clawbackAdmin\\n    ) internal onlyInitializing {\\n        __Timed_init_unchained(_duration);\\n        __TokenTimelock_init_unchained(\\n            _beneficiary,\\n            _duration,\\n            _cliffSeconds,\\n            _lockedToken,\\n            _clawbackAdmin\\n        );\\n    }\\n\\n    function __TokenTimelock_init_unchained(\\n        address _beneficiary,\\n        uint256 _duration,\\n        uint256 _cliffSeconds,\\n        address _lockedToken,\\n        address _clawbackAdmin\\n    ) internal onlyInitializing {\\n        require(_duration != 0, \\\"TokenTimelock: duration is 0\\\");\\n        require(\\n            _beneficiary != address(0),\\n            \\\"TokenTimelock: Beneficiary must not be 0 address\\\"\\n        );\\n\\n        beneficiary = _beneficiary;\\n        _initTimed();\\n\\n        _setLockedToken(_lockedToken);\\n\\n        cliffSeconds = _cliffSeconds;\\n\\n        clawbackAdmin = _clawbackAdmin;\\n    }\\n\\n    // Prevents incoming LP tokens from messing up calculations\\n    modifier balanceCheck() virtual {\\n        if (totalToken() > lastBalance) {\\n            uint256 delta = totalToken() - lastBalance;\\n            initialBalance = initialBalance + delta;\\n        }\\n        _;\\n        lastBalance = totalToken();\\n    }\\n\\n    modifier onlyBeneficiary() {\\n        require(\\n            msg.sender == beneficiary,\\n            \\\"TokenTimelock: Caller is not a beneficiary\\\"\\n        );\\n        _;\\n    }\\n\\n    /// @notice releases `amount` unlocked tokens to address `to`\\n    function release(address to, uint256 amount) external override onlyBeneficiary balanceCheck {\\n        require(amount != 0, \\\"TokenTimelock: no amount desired\\\");\\n        require(passedCliff(), \\\"TokenTimelock: Cliff not passed\\\");\\n\\n        uint256 available = availableForRelease();\\n        require(amount <= available, \\\"TokenTimelock: not enough released tokens\\\");\\n\\n        _release(to, amount);\\n    }\\n\\n    /// @notice releases maximum unlocked tokens to address `to`\\n    function releaseMax(address to) external override onlyBeneficiary balanceCheck {\\n        require(passedCliff(), \\\"TokenTimelock: Cliff not passed\\\");\\n        _release(to, availableForRelease());\\n    }\\n\\n    /// @notice the total amount of tokens held by timelock\\n    function totalToken() public view override virtual returns (uint256) {\\n        return lockedToken.balanceOf(address(this));\\n    }\\n\\n    /// @notice amount of tokens released to beneficiary\\n    function alreadyReleasedAmount() public view override virtual returns (uint256) {\\n        return initialBalance - totalToken();\\n    }\\n\\n    /// @notice amount of held tokens unlocked and available for release\\n    function availableForRelease() public view override returns (uint256) {\\n        uint256 elapsed = timeSinceStart();\\n\\n        uint256 totalAvailable = _proportionAvailable(initialBalance, elapsed, duration);\\n        uint256 netAvailable = totalAvailable - alreadyReleasedAmount();\\n        return netAvailable;\\n    }\\n\\n    /// @notice current beneficiary can appoint new beneficiary, which must be accepted\\n    function setPendingBeneficiary(address _pendingBeneficiary)\\n        public\\n        override\\n        onlyBeneficiary\\n    {\\n        pendingBeneficiary = _pendingBeneficiary;\\n        emit PendingBeneficiaryUpdate(_pendingBeneficiary);\\n    }\\n\\n    /// @notice pending beneficiary accepts new beneficiary\\n    function acceptBeneficiary() public override virtual {\\n        _setBeneficiary(msg.sender);\\n    }\\n\\n    function clawback() public balanceCheck {\\n        require(msg.sender == clawbackAdmin, \\\"TokenTimelock: Only clawbackAdmin\\\");\\n        if (passedCliff()) {\\n            _release(beneficiary, availableForRelease());\\n        }\\n        _release(clawbackAdmin, totalToken());\\n    }\\n\\n    function passedCliff() public view returns (bool) {\\n        return timeSinceStart() >= cliffSeconds;\\n    }\\n\\n    function _proportionAvailable(uint256 initialBalance, uint256 elapsed, uint256 duration) internal pure virtual returns (uint256);\\n\\n    function _setBeneficiary(address newBeneficiary) internal {\\n        require(\\n            newBeneficiary == pendingBeneficiary,\\n            \\\"TokenTimelock: Caller is not pending beneficiary\\\"\\n        );\\n        beneficiary = newBeneficiary;\\n        emit BeneficiaryUpdate(newBeneficiary);\\n        pendingBeneficiary = address(0);\\n    }\\n\\n    function _setLockedToken(address tokenAddress) internal {\\n        lockedToken = IERC20(tokenAddress);\\n    }\\n\\n    function _release(address to, uint256 amount) internal virtual {\\n        lockedToken.transfer(to, amount);\\n        emit Release(beneficiary, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/TimedUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n/// @title an abstract contract for timed events\\n/// @author Fei Protocol\\nabstract contract TimedUpgradeable is Initializable {\\n\\n    /// @notice the start timestamp of the timed period\\n    uint256 public startTime;\\n\\n    /// @notice the duration of the timed period\\n    uint256 public duration;\\n\\n    event DurationUpdate(uint256 oldDuration, uint256 newDuration);\\n\\n    event TimerReset(uint256 startTime);\\n\\n    function __Timed_init(uint256 _duration) internal onlyInitializing {\\n        __Timed_init_unchained(_duration);\\n    }\\n\\n    function __Timed_init_unchained(uint256 _duration) internal onlyInitializing {\\n        _setDuration(_duration);\\n    }\\n\\n    modifier duringTime() {\\n        require(isTimeStarted(), \\\"Timed: time not started\\\");\\n        require(!isTimeEnded(), \\\"Timed: time ended\\\");\\n        _;\\n    }\\n\\n    modifier afterTime() {\\n        require(isTimeEnded(), \\\"Timed: time not ended\\\");\\n        _;\\n    }\\n\\n    /// @notice return true if time period has ended\\n    function isTimeEnded() public view returns (bool) {\\n        return remainingTime() == 0;\\n    }\\n\\n    /// @notice number of seconds remaining until time is up\\n    /// @return remaining\\n    function remainingTime() public view returns (uint256) {\\n        return duration - timeSinceStart(); // duration always >= timeSinceStart which is on [0,d]\\n    }\\n\\n    /// @notice number of seconds since contract was initialized\\n    /// @return timestamp\\n    /// @dev will be less than or equal to duration\\n    function timeSinceStart() public view returns (uint256) {\\n        if (!isTimeStarted()) {\\n            return 0; // uninitialized\\n        }\\n        uint256 _duration = duration;\\n        uint256 timePassed = block.timestamp - startTime; // block timestamp always >= startTime\\n        return timePassed > _duration ? _duration : timePassed;\\n    }\\n\\n    function isTimeStarted() public view returns (bool) {\\n        return startTime != 0;\\n    }\\n\\n    function _initTimed() internal {\\n        startTime = block.timestamp;\\n        \\n        emit TimerReset(block.timestamp);\\n    }\\n\\n    function _setDuration(uint256 newDuration) internal {\\n        require(newDuration != 0, \\\"Timed: zero duration\\\");\\n\\n        uint256 oldDuration = duration;\\n        duration = newDuration;\\n        emit DurationUpdate(oldDuration, newDuration);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/timelocks/ITokenTimelock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title TokenTimelock interface\\n/// @author Fei Protocol\\ninterface ITokenTimelock {\\n    // ----------- Events -----------\\n\\n    event Release(address indexed _beneficiary, address indexed _recipient, uint256 _amount);\\n    event BeneficiaryUpdate(address indexed _beneficiary);\\n    event PendingBeneficiaryUpdate(address indexed _pendingBeneficiary);\\n\\n    // ----------- State changing api -----------\\n\\n    function release(address to, uint256 amount) external;\\n\\n    function releaseMax(address to) external;\\n\\n    function setPendingBeneficiary(address _pendingBeneficiary) external;\\n\\n    function acceptBeneficiary() external;\\n\\n\\n    // ----------- Getters -----------\\n\\n    function lockedToken() external view returns (IERC20);\\n\\n    function beneficiary() external view returns (address);\\n\\n    function pendingBeneficiary() external view returns (address);\\n\\n    function initialBalance() external view returns (uint256);\\n\\n    function availableForRelease() external view returns (uint256);\\n\\n    function totalToken() external view returns(uint256);\\n\\n    function alreadyReleasedAmount() external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"BeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDuration\",\"type\":\"uint256\"}],\"name\":\"DurationUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"PendingBeneficiaryUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Release\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"TimerReset\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alreadyReleasedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"availableForRelease\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimedAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"clawbackAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cliffSeconds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_lockedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cliffDuration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_clawbackAdmin\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTimeStarted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockedToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"passedCliff\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBeneficiary\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"releaseMax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingBeneficiary\",\"type\":\"address\"}],\"name\":\"setPendingBeneficiary\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeSinceStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FixedQuadraticTimelockedDelegatorUpgradeable", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}