{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/TwapOraclePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"./interfaces/IUniswapV2Factory.sol\\\";\\r\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./interfaces/ITwapOraclePriceFeed.sol\\\";\\r\\n\\r\\nimport \\\"./libraries/FixedPoint.sol\\\";\\r\\nimport \\\"./libraries/UniswapV2OracleLibrary.sol\\\";\\r\\nimport \\\"./libraries/UniswapV2Library.sol\\\";\\r\\n\\r\\n// fixed window oracle that recomputes the average price for the entire period once every period\\r\\n// note that the price average is only guaranteed to be over at least 1 period, but may be over a longer period\\r\\ncontract TwapOraclePriceFeed is ITwapOraclePriceFeed {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    uint256 public constant PERIOD = 120 seconds;\\r\\n\\r\\n    IUniswapV2Pair immutable pair;\\r\\n    address public immutable token0;\\r\\n    address public immutable token1;\\r\\n\\r\\n    uint256 public price0CumulativeLast;\\r\\n    uint256 public price1CumulativeLast;\\r\\n    uint32 public blockTimestampLast;\\r\\n    FixedPoint.uq112x112 public price0Average;\\r\\n    FixedPoint.uq112x112 public price1Average;\\r\\n\\r\\n    constructor(\\r\\n        address factory,\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) {\\r\\n        IUniswapV2Pair _pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, tokenA, tokenB));\\r\\n        pair = _pair;\\r\\n        token0 = _pair.token0();\\r\\n        token1 = _pair.token1();\\r\\n        price0CumulativeLast = _pair.price0CumulativeLast(); // fetch the current accumulated price value (1 / 0)\\r\\n        price1CumulativeLast = _pair.price1CumulativeLast(); // fetch the current accumulated price value (0 / 1)\\r\\n        uint112 reserve0;\\r\\n        uint112 reserve1;\\r\\n        (reserve0, reserve1, blockTimestampLast) = _pair.getReserves();\\r\\n        require(reserve0 != 0 && reserve1 != 0, \\\"NO_RESERVES\\\"); // ensure that there's liquidity in the pair\\r\\n        _initialPrice(_pair);\\r\\n    }\\r\\n\\r\\n    function update() external override {\\r\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\\r\\n            .currentCumulativePrices(address(pair));\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n        // ensure that at least one full period has passed since the last update\\r\\n        require(timeElapsed >= PERIOD, \\\"PERIOD_NOT_ELAPSED\\\");\\r\\n\\r\\n        // overflow is desired, casting never truncates\\r\\n        // cumulative price is in (uq112x112 price * seconds) units so we simply wrap it after division by time elapsed\\r\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\r\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\r\\n\\r\\n        price0CumulativeLast = price0Cumulative;\\r\\n        price1CumulativeLast = price1Cumulative;\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n    }\\r\\n\\r\\n    // note this will always return 0 before update has been called successfully for the first time.\\r\\n    function consult(address token, uint256 amountIn) external view override returns (uint256 amountOut) {\\r\\n        if (token == token0) {\\r\\n            amountOut = price0Average.mul(amountIn).decode144();\\r\\n        } else {\\r\\n            require(token == token1, \\\"INVALID_TOKEN\\\");\\r\\n            amountOut = price1Average.mul(amountIn).decode144();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _initialPrice(IUniswapV2Pair _pair) private {\\r\\n        (uint256 price0Cumulative, uint256 price1Cumulative, uint32 blockTimestamp) = UniswapV2OracleLibrary\\r\\n            .currentCumulativePrices(address(_pair));\\r\\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\r\\n\\r\\n        price0Average = FixedPoint.uq112x112(uint224((price0Cumulative - price0CumulativeLast) / timeElapsed));\\r\\n        price1Average = FixedPoint.uq112x112(uint224((price1Cumulative - price1CumulativeLast) / timeElapsed));\\r\\n\\r\\n        price0CumulativeLast = price0Cumulative;\\r\\n        price1CumulativeLast = price1Cumulative;\\r\\n        blockTimestampLast = blockTimestamp;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Factory {\\r\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\r\\n\\r\\n    function feeTo() external view returns (address);\\r\\n\\r\\n    function feeToSetter() external view returns (address);\\r\\n\\r\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\r\\n\\r\\n    function allPairs(uint256) external view returns (address pair);\\r\\n\\r\\n    function allPairsLength() external view returns (uint256);\\r\\n\\r\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\r\\n\\r\\n    function setFeeTo(address) external;\\r\\n\\r\\n    function setFeeToSetter(address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\ninterface IUniswapV2Pair {\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    function name() external pure returns (string memory);\\r\\n\\r\\n    function symbol() external pure returns (string memory);\\r\\n\\r\\n    function decimals() external pure returns (uint8);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view returns (uint256);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n    function transfer(address to, uint256 value) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 value\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\r\\n\\r\\n    function nonces(address owner) external view returns (uint256);\\r\\n\\r\\n    function permit(\\r\\n        address owner,\\r\\n        address spender,\\r\\n        uint256 value,\\r\\n        uint256 deadline,\\r\\n        uint8 v,\\r\\n        bytes32 r,\\r\\n        bytes32 s\\r\\n    ) external;\\r\\n\\r\\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\\r\\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\\r\\n    event Swap(\\r\\n        address indexed sender,\\r\\n        uint256 amount0In,\\r\\n        uint256 amount1In,\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address indexed to\\r\\n    );\\r\\n    event Sync(uint112 reserve0, uint112 reserve1);\\r\\n\\r\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    function token0() external view returns (address);\\r\\n\\r\\n    function token1() external view returns (address);\\r\\n\\r\\n    function getReserves()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint112 reserve0,\\r\\n            uint112 reserve1,\\r\\n            uint32 blockTimestampLast\\r\\n        );\\r\\n\\r\\n    function price0CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function price1CumulativeLast() external view returns (uint256);\\r\\n\\r\\n    function kLast() external view returns (uint256);\\r\\n\\r\\n    function mint(address to) external returns (uint256 liquidity);\\r\\n\\r\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    function swap(\\r\\n        uint256 amount0Out,\\r\\n        uint256 amount1Out,\\r\\n        address to,\\r\\n        bytes calldata data\\r\\n    ) external;\\r\\n\\r\\n    function skim(address to) external;\\r\\n\\r\\n    function sync() external;\\r\\n\\r\\n    function initialize(address, address) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOraclePriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.8.0;\\r\\n\\r\\ninterface ITwapOraclePriceFeed {\\r\\n    function update() external;\\r\\n\\r\\n    function consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\nimport \\\"./FullMath.sol\\\";\\r\\nimport \\\"./Babylonian.sol\\\";\\r\\nimport \\\"./BitMath.sol\\\";\\r\\n\\r\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\r\\nlibrary FixedPoint {\\r\\n    // range: [0, 2**112 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq112x112 {\\r\\n        uint224 _x;\\r\\n    }\\r\\n\\r\\n    // range: [0, 2**144 - 1]\\r\\n    // resolution: 1 / 2**112\\r\\n    struct uq144x112 {\\r\\n        uint256 _x;\\r\\n    }\\r\\n\\r\\n    uint8 public constant RESOLUTION = 112;\\r\\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\\r\\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\\r\\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\\r\\n\\r\\n    // encode a uint112 as a UQ112x112\\r\\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\\r\\n        return uq112x112(uint224(x) << RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // encodes a uint144 as a UQ144x112\\r\\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\\r\\n        return uq144x112(uint256(x) << RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\r\\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\\r\\n        return uint112(self._x >> RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\\r\\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\\r\\n        return uint144(self._x >> RESOLUTION);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\\r\\n    // reverts on overflow\\r\\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\\r\\n        uint256 z = 0;\\r\\n        require(y == 0 || (z = self._x * y) / y == self._x, \\\"FixedPoint::mul: overflow\\\");\\r\\n        return uq144x112(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by an int and decode, returning an int\\r\\n    // reverts on overflow\\r\\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\\r\\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\\r\\n        require(z < 2**255, \\\"FixedPoint::muli: overflow\\\");\\r\\n        return y < 0 ? -int256(z) : int256(z);\\r\\n    }\\r\\n\\r\\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    // lossy\\r\\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x == 0 || other._x == 0) {\\r\\n            return uq112x112(0);\\r\\n        }\\r\\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\\r\\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\\r\\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\\r\\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\\r\\n\\r\\n        // partial products\\r\\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\\r\\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\\r\\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\\r\\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\\r\\n\\r\\n        // so the bit shift does not overflow\\r\\n        require(upper <= type(uint112).max, \\\"FixedPoint::muluq: upper overflow\\\");\\r\\n\\r\\n        // this cannot exceed 256 bits, all values are 224 bits\\r\\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\\r\\n\\r\\n        // so the cast does not overflow\\r\\n        require(sum <= type(uint224).max, \\\"FixedPoint::muluq: sum overflow\\\");\\r\\n\\r\\n        return uq112x112(uint224(sum));\\r\\n    }\\r\\n\\r\\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\\r\\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\\r\\n        require(other._x > 0, \\\"FixedPoint::divuq: division by zero\\\");\\r\\n        if (self._x == other._x) {\\r\\n            return uq112x112(uint224(Q112));\\r\\n        }\\r\\n        if (self._x <= type(uint144).max) {\\r\\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\\r\\n            require(value <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\r\\n            return uq112x112(uint224(value));\\r\\n        }\\r\\n\\r\\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\\r\\n        require(result <= type(uint224).max, \\\"FixedPoint::divuq: overflow\\\");\\r\\n        return uq112x112(uint224(result));\\r\\n    }\\r\\n\\r\\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\\r\\n    // can be lossy\\r\\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\\r\\n        require(denominator > 0, \\\"FixedPoint::fraction: division by zero\\\");\\r\\n        if (numerator == 0) return FixedPoint.uq112x112(0);\\r\\n\\r\\n        if (numerator <= type(uint144).max) {\\r\\n            uint256 result = (numerator << RESOLUTION) / denominator;\\r\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\r\\n            return uq112x112(uint224(result));\\r\\n        } else {\\r\\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\\r\\n            require(result <= type(uint224).max, \\\"FixedPoint::fraction: overflow\\\");\\r\\n            return uq112x112(uint224(result));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // take the reciprocal of a UQ112x112\\r\\n    // reverts on overflow\\r\\n    // lossy\\r\\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        require(self._x != 0, \\\"FixedPoint::reciprocal: reciprocal of zero\\\");\\r\\n        require(self._x != 1, \\\"FixedPoint::reciprocal: overflow\\\");\\r\\n        return uq112x112(uint224(Q224 / self._x));\\r\\n    }\\r\\n\\r\\n    // square root of a UQ112x112\\r\\n    // lossy between 0/1 and 40 bits\\r\\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\\r\\n        if (self._x <= type(uint144).max) {\\r\\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\\r\\n        }\\r\\n\\r\\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\\r\\n        safeShiftBits -= safeShiftBits % 2;\\r\\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2OracleLibrary.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\r\\nimport \\\"./FixedPoint.sol\\\";\\r\\n\\r\\n// library with helper methods for oracles that are concerned with computing average prices\\r\\nlibrary UniswapV2OracleLibrary {\\r\\n    using FixedPoint for *;\\r\\n\\r\\n    // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\\r\\n    function currentBlockTimestamp() internal view returns (uint32) {\\r\\n        return uint32(block.timestamp % 2**32);\\r\\n    }\\r\\n\\r\\n    // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\\r\\n    function currentCumulativePrices(address pair)\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint256 price0Cumulative,\\r\\n            uint256 price1Cumulative,\\r\\n            uint32 blockTimestamp\\r\\n        )\\r\\n    {\\r\\n        blockTimestamp = currentBlockTimestamp();\\r\\n        price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\\r\\n        price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\\r\\n\\r\\n        // if time has elapsed since the last update on the pair, mock the accumulated price values\\r\\n        (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(pair).getReserves();\\r\\n        if (blockTimestampLast != blockTimestamp) {\\r\\n            // subtraction overflow is desired\\r\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast;\\r\\n            // addition overflow is desired\\r\\n            // counterfactual\\r\\n            price0Cumulative += uint256(FixedPoint.fraction(reserve1, reserve0)._x) * timeElapsed;\\r\\n            // counterfactual\\r\\n            price1Cumulative += uint256(FixedPoint.fraction(reserve0, reserve1)._x) * timeElapsed;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity 0.8.0;\\r\\n\\r\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\r\\n\\r\\nlibrary UniswapV2Library {\\r\\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\\r\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\r\\n        require(tokenA != tokenB, \\\"UniswapV2Library: IDENTICAL_ADDRESSES\\\");\\r\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\r\\n        require(token0 != address(0), \\\"UniswapV2Library: ZERO_ADDRESS\\\");\\r\\n    }\\r\\n\\r\\n    // calculates the CREATE2 address for a pair without making any external calls\\r\\n    function pairFor(\\r\\n        address factory,\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) internal pure returns (address pair) {\\r\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\r\\n        pair = address(\\r\\n            uint160(\\r\\n                uint256(\\r\\n                    keccak256(\\r\\n                        abi.encodePacked(\\r\\n                            hex\\\"ff\\\",\\r\\n                            factory,\\r\\n                            keccak256(abi.encodePacked(token0, token1)),\\r\\n                            hex\\\"96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f\\\" // init code hash\\r\\n                        )\\r\\n                    )\\r\\n                )\\r\\n            )\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // fetches and sorts the reserves for a pair\\r\\n    function getReserves(\\r\\n        address factory,\\r\\n        address tokenA,\\r\\n        address tokenB\\r\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\r\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\r\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\r\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\r\\n    }\\r\\n\\r\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\r\\n    function quote(\\r\\n        uint256 amountA,\\r\\n        uint256 reserveA,\\r\\n        uint256 reserveB\\r\\n    ) internal pure returns (uint256 amountB) {\\r\\n        require(amountA > 0, \\\"UniswapV2Library: INSUFFICIENT_AMOUNT\\\");\\r\\n        require(reserveA > 0 && reserveB > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\r\\n        amountB = (amountA * reserveB) / reserveA;\\r\\n    }\\r\\n\\r\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\r\\n    function getAmountOut(\\r\\n        uint256 amountIn,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) internal pure returns (uint256 amountOut) {\\r\\n        require(amountIn > 0, \\\"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\r\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\r\\n        uint256 amountInWithFee = amountIn * 997;\\r\\n        uint256 numerator = amountInWithFee * reserveOut;\\r\\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\\r\\n        amountOut = numerator / denominator;\\r\\n    }\\r\\n\\r\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\r\\n    function getAmountIn(\\r\\n        uint256 amountOut,\\r\\n        uint256 reserveIn,\\r\\n        uint256 reserveOut\\r\\n    ) internal pure returns (uint256 amountIn) {\\r\\n        require(amountOut > 0, \\\"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\");\\r\\n        require(reserveIn > 0 && reserveOut > 0, \\\"UniswapV2Library: INSUFFICIENT_LIQUIDITY\\\");\\r\\n        uint256 numerator = reserveIn * amountOut * 1000;\\r\\n        uint256 denominator = reserveOut - amountOut * 997;\\r\\n        amountIn = (numerator / denominator) + 1;\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountOut calculations on any number of pairs\\r\\n    function getAmountsOut(\\r\\n        address factory,\\r\\n        uint256 amountIn,\\r\\n        address[] memory path\\r\\n    ) internal view returns (uint256[] memory amounts) {\\r\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\r\\n        amounts = new uint256[](path.length);\\r\\n        amounts[0] = amountIn;\\r\\n        for (uint256 i; i < path.length - 1; i++) {\\r\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);\\r\\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // performs chained getAmountIn calculations on any number of pairs\\r\\n    function getAmountsIn(\\r\\n        address factory,\\r\\n        uint256 amountOut,\\r\\n        address[] memory path\\r\\n    ) internal view returns (uint256[] memory amounts) {\\r\\n        require(path.length >= 2, \\\"UniswapV2Library: INVALID_PATH\\\");\\r\\n        amounts = new uint256[](path.length);\\r\\n        amounts[amounts.length - 1] = amountOut;\\r\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\r\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\r\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\\r\\n// license is CC-BY-4.0\\r\\nlibrary FullMath {\\r\\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\\r\\n        uint256 mm = mulmod(x, y, type(uint256).max);\\r\\n        l = x * y;\\r\\n        h = mm - l;\\r\\n        if (mm < l) h -= 1;\\r\\n    }\\r\\n\\r\\n    function fullDiv(\\r\\n        uint256 l,\\r\\n        uint256 h,\\r\\n        uint256 d\\r\\n    ) private pure returns (uint256) {\\r\\n        uint256 pow2 = d & (~d + 1);\\r\\n        d /= pow2;\\r\\n        l /= pow2;\\r\\n        l += h * ((~pow2 + 1) / pow2 + 1);\\r\\n        uint256 r = 1;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        r *= 2 - d * r;\\r\\n        return l * r;\\r\\n    }\\r\\n\\r\\n    function mulDiv(\\r\\n        uint256 x,\\r\\n        uint256 y,\\r\\n        uint256 d\\r\\n    ) internal pure returns (uint256) {\\r\\n        (uint256 l, uint256 h) = fullMul(x, y);\\r\\n\\r\\n        uint256 mm = mulmod(x, y, d);\\r\\n        if (mm > l) h -= 1;\\r\\n        l -= mm;\\r\\n\\r\\n        if (h == 0) return l / d;\\r\\n\\r\\n        require(h < d, \\\"FullMath: FULLDIV_OVERFLOW\\\");\\r\\n        return fullDiv(l, h, d);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/Babylonian.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\n\\r\\npragma solidity >=0.4.0;\\r\\n\\r\\n// computes square roots using the babylonian method\\r\\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\\r\\nlibrary Babylonian {\\r\\n    // credit for this implementation goes to\\r\\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\\r\\n    function sqrt(uint256 x) internal pure returns (uint256) {\\r\\n        if (x == 0) return 0;\\r\\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\\r\\n        // however that code costs significantly more gas\\r\\n        uint256 xx = x;\\r\\n        uint256 r = 1;\\r\\n        if (xx >= 0x100000000000000000000000000000000) {\\r\\n            xx >>= 128;\\r\\n            r <<= 64;\\r\\n        }\\r\\n        if (xx >= 0x10000000000000000) {\\r\\n            xx >>= 64;\\r\\n            r <<= 32;\\r\\n        }\\r\\n        if (xx >= 0x100000000) {\\r\\n            xx >>= 32;\\r\\n            r <<= 16;\\r\\n        }\\r\\n        if (xx >= 0x10000) {\\r\\n            xx >>= 16;\\r\\n            r <<= 8;\\r\\n        }\\r\\n        if (xx >= 0x100) {\\r\\n            xx >>= 8;\\r\\n            r <<= 4;\\r\\n        }\\r\\n        if (xx >= 0x10) {\\r\\n            xx >>= 4;\\r\\n            r <<= 2;\\r\\n        }\\r\\n        if (xx >= 0x8) {\\r\\n            r <<= 1;\\r\\n        }\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1;\\r\\n        r = (r + x / r) >> 1; // Seven iterations should be enough\\r\\n        uint256 r1 = x / r;\\r\\n        return (r < r1 ? r : r1);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/BitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nlibrary BitMath {\\r\\n    // returns the 0 indexed position of the most significant bit of the input x\\r\\n    // s.t. x >= 2**msb and x < 2**(msb+1)\\r\\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x > 0, \\\"BitMath::mostSignificantBit: zero\\\");\\r\\n\\r\\n        if (x >= 0x100000000000000000000000000000000) {\\r\\n            x >>= 128;\\r\\n            r += 128;\\r\\n        }\\r\\n        if (x >= 0x10000000000000000) {\\r\\n            x >>= 64;\\r\\n            r += 64;\\r\\n        }\\r\\n        if (x >= 0x100000000) {\\r\\n            x >>= 32;\\r\\n            r += 32;\\r\\n        }\\r\\n        if (x >= 0x10000) {\\r\\n            x >>= 16;\\r\\n            r += 16;\\r\\n        }\\r\\n        if (x >= 0x100) {\\r\\n            x >>= 8;\\r\\n            r += 8;\\r\\n        }\\r\\n        if (x >= 0x10) {\\r\\n            x >>= 4;\\r\\n            r += 4;\\r\\n        }\\r\\n        if (x >= 0x4) {\\r\\n            x >>= 2;\\r\\n            r += 2;\\r\\n        }\\r\\n        if (x >= 0x2) r += 1;\\r\\n    }\\r\\n\\r\\n    // returns the 0 indexed position of the least significant bit of the input x\\r\\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\\r\\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\\r\\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\\r\\n        require(x > 0, \\\"BitMath::leastSignificantBit: zero\\\");\\r\\n\\r\\n        r = 255;\\r\\n        if (x & type(uint128).max > 0) {\\r\\n            r -= 128;\\r\\n        } else {\\r\\n            x >>= 128;\\r\\n        }\\r\\n        if (x & type(uint64).max > 0) {\\r\\n            r -= 64;\\r\\n        } else {\\r\\n            x >>= 64;\\r\\n        }\\r\\n        if (x & type(uint32).max > 0) {\\r\\n            r -= 32;\\r\\n        } else {\\r\\n            x >>= 32;\\r\\n        }\\r\\n        if (x & type(uint16).max > 0) {\\r\\n            r -= 16;\\r\\n        } else {\\r\\n            x >>= 16;\\r\\n        }\\r\\n        if (x & type(uint8).max > 0) {\\r\\n            r -= 8;\\r\\n        } else {\\r\\n            x >>= 8;\\r\\n        }\\r\\n        if (x & 0xf > 0) {\\r\\n            r -= 4;\\r\\n        } else {\\r\\n            x >>= 4;\\r\\n        }\\r\\n        if (x & 0x3 > 0) {\\r\\n            r -= 2;\\r\\n        } else {\\r\\n            x >>= 2;\\r\\n        }\\r\\n        if (x & 0x1 > 0) r -= 1;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blockTimestampLast\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"consult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0Average\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1Average\",\"outputs\":[{\"internalType\":\"uint224\",\"name\":\"_x\",\"type\":\"uint224\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TwapOraclePriceFeed", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000000000000000000000000d85ad783cc94bd04196a13dc042a3054a9b52210", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}