{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/BridgedOracleArtBlocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./PriceOracle.sol\\\";\\nimport \\\"./ChainlinkOracle/ChainlinkOracleArtBlocks.sol\\\";\\n\\ncontract BridgedOracleArtBlocks is PriceOracle {\\n    address public admin;\\n    ChainlinkOracleArtBlocks public chainlink;\\n    PriceOracle public uniswap;\\n\\n    mapping(address => bool) chainlinkAssets;\\n    mapping(address => bool) chainlinkETHs;\\n\\n    constructor(address _chainlink, address _uniswap) public {\\n        admin = msg.sender;\\n        chainlink = ChainlinkOracleArtBlocks(_chainlink);\\n        uniswap = PriceOracle(_uniswap);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin may call\\\");\\n        _;\\n    }\\n\\n    function getUnderlyingPriceView(address cToken)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (chainlinkAssets[cToken]) {\\n            if (chainlinkETHs[cToken]) {\\n                return chainlink.getUnderlyingPriceETH();\\n            } else {\\n                return chainlink.getUnderlyingPriceView(cToken);\\n            }\\n        } else {\\n            return uniswap.getUnderlyingPriceView(cToken);\\n        }\\n    }\\n\\n    function getUnderlyingPrice(address cToken)\\n        public\\n        override\\n        returns (uint256)\\n    {\\n        if (chainlinkAssets[cToken]) {\\n            if (chainlinkETHs[cToken]) {\\n                return chainlink.getUnderlyingPriceETH();\\n            } else {\\n                return chainlink.getUnderlyingPrice(cToken);\\n            }\\n        } else {\\n            return uniswap.getUnderlyingPrice(cToken);\\n        }\\n    }\\n\\n    function registerChainlinkAsset(\\n        address token,\\n        string calldata symbol,\\n        address feed,\\n        uint256 decimal,\\n        bool base,\\n        bool isETH\\n    ) public onlyAdmin {\\n        require(!chainlinkAssets[token], \\\"Already registered\\\");\\n        chainlinkAssets[token] = true;\\n        chainlinkETHs[token] = isETH;\\n        chainlink.setFeed(token, symbol, feed, decimal, base);\\n    }\\n\\n    function deregisterChainlinkAsset(address token) public onlyAdmin {\\n        require(chainlinkAssets[token], \\\"Already deregistered\\\");\\n        chainlinkAssets[token] = false;\\n    }\\n\\n    function getChainlinkAsset(address token) public view returns (bool) {\\n        return chainlinkAssets[token];\\n    }\\n\\n    function releaseChainlink(address newAdmin) public onlyAdmin {\\n        chainlink.setAdmin(newAdmin);\\n    }\\n\\n    function updateChainlink(address newChainlink) public onlyAdmin {\\n        chainlink = ChainlinkOracleArtBlocks(newChainlink);\\n        chainlink.setAdmin(address(this));\\n    }\\n\\n    function updateUniswap(address newUniswap) public onlyAdmin {\\n        uniswap = PriceOracle(newUniswap);\\n    }\\n\\n    function compareStrings(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return (keccak256(abi.encodePacked((a))) ==\\n            keccak256(abi.encodePacked((b))));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChainlinkOracle/AggregatorV2V3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n/**\\n * @title The V2 & V3 Aggregator Interface\\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\\n * and v0.5 AggregatorV3Interface.sol.\\n */\\ninterface AggregatorV2V3Interface {\\n  //\\n  // V2 Interface:\\n  //\\n  function latestAnswer() external view returns (int256);\\n  function latestTimestamp() external view returns (uint256);\\n  function latestRound() external view returns (uint256);\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n\\n  //\\n  // V3 Interface:\\n  //\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/ChainlinkOracle/ChainlinkOracleArtBlocks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../PriceOracle.sol\\\";\\nimport \\\"../SafeMath.sol\\\";\\nimport \\\"./AggregatorV2V3Interface.sol\\\";\\n\\ninterface IToken {\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\\ninterface ICToken {\\n    function symbol() external view returns (string memory);\\n\\n    function underlying() external view returns (address);\\n}\\n\\ncontract ChainlinkOracleArtBlocks is PriceOracle {\\n    using SafeMath for uint256;\\n    address public admin;\\n\\n    mapping(address => uint256) internal prices;\\n    mapping(bytes32 => AggregatorV2V3Interface) internal feeds;\\n    mapping(bytes32 => uint256) internal decimals;\\n    mapping(bytes32 => bool) internal bases;\\n    mapping(address => string) internal symbols;\\n    event PricePosted(\\n        address asset,\\n        uint256 previousPriceMantissa,\\n        uint256 requestedPriceMantissa,\\n        uint256 newPriceMantissa\\n    );\\n    event NewAdmin(address oldAdmin, address newAdmin);\\n    event FeedSet(address feed, string symbol);\\n\\n    constructor() public {\\n        admin = msg.sender;\\n    }\\n\\n    function getUnderlyingPriceETH() public view returns (uint) {\\n        return getChainlinkPrice(getFeed(\\\"ETH\\\"));\\n    }\\n\\n    function getUnderlyingPriceView(address cToken)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return getPrice(cToken);\\n    }\\n\\n    function getUnderlyingPrice(address cToken)\\n        public\\n        override\\n        returns (uint256)\\n    {\\n        return getUnderlyingPriceView(cToken);\\n    }\\n\\n    function getPrice(address cToken) public view returns (uint256 price) {\\n        address token = ICToken(cToken).underlying();\\n        string memory symbol = symbols[cToken];\\n        if (bytes(symbol).length == 0) {\\n            symbol = IToken(token).symbol();\\n        }\\n\\n        if (prices[token] != 0) {\\n            price = prices[token];\\n        } else {\\n            price = getChainlinkPrice(getFeed(symbol));\\n        }\\n\\n        if (!getBase(symbol)) {\\n            AggregatorV2V3Interface baseFeed = getFeed(\\\"ETH\\\");\\n            price = getChainlinkPrice(baseFeed).mul(price).div(10**18);\\n        }\\n\\n        uint256 tokenDecimals = 18;\\n        if (decimals[keccak256(abi.encodePacked(symbol))] > 0) {\\n            tokenDecimals = uint256(IToken(token).decimals());\\n        }\\n\\n        uint256 decimalDelta = uint256(36)\\n            .sub(tokenDecimals)\\n            .sub(getDecimal(symbol));\\n        // Ensure that we don't multiply the result by 0\\n        if (decimalDelta > 0) {\\n            return price.mul(10**decimalDelta);\\n        } else {\\n            return price;\\n        }\\n    }\\n\\n    function getChainlinkPrice(AggregatorV2V3Interface feed)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // Chainlink USD-denominated feeds store answers at 8 decimals\\n        uint256 decimalDelta = uint256(18).sub(feed.decimals());\\n        // Ensure that we don't multiply the result by 0\\n        if (decimalDelta > 0) {\\n            return uint256(feed.latestAnswer()).mul(10**decimalDelta);\\n        } else {\\n            return uint256(feed.latestAnswer());\\n        }\\n    }\\n\\n    function setUnderlyingPrice(address cToken, uint256 underlyingPriceMantissa)\\n        external\\n        onlyAdmin\\n    {\\n        address asset = ICToken(cToken).underlying();\\n        emit PricePosted(\\n            asset,\\n            prices[asset],\\n            underlyingPriceMantissa,\\n            underlyingPriceMantissa\\n        );\\n        prices[asset] = underlyingPriceMantissa;\\n    }\\n\\n    function setDirectPrice(address asset, uint256 price) external onlyAdmin {\\n        emit PricePosted(asset, prices[asset], price, price);\\n        prices[asset] = price;\\n    }\\n\\n    function setFeed(\\n        address cToken,\\n        string calldata symbol,\\n        address feed,\\n        uint256 decimal,\\n        bool base\\n    ) external onlyAdmin {\\n        require(\\n            feed != address(0) && feed != address(this),\\n            \\\"invalid feed address\\\"\\n        );\\n        emit FeedSet(feed, symbol);\\n        feeds[keccak256(abi.encodePacked(symbol))] = AggregatorV2V3Interface(\\n            feed\\n        );\\n        decimals[keccak256(abi.encodePacked(symbol))] = decimal;\\n        bases[keccak256(abi.encodePacked(symbol))] = base;\\n        symbols[cToken] = symbol;\\n    }\\n\\n    function getFeed(string memory symbol)\\n        public\\n        view\\n        returns (AggregatorV2V3Interface)\\n    {\\n        return feeds[keccak256(abi.encodePacked(symbol))];\\n    }\\n\\n    function getBase(string memory symbol) public view returns (bool) {\\n        return bases[keccak256(abi.encodePacked(symbol))];\\n    }\\n\\n    function getDecimal(string memory symbol) public view returns (uint256) {\\n        return decimals[keccak256(abi.encodePacked(symbol))];\\n    }\\n\\n    function assetPrices(address asset) external view returns (uint256) {\\n        return prices[asset];\\n    }\\n\\n    function compareStrings(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return (keccak256(abi.encodePacked((a))) ==\\n            keccak256(abi.encodePacked((b))));\\n    }\\n\\n    function setAdmin(address newAdmin) external onlyAdmin {\\n        address oldAdmin = admin;\\n        admin = newAdmin;\\n\\n        emit NewAdmin(oldAdmin, newAdmin);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == admin, \\\"only admin may call\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nabstract contract PriceOracle {\\n    /// @notice Indicator that this is a PriceOracle contract (for inspection)\\n    bool public constant isPriceOracle = true;\\n\\n    /**\\n      * @notice Get the underlying price of a cToken asset\\n      * @param cToken The cToken to get the underlying price of\\n      * @return The underlying asset price mantissa (scaled by 1e18).\\n      *  Zero means the price is unavailable.\\n      */\\n    function getUnderlyingPrice(address cToken) external virtual returns (uint);\\n\\n    function getUnderlyingPriceView(address cToken) public view virtual returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_chainlink\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswap\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainlink\",\"outputs\":[{\"internalType\":\"contract ChainlinkOracleArtBlocks\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"deregisterChainlinkAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getChainlinkAsset\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPriceView\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPriceOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"feed\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"decimal\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"base\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isETH\",\"type\":\"bool\"}],\"name\":\"registerChainlinkAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"releaseChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswap\",\"outputs\":[{\"internalType\":\"contract PriceOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newChainlink\",\"type\":\"address\"}],\"name\":\"updateChainlink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUniswap\",\"type\":\"address\"}],\"name\":\"updateUniswap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BridgedOracleArtBlocks", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008141a76b4ebc71afc5e0503d2dc08eb6dfc2405e00000000000000000000000052719dca4137e3e92cbb038242feb9c063e63635", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}