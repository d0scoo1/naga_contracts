{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ShackledRenderer.sol\": {\r\n      \"content\": \"// // SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledCoords.sol\\\";\\nimport \\\"./ShackledRasteriser.sol\\\";\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledRenderer {\\n    uint256 constant outputHeight = 512;\\n    uint256 constant outputWidth = 512;\\n\\n    /** @dev take any geometry, render it, and return a bitmap image inside an SVG \\n    this can be called to render the Shackled art collection (the output of ShackledGenesis.sol)\\n    or any other custom made geometry\\n\\n    */\\n    function render(\\n        ShackledStructs.RenderParams memory renderParams,\\n        int256 canvasDim,\\n        bool returnSVG\\n    ) public view returns (string memory) {\\n        /// prepare the fragments\\n        int256[12][3][] memory trisFragments = prepareGeometryForRender(\\n            renderParams,\\n            canvasDim\\n        );\\n\\n        /// run Bresenham's line algorithm to rasterize the fragments\\n        int256[12][] memory fragments = ShackledRasteriser.rasterise(\\n            trisFragments,\\n            canvasDim,\\n            renderParams.wireframe\\n        );\\n\\n        fragments = ShackledRasteriser.depthTesting(fragments, canvasDim);\\n\\n        if (renderParams.lightingParams.applyLighting) {\\n            /// apply lighting (Blinn phong)\\n            fragments = ShackledRasteriser.lightScene(\\n                fragments,\\n                renderParams.lightingParams\\n            );\\n        }\\n\\n        /// get the background\\n        int256[5][] memory background = ShackledRasteriser.getBackground(\\n            canvasDim,\\n            renderParams.backgroundColor\\n        );\\n\\n        /// place each fragment in an encoded bitmap\\n        string memory encodedBitmap = ShackledUtils.getEncodedBitmap(\\n            fragments,\\n            background,\\n            canvasDim,\\n            renderParams.invert\\n        );\\n\\n        if (returnSVG) {\\n            /// insert the bitmap into an encoded svg (to be accepted by OpenSea)\\n            return\\n                ShackledUtils.getSVGContainer(\\n                    encodedBitmap,\\n                    canvasDim,\\n                    outputHeight,\\n                    outputWidth\\n                );\\n        } else {\\n            return encodedBitmap;\\n        }\\n    }\\n\\n    /** @dev prepare the triangles and colors for rasterization\\n     */\\n    function prepareGeometryForRender(\\n        ShackledStructs.RenderParams memory renderParams,\\n        int256 canvasDim\\n    ) internal view returns (int256[12][3][] memory) {\\n        /// convert geometry and colors from PLY standard into Shackled format\\n        /// create the final triangles and colors that will be rendered\\n        /// by pulling the numbers out of the faces array\\n        /// and using them to index into the verts and colors arrays\\n        /// make copies of each coordinate and color\\n        int256[3][3][] memory tris = new int256[3][3][](\\n            renderParams.faces.length\\n        );\\n        int256[3][3][] memory trisCols = new int256[3][3][](\\n            renderParams.faces.length\\n        );\\n\\n        for (uint256 i = 0; i < renderParams.faces.length; i++) {\\n            for (uint256 j = 0; j < 3; j++) {\\n                for (uint256 k = 0; k < 3; k++) {\\n                    /// copy the values from verts and cols arrays\\n                    /// using the faces lookup array to index into them\\n                    tris[i][j][k] = renderParams.verts[\\n                        renderParams.faces[i][j]\\n                    ][k];\\n                    trisCols[i][j][k] = renderParams.cols[\\n                        renderParams.faces[i][j]\\n                    ][k];\\n                }\\n            }\\n        }\\n\\n        /// convert the fragments from model to world space\\n        int256[3][] memory vertsWorldSpace = ShackledCoords\\n            .convertToWorldSpaceWithModelTransform(\\n                tris,\\n                renderParams.objScale,\\n                renderParams.objPosition\\n            );\\n\\n        /// convert the vertices back to triangles in world space\\n        int256[3][3][] memory trisWorldSpace = ShackledUtils\\n            .unflattenVertsToTris(vertsWorldSpace);\\n\\n        /// implement backface culling\\n        if (renderParams.backfaceCulling) {\\n            (trisWorldSpace, trisCols) = ShackledCoords.backfaceCulling(\\n                trisWorldSpace,\\n                trisCols\\n            );\\n        }\\n\\n        /// update vertsWorldSpace\\n        vertsWorldSpace = ShackledUtils.flattenTris(trisWorldSpace);\\n\\n        /// convert the fragments from world to camera space\\n        int256[3][] memory vertsCameraSpace = ShackledCoords\\n            .convertToCameraSpaceViaVertexShader(\\n                vertsWorldSpace,\\n                canvasDim,\\n                renderParams.perspCamera\\n            );\\n\\n        /// convert the vertices back to triangles in camera space\\n        int256[3][3][] memory trisCameraSpace = ShackledUtils\\n            .unflattenVertsToTris(vertsCameraSpace);\\n\\n        int256[12][3][] memory trisFragments = ShackledRasteriser\\n            .initialiseFragments(\\n                trisCameraSpace,\\n                trisWorldSpace,\\n                trisCols,\\n                canvasDim\\n            );\\n\\n        return trisFragments;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledCoords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledMath.sol\\\";\\n\\nlibrary ShackledCoords {\\n    /** @dev scale and translate the verts\\n    this can be effectively disabled with a scale of 1 and translate of [0, 0, 0]\\n     */\\n    function convertToWorldSpaceWithModelTransform(\\n        int256[3][3][] memory tris,\\n        int256 scale,\\n        int256[3] memory position\\n    ) external view returns (int256[3][] memory) {\\n        int256[3][] memory verts = ShackledUtils.flattenTris(tris);\\n\\n        // Scale model matrices are easy, just multiply through by the scale value\\n        int256[3][] memory scaledVerts = new int256[3][](verts.length);\\n\\n        for (uint256 i = 0; i < verts.length; i++) {\\n            scaledVerts[i][0] = verts[i][0] * scale + position[0];\\n            scaledVerts[i][1] = verts[i][1] * scale + position[1];\\n            scaledVerts[i][2] = verts[i][2] * scale + position[2];\\n        }\\n        return scaledVerts;\\n    }\\n\\n    /** @dev run backfaceCulling to save future operations on faces that aren't seen by the camera*/\\n    function backfaceCulling(\\n        int256[3][3][] memory trisWorldSpace,\\n        int256[3][3][] memory trisCols\\n    )\\n        external\\n        view\\n        returns (\\n            int256[3][3][] memory culledTrisWorldSpace,\\n            int256[3][3][] memory culledTrisCols\\n        )\\n    {\\n        culledTrisWorldSpace = new int256[3][3][](trisWorldSpace.length);\\n        culledTrisCols = new int256[3][3][](trisCols.length);\\n\\n        uint256 nextIx;\\n\\n        for (uint256 i = 0; i < trisWorldSpace.length; i++) {\\n            int256[3] memory v1 = trisWorldSpace[i][0];\\n            int256[3] memory v2 = trisWorldSpace[i][1];\\n            int256[3] memory v3 = trisWorldSpace[i][2];\\n            int256[3] memory norm = ShackledMath.crossProduct(\\n                ShackledMath.vector3Sub(v1, v2),\\n                ShackledMath.vector3Sub(v2, v3)\\n            );\\n            /// since shackled has a static positioned camera at the origin,\\n            /// the points are already in view space, relaxing the backfaceCullingCond\\n            int256 backfaceCullingCond = ShackledMath.vector3Dot(v1, norm);\\n            if (backfaceCullingCond < 0) {\\n                culledTrisWorldSpace[nextIx] = trisWorldSpace[i];\\n                culledTrisCols[nextIx] = trisCols[i];\\n                nextIx++;\\n            }\\n        }\\n        /// remove any empty slots\\n        uint256 nToCull = culledTrisWorldSpace.length - nextIx;\\n        /// cull uneeded tris\\n        assembly {\\n            mstore(\\n                culledTrisWorldSpace,\\n                sub(mload(culledTrisWorldSpace), nToCull)\\n            )\\n        }\\n        /// cull uneeded cols\\n        assembly {\\n            mstore(culledTrisCols, sub(mload(culledTrisCols), nToCull))\\n        }\\n    }\\n\\n    /**@dev calculate verts in camera space */\\n    function convertToCameraSpaceViaVertexShader(\\n        int256[3][] memory vertsWorldSpace,\\n        int256 canvasDim,\\n        bool perspCamera\\n    ) external view returns (int256[3][] memory) {\\n        // get the camera matrix as a numerator and denominator\\n        int256[4][4][2] memory cameraMatrix;\\n        if (perspCamera) {\\n            cameraMatrix = getCameraMatrixPersp();\\n        } else {\\n            cameraMatrix = getCameraMatrixOrth(canvasDim);\\n        }\\n\\n        int256[4][4] memory nM = cameraMatrix[0]; // camera matrix numerator\\n        int256[4][4] memory dM = cameraMatrix[1]; // camera matrix denominator\\n\\n        int256[3][] memory verticesCameraSpace = new int256[3][](\\n            vertsWorldSpace.length\\n        );\\n\\n        for (uint256 i = 0; i < vertsWorldSpace.length; i++) {\\n            // Convert from 3D to 4D homogenous coordinate system\\n            int256[3] memory vert = vertsWorldSpace[i];\\n\\n            // Make a copy of vert (\\\"homoVertex\\\")\\n            int256[] memory hv = new int256[](vert.length + 1);\\n\\n            for (uint256 j = 0; j < vert.length; j++) {\\n                hv[j] = vert[j];\\n            }\\n\\n            // Insert 1 at final position in copy of vert\\n            hv[hv.length - 1] = 1;\\n\\n            int256 x = ((hv[0] * nM[0][0]) / dM[0][0]) +\\n                ((hv[1] * nM[0][1]) / dM[0][1]) +\\n                ((hv[2] * nM[0][2]) / dM[0][2]) +\\n                (nM[0][3] / dM[0][3]);\\n\\n            int256 y = ((hv[0] * nM[1][0]) / dM[1][0]) +\\n                ((hv[1] * nM[1][1]) / dM[1][1]) +\\n                ((hv[2] * nM[1][2]) / dM[1][2]) +\\n                (nM[1][3] / dM[1][0]);\\n\\n            int256 z = ((hv[0] * nM[2][0]) / dM[2][0]) +\\n                ((hv[1] * nM[2][1]) / dM[2][1]) +\\n                ((hv[2] * nM[2][2]) / dM[2][2]) +\\n                (nM[2][3] / dM[2][3]);\\n\\n            int256 w = ((hv[0] * nM[3][0]) / dM[3][0]) +\\n                ((hv[1] * nM[3][1]) / dM[3][1]) +\\n                ((hv[2] * nM[3][2]) / dM[3][2]) +\\n                (nM[3][3] / dM[3][3]);\\n\\n            if (w != 1) {\\n                x = (x * 1e3) / w;\\n                y = (y * 1e3) / w;\\n                z = (z * 1e3) / w;\\n            }\\n\\n            // Turn it back into a 3-vector\\n            // Add it to the ordered list\\n            verticesCameraSpace[i] = [x, y, z];\\n        }\\n\\n        return verticesCameraSpace;\\n    }\\n\\n    /** @dev generate an orthographic camera matrix */\\n    function getCameraMatrixOrth(int256 canvasDim)\\n        internal\\n        pure\\n        returns (int256[4][4][2] memory)\\n    {\\n        int256 canvasHalf = canvasDim / 2;\\n\\n        // Left, right, top, bottom\\n        int256 r = ShackledMath.abs(canvasHalf);\\n        int256 l = -canvasHalf;\\n        int256 t = ShackledMath.abs(canvasHalf);\\n        int256 b = -canvasHalf;\\n\\n        // Z settings (near and far)\\n        /// multiplied by 1e3\\n        int256 n = 1;\\n        int256 f = 1024;\\n\\n        // Get the orthographic transform matrix\\n        // as a numerator and denominator\\n\\n        int256[4][4] memory cameraMatrixNum = [\\n            [int256(2), 0, 0, -(r + l)],\\n            [int256(0), 2, 0, -(t + b)],\\n            [int256(0), 0, -2, -(f + n)],\\n            [int256(0), 0, 0, 1]\\n        ];\\n\\n        int256[4][4] memory cameraMatrixDen = [\\n            [int256(r - l), 1, 1, (r - l)],\\n            [int256(1), (t - b), 1, (t - b)],\\n            [int256(1), 1, (f - n), (f - n)],\\n            [int256(1), 1, 1, 1]\\n        ];\\n\\n        int256[4][4][2] memory cameraMatrix = [\\n            cameraMatrixNum,\\n            cameraMatrixDen\\n        ];\\n\\n        return cameraMatrix;\\n    }\\n\\n    /** @dev generate a perspective camera matrix */\\n    function getCameraMatrixPersp()\\n        internal\\n        pure\\n        returns (int256[4][4][2] memory)\\n    {\\n        // Z settings (near and far)\\n        /// multiplied by 1e3\\n        int256 n = 500;\\n        int256 f = 501;\\n\\n        // Get the perspective transform matrix\\n        // as a numerator and denominator\\n\\n        // parameter = 1 / tan(fov in degrees / 2)\\n        // 0.1763 = 1 / tan(160 / 2)\\n        // 1.428 = 1 / tan(70 / 2)\\n        // 1.732 = 1 / tan(60 / 2)\\n        // 2.145 = 1 / tan(50 / 2)\\n\\n        int256[4][4] memory cameraMatrixNum = [\\n            [int256(2145), 0, 0, 0],\\n            [int256(0), 2145, 0, 0],\\n            [int256(0), 0, f, -f * n],\\n            [int256(0), 0, 1, 0]\\n        ];\\n\\n        int256[4][4] memory cameraMatrixDen = [\\n            [int256(1000), 1, 1, 1],\\n            [int256(1), 1000, 1, 1],\\n            [int256(1), 1, f - n, f - n],\\n            [int256(1), 1, 1, 1]\\n        ];\\n\\n        int256[4][4][2] memory cameraMatrix = [\\n            cameraMatrixNum,\\n            cameraMatrixDen\\n        ];\\n\\n        return cameraMatrix;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledRasteriser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledUtils.sol\\\";\\nimport \\\"./ShackledMath.sol\\\";\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledRasteriser {\\n    /// define some constant lighting parameters\\n    int256 constant fidelity = int256(100); /// an extra paramater to improve numeric resolution\\n    int256 constant lightAmbiPower = int256(1); // Base light colour // was 0.5\\n    int256 constant lightDiffPower = int256(3e9); // Diffused light on surface relative strength\\n    int256 constant lightSpecPower = int256(1e7); // Specular reflection on surface relative strength\\n    uint256 constant inverseShininess = 10; // 'sharpness' of specular light on surface\\n\\n    /// define a scale factor to use in lerp to avoid rounding errors\\n    int256 constant lerpScaleFactor = 1e3;\\n\\n    /// storing variables used in the fragment lighting\\n    struct LightingVars {\\n        int256[3] fragCol;\\n        int256[3] fragNorm;\\n        int256[3] fragPos;\\n        int256[3] V;\\n        int256 vMag;\\n        int256[3] N;\\n        int256 nMag;\\n        int256[3] L;\\n        int256 lMag;\\n        int256 falloff;\\n        int256 lnDot;\\n        int256 lambertian;\\n    }\\n\\n    /// store variables used in Bresenham's line algorithm\\n    struct BresenhamsVars {\\n        int256 x;\\n        int256 y;\\n        int256 dx;\\n        int256 dy;\\n        int256 sx;\\n        int256 sy;\\n        int256 err;\\n        int256 e2;\\n    }\\n\\n    /// store variables used when running the scanline algorithm\\n    struct ScanlineVars {\\n        int256 left;\\n        int256 right;\\n        int256[12] leftFrag;\\n        int256[12] rightFrag;\\n        int256 dx;\\n        int256 ir;\\n        int256 newFragRow;\\n        int256 newFragCol;\\n    }\\n\\n    /** @dev initialise the fragments\\n        fragments are defined as:\\n        [\\n            canvas_x, canvas_y, depth,\\n            col_x, col_y, col_z,\\n            normal_x, normal_y, normal_z,\\n            world_x, world_y, world_z\\n        ]\\n        \\n     */\\n    function initialiseFragments(\\n        int256[3][3][] memory trisCameraSpace,\\n        int256[3][3][] memory trisWorldSpace,\\n        int256[3][3][] memory trisCols,\\n        int256 canvasDim\\n    ) external view returns (int256[12][3][] memory) {\\n        /// make an array containing the fragments of each triangle (groups of 3 frags)\\n        int256[12][3][] memory trisFragments = new int256[12][3][](\\n            trisCameraSpace.length\\n        );\\n\\n        // First convert from camera space to screen space within each triangle\\n        for (uint256 t = 0; t < trisCameraSpace.length; t++) {\\n            int256[3][3] memory tri = trisCameraSpace[t];\\n\\n            /// initialise an array for three fragments, each of len 9\\n            int256[12][3] memory triFragments;\\n\\n            // First calculate the fragments that belong to defined vertices\\n            for (uint256 v = 0; v < 3; v++) {\\n                int256[12] memory fragment;\\n\\n                // first convert to screen space\\n                // mapping from -1e3 -> 1e3 to account for the original geom being on order of 1e3\\n                fragment[0] = ShackledMath.mapRangeToRange(\\n                    tri[v][0],\\n                    -1e3,\\n                    1e3,\\n                    0,\\n                    canvasDim\\n                );\\n                fragment[1] = ShackledMath.mapRangeToRange(\\n                    tri[v][1],\\n                    -1e3,\\n                    1e3,\\n                    0,\\n                    canvasDim\\n                );\\n\\n                fragment[2] = tri[v][2];\\n\\n                // Now calculate the normal using the cross product of the edge vectors. This needs to be\\n                // done in world space coordinates\\n                int256[3] memory thisV = trisWorldSpace[t][(v + 0) % 3];\\n                int256[3] memory nextV = trisWorldSpace[t][(v + 1) % 3];\\n                int256[3] memory prevV = trisWorldSpace[t][(v + 2) % 3];\\n\\n                int256[3] memory norm = ShackledMath.crossProduct(\\n                    ShackledMath.vector3Sub(prevV, thisV),\\n                    ShackledMath.vector3Sub(thisV, nextV)\\n                );\\n\\n                // Now attach the colour (in 0 -> 255 space)\\n                fragment[3] = (trisCols[t][v][0]);\\n                fragment[4] = (trisCols[t][v][1]);\\n                fragment[5] = (trisCols[t][v][2]);\\n\\n                // And the normal (inverted)\\n                fragment[6] = -norm[0];\\n                fragment[7] = -norm[1];\\n                fragment[8] = -norm[2];\\n\\n                // And the world position of this vertex to the frag\\n                fragment[9] = thisV[0];\\n                fragment[10] = thisV[1];\\n                fragment[11] = thisV[2];\\n\\n                // These are just the fragments attached to\\n                // the given vertices\\n                triFragments[v] = fragment;\\n            }\\n\\n            trisFragments[t] = triFragments;\\n        }\\n\\n        return trisFragments;\\n    }\\n\\n    /** @dev rasterize fragments onto a canvas\\n     */\\n    function rasterise(\\n        int256[12][3][] memory trisFragments,\\n        int256 canvasDim,\\n        bool wireframe\\n    ) external view returns (int256[12][] memory) {\\n        /// determine the upper limits of the inner Bresenham's result\\n        uint256 canvasHypot = uint256(ShackledMath.hypot(canvasDim, canvasDim));\\n\\n        /// initialise a new array\\n        /// for each trisFragments we will get 3 results from bresenhams\\n        /// maximum of 1 per pixel (canvasDim**2)\\n        int256[12][] memory fragments = new int256[12][](\\n            3 * uint256(canvasDim)**2\\n        );\\n        uint256 nextFragmentsIx = 0;\\n\\n        for (uint256 t = 0; t < trisFragments.length; t++) {\\n            // prepare the variables required\\n            int256[12] memory fa;\\n            int256[12] memory fb;\\n            uint256 nextBresTriFragmentIx = 0;\\n\\n            /// create an array to hold the bresenham results\\n            /// this may cause an out of bounds error if there are a very large number of fragments\\n            /// (e.g. many that are 'off screen')\\n            int256[12][] memory bresTriFragments = new int256[12][](\\n                canvasHypot * 10\\n            );\\n\\n            // for each pair of fragments, run bresenhams and extend bresTriFragments with the output\\n            // this replaces the three push(...modified_bresenhams_algorhtm) statements in JS\\n            for (uint256 i = 0; i < 3; i++) {\\n                if (i == 0) {\\n                    fa = trisFragments[t][0];\\n                    fb = trisFragments[t][1];\\n                } else if (i == 1) {\\n                    fa = trisFragments[t][1];\\n                    fb = trisFragments[t][2];\\n                } else {\\n                    fa = trisFragments[t][2];\\n                    fb = trisFragments[t][0];\\n                }\\n\\n                // run the bresenhams algorithm\\n                (\\n                    bresTriFragments,\\n                    nextBresTriFragmentIx\\n                ) = runBresenhamsAlgorithm(\\n                    fa,\\n                    fb,\\n                    canvasDim,\\n                    bresTriFragments,\\n                    nextBresTriFragmentIx\\n                );\\n            }\\n\\n            bresTriFragments = ShackledUtils.clipArray12ToLength(\\n                bresTriFragments,\\n                nextBresTriFragmentIx\\n            );\\n\\n            if (wireframe) {\\n                /// only store the edges\\n                for (uint256 j = 0; j < bresTriFragments.length; j++) {\\n                    fragments[nextFragmentsIx] = bresTriFragments[j];\\n                    nextFragmentsIx++;\\n                }\\n            } else {\\n                /// fill the triangle\\n                (fragments, nextFragmentsIx) = runScanline(\\n                    bresTriFragments,\\n                    fragments,\\n                    nextFragmentsIx,\\n                    canvasDim\\n                );\\n            }\\n        }\\n\\n        fragments = ShackledUtils.clipArray12ToLength(\\n            fragments,\\n            nextFragmentsIx\\n        );\\n\\n        return fragments;\\n    }\\n\\n    /** @dev run Bresenham's line algorithm on a pair of fragments\\n     */\\n    function runBresenhamsAlgorithm(\\n        int256[12] memory f1,\\n        int256[12] memory f2,\\n        int256 canvasDim,\\n        int256[12][] memory bresTriFragments,\\n        uint256 nextBresTriFragmentIx\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        /// initiate a new set of vars\\n        BresenhamsVars memory vars;\\n\\n        int256[12] memory fa;\\n        int256[12] memory fb;\\n\\n        /// determine which fragment has a greater magnitude\\n        /// and set it as the destination (always order a given pair of edges the same)\\n        if (\\n            (f1[0]**2 + f1[1]**2 + f1[2]**2) < (f2[0]**2 + f2[1]**2 + f2[2]**2)\\n        ) {\\n            fa = f1;\\n            fb = f2;\\n        } else {\\n            fa = f2;\\n            fb = f1;\\n        }\\n\\n        vars.x = fa[0];\\n        vars.y = fa[1];\\n\\n        vars.dx = ShackledMath.abs(fb[0] - fa[0]);\\n        vars.dy = -ShackledMath.abs(fb[1] - fa[1]);\\n        int256 mag = ShackledMath.hypot(vars.dx, -vars.dy);\\n\\n        if (fa[0] < fb[0]) {\\n            vars.sx = 1;\\n        } else {\\n            vars.sx = -1;\\n        }\\n\\n        if (fa[1] < fb[1]) {\\n            vars.sy = 1;\\n        } else {\\n            vars.sy = -1;\\n        }\\n\\n        vars.err = vars.dx + vars.dy;\\n        vars.e2 = 0;\\n\\n        // get the bresenhams output for this fragment pair (fa & fb)\\n\\n        if (mag == 0) {\\n            bresTriFragments[nextBresTriFragmentIx] = fa;\\n            bresTriFragments[nextBresTriFragmentIx + 1] = fb;\\n            nextBresTriFragmentIx += 2;\\n        } else {\\n            // when mag is not 0,\\n            // the length of the result will be max of upperLimitInner\\n            // but will be clipped to remove any empty slots\\n            (bresTriFragments, nextBresTriFragmentIx) = bresenhamsInner(\\n                vars,\\n                mag,\\n                fa,\\n                fb,\\n                canvasDim,\\n                bresTriFragments,\\n                nextBresTriFragmentIx\\n            );\\n        }\\n        return (bresTriFragments, nextBresTriFragmentIx);\\n    }\\n\\n    /** @dev run the inner loop of Bresenham's line algorithm on a pair of fragments\\n     * (preventing stack too deep)\\n     */\\n    function bresenhamsInner(\\n        BresenhamsVars memory vars,\\n        int256 mag,\\n        int256[12] memory fa,\\n        int256[12] memory fb,\\n        int256 canvasDim,\\n        int256[12][] memory bresTriFragments,\\n        uint256 nextBresTriFragmentIx\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        // define variables to be used in the inner loop\\n        int256 ir;\\n        int256 h;\\n\\n        /// loop through all fragments\\n        while (!(vars.x == fb[0] && vars.y == fb[1])) {\\n            /// get hypotenuse length of fragment a\\n            h = ShackledMath.hypot(fa[0] - vars.x, fa[1] - vars.y);\\n            assembly {\\n                ir := div(mul(lerpScaleFactor, h), mag)\\n            }\\n\\n            // only add the fragment if it falls within the canvas\\n\\n            /// create a new fragment by linear interpolation between a and b\\n            int256[12] memory newFragment = ShackledMath.vector12Lerp(\\n                fa,\\n                fb,\\n                ir,\\n                lerpScaleFactor\\n            );\\n            newFragment[0] = vars.x;\\n            newFragment[1] = vars.y;\\n\\n            /// save this fragment\\n            bresTriFragments[nextBresTriFragmentIx] = newFragment;\\n            ++nextBresTriFragmentIx;\\n\\n            /// update variables to use in next iteration\\n            vars.e2 = 2 * vars.err;\\n            if (vars.e2 >= vars.dy) {\\n                vars.err += vars.dy;\\n                vars.x += vars.sx;\\n            }\\n            if (vars.e2 <= vars.dx) {\\n                vars.err += vars.dx;\\n                vars.y += vars.sy;\\n            }\\n        }\\n\\n        /// save fragment 2\\n        bresTriFragments[nextBresTriFragmentIx] = fb;\\n        ++nextBresTriFragmentIx;\\n\\n        return (bresTriFragments, nextBresTriFragmentIx);\\n    }\\n\\n    /** @dev run the scan line algorithm to fill the raster\\n     */\\n    function runScanline(\\n        int256[12][] memory bresTriFragments,\\n        int256[12][] memory fragments,\\n        uint256 nextFragmentsIx,\\n        int256 canvasDim\\n    ) internal view returns (int256[12][] memory, uint256) {\\n        /// make a 2d array with length = num of output rows\\n\\n        (\\n            int256[][] memory rowFragIndices,\\n            uint256[] memory nextIxFragRows\\n        ) = getRowFragIndices(bresTriFragments, canvasDim);\\n\\n        /// initialise a struct to hold the scanline vars\\n        ScanlineVars memory slVars;\\n\\n        // Now iterate through the list of fragments that live in a single row\\n        for (uint256 i = 0; i < rowFragIndices.length; i++) {\\n            /// Get the left most fragment\\n            slVars.left = 4096;\\n\\n            /// Get the right most fragment\\n            slVars.right = -4096;\\n\\n            /// loop through the fragments in this row\\n            /// and check that a fragment was written to this row\\n            for (uint256 j = 0; j < nextIxFragRows[i]; j++) {\\n                /// What's the current fragment that we're looking at\\n                int256 fragX = bresTriFragments[uint256(rowFragIndices[i][j])][\\n                    0\\n                ];\\n\\n                // if it's lefter than our current most left frag then its the new left frag\\n                if (fragX < slVars.left) {\\n                    slVars.left = fragX;\\n                    slVars.leftFrag = bresTriFragments[\\n                        uint256(rowFragIndices[i][j])\\n                    ];\\n                }\\n                // if it's righter than our current most right frag then its the new right frag\\n                if (fragX > slVars.right) {\\n                    slVars.right = fragX;\\n                    slVars.rightFrag = bresTriFragments[\\n                        uint256(rowFragIndices[i][j])\\n                    ];\\n                }\\n            }\\n\\n            /// now we need to scan from the left to the right fragment\\n            /// and interpolate as we go\\n            slVars.dx = slVars.right - slVars.left + 1;\\n\\n            /// get the row that we're on\\n            slVars.newFragRow = slVars.leftFrag[1];\\n\\n            /// check that the new frag's row will be in the canvas bounds\\n            if (slVars.newFragRow >= 0 && slVars.newFragRow < canvasDim) {\\n                if (slVars.dx > int256(0)) {\\n                    for (int256 j = 0; j < slVars.dx; j++) {\\n                        /// calculate the column of the new fragment (its position in the scan)\\n                        slVars.newFragCol = slVars.leftFrag[0] + j;\\n\\n                        /// check that the new frag's column will be in the canvas bounds\\n                        if (\\n                            slVars.newFragCol >= 0 &&\\n                            slVars.newFragCol < canvasDim\\n                        ) {\\n                            slVars.ir = (j * lerpScaleFactor) / slVars.dx;\\n\\n                            /// make a new fragment by linear interpolation between left and right frags\\n                            fragments[nextFragmentsIx] = ShackledMath\\n                                .vector12Lerp(\\n                                    slVars.leftFrag,\\n                                    slVars.rightFrag,\\n                                    slVars.ir,\\n                                    lerpScaleFactor\\n                                );\\n                            /// update its position\\n                            fragments[nextFragmentsIx][0] = slVars.newFragCol;\\n                            fragments[nextFragmentsIx][1] = slVars.newFragRow;\\n                            nextFragmentsIx++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return (fragments, nextFragmentsIx);\\n    }\\n\\n    /** @dev get the row indices of each fragment in preparation for the scanline alg\\n     */\\n    function getRowFragIndices(\\n        int256[12][] memory bresTriFragments,\\n        int256 canvasDim\\n    )\\n        internal\\n        view\\n        returns (int256[][] memory, uint256[] memory nextIxFragRows)\\n    {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n\\n        // define the length of each outer array so we can push items into it using nextIxFragRows\\n        int256[][] memory rowFragIndices = new int256[][](canvasDimUnsigned);\\n\\n        // the inner rows can't be longer than bresTriFragments\\n        for (uint256 i = 0; i < canvasDimUnsigned; i++) {\\n            rowFragIndices[i] = new int256[](bresTriFragments.length);\\n        }\\n\\n        // make an array the tracks for each row how many items have been pushed into it\\n        uint256[] memory nextIxFragRows = new uint256[](canvasDimUnsigned);\\n\\n        for (uint256 f = 0; f < bresTriFragments.length; f++) {\\n            // get the row index\\n            uint256 rowIx = uint256(bresTriFragments[f][1]); // canvas_y\\n\\n            if (rowIx >= 0 && rowIx < canvasDimUnsigned) {\\n                // get the ix of the next item to be added to the row\\n\\n                rowFragIndices[rowIx][nextIxFragRows[rowIx]] = int256(f);\\n                ++nextIxFragRows[rowIx];\\n            }\\n        }\\n        return (rowFragIndices, nextIxFragRows);\\n    }\\n\\n    /** @dev run depth-testing on all fragments\\n     */\\n    function depthTesting(int256[12][] memory fragments, int256 canvasDim)\\n        external\\n        view\\n        returns (int256[12][] memory)\\n    {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        /// create a 2d array to hold the zValues of the fragments\\n        int256[][] memory zValues = ShackledMath.get2dArray(\\n            canvasDimUnsigned,\\n            canvasDimUnsigned,\\n            0\\n        );\\n\\n        /// create a 2d array to hold the fragIndex of the fragments\\n        /// as their depth is compared\\n        int256[][] memory fragIndex = ShackledMath.get2dArray(\\n            canvasDimUnsigned,\\n            canvasDimUnsigned,\\n            -1 /// -1 so we can check if a fragment was written to this location\\n        );\\n\\n        int256[12][] memory culledFrags = new int256[12][](fragments.length);\\n        uint256 nextFragIx = 0;\\n\\n        /// iterate through all fragments\\n        /// and store the index of the fragment with the largest z value\\n        /// at each x, y coordinate\\n\\n        for (uint256 i = 0; i < fragments.length; i++) {\\n            int256[12] memory frag = fragments[i];\\n\\n            /// x and y must be uint for indexing\\n            uint256 fragX = uint256(frag[0]);\\n            uint256 fragY = uint256(frag[1]);\\n\\n            // console.log(\\\"checking frag\\\", i, \\\"z:\\\");\\n            // console.logInt(frag[2]);\\n\\n            if (\\n                (fragX < canvasDimUnsigned) &&\\n                (fragY < canvasDimUnsigned) &&\\n                fragX >= 0 &&\\n                fragY >= 0\\n            ) {\\n                // if this is the first fragment seen at (fragX, fragY), ie if fragIndex == 0, add it\\n                // or if this frag is closer (lower z value) than the current frag at (fragX, fragY), add it\\n                if (\\n                    fragIndex[fragX][fragY] == -1 ||\\n                    frag[2] >= zValues[fragX][fragY]\\n                ) {\\n                    zValues[fragX][fragY] = frag[2];\\n                    fragIndex[fragX][fragY] = int256(i);\\n                }\\n            }\\n        }\\n\\n        /// save only the fragments with prefered z values\\n        for (uint256 x = 0; x < canvasDimUnsigned; x++) {\\n            for (uint256 y = 0; y < canvasDimUnsigned; y++) {\\n                int256 fragIx = fragIndex[x][y];\\n                /// ensure we have a valid index\\n                if (fragIndex[x][y] != -1) {\\n                    culledFrags[nextFragIx] = fragments[uint256(fragIx)];\\n                    nextFragIx++;\\n                }\\n            }\\n        }\\n\\n        return ShackledUtils.clipArray12ToLength(culledFrags, nextFragIx);\\n    }\\n\\n    /** @dev apply lighting to the scene and update fragments accordingly\\n     */\\n    function lightScene(\\n        int256[12][] memory fragments,\\n        ShackledStructs.LightingParams memory lp\\n    ) external view returns (int256[12][] memory) {\\n        /// create a struct for the variables to prevent stack too deep\\n        LightingVars memory lv;\\n\\n        // calculate a constant lighting vector and its magniture\\n        lv.L = lp.lightPos;\\n        lv.lMag = ShackledMath.vector3Len(lv.L);\\n\\n        for (uint256 f = 0; f < fragments.length; f++) {\\n            /// get the fragment's color, norm and position\\n            lv.fragCol = [fragments[f][3], fragments[f][4], fragments[f][5]];\\n            lv.fragNorm = [fragments[f][6], fragments[f][7], fragments[f][8]];\\n            lv.fragPos = [fragments[f][9], fragments[f][10], fragments[f][11]];\\n\\n            /// calculate the direction to camera / viewer and its magnitude\\n            lv.V = ShackledMath.vector3MulScalar(lv.fragPos, -1);\\n            lv.vMag = ShackledMath.vector3Len(lv.V);\\n\\n            /// calculate the direction of the fragment normaland its magnitude\\n            lv.N = lv.fragNorm;\\n            lv.nMag = ShackledMath.vector3Len(lv.N);\\n\\n            /// calculate the light vector per-fragment\\n            // lv.L = ShackledMath.vector3Sub(lp.lightPos, lv.fragPos);\\n            // lv.lMag = ShackledMath.vector3Len(lv.L);\\n            lv.falloff = lv.lMag**2; /// lighting intensity fall over the scene\\n            lv.lnDot = ShackledMath.vector3Dot(lv.L, lv.N);\\n\\n            /// implement double-side rendering to account for flipped normals\\n            lv.lambertian = ShackledMath.abs(lv.lnDot);\\n\\n            int256 specular;\\n\\n            if (lv.lambertian > 0) {\\n                int256[3] memory normedL = ShackledMath.vector3NormX(\\n                    lv.L,\\n                    fidelity\\n                );\\n                int256[3] memory normedV = ShackledMath.vector3NormX(\\n                    lv.V,\\n                    fidelity\\n                );\\n\\n                int256[3] memory H = ShackledMath.vector3Add(normedL, normedV);\\n\\n                int256 hnDot = int256(\\n                    ShackledMath.vector3Dot(\\n                        ShackledMath.vector3NormX(H, fidelity),\\n                        ShackledMath.vector3NormX(lv.N, fidelity)\\n                    )\\n                );\\n\\n                specular = calculateSpecular(\\n                    lp.lightSpecPower,\\n                    hnDot,\\n                    fidelity,\\n                    lp.inverseShininess\\n                );\\n            }\\n\\n            // Calculate the colour and write it into the fragment\\n            int256[3] memory colAmbi = ShackledMath.vector3Add(\\n                lv.fragCol,\\n                ShackledMath.vector3MulScalar(\\n                    lp.lightColAmbi,\\n                    lp.lightAmbiPower\\n                )\\n            );\\n\\n            /// finalise and color the diffuse lighting\\n            int256[3] memory colDiff = ShackledMath.vector3MulScalar(\\n                lp.lightColDiff,\\n                ((lp.lightDiffPower * lv.lambertian) / (lv.lMag * lv.nMag)) /\\n                    lv.falloff\\n            );\\n\\n            /// finalise and color the specular lighting\\n            int256[3] memory colSpec = ShackledMath.vector3DivScalar(\\n                ShackledMath.vector3MulScalar(lp.lightColSpec, specular),\\n                lv.falloff\\n            );\\n\\n            // add up the colour components\\n            int256[3] memory col = ShackledMath.vector3Add(\\n                ShackledMath.vector3Add(colAmbi, colDiff),\\n                colSpec\\n            );\\n\\n            /// update the fragment's colour in place\\n            fragments[f][3] = col[0];\\n            fragments[f][4] = col[1];\\n            fragments[f][5] = col[2];\\n        }\\n        return fragments;\\n    }\\n\\n    /** @dev calculate the specular lighting parameter */\\n    function calculateSpecular(\\n        int256 lightSpecPower,\\n        int256 hnDot,\\n        int256 fidelity,\\n        uint256 inverseShininess\\n    ) internal pure returns (int256 specular) {\\n        int256 specAngle = hnDot > int256(0) ? hnDot : int256(0);\\n        assembly {\\n            specular := sdiv(\\n                mul(lightSpecPower, exp(specAngle, inverseShininess)),\\n                exp(fidelity, mul(inverseShininess, 2))\\n            )\\n        }\\n    }\\n\\n    /** @dev get background gradient that fills the canvas */\\n    function getBackground(\\n        int256 canvasDim,\\n        int256[3][2] memory backgroundColor\\n    ) external view returns (int256[5][] memory) {\\n        int256[5][] memory background = new int256[5][](uint256(canvasDim**2));\\n\\n        int256 w = canvasDim;\\n        uint256 nextIx = 0;\\n\\n        for (int256 i = 0; i < canvasDim; i++) {\\n            for (int256 j = 0; j < canvasDim; j++) {\\n                // / write coordinates of background pixel\\n                background[nextIx][0] = j; /// x\\n                background[nextIx][1] = i; /// y\\n\\n                // / write colours of background pixel\\n                // / get weighted average of top and bottom color according to row (i)\\n                background[nextIx][2] = /// r\\n                    ((backgroundColor[0][0] * i) +\\n                        (backgroundColor[1][0] * (w - i))) /\\n                    w;\\n\\n                background[nextIx][3] = /// g\\n                    ((backgroundColor[0][1] * i) +\\n                        (backgroundColor[1][1] * (w - i))) /\\n                    w;\\n\\n                background[nextIx][4] = /// b\\n                    ((backgroundColor[0][2] * i) +\\n                        (backgroundColor[1][2] * (w - i))) /\\n                    w;\\n\\n                ++nextIx;\\n            }\\n        }\\n        return background;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ShackledStructs.sol\\\";\\n\\nlibrary ShackledUtils {\\n    string internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /** @dev Flatten 3d tris array into 2d verts */\\n    function flattenTris(int256[3][3][] memory tris)\\n        internal\\n        pure\\n        returns (int256[3][] memory)\\n    {\\n        /// initialize a dynamic in-memory array\\n        int256[3][] memory flattened = new int256[3][](3 * tris.length);\\n\\n        for (uint256 i = 0; i < tris.length; i++) {\\n            /// tris.length == N\\n            // add values to specific index, as cannot push to array in memory\\n            flattened[(i * 3) + 0] = tris[i][0];\\n            flattened[(i * 3) + 1] = tris[i][1];\\n            flattened[(i * 3) + 2] = tris[i][2];\\n        }\\n        return flattened;\\n    }\\n\\n    /** @dev Unflatten 2d verts array into 3d tries (inverse of flattenTris function) */\\n    function unflattenVertsToTris(int256[3][] memory verts)\\n        internal\\n        pure\\n        returns (int256[3][3][] memory)\\n    {\\n        /// initialize an array with length = 1/3 length of verts\\n        int256[3][3][] memory tris = new int256[3][3][](verts.length / 3);\\n\\n        for (uint256 i = 0; i < verts.length; i += 3) {\\n            tris[i / 3] = [verts[i], verts[i + 1], verts[i + 2]];\\n        }\\n        return tris;\\n    }\\n\\n    /** @dev clip an array to a certain length (to trim empty tail slots) */\\n    function clipArray12ToLength(int256[12][] memory arr, uint256 desiredLen)\\n        internal\\n        pure\\n        returns (int256[12][] memory)\\n    {\\n        uint256 nToCull = arr.length - desiredLen;\\n        assembly {\\n            mstore(arr, sub(mload(arr), nToCull))\\n        }\\n        return arr;\\n    }\\n\\n    /** @dev convert an unsigned int to a string */\\n    function uint2str(uint256 _i)\\n        internal\\n        pure\\n        returns (string memory _uintAsString)\\n    {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = _i;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (_i != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(_i - (_i / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /** @dev get the hex encoding of various powers of 2 (canvas size options) */\\n    function getHex(uint256 _i) internal pure returns (bytes memory _hex) {\\n        if (_i == 8) {\\n            return hex\\\"08_00_00_00\\\";\\n        } else if (_i == 16) {\\n            return hex\\\"10_00_00_00\\\";\\n        } else if (_i == 32) {\\n            return hex\\\"20_00_00_00\\\";\\n        } else if (_i == 64) {\\n            return hex\\\"40_00_00_00\\\";\\n        } else if (_i == 128) {\\n            return hex\\\"80_00_00_00\\\";\\n        } else if (_i == 256) {\\n            return hex\\\"00_01_00_00\\\";\\n        } else if (_i == 512) {\\n            return hex\\\"00_02_00_00\\\";\\n        }\\n    }\\n\\n    /** @dev create an svg container for a bitmap (for display on svg-only platforms) */\\n    function getSVGContainer(\\n        string memory encodedBitmap,\\n        int256 canvasDim,\\n        uint256 outputHeight,\\n        uint256 outputWidth\\n    ) internal view returns (string memory) {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        // construct some elements in memory prior to return string to avoid stack too deep\\n        bytes memory imgSize = abi.encodePacked(\\n            \\\"width='\\\",\\n            ShackledUtils.uint2str(canvasDimUnsigned),\\n            \\\"' height='\\\",\\n            ShackledUtils.uint2str(canvasDimUnsigned),\\n            \\\"'\\\"\\n        );\\n        bytes memory canvasSize = abi.encodePacked(\\n            \\\"width='\\\",\\n            ShackledUtils.uint2str(outputWidth),\\n            \\\"' height='\\\",\\n            ShackledUtils.uint2str(outputHeight),\\n            \\\"'\\\"\\n        );\\n        bytes memory scaleStartTag = abi.encodePacked(\\n            \\\"<g transform='scale(\\\",\\n            ShackledUtils.uint2str(outputWidth / canvasDimUnsigned),\\n            \\\")'>\\\"\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/svg+xml;base64,\\\",\\n                    Base64.encode(\\n                        abi.encodePacked(\\n                            \\\"<svg xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' \\\",\\n                            \\\"shape-rendering='crispEdges' \\\",\\n                            canvasSize,\\n                            \\\">\\\",\\n                            scaleStartTag,\\n                            \\\"<image \\\",\\n                            imgSize,\\n                            \\\" style='image-rendering: pixelated; image-rendering: crisp-edges;' \\\",\\n                            \\\"href='\\\",\\n                            encodedBitmap,\\n                            \\\"'/></g></svg>\\\"\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    /** @dev converts raw metadata into */\\n    function getAttributes(ShackledStructs.Metadata memory metadata)\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        return\\n            abi.encodePacked(\\n                \\\"{\\\",\\n                '\\\"Structure\\\": \\\"',\\n                metadata.geomSpec,\\n                '\\\", \\\"Chroma\\\": \\\"',\\n                metadata.colorScheme,\\n                '\\\", \\\"Pseudosymmetry\\\": \\\"',\\n                metadata.pseudoSymmetry,\\n                '\\\", \\\"Wireframe\\\": \\\"',\\n                metadata.wireframe,\\n                '\\\", \\\"Inversion\\\": \\\"',\\n                metadata.inversion,\\n                '\\\", \\\"Prisms\\\": \\\"',\\n                uint2str(metadata.nPrisms),\\n                '\\\"}'\\n            );\\n    }\\n\\n    /** @dev create and encode the token's metadata */\\n    function getEncodedMetadata(\\n        string memory image,\\n        ShackledStructs.Metadata memory metadata,\\n        uint256 tokenId\\n    ) internal view returns (string memory) {\\n        /// get attributes and description here to avoid stack too deep\\n        string\\n            memory description = '\\\"description\\\": \\\"Shackled is the first general-purpose 3D renderer'\\n            \\\" running on the Ethereum blockchain.\\\"\\n            ' Each piece represents a leap forward in on-chain computer graphics, and the collection itself is an NFT first.\\\"';\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            string(\\n                                abi.encodePacked(\\n                                    '{\\\"name\\\": \\\"Shackled Genesis #',\\n                                    uint2str(tokenId),\\n                                    '\\\", ',\\n                                    description,\\n                                    ', \\\"attributes\\\":',\\n                                    getAttributes(metadata),\\n                                    ', \\\"image\\\":\\\"',\\n                                    image,\\n                                    '\\\"}'\\n                                )\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    // fragment =\\n    // [ canvas_x, canvas_y, depth, col_x, col_y, col_z, normal_x, normal_y, normal_z, world_x, world_y, world_z ],\\n    /** @dev get an encoded 2d bitmap by combining the object and background fragments */\\n    function getEncodedBitmap(\\n        int256[12][] memory fragments,\\n        int256[5][] memory background,\\n        int256 canvasDim,\\n        bool invert\\n    ) internal view returns (string memory) {\\n        uint256 canvasDimUnsigned = uint256(canvasDim);\\n        bytes memory fileHeader = abi.encodePacked(\\n            hex\\\"42_4d\\\", // BM\\n            hex\\\"36_04_00_00\\\", // size of the bitmap file in bytes (14 (file header) + 40 (info header) + size of raw data (1024))\\n            hex\\\"00_00_00_00\\\", // 2x2 bytes reserved\\n            hex\\\"36_00_00_00\\\" // offset of pixels in bytes\\n        );\\n        bytes memory infoHeader = abi.encodePacked(\\n            hex\\\"28_00_00_00\\\", // size of the header in bytes (40)\\n            getHex(canvasDimUnsigned), // width in pixels 32\\n            getHex(canvasDimUnsigned), // height in pixels 32\\n            hex\\\"01_00\\\", // number of color plans (must be 1)\\n            hex\\\"18_00\\\", // number of bits per pixel (24)\\n            hex\\\"00_00_00_00\\\", // type of compression (none)\\n            hex\\\"00_04_00_00\\\", // size of the raw bitmap data (1024)\\n            hex\\\"C4_0E_00_00\\\", // horizontal resolution\\n            hex\\\"C4_0E_00_00\\\", // vertical resolution\\n            hex\\\"00_00_00_00\\\", // number of used colours\\n            hex\\\"05_00_00_00\\\" // number of important colours\\n        );\\n        bytes memory headers = abi.encodePacked(fileHeader, infoHeader);\\n\\n        /// create a container for the bitmap's bytes\\n        bytes memory bytesArray = new bytes(3 * canvasDimUnsigned**2);\\n\\n        /// write the background first so it is behind the fragments\\n        bytesArray = writeBackgroundToBytesArray(\\n            background,\\n            bytesArray,\\n            canvasDimUnsigned,\\n            invert\\n        );\\n        bytesArray = writeFragmentsToBytesArray(\\n            fragments,\\n            bytesArray,\\n            canvasDimUnsigned,\\n            invert\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:image/bmp;base64,\\\",\\n                    Base64.encode(BytesUtils.MergeBytes(headers, bytesArray))\\n                )\\n            );\\n    }\\n\\n    /** @dev write the fragments to the bytes array */\\n    function writeFragmentsToBytesArray(\\n        int256[12][] memory fragments,\\n        bytes memory bytesArray,\\n        uint256 canvasDimUnsigned,\\n        bool invert\\n    ) internal pure returns (bytes memory) {\\n        /// loop through each fragment\\n        /// and write it's color into bytesArray in its canvas equivelant position\\n        for (uint256 i = 0; i < fragments.length; i++) {\\n            /// check if x and y are both greater than 0\\n            if (\\n                uint256(fragments[i][0]) >= 0 && uint256(fragments[i][1]) >= 0\\n            ) {\\n                /// calculating the starting bytesArray ix for this fragment's colors\\n                uint256 flatIx = ((canvasDimUnsigned -\\n                    uint256(fragments[i][1]) -\\n                    1) *\\n                    canvasDimUnsigned +\\n                    (canvasDimUnsigned - uint256(fragments[i][0]) - 1)) * 3;\\n\\n                /// red\\n                uint256 r = fragments[i][3] > 255\\n                    ? 255\\n                    : uint256(fragments[i][3]);\\n\\n                /// green\\n                uint256 g = fragments[i][4] > 255\\n                    ? 255\\n                    : uint256(fragments[i][4]);\\n\\n                /// blue\\n                uint256 b = fragments[i][5] > 255\\n                    ? 255\\n                    : uint256(fragments[i][5]);\\n\\n                if (invert) {\\n                    r = 255 - r;\\n                    g = 255 - g;\\n                    b = 255 - b;\\n                }\\n\\n                bytesArray[flatIx + 0] = bytes1(uint8(b));\\n                bytesArray[flatIx + 1] = bytes1(uint8(g));\\n                bytesArray[flatIx + 2] = bytes1(uint8(r));\\n            }\\n        }\\n        return bytesArray;\\n    }\\n\\n    /** @dev write the fragments to the bytes array \\n    using a separate function from above to account for variable input size\\n    */\\n    function writeBackgroundToBytesArray(\\n        int256[5][] memory background,\\n        bytes memory bytesArray,\\n        uint256 canvasDimUnsigned,\\n        bool invert\\n    ) internal pure returns (bytes memory) {\\n        /// loop through each fragment\\n        /// and write it's color into bytesArray in its canvas equivelant position\\n        for (uint256 i = 0; i < background.length; i++) {\\n            /// check if x and y are both greater than 0\\n            if (\\n                uint256(background[i][0]) >= 0 && uint256(background[i][1]) >= 0\\n            ) {\\n                /// calculating the starting bytesArray ix for this fragment's colors\\n                uint256 flatIx = (uint256(background[i][1]) *\\n                    canvasDimUnsigned +\\n                    uint256(background[i][0])) * 3;\\n\\n                // red\\n                uint256 r = background[i][2] > 255\\n                    ? 255\\n                    : uint256(background[i][2]);\\n\\n                /// green\\n                uint256 g = background[i][3] > 255\\n                    ? 255\\n                    : uint256(background[i][3]);\\n\\n                // blue\\n                uint256 b = background[i][4] > 255\\n                    ? 255\\n                    : uint256(background[i][4]);\\n\\n                if (invert) {\\n                    r = 255 - r;\\n                    g = 255 - g;\\n                    b = 255 - b;\\n                }\\n\\n                bytesArray[flatIx + 0] = bytes1(uint8(b));\\n                bytesArray[flatIx + 1] = bytes1(uint8(g));\\n                bytesArray[flatIx + 2] = bytes1(uint8(r));\\n            }\\n        }\\n        return bytesArray;\\n    }\\n}\\n\\n/// [MIT License]\\n/// @title Base64\\n/// @notice Provides a function for encoding some bytes in base64\\n/// @author Brecht Devos <brecht@loopring.org>\\nlibrary Base64 {\\n    bytes internal constant TABLE =\\n        \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\\\";\\n\\n    /// @notice Encodes some bytes to the base64 representation\\n    function encode(bytes memory data) internal view returns (string memory) {\\n        uint256 len = data.length;\\n        if (len == 0) return \\\"\\\";\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((len + 2) / 3);\\n\\n        // Add some extra buffer at the end\\n        bytes memory result = new bytes(encodedLen + 32);\\n\\n        bytes memory table = TABLE;\\n\\n        assembly {\\n            let tablePtr := add(table, 1)\\n            let resultPtr := add(result, 32)\\n\\n            for {\\n                let i := 0\\n            } lt(i, len) {\\n\\n            } {\\n                i := add(i, 3)\\n                let input := and(mload(add(data, i)), 0xffffff)\\n\\n                let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF)\\n                )\\n                out := shl(8, out)\\n                out := add(\\n                    out,\\n                    and(mload(add(tablePtr, and(input, 0x3F))), 0xFF)\\n                )\\n                out := shl(224, out)\\n\\n                mstore(resultPtr, out)\\n\\n                resultPtr := add(resultPtr, 4)\\n            }\\n\\n            switch mod(len, 3)\\n            case 1 {\\n                mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\\n            }\\n            case 2 {\\n                mstore(sub(resultPtr, 1), shl(248, 0x3d))\\n            }\\n\\n            mstore(result, encodedLen)\\n        }\\n\\n        return string(result);\\n    }\\n}\\n\\nlibrary BytesUtils {\\n    function char(bytes1 b) internal view returns (bytes1 c) {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    function bytes32string(bytes32 b32)\\n        internal\\n        view\\n        returns (string memory out)\\n    {\\n        bytes memory s = new bytes(64);\\n        for (uint32 i = 0; i < 32; i++) {\\n            bytes1 b = bytes1(b32[i]);\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[i * 2] = char(hi);\\n            s[i * 2 + 1] = char(lo);\\n        }\\n        out = string(s);\\n    }\\n\\n    function hach(string memory value) internal view returns (string memory) {\\n        return bytes32string(sha256(abi.encodePacked(value)));\\n    }\\n\\n    function MergeBytes(bytes memory a, bytes memory b)\\n        internal\\n        pure\\n        returns (bytes memory c)\\n    {\\n        // Store the length of the first array\\n        uint256 alen = a.length;\\n        // Store the length of BOTH arrays\\n        uint256 totallen = alen + b.length;\\n        // Count the loops required for array a (sets of 32 bytes)\\n        uint256 loopsa = (a.length + 31) / 32;\\n        // Count the loops required for array b (sets of 32 bytes)\\n        uint256 loopsb = (b.length + 31) / 32;\\n        assembly {\\n            let m := mload(0x40)\\n            // Load the length of both arrays to the head of the new bytes array\\n            mstore(m, totallen)\\n            // Add the contents of a to the array\\n            for {\\n                let i := 0\\n            } lt(i, loopsa) {\\n                i := add(1, i)\\n            } {\\n                mstore(\\n                    add(m, mul(32, add(1, i))),\\n                    mload(add(a, mul(32, add(1, i))))\\n                )\\n            }\\n            // Add the contents of b to the array\\n            for {\\n                let i := 0\\n            } lt(i, loopsb) {\\n                i := add(1, i)\\n            } {\\n                mstore(\\n                    add(m, add(mul(32, add(1, i)), alen)),\\n                    mload(add(b, mul(32, add(1, i))))\\n                )\\n            }\\n            mstore(0x40, add(m, add(32, totallen)))\\n            c := m\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ShackledStructs {\\n    struct Metadata {\\n        string colorScheme; /// name of the color scheme\\n        string geomSpec; /// name of the geometry specification\\n        uint256 nPrisms; /// number of prisms made\\n        string pseudoSymmetry; /// horizontal, vertical, diagonal\\n        string wireframe; /// enabled or disabled\\n        string inversion; /// enabled or disabled\\n    }\\n\\n    struct RenderParams {\\n        uint256[3][] faces; /// index of verts and colorss used for each face (triangle)\\n        int256[3][] verts; /// x, y, z coordinates used in the geometry\\n        int256[3][] cols; /// colors of each vert\\n        int256[3] objPosition; /// position to place the object\\n        int256 objScale; /// scalar for the object\\n        int256[3][2] backgroundColor; /// color of the background (gradient)\\n        LightingParams lightingParams; /// parameters for the lighting\\n        bool perspCamera; /// true = perspective camera, false = orthographic\\n        bool backfaceCulling; /// whether to implement backface culling (saves gas!)\\n        bool invert; /// whether to invert colors in the final encoding stage\\n        bool wireframe; /// whether to only render edges\\n    }\\n\\n    /// struct for testing lighting\\n    struct LightingParams {\\n        bool applyLighting; /// true = apply lighting, false = don't apply lighting\\n        int256 lightAmbiPower; /// power of the ambient light\\n        int256 lightDiffPower; /// power of the diffuse light\\n        int256 lightSpecPower; /// power of the specular light\\n        uint256 inverseShininess; /// shininess of the material\\n        int256[3] lightPos; /// position of the light\\n        int256[3] lightColSpec; /// color of the specular light\\n        int256[3] lightColDiff; /// color of the diffuse light\\n        int256[3] lightColAmbi; /// color of the ambient light\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ShackledMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nlibrary ShackledMath {\\n    /** @dev Get the minimum of two numbers */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /** @dev Get the maximum of two numbers */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /** @dev perform a modulo operation, with support for negative numbers */\\n    function mod(int256 n, int256 m) internal pure returns (int256) {\\n        if (n < 0) {\\n            return ((n % m) + m) % m;\\n        } else {\\n            return n % m;\\n        }\\n    }\\n\\n    /** @dev 'randomly' select n numbers between 0 and m \\n    (useful for getting a randomly sampled index)\\n    */\\n    function randomIdx(\\n        bytes32 seedModifier,\\n        uint256 n, // number of elements to select\\n        uint256 m // max value of elements\\n    ) internal pure returns (uint256[] memory) {\\n        uint256[] memory result = new uint256[](n);\\n        for (uint256 i = 0; i < n; i++) {\\n            result[i] =\\n                uint256(keccak256(abi.encodePacked(seedModifier, i))) %\\n                m;\\n        }\\n        return result;\\n    }\\n\\n    /** @dev create a 2d array and fill with a single value */\\n    function get2dArray(\\n        uint256 m,\\n        uint256 q,\\n        int256 value\\n    ) internal pure returns (int256[][] memory) {\\n        /// Create a matrix of values with dimensions (m, q)\\n        int256[][] memory rows = new int256[][](m);\\n        for (uint256 i = 0; i < m; i++) {\\n            int256[] memory row = new int256[](q);\\n            for (uint256 j = 0; j < q; j++) {\\n                row[j] = value;\\n            }\\n            rows[i] = row;\\n        }\\n        return rows;\\n    }\\n\\n    /** @dev get the absolute of a number\\n     */\\n    function abs(int256 x) internal pure returns (int256) {\\n        assembly {\\n            if slt(x, 0) {\\n                x := sub(0, x)\\n            }\\n        }\\n        return x;\\n    }\\n\\n    /** @dev get the square root of a number\\n     */\\n    function sqrt(int256 y) internal pure returns (int256 z) {\\n        assembly {\\n            if sgt(y, 3) {\\n                z := y\\n                let x := add(div(y, 2), 1)\\n                for {\\n\\n                } slt(x, z) {\\n\\n                } {\\n                    z := x\\n                    x := div(add(div(y, x), x), 2)\\n                }\\n            }\\n            if and(slt(y, 4), sgt(y, 0)) {\\n                z := 1\\n            }\\n        }\\n    }\\n\\n    /** @dev get the hypotenuse of a triangle given the length of 2 sides\\n     */\\n    function hypot(int256 x, int256 y) internal pure returns (int256) {\\n        int256 sumsq;\\n        assembly {\\n            let xsq := mul(x, x)\\n            let ysq := mul(y, y)\\n            sumsq := add(xsq, ysq)\\n        }\\n\\n        return sqrt(sumsq);\\n    }\\n\\n    /** @dev addition between two vectors (size 3)\\n     */\\n    function vector3Add(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, add(mload(v1), mload(v2)))\\n            mstore(\\n                add(result, 0x20),\\n                add(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                add(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev subtraction between two vectors (size 3)\\n     */\\n    function vector3Sub(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, sub(mload(v1), mload(v2)))\\n            mstore(\\n                add(result, 0x20),\\n                sub(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                sub(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev multiply a vector (size 3) by a constant\\n     */\\n    function vector3MulScalar(int256[3] memory v, int256 a)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, mul(mload(v), a))\\n            mstore(add(result, 0x20), mul(mload(add(v, 0x20)), a))\\n            mstore(add(result, 0x40), mul(mload(add(v, 0x40)), a))\\n        }\\n    }\\n\\n    /** @dev divide a vector (size 3) by a constant\\n     */\\n    function vector3DivScalar(int256[3] memory v, int256 a)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(result, sdiv(mload(v), a))\\n            mstore(add(result, 0x20), sdiv(mload(add(v, 0x20)), a))\\n            mstore(add(result, 0x40), sdiv(mload(add(v, 0x40)), a))\\n        }\\n    }\\n\\n    /** @dev get the length of a vector (size 3)\\n     */\\n    function vector3Len(int256[3] memory v) internal pure returns (int256) {\\n        int256 res;\\n        assembly {\\n            let x := mload(v)\\n            let y := mload(add(v, 0x20))\\n            let z := mload(add(v, 0x40))\\n            res := add(add(mul(x, x), mul(y, y)), mul(z, z))\\n        }\\n        return sqrt(res);\\n    }\\n\\n    /** @dev scale and then normalise a vector (size 3)\\n     */\\n    function vector3NormX(int256[3] memory v, int256 fidelity)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        int256 l = vector3Len(v);\\n        assembly {\\n            mstore(result, sdiv(mul(fidelity, mload(add(v, 0x40))), l))\\n            mstore(\\n                add(result, 0x20),\\n                sdiv(mul(fidelity, mload(add(v, 0x20))), l)\\n            )\\n            mstore(add(result, 0x40), sdiv(mul(fidelity, mload(v)), l))\\n        }\\n    }\\n\\n    /** @dev get the dot-product of two vectors (size 3)\\n     */\\n    function vector3Dot(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        view\\n        returns (int256 result)\\n    {\\n        assembly {\\n            result := add(\\n                add(\\n                    mul(mload(v1), mload(v2)),\\n                    mul(mload(add(v1, 0x20)), mload(add(v2, 0x20)))\\n                ),\\n                mul(mload(add(v1, 0x40)), mload(add(v2, 0x40)))\\n            )\\n        }\\n    }\\n\\n    /** @dev get the cross product of two vectors (size 3)\\n     */\\n    function crossProduct(int256[3] memory v1, int256[3] memory v2)\\n        internal\\n        pure\\n        returns (int256[3] memory result)\\n    {\\n        assembly {\\n            mstore(\\n                result,\\n                sub(\\n                    mul(mload(add(v1, 0x20)), mload(add(v2, 0x40))),\\n                    mul(mload(add(v1, 0x40)), mload(add(v2, 0x20)))\\n                )\\n            )\\n            mstore(\\n                add(result, 0x20),\\n                sub(\\n                    mul(mload(add(v1, 0x40)), mload(v2)),\\n                    mul(mload(v1), mload(add(v2, 0x40)))\\n                )\\n            )\\n            mstore(\\n                add(result, 0x40),\\n                sub(\\n                    mul(mload(v1), mload(add(v2, 0x20))),\\n                    mul(mload(add(v1, 0x20)), mload(v2))\\n                )\\n            )\\n        }\\n    }\\n\\n    /** @dev linearly interpolate between two vectors (size 12)\\n     */\\n    function vector12Lerp(\\n        int256[12] memory v1,\\n        int256[12] memory v2,\\n        int256 ir,\\n        int256 scaleFactor\\n    ) internal view returns (int256[12] memory result) {\\n        int256[12] memory vd = vector12Sub(v2, v1);\\n        // loop through all 12 items\\n        assembly {\\n            let ix\\n            for {\\n                let i := 0\\n            } lt(i, 0xC) {\\n                // (i < 12)\\n                i := add(i, 1)\\n            } {\\n                /// get index of the next element\\n                ix := mul(i, 0x20)\\n\\n                /// store into the result array\\n                mstore(\\n                    add(result, ix),\\n                    add(\\n                        // v1[i] + (ir * vd[i]) / 1e3\\n                        mload(add(v1, ix)),\\n                        sdiv(mul(ir, mload(add(vd, ix))), 1000)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /** @dev subtraction between two vectors (size 12)\\n     */\\n    function vector12Sub(int256[12] memory v1, int256[12] memory v2)\\n        internal\\n        view\\n        returns (int256[12] memory result)\\n    {\\n        // loop through all 12 items\\n        assembly {\\n            let ix\\n            for {\\n                let i := 0\\n            } lt(i, 0xC) {\\n                // (i < 12)\\n                i := add(i, 1)\\n            } {\\n                /// get index of the next element\\n                ix := mul(i, 0x20)\\n                /// store into the result array\\n                mstore(\\n                    add(result, ix),\\n                    sub(\\n                        // v1[ix] - v2[ix]\\n                        mload(add(v1, ix)),\\n                        mload(add(v2, ix))\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /** @dev map a number from one range into another\\n     */\\n    function mapRangeToRange(\\n        int256 num,\\n        int256 inMin,\\n        int256 inMax,\\n        int256 outMin,\\n        int256 outMax\\n    ) internal pure returns (int256 res) {\\n        assembly {\\n            res := add(\\n                sdiv(\\n                    mul(sub(outMax, outMin), sub(num, inMin)),\\n                    sub(inMax, inMin)\\n                ),\\n                outMin\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledCoords.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledCoords.sol\\\";\\n\\ncontract XShackledCoords {\\n    constructor() {}\\n\\n    function xconvertToWorldSpaceWithModelTransform(int256[3][3][] calldata tris,int256 scale,int256[3] calldata position) external view returns (int256[3][] memory) {\\n        return ShackledCoords.convertToWorldSpaceWithModelTransform(tris,scale,position);\\n    }\\n\\n    function xbackfaceCulling(int256[3][3][] calldata trisWorldSpace,int256[3][3][] calldata trisCols) external view returns (int256[3][3][] memory, int256[3][3][] memory) {\\n        return ShackledCoords.backfaceCulling(trisWorldSpace,trisCols);\\n    }\\n\\n    function xconvertToCameraSpaceViaVertexShader(int256[3][] calldata vertsWorldSpace,int256 canvasDim,bool perspCamera) external view returns (int256[3][] memory) {\\n        return ShackledCoords.convertToCameraSpaceViaVertexShader(vertsWorldSpace,canvasDim,perspCamera);\\n    }\\n\\n    function xgetCameraMatrixOrth(int256 canvasDim) external pure returns (int256[4][4][2] memory) {\\n        return ShackledCoords.getCameraMatrixOrth(canvasDim);\\n    }\\n\\n    function xgetCameraMatrixPersp() external pure returns (int256[4][4][2] memory) {\\n        return ShackledCoords.getCameraMatrixPersp();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledMath.sol\\\";\\n\\ncontract XShackledMath {\\n    constructor() {}\\n\\n    function xmin(int256 a,int256 b) external pure returns (int256) {\\n        return ShackledMath.min(a,b);\\n    }\\n\\n    function xmax(int256 a,int256 b) external pure returns (int256) {\\n        return ShackledMath.max(a,b);\\n    }\\n\\n    function xmod(int256 n,int256 m) external pure returns (int256) {\\n        return ShackledMath.mod(n,m);\\n    }\\n\\n    function xrandomIdx(bytes32 seedModifier,uint256 n,uint256 m) external pure returns (uint256[] memory) {\\n        return ShackledMath.randomIdx(seedModifier,n,m);\\n    }\\n\\n    function xget2dArray(uint256 m,uint256 q,int256 value) external pure returns (int256[][] memory) {\\n        return ShackledMath.get2dArray(m,q,value);\\n    }\\n\\n    function xabs(int256 x) external pure returns (int256) {\\n        return ShackledMath.abs(x);\\n    }\\n\\n    function xsqrt(int256 y) external pure returns (int256) {\\n        return ShackledMath.sqrt(y);\\n    }\\n\\n    function xhypot(int256 x,int256 y) external pure returns (int256) {\\n        return ShackledMath.hypot(x,y);\\n    }\\n\\n    function xvector3Add(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3Add(v1,v2);\\n    }\\n\\n    function xvector3Sub(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3Sub(v1,v2);\\n    }\\n\\n    function xvector3MulScalar(int256[3] calldata v,int256 a) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3MulScalar(v,a);\\n    }\\n\\n    function xvector3DivScalar(int256[3] calldata v,int256 a) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3DivScalar(v,a);\\n    }\\n\\n    function xvector3Len(int256[3] calldata v) external pure returns (int256) {\\n        return ShackledMath.vector3Len(v);\\n    }\\n\\n    function xvector3NormX(int256[3] calldata v,int256 fidelity) external pure returns (int256[3] memory) {\\n        return ShackledMath.vector3NormX(v,fidelity);\\n    }\\n\\n    function xvector3Dot(int256[3] calldata v1,int256[3] calldata v2) external view returns (int256) {\\n        return ShackledMath.vector3Dot(v1,v2);\\n    }\\n\\n    function xcrossProduct(int256[3] calldata v1,int256[3] calldata v2) external pure returns (int256[3] memory) {\\n        return ShackledMath.crossProduct(v1,v2);\\n    }\\n\\n    function xvector12Lerp(int256[12] calldata v1,int256[12] calldata v2,int256 ir,int256 scaleFactor) external view returns (int256[12] memory) {\\n        return ShackledMath.vector12Lerp(v1,v2,ir,scaleFactor);\\n    }\\n\\n    function xvector12Sub(int256[12] calldata v1,int256[12] calldata v2) external view returns (int256[12] memory) {\\n        return ShackledMath.vector12Sub(v1,v2);\\n    }\\n\\n    function xmapRangeToRange(int256 num,int256 inMin,int256 inMax,int256 outMin,int256 outMax) external pure returns (int256) {\\n        return ShackledMath.mapRangeToRange(num,inMin,inMax,outMin,outMax);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledRasteriser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledRasteriser.sol\\\";\\n\\ncontract XShackledRasteriser {\\n    constructor() {}\\n\\n    function xinitialiseFragments(int256[3][3][] calldata trisCameraSpace,int256[3][3][] calldata trisWorldSpace,int256[3][3][] calldata trisCols,int256 canvasDim) external view returns (int256[12][3][] memory) {\\n        return ShackledRasteriser.initialiseFragments(trisCameraSpace,trisWorldSpace,trisCols,canvasDim);\\n    }\\n\\n    function xrasterise(int256[12][3][] calldata trisFragments,int256 canvasDim,bool wireframe) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.rasterise(trisFragments,canvasDim,wireframe);\\n    }\\n\\n    function xrunBresenhamsAlgorithm(int256[12] calldata f1,int256[12] calldata f2,int256 canvasDim,int256[12][] calldata bresTriFragments,uint256 nextBresTriFragmentIx) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.runBresenhamsAlgorithm(f1,f2,canvasDim,bresTriFragments,nextBresTriFragmentIx);\\n    }\\n\\n    function xbresenhamsInner(ShackledRasteriser.BresenhamsVars calldata vars,int256 mag,int256[12] calldata fa,int256[12] calldata fb,int256 canvasDim,int256[12][] calldata bresTriFragments,uint256 nextBresTriFragmentIx) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.bresenhamsInner(vars,mag,fa,fb,canvasDim,bresTriFragments,nextBresTriFragmentIx);\\n    }\\n\\n    function xrunScanline(int256[12][] calldata bresTriFragments,int256[12][] calldata fragments,uint256 nextFragmentsIx,int256 canvasDim) external view returns (int256[12][] memory, uint256) {\\n        return ShackledRasteriser.runScanline(bresTriFragments,fragments,nextFragmentsIx,canvasDim);\\n    }\\n\\n    function xgetRowFragIndices(int256[12][] calldata bresTriFragments,int256 canvasDim) external view returns (int256[][] memory, uint256[] memory) {\\n        return ShackledRasteriser.getRowFragIndices(bresTriFragments,canvasDim);\\n    }\\n\\n    function xdepthTesting(int256[12][] calldata fragments,int256 canvasDim) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.depthTesting(fragments,canvasDim);\\n    }\\n\\n    function xlightScene(int256[12][] calldata fragments,ShackledStructs.LightingParams calldata lp) external view returns (int256[12][] memory) {\\n        return ShackledRasteriser.lightScene(fragments,lp);\\n    }\\n\\n    function xcalculateSpecular(int256 lightSpecPower,int256 hnDot,int256 fidelity,uint256 inverseShininess) external pure returns (int256) {\\n        return ShackledRasteriser.calculateSpecular(lightSpecPower,hnDot,fidelity,inverseShininess);\\n    }\\n\\n    function xgetBackground(int256 canvasDim,int256[3][2] calldata backgroundColor) external view returns (int256[5][] memory) {\\n        return ShackledRasteriser.getBackground(canvasDim,backgroundColor);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledRenderer.sol\\\";\\n\\ncontract XShackledRenderer {\\n    constructor() {}\\n\\n    function xrender(ShackledStructs.RenderParams calldata renderParams,int256 canvasDim,bool returnSVG) external view returns (string memory) {\\n        return ShackledRenderer.render(renderParams,canvasDim,returnSVG);\\n    }\\n\\n    function xprepareGeometryForRender(ShackledStructs.RenderParams calldata renderParams,int256 canvasDim) external view returns (int256[12][3][] memory) {\\n        return ShackledRenderer.prepareGeometryForRender(renderParams,canvasDim);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledStructs.sol\\\";\\n\\ncontract XShackledStructs {\\n    constructor() {}\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/ShackledUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/ShackledUtils.sol\\\";\\n\\ncontract XShackledUtils {\\n    constructor() {}\\n\\n    function xflattenTris(int256[3][3][] calldata tris) external pure returns (int256[3][] memory) {\\n        return ShackledUtils.flattenTris(tris);\\n    }\\n\\n    function xunflattenVertsToTris(int256[3][] calldata verts) external pure returns (int256[3][3][] memory) {\\n        return ShackledUtils.unflattenVertsToTris(verts);\\n    }\\n\\n    function xclipArray12ToLength(int256[12][] calldata arr,uint256 desiredLen) external pure returns (int256[12][] memory) {\\n        return ShackledUtils.clipArray12ToLength(arr,desiredLen);\\n    }\\n\\n    function xuint2str(uint256 _i) external pure returns (string memory) {\\n        return ShackledUtils.uint2str(_i);\\n    }\\n\\n    function xgetHex(uint256 _i) external pure returns (bytes memory) {\\n        return ShackledUtils.getHex(_i);\\n    }\\n\\n    function xgetSVGContainer(string calldata encodedBitmap,int256 canvasDim,uint256 outputHeight,uint256 outputWidth) external view returns (string memory) {\\n        return ShackledUtils.getSVGContainer(encodedBitmap,canvasDim,outputHeight,outputWidth);\\n    }\\n\\n    function xgetAttributes(ShackledStructs.Metadata calldata metadata) external pure returns (bytes memory) {\\n        return ShackledUtils.getAttributes(metadata);\\n    }\\n\\n    function xgetEncodedMetadata(string calldata image,ShackledStructs.Metadata calldata metadata,uint256 tokenId) external view returns (string memory) {\\n        return ShackledUtils.getEncodedMetadata(image,metadata,tokenId);\\n    }\\n\\n    function xgetEncodedBitmap(int256[12][] calldata fragments,int256[5][] calldata background,int256 canvasDim,bool invert) external view returns (string memory) {\\n        return ShackledUtils.getEncodedBitmap(fragments,background,canvasDim,invert);\\n    }\\n\\n    function xwriteFragmentsToBytesArray(int256[12][] calldata fragments,bytes calldata bytesArray,uint256 canvasDimUnsigned,bool invert) external pure returns (bytes memory) {\\n        return ShackledUtils.writeFragmentsToBytesArray(fragments,bytesArray,canvasDimUnsigned,invert);\\n    }\\n\\n    function xwriteBackgroundToBytesArray(int256[5][] calldata background,bytes calldata bytesArray,uint256 canvasDimUnsigned,bool invert) external pure returns (bytes memory) {\\n        return ShackledUtils.writeBackgroundToBytesArray(background,bytesArray,canvasDimUnsigned,invert);\\n    }\\n}\\n\\ncontract XBase64 {\\n    constructor() {}\\n\\n    function xencode(bytes calldata data) external view returns (string memory) {\\n        return Base64.encode(data);\\n    }\\n}\\n\\ncontract XBytesUtils {\\n    constructor() {}\\n\\n    function xchar(bytes1 b) external view returns (bytes1) {\\n        return BytesUtils.char(b);\\n    }\\n\\n    function xbytes32string(bytes32 b32) external view returns (string memory) {\\n        return BytesUtils.bytes32string(b32);\\n    }\\n\\n    function xhach(string calldata value) external view returns (string memory) {\\n        return BytesUtils.hach(value);\\n    }\\n\\n    function xMergeBytes(bytes calldata a,bytes calldata b) external pure returns (bytes memory) {\\n        return BytesUtils.MergeBytes(a,b);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/ShackledCoords.sol\": {\r\n        \"ShackledCoords\": \"0x1dc9119f8884c189193fe930de70611d79f79cd2\"\r\n      },\r\n      \"contracts/ShackledRasteriser.sol\": {\r\n        \"ShackledRasteriser\": \"0xb85e2cde413bb51651c5948c3e15ed0738367117\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256[3][]\",\"name\":\"faces\",\"type\":\"uint256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"verts\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3][]\",\"name\":\"cols\",\"type\":\"int256[3][]\"},{\"internalType\":\"int256[3]\",\"name\":\"objPosition\",\"type\":\"int256[3]\"},{\"internalType\":\"int256\",\"name\":\"objScale\",\"type\":\"int256\"},{\"internalType\":\"int256[3][2]\",\"name\":\"backgroundColor\",\"type\":\"int256[3][2]\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"applyLighting\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"lightAmbiPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightDiffPower\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"lightSpecPower\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"inverseShininess\",\"type\":\"uint256\"},{\"internalType\":\"int256[3]\",\"name\":\"lightPos\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColSpec\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColDiff\",\"type\":\"int256[3]\"},{\"internalType\":\"int256[3]\",\"name\":\"lightColAmbi\",\"type\":\"int256[3]\"}],\"internalType\":\"struct ShackledStructs.LightingParams\",\"name\":\"lightingParams\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"perspCamera\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"backfaceCulling\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"invert\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"wireframe\",\"type\":\"bool\"}],\"internalType\":\"struct ShackledStructs.RenderParams\",\"name\":\"renderParams\",\"type\":\"tuple\"},{\"internalType\":\"int256\",\"name\":\"canvasDim\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"returnSVG\",\"type\":\"bool\"}],\"name\":\"render\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ShackledRenderer", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}