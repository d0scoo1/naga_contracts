{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/nft/DopamineTab.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport { IDopamineTab } from \\\"../interfaces/IDopamineTab.sol\\\";\\nimport { IOpenSeaProxyRegistry } from \\\"../interfaces/IOpenSeaProxyRegistry.sol\\\";\\n\\nimport { ERC721 } from \\\"../erc721/ERC721.sol\\\";\\nimport { ERC721Votable } from \\\"../erc721/ERC721Votable.sol\\\";\\n\\n/// @title Dopamine Membership Tab\\n/// @notice Tab holders are first-class members of the Dopamine metaverse.\\n///  The tabs are minted through seasonal drops of varying sizes and durations,\\n///  with each drop featuring different sets of attributes. Drop parameters are\\n///  configurable by the admin address, with emissions controlled by the minter\\n///  address. A drop is completed once all non-allowlisted tabs are minted.\\ncontract DopamineTab is ERC721Votable, IDopamineTab {\\n\\n    /// @notice The maximum number of tabs that may be allowlisted per drop.\\n    uint256 public constant MAX_AL_SIZE = 99;\\n\\n    /// @notice The minimum number of tabs that can be minted for a drop.\\n    uint256 public constant MIN_DROP_SIZE = 1;\\n\\n    /// @notice The maximum number of tabs that can be minted for a drop.\\n    uint256 public constant MAX_DROP_SIZE = 9999;\\n\\n    /// @notice The minimum delay required to wait between creations of drops.\\n    uint256 public constant MIN_DROP_DELAY = 1 days;\\n\\n    /// @notice The maximum delay required to wait between creations of drops.\\n    uint256 public constant MAX_DROP_DELAY = 24 weeks;\\n\\n    /// @notice The address administering drop creation, sizing, and scheduling.\\n    address public admin;\\n\\n    /// @notice The temporary address that will become admin once accepted.\\n    address public pendingAdmin;\\n\\n    /// @notice The address responsible for controlling tab emissions.\\n    address public minter;\\n\\n    /// @notice The OS registry address - allowlisted for gasless OS approvals.\\n    IOpenSeaProxyRegistry public proxyRegistry;\\n\\n    /// @notice The URI each tab initially points to for metadata resolution.\\n    /// @dev Before drop completion, `tokenURI()` resolves to \\\"{baseURI}/{id}\\\".\\n    string public baseURI;\\n\\n    /// @notice The minimum time to wait in seconds between drop creations.\\n    uint256 public dropDelay;\\n\\n    /// @notice The current drop's ending tab id (exclusive boundary).\\n    uint256 public dropEndIndex;\\n\\n    /// @notice The time at which a new drop can start (if last drop completes).\\n    uint256 public dropEndTime;\\n\\n    /// @notice Maps a drop to its allowlist (merkle tree root).\\n    mapping(uint256 => bytes32) public dropAllowlist;\\n\\n    /// @notice Maps a drop to its provenance hash (concatenated image hash).\\n    mapping(uint256 => bytes32) public dropProvenanceHash;\\n\\n    /// @notice Maps a drop to its finalized IPFS / Arweave tab metadata URI.\\n    mapping(uint256 => string) public dropURI;\\n\\n    /// @dev Maps a drop id to its ending tab id (exclusive boundary).\\n    uint256[] private _dropEndIndices;\\n\\n    /// @dev An internal tracker for the id of the next tab to mint.\\n    uint256 private _id;\\n\\n    /// @dev Restricts a function call to address `minter`.\\n    modifier onlyMinter() {\\n        if (msg.sender != minter) {\\n            revert MinterOnly();\\n        }\\n        _;\\n    }\\n\\n    /// @dev Restricts a function call to address `admin`.\\n    modifier onlyAdmin() {\\n        if (msg.sender != admin) {\\n            revert AdminOnly();\\n        }\\n        _;\\n    }\\n\\n    /// @notice Initializes the membership tab with the specified drop settings.\\n    /// @param minter_ The address which will control tab emissions.\\n    /// @param proxyRegistry_ The OS proxy registry address.\\n    /// @param dropDelay_ The minimum delay to wait between drop creations.\\n    /// @param maxSupply_ The supply for the tab collection.\\n    constructor(\\n        string memory baseURI_,\\n        address minter_,\\n        address proxyRegistry_,\\n        uint256 dropDelay_,\\n        uint256 maxSupply_\\n    ) ERC721Votable(\\\"Dopamine Tabs\\\", \\\"TAB\\\", maxSupply_) {\\n        admin = msg.sender;\\n        emit AdminChanged(address(0), admin);\\n\\n        minter = minter_;\\n        emit MinterChanged(address(0), minter);\\n\\n        baseURI = baseURI_;\\n        emit BaseURISet(baseURI);\\n\\n        proxyRegistry = IOpenSeaProxyRegistry(proxyRegistry_);\\n\\n        setDropDelay(dropDelay_);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function contractURI() external view returns (string memory)  {\\n        return string(abi.encodePacked(baseURI, \\\"contract\\\"));\\n    }\\n\\n    /// @inheritdoc ERC721\\n    /// @dev Before drop completion, the token URI for tab of id `id` defaults\\n    ///  to {baseURI}/{id}. Once the drop completes, it is replaced by an IPFS /\\n    ///  Arweave URI, and `tokenURI()` will resolve to {dropURI[dropId]}/{id}.\\n    ///  This function reverts if the queried tab of id `id` does not exist.\\n    /// @param id The id of the NFT being queried.\\n    function tokenURI(uint256 id)\\n        external\\n        view\\n        override(ERC721)\\n        returns (string memory)\\n    {\\n        if (ownerOf[id] == address(0)) {\\n            revert TokenNonExistent();\\n        }\\n\\n        string memory uri = dropURI[dropId(id)];\\n        if (bytes(uri).length == 0) {\\n            uri = baseURI;\\n        }\\n        return string(abi.encodePacked(uri, _toString(id)));\\n    }\\n\\n\\n    /// @dev Ensures OS proxy is allowlisted for operating on behalf of owners.\\n    /// @inheritdoc ERC721\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return\\n            proxyRegistry.proxies(owner) == operator ||\\n            _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function mint() external onlyMinter returns (uint256) {\\n        if (_id >= dropEndIndex) {\\n            revert DropMaxCapacity();\\n        }\\n        return _mint(minter, _id++);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function claim(bytes32[] calldata proof, uint256 id) external {\\n        if (id >= _id) {\\n            revert ClaimInvalid();\\n        }\\n\\n        bytes32 allowlist = dropAllowlist[dropId(id)];\\n        bytes32 leaf = keccak256(abi.encodePacked(msg.sender, id));\\n\\n        if (!_verify(allowlist, proof, leaf)) {\\n            revert ProofInvalid();\\n        }\\n\\n        _mint(msg.sender, id);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function createDrop(\\n        uint256 dropId,\\n        uint256 startIndex,\\n        uint256 dropSize,\\n        bytes32 provenanceHash,\\n        uint256 allowlistSize,\\n        bytes32 allowlist\\n    )\\n        external\\n        onlyAdmin\\n    {\\n        if (_id < dropEndIndex) {\\n            revert DropOngoing();\\n        }\\n        if (startIndex != _id) {\\n            revert DropStartInvalid();\\n        }\\n        if (dropId != _dropEndIndices.length) {\\n            revert DropInvalid();\\n        }\\n        if (block.timestamp < dropEndTime) {\\n            revert DropTooEarly();\\n        }\\n        if (allowlistSize > MAX_AL_SIZE || allowlistSize > dropSize) {\\n            revert DropAllowlistOverCapacity();\\n        }\\n        if (\\n            dropSize < MIN_DROP_SIZE ||\\n            dropSize > MAX_DROP_SIZE\\n        ) {\\n            revert DropSizeInvalid();\\n        }\\n        if (_id + dropSize > maxSupply) {\\n            revert DropMaxCapacity();\\n        }\\n\\n        dropEndIndex = _id + dropSize;\\n        _id += allowlistSize;\\n        _dropEndIndices.push(dropEndIndex);\\n\\n        dropEndTime = block.timestamp + dropDelay;\\n\\n        dropProvenanceHash[dropId] = provenanceHash;\\n        dropAllowlist[dropId] = allowlist;\\n\\n        emit DropCreated(\\n            dropId,\\n            startIndex,\\n            dropSize,\\n            allowlistSize,\\n            allowlist,\\n            provenanceHash\\n        );\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function setMinter(address newMinter) external onlyAdmin {\\n        emit MinterChanged(minter, newMinter);\\n        minter = newMinter;\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function setPendingAdmin(address newPendingAdmin)\\n        public\\n        override\\n        onlyAdmin\\n    {\\n        pendingAdmin = newPendingAdmin;\\n        emit PendingAdminSet(pendingAdmin);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function acceptAdmin() public override {\\n        if (msg.sender != pendingAdmin) {\\n            revert PendingAdminOnly();\\n        }\\n\\n        emit AdminChanged(admin, pendingAdmin);\\n        admin = pendingAdmin;\\n        pendingAdmin = address(0);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function setDropURI(uint256 id, string calldata uri)\\n        external\\n        onlyAdmin\\n    {\\n        uint256 numDrops = _dropEndIndices.length;\\n        if (id >= numDrops) {\\n            revert DropNonExistent();\\n        }\\n        dropURI[id] = uri;\\n        emit DropURISet(id, uri);\\n    }\\n\\n\\n    /// @inheritdoc IDopamineTab\\n    function updateDrop(\\n        uint256 dropId,\\n        bytes32 provenanceHash,\\n        bytes32 allowlist\\n    ) external onlyAdmin {\\n        uint256 numDrops = _dropEndIndices.length;\\n        if (dropId >= numDrops) {\\n            revert DropNonExistent();\\n        }\\n\\n        // Once a drop's URI is set, it may not be modified.\\n        if (bytes(dropURI[dropId]).length != 0) {\\n            revert DropImmutable();\\n        }\\n\\n        dropProvenanceHash[dropId] = provenanceHash;\\n        dropAllowlist[dropId] = allowlist;\\n\\n        emit DropUpdated(\\n            dropId,\\n            provenanceHash,\\n            allowlist\\n        );\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function setBaseURI(string calldata newBaseURI) public onlyAdmin {\\n        baseURI = newBaseURI;\\n        emit BaseURISet(newBaseURI);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function setDropDelay(uint256 newDropDelay) public override onlyAdmin {\\n        if (newDropDelay < MIN_DROP_DELAY || newDropDelay > MAX_DROP_DELAY) {\\n            revert DropDelayInvalid();\\n        }\\n        dropDelay = newDropDelay;\\n        emit DropDelaySet(dropDelay);\\n    }\\n\\n    /// @inheritdoc IDopamineTab\\n    function dropId(uint256 id) public view returns (uint256) {\\n        for (uint256 i = 0; i < _dropEndIndices.length; i++) {\\n            if (id  < _dropEndIndices[i]) {\\n                return i;\\n            }\\n        }\\n        revert DropNonExistent();\\n    }\\n\\n    /// @dev Checks whether `leaf` is part of merkle tree rooted at `merkleRoot`\\n    ///  using proof `proof`. Merkle tree generation and proof construction is\\n    ///  done using the following JS library: github.com/miguelmota/merkletreejs\\n    /// @param merkleRoot The hexlified merkle root as a bytes32 data type.\\n    /// @param proof The abi-encoded proof formatted as a bytes32 array.\\n    /// @param leaf The leaf node being checked (uses keccak-256 hashing).\\n    /// @return True if `leaf` is in `merkleRoot`-rooted tree, False otherwise.\\n    function _verify(\\n        bytes32 merkleRoot,\\n        bytes32[] memory proof,\\n        bytes32 leaf\\n    ) private pure returns (bool)\\n    {\\n        bytes32 hash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (hash <= proofElement) {\\n                hash = keccak256(abi.encodePacked(hash, proofElement));\\n            } else {\\n                hash = keccak256(abi.encodePacked(proofElement, hash));\\n            }\\n        }\\n        return hash == merkleRoot;\\n    }\\n\\n    /// @dev Converts a uint256 into a string.\\n    function _toString(uint256 value) private pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n// This file is a shared repository of all errors used in Dopamine's contracts.\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                              Dopamine Tab                                ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Configured drop delay is invalid.\\nerror DropDelayInvalid();\\n\\n/// @notice Drop identifier is invalid.\\nerror DropInvalid();\\n\\n/// @notice Drop details may no longer be modified.\\nerror DropImmutable();\\n\\n/// @notice Drop hit max allocatable capacity.\\nerror DropMaxCapacity();\\n\\n/// @notice No such drop exists.\\nerror DropNonExistent();\\n\\n/// @notice Action cannot be completed as a current drop is ongoing.\\nerror DropOngoing();\\n\\n/// @notice Configured drop size is invalid.\\nerror DropSizeInvalid();\\n\\n/// @notice Drop starting index is incorrect.\\nerror DropStartInvalid();\\n\\n/// @notice Insufficient time passed since last drop was created.\\nerror DropTooEarly();\\n\\n/// @notice Configured allowlist size is too large.\\nerror DropAllowlistOverCapacity();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                          Dopamine Auction House                          ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Auction has already been settled.\\nerror AuctionAlreadySettled();\\n\\n/// @notice Operation cannot be performed as auction is already suspended.\\nerror AuctionAlreadySuspended();\\n\\n/// @notice The NFT specified in the auction bid is invalid.\\nerror AuctionBidInvalid();\\n\\n/// @notice Bid placed was too low.\\nerror AuctionBidTooLow();\\n\\n/// @notice Auction duration set is invalid.\\nerror AuctionDurationInvalid();\\n\\n/// @notice The auction has expired.\\nerror AuctionExpired();\\n\\n/// @notice Operation cannot be performed as auction is not suspended.\\nerror AuctionNotSuspended();\\n\\n/// @notice Auction has yet to complete.\\nerror AuctionOngoing();\\n\\n/// @notice Reserve price set is invalid.\\nerror AuctionReservePriceInvalid();\\n\\n/// @notice Time buffer set is invalid.\\nerror AuctionBufferInvalid();\\n\\n/// @notice Treasury split is invalid, must be in range [0, 100].\\nerror AuctionTreasurySplitInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                              Miscellaneous                               ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Mismatch between input arrays.\\nerror ArityMismatch();\\n\\n/// @notice Block number being queried is invalid.\\nerror BlockInvalid();\\n\\n/// @notice Reentrancy vulnerability.\\nerror FunctionReentrant();\\n\\n/// @notice Number does not fit in 32 bytes.\\nerror Uint32ConversionInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 Upgrades                                 ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Contract already initialized.\\nerror ContractAlreadyInitialized();\\n\\n/// @notice Upgrade requires either admin or vetoer privileges.\\nerror UpgradeUnauthorized();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 EIP-712                                  ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Signature has expired and is no longer valid.\\nerror SignatureExpired();\\n\\n/// @notice Signature invalid.\\nerror SignatureInvalid();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 EIP-721                                  ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Originating address does not own the NFT.\\nerror OwnerInvalid();\\n\\n/// @notice Receiving address cannot be the zero address.\\nerror ReceiverInvalid();\\n\\n/// @notice Receiving contract does not implement the ERC-721 wallet interface.\\nerror SafeTransferUnsupported();\\n\\n/// @notice Sender is not NFT owner, approved address, or owner operator.\\nerror SenderUnauthorized();\\n\\n/// @notice NFT supply has hit maximum capacity.\\nerror SupplyMaxCapacity();\\n\\n/// @notice Token has already minted.\\nerror TokenAlreadyMinted();\\n\\n/// @notice NFT does not exist.\\nerror TokenNonExistent();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                              Administrative                              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Function callable only by the admin.\\nerror AdminOnly();\\n\\n/// @notice Function callable only by the minter.\\nerror MinterOnly();\\n\\n/// @notice Function callable only by the owner.\\nerror OwnerOnly();\\n\\n/// @notice Function callable only by the pending owner.\\nerror PendingAdminOnly();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                Governance                                ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Invalid number of actions proposed.\\nerror ProposalActionCountInvalid();\\n\\n/// @notice Proposal has already been settled.\\nerror ProposalAlreadySettled();\\n\\n/// @notice Inactive proposals may not be voted for.\\nerror ProposalInactive();\\n\\n/// @notice Proposal has failed to or has yet to be queued.\\nerror ProposalNotYetQueued();\\n\\n/// @notice Quorum threshold is invalid.\\nerror ProposalQuorumThresholdInvalid();\\n\\n/// @notice Proposal threshold is invalid.\\nerror ProposalThresholdInvalid();\\n\\n/// @notice Proposal has failed to or has yet to be successful.\\nerror ProposalUnpassed();\\n\\n/// @notice A proposal is currently running and must be settled first.\\nerror ProposalUnsettled();\\n\\n/// @notice Voting delay set is invalid.\\nerror ProposalVotingDelayInvalid();\\n\\n/// @notice Voting period set is invalid.\\nerror ProposalVotingPeriodInvalid();\\n\\n/// @notice Only the proposer may invoke this action.\\nerror ProposerOnly();\\n\\n/// @notice Function callable only by the vetoer.\\nerror VetoerOnly();\\n\\n/// @notice Veto power has been revoked.\\nerror VetoPowerRevoked();\\n\\n/// @notice Proposal already voted for.\\nerror VoteAlreadyCast();\\n\\n/// @notice Vote type is not valid.\\nerror VoteInvalid();\\n\\n/// @notice Voting power insufficient.\\nerror VotingPowerInsufficient();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                                 Timelock                                 ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Invalid set timelock delay.\\nerror TimelockDelayInvalid();\\n\\n/// @notice Function callable only by the timelock itself.\\nerror TimelockOnly();\\n\\n/// @notice Duplicate transaction queued.\\nerror TransactionAlreadyQueued();\\n\\n/// @notice Transaction is not yet queued.\\nerror TransactionNotYetQueued();\\n\\n/// @notice Transaction executed prematurely.\\nerror TransactionPremature();\\n\\n/// @notice Transaction execution was reverted.\\nerror TransactionReverted();\\n\\n/// @notice Transaction is stale.\\nerror TransactionStale();\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///                             Merkle Allowlist                             ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Claim drop identifier is invalid.\\nerror ClaimInvalid();\\n\\n/// @notice Proof for claim is invalid.\\nerror ProofInvalid();\\n\\n///////////////////////////////////////////////////////////////////////////////\\n///                           EIP-2981 Royalties                             ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @notice Royalties are set too high.\\nerror RoyaltiesTooHigh();\\n\"\r\n    },\r\n    \"src/interfaces/IDopamineTab.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\nimport \\\"./IDopamineTabEvents.sol\\\";\\n\\n/// @title Dopamine Membership Tab Interface\\ninterface IDopamineTab is IDopamineTabEvents {\\n\\n    /// @notice Mints a dopamine tab to the minter address.\\n    /// @dev This function is only callable by the minter address.\\n    /// @return Id of the minted tab, which is always equal to `_id`.\\n    function mint() external returns (uint256);\\n\\n    /// @notice Mints an allowlisted tab of id `id` to the sender address if\\n    ///  merkle proof `proof` proves they were allowlisted with that tab id.\\n    /// @dev Reverts if invalid proof is provided or claimer isn't allowlisted.\\n    ///  The allowlist is formed using encoded tuple leaves (address, id). The\\n    ///  Merkle Tree JS library used: https://github.com/miguelmota/merkletreejs\\n    /// @param proof The Merkle proof of the claim as a bytes32 array.\\n    /// @param id The id of the Dopamine tab being claimed.\\n    function claim(bytes32[] calldata proof, uint256 id) external;\\n\\n    /// @notice Creates a new Dopamine tab drop.\\n    /// @dev This function is only callable by the admin address, and reverts if\\n    ///  an ongoing drop exists, drop starting index is invalid, call is too\\n    //   early, drop identifier is invalid, allowlist size is too large,\\n    ///  drop size is too small or too large, or max capacity was reached.\\n    /// @param dropId The drop's id (must 1 + last drop id).\\n    /// @param startIndex The drop's start index (must be last `dropEndIndex`).\\n    /// @param dropSize The total number of tabs of the drop (incl. allowlist).\\n    /// @param provenanceHash An immutable provenance hash equal to the SHA-256\\n    ///  hash of the concatenation of all SHA-256 image hashes of the drop.\\n    /// @param allowlistSize The total number of allowlisted tabs of the drop.\\n    /// @param allowlist Merkle root comprised of allowlisted address-tab pairs.\\n    function createDrop(\\n        uint256 dropId,\\n        uint256 startIndex,\\n        uint256 dropSize,\\n        bytes32 provenanceHash,\\n        uint256 allowlistSize,\\n        bytes32 allowlist\\n    ) external;\\n\\n    /// @notice Gets the admin address, which controls drop settings & creation.\\n    function admin() external view returns (address);\\n\\n    /// @notice Gets the minter address, which controls Dopamine tab emissions.\\n    function minter() external view returns (address);\\n\\n    /// @notice Gets the time needed to wait in seconds between drop creations.\\n    function dropDelay() external view returns (uint256);\\n\\n    /// @notice Gets the last token id of the current drop (exclusive boundary).\\n    function dropEndIndex() external view returns (uint256);\\n\\n    /// @notice Gets the time at which a new drop can start (if last completed).\\n    function dropEndTime() external view returns (uint256);\\n\\n    /// @notice Retrieves the provenance hash for a drop with id `dropId`.\\n    /// @param dropId The id of the drop being queried.\\n    /// @return SHA-256 hash of all sequenced SHA-256 image hashes of the drop.\\n    function dropProvenanceHash(uint256 dropId) external view returns (bytes32);\\n\\n    /// @notice Retrieves the metadata URI for a drop with id `dropId`.\\n    /// @param dropId The id of the drop being queried.\\n    /// @return URI of the drop's metadata as a string.\\n    function dropURI(uint256 dropId) external view returns (string memory);\\n\\n    /// @notice Retrieves the allowlist for a drop with id `dropId`.\\n    /// @dev See `claim()` for details regarding allowlist generation.\\n    /// @param dropId The id of the drop being queried.\\n    /// @return The drop's allowlist, as a bytes32 merkle tree root.\\n    function dropAllowlist(uint256 dropId) external view returns (bytes32);\\n\\n    /// @notice Retrieves the drop id of the tab with id `id`.\\n    /// @dev This function reverts for non-existent drops. For existing drops, \\n    ///  the drop id will be returned even if a drop's tab has yet to mint.\\n    /// @param dropId The id of the drop being queried.\\n    /// @return The drop id of the queried tab.\\n    function dropId(uint256 dropId) external view returns (uint256);\\n\\n    /// @notice Retrieves a URI describing the overall contract-level metadata.\\n    /// @return A string URI pointing to the tab contract metadata.\\n    function contractURI() external view returns (string memory);\\n\\n    /// @notice Sets the minter address to `newMinter`.\\n    /// @param newMinter The address of the new minter.\\n    /// @dev This function is only callable by the admin address.\\n    function setMinter(address newMinter) external;\\n\\n    /// @notice Sets the pending admin address to  `newPendingAdmin`.\\n    /// @param newPendingAdmin The address of the new pending admin.\\n    /// @dev This function is only callable by the admin address.\\n    function setPendingAdmin(address newPendingAdmin) external;\\n\\n    /// @notice Assigns the `pendingAdmin` address to the `admin` address.\\n    /// @dev This function is only callable by the pending admin address.\\n    function acceptAdmin() external;\\n\\n    /// @notice Sets the base URI to `newBaseURI`.\\n    /// @param newBaseURI The new base metadata URI to set for the collection.\\n    /// @dev This function is only callable by the admin address.\\n    function setBaseURI(string calldata newBaseURI) external;\\n\\n    /// @notice Sets the final metadata URI for drop `dropId` to `dropURI`.\\n    /// @dev This function is only callable by the admin address, and reverts\\n    ///  if the specified drop `dropId` does not exist.\\n    /// @param dropId The id of the drop whose final metadata URI is being set.\\n    /// @param uri The finalized IPFS / Arweave metadata URI.\\n    function setDropURI(uint256 dropId, string calldata uri) external;\\n\\n    /// @notice Sets the drop delay `dropDelay` to `newDropDelay`.\\n    /// @dev This function is only callable by the admin address, and reverts if\\n    ///  the drop delay is too small or too large.\\n    /// @param newDropDelay The new drop delay to set, in seconds.\\n    function setDropDelay(uint256 newDropDelay) external;\\n\\n    /// @notice Updates the drop provenance hash and allowlist.\\n    /// @dev This function is only callable by the admin address, and will\\n    ///  revert when called after drop finalization (when drop URI is set).\\n    ///  Note: This function should NOT be called unless drop is misconfigured.\\n    /// @param dropId The id of the drop being queried.\\n    /// @param provenanceHash The drop's provenance hash (SHA-256 of images).\\n    /// @param allowlist Merkle root of drop's allowlisted address-NFT pairs.\\n    function updateDrop(\\n        uint256 dropId,\\n        bytes32 provenanceHash,\\n        bytes32 allowlist\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IOpenSeaProxyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title OpenSea Proxy Registry Interface\\ninterface IOpenSeaProxyRegistry {\\n\\n    /// @notice Returns the proxy account associated with an OS user address.\\n    function proxies(address) external view returns (address);\\n\\n}\\n\"\r\n    },\r\n    \"src/erc721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// Transfer & minting methods derive from ERC721.sol of Rari Capital's solmate.\\n\\nimport {IERC721} from \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\\\";\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\n\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport {IERC2981} from \\\"../interfaces/IERC2981.sol\\\";\\n\\n/// @title Dopamine Minimal ERC-721 Contract\\n/// @notice This is a minimal ERC-721 implementation that supports the metadata\\n///  extension, tracks total supply, and includes a capped maximum supply.\\n/// @dev This ERC-721 implementation is optimized for mints and transfers of\\n///  individual tokens (as opposed to bulk). It also includes EIP-712 methods &\\n///  data structures to allow for signing processes to be built on top of it.\\ncontract ERC721 is IERC721, IERC721Metadata, IERC2981 {\\n\\n    /// @notice The maximum number of NFTs that can ever exist.\\n    /// @dev For tabs this is also capped by the emissions plan (e.g. 1 / day).\\n    uint256 public immutable maxSupply;\\n\\n    /// @notice The name of the NFT collection.\\n    string public name;\\n\\n    /// @notice The abbreviated name of the NFT collection.\\n    string public symbol;\\n\\n    /// @notice The total number of NFTs in circulation.\\n    uint256 public totalSupply;\\n\\n    /// @notice Gets the number of NFTs owned by an address.\\n    /// @dev This implementation does not throw for zero-address queries.\\n    mapping(address => uint256) public balanceOf;\\n\\n    /// @notice Gets the assigned owner of an address.\\n    /// @dev This implementation does not throw for NFTs of the zero address.\\n    mapping(uint256 => address) public ownerOf;\\n\\n    /// @notice Gets the approved address for an NFT.\\n    /// @dev This implementation does not throw for zero-address queries.\\n    mapping(uint256 => address) public getApproved;\\n\\n    /// @notice Maps an address to a nonce for replay protection.\\n    /// @dev Nonces are used with EIP-712 signing built on top of this contract.\\n    mapping(address => uint256) public nonces;\\n\\n    /// @dev Checks for an owner if an address is an authorized operator.\\n    mapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n    /// @dev EIP-2981 collection-wide royalties information.\\n    RoyaltiesInfo internal _royaltiesInfo;\\n\\n    /// @dev EIP-712 immutables for signing messages.\\n    uint256 internal immutable _CHAIN_ID;\\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\\n\\n    /// @dev  EIP-165 identifiers for all supported interfaces.\\n    bytes4 private constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\\n    bytes4 private constant _ERC721_INTERFACE_ID = 0x80ac58cd;\\n    bytes4 private constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\\n    bytes4 private constant _ERC2981_METADATA_INTERFACE_ID = 0x2a55205a;\\n\\n    /// @notice Instantiates a new ERC-721 contract.\\n    /// @param name_ The name of the NFT collecton.\\n    /// @param symbol_ The abbreviated name of the NFT collection.\\n    /// @param maxSupply_ The maximum supply for the NFT collection.\\n    constructor(\\n        string memory name_,\\n        string memory symbol_,\\n        uint256 maxSupply_\\n    ) {\\n        name = name_;\\n        symbol = symbol_;\\n        maxSupply = maxSupply_;\\n\\n        _CHAIN_ID = block.chainid;\\n        _DOMAIN_SEPARATOR = _buildDomainSeparator();\\n    }\\n\\n    /// @notice Sets approved address of NFT of id `id` to address `approved`.\\n    /// @param approved The new approved address for the NFT.\\n    /// @param id The id of the NFT to approve.\\n    function approve(address approved, uint256 id) external {\\n        address owner = ownerOf[id];\\n\\n        if (msg.sender != owner && !_operatorApprovals[owner][msg.sender]) {\\n            revert SenderUnauthorized();\\n        }\\n\\n        getApproved[id] = approved;\\n        emit Approval(owner, approved, id);\\n    }\\n\\n    /// @notice Checks if `operator` is an authorized operator for `owner`.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the owner's operator.\\n    /// @return True if `operator` is approved operator of `owner`, else False.\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        virtual returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /// @notice Sets the operator for `msg.sender` to `operator`.\\n    /// @param operator The operator address that will manage the sender's NFTs.\\n    /// @param approved Whether operator is allowed to operate sender's NFTs.\\n    function setApprovalForAll(address operator, bool approved) external {\\n        _operatorApprovals[msg.sender][operator] = approved;\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    /// @notice Returns the metadata URI associated with the NFT of id `id`.\\n    /// @return A string URI pointing to metadata of the queried NFT.\\n    function tokenURI(uint256) external view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /// @notice Checks if interface of identifier `id` is supported.\\n    /// @param id The ERC-165 interface identifier.\\n    /// @return True if interface id `id` is supported, false otherwise.\\n    function supportsInterface(bytes4 id) external pure virtual returns (bool) {\\n        return\\n            id == _ERC165_INTERFACE_ID ||\\n            id == _ERC721_INTERFACE_ID ||\\n            id == _ERC721_METADATA_INTERFACE_ID ||\\n            id == _ERC2981_METADATA_INTERFACE_ID;\\n    }\\n\\n    /// @inheritdoc IERC2981\\n    function royaltyInfo(\\n        uint256,\\n        uint256 salePrice\\n    ) external view returns (address, uint256) {\\n        RoyaltiesInfo memory royaltiesInfo = _royaltiesInfo;\\n        uint256 royalties = (salePrice * royaltiesInfo.royalties) / 10000;\\n        return (royaltiesInfo.receiver, royalties);\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  with safety checks ensuring `to` is capable of receiving the NFT.\\n    /// @dev Safety checks are only performed if `to` is a smart contract.\\n    /// @param from The existing owner address of the NFT to be transferred.\\n    /// @param to The new owner address of the NFT being transferred.\\n    /// @param id The id of the NFT being transferred.\\n    /// @param data Additional transfer data to pass to the receiving contract.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, data)\\n                !=\\n                IERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert SafeTransferUnsupported();\\n        }\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  with safety checks ensuring `to` is capable of receiving the NFT.\\n    /// @dev Safety checks are only performed if `to` is a smart contract.\\n    /// @param from The existing owner address of the NFT to be transferred.\\n    /// @param to The new owner address of the NFT being transferred.\\n    /// @param id The id of the NFT being transferred.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public {\\n        transferFrom(from, to, id);\\n\\n        if (\\n            to.code.length != 0 &&\\n                IERC721Receiver(to).onERC721Received(msg.sender, from, id, \\\"\\\")\\n                !=\\n                IERC721Receiver.onERC721Received.selector\\n        ) {\\n            revert SafeTransferUnsupported();\\n        }\\n    }\\n\\n    /// @notice Transfers NFT of id `id` from address `from` to address `to`,\\n    ///  without performing any safety checks.\\n    /// @dev Existence of an NFT is inferred by having a non-zero owner address.\\n    ///  Transfers clear owner approvals, but `Approval` events are omitted.\\n    /// @param from The existing owner address of the NFT being transferred.\\n    /// @param to The new owner address of the NFT being transferred.\\n    /// @param id The id of the NFT being transferred.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public {\\n        if (from != ownerOf[id]) {\\n            revert OwnerInvalid();\\n        }\\n\\n        if (\\n            msg.sender != from &&\\n            msg.sender != getApproved[id] &&\\n            !_operatorApprovals[from][msg.sender]\\n        ) {\\n            revert SenderUnauthorized();\\n        }\\n\\n        if (to == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n\\n        _beforeTokenTransfer(from, to, id);\\n\\n        delete getApproved[id];\\n\\n        unchecked {\\n            balanceOf[from]--;\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n        emit Transfer(from, to, id);\\n    }\\n\\n    /// @dev Mints NFT of id `id` to address `to`. To save gas, it is assumed\\n    ///  that `maxSupply` < `type(uint256).max` (ex. for tabs, cap is very low).\\n    /// @param to Address receiving the minted NFT.\\n    /// @param id Identifier of the NFT being minted.\\n    /// @return The id of the minted NFT.\\n    function _mint(address to, uint256 id) internal returns (uint256) {\\n        if (to == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n        if (ownerOf[id] != address(0)) {\\n            revert TokenAlreadyMinted();\\n        }\\n\\n        _beforeTokenTransfer(address(0), to, id);\\n\\n        unchecked {\\n            totalSupply++;\\n            balanceOf[to]++;\\n        }\\n\\n        if (totalSupply > maxSupply) {\\n            revert SupplyMaxCapacity();\\n        }\\n\\n        ownerOf[id] = to;\\n        emit Transfer(address(0), to, id);\\n        return id;\\n    }\\n\\n    /// @dev Burns NFT of id `id`, removing it from existence.\\n    /// @param id Identifier of the NFT being burned\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        if (owner == address(0)) {\\n            revert TokenNonExistent();\\n        }\\n\\n        _beforeTokenTransfer(owner, address(0), id);\\n\\n        unchecked {\\n            totalSupply--;\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /// @notice Pre-transfer hook for embedding additional transfer behavior.\\n    /// @param from The address of the existing owner of the NFT.\\n    /// @param to The address of the new owner of the NFT.\\n    /// @param id The id of the NFT being transferred.\\n    function _beforeTokenTransfer(address from, address to, uint256 id)\\n        internal\\n        virtual\\n        {}\\n\\n    /// @dev Generates an EIP-712 domain separator for the NFT collection.\\n    /// @return A 256-bit domain separator (see EIP-712 for details).\\n    function _buildDomainSeparator() internal view returns (bytes32) {\\n        return keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(\\\"1\\\"),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    /// @dev Returns an EIP-712 encoding of structured data `structHash`.\\n    /// @param structHash The structured data to be encoded and signed.\\n    /// @return A bytestring suitable for signing in accordance to EIP-712.\\n    function _hashTypedData(bytes32 structHash)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\\"\\\\x19\\\\x01\\\", _domainSeparator(), structHash)\\n        );\\n    }\\n\\n    /// @dev Returns the domain separator tied to the NFT contract.\\n    /// @return 256-bit domain separator tied to this contract.\\n    function _domainSeparator() internal view returns (bytes32) {\\n        if (block.chainid == _CHAIN_ID) {\\n            return _DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator();\\n        }\\n    }\\n\\n    /// @dev Sets the royalty information for all NFTs in the collection.\\n    /// @param receiver Address which will receive token royalties.\\n    /// @param royalties Royalties amount, in bips.\\n    function _setRoyalties(address receiver, uint96 royalties) internal {\\n        if (royalties > 10000) {\\n            revert RoyaltiesTooHigh();\\n        }\\n        if (receiver == address(0)) {\\n            revert ReceiverInvalid();\\n        }\\n        _royaltiesInfo = RoyaltiesInfo(receiver, royalties);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/erc721/ERC721Votable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// ERC721Votable.sol is a modification of Nouns DAO's ERC721Checkpointable.sol.\\n///\\n/// Copyright licensing is under the BSD-3-Clause license, as the above contract\\n/// is itself a modification of Compound Lab's Comp.sol (3-Clause BSD Licensed).\\n///\\n/// The following major changes were made from the original Nouns DAO contract:\\n/// - Numerous safety checks were removed (assumption is max supply < 2^32 - 1)\\n/// - Voting units were changed: `uint96` -> `uint32` (due to above assumption)\\n/// - `Checkpoint` struct was modified to pack 4 checkpoints per storage slot\\n/// - Signing was modularized to abstract away EIP-712 details (see ERC721.sol)\\n\\nimport \\\"../interfaces/Errors.sol\\\";\\nimport {IERC721Votable} from \\\"../interfaces/IERC721Votable.sol\\\";\\n\\nimport {ERC721} from \\\"./ERC721.sol\\\";\\n\\n/// @title Dopamine ERC-721 Voting Contract\\n/// @notice This voting contract allows any ERC-721 with a maximum supply of\\n///  under `type(uint32).max` which inherits the contract to be integrated under\\n///  its Governor Bravo governance framework. This contract is to be inherited\\n///  by the Dopamine ERC-721 membership tab, allowing tabs to act as governance\\n///  tokens to be used for proposals, voting, and membership delegation.\\ncontract ERC721Votable is ERC721, IERC721Votable {\\n\\n    /// @notice Maps an address to a list of all of its created checkpoints.\\n    mapping(address => Checkpoint[]) public checkpoints;\\n\\n    /// @dev Maps an address to its currently assigned voting delegate.\\n    mapping(address => address) internal _delegates;\\n\\n    /// @notice Typehash used for EIP-712 vote delegation (see `delegateBySig`).\\n    bytes32 internal constant DELEGATION_TYPEHASH = keccak256('Delegate(address delegator,address delegatee,uint256 nonce,uint256 expiry)');\\n\\n    /// @notice Instantiates a new ERC-721 voting contract.\\n    /// @param name_ The name of the ERC-721 NFT collection.\\n    /// @param symbol_ The abbreviated name of the ERC-721 NFT collection.\\n    /// @param maxSupply_ The maximum supply of the ERC-721 NFT collection.\\n    constructor(string memory name_, string memory symbol_, uint256 maxSupply_)\\n        ERC721(name_, symbol_, maxSupply_) {}\\n\\n    /// @inheritdoc IERC721Votable\\n    function delegate(address delegatee) external {\\n        _delegate(msg.sender, delegatee);\\n    }\\n\\n    /// @inheritdoc IERC721Votable\\n    function delegateBySig(\\n        address delegator,\\n        address delegatee,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        if (block.timestamp > expiry) {\\n            revert SignatureExpired();\\n        }\\n        address signatory = ecrecover(\\n            _hashTypedData(keccak256(\\n                abi.encode(\\n                    DELEGATION_TYPEHASH,\\n                    delegator,\\n                    delegatee,\\n                    nonces[delegator]++,\\n                    expiry\\n                )\\n            )),\\n            v,\\n            r,\\n            s\\n        );\\n        if (signatory == address(0) || signatory != delegator) {\\n            revert SignatureInvalid();\\n        }\\n        _delegate(signatory, delegatee);\\n    }\\n\\n    /// @inheritdoc IERC721Votable\\n    function totalCheckpoints(address voter) external view returns (uint256) {\\n        return checkpoints[voter].length;\\n    }\\n\\n    /// @inheritdoc IERC721Votable\\n    function currentVotes(address voter) external view returns (uint32) {\\n        uint256 numCheckpoints = checkpoints[voter].length;\\n        return numCheckpoints == 0 ?\\n            0 : checkpoints[voter][numCheckpoints - 1].votes;\\n    }\\n\\n    /// @inheritdoc IERC721Votable\\n    function priorVotes(address voter, uint256 blockNumber)\\n        external\\n        view\\n        returns (uint32)\\n    {\\n        if (blockNumber >= block.number) {\\n            revert BlockInvalid();\\n        }\\n\\n        uint256 numCheckpoints = checkpoints[voter].length;\\n        if (numCheckpoints == 0) {\\n            return 0;\\n        }\\n\\n        // Check common case of `blockNumber` being ahead of latest checkpoint.\\n        if (checkpoints[voter][numCheckpoints - 1].fromBlock <= blockNumber) {\\n            return checkpoints[voter][numCheckpoints - 1].votes;\\n        }\\n\\n        // Check case of `blockNumber` being behind first checkpoint (0 votes).\\n        if (checkpoints[voter][0].fromBlock > blockNumber) {\\n            return 0;\\n        }\\n\\n        // Run binary search to find 1st checkpoint at or before `blockNumber`.\\n        uint256 lower = 0;\\n        uint256 upper = numCheckpoints - 1;\\n        while (upper > lower) {\\n            uint256 center = upper - (upper - lower) / 2;\\n            Checkpoint memory cp = checkpoints[voter][center];\\n            if (cp.fromBlock == blockNumber) {\\n                return cp.votes;\\n            } else if (cp.fromBlock < blockNumber) {\\n                lower = center;\\n            } else {\\n                upper = center - 1;\\n            }\\n        }\\n        return checkpoints[voter][lower].votes;\\n    }\\n\\n    /// @inheritdoc IERC721Votable\\n    function delegates(address delegator) public view returns (address) {\\n        address current = _delegates[delegator];\\n        return current == address(0) ? delegator : current;\\n    }\\n\\n    /// @notice Delegate voting power of `delegator` to `delegatee`.\\n    /// @param delegator The address of the delegator.\\n    /// @param delegatee The address of the delegatee.\\n    function _delegate(address delegator, address delegatee) internal {\\n        if (delegatee == address(0)) {\\n            delegatee = delegator;\\n        }\\n\\n        address currentDelegate = delegates(delegator);\\n        uint256 amount = balanceOf[delegator];\\n\\n        _delegates[delegator] = delegatee;\\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\\n\\n        _transferDelegates(currentDelegate, delegatee, amount);\\n    }\\n\\n    /// @notice Transfer `amount` voting power from `srcRep` to `dstRep`.\\n    /// @param srcRep The delegate whose votes are being transferred away from.\\n    /// @param dstRep The delegate who is being transferred new votes.\\n    /// @param amount The number of votes being transferred.\\n    function _transferDelegates(\\n        address srcRep,\\n        address dstRep,\\n        uint256 amount\\n    ) internal {\\n        if (srcRep == dstRep || amount == 0) {\\n            return;\\n        }\\n\\n        if (srcRep != address(0)) {\\n            (uint256 oldVotes, uint256 newVotes) =\\n                _writeCheckpoint(\\n                    checkpoints[srcRep],\\n                    _sub,\\n                    amount\\n                );\\n            emit DelegateVotesChanged(srcRep, oldVotes, newVotes);\\n        }\\n\\n        if (dstRep != address(0)) {\\n            (uint256 oldVotes, uint256 newVotes) =\\n                _writeCheckpoint(\\n                    checkpoints[dstRep],\\n                    _add,\\n                    amount\\n                );\\n            emit DelegateVotesChanged(dstRep, oldVotes, newVotes);\\n        }\\n    }\\n\\n    /// @notice Override pre-transfer hook to account for voting power transfer.\\n    /// @dev By design, a governance NFT corresponds to a single voting unit.\\n    /// @param from The address from which the gov NFT is being transferred.\\n    /// @param to The receiving address of the gov NFT.\\n    /// @param id The identifier of the gov NFT being transferred.\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, id);\\n        _transferDelegates(delegates(from), delegates(to), 1);\\n    }\\n\\n    /// @notice Adds a new checkpoint to `ckpts` by performing `op` of amount\\n    ///  `delta` on the last known checkpoint of `ckpts` (if it exists).\\n    /// @param ckpts Storage pointer to the Checkpoint array being modified\\n    /// @param op Binary operator, either add or subtract.\\n    /// @param delta Amount in voting units to be added to or subtracted from.\\n    function _writeCheckpoint(\\n        Checkpoint[] storage ckpts,\\n        function(uint256, uint256) view returns (uint256) op,\\n        uint256 delta\\n    ) private returns (uint256 oldVotes, uint256 newVotes) {\\n        uint256 numCheckpoints = ckpts.length;\\n        oldVotes = numCheckpoints == 0 ? 0 : ckpts[numCheckpoints - 1].votes;\\n        newVotes = op(oldVotes, delta);\\n\\n        if ( // If latest checkpoint belonged to current block, just reassign.\\n             numCheckpoints > 0 &&\\n            ckpts[numCheckpoints - 1].fromBlock == block.number\\n        ) {\\n            ckpts[numCheckpoints - 1].votes = _safe32(newVotes);\\n        } else { // Otherwise, a new Checkpoint must be created.\\n            ckpts.push(Checkpoint({\\n                fromBlock: _safe32(block.number),\\n                votes: _safe32(newVotes)\\n            }));\\n        }\\n    }\\n\\n    /// @notice Safely downcasts a uint256 `n` into a uint32.\\n    function _safe32(uint256 n) private  pure returns (uint32) {\\n        if (n > type(uint32).max) {\\n            revert Uint32ConversionInvalid();\\n        }\\n        return uint32(n);\\n    }\\n\\n    /// @notice Binary operator for adding operand `a` to operand `b`.\\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /// @notice Binary operator for subtracting operand `b` from operand `a`.\\n    function _sub(uint256 a, uint256 b) private pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IDopamineTabEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title Dopamine Membership Tab Events Interface\\ninterface IDopamineTabEvents {\\n\\n    /// @notice Emits when the Dopamine tab base URI is set to `baseUri`.\\n    /// @param baseUri The base URI of the Dopamine tab contract, as a string.\\n    event BaseURISet(string baseUri);\\n\\n    /// @notice Emits when a new drop is created by the Dopamine tab admin.\\n    /// @param dropId The id of the newly created drop.\\n    /// @param startIndex The id of the first tabincluded in the drop.\\n    /// @param dropSize The number of tabs to distribute in the drop.\\n    /// @param allowlistSize The number of allowlisted tabs in the drop.\\n    /// @param allowlist A merkle root of the included address-tab pairs.\\n    /// @param provenanceHash SHA-256 hash of combined image hashes in the drop.\\n    event DropCreated(\\n        uint256 indexed dropId,\\n        uint256 startIndex,\\n        uint256 dropSize,\\n        uint256 allowlistSize,\\n        bytes32 allowlist,\\n        bytes32 provenanceHash\\n    );\\n\\n    /// @notice Emits when a new drop delay `dropDelay` is set.\\n    /// @param dropDelay The new drop delay to set, in seconds.\\n    event DropDelaySet(uint256 dropDelay);\\n\\n    /// @notice Emits when a new drop size `dropSize` is set.\\n    /// @param dropId The id of the queried drop.\\n    /// @param provenanceHash The drop collection provenance hash.\\n    /// @param allowlist Merkle root of drop's allowlisted address-tab pairs.\\n    event DropUpdated(uint256 indexed dropId, bytes32 provenanceHash, bytes32 allowlist);\\n\\n    /// @notice Emits when the drop of id `id` has its URI set to `dropUr1`.\\n    /// @param id  The id of the drop whose URI was set.\\n    /// @param dropUri The metadata URI of the drop, as a string.\\n    event DropURISet(uint256 indexed id, string dropUri);\\n\\n    /// @notice Emits when a new pending admin `pendingAdmin` is set.\\n    /// @param pendingAdmin The new address of the pending admin that was set.\\n    event PendingAdminSet(address pendingAdmin);\\n\\n    /// @notice Emits when minter is changed from `oldMinter` to `newMinter`.\\n    /// @param oldMinter The address of the previous minter.\\n    /// @param newMinter The address of the new minter.\\n    event MinterChanged(address indexed oldMinter, address indexed newMinter);\\n\\n    /// @notice Emits when admin is changed from `oldAdmin` to `newAdmin`.\\n    /// @param oldAdmin The address of the previous admin.\\n    /// @param newAdmin The address of the new admin.\\n    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);\\n\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC2981.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title Interface for the ERC-2981 royalties standard.\\ninterface IERC2981 {\\n\\n/// @notice RoyaltiesInfo stores token royalties information.\\nstruct RoyaltiesInfo {\\n\\n    /// @notice The address to which royalties will be directed.\\n    address receiver;\\n\\n    /// @notice The royalties amount, in bips.\\n    uint96 royalties;\\n\\n}\\n\\n    /// @notice Returns the address to which royalties are received along with\\n    ///  the royalties amount to be paid to them for a given sale price.\\n    /// @param id The id of the NFT being queried for royalties information.\\n    /// @param salePrice The sale price of the NFT, in some unit of exchange.\\n    /// @return receiver The address of the royalties receiver.\\n    /// @return royaltyAmount The royalty payment to be made given `salePrice`.\\n    function royaltyInfo(\\n        uint256 id,\\n        uint256 salePrice\\n    ) external view returns (address receiver, uint256 royaltyAmount);\\n\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721Votable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\nimport \\\"./IERC721VotableEvents.sol\\\";\\n\\n/// @title Dopamine ERC-721 Voting Contract Interface\\ninterface IERC721Votable is IERC721VotableEvents {\\n\\n    /// @notice Checkpoints hold the vote balance of addresses at given blocks.\\n    struct Checkpoint {\\n\\n        /// @notice The block number that the checkpoint was created.\\n        uint32 fromBlock;\\n\\n        /// @notice The assigned voting balance.\\n        uint32 votes;\\n\\n    }\\n\\n    /// @notice Delegate assigned votes to `msg.sender` to `delegatee`.\\n    /// @param delegatee Address of the delegatee being delegated to.\\n    function delegate(address delegatee) external;\\n\\n    /// @notice Delegate to `delegatee` on behalf of `delegator` via signature.\\n    /// @dev Refer to EIP-712 on signature and hashing details. This function\\n    ///  will revert if the provided signature is invalid or has expired.\\n    /// @param delegator The address to perform delegation on behalf of.\\n    /// @param delegatee The address being delegated to.\\n    /// @param expiry The timestamp at which this signature is set to expire.\\n    /// @param v Transaction signature recovery identifier.\\n    /// @param r Transaction signature output component #1.\\n    /// @param s Transaction signature output component #2.\\n    function delegateBySig(\\n        address delegator,\\n        address delegatee,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /// @notice Get the total number of checkpoints created for address `voter`.\\n    /// @param voter Address of the voter being queried.\\n    /// @return The number of checkpoints tied to `voter`.\\n    function totalCheckpoints(address voter) external view returns (uint256);\\n\\n    /// @notice Retrieves the voting weight `votes` and block `fromBlock`\\n    ///  corresponding to the checkpoint at index `index` of address `voter`.\\n    /// @param voter The address whose checkpoint we want to query.\\n    /// @param index The index to query among the voter's list of checkpoints.\\n    /// @return fromBlock The block number that the checkpoint was created.\\n    /// @return votes The voting balance assigned to the queried checkpoint.\\n    function checkpoints(address voter, uint256 index)\\n        external returns (uint32 fromBlock, uint32 votes);\\n\\n    /// @notice Get the current number of votes allocated for address `voter`.\\n    /// @param voter The address of the voter being queried.\\n    /// @return The number of votes currently tied to address `voter`.\\n    function currentVotes(address voter) external view returns (uint32);\\n\\n    /// @notice Get number of votes for `voter` at block number `blockNumber`.\\n    /// @param voter Address of the voter being queried.\\n    /// @param blockNumber Block number to tally votes from.\\n    /// @dev This function reverts if the current or future block is specified.\\n    /// @return The total tallied votes of `voter` at `blockNumber`.\\n    function priorVotes(address voter, uint256 blockNumber)\\n        external view returns (uint32);\\n\\n    /// @notice Retrieves the currently assigned delegate of `delegator`.\\n    /// @dev Having no delegate assigned indicates self-delegation.\\n    /// @param delegator The address of the delegator.\\n    /// @return Assigned delegate address if it exists, `delegator` otherwise.\\n    function delegates(address delegator) external view returns (address);\\n\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC721VotableEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity ^0.8.13;\\n\\n////////////////////////////////////////////////////////////////////////////////\\n///              \u2591\u2592\u2588\u2580\u2580\u2584\u2591\u2588\u2580\u2580\u2588\u2591\u2592\u2588\u2580\u2580\u2588\u2591\u2588\u2580\u2580\u2584\u2591\u2592\u2588\u2580\u2584\u2580\u2588\u2591\u2584\u2588\u2591\u2591\u2592\u2588\u2584\u2591\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2588\u2584\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2588\u2592\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2591\u2588\u2592\u2591\u2592\u2588\u2592\u2588\u2592\u2588\u2591\u2592\u2588\u2580\u2580\u2580              ///\\n///              \u2591\u2592\u2588\u2584\u2584\u2588\u2591\u2588\u2584\u2584\u2588\u2591\u2592\u2588\u2591\u2591\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2592\u2588\u2591\u2591\u2592\u2588\u2591\u2584\u2588\u2584\u2591\u2592\u2588\u2591\u2591\u2580\u2588\u2591\u2592\u2588\u2584\u2584\u2584              ///\\n////////////////////////////////////////////////////////////////////////////////\\n\\n/// @title Dopamine ERC-721 Voting Contract Events Interface\\ninterface IERC721VotableEvents {\\n\\n    /// @notice Emits when address `delegator` has its delegate address changed\\n    ///  from `fromDelegate` to `toDelegate` (even if they're the same address).\\n    /// @param delegator Address whose delegate has changed.\\n    /// @param fromDelegate The original delegate of the delegator.\\n    /// @param toDelegate The new delegate of the delegator.\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate\\n    );\\n\\n    /// @notice Emits when `delegate` votes moves from `oldVotes` to `newVotes`.\\n    /// @param delegate Address of the delegate whose voting weight changed.\\n    /// @param oldVotes The old voting weight assigned to the delegator.\\n    /// @param newVotes The new voting weight assigned to the delegator.\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    );\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"src/=src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"minter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"proxyRegistry_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dropDelay_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxSupply_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AdminOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BlockInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ClaimInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropAllowlistOverCapacity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropDelayInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropImmutable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropMaxCapacity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropNonExistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropOngoing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropSizeInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropStartInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DropTooEarly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinterOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OwnerInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PendingAdminOnly\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ProofInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReceiverInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SafeTransferUnsupported\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SenderUnauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SupplyMaxCapacity\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenAlreadyMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenNonExistent\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Uint32ConversionInvalid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"baseUri\",\"type\":\"string\"}],\"name\":\"BaseURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldVotes\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVotes\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allowlistSize\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"allowlist\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"provenanceHash\",\"type\":\"bytes32\"}],\"name\":\"DropCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dropDelay\",\"type\":\"uint256\"}],\"name\":\"DropDelaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"dropUri\",\"type\":\"string\"}],\"name\":\"DropURISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"provenanceHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"allowlist\",\"type\":\"bytes32\"}],\"name\":\"DropUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldMinter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"PendingAdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_AL_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DROP_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_DROP_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DROP_DELAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_DROP_SIZE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"checkpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"votes\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dropSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"provenanceHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"allowlistSize\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"allowlist\",\"type\":\"bytes32\"}],\"name\":\"createDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"currentVotes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"delegateBySig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dropAllowlist\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropEndIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"dropId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dropProvenanceHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dropURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"priorVotes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyRegistry\",\"outputs\":[{\"internalType\":\"contract IOpenSeaProxyRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newDropDelay\",\"type\":\"uint256\"}],\"name\":\"setDropDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setDropURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newPendingAdmin\",\"type\":\"address\"}],\"name\":\"setPendingAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"totalCheckpoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dropId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"provenanceHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"allowlist\",\"type\":\"bytes32\"}],\"name\":\"updateDrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DopamineTab", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000b76e9212fc7ef34d499c5557b2f1c8c516e2eae1000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c10000000000000000000000000000000000000000000000000000000000093a80000000000000000000000000000000000000000000000000000000000000270f000000000000000000000000000000000000000000000000000000000000002768747470733a2f2f6170692e646f70616d696e652e78797a2f746162732f6d657461646174612f00000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}