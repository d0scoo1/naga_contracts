{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/VotingBalanceV2Gauges.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\n\\r\\nimport \\\"./interfaces/ILockedCvx.sol\\\";\\r\\n\\r\\ncontract VotingBalanceV2Gauges{\\r\\n\\r\\n    address public constant oldlocker = address(0xD18140b4B819b895A3dba5442F959fA44994AF50);\\r\\n    address public constant locker = address(0x72a19342e8F1838460eBFCCEf09F6585e32db86E);\\r\\n    uint256 public constant rewardsDuration = 86400 * 7;\\r\\n    uint256 public constant lockDuration = rewardsDuration * 17;\\r\\n\\r\\n    bool public UseOldLocker = true;\\r\\n    address public constant owner = address(0xa3C5A1e09150B75ff251c1a7815A07182c3de2FB);\\r\\n\\r\\n    constructor() public {\\r\\n    }\\r\\n\\r\\n    function setUseOldLocker(bool _use) external{\\r\\n        require(msg.sender == owner, \\\"!auth\\\");\\r\\n\\r\\n        UseOldLocker = _use;\\r\\n    }\\r\\n\\r\\n    function balanceOf(address _account) external view returns(uint256){\\r\\n\\r\\n        //compute to find previous epoch\\r\\n        uint256 currentEpoch = block.timestamp / rewardsDuration * rewardsDuration;\\r\\n        uint256 epochindex = ILockedCvx(locker).epochCount() - 1;\\r\\n\\r\\n        //there may or may not have been a checkpoint in the new epoch\\r\\n        //thus get date of latest epoch and compare to block.timestamp\\r\\n        //if epoch.date >= current epoch then there was a checkpoint and need to move index back to get prev\\r\\n        (, uint32 _date) = ILockedCvx(locker).epochs(epochindex);\\r\\n        if(_date >= currentEpoch){\\r\\n            //if end date is already the current epoch,  minus 1 to get the previous\\r\\n            epochindex--;\\r\\n        }\\r\\n\\r\\n        //check again because new locker has an extra epoch for the following week\\r\\n        // note: the epochindex-- above can not be -= 2 because there may have been 0 locks for a given week\\r\\n        //       thus best to check one at a time\\r\\n        // length -1 = next\\r\\n        // length -2 = current\\r\\n        // length -3 = previous\\r\\n        (, _date) = ILockedCvx(locker).epochs(epochindex);\\r\\n        if(_date >= currentEpoch){\\r\\n            //if end date is already the current epoch,  minus 1 to get the previous\\r\\n            epochindex--;\\r\\n        }\\r\\n\\r\\n        //get balances of previous epoch\\r\\n        uint256 balanceAtPrev = ILockedCvx(locker).balanceAtEpochOf(epochindex, _account);\\r\\n\\r\\n        //get pending\\r\\n        uint256 pending = ILockedCvx(locker).pendingLockAtEpochOf(epochindex, _account);\\r\\n\\r\\n        //if using old locker for grace period\\r\\n        if(UseOldLocker){\\r\\n            //check if tokens have not been withdrawn yet\\r\\n            if(ILockedCvx(oldlocker).lockedBalanceOf(_account) > 0){\\r\\n                uint256 eindex = ILockedCvx(oldlocker).epochCount() - 1;\\r\\n                (, uint32 _edate) = ILockedCvx(oldlocker).epochs(eindex);\\r\\n                if(_edate >= currentEpoch){\\r\\n                    //if end date is already the current epoch,  minus 1 to get the previous\\r\\n                    eindex--;\\r\\n                }\\r\\n                //add to current balance\\r\\n                pending += ILockedCvx(oldlocker).balanceAtEpochOf(eindex, _account);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return balanceAtPrev + pending;\\r\\n    }\\r\\n\\r\\n    function totalSupply() view external returns(uint256){\\r\\n        return ILockedCvx(locker).totalSupply();\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"/contracts/interfaces/ILockedCvx.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.6.12;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface ILockedCvx{\\r\\n     struct LockedBalance {\\r\\n        uint112 amount;\\r\\n        uint112 boosted;\\r\\n        uint32 unlockTime;\\r\\n    }\\r\\n\\r\\n    function lock(address _account, uint256 _amount, uint256 _spendRatio) external;\\r\\n    function processExpiredLocks(bool _relock, uint256 _spendRatio, address _withdrawTo) external;\\r\\n    function getReward(address _account, bool _stake) external;\\r\\n    function balanceAtEpochOf(uint256 _epoch, address _user) view external returns(uint256 amount);\\r\\n    function totalSupplyAtEpoch(uint256 _epoch) view external returns(uint256 supply);\\r\\n    function epochCount() external view returns(uint256);\\r\\n    function epochs(uint256 _id) external view returns(uint224,uint32);\\r\\n    function checkpointEpoch() external;\\r\\n    function balanceOf(address _account) external view returns(uint256);\\r\\n    function lockedBalanceOf(address _user) external view returns(uint256 amount);\\r\\n    function pendingLockOf(address _user) external view returns(uint256 amount);\\r\\n    function pendingLockAtEpochOf(uint256 _epoch, address _user) view external returns(uint256 amount);\\r\\n    function totalSupply() view external returns(uint256 supply);\\r\\n    function lockedBalances(\\r\\n        address _user\\r\\n    ) view external returns(\\r\\n        uint256 total,\\r\\n        uint256 unlockable,\\r\\n        uint256 locked,\\r\\n        LockedBalance[] memory lockData\\r\\n    );\\r\\n    function addReward(\\r\\n        address _rewardsToken,\\r\\n        address _distributor,\\r\\n        bool _useBoost\\r\\n    ) external;\\r\\n    function approveRewardDistributor(\\r\\n        address _rewardsToken,\\r\\n        address _distributor,\\r\\n        bool _approved\\r\\n    ) external;\\r\\n    function setStakeLimits(uint256 _minimum, uint256 _maximum) external;\\r\\n    function setBoost(uint256 _max, uint256 _rate, address _receivingAddress) external;\\r\\n    function setKickIncentive(uint256 _rate, uint256 _delay) external;\\r\\n    function shutdown() external;\\r\\n    function recoverERC20(address _tokenAddress, uint256 _tokenAmount) external;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"UseOldLocker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"locker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldlocker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_use\",\"type\":\"bool\"}],\"name\":\"setUseOldLocker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VotingBalanceV2Gauges", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}