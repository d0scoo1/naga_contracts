{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Progressive/ProgressiveArt.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ninterface IPerlinNoise {\\n  function noise2d(int256, int256) external view returns (int256);\\n}\\n\\ninterface IMnemonic {\\n  function random(uint256, uint256) external view returns (string[] memory);\\n}\\n\\ncontract ProgressiveArt is Ownable {\\n  IPerlinNoise perlinNoise;\\n  IMnemonic mnemonic;\\n\\n  string private _baseExternalURI;\\n  string private _metaDescription;\\n\\n  uint256 private constant FIX = 2**16;\\n  uint256 private constant SIZE = 30;\\n\\n  string[4] private MIX_MODES = [\\n    \\\"multiply\\\",\\n    \\\"color-dodge\\\",\\n    \\\"soft-light\\\",\\n    \\\"hard-light\\\"\\n  ];\\n  string[11] private FREQUENCIES = [\\n    \\\"0.5\\\",\\n    \\\"0.3\\\",\\n    \\\"0.1\\\",\\n    \\\"0.08\\\",\\n    \\\"0.07\\\",\\n    \\\"0.06\\\",\\n    \\\"0.05\\\",\\n    \\\"0.04\\\",\\n    \\\"0.03\\\",\\n    \\\"0.02\\\",\\n    \\\"0.01\\\"\\n  ];\\n  string[10] private BG_COLORS = [\\n    \\\"FAFAFA\\\",\\n    \\\"F5F5F5\\\",\\n    \\\"EEEEEE\\\",\\n    \\\"E0E0E0\\\",\\n    \\\"BDBDBD\\\",\\n    \\\"9E9E9E\\\",\\n    \\\"757575\\\",\\n    \\\"616161\\\",\\n    \\\"424242\\\",\\n    \\\"212121\\\"\\n  ];\\n\\n  constructor(\\n    string memory metaDescription_,\\n    address noiseAddress_,\\n    address mnemonicAddress_\\n  ) {\\n    _metaDescription = metaDescription_;\\n    perlinNoise = IPerlinNoise(noiseAddress_);\\n    mnemonic = IMnemonic(mnemonicAddress_);\\n  }\\n\\n  function random(uint256 tokenId, string memory keyPrefix)\\n    internal\\n    pure\\n    returns (uint256)\\n  {\\n    return\\n      uint256(\\n        keccak256(abi.encodePacked(keyPrefix, Strings.toString(tokenId)))\\n      );\\n  }\\n\\n  function getBgColor(uint256 _seed) private view returns (string memory) {\\n    return BG_COLORS[random(_seed, \\\"bg\\\") % 10];\\n  }\\n\\n  function getTitle(uint256 _seed) public view returns (string memory) {\\n    string[] memory words = mnemonic.random(_seed, 2);\\n    return string(abi.encodePacked(words[0], \\\" \\\", words[1]));\\n  }\\n\\n  function getColors(uint256 _seed)\\n    private\\n    pure\\n    returns (string[10] memory colors)\\n  {\\n    string memory key = string(abi.encodePacked(_seed, \\\"c\\\"));\\n    uint256 ct = random(_seed, \\\"ct\\\") % 3;\\n    uint256 light = 30 + (random(_seed, \\\"cl\\\") % 40);\\n\\n    uint256 primary = random(0, key) % 361;\\n    uint256 step = 5 + (random(_seed, \\\"cs\\\") % 15);\\n\\n    for (uint256 i = 0; i < 10; i++) {\\n      if (ct == 0) {\\n        colors[i] = string(\\n          abi.encodePacked(\\n            \\\"hsl(\\\",\\n            Strings.toString((primary + step * i) % 361),\\n            \\\",100%,\\\",\\n            Strings.toString(light),\\n            \\\"%)\\\"\\n          )\\n        );\\n      } else if (ct == 1) {\\n        colors[i] = string(\\n          abi.encodePacked(\\n            \\\"hsl(\\\",\\n            Strings.toString(random(i, key) % 361),\\n            \\\",100%,\\\",\\n            Strings.toString(light),\\n            \\\"%)\\\"\\n          )\\n        );\\n      } else {\\n        colors[i] = string(\\n          abi.encodePacked(\\n            \\\"hsl(\\\",\\n            Strings.toString(primary),\\n            \\\",100%,\\\",\\n            Strings.toString(10 + i * 8),\\n            \\\"%)\\\"\\n          )\\n        );\\n      }\\n    }\\n  }\\n\\n  function merge(string[SIZE] memory arr) private pure returns (string memory) {\\n    string[3] memory buffers;\\n\\n    for (uint256 i; i < 3; i++) {\\n      buffers[i] = string(\\n        abi.encodePacked(\\n          arr[i * 10],\\n          arr[i * 10 + 1],\\n          arr[i * 10 + 2],\\n          arr[i * 10 + 3],\\n          arr[i * 10 + 4],\\n          arr[i * 10 + 5],\\n          arr[i * 10 + 6],\\n          arr[i * 10 + 7],\\n          arr[i * 10 + 8],\\n          arr[i * 10 + 9]\\n        )\\n      );\\n    }\\n\\n    return string(abi.encodePacked(buffers[0], buffers[1], buffers[2]));\\n  }\\n\\n  function map(bytes32 _rand)\\n    private\\n    view\\n    returns (\\n      int256[SIZE][SIZE] memory arr,\\n      int256 max,\\n      int256 min\\n    )\\n  {\\n    int256 n;\\n    uint256 step = 150 + (uint256(_rand) % 19850);\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    uint256 xPos = uint256(_rand) % FIX;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    uint256 yPos = uint256(_rand) % FIX;\\n    for (uint256 x = 0; x < SIZE; x++) {\\n      for (uint256 y = 0; y < SIZE; y++) {\\n        n =\\n          (perlinNoise.noise2d(\\n            int256(xPos + x * step),\\n            int256(yPos + y * step)\\n          ) * 1000) /\\n          65536 +\\n          1000;\\n        if (max == 0 || n > max) max = n;\\n        if (min == 0 || n < min) min = n;\\n        arr[uint256(y)][uint256(x)] = n;\\n      }\\n    }\\n  }\\n\\n  function dot(\\n    string memory sx,\\n    string memory sy,\\n    uint256 z,\\n    settingContext memory params\\n  ) private pure returns (string memory) {\\n    if (params.dotType == 0) {\\n      return\\n        string(\\n          abi.encodePacked(\\n            \\\"<rect x='\\\",\\n            sx,\\n            \\\"' y='\\\",\\n            sy,\\n            \\\"' class='r c\\\",\\n            Strings.toString(z),\\n            \\\"'/>\\\"\\n          )\\n        );\\n    } else {\\n      return\\n        string(\\n          abi.encodePacked(\\n            \\\"<circle cx='\\\",\\n            sx,\\n            \\\"' cy='\\\",\\n            sy,\\n            \\\"' class='c c\\\",\\n            Strings.toString(z),\\n            \\\"'/>\\\"\\n          )\\n        );\\n    }\\n  }\\n\\n  struct plotContext {\\n    string sy;\\n    uint256 px;\\n    uint256 py;\\n    uint256 z;\\n    string[SIZE] rows;\\n    string[SIZE] cols;\\n  }\\n\\n  function dots(\\n    int256[SIZE][SIZE] memory arr,\\n    int256 max,\\n    int256 min,\\n    settingContext memory params\\n  ) private pure returns (string memory) {\\n    plotContext memory plot;\\n\\n    int256 s = (max - min) / 9;\\n    if (s == 0) {\\n      s = 1;\\n    }\\n\\n    for (uint256 y = 0; y < SIZE; y++) {\\n      plot.sy = Strings.toString(uint256(y * 8));\\n      if (params.mirrorType == 1 && 14 < y) {\\n        plot.py = SIZE - 1 - y;\\n      } else {\\n        plot.py = uint256(y);\\n      }\\n      for (uint256 x = 0; x < SIZE; x++) {\\n        if ((params.mirrorType == 1 || params.mirrorType == 2) && 14 < x) {\\n          plot.px = SIZE - 1 - x;\\n        } else {\\n          plot.px = uint256(x);\\n        }\\n\\n        {\\n          if (\\n            params.frameType == 1 &&\\n            (plot.py == 0 ||\\n              plot.py == SIZE - 1 ||\\n              plot.px == 0 ||\\n              plot.px == SIZE - 1)\\n          ) {\\n            plot.z = 0;\\n          } else {\\n            plot.z = uint256((arr[plot.px][plot.py] - min) / s);\\n          }\\n          if (plot.z < 0) {\\n            plot.z = 0;\\n          }\\n          if (9 < plot.z) {\\n            plot.z = 9;\\n          }\\n        }\\n\\n        plot.cols[uint256(x)] = dot(\\n          Strings.toString(uint256(x * 8)),\\n          plot.sy,\\n          plot.z,\\n          params\\n        );\\n      }\\n\\n      plot.rows[uint256(y)] = merge(plot.cols);\\n    }\\n    return merge(plot.rows);\\n  }\\n\\n  function polygon(\\n    uint256 x,\\n    uint256 y,\\n    bool top,\\n    string memory bgColor\\n  ) private pure returns (string memory) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"<polygon points='0,\\\",\\n          Strings.toString((y + 1) * 8),\\n          \\\" \\\",\\n          Strings.toString(x * 8),\\n          \\\",\\\",\\n          Strings.toString((y + 1) * 8),\\n          \\\" \\\",\\n          Strings.toString(x * 8),\\n          \\\",\\\",\\n          Strings.toString(y * 8),\\n          \\\" 240,\\\",\\n          Strings.toString(y * 8),\\n          top ? \\\" 240,0 0,0\\\" : \\\" 240,240 0,240\\\",\\n          \\\"' fill='#\\\",\\n          bgColor,\\n          \\\"' />\\\"\\n        )\\n      );\\n  }\\n\\n  struct settingContext {\\n    int256[SIZE][SIZE] arr;\\n    int256 max;\\n    int256 min;\\n    uint256 mirrorType;\\n    uint256 frameType;\\n    uint256 noiseType;\\n    uint256 filterType;\\n    uint256 filterMode;\\n    uint256 filterVolume;\\n    uint256 frequencyX;\\n    uint256 frequencyY;\\n    uint256 dotType;\\n    string[10] colors;\\n    string dotStr;\\n    string bgColor;\\n    uint256 p;\\n    uint256 pp;\\n    uint256 endBlur;\\n    uint256 endBlurX;\\n    uint256 endBlurY;\\n    uint256 endSharp;\\n    uint256 endSharpX;\\n    uint256 endSharpY;\\n    uint256 endBlurP;\\n    uint256 startSharpP;\\n  }\\n\\n  function SVG(uint256 _time, uint256 _seed)\\n    public\\n    view\\n    returns (string memory)\\n  {\\n    settingContext memory params;\\n\\n    bytes32 _rand = keccak256(abi.encodePacked(\\\"Progressive\\\", _seed));\\n    _rand = keccak256(abi.encodePacked(_rand));\\n\\n    params.endBlurP = 40 + (uint256(_rand) % 30);\\n    params.startSharpP = 20 + (uint256(_rand) % 20);\\n\\n    params.p = toRate(_time);\\n    params.pp = SIZE * SIZE * params.p;\\n    params.endBlur = params.pp / params.endBlurP;\\n    params.endBlurX = params.endBlur % SIZE;\\n    params.endBlurY = params.endBlur / SIZE;\\n    params.p = params.p <= params.startSharpP\\n      ? 0\\n      : params.p - params.startSharpP;\\n    params.pp = SIZE * SIZE * params.p;\\n    params.endSharp = params.pp / (100 - params.startSharpP);\\n    params.endSharpX = params.endSharp % SIZE;\\n    params.endSharpY = params.endSharp / SIZE;\\n\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.mirrorType = uint256(_rand) % 3;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.frameType = uint256(_rand) % 2;\\n    params.frequencyX = uint256(_rand) % 11;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.dotType = uint256(_rand) % 5 == 0 ? 1 : 0;\\n    params.frequencyY = uint256(_rand) % 11;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.noiseType = uint256(_rand) % 4;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.filterType = uint256(_rand) % 3 == 0 ? 1 : 0;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.filterMode = uint256(_rand) % 2;\\n    _rand = keccak256(abi.encodePacked(_rand));\\n    params.filterVolume = params.filterType == 1 ? uint256(_rand) % 500 : 0;\\n\\n    (params.arr, params.max, params.min) = map(_rand);\\n    params.colors = getColors(_seed);\\n    params.bgColor = getBgColor(_seed);\\n    params.dotStr = dots(params.arr, params.max, params.min, params);\\n\\n    string memory pallete;\\n    {\\n      pallete = string(\\n        abi.encodePacked(\\n          \\\".c0{fill:\\\",\\n          params.colors[0],\\n          \\\"}.c1{fill:\\\",\\n          params.colors[1],\\n          \\\"}.c2{fill:\\\",\\n          params.colors[2],\\n          \\\"}.c3{fill:\\\",\\n          params.colors[3],\\n          \\\"}.c4{fill:\\\",\\n          params.colors[4],\\n          \\\"}.c5{fill:\\\",\\n          params.colors[5],\\n          \\\"}.c6{fill:\\\",\\n          params.colors[6],\\n          \\\"}.c7{fill:\\\",\\n          params.colors[7],\\n          \\\"}.c8{fill:\\\",\\n          params.colors[8],\\n          \\\"}.c9{fill:\\\",\\n          params.colors[9],\\n          \\\"}\\\"\\n        )\\n      );\\n    }\\n\\n    string memory filter;\\n    {\\n      filter = string(\\n        abi.encodePacked(\\n          \\\"<filter id='s' class='m'><feTurbulence type='\\\",\\n          params.filterMode == 0 ? \\\"fractalNoise\\\" : \\\"turbulence\\\",\\n          \\\"' id='turbulence' baseFrequency='\\\",\\n          FREQUENCIES[params.frequencyX],\\n          \\\" \\\",\\n          FREQUENCIES[params.frequencyY],\\n          \\\"' numOctaves='3' result='noise' seed='\\\",\\n          Strings.toString(_seed % 1000),\\n          \\\"' /><feDisplacementMap id='displacement' in='SourceGraphic' in2='noise' scale='\\\",\\n          Strings.toString(params.filterVolume),\\n          \\\"' /></filter>\\\",\\n          \\\"<filter id='b' x='0' y='0'><feGaussianBlur in='SourceGraphic' stdDeviation='4' result='smoothed' /></filter>\\\",\\n          \\\"<filter id='n'><feTurbulence baseFrequency='0.5' result='noise'/><feColorMatrix type='saturate' values='0.10'/><feBlend in='SourceGraphic' in2='noise' mode='multiply'/></filter>\\\"\\n        )\\n      );\\n    }\\n\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"<svg width='720' height='720' preserveAspectRatio='xMinYMin meet' fill='none' viewBox='0 0 240 240' version='1.1' xmlns='http://www.w3.org/2000/svg'>\\\",\\n          \\\"<style>.r{width:8px;height:8px}.c{width:8px;height:8px;transform:translate(4px,4px);r:4px}.f{filter: url(#n); mix-blend-mode:\\\",\\n          MIX_MODES[params.noiseType],\\n          \\\"; opacity:0.5}.fn{filter: url(#s)}.g{filter: url(#b)}.m{x:0;y:0;width:100%;height:100%}\\\",\\n          pallete,\\n          \\\"</style>\\\",\\n          \\\"<symbol id='dots' viewBox='0 0 240 240'>\\\",\\n          params.dotStr,\\n          \\\"</symbol>\\\",\\n          filter,\\n          \\\"<clipPath id='c'>\\\",\\n          polygon(params.endSharpX, params.endSharpY, true, \\\"000000\\\"),\\n          \\\"</clipPath><rect class='m' fill='\\\",\\n          params.colors[0],\\n          \\\"' /><g class='g'><g class='fn'>\\\",\\n          \\\"<use href='#dots' />\\\",\\n          \\\"</g></g><g clip-path='url(#c)'><rect class='m' fill='\\\",\\n          params.colors[0],\\n          \\\"' /><g class='fn'>\\\",\\n          \\\"<use href='#dots' />\\\",\\n          \\\"</g><rect class='m f'/></g>\\\",\\n          polygon(params.endBlurX, params.endBlurY, false, params.bgColor),\\n          \\\"</svg>\\\"\\n        )\\n      );\\n  }\\n\\n  struct stateContext {\\n    uint256 tokenId;\\n    string svg;\\n    uint256 progress;\\n    uint256 time;\\n    uint256 price;\\n  }\\n\\n  function toRate(uint256 _time) private pure returns (uint256) {\\n    return _time >= 1 days ? 100 : (_time * 100) / 1 days;\\n  }\\n\\n  function setMetaDescription(string memory description) external onlyOwner {\\n    _metaDescription = description;\\n  }\\n\\n  function setBaseExternalURI(string memory URI) external onlyOwner {\\n    _baseExternalURI = URI;\\n  }\\n\\n  function getMetaData(\\n    uint256 _tokenId,\\n    uint256 _time,\\n    uint256 _seed\\n  ) private view returns (string memory) {\\n    string memory bg = getBgColor(_seed);\\n    string memory rate = Strings.toString(toRate(_time));\\n    return\\n      string(\\n        abi.encodePacked(\\n          '{\\\"name\\\":\\\"',\\n          getTitle(_seed),\\n          '\\\",\\\"description\\\":\\\"',\\n          _metaDescription,\\n          '\\\",\\\"image\\\":\\\"data:image/svg+xml;utf8,',\\n          SVG(_time, _seed),\\n          '\\\",\\\"external_url\\\":\\\"',\\n          _baseExternalURI,\\n          Strings.toString(_tokenId),\\n          '\\\",\\\"background_color\\\":\\\"',\\n          bg,\\n          '\\\",\\\"attributes\\\":[{\\\"trait_type\\\":\\\"Time\\\",\\\"value\\\":',\\n          Strings.toString(_time),\\n          '},{\\\"trait_type\\\":\\\"Progress\\\",\\\"value\\\":',\\n          rate,\\n          '},{\\\"trait_type\\\":\\\"Background\\\",\\\"value\\\":\\\"',\\n          bg,\\n          '\\\"},{\\\"trait_type\\\":\\\"Edition\\\",\\\"value\\\":\\\"',\\n          Strings.toString(_tokenId),\\n          '\\\"}]}'\\n        )\\n      );\\n  }\\n\\n  function tokenURI(\\n    uint256 _tokenId,\\n    uint256 _time,\\n    uint256 _seed\\n  ) external view returns (string memory) {\\n    return\\n      string(\\n        abi.encodePacked(\\n          \\\"data:application/json;utf8,\\\",\\n          getMetaData(_tokenId, _time, _seed)\\n        )\\n      );\\n  }\\n}\\n\\nlibrary Strings {\\n  function toString(uint256 value) internal pure returns (string memory) {\\n    // Inspired by OraclizeAPI's implementation - MIT licence\\n    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint256 temp = value;\\n    uint256 digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"metaDescription_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"noiseAddress_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"mnemonicAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"SVG\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"getTitle\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"URI\",\"type\":\"string\"}],\"name\":\"setBaseExternalURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"setMetaDescription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ProgressiveArt", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000e8ea5c616c55dc158da6b3ebc55d88c258fcd664000000000000000000000000760125dada432e83600b506700674dd20d11624f000000000000000000000000000000000000000000000000000000000000012750726f677265737369766520697320737570657220736c6f77204e4654206172742e20497420696d697461746573204a50454720696d616765206c6f6164696e6720756e646572206120736c6f77206e6574776f726b20746f206d616b6520796f75207468696e6b2061626f757420686f7720746f206465616c2077697468206172742e2049742074616b657320323420686f7572732066726f6d20746865206c617374206d696e7420746f20636f6d706c65746520746865206172742e20596f752063616e20616c736f206d696e74206120736e617073686f7420696e2070726f67726573732e2042757420696620736f6d656f6e65206d696e74732069742c207468652073616d65206172742077696c6c206e657665722061707065617220616761696e2e00000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}