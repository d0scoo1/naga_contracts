{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"details\": {\r\n        \"constantOptimizer\": true,\r\n        \"cse\": true,\r\n        \"deduplicate\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"peephole\": true,\r\n        \"yul\": true,\r\n        \"yulDetails\": {\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf\",\r\n          \"stackAllocation\": true\r\n        }\r\n      },\r\n      \"runs\": 2000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved[id] ||\\n                isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/Pirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\r\\nimport \\\"./ERC721.sol\\\";\\r\\nimport \\\"./interfaces/IPirates.sol\\\";\\r\\nimport \\\"./interfaces/ITPirates.sol\\\";\\r\\nimport \\\"./interfaces/IHPirates.sol\\\";\\r\\nimport \\\"./interfaces/IOrbitalBlockade.sol\\\";\\r\\nimport \\\"./interfaces/IRandomizer.sol\\\";\\r\\nimport \\\"./interfaces/IEON.sol\\\";\\r\\n\\r\\ncontract Pirates is IPirates, ERC721, Pausable {\\r\\n    struct LastWrite {\\r\\n        uint64 time;\\r\\n        uint64 blockNum;\\r\\n    }\\r\\n\\r\\n    event PirateNamed(uint256 indexed tokenId, string newName);\\r\\n    event PirateMinted(uint256 indexed tokenId);\\r\\n    event PirateStolen(uint256 indexed tokenId);\\r\\n\\r\\n    // tally of the number of pirates that have been minted\\r\\n    uint16 public override piratesMinted;\\r\\n\\r\\n    // an arbatrary counter to dish out IDs\\r\\n    uint16 public override minted;\\r\\n\\r\\n    // toggle naming\\r\\n    bool public namingActive;\\r\\n\\r\\n    // number of max pirates that can exist with the total minted to keep a 10:1 ratio\\r\\n\\r\\n    uint256 public constant MAX_PIRATES = 6000;\\r\\n\\r\\n    // cost to name\\r\\n    uint256 public constant costToName = 2000 ether; //2000 EON\\r\\n\\r\\n    // mapping from tokenId to a struct containing the colonist token's traits\\r\\n    mapping(uint256 => Pirate) public tokenTraitsPirate;\\r\\n\\r\\n    // mapping from tokenId to a stuct containing the honors pirates\\r\\n    mapping(uint256 => HPirates) public tokenTraitsHonors;\\r\\n    mapping(uint256 => bool) public isHonors;\\r\\n\\r\\n    // mapping from hashed(tokenTrait) to the tokenId it's associated with\\r\\n    // used to ensure there are no duplicates\\r\\n    mapping(uint256 => uint256) public existingCombinations;\\r\\n\\r\\n    // Mapping from token ID to name\\r\\n    mapping(uint256 => string) private _tokenName;\\r\\n\\r\\n    mapping(uint256 => bool) private _hasName;\\r\\n\\r\\n    // Mapping if certain name string has already been reserved\\r\\n    mapping(string => bool) private _nameReserved;\\r\\n\\r\\n    // list of probabilities for each trait type\\r\\n    uint8[][9] public rarities;\\r\\n    uint8[][9] public aliases;\\r\\n\\r\\n    // reference to the orbital for transfers without approval\\r\\n    IOrbitalBlockade public orbital;\\r\\n\\r\\n    // reference to Traits\\r\\n    ITPirates public traits;\\r\\n\\r\\n    // reference to honors traits\\r\\n    IHPirates public honorTraits;\\r\\n\\r\\n    //reference to Randomizer\\r\\n    IRandomizer public randomizer;\\r\\n\\r\\n    //referenve to EON\\r\\n    IEON public EON;\\r\\n\\r\\n    address public auth;\\r\\n\\r\\n      // address => used in allowing system communication between contracts\\r\\n    mapping(address => bool) private admins;\\r\\n\\r\\n    // Imperial Guild Treasury\\r\\n    address private imperialGuildTreasury;\\r\\n\\r\\n    /**\\r\\n     * instantiates contract and rarity tables\\r\\n     */\\r\\n    constructor() ERC721(\\\"ShatteredEon\\\", \\\"Pirates\\\") {\\r\\n        auth = msg.sender;\\r\\n        admins[msg.sender] = true;\\r\\n\\r\\n        //PIRATES\\r\\n        //sky\\r\\n        rarities[0] = [200, 200, 200, 200, 200, 255];\\r\\n        aliases[0] = [1, 2, 0, 4, 3, 5];\\r\\n        //cockpit\\r\\n        rarities[1] = [255];\\r\\n        aliases[1] = [0];\\r\\n        //base\\r\\n        rarities[2] = [\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            200,\\r\\n            200,\\r\\n            200,\\r\\n            200,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255\\r\\n        ];\\r\\n        aliases[2] = [\\r\\n            16,\\r\\n            17,\\r\\n            18,\\r\\n            19,\\r\\n            7,\\r\\n            6,\\r\\n            5,\\r\\n            4,\\r\\n            3,\\r\\n            2,\\r\\n            1,\\r\\n            0,\\r\\n            16,\\r\\n            17,\\r\\n            18,\\r\\n            19,\\r\\n            0,\\r\\n            1,\\r\\n            2,\\r\\n            3\\r\\n        ];\\r\\n        //engine\\r\\n        rarities[3] = [\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            100,\\r\\n            100,\\r\\n            100,\\r\\n            100,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            40\\r\\n        ];\\r\\n        aliases[3] = [\\r\\n            8,\\r\\n            9,\\r\\n            10,\\r\\n            11,\\r\\n            12,\\r\\n            13,\\r\\n            14,\\r\\n            15,\\r\\n            15,\\r\\n            14,\\r\\n            13,\\r\\n            12,\\r\\n            7,\\r\\n            6,\\r\\n            5,\\r\\n            4,\\r\\n            8,\\r\\n            9,\\r\\n            10,\\r\\n            11\\r\\n        ];\\r\\n        //nose\\r\\n        rarities[4] = [\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            120,\\r\\n            120,\\r\\n            120,\\r\\n            120,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            40\\r\\n        ];\\r\\n        aliases[4] = [\\r\\n            0,\\r\\n            1,\\r\\n            2,\\r\\n            3,\\r\\n            15,\\r\\n            14,\\r\\n            13,\\r\\n            12,\\r\\n            11,\\r\\n            10,\\r\\n            9,\\r\\n            8,\\r\\n            3,\\r\\n            2,\\r\\n            1,\\r\\n            0,\\r\\n            12,\\r\\n            13,\\r\\n            14,\\r\\n            15\\r\\n        ];\\r\\n        //wing\\r\\n        rarities[5] = [\\r\\n            120,\\r\\n            120,\\r\\n            120,\\r\\n            120,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            40,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            150,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255,\\r\\n            255\\r\\n        ];\\r\\n        aliases[5] = [\\r\\n            19,\\r\\n            18,\\r\\n            17,\\r\\n            16,\\r\\n            3,\\r\\n            2,\\r\\n            1,\\r\\n            0,\\r\\n            0,\\r\\n            1,\\r\\n            2,\\r\\n            3,\\r\\n            19,\\r\\n            18,\\r\\n            17,\\r\\n            16,\\r\\n            15,\\r\\n            14,\\r\\n            13,\\r\\n            12\\r\\n        ];\\r\\n        //weapon1\\r\\n        rarities[6] = [255, 150, 220, 220, 120, 30];\\r\\n        aliases[6] = [0, 0, 0, 0, 0, 0];\\r\\n        //weapon2\\r\\n        rarities[7] = [255, 150, 30, 100, 20, 200];\\r\\n        aliases[7] = [0, 0, 0, 0, 0, 0];\\r\\n        //rank\\r\\n        rarities[8] = [12, 160, 73, 255];\\r\\n        aliases[8] = [2, 3, 3, 3];\\r\\n    }\\r\\n\\r\\n    modifier requireContractsSet() {\\r\\n        require(\\r\\n            address(traits) != address(0) &&\\r\\n                address(orbital) != address(0) &&\\r\\n                address(randomizer) != address(0)\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwner() {\\r\\n        require(msg.sender == auth);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setContracts(\\r\\n        address _traits,\\r\\n        address _honorTraits,\\r\\n        address _orbital,\\r\\n        address _rand,\\r\\n        address _eon\\r\\n    ) external onlyOwner {\\r\\n        traits = ITPirates(_traits);\\r\\n        honorTraits = IHPirates(_honorTraits);\\r\\n        orbital = IOrbitalBlockade(_orbital);\\r\\n        randomizer = IRandomizer(_rand);\\r\\n        EON = IEON(_eon);\\r\\n    }\\r\\n\\r\\n    /*///////////////////////////////////////////////////////////////\\r\\n                    EXTERNAL\\r\\n    //////////////////////////////////////////////////////////////*/\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed)\\r\\n        external\\r\\n        override\\r\\n        whenNotPaused\\r\\n    {\\r\\n        require(admins[msg.sender], \\\"Only Admins\\\");\\r\\n        require(piratesMinted + 1 <= MAX_PIRATES, \\\"Pirate forces are full\\\");\\r\\n        minted++;\\r\\n        piratesMinted++;\\r\\n        generatePirate(minted, seed);\\r\\n        if (tx.origin != recipient && recipient != address(orbital)) {\\r\\n            // Stolen!\\r\\n            emit PirateStolen(minted);\\r\\n        }\\r\\n        _mint(recipient, minted);\\r\\n    }\\r\\n\\r\\n    function _mintHonors(address recipient, uint8 id)\\r\\n        external\\r\\n        whenNotPaused\\r\\n        onlyOwner\\r\\n    {\\r\\n        require(minted + 1 <= MAX_PIRATES, \\\"All Pirates Minted\\\");\\r\\n        minted++;\\r\\n        piratesMinted++;\\r\\n        generateHonors(minted, id);\\r\\n        _mint(recipient, minted);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Burn a token - any game logic should be handled before this function.\\r\\n     */\\r\\n    function burn(uint256 tokenId) external override whenNotPaused {\\r\\n        require(admins[msg.sender]);\\r\\n        require(ownerOf[tokenId] == tx.origin, \\\"not owner\\\");\\r\\n        _burn(tokenId);\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public override(ERC721, IPirates) {\\r\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\r\\n\\r\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\r\\n        // allow admin contracts to send without approval\\r\\n        if (!admins[msg.sender]) {\\r\\n            require(\\r\\n                msg.sender == from ||\\r\\n                    msg.sender == getApproved[id] ||\\r\\n                    isApprovedForAll[from][msg.sender],\\r\\n                \\\"NOT_AUTHORIZED\\\"\\r\\n            );\\r\\n        }\\r\\n        // Underflow of the sender's balance is impossible because we check for\\r\\n        // ownership above and the recipient's balance can't realistically overflow.\\r\\n        unchecked {\\r\\n            balanceOf[from]--;\\r\\n\\r\\n            balanceOf[to]++;\\r\\n        }\\r\\n\\r\\n        ownerOf[id] = to;\\r\\n\\r\\n        delete getApproved[id];\\r\\n\\r\\n        emit Transfer(from, to, id);\\r\\n    }\\r\\n\\r\\n    function generatePirate(uint256 tokenId, uint256 seed)\\r\\n        internal\\r\\n        returns (Pirate memory p)\\r\\n    {\\r\\n        p = selectPiTraits(seed);\\r\\n        if (existingCombinations[structToHashPi(p)] == 0) {\\r\\n            tokenTraitsPirate[tokenId] = p;\\r\\n            existingCombinations[structToHashPi(p)] = tokenId;\\r\\n            emit PirateMinted(tokenId);\\r\\n            return p;\\r\\n        }\\r\\n        return generatePirate(tokenId, randomizer.random(seed));\\r\\n    }\\r\\n\\r\\n    function generateHonors(uint256 tokenId, uint8 id)\\r\\n        internal\\r\\n        returns (HPirates memory r)\\r\\n    {\\r\\n        r.Legendary = id;\\r\\n        tokenTraitsHonors[minted] = r;\\r\\n        isHonors[minted] = true;\\r\\n        emit PirateMinted(tokenId);\\r\\n        return r;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * uses A.J. Walker's Alias algorithm for O(1) rarity table lookup\\r\\n     * ensuring O(1) instead of O(n) reduces mint cost by more than 50%\\r\\n     * probability & alias tables are generated off-chain beforehand\\r\\n     * @param seed portion of the 256 bit seed to remove trait correlation\\r\\n     * @param traitType the trait type to select a trait for\\r\\n     * @return the ID of the randomly selected trait\\r\\n     */\\r\\n    function selectTrait(uint16 seed, uint8 traitType)\\r\\n        internal\\r\\n        view\\r\\n        returns (uint8)\\r\\n    {\\r\\n        uint8 trait = uint8(seed) % uint8(rarities[traitType].length);\\r\\n        // If a selected random trait probability is selected (biased coin) return that trait\\r\\n        if (seed >> 8 < rarities[traitType][trait]) return trait;\\r\\n        return aliases[traitType][trait];\\r\\n    }\\r\\n\\r\\n    function selectPiTraits(uint256 seed)\\r\\n        internal\\r\\n        view\\r\\n        returns (Pirate memory p)\\r\\n    {\\r\\n        p.isPirate = true;\\r\\n        seed >>= 16;\\r\\n        p.sky = selectTrait(uint16(seed & 0xFFFF), 0);\\r\\n        seed >>= 16;\\r\\n        p.cockpit = selectTrait(uint16(seed & 0xFFFF), 1);\\r\\n        seed >>= 16;\\r\\n        p.base = selectTrait(uint16(seed & 0xFFFF), 2);\\r\\n        seed >>= 16;\\r\\n        p.engine = selectTrait(uint16(seed & 0xFFFF), 3);\\r\\n        seed >>= 16;\\r\\n        p.nose = selectTrait(uint16(seed & 0xFFFF), 4);\\r\\n        seed >>= 16;\\r\\n        p.wing = selectTrait(uint16(seed & 0xFFFF), 5);\\r\\n        seed >>= 16;\\r\\n        p.weapon1 = selectTrait(uint16(seed & 0xFFFF), 6);\\r\\n        seed >>= 16;\\r\\n        p.weapon2 = selectTrait(uint16(seed & 0xFFFF), 7);\\r\\n        seed >>= 16;\\r\\n        p.rank = selectTrait(uint16(seed & 0xFFFF), 8);\\r\\n    }\\r\\n\\r\\n    function structToHashPi(Pirate memory q) internal pure returns (uint256) {\\r\\n        return\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        q.sky,\\r\\n                        q.cockpit,\\r\\n                        q.base,\\r\\n                        q.engine,\\r\\n                        q.nose,\\r\\n                        q.wing,\\r\\n                        q.weapon1,\\r\\n                        q.weapon2,\\r\\n                        q.rank\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        public\\r\\n        view\\r\\n        returns (string memory)\\r\\n    {\\r\\n        return _tokenName[index];\\r\\n    }\\r\\n\\r\\n    function isNameReserved(string memory nameString)\\r\\n        public\\r\\n        view\\r\\n        returns (bool)\\r\\n    {\\r\\n        return _nameReserved[toLower(nameString)];\\r\\n    }\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) public view returns (bool) {\\r\\n        return _hasName[tokenId];\\r\\n    }\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) public {\\r\\n        require(namingActive == true, \\\"naming not yet availanle\\\");\\r\\n        require(ownerOf[tokenId] == msg.sender, \\\"Not your pirate to name\\\");\\r\\n        require(hasBeenNamed(tokenId) == false, \\\"Pirate already named\\\");\\r\\n        require(validateName(newName) == true, \\\"Not a valid name\\\");\\r\\n        require(isNameReserved(newName) == false, \\\"Name already reserved\\\");\\r\\n\\r\\n        //   IERC20(_eonAddress).transferFrom(msg.sender, address(this), NAME_CHANGE_PRICE);\\r\\n\\r\\n        toggleReserveName(newName, true);\\r\\n        toggleHasName(tokenId, true);\\r\\n        _tokenName[tokenId] = newName;\\r\\n        EON.burn(msg.sender, costToName);\\r\\n        emit PirateNamed(tokenId, newName);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Reserves the name if isReserve is set to true, de-reserves if set to false\\r\\n     */\\r\\n    function toggleReserveName(string memory str, bool isReserve) internal {\\r\\n        _nameReserved[toLower(str)] = isReserve;\\r\\n    }\\r\\n\\r\\n    function toggleHasName(uint256 tokenId, bool hasName) internal {\\r\\n        _hasName[tokenId] = hasName;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Check if the name string is valid (Alphanumeric and spaces without leading or trailing space)\\r\\n     */\\r\\n    function validateName(string memory str) public pure returns (bool) {\\r\\n        bytes memory b = bytes(str);\\r\\n        if (b.length < 1) return false;\\r\\n        if (b.length > 25) return false; // Cannot be longer than 25 characters\\r\\n        if (b[0] == 0x20) return false; // Leading space\\r\\n        if (b[b.length - 1] == 0x20) return false; // Trailing space\\r\\n\\r\\n        bytes1 lastChar = b[0];\\r\\n\\r\\n        for (uint256 i; i < b.length; i++) {\\r\\n            bytes1 char = b[i];\\r\\n\\r\\n            if (char == 0x20 && lastChar == 0x20) return false; // Cannot contain continous spaces\\r\\n\\r\\n            if (\\r\\n                !(char >= 0x30 && char <= 0x39) && //9-0\\r\\n                !(char >= 0x41 && char <= 0x5A) && //A-Z\\r\\n                !(char >= 0x61 && char <= 0x7A) && //a-z\\r\\n                !(char == 0x20) //space\\r\\n            ) return false;\\r\\n\\r\\n            lastChar = char;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts the string to lowercase\\r\\n     */\\r\\n    function toLower(string memory str) public pure returns (string memory) {\\r\\n        bytes memory bStr = bytes(str);\\r\\n        bytes memory bLower = new bytes(bStr.length);\\r\\n        for (uint256 i = 0; i < bStr.length; i++) {\\r\\n            // Uppercase character\\r\\n            if ((uint8(bStr[i]) >= 65) && (uint8(bStr[i]) <= 90)) {\\r\\n                bLower[i] = bytes1(uint8(bStr[i]) + 32);\\r\\n            } else {\\r\\n                bLower[i] = bStr[i];\\r\\n            }\\r\\n        }\\r\\n        return string(bLower);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables owner to pause / unpause minting\\r\\n     */\\r\\n    function setPaused(bool _paused) external requireContractsSet onlyOwner {\\r\\n        if (_paused) _pause();\\r\\n        else _unpause();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * enables an address to mint / burn\\r\\n     * @param addr the address to enable\\r\\n     */\\r\\n    function addAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * disables an address from minting / burning\\r\\n     * @param addr the address to disbale\\r\\n     */\\r\\n    function removeAdmin(address addr) external onlyOwner {\\r\\n        admins[addr] = false;\\r\\n    }\\r\\n\\r\\n    function transferOwnership(address newOwner) external onlyOwner {\\r\\n        auth = newOwner;\\r\\n    }\\r\\n\\r\\n    function toggleNameing(bool _namingActive) external onlyOwner {\\r\\n        namingActive = _namingActive;\\r\\n    }\\r\\n\\r\\n    function setImperialGuildTreasury(address _imperialTreasury)\\r\\n        external\\r\\n        onlyOwner\\r\\n    {\\r\\n        imperialGuildTreasury = _imperialTreasury;\\r\\n    }\\r\\n\\r\\n    /** Traits */\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (Pirate memory)\\r\\n    {\\r\\n        return tokenTraitsPirate[tokenId];\\r\\n    }\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (HPirates memory)\\r\\n    {\\r\\n        return tokenTraitsHonors[tokenId];\\r\\n    }\\r\\n\\r\\n    function tokenURI(uint256 tokenId)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (string memory)\\r\\n    {\\r\\n        if (isHonors[tokenId]) {\\r\\n            return honorTraits.tokenURI(tokenId);\\r\\n        }\\r\\n        return traits.tokenURI(tokenId);\\r\\n    }\\r\\n\\r\\n    function isOwner(uint256 tokenId) public view returns (address) {\\r\\n        address addr = ownerOf[tokenId];\\r\\n        return addr;\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id\\r\\n    ) public override(ERC721, IPirates) {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    \\\"\\\"\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 id,\\r\\n        bytes memory data\\r\\n    ) public override(ERC721, IPirates) {\\r\\n        transferFrom(from, to, id);\\r\\n\\r\\n        require(\\r\\n            to.code.length == 0 ||\\r\\n                ERC721TokenReceiver(to).onERC721Received(\\r\\n                    msg.sender,\\r\\n                    from,\\r\\n                    id,\\r\\n                    data\\r\\n                ) ==\\r\\n                ERC721TokenReceiver.onERC721Received.selector,\\r\\n            \\\"UNSAFE_RECIPIENT\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    // For OpenSeas\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return auth;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IEON.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IEON {\\r\\n    function mint(address to, uint256 amount) external;\\r\\n\\r\\n    function burn(address from, uint256 amount) external;\\r\\n\\r\\n    function transferFrom(\\r\\n        address sender,\\r\\n        address recipient,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IHPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\npragma solidity ^0.8.0;\\n\\ninterface IHPirates {\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOrbitalBlockade.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\n\\npragma solidity ^0.8.0;\\n\\ninterface IOrbitalBlockade {\\n    function addPiratesToCrew(address account, uint16[] calldata tokenIds)\\n        external;\\n    \\n    function claimPiratesFromCrew(address account, uint16[] calldata tokenIds, bool unstake)\\n        external;\\n\\n    function payPirateTax(uint256 amount) external;\\n\\n    function randomPirateOwner(uint256 seed) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPirates {\\r\\n    // struct to store each Colonist's traits\\r\\n    struct Pirate {\\r\\n        bool isPirate;\\r\\n        uint8 sky;\\r\\n        uint8 cockpit;\\r\\n        uint8 base;\\r\\n        uint8 engine;\\r\\n        uint8 nose;\\r\\n        uint8 wing;\\r\\n        uint8 weapon1;\\r\\n        uint8 weapon2;\\r\\n        uint8 rank;\\r\\n    }\\r\\n\\r\\n    struct HPirates {\\r\\n        uint8 Legendary;\\r\\n    }\\r\\n\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId,\\r\\n        bytes memory _data\\r\\n    ) external;\\r\\n\\r\\n    function minted() external returns (uint16);\\r\\n\\r\\n    function piratesMinted() external returns (uint16);\\r\\n\\r\\n    function isOwner(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (address);\\r\\n\\r\\n    function _mintPirate(address recipient, uint256 seed) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function getTokenTraitsPirate(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (Pirate memory);\\r\\n\\r\\n    function getTokenTraitsHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (HPirates memory);\\r\\n\\r\\n    function tokenNameByIndex(uint256 index)\\r\\n        external\\r\\n        view\\r\\n        returns (string memory);\\r\\n    \\r\\n    function isHonors(uint256 tokenId)\\r\\n        external\\r\\n        view\\r\\n        returns (bool);\\r\\n\\r\\n    function hasBeenNamed(uint256 tokenId) external view returns (bool);\\r\\n\\r\\n    function namePirate(uint256 tokenId, string memory newName) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IRandomizer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IRandomizer {\\r\\n    function random(uint256) external returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ITPirates.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT LICENSE\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ITPirates {\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\r\\n}\\r\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PirateMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"PirateNamed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PirateStolen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EON\",\"outputs\":[{\"internalType\":\"contract IEON\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PIRATES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"id\",\"type\":\"uint8\"}],\"name\":\"_mintHonors\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"_mintPirate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"aliases\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"auth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"costToName\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"existingCombinations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsHonors\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"internalType\":\"struct IPirates.HPirates\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getTokenTraitsPirate\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPirate\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"sky\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cockpit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"engine\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"wing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rank\",\"type\":\"uint8\"}],\"internalType\":\"struct IPirates.Pirate\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"hasBeenNamed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"honorTraits\",\"outputs\":[{\"internalType\":\"contract IHPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"isHonors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"nameString\",\"type\":\"string\"}],\"name\":\"isNameReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"namePirate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"namingActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbital\",\"outputs\":[{\"internalType\":\"contract IOrbitalBlockade\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"piratesMinted\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomizer\",\"outputs\":[{\"internalType\":\"contract IRandomizer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rarities\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_honorTraits\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_orbital\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_eon\",\"type\":\"address\"}],\"name\":\"setContracts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_imperialTreasury\",\"type\":\"address\"}],\"name\":\"setImperialGuildTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"toLower\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_namingActive\",\"type\":\"bool\"}],\"name\":\"toggleNameing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenNameByIndex\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsHonors\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"Legendary\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenTraitsPirate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPirate\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"sky\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"cockpit\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"base\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"engine\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"nose\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"wing\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon1\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"weapon2\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"rank\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traits\",\"outputs\":[{\"internalType\":\"contract ITPirates\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"validateName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "Pirates", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "0", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}