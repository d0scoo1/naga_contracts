{"status": "1", "message": "OK", "result": [{"SourceCode": "{\"AssetMatcherCollection.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./IAssetMatcher.sol\\\";\\nimport \\\"./LibERC721LazyMint.sol\\\";\\nimport \\\"./LibERC1155LazyMint.sol\\\";\\n\\n/*\\n * Custom matcher for collection (assetClass, that need any/all elements from collection)\\n */\\ncontract AssetMatcherCollection is IAssetMatcher {\\n\\n    bytes constant EMPTY = \\\"\\\";\\n\\n    function matchAssets(LibAsset.AssetType memory leftAssetType, LibAsset.AssetType memory rightAssetType) public view override returns (LibAsset.AssetType memory) {\\n        if (\\n            (rightAssetType.assetClass == LibAsset.ERC721_ASSET_CLASS) || \\n            (rightAssetType.assetClass == LibERC721LazyMint.ERC721_LAZY_ASSET_CLASS) ||\\n            (rightAssetType.assetClass == LibAsset.ERC1155_ASSET_CLASS) || \\n            (rightAssetType.assetClass == LibERC1155LazyMint.ERC1155_LAZY_ASSET_CLASS) ||\\n            (rightAssetType.assetClass == LibAsset.CRYPTO_PUNKS)\\n        ) {\\n          (address leftToken) = abi.decode(leftAssetType.data, (address));\\n          (address rightToken,) = abi.decode(rightAssetType.data, (address, uint));\\n          if (leftToken == rightToken) {\\n              return LibAsset.AssetType(rightAssetType.assetClass, rightAssetType.data);\\n          }\\n        }\\n        return LibAsset.AssetType(0, EMPTY);\\n    }\\n}\"},\"IAssetMatcher.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport \\\"./LibAsset.sol\\\";\\n\\ninterface IAssetMatcher {\\n    function matchAssets(\\n        LibAsset.AssetType memory leftAssetType,\\n        LibAsset.AssetType memory rightAssetType\\n    ) external view returns (LibAsset.AssetType memory);\\n}\\n\"},\"LibAsset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nlibrary LibAsset {\\n    bytes4 constant public ETH_ASSET_CLASS = bytes4(keccak256(\\\"ETH\\\"));\\n    bytes4 constant public ERC20_ASSET_CLASS = bytes4(keccak256(\\\"ERC20\\\"));\\n    bytes4 constant public ERC721_ASSET_CLASS = bytes4(keccak256(\\\"ERC721\\\"));\\n    bytes4 constant public ERC1155_ASSET_CLASS = bytes4(keccak256(\\\"ERC1155\\\"));\\n    bytes4 constant public COLLECTION = bytes4(keccak256(\\\"COLLECTION\\\"));\\n    bytes4 constant public CRYPTO_PUNKS = bytes4(keccak256(\\\"CRYPTO_PUNKS\\\"));\\n\\n    bytes32 constant ASSET_TYPE_TYPEHASH = keccak256(\\n        \\\"AssetType(bytes4 assetClass,bytes data)\\\"\\n    );\\n\\n    bytes32 constant ASSET_TYPEHASH = keccak256(\\n        \\\"Asset(AssetType assetType,uint256 value)AssetType(bytes4 assetClass,bytes data)\\\"\\n    );\\n\\n    struct AssetType {\\n        bytes4 assetClass;\\n        bytes data;\\n    }\\n\\n    struct Asset {\\n        AssetType assetType;\\n        uint value;\\n    }\\n\\n    function hash(AssetType memory assetType) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n                ASSET_TYPE_TYPEHASH,\\n                assetType.assetClass,\\n                keccak256(assetType.data)\\n            ));\\n    }\\n\\n    function hash(Asset memory asset) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(\\n                ASSET_TYPEHASH,\\n                hash(asset.assetType),\\n                asset.value\\n            ));\\n    }\\n\\n}\\n\"},\"LibERC1155LazyMint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\nimport \\\"./LibPart.sol\\\";\\n\\nlibrary LibERC1155LazyMint {\\n    bytes4 constant public ERC1155_LAZY_ASSET_CLASS = bytes4(keccak256(\\\"ERC1155_LAZY\\\"));\\n    bytes4 constant _INTERFACE_ID_MINT_AND_TRANSFER = 0x6db15a0f;\\n\\n    struct Mint1155Data {\\n        uint tokenId;\\n        string tokenURI;\\n        uint supply;\\n        LibPart.Part[] creators;\\n        LibPart.Part[] royalties;\\n        bytes[] signatures;\\n    }\\n\\n    bytes32 public constant MINT_AND_TRANSFER_TYPEHASH = keccak256(\\\"Mint1155(uint256 tokenId,uint256 supply,string tokenURI,Part[] creators,Part[] royalties)Part(address account,uint96 value)\\\");\\n\\n    function hash(Mint1155Data memory data) internal pure returns (bytes32) {\\n        bytes32[] memory royaltiesBytes = new bytes32[](data.royalties.length);\\n        for (uint i = 0; i \\u003c data.royalties.length; i++) {\\n            royaltiesBytes[i] = LibPart.hash(data.royalties[i]);\\n        }\\n        bytes32[] memory creatorsBytes = new bytes32[](data.creators.length);\\n        for (uint i = 0; i \\u003c data.creators.length; i++) {\\n            creatorsBytes[i] = LibPart.hash(data.creators[i]);\\n        }\\n        return keccak256(abi.encode(\\n                MINT_AND_TRANSFER_TYPEHASH,\\n                data.tokenId,\\n                data.supply,\\n                keccak256(bytes(data.tokenURI)),\\n                keccak256(abi.encodePacked(creatorsBytes)),\\n                keccak256(abi.encodePacked(royaltiesBytes))\\n            ));\\n    }\\n}\\n\"},\"LibERC721LazyMint.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\nimport \\\"./LibPart.sol\\\";\\n\\nlibrary LibERC721LazyMint {\\n    bytes4 constant public ERC721_LAZY_ASSET_CLASS = bytes4(keccak256(\\\"ERC721_LAZY\\\"));\\n    bytes4 constant _INTERFACE_ID_MINT_AND_TRANSFER = 0x8486f69f;\\n\\n    struct Mint721Data {\\n        uint tokenId;\\n        string tokenURI;\\n        LibPart.Part[] creators;\\n        LibPart.Part[] royalties;\\n        bytes[] signatures;\\n    }\\n\\n    bytes32 public constant MINT_AND_TRANSFER_TYPEHASH = keccak256(\\\"Mint721(uint256 tokenId,string tokenURI,Part[] creators,Part[] royalties)Part(address account,uint96 value)\\\");\\n\\n    function hash(Mint721Data memory data) internal pure returns (bytes32) {\\n        bytes32[] memory royaltiesBytes = new bytes32[](data.royalties.length);\\n        for (uint i = 0; i \\u003c data.royalties.length; i++) {\\n            royaltiesBytes[i] = LibPart.hash(data.royalties[i]);\\n        }\\n        bytes32[] memory creatorsBytes = new bytes32[](data.creators.length);\\n        for (uint i = 0; i \\u003c data.creators.length; i++) {\\n            creatorsBytes[i] = LibPart.hash(data.creators[i]);\\n        }\\n        return keccak256(abi.encode(\\n                MINT_AND_TRANSFER_TYPEHASH,\\n                data.tokenId,\\n                keccak256(bytes(data.tokenURI)),\\n                keccak256(abi.encodePacked(creatorsBytes)),\\n                keccak256(abi.encodePacked(royaltiesBytes))\\n            ));\\n    }\\n\\n}\\n\"},\"LibPart.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity \\u003e=0.6.2 \\u003c0.8.0;\\n\\nlibrary LibPart {\\n    bytes32 public constant TYPE_HASH = keccak256(\\\"Part(address account,uint96 value)\\\");\\n\\n    struct Part {\\n        address payable account;\\n        uint96 value;\\n    }\\n\\n    function hash(Part memory part) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, part.account, part.value));\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"assetClass\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LibAsset.AssetType\",\"name\":\"leftAssetType\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"assetClass\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LibAsset.AssetType\",\"name\":\"rightAssetType\",\"type\":\"tuple\"}],\"name\":\"matchAssets\",\"outputs\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"assetClass\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct LibAsset.AssetType\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "AssetMatcherCollection", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8531bf056e7a72f8ce15a1bf8326e81a0cae36434a5092e1e13dbb13923a5030"}]}