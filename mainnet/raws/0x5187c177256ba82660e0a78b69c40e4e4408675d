{"status": "1", "message": "OK", "result": [{"SourceCode": "pragma solidity 0.8.6;\r\npragma abicoder v2;\r\n\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\nstruct Balance {\r\n    /// units of staking token that has been deposited and consequently wrapped\r\n    uint88 raw;\r\n    /// (block.timestamp - weightedTimestamp) represents the seconds a user has had their full raw balance wrapped.\r\n    /// If they deposit or withdraw, the weightedTimestamp is dragged towards block.timestamp proportionately\r\n    uint32 weightedTimestamp;\r\n    /// multiplier awarded for staking for a long time\r\n    uint8 timeMultiplier;\r\n    /// multiplier duplicated from QuestManager\r\n    uint8 questMultiplier;\r\n    /// Time at which the relative cooldown began\r\n    uint32 cooldownTimestamp;\r\n    /// Units up for cooldown\r\n    uint88 cooldownUnits;\r\n}\r\n\r\nstruct QuestBalance {\r\n    /// last timestamp at which the user made a write action to this contract\r\n    uint32 lastAction;\r\n    /// permanent multiplier applied to an account, awarded for PERMANENT QuestTypes\r\n    uint8 permMultiplier;\r\n    /// multiplier that decays after each \"season\" (~9 months) by 75%, to avoid multipliers getting out of control\r\n    uint8 seasonMultiplier;\r\n}\r\n\r\n/// @notice Quests can either give permanent rewards or only for the season\r\nenum QuestType {\r\n    PERMANENT,\r\n    SEASONAL\r\n}\r\n\r\n/// @notice Quests can be turned off by the questMaster. All those who already completed remain\r\nenum QuestStatus {\r\n    ACTIVE,\r\n    EXPIRED\r\n}\r\n\r\nstruct Quest {\r\n    /// Type of quest rewards\r\n    QuestType model;\r\n    /// Multiplier, from 1 == 1.01x to 100 == 2.00x\r\n    uint8 multiplier;\r\n    /// Is the current quest valid?\r\n    QuestStatus status;\r\n    /// Expiry date in seconds for the quest\r\n    uint32 expiry;\r\n}\r\n\r\ninterface IStakedToken {\r\n    // GETTERS\r\n    function COOLDOWN_SECONDS() external view returns (uint256);\r\n\r\n    function UNSTAKE_WINDOW() external view returns (uint256);\r\n\r\n    function STAKED_TOKEN() external view returns (IERC20);\r\n\r\n    function getRewardToken() external view returns (address);\r\n\r\n    function pendingAdditionalReward() external view returns (uint256);\r\n\r\n    function whitelistedWrappers(address) external view returns (bool);\r\n\r\n    function balanceData(address _account) external view returns (Balance memory);\r\n\r\n    function balanceOf(address _account) external view returns (uint256);\r\n\r\n    function rawBalanceOf(address _account) external view returns (uint256, uint256);\r\n\r\n    function calcRedemptionFeeRate(uint32 _weightedTimestamp)\r\n        external\r\n        view\r\n        returns (uint256 _feeRate);\r\n\r\n    function safetyData()\r\n        external\r\n        view\r\n        returns (uint128 collateralisationRatio, uint128 slashingPercentage);\r\n\r\n    function delegates(address account) external view returns (address);\r\n\r\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\r\n\r\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\r\n\r\n    function getVotes(address account) external view returns (uint256);\r\n\r\n    // HOOKS/PERMISSIONED\r\n    function applyQuestMultiplier(address _account, uint8 _newMultiplier) external;\r\n\r\n    // ADMIN\r\n    function whitelistWrapper(address _wrapper) external;\r\n\r\n    function blackListWrapper(address _wrapper) external;\r\n\r\n    function changeSlashingPercentage(uint256 _newRate) external;\r\n\r\n    function emergencyRecollateralisation() external;\r\n\r\n    function setGovernanceHook(address _newHook) external;\r\n\r\n    // USER\r\n    function stake(uint256 _amount) external;\r\n\r\n    function stake(uint256 _amount, address _delegatee) external;\r\n\r\n    function stake(uint256 _amount, bool _exitCooldown) external;\r\n\r\n    function withdraw(\r\n        uint256 _amount,\r\n        address _recipient,\r\n        bool _amountIncludesFee,\r\n        bool _exitCooldown\r\n    ) external;\r\n\r\n    function delegate(address delegatee) external;\r\n\r\n    function startCooldown(uint256 _units) external;\r\n\r\n    function endCooldown() external;\r\n\r\n    function reviewTimestamp(address _account) external;\r\n\r\n    function claimReward() external;\r\n\r\n    function claimReward(address _to) external;\r\n\r\n    // Backwards compatibility\r\n    function createLock(uint256 _value, uint256) external;\r\n\r\n    function exit() external;\r\n\r\n    function increaseLockAmount(uint256 _value) external;\r\n\r\n    function increaseLockLength(uint256) external;\r\n}\r\n\r\nlibrary MathUpgradeable {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute.\r\n        return (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a / b + (a % b == 0 ? 0 : 1);\r\n    }\r\n}\r\n\r\nlibrary SafeCast {\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\nlibrary ECDSAUpgradeable {\r\n    /**\r\n     * @dev Returns the address that signed a hashed message (`hash`) with\r\n     * `signature`. This address can then be used for verification purposes.\r\n     *\r\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\r\n     * this function rejects them by requiring the `s` value to be in the lower\r\n     * half order, and the `v` value to be either 27 or 28.\r\n     *\r\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\r\n     * verification to be secure: it is possible to craft signatures that\r\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\r\n     * this is by receiving a hash of the original message (which may otherwise\r\n     * be too long), and then calling {toEthSignedMessageHash} on it.\r\n     *\r\n     * Documentation for signature generation:\r\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\r\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\r\n     */\r\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\r\n        // Check the signature length\r\n        // - case 65: r,s,v signature (standard)\r\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\r\n        if (signature.length == 65) {\r\n            bytes32 r;\r\n            bytes32 s;\r\n            uint8 v;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                s := mload(add(signature, 0x40))\r\n                v := byte(0, mload(add(signature, 0x60)))\r\n            }\r\n            return recover(hash, v, r, s);\r\n        } else if (signature.length == 64) {\r\n            bytes32 r;\r\n            bytes32 vs;\r\n            // ecrecover takes the signature parameters, and the only way to get them\r\n            // currently is to use assembly.\r\n            assembly {\r\n                r := mload(add(signature, 0x20))\r\n                vs := mload(add(signature, 0x40))\r\n            }\r\n            return recover(hash, r, vs);\r\n        } else {\r\n            revert(\"ECDSA: invalid signature length\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\r\n     *\r\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\r\n     *\r\n     * _Available since v4.2._\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        bytes32 r,\r\n        bytes32 vs\r\n    ) internal pure returns (address) {\r\n        bytes32 s;\r\n        uint8 v;\r\n        assembly {\r\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\r\n            v := add(shr(255, vs), 27)\r\n        }\r\n        return recover(hash, v, r, s);\r\n    }\r\n\r\n    /**\r\n     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\r\n     */\r\n    function recover(\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal pure returns (address) {\r\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\r\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\r\n        // the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\r\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\r\n        //\r\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\r\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\r\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\r\n        // these malleable signatures as well.\r\n        require(\r\n            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\r\n            \"ECDSA: invalid signature 's' value\"\r\n        );\r\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\r\n\r\n        // If the signature is valid (and not malleable), return the signer address\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer != address(0), \"ECDSA: invalid signature\");\r\n\r\n        return signer;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\r\n     * produces hash corresponding to the one signed with the\r\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\r\n     * JSON-RPC method as part of EIP-191.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\r\n        // 32 is the length in bytes of hash,\r\n        // enforced by the type signature above\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns an Ethereum Signed Typed Data, created from a\r\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\r\n     * to the one signed with the\r\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\r\n     * JSON-RPC method as part of EIP-712.\r\n     *\r\n     * See {recover}.\r\n     */\r\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\r\n    }\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n */\r\n\r\nabstract contract ContextUpgradeable is Initializable {\r\n    function __Context_init() internal initializer {\r\n        __Context_init_unchained();\r\n    }\r\n\r\n    function __Context_init_unchained() internal initializer {\r\n    }\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n    uint256[50] private __gap;\r\n}\r\n\r\nlibrary SafeCastExtended {\r\n    /**\r\n     * @dev Returns the downcasted uint224 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint224).\r\n     *\r\n     * Counterpart to Solidity's `uint224` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 224 bits\r\n     */\r\n    function toUint224(uint256 value) internal pure returns (uint224) {\r\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\r\n        return uint224(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint128 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint128).\r\n     *\r\n     * Counterpart to Solidity's `uint128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     */\r\n    function toUint128(uint256 value) internal pure returns (uint128) {\r\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\r\n        return uint128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint96 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint96).\r\n     *\r\n     * Counterpart to Solidity's `uint96` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 96 bits\r\n     */\r\n    function toUint96(uint256 value) internal pure returns (uint96) {\r\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\r\n        return uint96(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint88 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint88).\r\n     *\r\n     * Counterpart to Solidity's `uint88` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 88 bits\r\n     */\r\n    function toUint88(uint256 value) internal pure returns (uint88) {\r\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\r\n        return uint88(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint64 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint64).\r\n     *\r\n     * Counterpart to Solidity's `uint64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     */\r\n    function toUint64(uint256 value) internal pure returns (uint64) {\r\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\r\n        return uint64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint32 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint32).\r\n     *\r\n     * Counterpart to Solidity's `uint32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     */\r\n    function toUint32(uint256 value) internal pure returns (uint32) {\r\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\r\n        return uint32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint16 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint16).\r\n     *\r\n     * Counterpart to Solidity's `uint16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     */\r\n    function toUint16(uint256 value) internal pure returns (uint16) {\r\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\r\n        return uint16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted uint8 from uint256, reverting on\r\n     * overflow (when the input is greater than largest uint8).\r\n     *\r\n     * Counterpart to Solidity's `uint8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     */\r\n    function toUint8(uint256 value) internal pure returns (uint8) {\r\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\r\n        return uint8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a signed int256 into an unsigned uint256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be greater than or equal to 0.\r\n     */\r\n    function toUint256(int256 value) internal pure returns (uint256) {\r\n        require(value >= 0, \"SafeCast: value must be positive\");\r\n        return uint256(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int128 from int256, reverting on\r\n     * overflow (when the input is less than smallest int128 or\r\n     * greater than largest int128).\r\n     *\r\n     * Counterpart to Solidity's `int128` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 128 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt128(int256 value) internal pure returns (int128) {\r\n        require(\r\n            value >= type(int128).min && value <= type(int128).max,\r\n            \"SafeCast: value doesn't fit in 128 bits\"\r\n        );\r\n        return int128(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int64 from int256, reverting on\r\n     * overflow (when the input is less than smallest int64 or\r\n     * greater than largest int64).\r\n     *\r\n     * Counterpart to Solidity's `int64` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 64 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt64(int256 value) internal pure returns (int64) {\r\n        require(\r\n            value >= type(int64).min && value <= type(int64).max,\r\n            \"SafeCast: value doesn't fit in 64 bits\"\r\n        );\r\n        return int64(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int32 from int256, reverting on\r\n     * overflow (when the input is less than smallest int32 or\r\n     * greater than largest int32).\r\n     *\r\n     * Counterpart to Solidity's `int32` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 32 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt32(int256 value) internal pure returns (int32) {\r\n        require(\r\n            value >= type(int32).min && value <= type(int32).max,\r\n            \"SafeCast: value doesn't fit in 32 bits\"\r\n        );\r\n        return int32(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int16 from int256, reverting on\r\n     * overflow (when the input is less than smallest int16 or\r\n     * greater than largest int16).\r\n     *\r\n     * Counterpart to Solidity's `int16` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 16 bits\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt16(int256 value) internal pure returns (int16) {\r\n        require(\r\n            value >= type(int16).min && value <= type(int16).max,\r\n            \"SafeCast: value doesn't fit in 16 bits\"\r\n        );\r\n        return int16(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the downcasted int8 from int256, reverting on\r\n     * overflow (when the input is less than smallest int8 or\r\n     * greater than largest int8).\r\n     *\r\n     * Counterpart to Solidity's `int8` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must fit into 8 bits.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function toInt8(int256 value) internal pure returns (int8) {\r\n        require(\r\n            value >= type(int8).min && value <= type(int8).max,\r\n            \"SafeCast: value doesn't fit in 8 bits\"\r\n        );\r\n        return int8(value);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an unsigned uint256 into a signed int256.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - input must be less than or equal to maxInt256.\r\n     */\r\n    function toInt256(uint256 value) internal pure returns (int256) {\r\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\r\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\r\n        return int256(value);\r\n    }\r\n}\r\n\r\ninterface ILockedERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ModuleKeys {\r\n    // Governance\r\n    // ===========\r\n    // keccak256(\"Governance\");\r\n    bytes32 internal constant KEY_GOVERNANCE =\r\n        0x9409903de1e6fd852dfc61c9dacb48196c48535b60e25abf92acc92dd689078d;\r\n    //keccak256(\"Staking\");\r\n    bytes32 internal constant KEY_STAKING =\r\n        0x1df41cd916959d1163dc8f0671a666ea8a3e434c13e40faef527133b5d167034;\r\n    //keccak256(\"ProxyAdmin\");\r\n    bytes32 internal constant KEY_PROXY_ADMIN =\r\n        0x96ed0203eb7e975a4cbcaa23951943fa35c5d8288117d50c12b3d48b0fab48d1;\r\n\r\n    // mStable\r\n    // =======\r\n    // keccak256(\"OracleHub\");\r\n    bytes32 internal constant KEY_ORACLE_HUB =\r\n        0x8ae3a082c61a7379e2280f3356a5131507d9829d222d853bfa7c9fe1200dd040;\r\n    // keccak256(\"Manager\");\r\n    bytes32 internal constant KEY_MANAGER =\r\n        0x6d439300980e333f0256d64be2c9f67e86f4493ce25f82498d6db7f4be3d9e6f;\r\n    //keccak256(\"Recollateraliser\");\r\n    bytes32 internal constant KEY_RECOLLATERALISER =\r\n        0x39e3ed1fc335ce346a8cbe3e64dd525cf22b37f1e2104a755e761c3c1eb4734f;\r\n    //keccak256(\"MetaToken\");\r\n    bytes32 internal constant KEY_META_TOKEN =\r\n        0xea7469b14936af748ee93c53b2fe510b9928edbdccac3963321efca7eb1a57a2;\r\n    // keccak256(\"SavingsManager\");\r\n    bytes32 internal constant KEY_SAVINGS_MANAGER =\r\n        0x12fe936c77a1e196473c4314f3bed8eeac1d757b319abb85bdda70df35511bf1;\r\n    // keccak256(\"Liquidator\");\r\n    bytes32 internal constant KEY_LIQUIDATOR =\r\n        0x1e9cb14d7560734a61fa5ff9273953e971ff3cd9283c03d8346e3264617933d4;\r\n    // keccak256(\"InterestValidator\");\r\n    bytes32 internal constant KEY_INTEREST_VALIDATOR =\r\n        0xc10a28f028c7f7282a03c90608e38a4a646e136e614e4b07d119280c5f7f839f;\r\n}\r\n\r\ninterface INexus {\r\n    function governor() external view returns (address);\r\n\r\n    function getModule(bytes32 key) external view returns (address);\r\n\r\n    function proposeModule(bytes32 _key, address _addr) external;\r\n\r\n    function cancelProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModule(bytes32 _key) external;\r\n\r\n    function acceptProposedModules(bytes32[] calldata _keys) external;\r\n\r\n    function requestLockModule(bytes32 _key) external;\r\n\r\n    function cancelLockModule(bytes32 _key) external;\r\n\r\n    function lockModule(bytes32 _key) external;\r\n}\r\n\r\nabstract contract ImmutableModule is ModuleKeys {\r\n    INexus public immutable nexus;\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contracts\r\n     * @param _nexus Nexus contract address\r\n     */\r\n    constructor(address _nexus) {\r\n        require(_nexus != address(0), \"Nexus address is zero\");\r\n        nexus = INexus(_nexus);\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governor.\r\n     */\r\n    modifier onlyGovernor() {\r\n        _onlyGovernor();\r\n        _;\r\n    }\r\n\r\n    function _onlyGovernor() internal view {\r\n        require(msg.sender == _governor(), \"Only governor can execute\");\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to allow function calls only from the Governance.\r\n     *      Governance is either Governor address or Governance address.\r\n     */\r\n    modifier onlyGovernance() {\r\n        require(\r\n            msg.sender == _governor() || msg.sender == _governance(),\r\n            \"Only governance can execute\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governor address from the Nexus\r\n     * @return Address of Governor Contract\r\n     */\r\n    function _governor() internal view returns (address) {\r\n        return nexus.governor();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns Governance Module address from the Nexus\r\n     * @return Address of the Governance (Phase 2)\r\n     */\r\n    function _governance() internal view returns (address) {\r\n        return nexus.getModule(KEY_GOVERNANCE);\r\n    }\r\n\r\n    /**\r\n     * @dev Return SavingsManager Module address from the Nexus\r\n     * @return Address of the SavingsManager Module contract\r\n     */\r\n    function _savingsManager() internal view returns (address) {\r\n        return nexus.getModule(KEY_SAVINGS_MANAGER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Recollateraliser Module address from the Nexus\r\n     * @return  Address of the Recollateraliser Module contract (Phase 2)\r\n     */\r\n    function _recollateraliser() internal view returns (address) {\r\n        return nexus.getModule(KEY_RECOLLATERALISER);\r\n    }\r\n\r\n    /**\r\n     * @dev Return Liquidator Module address from the Nexus\r\n     * @return  Address of the Liquidator Module contract\r\n     */\r\n    function _liquidator() internal view returns (address) {\r\n        return nexus.getModule(KEY_LIQUIDATOR);\r\n    }\r\n\r\n    /**\r\n     * @dev Return ProxyAdmin Module address from the Nexus\r\n     * @return Address of the ProxyAdmin Module contract\r\n     */\r\n    function _proxyAdmin() internal view returns (address) {\r\n        return nexus.getModule(KEY_PROXY_ADMIN);\r\n    }\r\n}\r\n\r\ninterface IRewardsDistributionRecipient {\r\n    function notifyRewardAmount(uint256 reward) external;\r\n\r\n    function getRewardToken() external view returns (IERC20);\r\n}\r\n\r\nabstract contract InitializableRewardsDistributionRecipient is\r\n    IRewardsDistributionRecipient,\r\n    ImmutableModule\r\n{\r\n    // This address has the ability to distribute the rewards\r\n    address public rewardsDistributor;\r\n\r\n    constructor(address _nexus) ImmutableModule(_nexus) {}\r\n\r\n    /** @dev Recipient is a module, governed by mStable governance */\r\n    function _initialize(address _rewardsDistributor) internal virtual {\r\n        rewardsDistributor = _rewardsDistributor;\r\n    }\r\n\r\n    /**\r\n     * @dev Only the rewards distributor can notify about rewards\r\n     */\r\n    modifier onlyRewardsDistributor() {\r\n        require(msg.sender == rewardsDistributor, \"Caller is not reward distributor\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the rewardsDistributor - only called by mStable governor\r\n     * @param _rewardsDistributor   Address of the new distributor\r\n     */\r\n    function setRewardsDistribution(address _rewardsDistributor) external onlyGovernor {\r\n        rewardsDistributor = _rewardsDistributor;\r\n    }\r\n}\r\n\r\nlibrary StableMath {\r\n    /**\r\n     * @dev Scaling unit for use in specific calculations,\r\n     * where 1 * 10**18, or 1e18 represents a unit '1'\r\n     */\r\n    uint256 private constant FULL_SCALE = 1e18;\r\n\r\n    /**\r\n     * @dev Token Ratios are used when converting between units of bAsset, mAsset and MTA\r\n     * Reasoning: Takes into account token decimals, and difference in base unit (i.e. grams to Troy oz for gold)\r\n     * bAsset ratio unit for use in exact calculations,\r\n     * where (1 bAsset unit * bAsset.ratio) / ratioScale == x mAsset unit\r\n     */\r\n    uint256 private constant RATIO_SCALE = 1e8;\r\n\r\n    /**\r\n     * @dev Provides an interface to the scaling unit\r\n     * @return Scaling unit (1e18 or 1 * 10**18)\r\n     */\r\n    function getFullScale() internal pure returns (uint256) {\r\n        return FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Provides an interface to the ratio unit\r\n     * @return Ratio scale unit (1e8 or 1 * 10**8)\r\n     */\r\n    function getRatioScale() internal pure returns (uint256) {\r\n        return RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Scales a given integer to the power of the full scale.\r\n     * @param x   Simple uint256 to scale\r\n     * @return    Scaled value a to an exact number\r\n     */\r\n    function scaleInteger(uint256 x) internal pure returns (uint256) {\r\n        return x * FULL_SCALE;\r\n    }\r\n\r\n    /***************************************\r\n              PRECISE ARITHMETIC\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncate(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulTruncateScale(x, y, FULL_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the given scale. For example,\r\n     * when calculating 90% of 10e18, (10e18 * 9e17) / 1e18 = (9e36) / 1e18 = 9e18\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @param scale Scale unit\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit\r\n     */\r\n    function mulTruncateScale(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 scale\r\n    ) internal pure returns (uint256) {\r\n        // e.g. assume scale = fullScale\r\n        // z = 10e18 * 9e17 = 9e36\r\n        // return 9e36 / 1e18 = 9e18\r\n        return (x * y) / scale;\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies two precise units, and then truncates by the full scale, rounding up the result\r\n     * @param x     Left hand input to multiplication\r\n     * @param y     Right hand input to multiplication\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              scale unit, rounded up to the closest base unit.\r\n     */\r\n    function mulTruncateCeil(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e17 * 17268172638 = 138145381104e17\r\n        uint256 scaled = x * y;\r\n        // e.g. 138145381104e17 + 9.99...e17 = 138145381113.99...e17\r\n        uint256 ceil = scaled + FULL_SCALE - 1;\r\n        // e.g. 13814538111.399...e18 / 1e18 = 13814538111\r\n        return ceil / FULL_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two units, by first scaling the left hand operand. Useful\r\n     *      for finding percentage weightings, i.e. 8e18/10e18 = 80% (or 8e17)\r\n     * @param x     Left hand input to division\r\n     * @param y     Right hand input to division\r\n     * @return      Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divPrecisely(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        // e.g. 8e18 * 1e18 = 8e36\r\n        // e.g. 8e36 / 10e18 = 8e17\r\n        return (x * FULL_SCALE) / y;\r\n    }\r\n\r\n    /***************************************\r\n                  RATIO FUNCS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, essentially flooring the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand operand to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the two inputs and then dividing by the ratio scale\r\n     */\r\n    function mulRatioTruncate(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        return mulTruncateScale(x, ratio, RATIO_SCALE);\r\n    }\r\n\r\n    /**\r\n     * @dev Multiplies and truncates a token ratio, rounding up the result\r\n     *      i.e. How much mAsset is this bAsset worth?\r\n     * @param x     Left hand input to multiplication (i.e Exact quantity)\r\n     * @param ratio bAsset ratio\r\n     * @return      Result after multiplying the two inputs and then dividing by the shared\r\n     *              ratio scale, rounded up to the closest base unit.\r\n     */\r\n    function mulRatioTruncateCeil(uint256 x, uint256 ratio) internal pure returns (uint256) {\r\n        // e.g. How much mAsset should I burn for this bAsset (x)?\r\n        // 1e18 * 1e8 = 1e26\r\n        uint256 scaled = x * ratio;\r\n        // 1e26 + 9.99e7 = 100..00.999e8\r\n        uint256 ceil = scaled + RATIO_SCALE - 1;\r\n        // return 100..00.999e8 / 1e8 = 1e18\r\n        return ceil / RATIO_SCALE;\r\n    }\r\n\r\n    /**\r\n     * @dev Precisely divides two ratioed units, by first scaling the left hand operand\r\n     *      i.e. How much bAsset is this mAsset worth?\r\n     * @param x     Left hand operand in division\r\n     * @param ratio bAsset ratio\r\n     * @return c    Result after multiplying the left operand by the scale, and\r\n     *              executing the division on the right hand input.\r\n     */\r\n    function divRatioPrecisely(uint256 x, uint256 ratio) internal pure returns (uint256 c) {\r\n        // e.g. 1e14 * 1e8 = 1e22\r\n        // return 1e22 / 1e12 = 1e10\r\n        return (x * RATIO_SCALE) / ratio;\r\n    }\r\n\r\n    /***************************************\r\n                    HELPERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Calculates minimum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Minimum of the two inputs\r\n     */\r\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? y : x;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculated maximum of two numbers\r\n     * @param x     Left hand input\r\n     * @param y     Right hand input\r\n     * @return      Maximum of the two inputs\r\n     */\r\n    function max(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return x > y ? x : y;\r\n    }\r\n\r\n    /**\r\n     * @dev Clamps a value to an upper bound\r\n     * @param x           Left hand input\r\n     * @param upperBound  Maximum possible value to return\r\n     * @return            Input x clamped to a maximum value, upperBound\r\n     */\r\n    function clamp(uint256 x, uint256 upperBound) internal pure returns (uint256) {\r\n        return x > upperBound ? upperBound : x;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) private pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\nlibrary MassetHelpers {\r\n    using SafeERC20 for IERC20;\r\n\r\n    function transferReturnBalance(\r\n        address _sender,\r\n        address _recipient,\r\n        address _bAsset,\r\n        uint256 _qty\r\n    ) internal returns (uint256 receivedQty, uint256 recipientBalance) {\r\n        uint256 balBefore = IERC20(_bAsset).balanceOf(_recipient);\r\n        IERC20(_bAsset).safeTransferFrom(_sender, _recipient, _qty);\r\n        recipientBalance = IERC20(_bAsset).balanceOf(_recipient);\r\n        receivedQty = recipientBalance - balBefore;\r\n    }\r\n\r\n    function safeInfiniteApprove(address _asset, address _spender) internal {\r\n        IERC20(_asset).safeApprove(_spender, 0);\r\n        IERC20(_asset).safeApprove(_spender, 2**256 - 1);\r\n    }\r\n}\r\n\r\ncontract PlatformTokenVendor {\r\n    IERC20 public immutable platformToken;\r\n    address public immutable parentStakingContract;\r\n\r\n    /** @dev Simple constructor that stores the parent address */\r\n    constructor(IERC20 _platformToken) {\r\n        parentStakingContract = msg.sender;\r\n        platformToken = _platformToken;\r\n        MassetHelpers.safeInfiniteApprove(address(_platformToken), msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Re-approves the StakingReward contract to spend the platform token.\r\n     * Just incase for some reason approval has been reset.\r\n     */\r\n    function reApproveOwner() external {\r\n        MassetHelpers.safeInfiniteApprove(address(platformToken), parentStakingContract);\r\n    }\r\n}\r\n\r\nlibrary PlatformTokenVendorFactory {\r\n    /// @dev for some reason Typechain will not generate the types if the library only has the create function\r\n    function dummy() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Deploys a new PlatformTokenVendor contract\r\n     * @param _rewardsToken reward or platform rewards token. eg MTA or WMATIC\r\n     * @return address of the deployed PlatformTokenVendor contract\r\n     */\r\n    function create(IERC20 _rewardsToken) public returns (address) {\r\n        PlatformTokenVendor newPlatformTokenVendor = new PlatformTokenVendor(_rewardsToken);\r\n        return address(newPlatformTokenVendor);\r\n    }\r\n}\r\n\r\nabstract contract HeadlessStakingRewards is\r\n    ContextUpgradeable,\r\n    InitializableRewardsDistributionRecipient\r\n{\r\n    using SafeERC20 for IERC20;\r\n    using StableMath for uint256;\r\n\r\n    /// @notice token the rewards are distributed in. eg MTA\r\n    IERC20 public immutable REWARDS_TOKEN;\r\n\r\n    /// @notice length of each staking period in seconds. 7 days = 604,800; 3 months = 7,862,400\r\n    uint256 public constant DURATION = 1 weeks;\r\n\r\n    /// @notice contract that holds the platform tokens\r\n    address public rewardTokenVendor;\r\n\r\n    struct Data {\r\n        /// Timestamp for current period finish\r\n        uint32 periodFinish;\r\n        /// Last time any user took action\r\n        uint32 lastUpdateTime;\r\n        /// RewardRate for the rest of the period\r\n        uint96 rewardRate;\r\n        /// Ever increasing rewardPerToken rate, based on % of total supply\r\n        uint96 rewardPerTokenStored;\r\n    }\r\n\r\n    struct UserData {\r\n        uint128 rewardPerTokenPaid;\r\n        uint128 rewards;\r\n    }\r\n\r\n    Data public globalData;\r\n    mapping(address => UserData) public userData;\r\n    uint256 public pendingAdditionalReward;\r\n\r\n    event RewardAdded(uint256 reward);\r\n    event RewardPaid(address indexed user, address indexed to, uint256 reward);\r\n\r\n    /**\r\n     * @param _nexus mStable system Nexus address\r\n     * @param _rewardsToken first token that is being distributed as a reward. eg MTA\r\n     */\r\n    constructor(address _nexus, address _rewardsToken)\r\n        InitializableRewardsDistributionRecipient(_nexus)\r\n    {\r\n        REWARDS_TOKEN = IERC20(_rewardsToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Initialization function for upgradable proxy contract.\r\n     *      This function should be called via Proxy just after contract deployment.\r\n     *      To avoid variable shadowing appended `Arg` after arguments name.\r\n     * @param _rewardsDistributorArg mStable Reward Distributor contract address\r\n     */\r\n    function _initialize(address _rewardsDistributorArg) internal virtual override {\r\n        InitializableRewardsDistributionRecipient._initialize(_rewardsDistributorArg);\r\n        rewardTokenVendor = PlatformTokenVendorFactory.create(REWARDS_TOKEN);\r\n    }\r\n\r\n    /** @dev Updates the reward for a given address, before executing function */\r\n    modifier updateReward(address _account) {\r\n        _updateReward(_account);\r\n        _;\r\n    }\r\n\r\n    function _updateReward(address _account) internal {\r\n        // Setting of global vars\r\n        (uint256 newRewardPerToken, uint256 lastApplicableTime) = _rewardPerToken();\r\n        // If statement protects against loss in initialisation case\r\n        if (newRewardPerToken > 0) {\r\n            globalData.rewardPerTokenStored = SafeCast.toUint96(newRewardPerToken);\r\n            globalData.lastUpdateTime = SafeCast.toUint32(lastApplicableTime);\r\n            // Setting of personal vars based on new globals\r\n            if (_account != address(0)) {\r\n                userData[_account] = UserData({\r\n                    rewardPerTokenPaid: SafeCast.toUint128(newRewardPerToken),\r\n                    rewards: SafeCast.toUint128(_earned(_account, newRewardPerToken))\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    ACTIONS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Claims outstanding rewards for the sender.\r\n     * First updates outstanding reward allocation and then transfers.\r\n     */\r\n    function claimReward(address _to) public {\r\n        _claimReward(_to);\r\n    }\r\n\r\n    /**\r\n     * @dev Claims outstanding rewards for the sender.\r\n     * First updates outstanding reward allocation and then transfers.\r\n     */\r\n    function claimReward() public {\r\n        _claimReward(_msgSender());\r\n    }\r\n\r\n    function _claimReward(address _to) internal updateReward(_msgSender()) {\r\n        uint128 reward = userData[_msgSender()].rewards;\r\n        if (reward > 0) {\r\n            userData[_msgSender()].rewards = 0;\r\n            REWARDS_TOKEN.safeTransferFrom(rewardTokenVendor, _to, reward);\r\n            emit RewardPaid(_msgSender(), _to, reward);\r\n        }\r\n        _claimRewardHook(_msgSender());\r\n    }\r\n\r\n    /***************************************\r\n                    GETTERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Gets the RewardsToken\r\n     */\r\n    function getRewardToken() external view override returns (IERC20) {\r\n        return REWARDS_TOKEN;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the last applicable timestamp for this reward period\r\n     */\r\n    function lastTimeRewardApplicable() public view returns (uint256) {\r\n        return StableMath.min(block.timestamp, globalData.periodFinish);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of unclaimed rewards per token since last update,\r\n     * and sums with stored to give the new cumulative reward per token\r\n     * @return 'Reward' per staked token\r\n     */\r\n    function rewardPerToken() public view returns (uint256) {\r\n        (uint256 rewardPerToken_, ) = _rewardPerToken();\r\n        return rewardPerToken_;\r\n    }\r\n\r\n    function _rewardPerToken()\r\n        internal\r\n        view\r\n        returns (uint256 rewardPerToken_, uint256 lastTimeRewardApplicable_)\r\n    {\r\n        uint256 lastApplicableTime = lastTimeRewardApplicable(); // + 1 SLOAD\r\n        Data memory data = globalData;\r\n        uint256 timeDelta = lastApplicableTime - data.lastUpdateTime; // + 1 SLOAD\r\n        // If this has been called twice in the same block, shortcircuit to reduce gas\r\n        if (timeDelta == 0) {\r\n            return (data.rewardPerTokenStored, lastApplicableTime);\r\n        }\r\n        // new reward units to distribute = rewardRate * timeSinceLastUpdate\r\n        uint256 rewardUnitsToDistribute = data.rewardRate * timeDelta; // + 1 SLOAD\r\n        uint256 supply = totalSupply(); // + 1 SLOAD\r\n        // If there is no StakingToken liquidity, avoid div(0)\r\n        // If there is nothing to distribute, short circuit\r\n        if (supply == 0 || rewardUnitsToDistribute == 0) {\r\n            return (data.rewardPerTokenStored, lastApplicableTime);\r\n        }\r\n        // new reward units per token = (rewardUnitsToDistribute * 1e18) / totalTokens\r\n        uint256 unitsToDistributePerToken = rewardUnitsToDistribute.divPrecisely(supply);\r\n        // return summed rate\r\n        return (data.rewardPerTokenStored + unitsToDistributePerToken, lastApplicableTime); // + 1 SLOAD\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount of unclaimed rewards a user has earned\r\n     * @param _account User address\r\n     * @return Total reward amount earned\r\n     */\r\n    function earned(address _account) public view returns (uint256) {\r\n        return _earned(_account, rewardPerToken());\r\n    }\r\n\r\n    function _earned(address _account, uint256 _currentRewardPerToken)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // current rate per token - rate user previously received\r\n        uint256 userRewardDelta = _currentRewardPerToken - userData[_account].rewardPerTokenPaid; // + 1 SLOAD\r\n        // Short circuit if there is nothing new to distribute\r\n        if (userRewardDelta == 0) {\r\n            return userData[_account].rewards;\r\n        }\r\n        // new reward = staked tokens * difference in rate\r\n        uint256 userNewReward = balanceOf(_account).mulTruncate(userRewardDelta); // + 1 SLOAD\r\n        // add to previous rewards\r\n        return userData[_account].rewards + userNewReward;\r\n    }\r\n\r\n    /***************************************\r\n                    ABSTRACT\r\n    ****************************************/\r\n\r\n    function balanceOf(address account) public view virtual returns (uint256);\r\n\r\n    function totalSupply() public view virtual returns (uint256);\r\n\r\n    function _claimRewardHook(address account) internal virtual;\r\n\r\n    /***************************************\r\n                    ADMIN\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Notifies the contract that new rewards have been added.\r\n     * Calculates an updated rewardRate based on the rewards in period.\r\n     * @param _reward Units of RewardToken that have been added to the pool\r\n     */\r\n    function notifyRewardAmount(uint256 _reward)\r\n        external\r\n        override\r\n        onlyRewardsDistributor\r\n        updateReward(address(0))\r\n    {\r\n        require(_reward < 1e24, \"Notify more than a million units\");\r\n\r\n        uint256 currentTime = block.timestamp;\r\n\r\n        // Pay and reset the pendingAdditionalRewards\r\n        if (pendingAdditionalReward > 1) {\r\n            _reward += (pendingAdditionalReward - 1);\r\n            pendingAdditionalReward = 1;\r\n        }\r\n        if (_reward > 0) {\r\n            REWARDS_TOKEN.safeTransfer(rewardTokenVendor, _reward);\r\n        }\r\n\r\n        // If previous period over, reset rewardRate\r\n        if (currentTime >= globalData.periodFinish) {\r\n            globalData.rewardRate = SafeCast.toUint96(_reward / DURATION);\r\n        }\r\n        // If additional reward to existing period, calc sum\r\n        else {\r\n            uint256 remainingSeconds = globalData.periodFinish - currentTime;\r\n            uint256 leftover = remainingSeconds * globalData.rewardRate;\r\n            globalData.rewardRate = SafeCast.toUint96((_reward + leftover) / DURATION);\r\n        }\r\n\r\n        globalData.lastUpdateTime = SafeCast.toUint32(currentTime);\r\n        globalData.periodFinish = SafeCast.toUint32(currentTime + DURATION);\r\n\r\n        emit RewardAdded(_reward);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the child contract to notify of any additional rewards that have accrued.\r\n     *      Trusts that this is called honestly.\r\n     * @param _additionalReward Units of additional RewardToken to add at the next notification\r\n     */\r\n    function _notifyAdditionalReward(uint256 _additionalReward) internal virtual {\r\n        require(_additionalReward < 1e24, \"Cannot notify with more than a million units\");\r\n\r\n        pendingAdditionalReward += _additionalReward;\r\n    }\r\n}\r\n\r\nlibrary SignatureVerifier {\r\n    function verify(\r\n        address signer,\r\n        address account,\r\n        uint256[] calldata ids,\r\n        bytes calldata signature\r\n    ) external pure returns (bool) {\r\n        bytes32 messageHash = getMessageHash(account, ids);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\r\n    }\r\n\r\n    function verify(\r\n        address signer,\r\n        uint256 id,\r\n        address[] calldata accounts,\r\n        bytes calldata signature\r\n    ) external pure returns (bool) {\r\n        bytes32 messageHash = getMessageHash(id, accounts);\r\n        bytes32 ethSignedMessageHash = getEthSignedMessageHash(messageHash);\r\n\r\n        return recoverSigner(ethSignedMessageHash, signature) == signer;\r\n    }\r\n\r\n    function getMessageHash(address account, uint256[] memory ids) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(account, ids));\r\n    }\r\n    function getMessageHash(uint256 id, address[] memory accounts) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(id, accounts));\r\n    }\r\n\r\n    function getEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash));\r\n    }\r\n\r\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature)\r\n        internal\r\n        pure\r\n        returns (address)\r\n    {\r\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\r\n\r\n        return ecrecover(_ethSignedMessageHash, v, r, s);\r\n    }\r\n\r\n    function splitSignature(bytes memory signature)\r\n        internal\r\n        pure\r\n        returns (\r\n            bytes32 r,\r\n            bytes32 s,\r\n            uint8 v\r\n        )\r\n    {\r\n        require(signature.length == 65, \"invalid signature length\");\r\n\r\n        //solium-disable-next-line\r\n        assembly {\r\n            r := mload(add(signature, 32))\r\n            s := mload(add(signature, 64))\r\n            v := byte(0, mload(add(signature, 96)))\r\n        }\r\n    }\r\n}\r\n\r\ninterface IQuestManager {\r\n    event QuestAdded(\r\n        address questMaster,\r\n        uint256 id,\r\n        QuestType model,\r\n        uint16 multiplier,\r\n        QuestStatus status,\r\n        uint32 expiry\r\n    );\r\n    event QuestCompleteQuests(address indexed user, uint256[] ids);\r\n    event QuestCompleteUsers(uint256 indexed questId, address[] accounts);\r\n    event QuestExpired(uint16 indexed id);\r\n    event QuestMaster(address oldQuestMaster, address newQuestMaster);\r\n    event QuestSeasonEnded();\r\n    event QuestSigner(address oldQuestSigner, address newQuestSigner);\r\n    event StakedTokenAdded(address stakedToken);\r\n\r\n    // GETTERS\r\n    function balanceData(address _account) external view returns (QuestBalance memory);\r\n\r\n    function getQuest(uint256 _id) external view returns (Quest memory);\r\n\r\n    function hasCompleted(address _account, uint256 _id) external view returns (bool);\r\n\r\n    function questMaster() external view returns (address);\r\n\r\n    function seasonEpoch() external view returns (uint32);\r\n\r\n    // ADMIN\r\n    function addQuest(\r\n        QuestType _model,\r\n        uint8 _multiplier,\r\n        uint32 _expiry\r\n    ) external;\r\n\r\n    function addStakedToken(address _stakedToken) external;\r\n\r\n    function expireQuest(uint16 _id) external;\r\n\r\n    function setQuestMaster(address _newQuestMaster) external;\r\n\r\n    function setQuestSigner(address _newQuestSigner) external;\r\n\r\n    function startNewQuestSeason() external;\r\n\r\n    // USER\r\n    function completeUserQuests(\r\n        address _account,\r\n        uint256[] memory _ids,\r\n        bytes calldata _signature\r\n    ) external;\r\n\r\n    function completeQuestUsers(\r\n        uint256 _questId,\r\n        address[] memory _accounts,\r\n        bytes calldata _signature\r\n    ) external;\r\n\r\n    function checkForSeasonFinish(address _account) external returns (uint8 newQuestMultiplier);\r\n}\r\n\r\ncontract QuestManager is IQuestManager, Initializable, ContextUpgradeable, ImmutableModule {\r\n    /// @notice Tracks the completion of each quest (user => questId => completion)\r\n    mapping(address => mapping(uint256 => bool)) private _questCompletion;\r\n\r\n    /// @notice User balance structs containing all data needed to scale balance\r\n    mapping(address => QuestBalance) internal _balances;\r\n\r\n    /// @notice List of quests, whose ID corresponds to their position in the array (from 0)\r\n    Quest[] private _quests;\r\n    /// @notice Timestamp at which the current season started\r\n    uint32 public override seasonEpoch;\r\n    /// @notice Timestamp at which the contract was created\r\n    uint32 public startTime;\r\n\r\n    /// @notice A whitelisted questMaster who can administer quests including signing user quests are completed.\r\n    address public override questMaster;\r\n    /// @notice account that can sign a user's quest as being completed.\r\n    address internal _questSigner;\r\n\r\n    /// @notice List of all staking tokens\r\n    address[] internal _stakedTokens;\r\n\r\n    /**\r\n     * @param _nexus System nexus\r\n     */\r\n    constructor(address _nexus) ImmutableModule(_nexus) {}\r\n\r\n    /**\r\n     * @param _questMaster account that can sign user quests as completed\r\n     * @param _questSignerArg account that can sign user quests as completed\r\n     */\r\n    function initialize(address _questMaster, address _questSignerArg) external initializer {\r\n        startTime = SafeCast.toUint32(block.timestamp);\r\n        questMaster = _questMaster;\r\n        _questSigner = _questSignerArg;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that _msgSender is either governor or the quest master\r\n     */\r\n    modifier questMasterOrGovernor() {\r\n        _questMasterOrGovernor();\r\n        _;\r\n    }\r\n\r\n    function _questMasterOrGovernor() internal view {\r\n        require(_msgSender() == questMaster || _msgSender() == _governor(), \"Not verified\");\r\n    }\r\n\r\n    /***************************************\r\n                    Getters\r\n    ****************************************/\r\n\r\n    /**\r\n     * @notice Gets raw quest data\r\n     */\r\n    function getQuest(uint256 _id) external view override returns (Quest memory) {\r\n        return _quests[_id];\r\n    }\r\n\r\n    /**\r\n     * @dev Simply checks if a given user has already completed a given quest\r\n     * @param _account User address\r\n     * @param _id Position of quest in array\r\n     * @return bool with completion status\r\n     */\r\n    function hasCompleted(address _account, uint256 _id) public view override returns (bool) {\r\n        return _questCompletion[_account][_id];\r\n    }\r\n\r\n    /**\r\n     * @notice Raw quest balance\r\n     */\r\n    function balanceData(address _account) external view override returns (QuestBalance memory) {\r\n        return _balances[_account];\r\n    }\r\n\r\n    /***************************************\r\n                    Admin\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Sets the quest master that can administoer quests. eg add, expire and start seasons.\r\n     */\r\n    function setQuestMaster(address _newQuestMaster) external override questMasterOrGovernor {\r\n        emit QuestMaster(questMaster, _newQuestMaster);\r\n\r\n        questMaster = _newQuestMaster;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the quest signer that can sign user quests as being completed.\r\n     */\r\n    function setQuestSigner(address _newQuestSigner) external override onlyGovernor {\r\n        emit QuestSigner(_questSigner, _newQuestSigner);\r\n\r\n        _questSigner = _newQuestSigner;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds a new stakedToken\r\n     */\r\n    function addStakedToken(address _stakedToken) external override onlyGovernor {\r\n        require(_stakedToken != address(0), \"Invalid StakedToken\");\r\n\r\n        _stakedTokens.push(_stakedToken);\r\n\r\n        emit StakedTokenAdded(_stakedToken);\r\n    }\r\n\r\n    /***************************************\r\n                    QUESTS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Called by questMasters to add a new quest to the system with default 'ACTIVE' status\r\n     * @param _model Type of quest rewards multiplier (does it last forever or just for the season).\r\n     * @param _multiplier Multiplier, from 1 == 1.01x to 100 == 2.00x\r\n     * @param _expiry Timestamp at which quest expires. Note that permanent quests should still be given a timestamp.\r\n     */\r\n    function addQuest(\r\n        QuestType _model,\r\n        uint8 _multiplier,\r\n        uint32 _expiry\r\n    ) external override questMasterOrGovernor {\r\n        require(_expiry > block.timestamp + 1 days, \"Quest window too small\");\r\n        require(_multiplier > 0 && _multiplier <= 50, \"Quest multiplier too large > 1.5x\");\r\n\r\n        _quests.push(\r\n            Quest({\r\n                model: _model,\r\n                multiplier: _multiplier,\r\n                status: QuestStatus.ACTIVE,\r\n                expiry: _expiry\r\n            })\r\n        );\r\n\r\n        emit QuestAdded(\r\n            msg.sender,\r\n            _quests.length - 1,\r\n            _model,\r\n            _multiplier,\r\n            QuestStatus.ACTIVE,\r\n            _expiry\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Called by questMasters to expire a quest, setting it's status as EXPIRED. After which it can\r\n     * no longer be completed.\r\n     * @param _id Quest ID (its position in the array)\r\n     */\r\n    function expireQuest(uint16 _id) external override questMasterOrGovernor {\r\n        require(_id < _quests.length, \"Quest does not exist\");\r\n        require(_quests[_id].status == QuestStatus.ACTIVE, \"Quest already expired\");\r\n\r\n        _quests[_id].status = QuestStatus.EXPIRED;\r\n        if (block.timestamp < _quests[_id].expiry) {\r\n            _quests[_id].expiry = SafeCast.toUint32(block.timestamp);\r\n        }\r\n\r\n        emit QuestExpired(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by questMasters to start a new quest season. After this, all current\r\n     * seasonMultipliers will be reduced at the next user action (or triggered manually).\r\n     * In order to reduce cost for any keepers, it is suggested to add quests at the start\r\n     * of a new season to incentivise user actions.\r\n     * A new season can only begin after 9 months has passed.\r\n     */\r\n    function startNewQuestSeason() external override questMasterOrGovernor {\r\n        require(block.timestamp > (startTime + 39 weeks), \"First season has not elapsed\");\r\n        require(block.timestamp > (seasonEpoch + 39 weeks), \"Season has not elapsed\");\r\n\r\n        uint256 len = _quests.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            Quest memory quest = _quests[i];\r\n            if (quest.model == QuestType.SEASONAL) {\r\n                require(\r\n                    quest.status == QuestStatus.EXPIRED || block.timestamp > quest.expiry,\r\n                    \"All seasonal quests must have expired\"\r\n                );\r\n            }\r\n        }\r\n\r\n        seasonEpoch = SafeCast.toUint32(block.timestamp);\r\n\r\n        emit QuestSeasonEnded();\r\n    }\r\n\r\n    /***************************************\r\n                    USER\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Called by anyone to complete one or more quests for a staker. The user must first collect a signed message\r\n     * from the whitelisted _signer.\r\n     * @param _account Account that has completed the quest\r\n     * @param _ids Quest IDs (its position in the array)\r\n     * @param _signature Signature from the verified _questSigner, containing keccak hash of account & ids\r\n     */\r\n    function completeUserQuests(\r\n        address _account,\r\n        uint256[] memory _ids,\r\n        bytes calldata _signature\r\n    ) external override {\r\n        uint256 len = _ids.length;\r\n        require(len > 0, \"No quest IDs\");\r\n\r\n        uint8 questMultiplier = checkForSeasonFinish(_account);\r\n\r\n        // For each quest\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(_validQuest(_ids[i]), \"Invalid Quest ID\");\r\n            require(!hasCompleted(_account, _ids[i]), \"Quest already completed\");\r\n            require(\r\n                SignatureVerifier.verify(_questSigner, _account, _ids, _signature),\r\n                \"Invalid Quest Signer Signature\"\r\n            );\r\n\r\n            // Store user quest has completed\r\n            _questCompletion[_account][_ids[i]] = true;\r\n\r\n            // Update multiplier\r\n            Quest memory quest = _quests[_ids[i]];\r\n            if (quest.model == QuestType.PERMANENT) {\r\n                _balances[_account].permMultiplier += quest.multiplier;\r\n            } else {\r\n                _balances[_account].seasonMultiplier += quest.multiplier;\r\n            }\r\n            questMultiplier += quest.multiplier;\r\n        }\r\n\r\n        uint256 len2 = _stakedTokens.length;\r\n        for (uint256 i = 0; i < len2; i++) {\r\n            IStakedToken(_stakedTokens[i]).applyQuestMultiplier(_account, questMultiplier);\r\n        }\r\n\r\n        emit QuestCompleteQuests(_account, _ids);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by anyone to complete one or more accounts for a quest. The user must first collect a signed message\r\n     * from the whitelisted _questMaster.\r\n     * @param _questId Quest ID (its position in the array)\r\n     * @param _accounts Accounts that has completed the quest\r\n     * @param _signature Signature from the verified _questMaster, containing keccak hash of id and accounts\r\n     */\r\n    function completeQuestUsers(\r\n        uint256 _questId,\r\n        address[] memory _accounts,\r\n        bytes calldata _signature\r\n    ) external override {\r\n        require(_validQuest(_questId), \"Invalid Quest ID\");\r\n        uint256 len = _accounts.length;\r\n        require(len > 0, \"No accounts\");\r\n        require(\r\n            SignatureVerifier.verify(_questSigner, _questId, _accounts, _signature),\r\n            \"Invalid Quest Signer Signature\"\r\n        );\r\n\r\n        Quest memory quest = _quests[_questId];\r\n\r\n        // For each user account\r\n        for (uint256 i = 0; i < len; i++) {\r\n            require(!hasCompleted(_accounts[i], _questId), \"Quest already completed\");\r\n\r\n            // store user quest has completed\r\n            _questCompletion[_accounts[i]][_questId] = true;\r\n\r\n            // _applyQuestMultiplier(_accounts[i], quests);\r\n            uint8 questMultiplier = checkForSeasonFinish(_accounts[i]);\r\n\r\n            // Update multiplier\r\n            if (quest.model == QuestType.PERMANENT) {\r\n                _balances[_accounts[i]].permMultiplier += quest.multiplier;\r\n            } else {\r\n                _balances[_accounts[i]].seasonMultiplier += quest.multiplier;\r\n            }\r\n            questMultiplier += quest.multiplier;\r\n\r\n            uint256 len2 = _stakedTokens.length;\r\n            for (uint256 j = 0; j < len2; j++) {\r\n                IStakedToken(_stakedTokens[j]).applyQuestMultiplier(_accounts[i], questMultiplier);\r\n            }\r\n        }\r\n\r\n        emit QuestCompleteUsers(_questId, _accounts);\r\n    }\r\n\r\n    /**\r\n     * @dev Simply checks if a quest is valid. Quests are valid if their id exists,\r\n     * they have an ACTIVE status and they have not yet reached their expiry timestamp.\r\n     * @param _id Position of quest in array\r\n     * @return bool with validity status\r\n     */\r\n    function _validQuest(uint256 _id) internal view returns (bool) {\r\n        return\r\n            _id < _quests.length &&\r\n            _quests[_id].status == QuestStatus.ACTIVE &&\r\n            block.timestamp < _quests[_id].expiry;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the season has just finished between now and the users last action.\r\n     * If it has, we reset the seasonMultiplier. Either way, we update the lastAction for the user.\r\n     * NOTE - it is important that this is called as a hook before each state change operation\r\n     * @param _account Address of user that should be updated\r\n     */\r\n    function checkForSeasonFinish(address _account)\r\n        public\r\n        override\r\n        returns (uint8 newQuestMultiplier)\r\n    {\r\n        QuestBalance storage balance = _balances[_account];\r\n        // If the last action was before current season, then reset the season timing\r\n        if (_hasFinishedSeason(balance.lastAction)) {\r\n            // Remove 85% of the multiplier gained in this season\r\n            balance.seasonMultiplier = (balance.seasonMultiplier * 15) / 100;\r\n            balance.lastAction = SafeCast.toUint32(block.timestamp);\r\n        }\r\n        return balance.seasonMultiplier + balance.permMultiplier;\r\n    }\r\n\r\n    /**\r\n     * @dev Simple view fn to check if the users last action was before the starting of the current season\r\n     */\r\n    function _hasFinishedSeason(uint32 _lastAction) internal view returns (bool) {\r\n        return _lastAction < seasonEpoch;\r\n    }\r\n}\r\n\r\nabstract contract GamifiedToken is\r\n    ILockedERC20,\r\n    Initializable,\r\n    ContextUpgradeable,\r\n    HeadlessStakingRewards\r\n{\r\n    /// @notice name of this token (ERC20)\r\n    bytes32 private _name;\r\n    /// @notice symbol of this token (ERC20)\r\n    bytes32 private _symbol;\r\n    /// @notice number of decimals of this token (ERC20)\r\n    uint8 public constant override decimals = 18;\r\n\r\n    /// @notice User balance structs containing all data needed to scale balance\r\n    mapping(address => Balance) internal _balances;\r\n    /// @notice Most recent price coefficients per user\r\n    mapping(address => uint256) internal _userPriceCoeff;\r\n    /// @notice Quest Manager\r\n    QuestManager public immutable questManager;\r\n    /// @notice Has variable price\r\n    bool public immutable hasPriceCoeff;\r\n\r\n    /***************************************\r\n                    INIT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @param _nexus System nexus\r\n     * @param _rewardsToken Token that is being distributed as a reward. eg MTA\r\n     * @param _questManager Centralised manager of quests\r\n     * @param _hasPriceCoeff true if raw staked amount is multiplied by price coeff to get staked amount. eg BPT Staked Token\r\n     */\r\n    constructor(\r\n        address _nexus,\r\n        address _rewardsToken,\r\n        address _questManager,\r\n        bool _hasPriceCoeff\r\n    ) HeadlessStakingRewards(_nexus, _rewardsToken) {\r\n        questManager = QuestManager(_questManager);\r\n        hasPriceCoeff = _hasPriceCoeff;\r\n    }\r\n\r\n    /**\r\n     * @param _nameArg Token name\r\n     * @param _symbolArg Token symbol\r\n     * @param _rewardsDistributorArg mStable Rewards Distributor\r\n     */\r\n    function __GamifiedToken_init(\r\n        bytes32 _nameArg,\r\n        bytes32 _symbolArg,\r\n        address _rewardsDistributorArg\r\n    ) internal initializer {\r\n        __Context_init_unchained();\r\n        _name = _nameArg;\r\n        _symbol = _symbolArg;\r\n        HeadlessStakingRewards._initialize(_rewardsDistributorArg);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks that _msgSender is the quest Manager\r\n     */\r\n    modifier onlyQuestManager() {\r\n        require(_msgSender() == address(questManager), \"Not verified\");\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n                    VIEWS\r\n    ****************************************/\r\n\r\n    function name() public view override returns (string memory) {\r\n        return bytes32ToString(_name);\r\n    }\r\n\r\n    function symbol() public view override returns (string memory) {\r\n        return bytes32ToString(_symbol);\r\n    }\r\n\r\n    /**\r\n     * @dev Total sum of all scaled balances\r\n     * In this instance, leave to the child token.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        virtual\r\n        override(HeadlessStakingRewards, ILockedERC20)\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @dev Simply gets scaled balance\r\n     * @return scaled balance for user\r\n     */\r\n    function balanceOf(address _account)\r\n        public\r\n        view\r\n        virtual\r\n        override(HeadlessStakingRewards, ILockedERC20)\r\n        returns (uint256)\r\n    {\r\n        return _getBalance(_account, _balances[_account]);\r\n    }\r\n\r\n    /**\r\n     * @dev Simply gets raw balance\r\n     * @return raw balance for user\r\n     */\r\n    function rawBalanceOf(address _account) public view returns (uint256, uint256) {\r\n        return (_balances[_account].raw, _balances[_account].cooldownUnits);\r\n    }\r\n\r\n    /**\r\n     * @dev Scales the balance of a given user by applying multipliers\r\n     */\r\n    function _getBalance(address _account, Balance memory _balance)\r\n        internal\r\n        view\r\n        returns (uint256 balance)\r\n    {\r\n        // e.g. raw = 1000, questMultiplier = 40, timeMultiplier = 30. Cooldown of 60%\r\n        // e.g. 1000 * (100 + 40) / 100 = 1400\r\n        balance = (_balance.raw * (100 + _balance.questMultiplier)) / 100;\r\n        // e.g. 1400 * (100 + 30) / 100 = 1820\r\n        balance = (balance * (100 + _balance.timeMultiplier)) / 100;\r\n\r\n        if (hasPriceCoeff) {\r\n            // e.g. 1820 * 16000 / 10000 = 2912\r\n            balance = (balance * _userPriceCoeff[_account]) / 10000;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Raw staked balance without any multipliers\r\n     */\r\n    function balanceData(address _account) external view returns (Balance memory) {\r\n        return _balances[_account];\r\n    }\r\n\r\n    /**\r\n     * @notice Raw staked balance without any multipliers\r\n     */\r\n    function userPriceCoeff(address _account) external view returns (uint256) {\r\n        return _userPriceCoeff[_account];\r\n    }\r\n\r\n    /***************************************\r\n                    QUESTS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Called by anyone to poke the timestamp of a given account. This allows users to\r\n     * effectively 'claim' any new timeMultiplier, but will revert if there is no change there.\r\n     */\r\n    function reviewTimestamp(address _account) external {\r\n        _reviewWeightedTimestamp(_account);\r\n    }\r\n\r\n    /**\r\n     * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\r\n     * to check time multipliers etc.\r\n     * @param _account Address of user that should be updated\r\n     * @param _newMultiplier New Quest Multiplier\r\n     */\r\n    function applyQuestMultiplier(address _account, uint8 _newMultiplier)\r\n        external\r\n        onlyQuestManager\r\n    {\r\n        require(_account != address(0), \"Invalid address\");\r\n\r\n        // 1. Get current balance & update questMultiplier, only if user has a balance\r\n        Balance memory oldBalance = _balances[_account];\r\n        uint256 oldScaledBalance = _getBalance(_account, oldBalance);\r\n        if (oldScaledBalance > 0) {\r\n            _applyQuestMultiplier(_account, oldBalance, oldScaledBalance, _newMultiplier);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the multiplier awarded for a given weightedTimestamp\r\n     * @param _ts WeightedTimestamp of a user\r\n     * @return timeMultiplier Ranging from 20 (0.2x) to 60 (0.6x)\r\n     */\r\n    function _timeMultiplier(uint32 _ts) internal view returns (uint8 timeMultiplier) {\r\n        // If the user has no ts yet, they are not in the system\r\n        if (_ts == 0) return 0;\r\n\r\n        uint256 hodlLength = block.timestamp - _ts;\r\n        if (hodlLength < 13 weeks) {\r\n            // 0-3 months = 1x\r\n            return 0;\r\n        } else if (hodlLength < 26 weeks) {\r\n            // 3 months = 1.2x\r\n            return 20;\r\n        } else if (hodlLength < 52 weeks) {\r\n            // 6 months = 1.3x\r\n            return 30;\r\n        } else if (hodlLength < 78 weeks) {\r\n            // 12 months = 1.4x\r\n            return 40;\r\n        } else if (hodlLength < 104 weeks) {\r\n            // 18 months = 1.5x\r\n            return 50;\r\n        } else {\r\n            // > 24 months = 1.6x\r\n            return 60;\r\n        }\r\n    }\r\n\r\n    function _getPriceCoeff() internal virtual returns (uint256) {\r\n        return 10000;\r\n    }\r\n\r\n    /***************************************\r\n                BALANCE CHANGES\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Adds the multiplier awarded from quest completion to a users data, taking the opportunity\r\n     * to check time multiplier.\r\n     * @param _account Address of user that should be updated\r\n     * @param _newMultiplier New Quest Multiplier\r\n     */\r\n    function _applyQuestMultiplier(\r\n        address _account,\r\n        Balance memory _oldBalance,\r\n        uint256 _oldScaledBalance,\r\n        uint8 _newMultiplier\r\n    ) private updateReward(_account) {\r\n        // 1. Set the questMultiplier\r\n        _balances[_account].questMultiplier = _newMultiplier;\r\n\r\n        // 2. Take the opportunity to set weighted timestamp, if it changes\r\n        _balances[_account].timeMultiplier = _timeMultiplier(_oldBalance.weightedTimestamp);\r\n\r\n        // 3. Update scaled balance\r\n        _settleScaledBalance(_account, _oldScaledBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Entering a cooldown period means a user wishes to withdraw. With this in mind, their balance\r\n     * should be reduced until they have shown more commitment to the system\r\n     * @param _account Address of user that should be cooled\r\n     * @param _units Units to cooldown for\r\n     */\r\n    function _enterCooldownPeriod(address _account, uint256 _units)\r\n        internal\r\n        updateReward(_account)\r\n    {\r\n        require(_account != address(0), \"Invalid address\");\r\n\r\n        // 1. Get current balance\r\n        (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(_account);\r\n        uint88 totalUnits = oldBalance.raw + oldBalance.cooldownUnits;\r\n        require(_units > 0 && _units <= totalUnits, \"Must choose between 0 and 100%\");\r\n\r\n        // 2. Set weighted timestamp and enter cooldown\r\n        _balances[_account].timeMultiplier = _timeMultiplier(oldBalance.weightedTimestamp);\r\n        // e.g. 1e18 / 1e16 = 100, 2e16 / 1e16 = 2, 1e15/1e16 = 0\r\n        _balances[_account].raw = totalUnits - SafeCastExtended.toUint88(_units);\r\n\r\n        // 3. Set cooldown data\r\n        _balances[_account].cooldownTimestamp = SafeCastExtended.toUint32(block.timestamp);\r\n        _balances[_account].cooldownUnits = SafeCastExtended.toUint88(_units);\r\n\r\n        // 4. Update scaled balance\r\n        _settleScaledBalance(_account, oldScaledBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Exiting the cooldown period explicitly resets the users cooldown window and their balance\r\n     * @param _account Address of user that should be exited\r\n     */\r\n    function _exitCooldownPeriod(address _account) internal updateReward(_account) {\r\n        require(_account != address(0), \"Invalid address\");\r\n\r\n        // 1. Get current balance\r\n        (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(_account);\r\n\r\n        // 2. Set weighted timestamp and exit cooldown\r\n        _balances[_account].timeMultiplier = _timeMultiplier(oldBalance.weightedTimestamp);\r\n        _balances[_account].raw += oldBalance.cooldownUnits;\r\n\r\n        // 3. Set cooldown data\r\n        _balances[_account].cooldownTimestamp = 0;\r\n        _balances[_account].cooldownUnits = 0;\r\n\r\n        // 4. Update scaled balance\r\n        _settleScaledBalance(_account, oldScaledBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Pokes the weightedTimestamp of a given user and checks if it entitles them\r\n     * to a better timeMultiplier. If not, it simply reverts as there is nothing to update.\r\n     * @param _account Address of user that should be updated\r\n     */\r\n    function _reviewWeightedTimestamp(address _account) internal updateReward(_account) {\r\n        require(_account != address(0), \"Invalid address\");\r\n\r\n        // 1. Get current balance\r\n        (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(_account);\r\n\r\n        // 2. Set weighted timestamp, if it changes\r\n        uint8 newTimeMultiplier = _timeMultiplier(oldBalance.weightedTimestamp);\r\n        require(newTimeMultiplier != oldBalance.timeMultiplier, \"Nothing worth poking here\");\r\n        _balances[_account].timeMultiplier = newTimeMultiplier;\r\n\r\n        // 3. Update scaled balance\r\n        _settleScaledBalance(_account, oldScaledBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Called to mint from raw tokens. Adds raw to a users balance, and then propagates the scaledBalance.\r\n     * Importantly, when a user stakes more, their weightedTimestamp is reduced proportionate to their stake.\r\n     * @param _account Address of user to credit\r\n     * @param _rawAmount Raw amount of tokens staked\r\n     * @param _exitCooldown Should we end any cooldown?\r\n     */\r\n    function _mintRaw(\r\n        address _account,\r\n        uint256 _rawAmount,\r\n        bool _exitCooldown\r\n    ) internal updateReward(_account) {\r\n        require(_account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        // 1. Get and update current balance\r\n        (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(_account);\r\n        uint88 totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\r\n        _balances[_account].raw = oldBalance.raw + SafeCastExtended.toUint88(_rawAmount);\r\n\r\n        // 2. Exit cooldown if necessary\r\n        if (_exitCooldown) {\r\n            _balances[_account].raw += oldBalance.cooldownUnits;\r\n            _balances[_account].cooldownTimestamp = 0;\r\n            _balances[_account].cooldownUnits = 0;\r\n        }\r\n\r\n        // 3. Set weighted timestamp\r\n        //  i) For new _account, set up weighted timestamp\r\n        if (oldBalance.weightedTimestamp == 0) {\r\n            _balances[_account].weightedTimestamp = SafeCastExtended.toUint32(block.timestamp);\r\n            _mintScaled(_account, _getBalance(_account, _balances[_account]));\r\n            return;\r\n        }\r\n        //  ii) For previous minters, recalculate time held\r\n        //      Calc new weighted timestamp\r\n        uint256 oldWeightedSecondsHeld = (block.timestamp - oldBalance.weightedTimestamp) *\r\n            totalRaw;\r\n        uint256 newSecondsHeld = oldWeightedSecondsHeld / (totalRaw + (_rawAmount / 2));\r\n        uint32 newWeightedTs = SafeCastExtended.toUint32(block.timestamp - newSecondsHeld);\r\n        _balances[_account].weightedTimestamp = newWeightedTs;\r\n\r\n        uint8 timeMultiplier = _timeMultiplier(newWeightedTs);\r\n        _balances[_account].timeMultiplier = timeMultiplier;\r\n\r\n        // 3. Update scaled balance\r\n        _settleScaledBalance(_account, oldScaledBalance);\r\n    }\r\n\r\n    /**\r\n     * @dev Called to burn a given amount of raw tokens.\r\n     * @param _account Address of user\r\n     * @param _rawAmount Raw amount of tokens to remove\r\n     * @param _exitCooldown Exit the cooldown?\r\n     * @param _finalise Has recollateralisation happened? If so, everything is cooled down\r\n     */\r\n    function _burnRaw(\r\n        address _account,\r\n        uint256 _rawAmount,\r\n        bool _exitCooldown,\r\n        bool _finalise\r\n    ) internal updateReward(_account) {\r\n        require(_account != address(0), \"ERC20: burn from zero address\");\r\n\r\n        // 1. Get and update current balance\r\n        (Balance memory oldBalance, uint256 oldScaledBalance) = _prepareOldBalance(_account);\r\n        uint256 totalRaw = oldBalance.raw + oldBalance.cooldownUnits;\r\n        // 1.1. If _finalise, move everything to cooldown\r\n        if (_finalise) {\r\n            _balances[_account].raw = 0;\r\n            _balances[_account].cooldownUnits = SafeCastExtended.toUint88(totalRaw);\r\n            oldBalance.cooldownUnits = SafeCastExtended.toUint88(totalRaw);\r\n        }\r\n        // 1.2. Update\r\n        require(oldBalance.cooldownUnits >= _rawAmount, \"ERC20: burn amount > balance\");\r\n        unchecked {\r\n            _balances[_account].cooldownUnits -= SafeCastExtended.toUint88(_rawAmount);\r\n        }\r\n\r\n        // 2. If we are exiting cooldown, reset the balance\r\n        if (_exitCooldown) {\r\n            _balances[_account].raw += _balances[_account].cooldownUnits;\r\n            _balances[_account].cooldownTimestamp = 0;\r\n            _balances[_account].cooldownUnits = 0;\r\n        }\r\n\r\n        // 3. Set back scaled time\r\n        // e.g. stake 10 for 100 seconds, withdraw 5.\r\n        //      secondsHeld = (100 - 0) * (10 - 0.625) = 937.5\r\n        uint256 secondsHeld = (block.timestamp - oldBalance.weightedTimestamp) *\r\n            (totalRaw - (_rawAmount / 8));\r\n        //      newWeightedTs = 937.5 / 100 = 93.75\r\n        uint256 newSecondsHeld = secondsHeld / totalRaw;\r\n        uint32 newWeightedTs = SafeCastExtended.toUint32(block.timestamp - newSecondsHeld);\r\n        _balances[_account].weightedTimestamp = newWeightedTs;\r\n\r\n        uint8 timeMultiplier = _timeMultiplier(newWeightedTs);\r\n        _balances[_account].timeMultiplier = timeMultiplier;\r\n\r\n        // 4. Update scaled balance\r\n        _settleScaledBalance(_account, oldScaledBalance);\r\n    }\r\n\r\n    /***************************************\r\n                    PRIVATE\r\n    updateReward should already be called by now\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Fetches the balance of a given user, scales it, and also takes the opportunity\r\n     * to check if the season has just finished between now and their last action.\r\n     * @param _account Address of user to fetch\r\n     * @return oldBalance struct containing all balance information\r\n     * @return oldScaledBalance scaled balance after applying multipliers\r\n     */\r\n    function _prepareOldBalance(address _account)\r\n        private\r\n        returns (Balance memory oldBalance, uint256 oldScaledBalance)\r\n    {\r\n        // Get the old balance\r\n        oldBalance = _balances[_account];\r\n        oldScaledBalance = _getBalance(_account, oldBalance);\r\n        // Take the opportunity to check for season finish\r\n        _balances[_account].questMultiplier = questManager.checkForSeasonFinish(_account);\r\n        if (hasPriceCoeff) {\r\n            _userPriceCoeff[_account] = SafeCastExtended.toUint16(_getPriceCoeff());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Settles the scaled balance of a given account. The reason this is done here, is because\r\n     * in each of the write functions above, there is the chance that a users balance can go down,\r\n     * requiring to burn sacled tokens. This could happen at the end of a season when multipliers are slashed.\r\n     * This is called after updating all multipliers etc.\r\n     * @param _account Address of user that should be updated\r\n     * @param _oldScaledBalance Previous scaled balance of the user\r\n     */\r\n    function _settleScaledBalance(address _account, uint256 _oldScaledBalance) private {\r\n        uint256 newScaledBalance = _getBalance(_account, _balances[_account]);\r\n        if (newScaledBalance > _oldScaledBalance) {\r\n            _mintScaled(_account, newScaledBalance - _oldScaledBalance);\r\n        }\r\n        // This can happen if the user moves back a time class, but is unlikely to result in a negative mint\r\n        else {\r\n            _burnScaled(_account, _oldScaledBalance - newScaledBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Propagates the minting of the tokens downwards.\r\n     * @param _account Address of user that has minted\r\n     * @param _amount Amount of scaled tokens minted\r\n     */\r\n    function _mintScaled(address _account, uint256 _amount) private {\r\n        emit Transfer(address(0), _account, _amount);\r\n\r\n        _afterTokenTransfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Propagates the burning of the tokens downwards.\r\n     * @param _account Address of user that has burned\r\n     * @param _amount Amount of scaled tokens burned\r\n     */\r\n    function _burnScaled(address _account, uint256 _amount) private {\r\n        emit Transfer(_account, address(0), _amount);\r\n\r\n        _afterTokenTransfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /***************************************\r\n                    HOOKS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Triggered after a user claims rewards from the HeadlessStakingRewards. Used\r\n     * to check for season finish. If it has not, then do not spend gas updating the other vars.\r\n     * @param _account Address of user that has burned\r\n     */\r\n    function _claimRewardHook(address _account) internal override {\r\n        uint8 newMultiplier = questManager.checkForSeasonFinish(_account);\r\n        bool priceCoeffChanged = hasPriceCoeff\r\n            ? _getPriceCoeff() != _userPriceCoeff[_account]\r\n            : false;\r\n        if (newMultiplier != _balances[_account].questMultiplier || priceCoeffChanged) {\r\n            // 1. Get current balance & trigger season finish\r\n            uint256 oldScaledBalance = _getBalance(_account, _balances[_account]);\r\n            _balances[_account].questMultiplier = newMultiplier;\r\n            if (priceCoeffChanged) {\r\n                _userPriceCoeff[_account] = SafeCastExtended.toUint16(_getPriceCoeff());\r\n            }\r\n            // 3. Update scaled balance\r\n            _settleScaledBalance(_account, oldScaledBalance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unchanged from OpenZeppelin. Used in child contracts to react to any balance changes.\r\n     */\r\n    function _afterTokenTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal virtual {}\r\n\r\n    /***************************************\r\n                    Utils\r\n    ****************************************/\r\n\r\n    function bytes32ToString(bytes32 _bytes32) internal pure returns (string memory) {\r\n        uint256 i = 0;\r\n        while (i < 32 && _bytes32[i] != 0) {\r\n            i++;\r\n        }\r\n        bytes memory bytesArray = new bytes(i);\r\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\r\n            bytesArray[i] = _bytes32[i];\r\n        }\r\n        return string(bytesArray);\r\n    }\r\n\r\n    uint256[46] private __gap;\r\n}\r\n\r\ninterface IGovernanceHook {\r\n    function moveVotingPowerHook(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n}\r\n\r\nabstract contract GamifiedVotingToken is Initializable, GamifiedToken {\r\n    struct Checkpoint {\r\n        uint32 fromBlock;\r\n        uint224 votes;\r\n    }\r\n\r\n    mapping(address => address) private _delegates;\r\n    mapping(address => Checkpoint[]) private _checkpoints;\r\n    Checkpoint[] private _totalSupplyCheckpoints;\r\n\r\n    IGovernanceHook private _governanceHook;\r\n\r\n    event GovernanceHookChanged(address indexed hook);\r\n\r\n    /**\r\n     * @dev Emitted when an account changes their delegate.\r\n     */\r\n    event DelegateChanged(\r\n        address indexed delegator,\r\n        address indexed fromDelegate,\r\n        address indexed toDelegate\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.\r\n     */\r\n    event DelegateVotesChanged(\r\n        address indexed delegate,\r\n        uint256 previousBalance,\r\n        uint256 newBalance\r\n    );\r\n\r\n    constructor(\r\n        address _nexus,\r\n        address _rewardsToken,\r\n        address _questManager,\r\n        bool _hasPriceCoeff\r\n    ) GamifiedToken(_nexus, _rewardsToken, _questManager, _hasPriceCoeff) {}\r\n\r\n    function __GamifiedVotingToken_init() internal initializer {}\r\n\r\n    /**\r\n     * @dev\r\n     */\r\n    function setGovernanceHook(address _newHook) external onlyGovernor {\r\n        _governanceHook = IGovernanceHook(_newHook);\r\n\r\n        emit GovernanceHookChanged(_newHook);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the `pos`-th checkpoint for `account`.\r\n     */\r\n    function checkpoints(address account, uint32 pos)\r\n        public\r\n        view\r\n        virtual\r\n        returns (Checkpoint memory)\r\n    {\r\n        return _checkpoints[account][pos];\r\n    }\r\n\r\n    /**\r\n     * @dev Get number of checkpoints for `account`.\r\n     */\r\n    function numCheckpoints(address account) public view virtual returns (uint32) {\r\n        return SafeCast.toUint32(_checkpoints[account].length);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the address `account` is currently delegating to.\r\n     */\r\n    function delegates(address account) public view virtual returns (address) {\r\n        // Override as per https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/master/contracts/token/ERC20/extensions/ERC20VotesUpgradeable.sol#L23\r\n        // return _delegates[account];\r\n        address delegatee = _delegates[account];\r\n        return delegatee == address(0) ? account : delegatee;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the current votes balance for `account`\r\n     */\r\n    function getVotes(address account) public view returns (uint256) {\r\n        uint256 pos = _checkpoints[account].length;\r\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `blockNumber` must have been already mined\r\n     */\r\n    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {\r\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\r\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\r\n    }\r\n\r\n    /**\r\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\r\n     * It is but NOT the sum of all the delegated votes!\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `blockNumber` must have been already mined\r\n     */\r\n    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {\r\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\r\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\r\n    }\r\n\r\n    /**\r\n     * @dev Total sum of all scaled balances\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        uint256 len = _totalSupplyCheckpoints.length;\r\n        if (len == 0) return 0;\r\n        return _totalSupplyCheckpoints[len - 1].votes;\r\n    }\r\n\r\n    /**\r\n     * @dev Lookup a value in a list of (sorted) checkpoints.\r\n     */\r\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber)\r\n        private\r\n        view\r\n        returns (uint256)\r\n    {\r\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\r\n        //\r\n        // During the loop, the index of the wanted checkpoint remains in the range [low, high).\r\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\r\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\r\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\r\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\r\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\r\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\r\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\r\n        // the same.\r\n        uint256 high = ckpts.length;\r\n        uint256 low = 0;\r\n        while (low < high) {\r\n            uint256 mid = MathUpgradeable.average(low, high);\r\n            if (ckpts[mid].fromBlock > blockNumber) {\r\n                high = mid;\r\n            } else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n\r\n        return high == 0 ? 0 : ckpts[high - 1].votes;\r\n    }\r\n\r\n    /**\r\n     * @dev Delegate votes from the sender to `delegatee`.\r\n     */\r\n    function delegate(address delegatee) public virtual {\r\n        return _delegate(_msgSender(), delegatee);\r\n    }\r\n\r\n    /**\r\n     * @dev Move voting power when tokens are transferred.\r\n     *\r\n     * Emits a {DelegateVotesChanged} event.\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual override {\r\n        super._afterTokenTransfer(from, to, amount);\r\n\r\n        // mint or burn, update total supply\r\n        if (from == address(0) || to == address(0)) {\r\n            _writeCheckpoint(_totalSupplyCheckpoints, to == address(0) ? _subtract : _add, amount);\r\n        }\r\n\r\n        _moveVotingPower(delegates(from), delegates(to), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Change delegation for `delegator` to `delegatee`.\r\n     *\r\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\r\n     */\r\n    function _delegate(address delegator, address delegatee) internal virtual {\r\n        address currentDelegate = delegates(delegator);\r\n        uint256 delegatorBalance = balanceOf(delegator);\r\n        _delegates[delegator] = delegatee;\r\n\r\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\r\n\r\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\r\n    }\r\n\r\n    function _moveVotingPower(\r\n        address src,\r\n        address dst,\r\n        uint256 amount\r\n    ) private {\r\n        if (src != dst && amount > 0) {\r\n            if (src != address(0)) {\r\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\r\n                    _checkpoints[src],\r\n                    _subtract,\r\n                    amount\r\n                );\r\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\r\n            }\r\n\r\n            if (dst != address(0)) {\r\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(\r\n                    _checkpoints[dst],\r\n                    _add,\r\n                    amount\r\n                );\r\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\r\n            }\r\n\r\n            if (address(_governanceHook) != address(0)) {\r\n                _governanceHook.moveVotingPowerHook(src, dst, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _writeCheckpoint(\r\n        Checkpoint[] storage ckpts,\r\n        function(uint256, uint256) view returns (uint256) op,\r\n        uint256 delta\r\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\r\n        uint256 pos = ckpts.length;\r\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\r\n        newWeight = op(oldWeight, delta);\r\n\r\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\r\n            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);\r\n        } else {\r\n            ckpts.push(\r\n                Checkpoint({\r\n                    fromBlock: SafeCast.toUint32(block.number),\r\n                    votes: SafeCast.toUint224(newWeight)\r\n                })\r\n            );\r\n        }\r\n    }\r\n\r\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a + b;\r\n    }\r\n\r\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\r\n        return a - b;\r\n    }\r\n\r\n    uint256[46] private __gap;\r\n}\r\n\r\nlibrary Root {\r\n    /**\r\n     * @dev Returns the square root of a given number\r\n     * @param x Input\r\n     * @return y Square root of Input\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\r\n        if (x == 0) return 0;\r\n        else {\r\n            uint256 xx = x;\r\n            uint256 r = 1;\r\n            if (xx >= 0x100000000000000000000000000000000) {\r\n                xx >>= 128;\r\n                r <<= 64;\r\n            }\r\n            if (xx >= 0x10000000000000000) {\r\n                xx >>= 64;\r\n                r <<= 32;\r\n            }\r\n            if (xx >= 0x100000000) {\r\n                xx >>= 32;\r\n                r <<= 16;\r\n            }\r\n            if (xx >= 0x10000) {\r\n                xx >>= 16;\r\n                r <<= 8;\r\n            }\r\n            if (xx >= 0x100) {\r\n                xx >>= 8;\r\n                r <<= 4;\r\n            }\r\n            if (xx >= 0x10) {\r\n                xx >>= 4;\r\n                r <<= 2;\r\n            }\r\n            if (xx >= 0x8) {\r\n                r <<= 1;\r\n            }\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1;\r\n            r = (r + x / r) >> 1; // Seven iterations should be enough\r\n            uint256 r1 = x / r;\r\n            return uint256(r < r1 ? r : r1);\r\n        }\r\n    }\r\n}\r\n\r\ncontract InitializableReentrancyGuard {\r\n    bool private _notEntered;\r\n\r\n    function _initializeReentrancyGuard() internal {\r\n        // Storing an initial non-zero value makes deployment a bit more\r\n        // expensive, but in exchange the refund on every call to nonReentrant\r\n        // will be lower in amount. Since refunds are capped to a percetange of\r\n        // the total transaction's gas, it is best to keep them low in cases\r\n        // like this one, to increase the likelihood of the full refund coming\r\n        // into effect.\r\n        _notEntered = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_notEntered, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _notEntered = false;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _notEntered = true;\r\n    }\r\n}\r\n\r\ncontract StakedToken is GamifiedVotingToken, InitializableReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice Core token that is staked and tracked (e.g. MTA)\r\n    IERC20 public immutable STAKED_TOKEN;\r\n    /// @notice Seconds a user must wait after she initiates her cooldown before withdrawal is possible\r\n    uint256 public immutable COOLDOWN_SECONDS;\r\n    /// @notice Window in which it is possible to withdraw, following the cooldown period\r\n    uint256 public immutable UNSTAKE_WINDOW;\r\n    /// @notice A week\r\n    uint256 private constant ONE_WEEK = 7 days;\r\n\r\n    struct SafetyData {\r\n        /// Percentage of collateralisation where 100% = 1e18\r\n        uint128 collateralisationRatio;\r\n        /// Slash % where 100% = 1e18\r\n        uint128 slashingPercentage;\r\n    }\r\n\r\n    /// @notice Data relating to the re-collateralisation safety module\r\n    SafetyData public safetyData;\r\n\r\n    /// @notice Whitelisted smart contract integrations\r\n    mapping(address => bool) public whitelistedWrappers;\r\n\r\n    event Staked(address indexed user, uint256 amount, address delegatee);\r\n    event Withdraw(address indexed user, address indexed to, uint256 amount);\r\n    event Cooldown(address indexed user, uint256 percentage);\r\n    event CooldownExited(address indexed user);\r\n    event SlashRateChanged(uint256 newRate);\r\n    event Recollateralised();\r\n    event WrapperWhitelisted(address wallet);\r\n    event WrapperBlacklisted(address wallet);\r\n\r\n    /***************************************\r\n                    INIT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @param _nexus System nexus\r\n     * @param _rewardsToken Token that is being distributed as a reward. eg MTA\r\n     * @param _questManager Centralised manager of quests\r\n     * @param _stakedToken Core token that is staked and tracked (e.g. MTA)\r\n     * @param _cooldownSeconds Seconds a user must wait after she initiates her cooldown before withdrawal is possible\r\n     * @param _unstakeWindow Window in which it is possible to withdraw, following the cooldown period\r\n     * @param _hasPriceCoeff true if raw staked amount is multiplied by price coeff to get staked amount. eg BPT Staked Token\r\n     */\r\n    constructor(\r\n        address _nexus,\r\n        address _rewardsToken,\r\n        address _questManager,\r\n        address _stakedToken,\r\n        uint256 _cooldownSeconds,\r\n        uint256 _unstakeWindow,\r\n        bool _hasPriceCoeff\r\n    ) GamifiedVotingToken(_nexus, _rewardsToken, _questManager, _hasPriceCoeff) {\r\n        STAKED_TOKEN = IERC20(_stakedToken);\r\n        COOLDOWN_SECONDS = _cooldownSeconds;\r\n        UNSTAKE_WINDOW = _unstakeWindow;\r\n    }\r\n\r\n    /**\r\n     * @param _nameArg Token name\r\n     * @param _symbolArg Token symbol\r\n     * @param _rewardsDistributorArg mStable Rewards Distributor\r\n     */\r\n    function __StakedToken_init(\r\n        bytes32 _nameArg,\r\n        bytes32 _symbolArg,\r\n        address _rewardsDistributorArg\r\n    ) public initializer {\r\n        __GamifiedToken_init(_nameArg, _symbolArg, _rewardsDistributorArg);\r\n        _initializeReentrancyGuard();\r\n        safetyData = SafetyData({ collateralisationRatio: 1e18, slashingPercentage: 0 });\r\n    }\r\n\r\n    /**\r\n     * @dev Only the recollateralisation module, as specified in the mStable Nexus, can execute this\r\n     */\r\n    modifier onlyRecollateralisationModule() {\r\n        require(_msgSender() == _recollateraliser(), \"Only Recollateralisation Module\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev This protects against fn's being called after a recollateralisation event, when the contract is essentially finished\r\n     */\r\n    modifier onlyBeforeRecollateralisation() {\r\n        _onlyBeforeRecollateralisation();\r\n        _;\r\n    }\r\n\r\n    function _onlyBeforeRecollateralisation() internal view {\r\n        require(safetyData.collateralisationRatio == 1e18, \"Only while fully collateralised\");\r\n    }\r\n\r\n    /**\r\n     * @dev Only whitelisted contracts can call core fns. mStable governors can whitelist and de-whitelist wrappers.\r\n     * Access may be given to yield optimisers to boost rewards, but creating unlimited and ungoverned wrappers is unadvised.\r\n     */\r\n    modifier assertNotContract() {\r\n        _assertNotContract();\r\n        _;\r\n    }\r\n\r\n    function _assertNotContract() internal view {\r\n        if (_msgSender() != tx.origin) {\r\n            require(whitelistedWrappers[_msgSender()], \"Not a whitelisted contract\");\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    ACTIONS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\r\n     * boosts their voting power.\r\n     * @param _amount Units of STAKED_TOKEN to stake\r\n     */\r\n    function stake(uint256 _amount) external {\r\n        _transferAndStake(_amount, address(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\r\n     * boosts their voting power.\r\n     * @param _amount Units of STAKED_TOKEN to stake\r\n     * @param _exitCooldown Bool signalling whether to take this opportunity to end any outstanding cooldown and\r\n     * return the user back to their full voting power\r\n     */\r\n    function stake(uint256 _amount, bool _exitCooldown) external {\r\n        _transferAndStake(_amount, address(0), _exitCooldown);\r\n    }\r\n\r\n    /**\r\n     * @dev Stake an `_amount` of STAKED_TOKEN in the system. This amount is added to the users stake and\r\n     * boosts their voting power. Take the opportunity to change delegatee.\r\n     * @param _amount Units of STAKED_TOKEN to stake\r\n     * @param _delegatee Address of the user to whom the sender would like to delegate their voting power\r\n     */\r\n    function stake(uint256 _amount, address _delegatee) external {\r\n        _transferAndStake(_amount, _delegatee, false);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers tokens from sender before calling `_settleStake`\r\n     */\r\n    function _transferAndStake(\r\n        uint256 _amount,\r\n        address _delegatee,\r\n        bool _exitCooldown\r\n    ) internal {\r\n        STAKED_TOKEN.safeTransferFrom(_msgSender(), address(this), _amount);\r\n        _settleStake(_amount, _delegatee, _exitCooldown);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal stake fn. Can only be called by whitelisted contracts/EOAs and only before a recollateralisation event.\r\n     * NOTE - Assumes tokens have already been transferred\r\n     * @param _amount Units of STAKED_TOKEN to stake\r\n     * @param _delegatee Address of the user to whom the sender would like to delegate their voting power\r\n     * @param _exitCooldown Bool signalling whether to take this opportunity to end any outstanding cooldown and\r\n     * return the user back to their full voting power\r\n     */\r\n    function _settleStake(\r\n        uint256 _amount,\r\n        address _delegatee,\r\n        bool _exitCooldown\r\n    ) internal onlyBeforeRecollateralisation assertNotContract {\r\n        require(_amount != 0, \"INVALID_ZERO_AMOUNT\");\r\n\r\n        // 1. Apply the delegate if it has been chosen (else it defaults to the sender)\r\n        if (_delegatee != address(0)) {\r\n            _delegate(_msgSender(), _delegatee);\r\n        }\r\n\r\n        // 2. Deal with cooldown\r\n        //      If a user is currently in a cooldown period, re-calculate their cooldown timestamp\r\n        Balance memory oldBalance = _balances[_msgSender()];\r\n        //      If we have missed the unstake window, or the user has chosen to exit the cooldown,\r\n        //      then reset the timestamp to 0\r\n        bool exitCooldown = _exitCooldown ||\r\n            (oldBalance.cooldownTimestamp > 0 &&\r\n                block.timestamp >\r\n                (oldBalance.cooldownTimestamp + COOLDOWN_SECONDS + UNSTAKE_WINDOW));\r\n        if (exitCooldown) {\r\n            emit CooldownExited(_msgSender());\r\n        }\r\n\r\n        // 3. Settle the stake by depositing the STAKED_TOKEN and minting voting power\r\n        _mintRaw(_msgSender(), _amount, exitCooldown);\r\n\r\n        emit Staked(_msgSender(), _amount, _delegatee);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\r\n     * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\r\n     * @param _amount Units of raw token to withdraw\r\n     * @param _recipient Address of beneficiary who will receive the raw tokens\r\n     * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\r\n     * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\r\n     **/\r\n    function withdraw(\r\n        uint256 _amount,\r\n        address _recipient,\r\n        bool _amountIncludesFee,\r\n        bool _exitCooldown\r\n    ) external {\r\n        _withdraw(_amount, _recipient, _amountIncludesFee, _exitCooldown);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw raw tokens from the system, following an elapsed cooldown period.\r\n     * Note - May be subject to a transfer fee, depending on the users weightedTimestamp\r\n     * @param _amount Units of raw token to withdraw\r\n     * @param _recipient Address of beneficiary who will receive the raw tokens\r\n     * @param _amountIncludesFee Is the `_amount` specified inclusive of any applicable redemption fee?\r\n     * @param _exitCooldown Should we take this opportunity to exit the cooldown period?\r\n     **/\r\n    function _withdraw(\r\n        uint256 _amount,\r\n        address _recipient,\r\n        bool _amountIncludesFee,\r\n        bool _exitCooldown\r\n    ) internal assertNotContract {\r\n        require(_amount != 0, \"INVALID_ZERO_AMOUNT\");\r\n\r\n        // Is the contract post-recollateralisation?\r\n        if (safetyData.collateralisationRatio != 1e18) {\r\n            // 1. If recollateralisation has occured, the contract is finished and we can skip all checks\r\n            _burnRaw(_msgSender(), _amount, false, true);\r\n            // 2. Return a proportionate amount of tokens, based on the collateralisation ratio\r\n            STAKED_TOKEN.safeTransfer(\r\n                _recipient,\r\n                (_amount * safetyData.collateralisationRatio) / 1e18\r\n            );\r\n            emit Withdraw(_msgSender(), _recipient, _amount);\r\n        } else {\r\n            // 1. If no recollateralisation has occured, the user must be within their UNSTAKE_WINDOW period in order to withdraw\r\n            Balance memory oldBalance = _balances[_msgSender()];\r\n            require(\r\n                block.timestamp > oldBalance.cooldownTimestamp + COOLDOWN_SECONDS,\r\n                \"INSUFFICIENT_COOLDOWN\"\r\n            );\r\n            require(\r\n                block.timestamp - (oldBalance.cooldownTimestamp + COOLDOWN_SECONDS) <=\r\n                    UNSTAKE_WINDOW,\r\n                \"UNSTAKE_WINDOW_FINISHED\"\r\n            );\r\n\r\n            // 2. Get current balance\r\n            Balance memory balance = _balances[_msgSender()];\r\n\r\n            // 3. Apply redemption fee\r\n            //      e.g. (55e18 / 5e18) - 2e18 = 9e18 / 100 = 9e16\r\n            uint256 feeRate = calcRedemptionFeeRate(balance.weightedTimestamp);\r\n            //      fee = amount * 1e18 / feeRate\r\n            //      totalAmount = amount + fee\r\n            uint256 totalWithdraw = _amountIncludesFee\r\n                ? _amount\r\n                : (_amount * (1e18 + feeRate)) / 1e18;\r\n            uint256 userWithdrawal = (totalWithdraw * 1e18) / (1e18 + feeRate);\r\n\r\n            //      Check for percentage withdrawal\r\n            uint256 maxWithdrawal = oldBalance.cooldownUnits;\r\n            require(totalWithdraw <= maxWithdrawal, \"Exceeds max withdrawal\");\r\n\r\n            // 4. Exit cooldown if the user has specified, or if they have withdrawn everything\r\n            // Otherwise, update the percentage remaining proportionately\r\n            bool exitCooldown = _exitCooldown || totalWithdraw == maxWithdrawal;\r\n\r\n            // 5. Settle the withdrawal by burning the voting tokens\r\n            _burnRaw(_msgSender(), totalWithdraw, exitCooldown, false);\r\n            //      Log any redemption fee to the rewards contract\r\n            _notifyAdditionalReward(totalWithdraw - userWithdrawal);\r\n            //      Finally transfer tokens back to recipient\r\n            STAKED_TOKEN.safeTransfer(_recipient, userWithdrawal);\r\n\r\n            emit Withdraw(_msgSender(), _recipient, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\r\n     * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\r\n     * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\r\n     * @param _units Units of stake to cooldown for\r\n     **/\r\n    function startCooldown(uint256 _units) external {\r\n        _startCooldown(_units);\r\n    }\r\n\r\n    /**\r\n     * @dev Ends the cooldown of the sender and give them back their full voting power. This can be used to signal that\r\n     * the user no longer wishes to exit the system. Note, the cooldown can also be reset, more smoothly, as part of a stake or\r\n     * withdraw transaction.\r\n     **/\r\n    function endCooldown() external {\r\n        require(_balances[_msgSender()].cooldownTimestamp != 0, \"No cooldown\");\r\n\r\n        _exitCooldownPeriod(_msgSender());\r\n\r\n        emit CooldownExited(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Enters a cooldown period, after which (and before the unstake window elapses) a user will be able\r\n     * to withdraw part or all of their staked tokens. Note, during this period, a users voting power is significantly reduced.\r\n     * If a user already has a cooldown period, then it will reset to the current block timestamp, so use wisely.\r\n     * @param _units Units of stake to cooldown for\r\n     **/\r\n    function _startCooldown(uint256 _units) internal {\r\n        require(balanceOf(_msgSender()) != 0, \"INVALID_BALANCE_ON_COOLDOWN\");\r\n\r\n        _enterCooldownPeriod(_msgSender(), _units);\r\n\r\n        emit Cooldown(_msgSender(), _units);\r\n    }\r\n\r\n    /***************************************\r\n                    ADMIN\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev This is a write function allowing the whitelisted recollateralisation module to slash stakers here and take\r\n     * the capital to use to recollateralise any lost value in the system. Trusting that the recollateralisation module has\r\n     * sufficient protections put in place. Note, once this has been executed, the contract is now finished, and undercollateralised,\r\n     * meaning that all users must withdraw, and will only receive a proportionate amount back relative to the colRatio.\r\n     **/\r\n    function emergencyRecollateralisation()\r\n        external\r\n        onlyRecollateralisationModule\r\n        onlyBeforeRecollateralisation\r\n    {\r\n        // 1. Change collateralisation rate\r\n        safetyData.collateralisationRatio = 1e18 - safetyData.slashingPercentage;\r\n        // 2. Take slashing percentage\r\n        uint256 balance = STAKED_TOKEN.balanceOf(address(this));\r\n        STAKED_TOKEN.safeTransfer(\r\n            _recollateraliser(),\r\n            (balance * safetyData.slashingPercentage) / 1e18\r\n        );\r\n        // 3. No functions should work anymore because the colRatio has changed\r\n        emit Recollateralised();\r\n    }\r\n\r\n    /**\r\n     * @dev Governance can change the slashing percentage here (initially 0). This is the amount of a stakers capital that is at\r\n     * risk in the recollateralisation process.\r\n     * @param _newRate Rate, where 50% == 5e17\r\n     **/\r\n    function changeSlashingPercentage(uint256 _newRate)\r\n        external\r\n        onlyGovernor\r\n        onlyBeforeRecollateralisation\r\n    {\r\n        require(_newRate <= 5e17, \"Cannot exceed 50%\");\r\n\r\n        safetyData.slashingPercentage = SafeCast.toUint128(_newRate);\r\n\r\n        emit SlashRateChanged(_newRate);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows governance to whitelist a smart contract to interact with the StakedToken (for example a yield aggregator or simply\r\n     * a Gnosis SAFE or other)\r\n     * @param _wrapper Address of the smart contract to list\r\n     **/\r\n    function whitelistWrapper(address _wrapper) external onlyGovernor {\r\n        whitelistedWrappers[_wrapper] = true;\r\n\r\n        emit WrapperWhitelisted(_wrapper);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows governance to blacklist a smart contract to end it's interaction with the StakedToken\r\n     * @param _wrapper Address of the smart contract to blacklist\r\n     **/\r\n    function blackListWrapper(address _wrapper) external onlyGovernor {\r\n        whitelistedWrappers[_wrapper] = false;\r\n\r\n        emit WrapperBlacklisted(_wrapper);\r\n    }\r\n\r\n    /***************************************\r\n            BACKWARDS COMPATIBILITY\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Allows for backwards compatibility with createLock fn, giving basic args to stake\r\n     * @param _value Units to stake\r\n     **/\r\n    function createLock(\r\n        uint256 _value,\r\n        uint256 /* _unlockTime */\r\n    ) external {\r\n        _transferAndStake(_value, address(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows for backwards compatibility with increaseLockAmount fn by simply staking more\r\n     * @param _value Units to stake\r\n     **/\r\n    function increaseLockAmount(uint256 _value) external {\r\n        require(balanceOf(_msgSender()) != 0, \"Nothing to increase\");\r\n        _transferAndStake(_value, address(0), false);\r\n    }\r\n\r\n    /**\r\n     * @dev Backwards compatibility. Previously a lock would run out and a user would call this. Now, it will take 2 calls\r\n     * to exit in order to leave. The first will initiate the cooldown period, and the second will execute a full withdrawal.\r\n     **/\r\n    function exit() external virtual {\r\n        // Since there is no immediate exit here, this can be called twice\r\n        // If there is no cooldown, or the cooldown has passed the unstake window, enter cooldown\r\n        uint128 ts = _balances[_msgSender()].cooldownTimestamp;\r\n        if (ts == 0 || block.timestamp > ts + COOLDOWN_SECONDS + UNSTAKE_WINDOW) {\r\n            (uint256 raw, uint256 cooldownUnits) = rawBalanceOf(_msgSender());\r\n            _startCooldown(raw + cooldownUnits);\r\n        }\r\n        // Else withdraw all available\r\n        else {\r\n            _withdraw(_balances[_msgSender()].cooldownUnits, _msgSender(), true, false);\r\n        }\r\n    }\r\n\r\n    /***************************************\r\n                    GETTERS\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev fee = sqrt(300/x)-2.5, where x = weeks since user has staked\r\n     * @param _weightedTimestamp The users weightedTimestamp\r\n     * @return _feeRate where 1% == 1e16\r\n     */\r\n    function calcRedemptionFeeRate(uint32 _weightedTimestamp)\r\n        public\r\n        view\r\n        returns (uint256 _feeRate)\r\n    {\r\n        uint256 weeksStaked = ((block.timestamp - _weightedTimestamp) * 1e18) / ONE_WEEK;\r\n        if (weeksStaked > 3e18) {\r\n            // e.g. weeks = 1  = sqrt(300e18) = 17320508075\r\n            // e.g. weeks = 10 = sqrt(30e18) =   5477225575\r\n            // e.g. weeks = 26 = sqrt(11.5) =    3391164991\r\n            _feeRate = Root.sqrt(300e36 / weeksStaked) * 1e7;\r\n            // e.g. weeks = 1  = 173e15 - 25e15 = 148e15 or 14.8%\r\n            // e.g. weeks = 10 =  55e15 - 25e15 = 30e15 or 3%\r\n            // e.g. weeks = 26 =  34e15 - 25e15 = 9e15 or 0.9%\r\n            _feeRate = _feeRate < 25e15 ? 0 : _feeRate - 25e15;\r\n        } else {\r\n            _feeRate = 75e15;\r\n        }\r\n    }\r\n\r\n    uint256[48] private __gap;\r\n}\r\n\r\nstruct ExitPoolRequest {\r\n    address[] assets;\r\n    uint256[] minAmountsOut;\r\n    bytes userData;\r\n    bool toInternalBalance;\r\n}\r\n\r\ninterface IBVault {\r\n    function exitPool(\r\n        bytes32 poolId,\r\n        address sender,\r\n        address payable recipient,\r\n        ExitPoolRequest memory request\r\n    ) external;\r\n\r\n    function getPoolTokens(bytes32 poolId)\r\n        external\r\n        view\r\n        returns (\r\n            address[] memory tokens,\r\n            uint256[] memory balances,\r\n            uint256 lastChangeBlock\r\n        );\r\n}\r\n\r\n// SPDX-License-Identifier: AGPL-3.0-or-later\r\n/**\r\n * @title StakedTokenBPT\r\n * @dev Derives from StakedToken, and simply adds the ability to withdraw any unclaimed $BAL tokens\r\n * that are at this address\r\n **/\r\ncontract StakedTokenBPT is StakedToken {\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// @notice Balancer token\r\n    IERC20 public immutable BAL;\r\n\r\n    /// @notice Balancer vault\r\n    IBVault public immutable balancerVault;\r\n\r\n    /// @notice Balancer poolId\r\n    bytes32 public immutable poolId;\r\n\r\n    /// @notice contract that can redistribute the $BAL\r\n    address public balRecipient;\r\n\r\n    /// @notice Keeper\r\n    address public keeper;\r\n\r\n    /// @notice Pending fees in BPT terms\r\n    uint256 public pendingBPTFees;\r\n\r\n    /// @notice Most recent PriceCoefficient\r\n    uint256 public priceCoefficient;\r\n\r\n    /// @notice Time of last priceCoefficient upgrade\r\n    uint256 public lastPriceUpdateTime;\r\n\r\n    event KeeperUpdated(address newKeeper);\r\n    event BalClaimed();\r\n    event BalRecipientChanged(address newRecipient);\r\n    event PriceCoefficientUpdated(uint256 newPriceCoeff);\r\n    event FeesConverted(uint256 bpt, uint256 mta);\r\n\r\n    /***************************************\r\n                    INIT\r\n    ****************************************/\r\n\r\n    /**\r\n     * @param _nexus System nexus\r\n     * @param _rewardsToken Token that is being distributed as a reward. eg MTA\r\n     * @param _stakedToken Core token that is staked and tracked (e.g. MTA)\r\n     * @param _cooldownSeconds Seconds a user must wait after she initiates her cooldown before withdrawal is possible\r\n     * @param _unstakeWindow Window in which it is possible to withdraw, following the cooldown period\r\n     * @param _bal Balancer addresses, [0] = $BAL addr, [1] = BAL vault\r\n     * @param _poolId Balancer Pool identifier\r\n     */\r\n    constructor(\r\n        address _nexus,\r\n        address _rewardsToken,\r\n        address _questManager,\r\n        address _stakedToken,\r\n        uint256 _cooldownSeconds,\r\n        uint256 _unstakeWindow,\r\n        address[2] memory _bal,\r\n        bytes32 _poolId\r\n    )\r\n        StakedToken(\r\n            _nexus,\r\n            _rewardsToken,\r\n            _questManager,\r\n            _stakedToken,\r\n            _cooldownSeconds,\r\n            _unstakeWindow,\r\n            true\r\n        )\r\n    {\r\n        BAL = IERC20(_bal[0]);\r\n        balancerVault = IBVault(_bal[1]);\r\n        poolId = _poolId;\r\n    }\r\n\r\n    /**\r\n     * @param _nameArg Token name\r\n     * @param _symbolArg Token symbol\r\n     * @param _rewardsDistributorArg mStable Rewards Distributor\r\n     * @param _balRecipient contract that can redistribute the $BAL\r\n     * @param _priceCoefficient Initial pricing coefficient\r\n     */\r\n    function initialize(\r\n        bytes32 _nameArg,\r\n        bytes32 _symbolArg,\r\n        address _rewardsDistributorArg,\r\n        address _balRecipient,\r\n        uint256 _priceCoefficient\r\n    ) external initializer {\r\n        __StakedToken_init(_nameArg, _symbolArg, _rewardsDistributorArg);\r\n        balRecipient = _balRecipient;\r\n        priceCoefficient = _priceCoefficient;\r\n    }\r\n\r\n    modifier governorOrKeeper() {\r\n        require(_msgSender() == _governor() || _msgSender() == keeper, \"Gov or keeper\");\r\n        _;\r\n    }\r\n\r\n    /***************************************\r\n                BAL incentives\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Claims any $BAL tokens present on this address as part of any potential liquidity mining program\r\n     */\r\n    function claimBal() external {\r\n        uint256 balance = BAL.balanceOf(address(this));\r\n        BAL.safeTransfer(balRecipient, balance);\r\n\r\n        emit BalClaimed();\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the recipient for any potential $BAL earnings\r\n     */\r\n    function setBalRecipient(address _newRecipient) external onlyGovernor {\r\n        balRecipient = _newRecipient;\r\n\r\n        emit BalRecipientChanged(_newRecipient);\r\n    }\r\n\r\n    /***************************************\r\n                    FEES\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Converts fees accrued in BPT into MTA, before depositing to the rewards contract\r\n     */\r\n    function convertFees() external nonReentrant {\r\n        uint256 pendingBPT = pendingBPTFees;\r\n        require(pendingBPT > 1, \"Must have something to convert\");\r\n        pendingBPTFees = 1;\r\n\r\n        // 1. Sell the BPT\r\n        uint256 stakingBalBefore = STAKED_TOKEN.balanceOf(address(this));\r\n        uint256 mtaBalBefore = REWARDS_TOKEN.balanceOf(address(this));\r\n        (address[] memory tokens, , ) = balancerVault.getPoolTokens(poolId);\r\n        require(tokens[0] == address(REWARDS_TOKEN), \"MTA in wrong place\");\r\n\r\n        // 1.1. Calculate minimum output amount\r\n        uint256[] memory minOut = new uint256[](2);\r\n        {\r\n            // 10% discount from the latest pcoeff\r\n            // e.g. 1e18 * 42000 / 11000 = 3.81e18\r\n            minOut[0] = (pendingBPT * priceCoefficient) / 11000;\r\n        }\r\n\r\n        // 1.2. Exits to here, from here. Assumes token is in position 0\r\n        balancerVault.exitPool(\r\n            poolId,\r\n            address(this),\r\n            payable(address(this)),\r\n            ExitPoolRequest(tokens, minOut, bytes(abi.encode(0, pendingBPT - 1, 0)), false)\r\n        );\r\n\r\n        // 2. Verify and update state\r\n        uint256 stakingBalAfter = STAKED_TOKEN.balanceOf(address(this));\r\n        require(\r\n            stakingBalAfter == (stakingBalBefore - pendingBPT + 1),\r\n            \"Must sell correct amount of BPT\"\r\n        );\r\n\r\n        // 3. Inform HeadlessRewards about the new rewards\r\n        uint256 received = REWARDS_TOKEN.balanceOf(address(this)) - mtaBalBefore;\r\n        require(received >= minOut[0], \"Must receive tokens\");\r\n        super._notifyAdditionalReward(received);\r\n\r\n        emit FeesConverted(pendingBPT, received);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the child contract to notify of any additional rewards that have accrued.\r\n     *      Trusts that this is called honestly.\r\n     * @param _additionalReward Units of additional RewardToken to add at the next notification\r\n     */\r\n    function _notifyAdditionalReward(uint256 _additionalReward) internal override {\r\n        require(_additionalReward < 1e24, \"more than a million units\");\r\n\r\n        pendingBPTFees += _additionalReward;\r\n    }\r\n\r\n    /***************************************\r\n                    PRICE\r\n    ****************************************/\r\n\r\n    /**\r\n     * @dev Sets the keeper that is responsible for fetching new price coefficients\r\n     */\r\n    function setKeeper(address _newKeeper) external onlyGovernor {\r\n        keeper = _newKeeper;\r\n\r\n        emit KeeperUpdated(_newKeeper);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the governor or keeper to update the price coeff\r\n     */\r\n    function fetchPriceCoefficient() external governorOrKeeper {\r\n        require(block.timestamp > lastPriceUpdateTime + 14 days, \"Max 1 update per 14 days\");\r\n\r\n        uint256 newPriceCoeff = getProspectivePriceCoefficient();\r\n        uint256 oldPriceCoeff = priceCoefficient;\r\n        uint256 diff = newPriceCoeff > oldPriceCoeff\r\n            ? newPriceCoeff - oldPriceCoeff\r\n            : oldPriceCoeff - newPriceCoeff;\r\n\r\n        // e.g. 500 * 10000 / 35000 = 5000000 / 35000 = 142\r\n        require((diff * 10000) / oldPriceCoeff > 500, \"Must be > 5% diff\");\r\n        require(newPriceCoeff > 15000 && newPriceCoeff < 75000, \"Out of bounds\");\r\n\r\n        priceCoefficient = newPriceCoeff;\r\n        lastPriceUpdateTime = block.timestamp;\r\n\r\n        emit PriceCoefficientUpdated(newPriceCoeff);\r\n    }\r\n\r\n    /**\r\n     * @dev Fetches most recent priceCoeff from the balancer pool.\r\n     * PriceCoeff = units of MTA per BPT, scaled to 1:1 = 10000\r\n     * Assuming an 80/20 BPT, it is possible to calculate\r\n     * PriceCoeff (p) = balanceOfMTA in pool (b) / bpt supply (s) / 0.8\r\n     * p = b * 1.25 / s\r\n     */\r\n    function getProspectivePriceCoefficient() public view returns (uint256 newPriceCoeff) {\r\n        (address[] memory tokens, uint256[] memory balances, ) = balancerVault.getPoolTokens(\r\n            poolId\r\n        );\r\n        require(tokens[0] == address(REWARDS_TOKEN), \"MTA in wrong place\");\r\n\r\n        // Calculate units of MTA per BPT\r\n        // e.g. 800e18 * 125e16 / 1000e18 = 1e18\r\n        // e.g. 1280e18 * 125e16 / 1000e18 = 16e17\r\n        uint256 unitsPerToken = (balances[0] * 125e16) / STAKED_TOKEN.totalSupply();\r\n        // e.g. 1e18 / 1e14 = 10000\r\n        // e.g. 16e17 / 1e14 = 16000\r\n        newPriceCoeff = unitsPerToken / 1e14;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the current priceCoeff\r\n     */\r\n    function _getPriceCoeff() internal view override returns (uint256) {\r\n        return priceCoefficient;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nexus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardsToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_questManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cooldownSeconds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_unstakeWindow\",\"type\":\"uint256\"},{\"internalType\":\"address[2]\",\"name\":\"_bal\",\"type\":\"address[2]\"},{\"internalType\":\"bytes32\",\"name\":\"_poolId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BalClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRecipient\",\"type\":\"address\"}],\"name\":\"BalRecipientChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"Cooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"CooldownExited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"fromDelegate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"toDelegate\",\"type\":\"address\"}],\"name\":\"DelegateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"DelegateVotesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bpt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mta\",\"type\":\"uint256\"}],\"name\":\"FeesConverted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"hook\",\"type\":\"address\"}],\"name\":\"GovernanceHookChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newKeeper\",\"type\":\"address\"}],\"name\":\"KeeperUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPriceCoeff\",\"type\":\"uint256\"}],\"name\":\"PriceCoefficientUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Recollateralised\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"SlashRateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"WrapperBlacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"WrapperWhitelisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BAL\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COOLDOWN_SECONDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARDS_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKED_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNSTAKE_WINDOW\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nameArg\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_symbolArg\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_rewardsDistributorArg\",\"type\":\"address\"}],\"name\":\"__StakedToken_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_newMultiplier\",\"type\":\"uint8\"}],\"name\":\"applyQuestMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceData\",\"outputs\":[{\"components\":[{\"internalType\":\"uint88\",\"name\":\"raw\",\"type\":\"uint88\"},{\"internalType\":\"uint32\",\"name\":\"weightedTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"timeMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"questMultiplier\",\"type\":\"uint8\"},{\"internalType\":\"uint32\",\"name\":\"cooldownTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint88\",\"name\":\"cooldownUnits\",\"type\":\"uint88\"}],\"internalType\":\"struct Balance\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balancerVault\",\"outputs\":[{\"internalType\":\"contract IBVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapper\",\"type\":\"address\"}],\"name\":\"blackListWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_weightedTimestamp\",\"type\":\"uint32\"}],\"name\":\"calcRedemptionFeeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"changeSlashingPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"pos\",\"type\":\"uint32\"}],\"name\":\"checkpoints\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"fromBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint224\",\"name\":\"votes\",\"type\":\"uint224\"}],\"internalType\":\"struct GamifiedVotingToken.Checkpoint\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimBal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"convertFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"createLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"delegates\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"earned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyRecollateralisation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fetchPriceCoefficient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPastTotalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getPastVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getProspectivePriceCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newPriceCoeff\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalData\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"periodFinish\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lastUpdateTime\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"rewardRate\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"rewardPerTokenStored\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasPriceCoeff\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"increaseLockAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_nameArg\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_symbolArg\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_rewardsDistributorArg\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_balRecipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_priceCoefficient\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"keeper\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastPriceUpdateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimeRewardApplicable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nexus\",\"outputs\":[{\"internalType\":\"contract INexus\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"numCheckpoints\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingAdditionalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingBPTFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceCoefficient\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"questManager\",\"outputs\":[{\"internalType\":\"contract QuestManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"rawBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"reviewTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardPerToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokenVendor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"safetyData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"collateralisationRatio\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"slashingPercentage\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newRecipient\",\"type\":\"address\"}],\"name\":\"setBalRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newHook\",\"type\":\"address\"}],\"name\":\"setGovernanceHook\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newKeeper\",\"type\":\"address\"}],\"name\":\"setKeeper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rewardsDistributor\",\"type\":\"address\"}],\"name\":\"setRewardsDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_delegatee\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_exitCooldown\",\"type\":\"bool\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_units\",\"type\":\"uint256\"}],\"name\":\"startCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userData\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"rewardPerTokenPaid\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"rewards\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"userPriceCoeff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wrapper\",\"type\":\"address\"}],\"name\":\"whitelistWrapper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedWrappers\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_amountIncludesFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_exitCooldown\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakedTokenBPT", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000afce80b19a8ce13dec0739a1aab7a028d6845eb3000000000000000000000000a3bed4e1c75d00fa6f4e5e6922db7261b5e9acd2000000000000000000000000861f12764780896fd783ea615dd55df0ff865752000000000000000000000000e2469f47ab58cf9cf59f9822e3c5de4950a41c4900000000000000000000000000000000000000000000000000000000001baf800000000000000000000000000000000000000000000000000000000000127500000000000000000000000000ba100000625a3754423978a60c9317c58a424e3d000000000000000000000000ba12222222228d8ba445958a75a0704d566bf2c8e2469f47ab58cf9cf59f9822e3c5de4950a41c49000200000000000000000089", "EVMVersion": "Default", "Library": "PlatformTokenVendorFactory:fb73476911c5e84556a5bf953644b7ef50f6cbc5", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d9ac75198e252306dbb3dc63f4d652061966a44cae426e0c740652af42900a08"}]}