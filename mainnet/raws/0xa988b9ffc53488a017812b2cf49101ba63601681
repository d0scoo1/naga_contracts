{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.0;\r\n\r\ncontract Convert {\r\n    function convert(\r\n        int256 x_,\r\n        uint256 currentPrecision_,\r\n        uint256 targetPrecision_\r\n    ) internal pure returns (int256) {\r\n        if (targetPrecision_ > currentPrecision_)\r\n            return x_ * int256(10**(targetPrecision_ - currentPrecision_));\r\n\r\n        return x_ / int256(10**(currentPrecision_ - targetPrecision_));\r\n    }\r\n\r\n    function uconvert(\r\n        uint256 x_,\r\n        uint256 currentPrecision_,\r\n        uint256 targetPrecision_\r\n    ) internal pure returns (uint256) {\r\n        if (targetPrecision_ > currentPrecision_)\r\n            return x_ * 10**(targetPrecision_ - currentPrecision_);\r\n\r\n        return x_ / 10**(currentPrecision_ - targetPrecision_);\r\n    }\r\n}\r\n\r\ninterface IOracle {\r\n    function value() external view returns (int256, bool);\r\n\r\n    function nextValue() external view returns (int256);\r\n\r\n    function update() external returns (bool);\r\n}\r\n\r\n/// @notice Emitted when paused\r\nerror Pausable__whenNotPaused_paused();\r\n\r\n/// @notice Emitted when not paused\r\nerror Pausable__whenPaused_notPaused();\r\n\r\n/// @title Guarded\r\n/// @notice Mixin implementing an authentication scheme on a method level\r\nabstract contract Guarded {\r\n    /// ======== Custom Errors ======== ///\r\n\r\n    error Guarded__notRoot();\r\n    error Guarded__notGranted();\r\n\r\n    /// ======== Storage ======== ///\r\n\r\n    /// @notice Wildcard for granting a caller to call every guarded method\r\n    bytes32 public constant ANY_SIG = keccak256(\"ANY_SIG\");\r\n    /// @notice Wildcard for granting a caller to call every guarded method\r\n    address public constant ANY_CALLER =\r\n        address(uint160(uint256(bytes32(keccak256(\"ANY_CALLER\")))));\r\n\r\n    /// @notice Mapping storing who is granted to which method\r\n    /// @dev Method Signature => Caller => Bool\r\n    mapping(bytes32 => mapping(address => bool)) private _canCall;\r\n\r\n    /// ======== Events ======== ///\r\n\r\n    event AllowCaller(bytes32 sig, address who);\r\n    event BlockCaller(bytes32 sig, address who);\r\n\r\n    constructor() {\r\n        // set root\r\n        _setRoot(msg.sender);\r\n    }\r\n\r\n    /// ======== Auth ======== ///\r\n\r\n    modifier callerIsRoot() {\r\n        if (_canCall[ANY_SIG][msg.sender]) {\r\n            _;\r\n        } else revert Guarded__notRoot();\r\n    }\r\n\r\n    modifier checkCaller() {\r\n        if (canCall(msg.sig, msg.sender)) {\r\n            _;\r\n        } else revert Guarded__notGranted();\r\n    }\r\n\r\n    /// @notice Grant the right to call method `sig` to `who`\r\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\r\n    /// @param sig_ Method signature (4Byte)\r\n    /// @param who_ Address of who should be able to call `sig`\r\n    function allowCaller(bytes32 sig_, address who_) public callerIsRoot {\r\n        _canCall[sig_][who_] = true;\r\n        emit AllowCaller(sig_, who_);\r\n    }\r\n\r\n    /// @notice Revoke the right to call method `sig` from `who`\r\n    /// @dev Only the root user (granted `ANY_SIG`) is able to call this method\r\n    /// @param sig_ Method signature (4Byte)\r\n    /// @param who_ Address of who should not be able to call `sig` anymore\r\n    function blockCaller(bytes32 sig_, address who_) public callerIsRoot {\r\n        _canCall[sig_][who_] = false;\r\n        emit BlockCaller(sig_, who_);\r\n    }\r\n\r\n    /// @notice Returns if `who` can call `sig`\r\n    /// @param sig_ Method signature (4Byte)\r\n    /// @param who_ Address of who should be able to call `sig`\r\n    function canCall(bytes32 sig_, address who_) public view returns (bool) {\r\n        return (_canCall[sig_][who_] ||\r\n            _canCall[ANY_SIG][who_] ||\r\n            _canCall[sig_][ANY_CALLER]);\r\n    }\r\n\r\n    /// @notice Sets the root user (granted `ANY_SIG`)\r\n    /// @param root_ Address of who should be set as root\r\n    function _setRoot(address root_) internal {\r\n        _canCall[ANY_SIG][root_] = true;\r\n        emit AllowCaller(ANY_SIG, root_);\r\n    }\r\n}\r\n\r\ncontract Pausable is Guarded {\r\n    event Paused(address who);\r\n    event Unpaused(address who);\r\n\r\n    bool private _paused;\r\n\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        // If the contract is paused, throw an error\r\n        if (_paused) {\r\n            revert Pausable__whenNotPaused_paused();\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        // If the contract is not paused, throw an error\r\n        if (_paused == false) {\r\n            revert Pausable__whenPaused_notPaused();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function _pause() internal whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(msg.sender);\r\n    }\r\n\r\n    function _unpause() internal whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(msg.sender);\r\n    }\r\n}\r\n\r\nabstract contract Oracle is Pausable, IOracle {\r\n    /// @notice Emitted when a method is reentered\r\n    error Oracle__nonReentrant();\r\n\r\n    /// ======== Events ======== ///\r\n\r\n    event ValueInvalid();\r\n    event ValueUpdated(int256 currentValue, int256 nextValue);\r\n    event OracleReset();\r\n\r\n    /// ======== Storage ======== ///\r\n    // Time interval between the value updates\r\n    uint256 public immutable timeUpdateWindow;\r\n\r\n    // Timestamp of the current value\r\n    uint256 public lastTimestamp;\r\n\r\n    // The next value that will replace the current value once the timeUpdateWindow has passed\r\n    int256 public override(IOracle) nextValue;\r\n\r\n    // Current value that will be returned by the Oracle\r\n    int256 private _currentValue;\r\n\r\n    // Flag that tells if the value provider returned successfully\r\n    bool private _validReturnedValue;\r\n\r\n    // Reentrancy constants\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    // Reentrancy guard flag\r\n    uint256 private _reentrantGuard = _NOT_ENTERED;\r\n\r\n    /// ======== Modifiers ======== ///\r\n\r\n    modifier nonReentrant() {\r\n        // Check if the guard is set\r\n        if (_reentrantGuard != _NOT_ENTERED) {\r\n            revert Oracle__nonReentrant();\r\n        }\r\n\r\n        // Set the guard\r\n        _reentrantGuard = _ENTERED;\r\n\r\n        // Allow execution\r\n        _;\r\n\r\n        // Reset the guard\r\n        _reentrantGuard = _NOT_ENTERED;\r\n    }\r\n\r\n    constructor(uint256 timeUpdateWindow_) {\r\n        timeUpdateWindow = timeUpdateWindow_;\r\n        _validReturnedValue = false;\r\n    }\r\n\r\n    /// @notice Get the current value of the oracle\r\n    /// @return The current value of the oracle\r\n    /// @return Whether the value is valid\r\n    function value()\r\n        public\r\n        view\r\n        override(IOracle)\r\n        whenNotPaused\r\n        returns (int256, bool)\r\n    {\r\n        // Value is considered valid if the value provider successfully returned a value\r\n        return (_currentValue, _validReturnedValue);\r\n    }\r\n\r\n    function getValue() external virtual returns (int256);\r\n\r\n    function update()\r\n        public\r\n        override(IOracle)\r\n        checkCaller\r\n        nonReentrant\r\n        returns (bool)\r\n    {\r\n        // Not enough time has passed since the last update\r\n        if (lastTimestamp + timeUpdateWindow > block.timestamp) {\r\n            // Exit early if no update is needed\r\n            return false;\r\n        }\r\n\r\n        // Oracle update should not fail even if the value provider fails to return a value\r\n        try this.getValue() returns (int256 returnedValue) {\r\n            // Update the value using an exponential moving average\r\n            if (_currentValue == 0) {\r\n                // First update takes the current value\r\n                nextValue = returnedValue;\r\n                _currentValue = nextValue;\r\n            } else {\r\n                // Update the current value with the next value\r\n                _currentValue = nextValue;\r\n                // Set the returnedValue as the next value\r\n                nextValue = returnedValue;\r\n            }\r\n\r\n            // Save when the value was last updated\r\n            lastTimestamp = block.timestamp;\r\n            _validReturnedValue = true;\r\n\r\n            emit ValueUpdated(_currentValue, nextValue);\r\n\r\n            return true;\r\n        } catch {\r\n            // When a value provider fails, we update the valid flag which will\r\n            // invalidate the value instantly\r\n            _validReturnedValue = false;\r\n            emit ValueInvalid();\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function pause() public checkCaller {\r\n        _pause();\r\n    }\r\n\r\n    function unpause() public checkCaller {\r\n        _unpause();\r\n    }\r\n\r\n    function reset() public whenPaused checkCaller {\r\n        _currentValue = 0;\r\n        nextValue = 0;\r\n        lastTimestamp = 0;\r\n        _validReturnedValue = false;\r\n\r\n        emit OracleReset();\r\n    }\r\n}\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\r\n\r\n/// @notice Emitted when the result overflows uint256.\r\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\r\n\r\n/// @notice Emitted when one of the inputs is type(int256).min.\r\nerror PRBMath__MulDivSignedInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows int256.\r\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is MIN_SD59x18.\r\nerror PRBMathSD59x18__AbsInputTooSmall();\r\n\r\n/// @notice Emitted when ceiling a number overflows SD59x18.\r\nerror PRBMathSD59x18__CeilOverflow(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__DivInputTooSmall();\r\n\r\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\r\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\r\n\r\n/// @notice Emitted when flooring a number underflows SD59x18.\r\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\r\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\r\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\r\n\r\n/// @notice Emitted when the product of the inputs is negative.\r\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\r\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\r\n\r\n/// @notice Emitted when the input is less than or equal to zero.\r\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\r\n\r\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\r\nerror PRBMathSD59x18__MulInputTooSmall();\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\r\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\r\n\r\n/// @notice Emitted when the input is negative.\r\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows SD59x18.\r\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\r\n\r\n/// @notice Emitted when addition overflows UD60x18.\r\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when ceiling a number overflows UD60x18.\r\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 133.084258667509499441.\r\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when the input is greater than 192.\r\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\r\n\r\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\r\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\r\n\r\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\r\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\r\n\r\n/// @notice Emitted when the input is less than 1.\r\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\r\n\r\n/// @notice Emitted when the calculating the square root overflows UD60x18.\r\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\r\n\r\n/// @notice Emitted when subtraction underflows UD60x18.\r\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\r\n\r\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\r\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\r\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\r\nlibrary PRBMath {\r\n    /// STRUCTS ///\r\n\r\n    struct SD59x18 {\r\n        int256 value;\r\n    }\r\n\r\n    struct UD60x18 {\r\n        uint256 value;\r\n    }\r\n\r\n    /// STORAGE ///\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    uint256 internal constant SCALE = 1e18;\r\n\r\n    /// @dev Largest power of two divisor of SCALE.\r\n    uint256 internal constant SCALE_LPOTD = 262144;\r\n\r\n    /// @dev SCALE inverted mod 2^256.\r\n    uint256 internal constant SCALE_INVERSE =\r\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\r\n\r\n    /// FUNCTIONS ///\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    /// @dev Has to use 192.64-bit fixed-point numbers.\r\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\r\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function exp2(uint256 x) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // Start from 0.5 in the 192.64-bit fixed-point format.\r\n            result = 0x800000000000000000000000000000000000000000000000;\r\n\r\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\r\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\r\n            if (x & 0x8000000000000000 > 0) {\r\n                result = (result * 0x16A09E667F3BCC909) >> 64;\r\n            }\r\n            if (x & 0x4000000000000000 > 0) {\r\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\r\n            }\r\n            if (x & 0x2000000000000000 > 0) {\r\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\r\n            }\r\n            if (x & 0x1000000000000000 > 0) {\r\n                result = (result * 0x10B5586CF9890F62A) >> 64;\r\n            }\r\n            if (x & 0x800000000000000 > 0) {\r\n                result = (result * 0x1059B0D31585743AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000000 > 0) {\r\n                result = (result * 0x102C9A3E778060EE7) >> 64;\r\n            }\r\n            if (x & 0x200000000000000 > 0) {\r\n                result = (result * 0x10163DA9FB33356D8) >> 64;\r\n            }\r\n            if (x & 0x100000000000000 > 0) {\r\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\r\n            }\r\n            if (x & 0x80000000000000 > 0) {\r\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\r\n            }\r\n            if (x & 0x40000000000000 > 0) {\r\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\r\n            }\r\n            if (x & 0x20000000000000 > 0) {\r\n                result = (result * 0x100162F3904051FA1) >> 64;\r\n            }\r\n            if (x & 0x10000000000000 > 0) {\r\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\r\n            }\r\n            if (x & 0x8000000000000 > 0) {\r\n                result = (result * 0x100058BA01FB9F96D) >> 64;\r\n            }\r\n            if (x & 0x4000000000000 > 0) {\r\n                result = (result * 0x10002C5CC37DA9492) >> 64;\r\n            }\r\n            if (x & 0x2000000000000 > 0) {\r\n                result = (result * 0x1000162E525EE0547) >> 64;\r\n            }\r\n            if (x & 0x1000000000000 > 0) {\r\n                result = (result * 0x10000B17255775C04) >> 64;\r\n            }\r\n            if (x & 0x800000000000 > 0) {\r\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\r\n            }\r\n            if (x & 0x400000000000 > 0) {\r\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\r\n            }\r\n            if (x & 0x200000000000 > 0) {\r\n                result = (result * 0x10000162E43F4F831) >> 64;\r\n            }\r\n            if (x & 0x100000000000 > 0) {\r\n                result = (result * 0x100000B1721BCFC9A) >> 64;\r\n            }\r\n            if (x & 0x80000000000 > 0) {\r\n                result = (result * 0x10000058B90CF1E6E) >> 64;\r\n            }\r\n            if (x & 0x40000000000 > 0) {\r\n                result = (result * 0x1000002C5C863B73F) >> 64;\r\n            }\r\n            if (x & 0x20000000000 > 0) {\r\n                result = (result * 0x100000162E430E5A2) >> 64;\r\n            }\r\n            if (x & 0x10000000000 > 0) {\r\n                result = (result * 0x1000000B172183551) >> 64;\r\n            }\r\n            if (x & 0x8000000000 > 0) {\r\n                result = (result * 0x100000058B90C0B49) >> 64;\r\n            }\r\n            if (x & 0x4000000000 > 0) {\r\n                result = (result * 0x10000002C5C8601CC) >> 64;\r\n            }\r\n            if (x & 0x2000000000 > 0) {\r\n                result = (result * 0x1000000162E42FFF0) >> 64;\r\n            }\r\n            if (x & 0x1000000000 > 0) {\r\n                result = (result * 0x10000000B17217FBB) >> 64;\r\n            }\r\n            if (x & 0x800000000 > 0) {\r\n                result = (result * 0x1000000058B90BFCE) >> 64;\r\n            }\r\n            if (x & 0x400000000 > 0) {\r\n                result = (result * 0x100000002C5C85FE3) >> 64;\r\n            }\r\n            if (x & 0x200000000 > 0) {\r\n                result = (result * 0x10000000162E42FF1) >> 64;\r\n            }\r\n            if (x & 0x100000000 > 0) {\r\n                result = (result * 0x100000000B17217F8) >> 64;\r\n            }\r\n            if (x & 0x80000000 > 0) {\r\n                result = (result * 0x10000000058B90BFC) >> 64;\r\n            }\r\n            if (x & 0x40000000 > 0) {\r\n                result = (result * 0x1000000002C5C85FE) >> 64;\r\n            }\r\n            if (x & 0x20000000 > 0) {\r\n                result = (result * 0x100000000162E42FF) >> 64;\r\n            }\r\n            if (x & 0x10000000 > 0) {\r\n                result = (result * 0x1000000000B17217F) >> 64;\r\n            }\r\n            if (x & 0x8000000 > 0) {\r\n                result = (result * 0x100000000058B90C0) >> 64;\r\n            }\r\n            if (x & 0x4000000 > 0) {\r\n                result = (result * 0x10000000002C5C860) >> 64;\r\n            }\r\n            if (x & 0x2000000 > 0) {\r\n                result = (result * 0x1000000000162E430) >> 64;\r\n            }\r\n            if (x & 0x1000000 > 0) {\r\n                result = (result * 0x10000000000B17218) >> 64;\r\n            }\r\n            if (x & 0x800000 > 0) {\r\n                result = (result * 0x1000000000058B90C) >> 64;\r\n            }\r\n            if (x & 0x400000 > 0) {\r\n                result = (result * 0x100000000002C5C86) >> 64;\r\n            }\r\n            if (x & 0x200000 > 0) {\r\n                result = (result * 0x10000000000162E43) >> 64;\r\n            }\r\n            if (x & 0x100000 > 0) {\r\n                result = (result * 0x100000000000B1721) >> 64;\r\n            }\r\n            if (x & 0x80000 > 0) {\r\n                result = (result * 0x10000000000058B91) >> 64;\r\n            }\r\n            if (x & 0x40000 > 0) {\r\n                result = (result * 0x1000000000002C5C8) >> 64;\r\n            }\r\n            if (x & 0x20000 > 0) {\r\n                result = (result * 0x100000000000162E4) >> 64;\r\n            }\r\n            if (x & 0x10000 > 0) {\r\n                result = (result * 0x1000000000000B172) >> 64;\r\n            }\r\n            if (x & 0x8000 > 0) {\r\n                result = (result * 0x100000000000058B9) >> 64;\r\n            }\r\n            if (x & 0x4000 > 0) {\r\n                result = (result * 0x10000000000002C5D) >> 64;\r\n            }\r\n            if (x & 0x2000 > 0) {\r\n                result = (result * 0x1000000000000162E) >> 64;\r\n            }\r\n            if (x & 0x1000 > 0) {\r\n                result = (result * 0x10000000000000B17) >> 64;\r\n            }\r\n            if (x & 0x800 > 0) {\r\n                result = (result * 0x1000000000000058C) >> 64;\r\n            }\r\n            if (x & 0x400 > 0) {\r\n                result = (result * 0x100000000000002C6) >> 64;\r\n            }\r\n            if (x & 0x200 > 0) {\r\n                result = (result * 0x10000000000000163) >> 64;\r\n            }\r\n            if (x & 0x100 > 0) {\r\n                result = (result * 0x100000000000000B1) >> 64;\r\n            }\r\n            if (x & 0x80 > 0) {\r\n                result = (result * 0x10000000000000059) >> 64;\r\n            }\r\n            if (x & 0x40 > 0) {\r\n                result = (result * 0x1000000000000002C) >> 64;\r\n            }\r\n            if (x & 0x20 > 0) {\r\n                result = (result * 0x10000000000000016) >> 64;\r\n            }\r\n            if (x & 0x10 > 0) {\r\n                result = (result * 0x1000000000000000B) >> 64;\r\n            }\r\n            if (x & 0x8 > 0) {\r\n                result = (result * 0x10000000000000006) >> 64;\r\n            }\r\n            if (x & 0x4 > 0) {\r\n                result = (result * 0x10000000000000003) >> 64;\r\n            }\r\n            if (x & 0x2 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n            if (x & 0x1 > 0) {\r\n                result = (result * 0x10000000000000001) >> 64;\r\n            }\r\n\r\n            // We're doing two things at the same time:\r\n            //\r\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\r\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\r\n            //      rather than 192.\r\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\r\n            //\r\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\r\n            result *= SCALE;\r\n            result >>= (191 - (x >> 64));\r\n        }\r\n    }\r\n\r\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\r\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\r\n    /// @param x The uint256 number for which to find the index of the most significant bit.\r\n    /// @return msb The index of the most significant bit as an uint256.\r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\r\n    ///\r\n    /// Requirements:\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The multiplicand as an uint256.\r\n    /// @param y The multiplier as an uint256.\r\n    /// @param denominator The divisor as an uint256.\r\n    /// @return result The result as an uint256.\r\n    function mulDiv(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n        // variables such that product = prod1 * 2^256 + prod0.\r\n        uint256 prod0; // Least significant 256 bits of the product\r\n        uint256 prod1; // Most significant 256 bits of the product\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        // Handle non-overflow cases, 256 by 256 division.\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = prod0 / denominator;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n        if (prod1 >= denominator) {\r\n            revert PRBMath__MulDivOverflow(prod1, denominator);\r\n        }\r\n\r\n        ///////////////////////////////////////////////\r\n        // 512 by 256 division.\r\n        ///////////////////////////////////////////////\r\n\r\n        // Make division exact by subtracting the remainder from [prod1 prod0].\r\n        uint256 remainder;\r\n        assembly {\r\n            // Compute remainder using mulmod.\r\n            remainder := mulmod(x, y, denominator)\r\n\r\n            // Subtract 256 bit number from 512 bit number.\r\n            prod1 := sub(prod1, gt(remainder, prod0))\r\n            prod0 := sub(prod0, remainder)\r\n        }\r\n\r\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n        // See https://cs.stackexchange.com/q/138556/92363.\r\n        unchecked {\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 lpotdod = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by lpotdod.\r\n                denominator := div(denominator, lpotdod)\r\n\r\n                // Divide [prod1 prod0] by lpotdod.\r\n                prod0 := div(prod0, lpotdod)\r\n\r\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\r\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * lpotdod;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f71e18) with full precision.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\r\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\r\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\r\n    ///\r\n    /// Requirements:\r\n    /// - The result must fit within uint256.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\r\n    ///     1. x * y = type(uint256).max * SCALE\r\n    ///     2. (x * y) % SCALE >= SCALE / 2\r\n    ///\r\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\r\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\r\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\r\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\r\n        uint256 prod0;\r\n        uint256 prod1;\r\n        assembly {\r\n            let mm := mulmod(x, y, not(0))\r\n            prod0 := mul(x, y)\r\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n        }\r\n\r\n        if (prod1 >= SCALE) {\r\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\r\n        }\r\n\r\n        uint256 remainder;\r\n        uint256 roundUpUnit;\r\n        assembly {\r\n            remainder := mulmod(x, y, SCALE)\r\n            roundUpUnit := gt(remainder, 499999999999999999)\r\n        }\r\n\r\n        if (prod1 == 0) {\r\n            unchecked {\r\n                result = (prod0 / SCALE) + roundUpUnit;\r\n                return result;\r\n            }\r\n        }\r\n\r\n        assembly {\r\n            result := add(\r\n                mul(\r\n                    or(\r\n                        div(sub(prod0, remainder), SCALE_LPOTD),\r\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\r\n                    ),\r\n                    SCALE_INVERSE\r\n                ),\r\n                roundUpUnit\r\n            )\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates floor(x*y\u00f7denominator) with full precision.\r\n    ///\r\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - None of the inputs can be type(int256).min.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// @param x The multiplicand as an int256.\r\n    /// @param y The multiplier as an int256.\r\n    /// @param denominator The divisor as an int256.\r\n    /// @return result The result as an int256.\r\n    function mulDivSigned(\r\n        int256 x,\r\n        int256 y,\r\n        int256 denominator\r\n    ) internal pure returns (int256 result) {\r\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\r\n            revert PRBMath__MulDivSignedInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x, y and the denominator.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        uint256 ad;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\r\n        }\r\n\r\n        // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\r\n        uint256 rAbs = mulDiv(ax, ay, ad);\r\n        if (rAbs > uint256(type(int256).max)) {\r\n            revert PRBMath__MulDivSignedOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x, y and the denominator.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        uint256 sd;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n            sd := sgt(denominator, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\r\n        // If yes, the result should be negative.\r\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Caveats:\r\n    /// - This function does not work with fixed-point numbers.\r\n    ///\r\n    /// @param x The uint256 number for which to calculate the square root.\r\n    /// @return result The result as an uint256.\r\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\r\n        uint256 xAux = uint256(x);\r\n        result = 1;\r\n        if (xAux >= 0x100000000000000000000000000000000) {\r\n            xAux >>= 128;\r\n            result <<= 64;\r\n        }\r\n        if (xAux >= 0x10000000000000000) {\r\n            xAux >>= 64;\r\n            result <<= 32;\r\n        }\r\n        if (xAux >= 0x100000000) {\r\n            xAux >>= 32;\r\n            result <<= 16;\r\n        }\r\n        if (xAux >= 0x10000) {\r\n            xAux >>= 16;\r\n            result <<= 8;\r\n        }\r\n        if (xAux >= 0x100) {\r\n            xAux >>= 8;\r\n            result <<= 4;\r\n        }\r\n        if (xAux >= 0x10) {\r\n            xAux >>= 4;\r\n            result <<= 2;\r\n        }\r\n        if (xAux >= 0x8) {\r\n            result <<= 1;\r\n        }\r\n\r\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\r\n        unchecked {\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1;\r\n            result = (result + x / result) >> 1; // Seven iterations should be enough\r\n            uint256 roundedDownResult = x / result;\r\n            return result >= roundedDownResult ? roundedDownResult : result;\r\n        }\r\n    }\r\n}\r\n\r\n/// @title PRBMathSD59x18\r\n/// @author Paul Razvan Berg\r\n/// @notice Smart contract library for advanced fixed-point math that works with int256 numbers considered to have 18\r\n/// trailing decimals. We call this number representation signed 59.18-decimal fixed-point, since the numbers can have\r\n/// a sign and there can be up to 59 digits in the integer part and up to 18 decimals in the fractional part. The numbers\r\n/// are bound by the minimum and the maximum values permitted by the Solidity type int256.\r\nlibrary PRBMathSD59x18 {\r\n    /// @dev log2(e) as a signed 59.18-decimal fixed-point number.\r\n    int256 internal constant LOG2_E = 1_442695040888963407;\r\n\r\n    /// @dev Half the SCALE number.\r\n    int256 internal constant HALF_SCALE = 5e17;\r\n\r\n    /// @dev The maximum value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MAX_SD59x18 =\r\n        57896044618658097711785492504343953926634992332820282019728_792003956564819967;\r\n\r\n    /// @dev The maximum whole value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MAX_WHOLE_SD59x18 =\r\n        57896044618658097711785492504343953926634992332820282019728_000000000000000000;\r\n\r\n    /// @dev The minimum value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MIN_SD59x18 =\r\n        -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\r\n\r\n    /// @dev The minimum whole value a signed 59.18-decimal fixed-point number can have.\r\n    int256 internal constant MIN_WHOLE_SD59x18 =\r\n        -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\r\n\r\n    /// @dev How many trailing decimals can be represented.\r\n    int256 internal constant SCALE = 1e18;\r\n\r\n    /// INTERNAL FUNCTIONS ///\r\n\r\n    /// @notice Calculate the absolute value of x.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be greater than MIN_SD59x18.\r\n    ///\r\n    /// @param x The number to calculate the absolute value for.\r\n    /// @param result The absolute value of x.\r\n    function abs(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x == MIN_SD59x18) {\r\n                revert PRBMathSD59x18__AbsInputTooSmall();\r\n            }\r\n            result = x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\r\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The arithmetic average as a signed 59.18-decimal fixed-point number.\r\n    function avg(int256 x, int256 y) internal pure returns (int256 result) {\r\n        // The operations can never overflow.\r\n        unchecked {\r\n            int256 sum = (x >> 1) + (y >> 1);\r\n            if (sum < 0) {\r\n                // If at least one of x and y is odd, we add 1 to the result. This is because shifting negative numbers to the\r\n                // right rounds down to infinity.\r\n                assembly {\r\n                    result := add(sum, and(or(x, y), 1))\r\n                }\r\n            } else {\r\n                // If both x and y are odd, we add 1 to the result. This is because if both numbers are odd, the 0.5\r\n                // remainder gets truncated twice.\r\n                result = sum + (x & y & 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the least greatest signed 59.18 decimal fixed-point number greater than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be less than or equal to MAX_WHOLE_SD59x18.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number to ceil.\r\n    /// @param result The least integer greater than or equal to x, as a signed 58.18-decimal fixed-point number.\r\n    function ceil(int256 x) internal pure returns (int256 result) {\r\n        if (x > MAX_WHOLE_SD59x18) {\r\n            revert PRBMathSD59x18__CeilOverflow(x);\r\n        }\r\n        unchecked {\r\n            int256 remainder = x % SCALE;\r\n            if (remainder == 0) {\r\n                result = x;\r\n            } else {\r\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\r\n                result = x - remainder;\r\n                if (x > 0) {\r\n                    result += SCALE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Divides two signed 59.18-decimal fixed-point numbers, returning a new signed 59.18-decimal fixed-point number.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" that works with signed numbers. Works by computing the signs and the absolute values separately.\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"PRBMath.mulDiv\".\r\n    /// - None of the inputs can be MIN_SD59x18.\r\n    /// - The denominator cannot be zero.\r\n    /// - The result must fit within int256.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"PRBMath.mulDiv\".\r\n    ///\r\n    /// @param x The numerator as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The denominator as a signed 59.18-decimal fixed-point number.\r\n    /// @param result The quotient as a signed 59.18-decimal fixed-point number.\r\n    function div(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\r\n            revert PRBMathSD59x18__DivInputTooSmall();\r\n        }\r\n\r\n        // Get hold of the absolute values of x and y.\r\n        uint256 ax;\r\n        uint256 ay;\r\n        unchecked {\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n        }\r\n\r\n        // Compute the absolute value of (x*SCALE)\u00f7y. The result must fit within int256.\r\n        uint256 rAbs = PRBMath.mulDiv(ax, uint256(SCALE), ay);\r\n        if (rAbs > uint256(MAX_SD59x18)) {\r\n            revert PRBMathSD59x18__DivOverflow(rAbs);\r\n        }\r\n\r\n        // Get the signs of x and y.\r\n        uint256 sx;\r\n        uint256 sy;\r\n        assembly {\r\n            sx := sgt(x, sub(0, 1))\r\n            sy := sgt(y, sub(0, 1))\r\n        }\r\n\r\n        // XOR over sx and sy. This is basically checking whether the inputs have the same sign. If yes, the result\r\n        // should be positive. Otherwise, it should be negative.\r\n        result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Returns Euler's number as a signed 59.18-decimal fixed-point number.\r\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\r\n    function e() internal pure returns (int256 result) {\r\n        result = 2_718281828459045235;\r\n    }\r\n\r\n    /// @notice Calculates the natural exponent of x.\r\n    ///\r\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    /// - x must be less than 133.084258667509499441.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\".\r\n    /// - For any x less than -41.446531673892822322, the result is zero.\r\n    ///\r\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function exp(int256 x) internal pure returns (int256 result) {\r\n        // Without this check, the value passed to \"exp2\" would be less than -59.794705707972522261.\r\n        if (x < -41_446531673892822322) {\r\n            return 0;\r\n        }\r\n\r\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\r\n        if (x >= 133_084258667509499441) {\r\n            revert PRBMathSD59x18__ExpInputTooBig(x);\r\n        }\r\n\r\n        // Do the fixed-point multiplication inline to save gas.\r\n        unchecked {\r\n            int256 doubleScaleProduct = x * LOG2_E;\r\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\r\n    ///\r\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be 192 or less.\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - For any x less than -59.794705707972522261, the result is zero.\r\n    ///\r\n    /// @param x The exponent as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function exp2(int256 x) internal pure returns (int256 result) {\r\n        // This works because 2^(-x) = 1/2^x.\r\n        if (x < 0) {\r\n            // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\r\n            if (x < -59_794705707972522261) {\r\n                return 0;\r\n            }\r\n\r\n            // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n            unchecked {\r\n                result = 1e36 / exp2(-x);\r\n            }\r\n        } else {\r\n            // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\r\n            if (x >= 192e18) {\r\n                revert PRBMathSD59x18__Exp2InputTooBig(x);\r\n            }\r\n\r\n            unchecked {\r\n                // Convert x to the 192.64-bit fixed-point format.\r\n                uint256 x192x64 = (uint256(x) << 64) / uint256(SCALE);\r\n\r\n                // Safe to convert the result to int256 directly because the maximum input allowed is 192.\r\n                result = int256(PRBMath.exp2(x192x64));\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the greatest signed 59.18 decimal fixed-point number less than or equal to x.\r\n    ///\r\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\r\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than or equal to MIN_WHOLE_SD59x18.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number to floor.\r\n    /// @param result The greatest integer less than or equal to x, as a signed 58.18-decimal fixed-point number.\r\n    function floor(int256 x) internal pure returns (int256 result) {\r\n        if (x < MIN_WHOLE_SD59x18) {\r\n            revert PRBMathSD59x18__FloorUnderflow(x);\r\n        }\r\n        unchecked {\r\n            int256 remainder = x % SCALE;\r\n            if (remainder == 0) {\r\n                result = x;\r\n            } else {\r\n                // Solidity uses C fmod style, which returns a modulus with the same sign as x.\r\n                result = x - remainder;\r\n                if (x < 0) {\r\n                    result -= SCALE;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right\r\n    /// of the radix point for negative numbers.\r\n    /// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\r\n    /// @param x The signed 59.18-decimal fixed-point number to get the fractional part of.\r\n    /// @param result The fractional part of x as a signed 59.18-decimal fixed-point number.\r\n    function frac(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            result = x % SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a number from basic integer form to signed 59.18-decimal fixed-point representation.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x must be greater than or equal to MIN_SD59x18 divided by SCALE.\r\n    /// - x must be less than or equal to MAX_SD59x18 divided by SCALE.\r\n    ///\r\n    /// @param x The basic integer to convert.\r\n    /// @param result The same number in signed 59.18-decimal fixed-point representation.\r\n    function fromInt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x < MIN_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__FromIntUnderflow(x);\r\n            }\r\n            if (x > MAX_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__FromIntOverflow(x);\r\n            }\r\n            result = x * SCALE;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x * y must fit within MAX_SD59x18, lest it overflows.\r\n    /// - x * y cannot be negative.\r\n    ///\r\n    /// @param x The first operand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The second operand as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function gm(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        unchecked {\r\n            // Checking for overflow this way is faster than letting Solidity do it.\r\n            int256 xy = x * y;\r\n            if (xy / x != y) {\r\n                revert PRBMathSD59x18__GmOverflow(x, y);\r\n            }\r\n\r\n            // The product cannot be negative.\r\n            if (xy < 0) {\r\n                revert PRBMathSD59x18__GmNegativeProduct(x, y);\r\n            }\r\n\r\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\r\n            // during multiplication. See the comments within the \"sqrt\" function.\r\n            result = int256(PRBMath.sqrt(uint256(xy)));\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates 1 / x, rounding toward zero.\r\n    ///\r\n    /// @dev Requirements:\r\n    /// - x cannot be zero.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the inverse.\r\n    /// @return result The inverse as a signed 59.18-decimal fixed-point number.\r\n    function inv(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            // 1e36 is SCALE * SCALE.\r\n            result = 1e36 / x;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the natural logarithm of x.\r\n    ///\r\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    /// - This doesn't return exactly 1 for 2718281828459045235, for that we would need more fine-grained precision.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the natural logarithm.\r\n    /// @return result The natural logarithm as a signed 59.18-decimal fixed-point number.\r\n    function ln(int256 x) internal pure returns (int256 result) {\r\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\r\n        // can return is 195205294292027477728.\r\n        unchecked {\r\n            result = (log2(x) * SCALE) / LOG2_E;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the common logarithm of x.\r\n    ///\r\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\r\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"log2\".\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the common logarithm.\r\n    /// @return result The common logarithm as a signed 59.18-decimal fixed-point number.\r\n    function log10(int256 x) internal pure returns (int256 result) {\r\n        if (x <= 0) {\r\n            revert PRBMathSD59x18__LogInputTooSmall(x);\r\n        }\r\n\r\n        // Note that the \"mul\" in this block is the assembly mul operation, not the \"mul\" function defined in this contract.\r\n        // prettier-ignore\r\n        assembly {\r\n            switch x\r\n            case 1 { result := mul(SCALE, sub(0, 18)) }\r\n            case 10 { result := mul(SCALE, sub(1, 18)) }\r\n            case 100 { result := mul(SCALE, sub(2, 18)) }\r\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\r\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\r\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\r\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\r\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\r\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\r\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\r\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\r\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\r\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\r\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\r\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\r\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\r\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\r\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\r\n            case 1000000000000000000 { result := 0 }\r\n            case 10000000000000000000 { result := SCALE }\r\n            case 100000000000000000000 { result := mul(SCALE, 2) }\r\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\r\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\r\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\r\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\r\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\r\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\r\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\r\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\r\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\r\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\r\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\r\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\r\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\r\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\r\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\r\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\r\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\r\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\r\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\r\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\r\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\r\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\r\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\r\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\r\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\r\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\r\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\r\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\r\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\r\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\r\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\r\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\r\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\r\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\r\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\r\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\r\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\r\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\r\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\r\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\r\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\r\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\r\n            default {\r\n                result := MAX_SD59x18\r\n            }\r\n        }\r\n\r\n        if (result == MAX_SD59x18) {\r\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\r\n            unchecked {\r\n                result = (log2(x) * SCALE) / 3_321928094887362347;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the binary logarithm of x.\r\n    ///\r\n    /// @dev Based on the iterative approximation algorithm.\r\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\r\n    ///\r\n    /// Requirements:\r\n    /// - x must be greater than zero.\r\n    ///\r\n    /// Caveats:\r\n    /// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the binary logarithm.\r\n    /// @return result The binary logarithm as a signed 59.18-decimal fixed-point number.\r\n    function log2(int256 x) internal pure returns (int256 result) {\r\n        if (x <= 0) {\r\n            revert PRBMathSD59x18__LogInputTooSmall(x);\r\n        }\r\n        unchecked {\r\n            // This works because log2(x) = -log2(1/x).\r\n            int256 sign;\r\n            if (x >= SCALE) {\r\n                sign = 1;\r\n            } else {\r\n                sign = -1;\r\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n                assembly {\r\n                    x := div(1000000000000000000000000000000000000, x)\r\n                }\r\n            }\r\n\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = PRBMath.mostSignificantBit(uint256(x / SCALE));\r\n\r\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\r\n            result = int256(n) * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            int256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result * sign;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (int256 delta = int256(HALF_SCALE); delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n            result *= sign;\r\n        }\r\n    }\r\n\r\n    /// @notice Multiplies two signed 59.18-decimal fixed-point numbers together, returning a new signed 59.18-decimal\r\n    /// fixed-point number.\r\n    ///\r\n    /// @dev Variant of \"mulDiv\" that works with signed numbers and employs constant folding, i.e. the denominator is\r\n    /// always 1e18.\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"PRBMath.mulDivFixedPoint\".\r\n    /// - None of the inputs can be MIN_SD59x18\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\r\n    ///\r\n    /// @param x The multiplicand as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The multiplier as a signed 59.18-decimal fixed-point number.\r\n    /// @return result The product as a signed 59.18-decimal fixed-point number.\r\n    function mul(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == MIN_SD59x18 || y == MIN_SD59x18) {\r\n            revert PRBMathSD59x18__MulInputTooSmall();\r\n        }\r\n\r\n        unchecked {\r\n            uint256 ax;\r\n            uint256 ay;\r\n            ax = x < 0 ? uint256(-x) : uint256(x);\r\n            ay = y < 0 ? uint256(-y) : uint256(y);\r\n\r\n            uint256 rAbs = PRBMath.mulDivFixedPoint(ax, ay);\r\n            if (rAbs > uint256(MAX_SD59x18)) {\r\n                revert PRBMathSD59x18__MulOverflow(rAbs);\r\n            }\r\n\r\n            uint256 sx;\r\n            uint256 sy;\r\n            assembly {\r\n                sx := sgt(x, sub(0, 1))\r\n                sy := sgt(y, sub(0, 1))\r\n            }\r\n            result = sx ^ sy == 1 ? -int256(rAbs) : int256(rAbs);\r\n        }\r\n    }\r\n\r\n    /// @notice Returns PI as a signed 59.18-decimal fixed-point number.\r\n    function pi() internal pure returns (int256 result) {\r\n        result = 3_141592653589793238;\r\n    }\r\n\r\n    /// @notice Raises x to the power of y.\r\n    ///\r\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - z cannot be zero.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"exp2\", \"log2\" and \"mul\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x Number to raise to given power y, as a signed 59.18-decimal fixed-point number.\r\n    /// @param y Exponent to raise x to, as a signed 59.18-decimal fixed-point number.\r\n    /// @return result x raised to power y, as a signed 59.18-decimal fixed-point number.\r\n    function pow(int256 x, int256 y) internal pure returns (int256 result) {\r\n        if (x == 0) {\r\n            result = y == 0 ? SCALE : int256(0);\r\n        } else {\r\n            result = exp2(mul(log2(x), y));\r\n        }\r\n    }\r\n\r\n    /// @notice Raises x (signed 59.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\r\n    /// famous algorithm \"exponentiation by squaring\".\r\n    ///\r\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\r\n    ///\r\n    /// Requirements:\r\n    /// - All from \"abs\" and \"PRBMath.mulDivFixedPoint\".\r\n    /// - The result must fit within MAX_SD59x18.\r\n    ///\r\n    /// Caveats:\r\n    /// - All from \"PRBMath.mulDivFixedPoint\".\r\n    /// - Assumes 0^0 is 1.\r\n    ///\r\n    /// @param x The base as a signed 59.18-decimal fixed-point number.\r\n    /// @param y The exponent as an uint256.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point number.\r\n    function powu(int256 x, uint256 y) internal pure returns (int256 result) {\r\n        uint256 xAbs = uint256(abs(x));\r\n\r\n        // Calculate the first iteration of the loop in advance.\r\n        uint256 rAbs = y & 1 > 0 ? xAbs : uint256(SCALE);\r\n\r\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\r\n        uint256 yAux = y;\r\n        for (yAux >>= 1; yAux > 0; yAux >>= 1) {\r\n            xAbs = PRBMath.mulDivFixedPoint(xAbs, xAbs);\r\n\r\n            // Equivalent to \"y % 2 == 1\" but faster.\r\n            if (yAux & 1 > 0) {\r\n                rAbs = PRBMath.mulDivFixedPoint(rAbs, xAbs);\r\n            }\r\n        }\r\n\r\n        // The result must fit within the 59.18-decimal fixed-point representation.\r\n        if (rAbs > uint256(MAX_SD59x18)) {\r\n            revert PRBMathSD59x18__PowuOverflow(rAbs);\r\n        }\r\n\r\n        // Is the base negative and the exponent an odd number?\r\n        bool isNegative = x < 0 && y & 1 == 1;\r\n        result = isNegative ? -int256(rAbs) : int256(rAbs);\r\n    }\r\n\r\n    /// @notice Returns 1 as a signed 59.18-decimal fixed-point number.\r\n    function scale() internal pure returns (int256 result) {\r\n        result = SCALE;\r\n    }\r\n\r\n    /// @notice Calculates the square root of x, rounding down.\r\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\r\n    ///\r\n    /// Requirements:\r\n    /// - x cannot be negative.\r\n    /// - x must be less than MAX_SD59x18 / SCALE.\r\n    ///\r\n    /// @param x The signed 59.18-decimal fixed-point number for which to calculate the square root.\r\n    /// @return result The result as a signed 59.18-decimal fixed-point .\r\n    function sqrt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            if (x < 0) {\r\n                revert PRBMathSD59x18__SqrtNegativeInput(x);\r\n            }\r\n            if (x > MAX_SD59x18 / SCALE) {\r\n                revert PRBMathSD59x18__SqrtOverflow(x);\r\n            }\r\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two signed\r\n            // 59.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\r\n            result = int256(PRBMath.sqrt(uint256(x * SCALE)));\r\n        }\r\n    }\r\n\r\n    /// @notice Converts a signed 59.18-decimal fixed-point number to basic integer form, rounding down in the process.\r\n    /// @param x The signed 59.18-decimal fixed-point number to convert.\r\n    /// @return result The same number in basic integer form.\r\n    function toInt(int256 x) internal pure returns (int256 result) {\r\n        unchecked {\r\n            result = x / SCALE;\r\n        }\r\n    }\r\n}\r\n\r\n/// Imported from:\r\n/// https://github.com/notional-finance/contracts-v2/blob/23a3d5fcdba8a2e2ae6b0730f73eed810484e4cc/contracts/global/Types.sol\r\n/// @dev Holds information about a market, total storage is 42 bytes so this spans\r\n/// two storage words\r\nstruct MarketStorage {\r\n    // Total fCash in the market\r\n    uint80 totalfCash;\r\n    // Total asset cash in the market\r\n    uint80 totalAssetCash;\r\n    // Last annualized interest rate the market traded at\r\n    uint32 lastImpliedRate;\r\n    // Last recorded oracle rate for the market\r\n    uint32 oracleRate;\r\n    // Last time a trade was made\r\n    uint32 previousTradeTime;\r\n    // This is stored in slot + 1\r\n    uint80 totalLiquidity;\r\n}\r\n\r\n/// Imported from:\r\n/// https://github.com/notional-finance/contracts-v2/blob/23a3d5fcdba8a2e2ae6b0730f73eed810484e4cc/contracts/global/Types.sol\r\n/// @dev Market object as represented in memory\r\nstruct MarketParameters {\r\n    bytes32 storageSlot;\r\n    uint256 maturity;\r\n    // Total amount of fCash available for purchase in the market.\r\n    int256 totalfCash;\r\n    // Total amount of cash available for purchase in the market.\r\n    int256 totalAssetCash;\r\n    // Total amount of liquidity tokens (representing a claim on liquidity) in the market.\r\n    int256 totalLiquidity;\r\n    // This is the previous annualized interest rate in RATE_PRECISION that the market traded\r\n    // at. This is used to calculate the rate anchor to smooth interest rates over time.\r\n    // RATE_PRECISION is defined as 1e9 in the constants contract deployed here:\r\n    // https://github.com/notional-finance/contracts-v2/blob/23a3d5fcdba8a2e2ae6b0730f73eed810484e4cc/contracts/global/Constants.sol\r\n    uint256 lastImpliedRate;\r\n    // Time lagged version of lastImpliedRate, used to value fCash assets at market rates while\r\n    // remaining resistent to flash loan attacks.\r\n    uint256 oracleRate;\r\n    // This is the timestamp of the previous trade\r\n    uint256 previousTradeTime;\r\n}\r\n\r\ninterface INotionalView {\r\n    /// @notice Returns a single market\r\n    function getMarket(\r\n        uint16 currencyId_,\r\n        uint256 maturity_,\r\n        uint256 settlementDate_\r\n    ) external view returns (MarketParameters memory);\r\n\r\n    function getActiveMarkets(uint16 currencyId)\r\n        external\r\n        view\r\n        returns (MarketParameters[] memory);\r\n}\r\n\r\ncontract NotionalFinanceValueProvider is Oracle, Convert {\r\n    /// @notice Emitted when trying to add pull a value for an expired pool\r\n    error NotionalFinanceValueProvider__getValue_maturityLessThanBlocktime(\r\n        uint256 maturity\r\n    );\r\n\r\n    /// @notice Emitted when an invalid currencyId is used to deploy the contract\r\n    error NotionalFinanceValueProvider__constructor_invalidCurrencyId(\r\n        uint256 currencyId\r\n    );\r\n\r\n    /// @notice Emitted when the parameters do not map to an active / initialized Notional Market\r\n    error NotionalFinanceValueProvider__getValue_invalidMarketParameters(\r\n        uint256 currencyId,\r\n        uint256 maturityDate,\r\n        uint256 settlementDate\r\n    );\r\n\r\n    // Seconds in a 360 days year as used by Notional in 18 digits precision\r\n    int256 internal constant SECONDS_PER_YEAR = 31104000 * 1e18;\r\n\r\n    // Quarter computed as it's defined in the Notional protocol\r\n    // 3 months , 5 weeks per month, 6 days per week computed in seconds\r\n    // Reference: https://github.com/notional-finance/contracts-v2/blob/master/contracts/global/Constants.sol#L56\r\n    uint256 internal constant QUARTER = 3 * 5 * 6 * 86400;\r\n\r\n    address public immutable notional;\r\n    uint256 public immutable currencyId;\r\n    uint256 public immutable maturityDate;\r\n    uint256 public immutable oracleRateDecimals;\r\n\r\n    /// @notice Constructs the Value provider contracts with the needed Notional contract data in order to\r\n    /// calculate the per-second rate.\r\n    /// @param timeUpdateWindow_ Minimum time between updates of the value\r\n    /// @param notional_ The address of the deployed notional contract\r\n    /// @param currencyId_ Currency ID(eth = 1, dai = 2, usdc = 3, wbtc = 4)\r\n    /// @param oracleRateDecimals_ Precision of the Notional oracle rate\r\n    /// @param maturityDate_ Maturity date.\r\n    /// @dev reverts if the CurrencyId is bigger than uint16 max value\r\n    constructor(\r\n        // Oracle parameters\r\n        uint256 timeUpdateWindow_,\r\n        // Notional specific parameters\r\n        address notional_,\r\n        uint256 currencyId_,\r\n        uint256 oracleRateDecimals_,\r\n        uint256 maturityDate_\r\n    ) Oracle(timeUpdateWindow_) {\r\n        if (currencyId_ > type(uint16).max) {\r\n            revert NotionalFinanceValueProvider__constructor_invalidCurrencyId(\r\n                currencyId_\r\n            );\r\n        }\r\n\r\n        oracleRateDecimals = oracleRateDecimals_;\r\n        notional = notional_;\r\n        currencyId = currencyId_;\r\n        maturityDate = maturityDate_;\r\n    }\r\n\r\n    /// @notice Calculates the annual rate used by the FIAT DAO contracts\r\n    /// the rate is precomputed by the notional contract and scaled to 1e18 precision\r\n    /// @dev For more details regarding the computed rate in the Notional contracts:\r\n    /// https://github.com/notional-finance/contracts-v2/blob/b8e3792e39486b2719c6153acc270199377cc6b9/contracts/internal/markets/Market.sol#L495\r\n    /// @return result The result as an signed 59.18-decimal fixed-point number\r\n    function getValue() external view override(Oracle) returns (int256) {\r\n        // No values for matured pools\r\n        if (block.timestamp >= maturityDate) {\r\n            revert NotionalFinanceValueProvider__getValue_maturityLessThanBlocktime(\r\n                maturityDate\r\n            );\r\n        }\r\n\r\n        // Retrieve the oracle rate from Notional\r\n        uint256 oracleRate = getOracleRate();\r\n\r\n        // Convert rate per annum to 18 digits precision.\r\n        uint256 ratePerAnnum = uconvert(oracleRate, oracleRateDecimals, 18);\r\n\r\n        // Convert per annum to per second rate\r\n        int256 ratePerSecondD59x18 = PRBMathSD59x18.div(\r\n            int256(ratePerAnnum),\r\n            SECONDS_PER_YEAR\r\n        );\r\n\r\n        // Convert continuous compounding to discrete compounding rate\r\n        int256 discreteRateD59x18 = PRBMathSD59x18.exp(ratePerSecondD59x18) -\r\n            PRBMathSD59x18.SCALE;\r\n\r\n        // The result is a 59.18 fixed-point number.\r\n        return discreteRateD59x18;\r\n    }\r\n\r\n    /// @notice Retrieve the oracle rate from the NotionalFinance Market\r\n    function getOracleRate() internal view returns (uint256) {\r\n        uint256 settlementDate = getSettlementDate();\r\n        // Attempt to retrieve the oracle rate directly by using the maturity and settlement date\r\n        MarketParameters memory marketParams = INotionalView(notional)\r\n            .getMarket(uint16(currencyId), maturityDate, settlementDate);\r\n\r\n        // If we find an active market we can return the oracle rate otherwise we revert\r\n        if (marketParams.oracleRate <= 0) {\r\n            revert NotionalFinanceValueProvider__getValue_invalidMarketParameters(\r\n                currencyId,\r\n                maturityDate,\r\n                settlementDate\r\n            );\r\n        }\r\n\r\n        return marketParams.oracleRate;\r\n    }\r\n\r\n    /// @notice Computes the settlement date as is done in the NotionalFinance contracts\r\n    /// Reference 1:\r\n    /// https://github.com/notional-finance/contracts-v2/blob/d89be9474e181b322480830501728ea625e853d0/contracts/internal/markets/DateTime.sol#L14\r\n    /// Reference 2:\r\n    /// https://github.com/notional-finance/contracts-v2/blob/d89be9474e181b322480830501728ea625e853d0/contracts/internal/markets/Market.sol#L536\r\n    function getSettlementDate() public view returns (uint256) {\r\n        return block.timestamp - (block.timestamp % QUARTER) + QUARTER;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeUpdateWindow_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"notional_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"currencyId_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oracleRateDecimals_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Guarded__notGranted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Guarded__notRoot\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"NotionalFinanceValueProvider__constructor_invalidCurrencyId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currencyId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maturityDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"settlementDate\",\"type\":\"uint256\"}],\"name\":\"NotionalFinanceValueProvider__getValue_invalidMarketParameters\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maturity\",\"type\":\"uint256\"}],\"name\":\"NotionalFinanceValueProvider__getValue_maturityLessThanBlocktime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Oracle__nonReentrant\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__DivInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rAbs\",\"type\":\"uint256\"}],\"name\":\"PRBMathSD59x18__DivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__ExpInputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"prod1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__whenNotPaused_paused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Pausable__whenPaused_notPaused\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"AllowCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sig\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"BlockCaller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"OracleReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ValueInvalid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"currentValue\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"nextValue\",\"type\":\"int256\"}],\"name\":\"ValueUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ANY_CALLER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ANY_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"allowCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"blockCaller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"sig_\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"who_\",\"type\":\"address\"}],\"name\":\"canCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSettlementDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maturityDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextValue\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notional\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleRateDecimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeUpdateWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"update\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"value\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NotionalFinanceValueProvider", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "8000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000e100000000000000000000000001344a36a1b56144c3bc62e7757377d288fde0369000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000062b8f300", "EVMVersion": "Default", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5789b0128f73b83a7232a5d730f872544be39e445187b3b8c5afee39abe08e2b"}]}