{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n\r\n\r\n /$$   /$$                                                /$$$$$$  /$$       /$$ /$$            \r\n| $$  | $$                                               /$$__  $$| $$      |__/| $$            \r\n| $$  | $$  /$$$$$$   /$$$$$$   /$$$$$$  /$$   /$$      | $$  \\__/| $$$$$$$  /$$| $$$$$$$       \r\n| $$$$$$$$ |____  $$ /$$__  $$ /$$__  $$| $$  | $$      |  $$$$$$ | $$__  $$| $$| $$__  $$      \r\n| $$__  $$  /$$$$$$$| $$  \\ $$| $$  \\ $$| $$  | $$       \\____  $$| $$  \\ $$| $$| $$  \\ $$      \r\n| $$  | $$ /$$__  $$| $$  | $$| $$  | $$| $$  | $$       /$$  \\ $$| $$  | $$| $$| $$  | $$      \r\n| $$  | $$|  $$$$$$$| $$$$$$$/| $$$$$$$/|  $$$$$$$      |  $$$$$$/| $$  | $$| $$| $$$$$$$/      \r\n|__/  |__/ \\_______/| $$____/ | $$____/  \\____  $$       \\______/ |__/  |__/|__/|_______/       \r\n                    | $$      | $$       /$$  | $$                                              \r\n                    | $$      | $$      |  $$$$$$/                                              \r\n                    |__/      |__/       \\______/                                               \r\n\r\n\r\n\r\nWelcome to Happy Shib! The Happiest Shib on the Ethereum Network\r\n\r\nFind us @ https://t.me/happyshibeth\r\n\r\n*/\r\n\r\n//SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.6.12;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\ninterface IPancakeSwapFactory {\r\n        event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n        function feeTo() external view returns (address);\r\n        function feeToSetter() external view returns (address);\r\n\r\n        function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n        function allPairs(uint) external view returns (address pair);\r\n        function allPairsLength() external view returns (uint);\r\n\r\n        function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n        function setFeeTo(address) external;\r\n        function setFeeToSetter(address) external;\r\n}\r\n\r\ninterface IPancakeSwapPair {\r\n        event Approval(address indexed owner, address indexed spender, uint value);\r\n        event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n        function name() external pure returns (string memory);\r\n        function symbol() external pure returns (string memory);\r\n        function decimals() external pure returns (uint8);\r\n        function totalSupply() external view returns (uint);\r\n        function balanceOf(address owner) external view returns (uint);\r\n        function allowance(address owner, address spender) external view returns (uint);\r\n\r\n        function approve(address spender, uint value) external returns (bool);\r\n        function transfer(address to, uint value) external returns (bool);\r\n        function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n        function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n        function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n        function nonces(address owner) external view returns (uint);\r\n\r\n        function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n        event Mint(address indexed sender, uint amount0, uint amount1);\r\n        event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n        event Swap(\r\n                address indexed sender,\r\n                uint amount0In,\r\n                uint amount1In,\r\n                uint amount0Out,\r\n                uint amount1Out,\r\n                address indexed to\r\n        );\r\n        event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n        function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n        function factory() external view returns (address);\r\n        function token0() external view returns (address);\r\n        function token1() external view returns (address);\r\n        function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n        function price0CumulativeLast() external view returns (uint);\r\n        function price1CumulativeLast() external view returns (uint);\r\n        function kLast() external view returns (uint);\r\n\r\n        function mint(address to) external returns (uint liquidity);\r\n        function burn(address to) external returns (uint amount0, uint amount1);\r\n        function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n        function skim(address to) external;\r\n        function sync() external;\r\n\r\n        function initialize(address, address) external;\r\n}\r\n\r\ninterface IPancakeSwapRouter{\r\n        function factory() external pure returns (address);\r\n        function WETH() external pure returns (address);\r\n\r\n        function addLiquidity(\r\n                address tokenA,\r\n                address tokenB,\r\n                uint amountADesired,\r\n                uint amountBDesired,\r\n                uint amountAMin,\r\n                uint amountBMin,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint amountA, uint amountB, uint liquidity);\r\n        function addLiquidityETH(\r\n                address token,\r\n                uint amountTokenDesired,\r\n                uint amountTokenMin,\r\n                uint amountETHMin,\r\n                address to,\r\n                uint deadline\r\n        ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n        function removeLiquidity(\r\n                address tokenA,\r\n                address tokenB,\r\n                uint liquidity,\r\n                uint amountAMin,\r\n                uint amountBMin,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint amountA, uint amountB);\r\n        function removeLiquidityETH(\r\n                address token,\r\n                uint liquidity,\r\n                uint amountTokenMin,\r\n                uint amountETHMin,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint amountToken, uint amountETH);\r\n        function removeLiquidityWithPermit(\r\n                address tokenA,\r\n                address tokenB,\r\n                uint liquidity,\r\n                uint amountAMin,\r\n                uint amountBMin,\r\n                address to,\r\n                uint deadline,\r\n                bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n        ) external returns (uint amountA, uint amountB);\r\n        function removeLiquidityETHWithPermit(\r\n                address token,\r\n                uint liquidity,\r\n                uint amountTokenMin,\r\n                uint amountETHMin,\r\n                address to,\r\n                uint deadline,\r\n                bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n        ) external returns (uint amountToken, uint amountETH);\r\n        function swapExactTokensForTokens(\r\n                uint amountIn,\r\n                uint amountOutMin,\r\n                address[] calldata path,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint[] memory amounts);\r\n        function swapTokensForExactTokens(\r\n                uint amountOut,\r\n                uint amountInMax,\r\n                address[] calldata path,\r\n                address to,\r\n                uint deadline\r\n        ) external returns (uint[] memory amounts);\r\n        function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n                external\r\n                payable\r\n                returns (uint[] memory amounts);\r\n        function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n                external\r\n                returns (uint[] memory amounts);\r\n        function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n                external\r\n                returns (uint[] memory amounts);\r\n        function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n                external\r\n                payable\r\n                returns (uint[] memory amounts);\r\n\r\n        function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n        function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n        function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n        function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n        function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n        function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n            address token,\r\n            uint liquidity,\r\n            uint amountTokenMin,\r\n            uint amountETHMin,\r\n            address to,\r\n            uint deadline\r\n        ) external returns (uint amountETH);\r\n        function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n            address token,\r\n            uint liquidity,\r\n            uint amountTokenMin,\r\n            uint amountETHMin,\r\n            address to,\r\n            uint deadline,\r\n            bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n        ) external returns (uint amountETH);\r\n    \r\n        function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n            uint amountIn,\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n        ) external;\r\n        function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n        ) external payable;\r\n        function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            uint amountIn,\r\n            uint amountOutMin,\r\n            address[] calldata path,\r\n            address to,\r\n            uint deadline\r\n        ) external;\r\n}\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n    /* --------- Access Control --------- */\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev Initializes the contract setting the deployer as the initial owner.\r\n    */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the address of the current owner.\r\n    */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Leaves the contract without owner. It will not be possible to call\r\n    * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n    *\r\n    * NOTE: Renouncing ownership will leave the contract without an owner,\r\n    * thereby removing any functionality that is only available to the owner.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n    * Can only be called by the current owner.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n    */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n    /* --------- safe math --------- */\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Returns the addition of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `+` operator.\r\n    *\r\n    * Requirements:\r\n    * - Addition cannot overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n    * overflow (when the result is negative).\r\n    *\r\n    * Counterpart to Solidity's `-` operator.\r\n    *\r\n    * Requirements:\r\n    * - Subtraction cannot overflow.\r\n    */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the multiplication of two unsigned integers, reverting on\r\n    * overflow.\r\n    *\r\n    * Counterpart to Solidity's `*` operator.\r\n    *\r\n    * Requirements:\r\n    * - Multiplication cannot overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n        return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n    * division by zero. The result is rounded towards zero.\r\n    *\r\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n    * uses an invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n    * Reverts with custom message when dividing by zero.\r\n    *\r\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n    * invalid opcode to revert (consuming all remaining gas).\r\n    *\r\n    * Requirements:\r\n    * - The divisor cannot be zero.\r\n    */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract BALLS is  Context, Ownable  {\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    event SwapAndLiquify(\r\n        uint256 tokensSwapped,\r\n        uint256 ethReceived,\r\n        uint256 tokensIntoLiqudity\r\n    );\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) private _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n    uint8 private _decimals;\r\n    string private _symbol;\r\n    string private _name;\r\n\r\n\r\n    function getOwner() external view returns (address) {\r\n        return owner();\r\n        \r\n    }\r\n\r\n    function decimals() external view returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function symbol() external view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function name() external view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint256 amount) external returns (bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"BEP20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"BEP20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender,amount);\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint256 amount) internal {\r\n        require(account != address(0), \"BEP20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"BEP20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint256 amount) internal {\r\n        require(owner != address(0), \"BEP20: approve from the zero address\");\r\n        require(spender != address(0), \"BEP20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n \r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, _msgSender(), _allowances[account][_msgSender()].sub(amount, \"BEP20: burn amount exceeds allowance\"));\r\n    }\r\n\r\n    //////////////////////////////////////////////\r\n    /* ----------- special features ----------- */\r\n    //////////////////////////////////////////////\r\n\r\n    event ExcludeFromFee(address user, bool isExlcude);\r\n    event SetSellFee(Fees sellFees);\r\n    event SetBuyFee(Fees buyFees);\r\n\r\n    struct Fees {\r\n        uint256 marketing;\r\n        uint256 gameWallet;\r\n        uint256 liquidity;\r\n        uint256 poolfee;\r\n    }\r\n\r\n    /* --------- special address info --------- */\r\n    address public marketingAddress;\r\n    address public gameAddress;\r\n    address public poolAddress;\r\n    address public babyPoolAddress;\r\n\r\n    /* --------- exchange info --------- */\r\n    IPancakeSwapRouter public PancakeSwapRouter;\r\n    address public PancakeSwapV2Pair;\r\n\r\n    bool inSwapAndLiquify;\r\n    modifier lockTheSwap {\r\n        inSwapAndLiquify = true;\r\n        _;\r\n        inSwapAndLiquify = false;\r\n    }\r\n\r\n    bool public swapAndLiquifyEnabled = true;\r\n\r\n    /* --------- buyFees info --------- */\r\n    Fees public sellFees;\r\n    Fees public buyFees;\r\n\r\n    mapping(address=>bool) isExcludeFromFee;\r\n    mapping(address=>bool) isExcludeFromLimit;\r\n\r\n    /* --------- max tx info --------- */\r\n    uint public _maxTxAmount = 1e6 * 1e18;\r\n    uint public _maxWalletAmount = 2e6 * 1e18;\r\n    uint public numTokensSellToAddToLiquidity = 1e2 * 1e18;\r\n\r\n    ////////////////////////////////////////////////\r\n    /* --------- General Implementation --------- */\r\n    ////////////////////////////////////////////////\r\n\r\n    constructor (address _RouterAddress) public {\r\n        _name = \"HAPPYSHIB\";\r\n        _symbol = \"HSHiB\";\r\n        _decimals = 18;\r\n        _totalSupply = 1e8*1e18; /// initial supply 100,000,000\r\n        _balances[msg.sender] = _totalSupply;\r\n\r\n        buyFees.marketing = 6;\r\n        buyFees.gameWallet = 0;\r\n        buyFees.liquidity = 2;\r\n        buyFees.poolfee = 0;\r\n\r\n        sellFees.marketing = 8;\r\n        sellFees.gameWallet = 0;\r\n        sellFees.liquidity = 2;\r\n        buyFees.poolfee = 0;\r\n\r\n        IPancakeSwapRouter _PancakeSwapRouter = IPancakeSwapRouter(_RouterAddress);\r\n        PancakeSwapRouter = _PancakeSwapRouter;\r\n        PancakeSwapV2Pair = IPancakeSwapFactory(_PancakeSwapRouter.factory()).createPair(address(this), _PancakeSwapRouter.WETH()); //MD vs USDT pair\r\n        \r\n        isExcludeFromFee[msg.sender] = true;\r\n        isExcludeFromLimit[msg.sender] = true;\r\n        isExcludeFromLimit[PancakeSwapV2Pair] = true;\r\n\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n        emit SetBuyFee(buyFees);\r\n        emit SetSellFee(sellFees);\r\n    }\r\n\r\n    /* --------- set token parameters--------- */\r\n\r\n    function setInitialAddresses(address _RouterAddress) external onlyOwner {\r\n        IPancakeSwapRouter _PancakeSwapRouter = IPancakeSwapRouter(_RouterAddress);\r\n        PancakeSwapRouter = _PancakeSwapRouter;\r\n        PancakeSwapV2Pair = IPancakeSwapFactory(_PancakeSwapRouter.factory()).createPair(address(this), _PancakeSwapRouter.WETH()); //MD vs USDT pair\r\n    }\r\n\r\n    function setFeeAddresses( address _marketingAddress, address _gameAddress, address _poolAddress) external onlyOwner {\r\n        marketingAddress = _marketingAddress;       \r\n        gameAddress = _gameAddress; \r\n        poolAddress = _poolAddress;\r\n    }\r\n\r\n    function setMaxTxAmount(uint maxTxAmount) external onlyOwner {\r\n        _maxTxAmount = maxTxAmount;\r\n    }\r\n    \r\n    function setbuyFee(uint256 _marketingFee, uint256 _gameWalletFee, uint256 _liquidityFee, uint256 _poolfee) external onlyOwner {\r\n        buyFees.marketing = _marketingFee;\r\n        buyFees.gameWallet = _gameWalletFee;\r\n        buyFees.liquidity = _liquidityFee;\r\n        buyFees.poolfee = _poolfee;\r\n        emit SetBuyFee(buyFees);\r\n    }\r\n\r\n    function setsellFee(uint256 _marketingFee, uint256 _gameWalletFee, uint256 _liquidityFee, uint256 _poolfee) external onlyOwner {\r\n        sellFees.marketing = _marketingFee;\r\n        sellFees.gameWallet = _gameWalletFee;\r\n        sellFees.liquidity = _liquidityFee;\r\n        sellFees.poolfee = _poolfee;\r\n        emit SetSellFee(sellFees);\r\n    }\r\n\r\n    function getTotalSellFee() public view returns (uint) {\r\n        return sellFees.marketing + sellFees.gameWallet + sellFees.liquidity + sellFees.poolfee ;\r\n    }\r\n    \r\n    function getTotalBuyFee() public view returns (uint) {\r\n        return buyFees.marketing + buyFees.gameWallet + buyFees.liquidity + buyFees.poolfee ;\r\n    }\r\n\r\n    /* --------- exclude address from buyFees--------- */\r\n    function excludeAddressFromFee(address user,bool _isExclude) external onlyOwner {\r\n        isExcludeFromFee[user] = _isExclude;\r\n        emit ExcludeFromFee(user,_isExclude);\r\n    }\r\n\r\n    /* --------- exclude address from Limit--------- */\r\n    function excludeAddressFromLimit(address user,bool _isExclude) external onlyOwner {\r\n        isExcludeFromLimit[user] = _isExclude;\r\n    }\r\n\r\n    /* --------- transfer --------- */\r\n\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"BEP20: transfer from the zero address\");\r\n        require(recipient != address(0), \"BEP20: transfer to the zero address\");\r\n\r\n        // transfer \r\n        if((sender == PancakeSwapV2Pair || recipient == PancakeSwapV2Pair )&& !isExcludeFromFee[sender])\r\n            require(_maxTxAmount>=amount,\"BEP20: transfer amount exceeds max transfer amount\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"BEP20: transfer amount exceeds balance\");\r\n\r\n        uint recieveAmount = amount;\r\n\r\n        uint256 contractTokenBalance = balanceOf(address(this));\r\n        \r\n        if(contractTokenBalance >= _maxTxAmount)\r\n        {\r\n            contractTokenBalance = _maxTxAmount;\r\n        }\r\n        \r\n        bool overMinTokenBalance = contractTokenBalance >= numTokensSellToAddToLiquidity;\r\n\r\n        if (\r\n            overMinTokenBalance &&\r\n            !inSwapAndLiquify &&\r\n            sender != PancakeSwapV2Pair &&\r\n            swapAndLiquifyEnabled\r\n        ) {\r\n            contractTokenBalance = numTokensSellToAddToLiquidity;\r\n            //add liquidity\r\n            swapAndLiquify(contractTokenBalance);\r\n        }\r\n\r\n        if(!isExcludeFromFee[sender]) {\r\n\r\n            if(sender == PancakeSwapV2Pair){\r\n                // buy fee\r\n                recieveAmount = recieveAmount.mul(1000-getTotalBuyFee()).div(1000); \r\n                _balances[marketingAddress] += amount.mul(buyFees.marketing).div(1000);\r\n                _balances[gameAddress] += amount.mul(buyFees.gameWallet).div(1000);\r\n                _balances[poolAddress] += amount.mul(buyFees.poolfee).div(1000);\r\n                _balances[address(this)] += amount.mul(buyFees.liquidity).div(1000);\r\n                \r\n                emit Transfer(sender, marketingAddress, amount.mul(buyFees.marketing).div(1000));\r\n                emit Transfer(sender, gameAddress, amount.mul(buyFees.gameWallet).div(1000));\r\n                emit Transfer(sender, poolAddress, amount.mul(buyFees.poolfee).div(1000));\r\n                emit Transfer(sender, address(this), amount.mul(buyFees.liquidity).div(1000));\r\n            }\r\n            else if(recipient == PancakeSwapV2Pair){\r\n                // sell fee\r\n                recieveAmount = recieveAmount.mul(1000-getTotalSellFee()).div(1000);    \r\n                _balances[marketingAddress] += amount.mul(sellFees.marketing).div(1000);\r\n                _balances[gameAddress] += amount.mul(sellFees.gameWallet).div(1000);\r\n                _balances[poolAddress] += amount.mul(sellFees.poolfee).div(1000);\r\n                _balances[address(this)] += amount.mul(sellFees.liquidity).div(1000);\r\n\r\n                emit Transfer(sender, marketingAddress, amount.mul(sellFees.marketing).div(1000));\r\n                emit Transfer(sender, gameAddress, amount.mul(sellFees.gameWallet).div(1000));\r\n                emit Transfer(sender, poolAddress, amount.mul(sellFees.poolfee).div(1000));\r\n                emit Transfer(sender, address(this), amount.mul(sellFees.liquidity).div(1000));\r\n            }\r\n        }\r\n\r\n        _balances[recipient] = _balances[recipient].add(recieveAmount);\r\n\r\n        if(!isExcludeFromLimit[recipient])\r\n            require(_balances[recipient]<_maxWalletAmount,\"already balance exist max amount\");\r\n            \r\n        emit Transfer(sender, recipient, recieveAmount);\r\n    }\r\n\r\n    function swapAndLiquify(uint256 contractTokenBalance) private lockTheSwap {\r\n        // split the contract balance into halves\r\n        uint256 half = contractTokenBalance.div(2);\r\n        uint256 otherHalf = contractTokenBalance.sub(half);\r\n\r\n        uint256 initialBalance = address(this).balance;\r\n\r\n        swapTokensForEth(half); \r\n\r\n        uint256 newBalance = address(this).balance.sub(initialBalance);\r\n\r\n        addLiquidity(otherHalf, newBalance);\r\n        \r\n        emit SwapAndLiquify(half, newBalance, otherHalf);\r\n    }\r\n\r\n    function swapTokensForEth(uint256 tokenAmount) private {\r\n        address[] memory path = new address[](2);\r\n        path[0] = address(this);\r\n        path[1] = PancakeSwapRouter.WETH();\r\n\r\n        _approve(address(this), address(PancakeSwapRouter), tokenAmount);\r\n\r\n        PancakeSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n            tokenAmount,\r\n            0, \r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\r\n        _approve(address(this), address(PancakeSwapRouter), tokenAmount);\r\n\r\n        PancakeSwapRouter.addLiquidityETH{value: ethAmount}(\r\n            address(this),\r\n            tokenAmount,\r\n            0, // slippage is unavoidable\r\n            0, // slippage is unavoidable\r\n            owner(),\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    receive() external payable {\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RouterAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isExlcude\",\"type\":\"bool\"}],\"name\":\"ExcludeFromFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BALLS.Fees\",\"name\":\"buyFees\",\"type\":\"tuple\"}],\"name\":\"SetBuyFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct BALLS.Fees\",\"name\":\"sellFees\",\"type\":\"tuple\"}],\"name\":\"SetSellFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensSwapped\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethReceived\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensIntoLiqudity\",\"type\":\"uint256\"}],\"name\":\"SwapAndLiquify\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PancakeSwapRouter\",\"outputs\":[{\"internalType\":\"contract IPancakeSwapRouter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PancakeSwapV2Pair\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxTxAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_maxWalletAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"babyPoolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExclude\",\"type\":\"bool\"}],\"name\":\"excludeAddressFromFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isExclude\",\"type\":\"bool\"}],\"name\":\"excludeAddressFromLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalBuyFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalSellFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numTokensSellToAddToLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sellFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"marketing\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameWallet\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolfee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_marketingAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gameAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_poolAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_RouterAddress\",\"type\":\"address\"}],\"name\":\"setInitialAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTxAmount\",\"type\":\"uint256\"}],\"name\":\"setMaxTxAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gameWalletFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolfee\",\"type\":\"uint256\"}],\"name\":\"setbuyFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_marketingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_gameWalletFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_liquidityFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_poolfee\",\"type\":\"uint256\"}],\"name\":\"setsellFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapAndLiquifyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "BALLS", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007a250d5630b4cf539739df2c5dacb4c659f2488d", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://038659d8a59001eae7e3b8c460277d393d23bdb6005d3cd765314f8d52c2b26c"}]}