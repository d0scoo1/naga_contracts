{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Dape.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.7;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// Inspired by Solmate: https://github.com/Rari-Capital/solmate\\n/// Developed by 0xBasset\\n\\ncontract DAPE {\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                  CONSTANTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 constant public PERIOD = 15 days;\\n    uint256 constant public BONUS  = 5_000;\\n    uint256 constant public DAILY_RATE = 1000 ether;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    bool public paused;\\n\\n    ERC721Like public dapeNft;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    mapping(address => bool) public isMinter;\\n\\n    mapping(uint256 => Claim) public claims;\\n\\n    struct Claim {\\n       address owner;\\n       uint48  start;\\n       uint48  last;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function name() external pure returns (string memory) {\\n        return \\\"$DAPE\\\";\\n    }\\n\\n    function symbol() external pure returns (string memory) {\\n        return \\\"$DAPE\\\";\\n    }\\n    \\n    function decimals() external pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    \\n    function initialize(address dapeNft_) external { \\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        dapeNft = ERC721Like(dapeNft_);\\n    }\\n\\n    function approve(address spender, uint256 value) external returns (bool) {\\n        allowance[msg.sender][spender] = value;\\n\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 value) external returns (bool) {\\n        balanceOf[msg.sender] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(msg.sender, to, value);\\n\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool) {\\n        if (allowance[from][msg.sender] != type(uint256).max) {\\n            allowance[from][msg.sender] -= value;\\n        }\\n\\n        balanceOf[from] -= value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(from, to, value);\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              STAKING\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function claimMany(uint256[] calldata ids_) external {\\n        for (uint256 i = 0; i < ids_.length; i++) {\\n            claim(ids_[i]);\\n        }\\n    }\\n\\n    function claim(uint256 id_) public {\\n        require(!paused, \\\"claims are paused\\\");\\n\\n        Claim memory cl = claims[id_];\\n\\n        uint256 amt = _claimable(cl.start, cl.last);\\n\\n        claims[id_].last = uint48(block.timestamp);\\n        _mint(cl.owner, amt);\\n    }\\n\\n    function claimable(uint256 id_) public view returns (uint256 amt) {\\n        Claim memory cl = claims[id_];\\n        return _claimable(cl.start, cl.last);\\n    }\\n\\n    function _claimable(uint256 claimStart, uint256 claimLast) internal view returns (uint256 amt) {\\n        // Get current tranche\\n        uint256 lastTranche = _tranche(claimStart, claimLast);\\n        uint256 currTranche = _tranche(claimStart, block.timestamp); \\n        \\n        if (lastTranche != currTranche) {\\n            // If we are in different tranches, the first step is to get the remaining amount of last tranche\\n            (,uint256 end) = _boundaries(claimStart, lastTranche);\\n            amt           += _amountFor(end - claimLast, lastTranche);\\n\\n            // Now we get the corresponding amount for current tranche\\n            (uint256 start, ) = _boundaries(claimStart, currTranche);\\n            amt              += _amountFor(block.timestamp - start, currTranche); \\n\\n            // For every thanche between lastTranch and currTranche, we get the full amount\\n            for (uint256 i = lastTranche + 1; i < currTranche; i++) {\\n                amt += _amountFor(PERIOD, i);\\n            }\\n\\n        } else {\\n            amt = _amountFor(block.timestamp - claimLast, currTranche);\\n        }\\n    }\\n\\n    function _tranche(uint256 start, uint256 time) internal pure returns (uint256) {\\n        return (time - start) / PERIOD;\\n    }\\n\\n    function _amountFor(uint256 interval, uint256 tranche) internal pure returns (uint256) {\\n        return interval * _rate(tranche) / 1 days;\\n    }\\n\\n    function _boundaries(uint256 start, uint256 tranche) internal pure returns (uint256 beginning, uint256 end) {\\n        beginning = start + PERIOD * tranche;\\n        end       = beginning + PERIOD;\\n    }\\n\\n    function _rate(uint256 tranche) internal pure returns (uint256 rate) {\\n        rate = DAILY_RATE + ((tranche > 5 ? 5 : tranche) * BONUS * DAILY_RATE / 100_000);\\n    }\\n\\n    function stake(uint256[] calldata ids) external {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(ERC721Like(dapeNft).transferFrom(msg.sender, address(this), ids[i]), \\\"Transfer failed\\\");\\n            claims[ids[i]] = Claim(msg.sender, uint48(block.timestamp), uint48(block.timestamp));\\n        }\\n    }\\n\\n    function unstake(uint256[] calldata ids) external {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(claims[ids[i]].owner == msg.sender, \\\"not owner\\\");\\n            require(ERC721Like(dapeNft).transferFrom(address(this), msg.sender, ids[i]), \\\"Transfer failed\\\");\\n\\n            claim(ids[i]);\\n\\n            delete claims[ids[i]];\\n        }\\n    }\\n\\n    function onERC721Received(address,address,uint,bytes calldata) external pure returns(bytes4){\\n        return 0x150b7a02;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN PRIVILEGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function mint(address to, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO MINT\\\");\\n        _mint(to, value);\\n    }\\n\\n    function burn(address from, uint256 value) external {\\n        require(isMinter[msg.sender], \\\"FORBIDDEN TO BURN\\\");\\n        _burn(from, value);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                         Ruler Function\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setMinter(address minter, bool status) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        isMinter[minter] = status;\\n    }\\n\\n    function setRuler(address ruler_) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        bytes32 slot = bytes32(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\\n        assembly {\\n            sstore(slot, ruler_)\\n        }\\n    }\\n\\n    function setPaused(bool paused_) external {\\n        require(msg.sender == _owner(), \\\"not allowed\\\");\\n\\n        paused = paused_;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          INTERNAL UTILS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 value) internal {\\n        totalSupply += value;\\n\\n        // This is safe because the sum of all user\\n        // balances can't exceed type(uint256).max!\\n        unchecked {\\n            balanceOf[to] += value;\\n        }\\n\\n        emit Transfer(address(0), to, value);\\n    }\\n\\n    function _burn(address from, uint256 value) internal {\\n        balanceOf[from] -= value;\\n\\n        // This is safe because a user won't ever\\n        // have a balance larger than totalSupply!\\n        unchecked {\\n            totalSupply -= value;\\n        }\\n\\n        emit Transfer(from, address(0), value);\\n    }\\n\\n    function _owner() internal view returns (address owner_) {\\n        bytes32 slot = bytes32(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103);\\n        assembly {\\n            owner_ := sload(slot)\\n        }\\n    } \\n}\\n\\ninterface ERC721Like {\\n    function transferFrom(address from, address to, uint256 id) external returns (bool success);\\n    function ownerOf(uint256 id_) external view returns(address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DAILY_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERIOD\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids_\",\"type\":\"uint256[]\"}],\"name\":\"claimMany\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id_\",\"type\":\"uint256\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint48\",\"name\":\"start\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"last\",\"type\":\"uint48\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dapeNft\",\"outputs\":[{\"internalType\":\"contract ERC721Like\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dapeNft_\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused_\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ruler_\",\"type\":\"address\"}],\"name\":\"setRuler\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DAPE", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}