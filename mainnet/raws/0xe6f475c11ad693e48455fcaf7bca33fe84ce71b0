{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/src/Mingoes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721 } from \\\"./ERC721/ERC721.sol\\\";\\nimport { ERC721M } from \\\"./ERC721/ERC721M.sol\\\";\\nimport { ERC721Tradable } from \\\"./ERC721/extensions/ERC721Tradable.sol\\\";\\n\\nimport { Ownable } from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract Mingoes is ERC721M, ERC721Tradable, Ownable {\\n\\tuint256 public constant PRICE = 0.04 ether;\\n\\n\\tuint256 public constant MAX_SUPPLY = 10000;\\n\\tuint256 public constant MAX_RESERVE = 300;\\n\\tuint256 public constant MAX_PUBLIC = 9700; // MAX_SUPPLY - MAX_RESERVE\\n\\tuint256 public constant MAX_FREE = 200;\\n\\n\\tuint256 public constant MAX_TX = 20;\\n\\n\\tuint256 public reservesMinted;\\n\\n\\tstring public baseURI;\\n\\n\\tbool public isSaleActive;\\n\\n\\tmapping (address => bool) public hasClaimed;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                 CONSTRUCTOR                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\tconstructor(\\n\\t\\taddress _openSeaProxyRegistry,\\n\\t\\taddress _looksRareTransferManager,\\n\\t\\tstring memory _baseURI\\n\\t) payable ERC721M(\\\"Mingoes\\\", \\\"MINGOES\\\") ERC721Tradable(_openSeaProxyRegistry, _looksRareTransferManager) {\\n\\t\\tbaseURI = _baseURI;\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                    USER                                    */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Mints an amount of tokens and transfers them to the caller during the public sale.\\n\\t/// @param amount The amount of tokens to mint.\\n\\tfunction publicMint(uint256 amount) external payable {\\n\\t\\trequire(isSaleActive, \\\"Sale is not active\\\");\\n\\t\\trequire(msg.sender == tx.origin, \\\"No contracts allowed\\\");\\n\\n\\t\\tuint256 _totalSupply = totalSupply();\\n\\t\\tif (_totalSupply < MAX_FREE) {\\n\\t\\t\\trequire(!hasClaimed[msg.sender], \\\"Already claimed\\\");\\n\\t\\t\\thasClaimed[msg.sender] = true;\\n\\t\\t\\t\\n\\t\\t\\t_mint(msg.sender, 1);\\n\\t\\t\\t\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\t\\t\\n\\t\\trequire(msg.value == PRICE * amount, \\\"Wrong ether amount\\\");\\n\\t\\trequire(amount <= MAX_TX, \\\"Amount exceeds tx limit\\\");\\n\\t\\trequire(_totalSupply + amount <= MAX_PUBLIC, \\\"Max public supply reached\\\");\\n\\n\\t\\t_mint(msg.sender, amount);\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                    OWNER                                   */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Enables or disables minting through {publicMint}.\\n\\t/// @dev Requirements:\\n\\t/// - Caller must be the owner.\\n\\tfunction setIsSaleActive(bool _isSaleActive) external onlyOwner {\\n\\t\\tisSaleActive = _isSaleActive;\\n\\t}\\n\\n\\t/// @notice Mints tokens to multiple addresses.\\n\\t/// @dev Requirements:\\n\\t/// - Caller must be the owner.\\n\\t/// @param recipients The addresses to mint the tokens to.\\n\\t/// @param amounts The amounts of tokens to mint.\\n\\tfunction reserveMint(address[] calldata recipients, uint256[] calldata amounts) external onlyOwner {\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 sum;\\n\\t\\t\\tuint256 length = recipients.length;\\n\\t\\t\\tfor (uint256 i; i < length; i++) {\\n\\t\\t\\t\\taddress to = recipients[i];\\n\\t\\t\\t\\trequire(to != address(0), \\\"Invalid recipient\\\");\\n\\t\\t\\t\\tuint256 amount = amounts[i];\\n\\n\\t\\t\\t\\t_mint(to, amount);\\n\\t\\t\\t\\tsum += amount;\\n\\t\\t\\t}\\n\\n\\t\\t\\tuint256 totalReserves = reservesMinted + sum;\\n\\n\\t\\t\\trequire(totalSupply() <= MAX_SUPPLY, \\\"Max supply reached\\\");\\n\\t\\t\\trequire(totalReserves <= MAX_RESERVE, \\\"Amount exceeds reserve limit\\\");\\n\\n\\t\\t\\treservesMinted = totalReserves;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @notice Sets the base Uniform Resource Identifier (URI) for token metadata.\\n\\t/// @dev Requirements:\\n\\t/// - Caller must be the owner.\\n\\t/// @param _baseURI The base URI.\\n\\tfunction setBaseURI(string calldata _baseURI) external onlyOwner {\\n\\t\\tbaseURI = _baseURI;\\n\\t}\\n\\n\\t/// @notice Withdraws all contract balance to the caller.\\n\\t/// @dev Requirements:\\n\\t/// - Caller must be the owner.\\n\\tfunction withdrawETH() external onlyOwner {\\n\\t\\t_transferETH(msg.sender, address(this).balance);\\n\\t}\\n\\n\\t/// @dev Requirements:\\n\\t/// - Caller must be the owner.\\n\\t/// @inheritdoc ERC721Tradable\\n\\tfunction setMarketplaceApprovalForAll(bool approved) public override onlyOwner {\\n\\t\\tmarketPlaceApprovalForAll = approved;\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                             SOLIDITY OVERRIDES                             */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction tokenURI(uint256 id) public view override returns (string memory) {\\n\\t\\trequire(_exists(id), \\\"NONEXISTENT_TOKEN\\\");\\n\\t\\tstring memory _baseURI = baseURI;\\n\\t\\treturn bytes(_baseURI).length == 0 ? \\\"\\\" : string(abi.encodePacked(_baseURI, toString(id)));\\n\\t}\\n\\n\\t/// @inheritdoc ERC721Tradable\\n\\tfunction isApprovedForAll(address owner, address operator) public view override(ERC721, ERC721Tradable) returns (bool) {\\n\\t\\treturn ERC721Tradable.isApprovedForAll(owner, operator);\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                    UTILS                                   */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\tfunction _transferETH(address to, uint256 value) internal {\\n\\t\\t// solhint-disable-next-line avoid-low-level-calls\\n\\t\\t(bool success, ) = to.call{ value: value }(\\\"\\\");\\n\\t\\trequire(success, \\\"ETH transfer failed\\\");\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721TokenReceiver } from \\\"./ERC721TokenReceiver.sol\\\";\\n\\nabstract contract ERC721 {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                   EVENTS                                   */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev Emitted when `id` token is transferred from `from` to `to`.\\n\\tevent Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n\\t/// @dev Emitted when `owner` enables `approved` to manage the `id` token.\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n\\t/// @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n\\tevent ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                              METADATA STORAGE                              */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev The collection name.\\n\\tstring private _name;\\n\\n\\t/// @dev The collection symbol.\\n\\tstring private _symbol;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               ERC721 STORAGE                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev ID => spender\\n\\tmapping(uint256 => address) internal _tokenApprovals;\\n\\n\\t/// @dev owner => operator => approved\\n\\tmapping(address => mapping(address => bool)) internal _operatorApprovals;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                 CONSTRUCTOR                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @param name_ The collection name.\\n\\t/// @param symbol_ The collection symbol.\\n\\tconstructor(string memory name_, string memory symbol_) {\\n\\t\\t_name = name_;\\n\\t\\t_symbol = symbol_;\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                ERC165 LOGIC                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Returns true if this contract implements an interface from its ID.\\n\\t/// @dev See the corresponding\\n\\t/// [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)\\n\\t/// to learn more about how these IDs are created.\\n\\t/// @return The implementation status.\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n\\t\\treturn\\n\\t\\t\\tinterfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n\\t\\t\\tinterfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n\\t\\t\\tinterfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC721Metadata\\n\\t\\t\\tinterfaceId == 0x780e9d63; // ERC165 Interface ID for ERC721Enumerable\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               METADATA LOGIC                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Returns the collection name.\\n\\t/// @return The collection name.\\n\\tfunction name() public view virtual returns (string memory) {\\n\\t\\treturn _name;\\n\\t}\\n\\n\\t/// @notice Returns the collection symbol.\\n\\t/// @return The collection symbol.\\n\\tfunction symbol() public view virtual returns (string memory) {\\n\\t\\treturn _symbol;\\n\\t}\\n\\n\\t/// @notice Returns the Uniform Resource Identifier (URI) for `id` token.\\n\\t/// @param id The token ID.\\n\\t/// @return The URI.\\n\\tfunction tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                              ENUMERABLE LOGIC                              */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Returns the total amount of tokens stored by the contract.\\n\\t/// @return The token supply.\\n\\tfunction totalSupply() public view virtual returns (uint256);\\n\\n\\t/// @notice Returns a token ID owned by `owner` at a given `index` of its token list.\\n\\t/// @dev Use along with {balanceOf} to enumerate all of `owner`'s tokens.\\n\\t/// @param owner The address to query.\\n\\t/// @param index The index to query.\\n\\t/// @return The token ID.\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual returns (uint256);\\n\\n\\t/// @notice Returns a token ID at a given `index` of all the tokens stored by the contract.\\n\\t/// @dev Use along with {totalSupply} to enumerate all tokens.\\n\\t/// @param index The index to query.\\n\\t/// @return The token ID.\\n\\tfunction tokenByIndex(uint256 index) public view virtual returns (uint256);\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                ERC721 LOGIC                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Returns the account approved for a token ID.\\n\\t/// @dev Requirements:\\n\\t/// - `id` must exist.\\n\\t/// @param id Token ID to query.\\n\\t/// @return The account approved for `id` token.\\n\\tfunction getApproved(uint256 id) public virtual returns (address) {\\n\\t\\trequire(_exists(id), \\\"NONEXISTENT_TOKEN\\\");\\n\\t\\treturn _tokenApprovals[id];\\n\\t}\\n\\n\\t/// @notice Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n\\t/// @param owner The address of the owner.\\n\\t/// @param operator The address of the operator.\\n\\t/// @return True if `operator` was approved by `owner`.\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\\n\\t\\treturn _operatorApprovals[owner][operator];\\n\\t}\\n\\n\\t/// @notice Gives permission to `to` to transfer `id` token to another account.\\n\\t/// @dev The approval is cleared when the token is transferred.\\n\\t/// Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n\\t/// Requirements:\\n\\t/// - The caller must own the token or be an approved operator.\\n\\t/// - `id` must exist.\\n\\t/// Emits an {Approval} event.\\n\\t/// @param spender The address of the spender to approve to.\\n\\t/// @param id The token ID to approve.\\n\\tfunction approve(address spender, uint256 id) public virtual {\\n\\t\\taddress owner = ownerOf(id);\\n\\n\\t\\trequire(isApprovedForAll(owner, msg.sender) || msg.sender == owner, \\\"NOT_AUTHORIZED\\\");\\n\\n\\t\\t_tokenApprovals[id] = spender;\\n\\n\\t\\temit Approval(owner, spender, id);\\n\\t}\\n\\n\\t/// @notice Approve or remove `operator` as an operator for the caller.\\n\\t/// @dev Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n\\t/// Emits an {ApprovalForAll} event.\\n\\t/// @param operator The address of the operator to approve.\\n\\t/// @param approved The status to set.\\n\\tfunction setApprovalForAll(address operator, bool approved) public virtual {\\n\\t\\t_operatorApprovals[msg.sender][operator] = approved;\\n\\n\\t\\temit ApprovalForAll(msg.sender, operator, approved);\\n\\t}\\n\\n\\t/// @notice Transfers `id` token from `from` to `to`.\\n\\t/// WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n\\t/// @dev Requirements:\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - `id` token must be owned by `from`.\\n\\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t/// Emits a {Transfer} event.\\n\\t/// @param from The address to transfer from.\\n\\t/// @param to The address to transfer to.\\n\\t/// @param id The token ID to transfer.\\n\\tfunction transferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id\\n\\t) public virtual {\\n\\t\\t_transfer(from, to, id);\\n\\t}\\n\\n\\t/// @notice Safely transfers `id` token from `from` to `to`.\\n\\t/// @dev Requirements:\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - `id` token must exist and be owned by `from`.\\n\\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver-onERC721Received}, which is called upon a safe transfer.\\n\\t/// Emits a {Transfer} event.\\n\\t/// @param from The address to transfer from.\\n\\t/// @param to The address to transfer to.\\n\\t/// @param id The token ID to transfer.\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id\\n\\t) public virtual {\\n\\t\\t_transfer(from, to, id);\\n\\n\\t\\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") == ERC721TokenReceiver.onERC721Received.selector, \\\"UNSAFE_RECIPIENT\\\");\\n\\t}\\n\\n\\t/// @notice Safely transfers `id` token from `from` to `to`.\\n\\t/// @dev Requirements:\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - `id` token must exist and be owned by `from`.\\n\\t/// - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n\\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver-onERC721Received}, which is called upon a safe transfer.\\n\\t/// Emits a {Transfer} event.\\n\\t/// Additionally passes `data` in the callback.\\n\\t/// @param from The address to transfer from.\\n\\t/// @param to The address to transfer to.\\n\\t/// @param id The token ID to transfer.\\n\\t/// @param data The calldata to pass in the {ERC721TokenReceiver-onERC721Received} callback.\\n\\tfunction safeTransferFrom(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id,\\n\\t\\tbytes memory data\\n\\t) public virtual {\\n\\t\\t_transfer(from, to, id);\\n\\n\\t\\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) == ERC721TokenReceiver.onERC721Received.selector, \\\"UNSAFE_RECIPIENT\\\");\\n\\t}\\n\\n\\t/// @notice Returns the number of tokens in an account.\\n\\t/// @param owner The address to query.\\n\\t/// @return The balance.\\n\\tfunction balanceOf(address owner) public view virtual returns (uint256);\\n\\n\\t/// @notice Returns the owner of a token ID.\\n\\t/// @dev Requirements:\\n\\t/// - `id` must exist.\\n\\t/// @param id The token ID.\\n\\tfunction ownerOf(uint256 id) public view virtual returns (address);\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               INTERNAL LOGIC                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev Returns whether a token ID exists.\\n\\t/// Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n\\t/// Tokens start existing when they are minted.\\n\\t/// @param id Token ID to query.\\n\\tfunction _exists(uint256 id) internal view virtual returns (bool);\\n\\n\\t/// @dev Transfers `id` from `from` to `to`.\\n\\t/// Requirements:\\n\\t/// - `to` cannot be the zero address.\\n\\t/// - `id` token must be owned by `from`.\\n\\t/// Emits a {Transfer} event.\\n\\t/// @param from The address to transfer from.\\n\\t/// @param to The address to transfer to.\\n\\t/// @param id The token ID to transfer.\\n\\tfunction _transfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id\\n\\t) internal virtual;\\n\\n\\t/// @dev Mints `amount` tokens to `to`.\\n\\t/// Requirements:\\n\\t/// - there must be `amount` tokens remaining unminted in the total collection.\\n\\t/// - `to` cannot be the zero address.\\n\\t/// Emits `amount` {Transfer} events.\\n\\t/// @param to The address to mint to.\\n\\t/// @param amount The amount of tokens to mint.\\n\\tfunction _mint(address to, uint256 amount) internal virtual;\\n\\n\\t/// @dev Safely mints `amount` of tokens and transfers them to `to`.\\n\\t/// If `to` is a contract it must implement {ERC721TokenReceiver.onERC721Received}\\n\\t/// that returns {ERC721TokenReceiver.onERC721Received.selector}.\\n\\t/// @param to The address to mint to.\\n\\t/// @param amount The amount of tokens to mint.\\n\\tfunction _safeMint(address to, uint256 amount) internal virtual {\\n\\t\\t_mint(to, amount);\\n\\n\\t\\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(address(0), to, totalSupply() - amount + 1, \\\"\\\") == ERC721TokenReceiver.onERC721Received.selector, \\\"UNSAFE_RECIPIENT\\\");\\n\\t}\\n\\n\\t/// @dev Safely mints `amount` of tokens and transfers them to `to`.\\n\\t/// Requirements:\\n\\t/// - `id` must not exist.\\n\\t/// - If `to` refers to a smart contract, it must implement {ERC721TokenReceiver.onERC721Received}, which is called upon a safe transfer.\\n\\t/// Additionally passes `data` in the callback.\\n\\t/// @param to The address to mint to.\\n\\t/// @param amount The amount of tokens to mint.\\n\\t/// @param data The calldata to pass in the {ERC721TokenReceiver.onERC721Received} callback.\\n\\tfunction _safeMint(\\n\\t\\taddress to,\\n\\t\\tuint256 amount,\\n\\t\\tbytes memory data\\n\\t) internal virtual {\\n\\t\\t_mint(to, amount);\\n\\n\\t\\trequire(to.code.length == 0 || ERC721TokenReceiver(to).onERC721Received(address(0), to, totalSupply() - amount + 1, data) == ERC721TokenReceiver.onERC721Received.selector, \\\"UNSAFE_RECIPIENT\\\");\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                    UTILS                                   */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Converts a `uint256` to its ASCII `string` decimal representation.\\n\\t/// @dev https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol\\n\\tfunction toString(uint256 value) internal pure virtual returns (string memory) {\\n\\t\\t// Inspired by OraclizeAPI's implementation - MIT licence\\n\\t\\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n\\t\\tif (value == 0) {\\n\\t\\t\\treturn \\\"0\\\";\\n\\t\\t}\\n\\t\\tuint256 temp = value;\\n\\t\\tuint256 digits;\\n\\t\\twhile (temp != 0) {\\n\\t\\t\\tdigits++;\\n\\t\\t\\ttemp /= 10;\\n\\t\\t}\\n\\t\\tbytes memory buffer = new bytes(digits);\\n\\t\\twhile (value != 0) {\\n\\t\\t\\tdigits -= 1;\\n\\t\\t\\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n\\t\\t\\tvalue /= 10;\\n\\t\\t}\\n\\t\\treturn string(buffer);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC721/ERC721M.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721 } from \\\"./ERC721.sol\\\";\\n\\nabstract contract ERC721M is ERC721 {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               ERC721M STORAGE                              */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev The index is the token ID counter and points to its owner.\\n\\taddress[] internal _owners;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                 CONSTRUCTOR                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\tconstructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {\\n\\t\\t// Initializes the index to 1.\\n\\t\\t_owners.push();\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                              ENUMERABLE LOGIC                              */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction totalSupply() public view override returns (uint256) {\\n\\t\\t// Overflow is impossible as _owners.length is initialized to 1.\\n\\t\\tunchecked {\\n\\t\\t\\treturn _owners.length - 1;\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev O(totalSupply), it is discouraged to call this function from other contracts\\n\\t/// as it can become very expensive, especially with higher total collection sizes.\\n\\t/// @inheritdoc ERC721\\n\\tfunction tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n\\t\\trequire(index < balanceOf(owner), \\\"INVALID_INDEX\\\");\\n\\n\\t\\t// Both of the counters cannot overflow because the loop breaks before that.\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 count;\\n\\t\\t\\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\\n\\t\\t\\tfor (uint256 i; i < _currentIndex; i++) {\\n\\t\\t\\t\\tif (owner == ownerOf(i)) {\\n\\t\\t\\t\\t\\tif (count == index) return i;\\n\\t\\t\\t\\t\\telse count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\trevert(\\\"NOT_FOUND\\\");\\n\\t}\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n\\t\\trequire(_exists(index), \\\"INVALID_INDEX\\\");\\n\\t\\treturn index;\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                ERC721 LOGIC                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @dev O(totalSupply), it is discouraged to call this function from other contracts\\n\\t/// as it can become very expensive, especially with higher total collection sizes.\\n\\t/// @inheritdoc ERC721\\n\\tfunction balanceOf(address owner) public view virtual override returns (uint256 balance) {\\n\\t\\trequire(owner != address(0), \\\"INVALID_OWNER\\\");\\n\\n\\t\\tunchecked {\\n\\t\\t\\t// Start at 1 since token 0 does not exist\\n\\t\\t\\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\\n\\t\\t\\tfor (uint256 i = 1; i < _currentIndex; i++) {\\n\\t\\t\\t\\tif (owner == ownerOf(i)) {\\n\\t\\t\\t\\t\\tbalance++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/// @dev O(MAX_TX), gradually moves to O(1) as more tokens get transferred and\\n\\t/// the owners are explicitly set.\\n\\t/// @inheritdoc ERC721\\n\\tfunction ownerOf(uint256 id) public view virtual override returns (address owner) {\\n\\t\\trequire(_exists(id), \\\"NONEXISTENT_TOKEN\\\");\\n\\n\\t\\tfor (uint256 i = id; ; i++) {\\n\\t\\t\\towner = _owners[i];\\n\\t\\t\\tif (owner != address(0)) {\\n\\t\\t\\t\\treturn owner;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               INTERNAL LOGIC                               */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction _mint(address to, uint256 amount) internal virtual override {\\n\\t\\trequire(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\t\\trequire(amount != 0, \\\"INVALID_AMOUNT\\\");\\n\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 _currentIndex = _owners.length; // == totalSupply() + 1 == _owners.length - 1 + 1\\n\\n\\t\\t\\tfor (uint256 i; i < amount - 1; i++) {\\n\\t\\t\\t\\t// storing address(0) while also incrementing the index\\n\\t\\t\\t\\t_owners.push();\\n\\t\\t\\t\\temit Transfer(address(0), to, _currentIndex + i);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// storing the actual owner\\n\\t\\t\\t_owners.push(to);\\n\\t\\t\\temit Transfer(address(0), to, _currentIndex + (amount - 1));\\n\\t\\t}\\n\\t}\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction _exists(uint256 id) internal view virtual override returns (bool) {\\n\\t\\treturn id != 0 && id < _owners.length;\\n\\t}\\n\\n\\t/// @inheritdoc ERC721\\n\\tfunction _transfer(\\n\\t\\taddress from,\\n\\t\\taddress to,\\n\\t\\tuint256 id\\n\\t) internal virtual override {\\n\\t\\trequire(ownerOf(id) == from, \\\"WRONG_FROM\\\");\\n\\t\\trequire(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\t\\trequire(msg.sender == from || getApproved(id) == msg.sender || isApprovedForAll(from, msg.sender), \\\"NOT_AUTHORIZED\\\");\\n\\n\\t\\tdelete _tokenApprovals[id];\\n\\n\\t\\t_owners[id] = to;\\n\\n\\t\\tunchecked {\\n\\t\\t\\tuint256 prevId = id - 1;\\n\\t\\t\\tif (_owners[prevId] == address(0)) {\\n\\t\\t\\t\\t_owners[prevId] = from;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\temit Transfer(from, to, id);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC721/extensions/ERC721Tradable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721 } from \\\"../ERC721.sol\\\";\\n\\n/// @notice An interface for the OpenSea Proxy Registry.\\ninterface IProxyRegistry {\\n\\tfunction proxies(address) external view returns (address);\\n}\\n\\nabstract contract ERC721Tradable is ERC721 {\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                              IMMUTABLE STORAGE                             */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice The OpenSea Proxy Registry address.\\n\\taddress public immutable openSeaProxyRegistry;\\n\\n\\t/// @notice The LooksRare Transfer Manager (ERC721) address.\\n\\taddress public immutable looksRareTransferManager;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                               MUTABLE STORAGE                              */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Returns true if the stored marketplace addresses are whitelisted in {isApprovedForAll}.\\n\\t/// @dev Enabled by default. Can be turned off with {setMarketplaceApprovalForAll}.\\n\\tbool public marketPlaceApprovalForAll = true;\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                                 CONSTRUCTOR                                */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// OpenSea proxy registry addresses:\\n\\t/// - ETHEREUM MAINNET: 0xa5409ec958C83C3f309868babACA7c86DCB077c1\\n\\t/// - ETHEREUM RINKEBY: 0xF57B2c51dED3A29e6891aba85459d600256Cf317\\n\\t/// LooksRare Transfer Manager addresses (https://docs.looksrare.org/developers/deployed-contract-addresses):\\n\\t/// - ETHEREUM MAINNET: 0xf42aa99F011A1fA7CDA90E5E98b277E306BcA83e\\n\\t/// - ETHEREUM RINKEBY: 0x3f65A762F15D01809cDC6B43d8849fF24949c86a\\n\\t/// @param _openSeaProxyRegistry The OpenSea proxy registry address.\\n\\tconstructor(address _openSeaProxyRegistry, address _looksRareTransferManager) {\\n\\t\\trequire(_openSeaProxyRegistry != address(0) && _looksRareTransferManager != address(0), \\\"INVALID_ADDRESS\\\");\\n\\t\\topenSeaProxyRegistry = _openSeaProxyRegistry;\\n\\t\\tlooksRareTransferManager = _looksRareTransferManager;\\n\\t}\\n\\n\\t/* -------------------------------------------------------------------------- */\\n\\t/*                            ERC721ATradable LOGIC                           */\\n\\t/* -------------------------------------------------------------------------- */\\n\\n\\t/// @notice Enables or disables the marketplace whitelist in {isApprovedForAll}.\\n\\t/// @dev Must be implemented in inheriting contracts.\\n\\t/// Recommended to use in combination with an access control contract (e.g. OpenZeppelin's Ownable).\\n\\tfunction setMarketplaceApprovalForAll(bool approved) public virtual;\\n\\n\\t/// @return True if `operator` is a whitelisted marketplace contract or if it was approved by `owner` with {ERC721A.setApprovalForAll}.\\n\\t/// @inheritdoc ERC721\\n\\tfunction isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n\\t\\tif (marketPlaceApprovalForAll && (operator == IProxyRegistry(openSeaProxyRegistry).proxies(owner) || operator == looksRareTransferManager)) return true;\\n\\t\\treturn super.isApprovedForAll(owner, operator);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/src/ERC721/ERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n\\tfunction onERC721Received(\\n\\t\\taddress operator,\\n\\t\\taddress from,\\n\\t\\tuint256 id,\\n\\t\\tbytes calldata data\\n\\t) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_openSeaProxyRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_looksRareTransferManager\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_FREE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PUBLIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_RESERVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"looksRareTransferManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketPlaceApprovalForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSeaProxyRegistry\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"reserveMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reservesMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSaleActive\",\"type\":\"bool\"}],\"name\":\"setIsSaleActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setMarketplaceApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Mingoes", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c1000000000000000000000000f42aa99f011a1fa7cda90e5e98b277e306bca83e00000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}