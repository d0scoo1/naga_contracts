{"status": "1", "message": "OK", "result": [{"SourceCode": "// Sources flattened with hardhat v2.6.7 https://hardhat.org\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v3.4.0\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/math/SafeMath.sol@v3.4.0\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it's recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        uint256 c = a + b;\r\n        if (c < a) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b > a) return (false, 0);\r\n        return (true, a - b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) return (true, 0);\r\n        uint256 c = a * b;\r\n        if (c / a != b) return (false, 0);\r\n        return (true, c);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a / b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\r\n        if (b == 0) return (false, 0);\r\n        return (true, a % b);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {trySub}.\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * reverting with custom message when dividing by zero.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryMod}.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b > 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v3.4.0\r\n\r\n\r\n\r\npragma solidity >=0.6.2 <0.8.0;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n        (bool success, ) = recipient.call{ value: amount }(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain`call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n      return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return _verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/SafeERC20.sol@v3.4.0\r\n\r\n\r\n\r\npragma solidity >=0.6.0 <0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint256;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        // solhint-disable-next-line max-line-length\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/convex/IConvexBooster.sol\r\n\r\n\r\n/* \r\n\r\n  _                          _   _____   _                       \r\n | |       ___   _ __     __| | |  ___| | |   __ _   _ __    ___ \r\n | |      / _ \\ | '_ \\   / _` | | |_    | |  / _` | | '__|  / _ \\\r\n | |___  |  __/ | | | | | (_| | |  _|   | | | (_| | | |    |  __/\r\n |_____|  \\___| |_| |_|  \\__,_| |_|     |_|  \\__,_| |_|     \\___|\r\n                                                                 \r\nLendFlare.finance\r\n*/\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface IConvexBooster {\r\n    function liquidate(\r\n        uint256 _convexPid,\r\n        int128 _curveCoinId,\r\n        address _user,\r\n        uint256 _amount\r\n    ) external returns (address, uint256);\r\n\r\n    function depositFor(\r\n        uint256 _convexPid,\r\n        uint256 _amount,\r\n        address _user\r\n    ) external returns (bool);\r\n\r\n    function withdrawFor(\r\n        uint256 _convexPid,\r\n        uint256 _amount,\r\n        address _user,\r\n        bool _freezeTokens\r\n    ) external returns (bool);\r\n\r\n    function poolInfo(uint256 _convexPid)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 originConvexPid,\r\n            address curveSwapAddress,\r\n            address lpToken,\r\n            address originCrvRewards,\r\n            address originStash,\r\n            address virtualBalance,\r\n            address rewardCrvPool,\r\n            address rewardCvxPool,\r\n            bool shutdown\r\n        );\r\n\r\n    function addConvexPool(uint256 _originConvexPid) external;\r\n}\r\n\r\n\r\n// File contracts/convex/ConvexInterfaces.sol\r\n\r\n\r\n/* \r\n\r\n  _                          _   _____   _                       \r\n | |       ___   _ __     __| | |  ___| | |   __ _   _ __    ___ \r\n | |      / _ \\ | '_ \\   / _` | | |_    | |  / _` | | '__|  / _ \\\r\n | |___  |  __/ | | | | | (_| | |  _|   | | | (_| | | |    |  __/\r\n |_____|  \\___| |_| |_|  \\__,_| |_|     |_|  \\__,_| |_|     \\___|\r\n                                                                 \r\nLendFlare.finance\r\n*/\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface IOriginConvexBooster {\r\n    function deposit( uint256 _pid, uint256 _amount, bool _stake ) external returns (bool);\r\n    function withdraw(uint256 _pid, uint256 _amount) external returns(bool);\r\n    function claimStashToken(address _token, address _rewardAddress, address _lfRewardAddress, uint256 _rewards) external;\r\n    function poolInfo(uint256) external view returns(address,address,address,address,address, bool);\r\n    function isShutdown() external view returns(bool);\r\n    function minter() external view returns(address);\r\n    function earmarkRewards(uint256) external returns(bool);\r\n}\r\n\r\ninterface IOriginConvexRewardPool {\r\n    function getReward() external returns(bool);\r\n    function getReward(address _account, bool _claimExtras) external returns(bool);\r\n    function withdrawAllAndUnwrap(bool claim) external;\r\n    function withdrawAndUnwrap(uint256 amount, bool claim) external returns(bool);\r\n    function withdrawAll(bool claim) external;\r\n    function withdraw(uint256 amount, bool claim) external returns(bool);\r\n    function stakeFor(address _for, uint256 _amount) external returns(bool);\r\n    function stakeAll() external returns(bool);\r\n    function stake(uint256 _amount) external returns(bool);\r\n    function earned(address account) external view returns (uint256);\r\n    function rewardPerToken() external view returns (uint256);\r\n    function rewardToken() external returns(address);\r\n    function extraRewards(uint256 _idx) external view returns (address);\r\n    function extraRewardsLength() external view returns (uint256);\r\n}\r\n\r\ninterface IOriginConvexVirtualBalanceRewardPool {\r\n    function getReward(address _account) external;\r\n    function getReward() external;\r\n    function rewardToken() external returns(address);\r\n}\r\n\r\ninterface IConvexRewardPool {\r\n    function earned(address account) external view returns (uint256);\r\n    function stake(address _for) external;\r\n    function withdraw(address _for) external;\r\n    function getReward(address _for) external;\r\n    function notifyRewardAmount(uint256 reward) external;\r\n\r\n    function extraRewards(uint256 _idx) external view returns (address);\r\n    function extraRewardsLength() external view returns (uint256);\r\n    function addExtraReward(address _reward) external returns(bool);\r\n}\r\n\r\ninterface IConvexRewardFactory {\r\n    function createReward(address _reward, address _virtualBalance, address _operator) external returns (address);\r\n}\r\n\r\ninterface ICurveSwap {\r\n    function remove_liquidity_one_coin(uint256 _token_amount, int128 i, uint256 min_amount) external;\r\n    /* function remove_liquidity(uint256 _token_amount, uint256[] memory min_amounts) external; */\r\n    function coins(uint256 _coinId) external view returns(address);\r\n    function balances(uint256 _coinId) external view returns(uint256);\r\n}\r\n\r\ninterface ICurveAddressProvider{\r\n    function get_registry() external view returns(address);\r\n    function get_address(uint256 _id) external view returns(address);\r\n}\r\n\r\ninterface ICurveRegistry{\r\n    function gauge_controller() external view returns(address);\r\n    function get_lp_token(address) external view returns(address);\r\n    function get_pool_from_lp_token(address) external view returns(address);\r\n    function get_gauges(address) external view returns(address[10] memory,uint128[10] memory);\r\n}\r\n\r\n\r\npragma solidity =0.6.12;\r\n\r\ninterface IConvexBoosterV2 is IConvexBooster {\r\n    function liquidate(\r\n        uint256 _convexPid,\r\n        int128 _curveCoinId,\r\n        address _user,\r\n        uint256 _amount\r\n    ) external override returns (address, uint256);\r\n\r\n    function depositFor(\r\n        uint256 _convexPid,\r\n        uint256 _amount,\r\n        address _user\r\n    ) external override returns (bool);\r\n\r\n    function withdrawFor(\r\n        uint256 _convexPid,\r\n        uint256 _amount,\r\n        address _user,\r\n        bool _freezeTokens\r\n    ) external override returns (bool);\r\n\r\n    function poolInfo(uint256 _convexPid)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint256 originConvexPid,\r\n            address curveSwapAddress,\r\n            address lpToken,\r\n            address originCrvRewards,\r\n            address originStash,\r\n            address virtualBalance,\r\n            address rewardCrvPool,\r\n            address rewardCvxPool,\r\n            bool shutdown\r\n        );\r\n\r\n    function addConvexPool(uint256 _originConvexPid) external override;\r\n\r\n    function addConvexPool(uint256 _originConvexPid, address _curveSwapAddress, address _curveZapAddress, address _basePoolAddress, bool _isMeta, bool _isMetaFactory)\r\n        external;\r\n\r\n    function getPoolZapAddress(address _lpToken)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function getPoolToken(uint256 _pid) external view returns (address);\r\n\r\n    function calculateTokenAmount(\r\n        uint256 _pid,\r\n        uint256 _tokens,\r\n        int128 _curveCoinId\r\n    ) external view returns (uint256);\r\n}\r\n\r\npragma solidity =0.6.12;\r\n\r\n\r\ninterface ICurveSwapV2 is ICurveSwap {\r\n    // function remove_liquidity_one_coin(\r\n    //     uint256 _token_amount,\r\n    //     int128 _i,\r\n    //     uint256 _min_amount\r\n    // ) external override;\r\n\r\n    function remove_liquidity_one_coin(\r\n        address _pool,\r\n        uint256 _burn_amount,\r\n        int128 _i,\r\n        uint256 _min_amount\r\n    ) external;\r\n\r\n    function coins(uint256 _coinId) external view override returns (address);\r\n\r\n    function balances(uint256 _coinId) external view override returns (uint256);\r\n\r\n    function get_virtual_price() external view returns (uint256);\r\n\r\n    function calc_withdraw_one_coin(uint256 _tokenAmount, int128 _tokenId)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /* factory */\r\n    function calc_withdraw_one_coin(\r\n        address _pool,\r\n        uint256 _tokenAmount,\r\n        int128 _tokenId\r\n    ) external view returns (uint256);\r\n}\r\n\r\npragma solidity 0.6.12;\r\n\r\n\r\ncontract ConvexBoosterV2Test {\r\n    using Address for address payable;\r\n    using SafeERC20 for IERC20;\r\n    using Address for address;\r\n\r\n    address public constant ZERO_ADDRESS =\r\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    address public originConvexBooster;\r\n\r\n    struct PoolInfo {\r\n        uint256 originConvexPid;\r\n        address curveSwapAddress; /* like 3pool https://github.com/curvefi/curve-js/blob/master/src/constants/abis/abis-ethereum.ts */\r\n        address lpToken;\r\n        address originCrvRewards;\r\n        address originStash;\r\n        address virtualBalance;\r\n        address rewardCrvPool;\r\n        address rewardCvxPool;\r\n        bool shutdown;\r\n    }\r\n\r\n    struct MetaPoolInfo {\r\n        address swapAddress;\r\n        address zapAddress;\r\n        address basePoolAddress;\r\n        bool isMeta;\r\n        bool isMetaFactory;\r\n    }\r\n\r\n    PoolInfo[] public poolInfo;\r\n\r\n    mapping(address => MetaPoolInfo) public metaPoolInfo;\r\n\r\n    event CurveZap(address lpToken, address curveZapAddress);\r\n\r\n    // @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor(address _originConvexBooster) public {\r\n        originConvexBooster = _originConvexBooster;\r\n\r\n        // sUSD\r\n        addConvexPool(\r\n            4,\r\n            0xA5407eAE9Ba41422680e2e00537571bcC53efBfD,\r\n            0xFCBa3E75865d2d561BE8D220616520c171F12851,\r\n            0xA5407eAE9Ba41422680e2e00537571bcC53efBfD,\r\n            false,\r\n            false\r\n        );\r\n\r\n        // mim , busdv2 factory pool\r\n        addConvexPool(\r\n            40,\r\n            0x5a6A4D54456819380173272A5E8E9B9904BdF41B,\r\n            0xA79828DF1850E8a3A3064576f380D90aECDD3359,\r\n            0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7,\r\n            true,\r\n            true\r\n        );\r\n\r\n        // musd , ust, gusd , usdn , usdk , husd , rsv , dusd , obtc , bbtc , tbtc , pbtc export function public(base_pool) in code\r\n        addConvexPool(\r\n            14,\r\n            0x8474DdbE98F5aA3179B3B3F5942D724aFcdec9f6,\r\n            0x803A2B40c5a9BB2B86DD630B274Fa2A9202874C2,\r\n            0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7,\r\n            true,\r\n            false\r\n        );\r\n\r\n        // lusd alusd has base_pool in code\r\n        addConvexPool(\r\n            33,\r\n            0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA,\r\n            0xA79828DF1850E8a3A3064576f380D90aECDD3359,\r\n            0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7,\r\n            true,\r\n            false\r\n        );\r\n\r\n        // factory mim-ust\r\n        addConvexPool(\r\n            52,\r\n            0x55A8a39bc9694714E2874c1ce77aa1E599461E18,\r\n            0x55A8a39bc9694714E2874c1ce77aa1E599461E18,\r\n            0x55A8a39bc9694714E2874c1ce77aa1E599461E18,\r\n            true,\r\n            false\r\n        );\r\n        \r\n        // factory dola-3pool\r\n        addConvexPool(\r\n            62,\r\n            0xd632f22692FaC7611d2AA1C0D552930D43CAEd3B,\r\n            0xA79828DF1850E8a3A3064576f380D90aECDD3359,\r\n            0xbEbc44782C7dB0a1A60Cb6fe97d0b483032FF1C7,\r\n            true,\r\n            true\r\n        );\r\n\r\n        // addConvexPool(_originConvexPid, _curveSwapAddress, _curveZapAddress, _basePoolAddress, _isMeta, _isMetaFactory);\r\n    }\r\n\r\n    function _addConvexPool(\r\n        uint256 _originConvexPid,\r\n        address _lpToken,\r\n        address _originCrvRewards,\r\n        address _originStash,\r\n        address _curveSwapAddress\r\n    ) internal {\r\n        poolInfo.push(\r\n            PoolInfo({\r\n                originConvexPid: _originConvexPid,\r\n                curveSwapAddress: _curveSwapAddress,\r\n                lpToken: _lpToken,\r\n                originCrvRewards: address(0),\r\n                originStash: address(0),\r\n                virtualBalance: address(0),\r\n                rewardCrvPool: address(0),\r\n                rewardCvxPool: address(0),\r\n                shutdown: false\r\n            })\r\n        );\r\n    }\r\n\r\n    // Reference https://curve.readthedocs.io/ref-addresses.html?highlight=zap#deposit-zaps\r\n    function addConvexPool(\r\n        uint256 _originConvexPid,\r\n        address _curveSwapAddress,\r\n        address _curveZapAddress,\r\n        address _basePoolAddress,\r\n        bool _isMeta,\r\n        bool _isMetaFactory\r\n    ) public {\r\n        require(_curveSwapAddress != address(0), \"!_curveSwapAddress\");\r\n        require(_curveZapAddress != address(0), \"!_curveZapAddress\");\r\n        require(_basePoolAddress != address(0), \"!_basePoolAddress\");\r\n\r\n        (\r\n            address lpToken,\r\n            ,\r\n            ,\r\n            address originCrvRewards,\r\n            address originStash,\r\n            bool shutdown\r\n        ) = IOriginConvexBooster(originConvexBooster).poolInfo(\r\n                _originConvexPid\r\n            );\r\n\r\n        require(!shutdown, \"!shutdown\");\r\n        require(lpToken != address(0), \"!lpToken\");\r\n\r\n        metaPoolInfo[lpToken] = MetaPoolInfo(\r\n            _curveSwapAddress,\r\n            _curveZapAddress,\r\n            _basePoolAddress,\r\n            _isMeta,\r\n            _isMetaFactory\r\n        );\r\n\r\n        _addConvexPool(\r\n            _originConvexPid,\r\n            lpToken,\r\n            originCrvRewards,\r\n            originStash,\r\n            _curveZapAddress\r\n        );\r\n\r\n        emit CurveZap(lpToken, _curveZapAddress);\r\n    }\r\n\r\n    function _removeLiquidity(\r\n        address _lpToken,\r\n        address _curveSwapAddress,\r\n        uint256 _amount,\r\n        int128 _coinId\r\n    ) internal {\r\n        if (metaPoolInfo[_lpToken].zapAddress != address(0)) {\r\n            _curveSwapAddress = metaPoolInfo[_lpToken].zapAddress;\r\n\r\n            if (metaPoolInfo[_lpToken].isMetaFactory) {\r\n                ICurveSwapV2(_curveSwapAddress).remove_liquidity_one_coin(\r\n                    _lpToken,\r\n                    _amount,\r\n                    _coinId,\r\n                    0\r\n                );\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        ICurveSwapV2(_curveSwapAddress).remove_liquidity_one_coin(\r\n            _amount,\r\n            _coinId,\r\n            0\r\n        );\r\n    }\r\n\r\n    function liquidate(\r\n        uint256 _pid,\r\n        int128 _coinId,\r\n        uint256 _amount\r\n    ) external returns (address, uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n\r\n        IERC20(pool.lpToken).safeApprove(pool.curveSwapAddress, 0);\r\n        IERC20(pool.lpToken).safeApprove(pool.curveSwapAddress, _amount);\r\n\r\n        address curveSwapAddress = pool.curveSwapAddress;\r\n        address underlyToken;\r\n\r\n        if (metaPoolInfo[pool.lpToken].zapAddress != address(0)) {\r\n            if (_coinId == 0) {\r\n                underlyToken = ICurveSwap(\r\n                    metaPoolInfo[pool.lpToken].swapAddress\r\n                ).coins(uint256(_coinId));\r\n            } else {\r\n                underlyToken = ICurveSwap(\r\n                    metaPoolInfo[pool.lpToken].basePoolAddress\r\n                ).coins(uint256(_coinId) - 1);\r\n            }\r\n        } else {\r\n            underlyToken = ICurveSwap(pool.curveSwapAddress).coins(\r\n                uint256(_coinId)\r\n            );\r\n        }\r\n\r\n        _removeLiquidity(pool.lpToken, curveSwapAddress, _amount, _coinId);\r\n\r\n        if (underlyToken == ZERO_ADDRESS) {\r\n            uint256 totalAmount = address(this).balance;\r\n\r\n            msg.sender.sendValue(totalAmount);\r\n\r\n            return (ZERO_ADDRESS, totalAmount);\r\n        } else {\r\n            uint256 totalAmount = IERC20(underlyToken).balanceOf(address(this));\r\n\r\n            IERC20(underlyToken).safeTransfer(msg.sender, totalAmount);\r\n\r\n            return (underlyToken, totalAmount);\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    /* view functions */\r\n    function poolLength() external view returns (uint256) {\r\n        return poolInfo.length;\r\n    }\r\n\r\n    function getPoolToken(uint256 _pid) external view returns (address) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n\r\n        return pool.lpToken;\r\n    }\r\n\r\n    function getPoolZapAddress(address _lpToken)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        return metaPoolInfo[_lpToken].zapAddress;\r\n    }\r\n\r\n    function calculateTokenAmount(\r\n        uint256 _pid,\r\n        uint256 _tokens,\r\n        int128 _curveCoinId\r\n    ) external view returns (uint256) {\r\n        PoolInfo storage pool = poolInfo[_pid];\r\n\r\n        address curveSwapAddress = pool.curveSwapAddress;\r\n\r\n        if (metaPoolInfo[pool.lpToken].zapAddress != address(0)) {\r\n            curveSwapAddress = metaPoolInfo[pool.lpToken].zapAddress;\r\n\r\n            if (metaPoolInfo[pool.lpToken].isMetaFactory) {\r\n                return\r\n                    ICurveSwapV2(curveSwapAddress).calc_withdraw_one_coin(\r\n                        pool.lpToken,\r\n                        _tokens,\r\n                        _curveCoinId\r\n                    );\r\n            }\r\n        }\r\n\r\n        return\r\n            ICurveSwapV2(curveSwapAddress).calc_withdraw_one_coin(\r\n                _tokens,\r\n                _curveCoinId\r\n            );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_originConvexBooster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"curveZapAddress\",\"type\":\"address\"}],\"name\":\"CurveZap\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ZERO_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_originConvexPid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_curveSwapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_curveZapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_basePoolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isMeta\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isMetaFactory\",\"type\":\"bool\"}],\"name\":\"addConvexPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tokens\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"_curveCoinId\",\"type\":\"int128\"}],\"name\":\"calculateTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getPoolToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lpToken\",\"type\":\"address\"}],\"name\":\"getPoolZapAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"int128\",\"name\":\"_coinId\",\"type\":\"int128\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"metaPoolInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"swapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"basePoolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isMeta\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isMetaFactory\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"originConvexBooster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"originConvexPid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"curveSwapAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originCrvRewards\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originStash\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"virtualBalance\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardCrvPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardCvxPool\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"shutdown\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ConvexBoosterV2Test", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f403c135812408bfbe8713b5a23a04b3d48aae31", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1ae8e47e325ea2fc67c83b1864aa7b9b0a2bbf9ec000bc6df3e8cf8cab76b1f1"}]}