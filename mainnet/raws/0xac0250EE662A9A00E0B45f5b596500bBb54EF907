{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/multichain/CrossChainCallProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./interfaces/IAnyCallProxy.sol\\\";\\nimport \\\"./interfaces/ICrossChainCallProxy.sol\\\";\\n\\n/// @dev This is a proxy contract to relay cross chain call to AnyCallProxy contract.\\n///      This contract should have the same address in all evm compatible chain.\\ncontract CrossChainCallProxy is Ownable, ICrossChainCallProxy {\\n  event UpdateWhitelist(address indexed _account, bool _status);\\n  event UpdateAnyCallProxy(address indexed _anyCallProxy);\\n\\n  /// @notice The address of AnyCallProxy.\\n  address public anyCallProxy;\\n  /// @notice Keep track the whitelist contracts.\\n  mapping(address => bool) public whitelist;\\n\\n  modifier onlyWhitelist() {\\n    // solhint-disable-next-line reason-string\\n    require(whitelist[msg.sender], \\\"CrossChainCallProxy: only whitelist\\\");\\n    _;\\n  }\\n\\n  constructor(address _anyCallProxy) {\\n    // solhint-disable-next-line reason-string\\n    require(_anyCallProxy != address(0), \\\"CrossChainCallProxy: zero address\\\");\\n\\n    anyCallProxy = _anyCallProxy;\\n  }\\n\\n  // solhint-disable-next-line no-empty-blocks\\n  receive() external payable {}\\n\\n  /********************************** Mutated Functions **********************************/\\n\\n  /// @notice Relay cross chain call to AnyCallProxy contract.\\n  /// @param _to The recipient of the cross chain call on `_toChainID`.\\n  /// @param _data The calldata supplied for the interaction with `_to`\\n  /// @param _fallback The address to call back on the originating chain if the cross chain interaction fails.\\n  /// @param _toChainID The target chain id to interact with\\n  function crossChainCall(\\n    address _to,\\n    bytes memory _data,\\n    address _fallback,\\n    uint256 _toChainID\\n  ) external override onlyWhitelist {\\n    IAnyCallProxy(anyCallProxy).anyCall(_to, _data, _fallback, _toChainID);\\n  }\\n\\n  /********************************** Restricted Functions **********************************/\\n\\n  /// @notice Withdraw execution budget from AnyCallProxy contract.\\n  /// @param _amount The amount of budget to withdraw.\\n  function withdraw(uint256 _amount) external onlyOwner {\\n    IAnyCallProxy(anyCallProxy).withdraw(_amount);\\n\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, ) = msg.sender.call{ value: _amount }(\\\"\\\");\\n    // solhint-disable-next-line reason-string\\n    require(success, \\\"CrossChainCallProxy: transfer failed\\\");\\n  }\\n\\n  /// @notice Update AnyCallProxy contract.\\n  /// @param _anyCallProxy The address to update.\\n  function updateAnyCallProxy(address _anyCallProxy) external onlyOwner {\\n    // solhint-disable-next-line reason-string\\n    require(_anyCallProxy != address(0), \\\"CrossChainCallProxy: zero address\\\");\\n\\n    anyCallProxy = _anyCallProxy;\\n\\n    emit UpdateAnyCallProxy(_anyCallProxy);\\n  }\\n\\n  /// @notice Update whitelist contract can call `crossChainCall`.\\n  /// @param _whitelist The list of whitelist address to update.\\n  /// @param _status The status to update.\\n  function updateWhitelist(address[] memory _whitelist, bool _status) external onlyOwner {\\n    for (uint256 i = 0; i < _whitelist.length; i++) {\\n      whitelist[_whitelist[i]] = _status;\\n\\n      emit UpdateWhitelist(_whitelist[i], _status);\\n    }\\n  }\\n\\n  /// @notice Execute calls on behalf of contract in case of emergency\\n  /// @param _to The address of contract to call.\\n  /// @param _value The amount of ETH passing to the contract.\\n  /// @param _data The data passing to the contract.\\n  function execute(\\n    address _to,\\n    uint256 _value,\\n    bytes calldata _data\\n  ) external onlyOwner returns (bool, bytes memory) {\\n    // solhint-disable-next-line avoid-low-level-calls\\n    (bool success, bytes memory result) = _to.call{ value: _value }(_data);\\n    return (success, result);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/multichain/interfaces/IAnyCallProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ninterface IAnyCallProxy {\\n  event LogAnyCall(address indexed from, address indexed to, bytes data, address _fallback, uint256 indexed toChainID);\\n\\n  event LogAnyExec(\\n    address indexed from,\\n    address indexed to,\\n    bytes data,\\n    bool success,\\n    bytes result,\\n    address _fallback,\\n    uint256 indexed fromChainID\\n  );\\n\\n  function setWhitelist(\\n    address _from,\\n    address _to,\\n    uint256 _toChainID,\\n    bool _flag\\n  ) external;\\n\\n  function anyCall(\\n    address _to,\\n    bytes calldata _data,\\n    address _fallback,\\n    uint256 _toChainID\\n  ) external;\\n\\n  function anyExec(\\n    address _from,\\n    address _to,\\n    bytes calldata _data,\\n    address _fallback,\\n    uint256 _fromChainID\\n  ) external;\\n\\n  function withdraw(uint256 _amount) external;\\n\\n  function deposit(address _account) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/multichain/interfaces/ICrossChainCallProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ninterface ICrossChainCallProxy {\\n  function crossChainCall(\\n    address _to,\\n    bytes memory _data,\\n    address _fallback,\\n    uint256 _toChainID\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_anyCallProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_anyCallProxy\",\"type\":\"address\"}],\"name\":\"UpdateAnyCallProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"UpdateWhitelist\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"anyCallProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_fallback\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_toChainID\",\"type\":\"uint256\"}],\"name\":\"crossChainCall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_anyCallProxy\",\"type\":\"address\"}],\"name\":\"updateAnyCallProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_whitelist\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CrossChainCallProxy", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000037414a8662bc1d25be3ee51fb27c2686e2490a89", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}