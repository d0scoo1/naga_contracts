{"status": "1", "message": "OK", "result": [{"SourceCode": "/**\r\n *Submitted for verification at polygonscan.com on 2022-05-12\r\n*/\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity ^0.8.6;\r\n\r\n/// IApp interface of the application\r\ninterface IApp {\r\n    /// (required) call on the destination chain to exec the interaction\r\n    function anyExecute(bytes calldata _data) external returns (bool success, bytes memory result);\r\n\r\n    /// (optional,advised) call back on the originating chain if the cross chain interaction fails\r\n    function anyFallback(address _to, bytes calldata _data) external;\r\n}\r\n\r\n/// anycall executor is the delegator to execute contract calling (like a sandbox)\r\ncontract AnyCallExecutor {\r\n    struct Context {\r\n        address from;\r\n        uint256 fromChainID;\r\n        uint256 nonce;\r\n    }\r\n\r\n    Context public context;\r\n    address public creator;\r\n\r\n    constructor() {\r\n        creator = msg.sender;\r\n    }\r\n\r\n    function execute(\r\n        address _to,\r\n        bytes calldata _data,\r\n        address _from,\r\n        uint256 _fromChainID,\r\n        uint256 _nonce\r\n    ) external returns (bool success, bytes memory result) {\r\n        if (msg.sender != creator) {\r\n            return (false, \"AnyCallExecutor: caller is not the creator\");\r\n        }\r\n        context = Context({from: _from, fromChainID: _fromChainID, nonce: _nonce});\r\n        (success, result) = IApp(_to).anyExecute(_data);\r\n        context = Context({from: address(0), fromChainID: 0, nonce: 0});\r\n    }\r\n}\r\n\r\n/// anycall proxy is a universal protocal to complete cross-chain interaction.\r\n/// 1. the client call `anyCall` on the originating chain\r\n///         to submit a request for a cross chain interaction\r\n/// 2. the mpc network verify the request and call `anyExec` on the destination chain\r\n///         to execute a cross chain interaction\r\n/// 3. if step 2 failed and step 1 has set non-zero fallback,\r\n///         then call `anyFallback` on the originating chain\r\ncontract AnyCallV6Proxy {\r\n    // Packed fee information (only 1 storage slot)\r\n    struct FeeData {\r\n        uint128 accruedFees;\r\n        uint128 premium;\r\n    }\r\n\r\n    // App config\r\n    struct AppConfig {\r\n        address app; // the application contract address\r\n        address appAdmin; // account who admin the application's config\r\n        uint256 appFlags; // flags of the application\r\n    }\r\n\r\n    // Src fee is (baseFees + msg.data.length*feesPerByte)\r\n    struct SrcFeeConfig {\r\n        uint256 baseFees;\r\n        uint256 feesPerByte;\r\n    }\r\n\r\n    // Exec record\r\n    struct ExecRecord {\r\n        address to;\r\n        bytes data;\r\n    }\r\n\r\n    // Context of the request on originating chain\r\n    struct RequestContext {\r\n        bytes32 txhash;\r\n        address from;\r\n        uint256 fromChainID;\r\n        uint256 nonce;\r\n        uint256 flags;\r\n    }\r\n\r\n    // anycall version\r\n    string constant ANYCALL_VERSION = \"v6.0\";\r\n\r\n    // Flags constant\r\n    uint256 public constant FLAG_MERGE_CONFIG_FLAGS = 0x1;\r\n    uint256 public constant FLAG_PAY_FEE_ON_SRC = 0x1 << 1;\r\n\r\n    // App Modes constant\r\n    uint256 public constant APPMODE_USE_CUSTOM_SRC_FEES = 0x1;\r\n\r\n    // Modes constant\r\n    uint256 public constant PERMISSIONLESS_MODE = 0x1;\r\n    uint256 public constant FREE_MODE = 0x1 << 1;\r\n\r\n    // Extra cost of execution (SSTOREs.SLOADs,ADDs,etc..)\r\n    // TODO: analysis to verify the correct overhead gas usage\r\n    uint256 constant EXECUTION_OVERHEAD = 100000;\r\n\r\n    // key is app address\r\n    mapping(address => string) public appIdentifier;\r\n\r\n    // key is appID, a unique identifier for each project\r\n    mapping(string => AppConfig) public appConfig;\r\n    mapping(string => mapping(address => bool)) public appExecWhitelist;\r\n    mapping(string => address[]) public appHistoryWhitelist;\r\n    mapping(string => bool) public appBlacklist;\r\n    mapping(uint256 => SrcFeeConfig) public srcDefaultFees; // key is chainID\r\n    mapping(string => mapping(uint256 => SrcFeeConfig)) public srcCustomFees;\r\n    mapping(string => uint256) public appDefaultModes;\r\n    mapping(string => mapping(uint256 => uint256)) public appCustomModes;\r\n\r\n    mapping(address => bool) public isAdmin;\r\n    address[] public admins;\r\n\r\n    address public mpc;\r\n    address public pendingMPC;\r\n\r\n    uint256 public mode;\r\n    bool public paused;\r\n\r\n    uint256 public minReserveBudget;\r\n    mapping(address => uint256) public executionBudget;\r\n    FeeData private _feeData;\r\n\r\n    // applications should give permission to this executor\r\n    AnyCallExecutor public executor;\r\n\r\n    mapping(bytes32 => ExecRecord) public retryExecRecords;\r\n\r\n    mapping(bytes32 => bool) public execCompleted;\r\n    uint256 nonce;\r\n\r\n    uint private unlocked = 1;\r\n    modifier lock() {\r\n        require(unlocked == 1);\r\n        unlocked = 0;\r\n        _;\r\n        unlocked = 1;\r\n    }\r\n\r\n    event LogAnyCall(\r\n        address indexed from,\r\n        address indexed to,\r\n        bytes data,\r\n        address _fallback,\r\n        uint256 indexed toChainID,\r\n        uint256 flags,\r\n        string appID,\r\n        uint256 nonce\r\n    );\r\n\r\n    event LogAnyExec(\r\n        bytes32 indexed txhash,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 fromChainID,\r\n        uint256 nonce,\r\n        bool success,\r\n        bytes result\r\n    );\r\n\r\n    event Deposit(address indexed account, uint256 amount);\r\n    event Withdraw(address indexed account, uint256 amount);\r\n    event SetBlacklist(string appID, bool flag);\r\n    event SetWhitelist(string appID, address indexed whitelist, bool flag);\r\n    event UpdatePremium(uint256 oldPremium, uint256 newPremium);\r\n    event AddAdmin(address admin);\r\n    event RemoveAdmin(address admin);\r\n    event ChangeMPC(address indexed oldMPC, address indexed newMPC, uint256 timestamp);\r\n    event ApplyMPC(address indexed oldMPC, address indexed newMPC, uint256 timestamp);\r\n    event SetAppConfig(string appID, address indexed app, address indexed appAdmin, uint256 appFlags);\r\n    event UpgradeApp(string appID, address indexed oldApp, address indexed newApp);\r\n    event StoreRetryExecRecord(bytes32 indexed txhash, address indexed from, address indexed to, uint256 fromChainID, uint256 nonce, bytes data);\r\n    event DoneRetryExecRecord(bytes32 indexed txhash, address indexed from, uint256 fromChainID, uint256 nonce);\r\n\r\n    constructor(\r\n        address _admin,\r\n        address _mpc,\r\n        uint128 _premium,\r\n        uint256 _mode\r\n    ) {\r\n        require(_mpc != address(0), \"zero mpc address\");\r\n        if (_admin != address(0)) {\r\n            isAdmin[_admin] = true;\r\n            admins.push(_admin);\r\n        }\r\n        if (_mpc != _admin) {\r\n            isAdmin[_mpc] = true;\r\n            admins.push(_mpc);\r\n        }\r\n\r\n        mpc = _mpc;\r\n        _feeData.premium = _premium;\r\n        mode = _mode;\r\n\r\n        executor = new AnyCallExecutor();\r\n\r\n        emit ApplyMPC(address(0), _mpc, block.timestamp);\r\n        emit UpdatePremium(0, _premium);\r\n    }\r\n\r\n    /// @dev Access control function\r\n    modifier onlyMPC() {\r\n        require(msg.sender == mpc, \"only MPC\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Access control function\r\n    modifier onlyAdmin() {\r\n        require(isAdmin[msg.sender], \"only admin\");\r\n        _;\r\n    }\r\n\r\n    /// @dev pausable control function\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"paused\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Charge an account for execution costs on this chain\r\n    /// @param _from The account to charge for execution costs\r\n    modifier charge(address _from, uint256 _flags) {\r\n        uint256 gasUsed;\r\n\r\n        // Prepare charge fee on the destination chain\r\n        if (!_isSet(mode, FREE_MODE)) {\r\n            if (!_isSet(_flags, FLAG_PAY_FEE_ON_SRC)) {\r\n                require(executionBudget[_from] >= minReserveBudget, \"less than min budget\");\r\n                gasUsed = gasleft() + EXECUTION_OVERHEAD;\r\n            }\r\n        }\r\n\r\n        _;\r\n\r\n        // Charge fee on the dest chain\r\n        if (gasUsed > 0) {\r\n            uint256 totalCost = (gasUsed - gasleft()) * (tx.gasprice + _feeData.premium);\r\n            uint256 budget = executionBudget[_from];\r\n            require(budget > totalCost, \"no enough budget\");\r\n            executionBudget[_from] = budget - totalCost;\r\n            _feeData.accruedFees += uint128(totalCost);\r\n        }\r\n    }\r\n\r\n    /// @dev set paused flag to pause/unpause functions\r\n    function setPaused(bool _paused) external onlyAdmin {\r\n        paused = _paused;\r\n    }\r\n\r\n    function _paySrcFees(uint256 fees) internal {\r\n        require(msg.value >= fees, \"no enough src fee\");\r\n        if (fees > 0) { // pay fees\r\n            (bool success,) = mpc.call{value: fees}(\"\");\r\n            require(success);\r\n        }\r\n        if (msg.value > fees) { // return remaining amount\r\n            (bool success,) = msg.sender.call{value: msg.value - fees}(\"\");\r\n            require(success);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Submit a request for a cross chain interaction\r\n        @param _to The target to interact with on `_toChainID`\r\n        @param _data The calldata supplied for the interaction with `_to`\r\n        @param _fallback The address to call back on the originating chain\r\n            if the cross chain interaction fails\r\n            for security reason, it must be zero or `msg.sender` address\r\n        @param _toChainID The target chain id to interact with\r\n        @param _flags The flags of app on the originating chain\r\n    */\r\n    function anyCall(\r\n        address _to,\r\n        bytes calldata _data,\r\n        address _fallback,\r\n        uint256 _toChainID,\r\n        uint256 _flags\r\n    ) external lock payable whenNotPaused {\r\n        require(_fallback == address(0) || _fallback == msg.sender, \"wrong fallback\");\r\n        string memory _appID = appIdentifier[msg.sender];\r\n\r\n        require(!appBlacklist[_appID], \"blacklist\");\r\n\r\n        bool _permissionlessMode = _isSet(mode, PERMISSIONLESS_MODE);\r\n        if (!_permissionlessMode) {\r\n            require(appExecWhitelist[_appID][msg.sender], \"no permission\");\r\n        }\r\n\r\n        if (!_isSet(mode, FREE_MODE)) {\r\n            AppConfig storage config = appConfig[_appID];\r\n            require(\r\n                (_permissionlessMode && config.app == address(0)) ||\r\n                msg.sender == config.app,\r\n                \"app not exist\"\r\n            );\r\n\r\n            if (_isSet(_flags, FLAG_MERGE_CONFIG_FLAGS) && config.app == msg.sender) {\r\n                _flags |= config.appFlags;\r\n            }\r\n\r\n            if (_isSet(_flags, FLAG_PAY_FEE_ON_SRC)) {\r\n                uint256 fees = _calcSrcFees(_appID, _toChainID, _data.length);\r\n                _paySrcFees(fees);\r\n            } else if (msg.value > 0) {\r\n                _paySrcFees(0);\r\n            }\r\n        }\r\n\r\n        nonce++;\r\n        emit LogAnyCall(msg.sender, _to, _data, _fallback, _toChainID, _flags, _appID, nonce);\r\n    }\r\n\r\n    /**\r\n        @notice Execute a cross chain interaction\r\n        @dev Only callable by the MPC\r\n        @param _to The cross chain interaction target\r\n        @param _data The calldata supplied for interacting with target\r\n        @param _fallback The address to call on originating chain if the interaction fails\r\n        @param _appID The app identifier to check whitelist\r\n        @param _ctx The context of the request on originating chain\r\n    */\r\n    function anyExec(\r\n        address _to,\r\n        bytes memory _data,\r\n        address _fallback,\r\n        string memory _appID,\r\n        RequestContext memory _ctx\r\n    ) external lock whenNotPaused charge(_ctx.from, _ctx.flags) onlyMPC {\r\n        address _from = _ctx.from;\r\n\r\n        require(_fallback == address(0) || _fallback == _from, \"wrong fallback\");\r\n\r\n        require(!appBlacklist[_appID], \"blacklist\");\r\n\r\n        if (!_isSet(mode, PERMISSIONLESS_MODE)) {\r\n            require(appExecWhitelist[_appID][_to], \"no permission\");\r\n        }\r\n\r\n        bytes32 uniqID = calcUniqID(_ctx.txhash, _from, _ctx.fromChainID, _ctx.nonce);\r\n        require(!execCompleted[uniqID], \"exec completed\");\r\n\r\n        bool success;\r\n        {\r\n            bytes memory result;\r\n            try executor.execute(_to, _data, _from, _ctx.fromChainID, _ctx.nonce) returns (bool succ, bytes memory res) {\r\n                (success, result) = (succ, res);\r\n            } catch Error(string memory reason) {\r\n                result = bytes(reason);\r\n            } catch (bytes memory reason) {\r\n                result = reason;\r\n            }\r\n            emit LogAnyExec(_ctx.txhash, _from, _to, _ctx.fromChainID, _ctx.nonce, success, result);\r\n        }\r\n\r\n        if (success) {\r\n            execCompleted[uniqID] = true;\r\n        } else if (_fallback == address(0)) {\r\n            retryExecRecords[uniqID] = ExecRecord(_to, _data);\r\n            emit StoreRetryExecRecord(_ctx.txhash, _from, _to, _ctx.fromChainID, _ctx.nonce, _data);\r\n        } else {\r\n            // Call the fallback on the originating chain with the call information (to, data)\r\n            nonce++;\r\n            emit LogAnyCall(\r\n                _from,\r\n                _fallback,\r\n                abi.encodeWithSelector(IApp.anyFallback.selector, _to, _data),\r\n                address(0),\r\n                _ctx.fromChainID,\r\n                0, // pay fee on dest chain\r\n                _appID,\r\n                nonce);\r\n        }\r\n    }\r\n\r\n    function _isSet(uint256 _value, uint256 _testBits) internal pure returns (bool) {\r\n        return (_value & _testBits) == _testBits;\r\n    }\r\n\r\n    // @notice Calc unique ID\r\n    function calcUniqID(bytes32 _txhash, address _from, uint256 _fromChainID, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encode(_txhash, _from, _fromChainID, _nonce));\r\n    }\r\n\r\n    /// @notice Retry stored exec record\r\n    function retryExec(bytes32 _txhash, address _from, uint256 _fromChainID, uint256 _nonce) external {\r\n        bytes32 uniqID = calcUniqID(_txhash, _from, _fromChainID, _nonce);\r\n        require(!execCompleted[uniqID], \"exec completed\");\r\n\r\n        ExecRecord storage record = retryExecRecords[uniqID];\r\n        require(record.to != address(0), \"no retry record\");\r\n\r\n        address _to = record.to;\r\n        bytes memory _data = record.data;\r\n\r\n        // Clear record\r\n        record.to = address(0);\r\n        record.data = \"\";\r\n\r\n        (bool success,) = executor.execute(_to, _data, _from, _fromChainID, _nonce);\r\n        require(success);\r\n\r\n        execCompleted[uniqID] = true;\r\n        emit DoneRetryExecRecord(_txhash, _from, _fromChainID, _nonce);\r\n    }\r\n\r\n    /// @notice Deposit native currency crediting `_account` for execution costs on this chain\r\n    /// @param _account The account to deposit and credit for\r\n    function deposit(address _account) external payable {\r\n        executionBudget[_account] += msg.value;\r\n        emit Deposit(_account, msg.value);\r\n    }\r\n\r\n    /// @notice Withdraw a previous deposit from your account\r\n    /// @param _amount The amount to withdraw from your account\r\n    function withdraw(uint256 _amount) external {\r\n        executionBudget[msg.sender] -= _amount;\r\n        emit Withdraw(msg.sender, _amount);\r\n        (bool success,) = msg.sender.call{value: _amount}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    /// @notice Withdraw all accrued execution fees\r\n    /// @dev The MPC is credited in the native currency\r\n    function withdrawAccruedFees() external {\r\n        uint256 fees = _feeData.accruedFees;\r\n        _feeData.accruedFees = 0;\r\n        (bool success,) = mpc.call{value: fees}(\"\");\r\n        require(success);\r\n    }\r\n\r\n    /// @notice Set app blacklist\r\n    function setBlacklist(string calldata _appID, bool _flag) external onlyAdmin {\r\n        appBlacklist[_appID] = _flag;\r\n        emit SetBlacklist(_appID, _flag);\r\n    }\r\n\r\n    /// @notice Set app blacklist in batch\r\n    function setBlacklists(string[] calldata _appIDs, bool _flag) external onlyAdmin {\r\n        for (uint256 i = 0; i < _appIDs.length; i++) {\r\n            this.setBlacklist(_appIDs[i], _flag);\r\n        }\r\n    }\r\n\r\n    /// @notice Set the premimum for cross chain executions\r\n    /// @param _premium The premium per gas\r\n    function setPremium(uint128 _premium) external onlyAdmin {\r\n        emit UpdatePremium(_feeData.premium, _premium);\r\n        _feeData.premium = _premium;\r\n    }\r\n\r\n    /// @notice Set minimum exection budget for cross chain executions\r\n    /// @param _minBudget The minimum exection budget\r\n    function setMinReserveBudget(uint128 _minBudget) external onlyAdmin {\r\n        minReserveBudget = _minBudget;\r\n    }\r\n\r\n    /// @notice Set mode\r\n    function setMode(uint256 _mode) external onlyAdmin {\r\n        mode = _mode;\r\n    }\r\n\r\n    /// @notice Change mpc\r\n    function changeMPC(address _mpc) external onlyMPC {\r\n        pendingMPC = _mpc;\r\n        emit ChangeMPC(mpc, _mpc, block.timestamp);\r\n    }\r\n\r\n    /// @notice Apply mpc\r\n    function applyMPC() external {\r\n        require(msg.sender == pendingMPC);\r\n        emit ApplyMPC(mpc, pendingMPC, block.timestamp);\r\n        mpc = pendingMPC;\r\n        pendingMPC = address(0);\r\n    }\r\n\r\n    /// @notice Get the total accrued fees in native currency\r\n    /// @dev Fees increase when executing cross chain requests\r\n    function accruedFees() external view returns(uint128) {\r\n        return _feeData.accruedFees;\r\n    }\r\n\r\n    /// @notice Get the gas premium cost\r\n    /// @dev This is similar to priority fee in eip-1559, except instead of going\r\n    ///     to the miner it is given to the MPC executing cross chain requests\r\n    function premium() external view returns(uint128) {\r\n        return _feeData.premium;\r\n    }\r\n\r\n    /// @notice Add admin\r\n    function addAdmin(address _admin) external onlyMPC {\r\n        require(!isAdmin[_admin]);\r\n        isAdmin[_admin] = true;\r\n        admins.push(_admin);\r\n        emit AddAdmin(_admin);\r\n    }\r\n\r\n    /// @notice Remove admin\r\n    function removeAdmin(address _admin) external onlyMPC {\r\n        require(isAdmin[_admin]);\r\n        isAdmin[_admin] = false;\r\n        uint256 length = admins.length;\r\n        for (uint256 i = 0; i < length - 1; i++) {\r\n            if (admins[i] == _admin) {\r\n                admins[i] = admins[length - 1];\r\n                break;\r\n            }\r\n        }\r\n        admins.pop();\r\n        emit RemoveAdmin(_admin);\r\n    }\r\n\r\n    /// @notice Get all admins\r\n    function getAllAdmins() external view returns (address[] memory) {\r\n        return admins;\r\n    }\r\n\r\n    /// @notice Init app config\r\n    function initAppConfig(\r\n        string calldata _appID,\r\n        address _app,\r\n        address _admin,\r\n        uint256 _flags,\r\n        address[] calldata _whitelist\r\n    ) external onlyAdmin {\r\n        require(bytes(_appID).length > 0, \"empty appID\");\r\n        require(_app != address(0), \"zero app address\");\r\n\r\n        AppConfig storage config = appConfig[_appID];\r\n        require(config.app == address(0), \"app exist\");\r\n\r\n        appIdentifier[_app] = _appID;\r\n\r\n        config.app = _app;\r\n        config.appAdmin = _admin;\r\n        config.appFlags = _flags;\r\n\r\n        address[] memory whitelist = new address[](1+_whitelist.length);\r\n        whitelist[0] = _app;\r\n        for (uint256 i = 0; i < _whitelist.length; i++) {\r\n            whitelist[i+1] = _whitelist[i];\r\n        }\r\n        _setAppWhitelist(_appID, whitelist, true);\r\n\r\n        emit SetAppConfig(_appID, _app, _admin, _flags);\r\n    }\r\n\r\n    /// @notice Update app config\r\n    /// can be operated only by mpc or app admin\r\n    /// the config.app will always keep unchanged here\r\n    function updateAppConfig(\r\n        address _app,\r\n        address _admin,\r\n        uint256 _flags,\r\n        address[] calldata _whitelist\r\n    ) external {\r\n        string memory _appID = appIdentifier[_app];\r\n        AppConfig storage config = appConfig[_appID];\r\n\r\n        require(config.app == _app && _app != address(0), \"app not exist\");\r\n        require(msg.sender == mpc || msg.sender == config.appAdmin, \"forbid\");\r\n\r\n        if (_admin != address(0)) {\r\n            config.appAdmin = _admin;\r\n        }\r\n        config.appFlags = _flags;\r\n        if (_whitelist.length > 0) {\r\n            _setAppWhitelist(_appID, _whitelist, true);\r\n        }\r\n\r\n        emit SetAppConfig(_appID, _app, _admin, _flags);\r\n    }\r\n\r\n    /// @notice Upgrade app\r\n    /// can be operated only by mpc or app admin\r\n    /// change config.app to a new address\r\n    /// require the `_newApp` is not inited\r\n    function upgradeApp(address _oldApp, address _newApp) external {\r\n        string memory _appID = appIdentifier[_oldApp];\r\n        AppConfig storage config = appConfig[_appID];\r\n\r\n        require(config.app == _oldApp && _oldApp != address(0), \"app not exist\");\r\n        require(msg.sender == mpc || msg.sender == config.appAdmin, \"forbid\");\r\n        require(bytes(appIdentifier[_newApp]).length == 0, \"new app is inited\");\r\n\r\n        config.app = _newApp;\r\n\r\n        emit UpgradeApp(_appID, _oldApp, _newApp);\r\n    }\r\n\r\n    /// @notice Add whitelist\r\n    function addWhitelist(address _app, address[] memory _whitelist) external {\r\n        string memory _appID = appIdentifier[_app];\r\n        AppConfig storage config = appConfig[_appID];\r\n\r\n        require(config.app == _app && _app != address(0), \"app not exist\");\r\n        require(msg.sender == mpc || msg.sender == config.appAdmin, \"forbid\");\r\n\r\n        _setAppWhitelist(_appID, _whitelist, true);\r\n    }\r\n\r\n    /// @notice Remove whitelist\r\n    function removeWhitelist(address _app, address[] memory _whitelist) external {\r\n        string memory _appID = appIdentifier[_app];\r\n        AppConfig storage config = appConfig[_appID];\r\n\r\n        require(config.app == _app && _app != address(0), \"app not exist\");\r\n        require(msg.sender == mpc || msg.sender == config.appAdmin, \"forbid\");\r\n\r\n        _setAppWhitelist(_appID, _whitelist, false);\r\n    }\r\n\r\n    function _setAppWhitelist(string memory _appID, address[] memory _whitelist, bool _flag) internal {\r\n        mapping(address => bool) storage whitelist = appExecWhitelist[_appID];\r\n        address[] storage historyWhitelist = appHistoryWhitelist[_appID];\r\n        address addr;\r\n        for (uint256 i = 0; i < _whitelist.length; i++) {\r\n            addr = _whitelist[i];\r\n            if (whitelist[addr] == _flag) {\r\n                continue;\r\n            }\r\n            if (_flag) {\r\n                historyWhitelist.push(addr);\r\n            }\r\n            whitelist[addr] = _flag;\r\n            emit SetWhitelist(_appID, addr, _flag);\r\n        }\r\n    }\r\n\r\n    /// @notice Get history whitelist length\r\n    function getHistoryWhitelistLength(string memory _appID) external view returns (uint256) {\r\n        return appHistoryWhitelist[_appID].length;\r\n    }\r\n\r\n    /// @notice Get all history whitelist\r\n    function getAllHistoryWhitelist(string memory _appID) external view returns (address[] memory) {\r\n        return appHistoryWhitelist[_appID];\r\n    }\r\n\r\n    /// @notice Tidy history whitelist to be same with actual whitelist\r\n    function tidyHistoryWhitelist(string memory _appID) external {\r\n        mapping(address => bool) storage actualWhitelist = appExecWhitelist[_appID];\r\n        address[] storage historyWhitelist = appHistoryWhitelist[_appID];\r\n        uint256 histLength = historyWhitelist.length;\r\n        uint256 popIndex = histLength;\r\n        address addr;\r\n        for (uint256 i = 0; i < popIndex; ) {\r\n            addr = historyWhitelist[i];\r\n            if (actualWhitelist[addr]) {\r\n                i++;\r\n            } else {\r\n                popIndex--;\r\n                historyWhitelist[i] = historyWhitelist[popIndex];\r\n            }\r\n        }\r\n        for (uint256 i = popIndex; i < histLength; i++) {\r\n            historyWhitelist.pop();\r\n        }\r\n    }\r\n\r\n    /// @notice Set default src fees\r\n    function setDefaultSrcFees(\r\n        uint256[] calldata _toChainIDs,\r\n        uint256[] calldata _baseFees,\r\n        uint256[] calldata _feesPerByte\r\n    ) external onlyAdmin {\r\n        uint256 length = _toChainIDs.length;\r\n        require(length == _baseFees.length && length == _feesPerByte.length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            srcDefaultFees[_toChainIDs[i]] = SrcFeeConfig(_baseFees[i], _feesPerByte[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Set custom src fees\r\n    function setCustomSrcFees(\r\n        address _app,\r\n        uint256[] calldata _toChainIDs,\r\n        uint256[] calldata _baseFees,\r\n        uint256[] calldata _feesPerByte\r\n    ) external onlyAdmin {\r\n        string memory _appID = appIdentifier[_app];\r\n        AppConfig storage config = appConfig[_appID];\r\n\r\n        require(config.app == _app && _app != address(0), \"app not exist\");\r\n        require(_isSet(config.appFlags, FLAG_PAY_FEE_ON_SRC), \"flag not set\");\r\n\r\n        uint256 length = _toChainIDs.length;\r\n        require(length == _baseFees.length && length == _feesPerByte.length);\r\n\r\n        mapping(uint256 => SrcFeeConfig) storage _srcFees = srcCustomFees[_appID];\r\n        for (uint256 i = 0; i < length; i++) {\r\n            _srcFees[_toChainIDs[i]] = SrcFeeConfig(_baseFees[i], _feesPerByte[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Set app modes\r\n    function setAppModes(\r\n        address _app,\r\n        uint256 _appDefaultMode,\r\n        uint256[] calldata _toChainIDs,\r\n        uint256[] calldata _appCustomModes\r\n    ) external onlyAdmin {\r\n        string memory _appID = appIdentifier[_app];\r\n        AppConfig storage config = appConfig[_appID];\r\n        require(config.app == _app && _app != address(0), \"app not exist\");\r\n\r\n        uint256 length = _toChainIDs.length;\r\n        require(length == _appCustomModes.length);\r\n\r\n        appDefaultModes[_appID] = _appDefaultMode;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            appCustomModes[_appID][_toChainIDs[i]] = _appCustomModes[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Calc fees\r\n    function calcSrcFees(\r\n        address _app,\r\n        uint256 _toChainID,\r\n        uint256 _dataLength\r\n    ) external view returns (uint256) {\r\n        string memory _appID = appIdentifier[_app];\r\n        return _calcSrcFees(_appID, _toChainID, _dataLength);\r\n    }\r\n\r\n    /// @notice Calc fees\r\n    function calcSrcFees(\r\n        string calldata _appID,\r\n        uint256 _toChainID,\r\n        uint256 _dataLength\r\n    ) external view returns (uint256) {\r\n        return _calcSrcFees(_appID, _toChainID, _dataLength);\r\n    }\r\n\r\n    /// @notice Is use custom src fees\r\n    function isUseCustomSrcFees(string memory _appID, uint256 _toChainID) public view returns (bool) {\r\n        uint256 _appMode = appCustomModes[_appID][_toChainID];\r\n        if (_isSet(_appMode, APPMODE_USE_CUSTOM_SRC_FEES)) {\r\n            return true;\r\n        }\r\n        _appMode = appDefaultModes[_appID];\r\n        return _isSet(_appMode, APPMODE_USE_CUSTOM_SRC_FEES);\r\n    }\r\n\r\n    function _calcSrcFees(\r\n        string memory _appID,\r\n        uint256 _toChainID,\r\n        uint256 _dataLength\r\n    ) internal view returns (uint256) {\r\n        SrcFeeConfig memory customFees = srcCustomFees[_appID][_toChainID];\r\n        uint256 customBaseFees = customFees.baseFees;\r\n        uint256 customFeesPerBytes = customFees.feesPerByte;\r\n\r\n        if (isUseCustomSrcFees(_appID, _toChainID)) {\r\n            return customBaseFees + _dataLength * customFeesPerBytes;\r\n        }\r\n\r\n        SrcFeeConfig memory defaultFees = srcDefaultFees[_toChainID];\r\n        uint256 defaultBaseFees = defaultFees.baseFees;\r\n        uint256 defaultFeesPerBytes = defaultFees.feesPerByte;\r\n\r\n        uint256 baseFees = (customBaseFees > defaultBaseFees) ? customBaseFees : defaultBaseFees;\r\n        uint256 feesPerByte = (customFeesPerBytes > defaultFeesPerBytes) ? customFeesPerBytes : defaultFeesPerBytes;\r\n\r\n        return baseFees + _dataLength * feesPerByte;\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"context\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromChainID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fromChainID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AnyCallExecutor", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ba584322a3bbbe0ff4a3893e9de722b0475cfd58467a20f7d12e2d9998b0f817"}]}