{"status": "1", "message": "OK", "result": [{"SourceCode": "/*\n   ____            __   __        __   _\n  / __/__ __ ___  / /_ / /  ___  / /_ (_)__ __\n _\\ \\ / // // _ \\/ __// _ \\/ -_)/ __// / \\ \\ /\n/___/ \\_, //_//_/\\__//_//_/\\__/ \\__//_/ /_\\_\\\n     /___/\n\n* Synthetix: migrations/Migration_Alsephina.sol\n*\n* Latest source (may be newer): https://github.com/Synthetixio/synthetix/blob/master/contracts/migrations/Migration_Alsephina.sol\n* Docs: https://docs.synthetix.io/contracts/migrations/Migration_Alsephina\n*\n* Contract Dependencies: \n*\t- BaseMigration\n*\t- ExchangeRates\n*\t- IAddressResolver\n*\t- IExchangeRates\n*\t- IExchangeState\n*\t- ISystemSettings\n*\t- ISystemStatus\n*\t- MixinResolver\n*\t- MixinSystemSettings\n*\t- Owned\n*\t- State\n* Libraries: \n*\t- SafeDecimalMath\n*\t- SafeMath\n*\t- SystemSettingsLib\n*\n* MIT License\n* ===========\n*\n* Copyright (c) 2022 Synthetix\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n*/\n\n\n\npragma solidity ^0.5.16;\n\n// https://docs.synthetix.io/contracts/source/contracts/owned\ncontract Owned {\n    address public owner;\n    address public nominatedOwner;\n\n    constructor(address _owner) public {\n        require(_owner != address(0), \"Owner address cannot be 0\");\n        owner = _owner;\n        emit OwnerChanged(address(0), _owner);\n    }\n\n    function nominateNewOwner(address _owner) external onlyOwner {\n        nominatedOwner = _owner;\n        emit OwnerNominated(_owner);\n    }\n\n    function acceptOwnership() external {\n        require(msg.sender == nominatedOwner, \"You must be nominated before you can accept ownership\");\n        emit OwnerChanged(owner, nominatedOwner);\n        owner = nominatedOwner;\n        nominatedOwner = address(0);\n    }\n\n    modifier onlyOwner {\n        _onlyOwner();\n        _;\n    }\n\n    function _onlyOwner() private view {\n        require(msg.sender == owner, \"Only the contract owner may perform this action\");\n    }\n\n    event OwnerNominated(address newOwner);\n    event OwnerChanged(address oldOwner, address newOwner);\n}\n\n\ncontract BaseMigration is Owned {\n    address public deployer;\n\n    constructor(address _owner) internal Owned(_owner) {\n        deployer = msg.sender;\n    }\n\n    // safety value to return ownership (anyone can invoke)\n    function returnOwnership(address forContract) public {\n        bytes memory payload = abi.encodeWithSignature(\"nominateNewOwner(address)\", owner);\n\n        // solhint-disable avoid-low-level-calls\n        (bool success, ) = forContract.call(payload);\n\n        if (!success) {\n            // then try legacy way\n            bytes memory legacyPayload = abi.encodeWithSignature(\"nominateOwner(address)\", owner);\n\n            // solhint-disable avoid-low-level-calls\n            (bool legacySuccess, ) = forContract.call(legacyPayload);\n\n            require(legacySuccess, \"Legacy nomination failed\");\n        }\n    }\n\n    function _requireDeployer() private view {\n        require(msg.sender == deployer, \"Only the deployer can invoke this\");\n    }\n\n    modifier onlyDeployer() {\n        _requireDeployer();\n        _;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iaddressresolver\ninterface IAddressResolver {\n    function getAddress(bytes32 name) external view returns (address);\n\n    function getSynth(bytes32 key) external view returns (address);\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isynth\ninterface ISynth {\n    // Views\n    function currencyKey() external view returns (bytes32);\n\n    function transferableSynths(address account) external view returns (uint);\n\n    // Mutative functions\n    function transferAndSettle(address to, uint value) external returns (bool);\n\n    function transferFromAndSettle(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Restricted: used internally to Synthetix\n    function burn(address account, uint amount) external;\n\n    function issue(address account, uint amount) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iissuer\ninterface IIssuer {\n    // Views\n    function anySynthOrSNXRateIsInvalid() external view returns (bool anyRateInvalid);\n\n    function availableCurrencyKeys() external view returns (bytes32[] memory);\n\n    function availableSynthCount() external view returns (uint);\n\n    function availableSynths(uint index) external view returns (ISynth);\n\n    function canBurnSynths(address account) external view returns (bool);\n\n    function collateral(address account) external view returns (uint);\n\n    function collateralisationRatio(address issuer) external view returns (uint);\n\n    function collateralisationRatioAndAnyRatesInvalid(address _issuer)\n        external\n        view\n        returns (uint cratio, bool anyRateIsInvalid);\n\n    function debtBalanceOf(address issuer, bytes32 currencyKey) external view returns (uint debtBalance);\n\n    function issuanceRatio() external view returns (uint);\n\n    function lastIssueEvent(address account) external view returns (uint);\n\n    function maxIssuableSynths(address issuer) external view returns (uint maxIssuable);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function remainingIssuableSynths(address issuer)\n        external\n        view\n        returns (\n            uint maxIssuable,\n            uint alreadyIssued,\n            uint totalSystemDebt\n        );\n\n    function synths(bytes32 currencyKey) external view returns (ISynth);\n\n    function getSynths(bytes32[] calldata currencyKeys) external view returns (ISynth[] memory);\n\n    function synthsByAddress(address synthAddress) external view returns (bytes32);\n\n    function totalIssuedSynths(bytes32 currencyKey, bool excludeOtherCollateral) external view returns (uint);\n\n    function transferableSynthetixAndAnyRateIsInvalid(address account, uint balance)\n        external\n        view\n        returns (uint transferable, bool anyRateIsInvalid);\n\n    // Restricted: used internally to Synthetix\n    function issueSynths(address from, uint amount) external;\n\n    function issueSynthsOnBehalf(\n        address issueFor,\n        address from,\n        uint amount\n    ) external;\n\n    function issueMaxSynths(address from) external;\n\n    function issueMaxSynthsOnBehalf(address issueFor, address from) external;\n\n    function burnSynths(address from, uint amount) external;\n\n    function burnSynthsOnBehalf(\n        address burnForAddress,\n        address from,\n        uint amount\n    ) external;\n\n    function burnSynthsToTarget(address from) external;\n\n    function burnSynthsToTargetOnBehalf(address burnForAddress, address from) external;\n\n    function burnForRedemption(\n        address deprecatedSynthProxy,\n        address account,\n        uint balance\n    ) external;\n\n    function liquidateDelinquentAccount(\n        address account,\n        uint susdAmount,\n        address liquidator\n    ) external returns (uint totalRedeemed, uint amountToLiquidate);\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinresolver\ncontract MixinResolver {\n    AddressResolver public resolver;\n\n    mapping(bytes32 => address) private addressCache;\n\n    constructor(address _resolver) internal {\n        resolver = AddressResolver(_resolver);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function combineArrays(bytes32[] memory first, bytes32[] memory second)\n        internal\n        pure\n        returns (bytes32[] memory combination)\n    {\n        combination = new bytes32[](first.length + second.length);\n\n        for (uint i = 0; i < first.length; i++) {\n            combination[i] = first[i];\n        }\n\n        for (uint j = 0; j < second.length; j++) {\n            combination[first.length + j] = second[j];\n        }\n    }\n\n    /* ========== PUBLIC FUNCTIONS ========== */\n\n    // Note: this function is public not external in order for it to be overridden and invoked via super in subclasses\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {}\n\n    function rebuildCache() public {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        // The resolver must call this function whenver it updates its state\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // Note: can only be invoked once the resolver has all the targets needed added\n            address destination =\n                resolver.requireAndGetAddress(name, string(abi.encodePacked(\"Resolver missing target: \", name)));\n            addressCache[name] = destination;\n            emit CacheUpdated(name, destination);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function isResolverCached() external view returns (bool) {\n        bytes32[] memory requiredAddresses = resolverAddressesRequired();\n        for (uint i = 0; i < requiredAddresses.length; i++) {\n            bytes32 name = requiredAddresses[i];\n            // false if our cache is invalid or if the resolver doesn't have the required address\n            if (resolver.getAddress(name) != addressCache[name] || addressCache[name] == address(0)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function requireAndGetAddress(bytes32 name) internal view returns (address) {\n        address _foundAddress = addressCache[name];\n        require(_foundAddress != address(0), string(abi.encodePacked(\"Missing address: \", name)));\n        return _foundAddress;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event CacheUpdated(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/addressresolver\ncontract AddressResolver is Owned, IAddressResolver {\n    mapping(bytes32 => address) public repository;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== RESTRICTED FUNCTIONS ========== */\n\n    function importAddresses(bytes32[] calldata names, address[] calldata destinations) external onlyOwner {\n        require(names.length == destinations.length, \"Input lengths must match\");\n\n        for (uint i = 0; i < names.length; i++) {\n            bytes32 name = names[i];\n            address destination = destinations[i];\n            repository[name] = destination;\n            emit AddressImported(name, destination);\n        }\n    }\n\n    /* ========= PUBLIC FUNCTIONS ========== */\n\n    function rebuildCaches(MixinResolver[] calldata destinations) external {\n        for (uint i = 0; i < destinations.length; i++) {\n            destinations[i].rebuildCache();\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function areAddressesImported(bytes32[] calldata names, address[] calldata destinations) external view returns (bool) {\n        for (uint i = 0; i < names.length; i++) {\n            if (repository[names[i]] != destinations[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    function getAddress(bytes32 name) external view returns (address) {\n        return repository[name];\n    }\n\n    function requireAndGetAddress(bytes32 name, string calldata reason) external view returns (address) {\n        address _foundAddress = repository[name];\n        require(_foundAddress != address(0), reason);\n        return _foundAddress;\n    }\n\n    function getSynth(bytes32 key) external view returns (address) {\n        IIssuer issuer = IIssuer(repository[\"Issuer\"]);\n        require(address(issuer) != address(0), \"Cannot find Issuer address\");\n        return address(issuer.synths(key));\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AddressImported(bytes32 name, address destination);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/state\ncontract State is Owned {\n    // the address of the contract that can modify variables\n    // this can only be changed by the owner of this contract\n    address public associatedContract;\n\n    constructor(address _associatedContract) internal {\n        // This contract is abstract, and thus cannot be instantiated directly\n        require(owner != address(0), \"Owner must be set\");\n\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== SETTERS ========== */\n\n    // Change the associated contract to a new address\n    function setAssociatedContract(address _associatedContract) external onlyOwner {\n        associatedContract = _associatedContract;\n        emit AssociatedContractUpdated(_associatedContract);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyAssociatedContract {\n        require(msg.sender == associatedContract, \"Only the associated contract can perform this action\");\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AssociatedContractUpdated(address associatedContract);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangestate\ninterface IExchangeState {\n    // Views\n    struct ExchangeEntry {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint amountReceived;\n        uint exchangeFeeRate;\n        uint timestamp;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint);\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        );\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint);\n\n    // Mutative functions\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external;\n\n    function removeEntries(address account, bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangestate\ncontract ExchangeState is Owned, State, IExchangeState {\n    mapping(address => mapping(bytes32 => IExchangeState.ExchangeEntry[])) public exchanges;\n\n    uint public maxEntriesInQueue = 12;\n\n    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}\n\n    /* ========== SETTERS ========== */\n\n    function setMaxEntriesInQueue(uint _maxEntriesInQueue) external onlyOwner {\n        maxEntriesInQueue = _maxEntriesInQueue;\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function appendExchangeEntry(\n        address account,\n        bytes32 src,\n        uint amount,\n        bytes32 dest,\n        uint amountReceived,\n        uint exchangeFeeRate,\n        uint timestamp,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    ) external onlyAssociatedContract {\n        require(exchanges[account][dest].length < maxEntriesInQueue, \"Max queue length reached\");\n\n        exchanges[account][dest].push(\n            ExchangeEntry({\n                src: src,\n                amount: amount,\n                dest: dest,\n                amountReceived: amountReceived,\n                exchangeFeeRate: exchangeFeeRate,\n                timestamp: timestamp,\n                roundIdForSrc: roundIdForSrc,\n                roundIdForDest: roundIdForDest\n            })\n        );\n    }\n\n    function removeEntries(address account, bytes32 currencyKey) external onlyAssociatedContract {\n        delete exchanges[account][currencyKey];\n    }\n\n    /* ========== VIEWS ========== */\n\n    function getLengthOfEntries(address account, bytes32 currencyKey) external view returns (uint) {\n        return exchanges[account][currencyKey].length;\n    }\n\n    function getEntryAt(\n        address account,\n        bytes32 currencyKey,\n        uint index\n    )\n        external\n        view\n        returns (\n            bytes32 src,\n            uint amount,\n            bytes32 dest,\n            uint amountReceived,\n            uint exchangeFeeRate,\n            uint timestamp,\n            uint roundIdForSrc,\n            uint roundIdForDest\n        )\n    {\n        ExchangeEntry storage entry = exchanges[account][currencyKey][index];\n        return (\n            entry.src,\n            entry.amount,\n            entry.dest,\n            entry.amountReceived,\n            entry.exchangeFeeRate,\n            entry.timestamp,\n            entry.roundIdForSrc,\n            entry.roundIdForDest\n        );\n    }\n\n    function getMaxTimestamp(address account, bytes32 currencyKey) external view returns (uint) {\n        ExchangeEntry[] storage userEntries = exchanges[account][currencyKey];\n        uint timestamp = 0;\n        for (uint i = 0; i < userEntries.length; i++) {\n            if (userEntries[i].timestamp > timestamp) {\n                timestamp = userEntries[i].timestamp;\n            }\n        }\n        return timestamp;\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemstatus\ninterface ISystemStatus {\n    struct Status {\n        bool canSuspend;\n        bool canResume;\n    }\n\n    struct Suspension {\n        bool suspended;\n        // reason is an integer code,\n        // 0 => no reason, 1 => upgrading, 2+ => defined by system usage\n        uint248 reason;\n    }\n\n    // Views\n    function accessControl(bytes32 section, address account) external view returns (bool canSuspend, bool canResume);\n\n    function requireSystemActive() external view;\n\n    function requireIssuanceActive() external view;\n\n    function requireExchangeActive() external view;\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function requireSynthActive(bytes32 currencyKey) external view;\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view;\n\n    function systemSuspension() external view returns (bool suspended, uint248 reason);\n\n    function issuanceSuspension() external view returns (bool suspended, uint248 reason);\n\n    function exchangeSuspension() external view returns (bool suspended, uint248 reason);\n\n    function synthExchangeSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function synthSuspension(bytes32 currencyKey) external view returns (bool suspended, uint248 reason);\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons);\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons);\n\n    // Restricted functions\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external;\n\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external;\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemstatus\ncontract SystemStatus is Owned, ISystemStatus {\n    mapping(bytes32 => mapping(address => Status)) public accessControl;\n\n    uint248 public constant SUSPENSION_REASON_UPGRADE = 1;\n\n    bytes32 public constant SECTION_SYSTEM = \"System\";\n    bytes32 public constant SECTION_ISSUANCE = \"Issuance\";\n    bytes32 public constant SECTION_EXCHANGE = \"Exchange\";\n    bytes32 public constant SECTION_SYNTH_EXCHANGE = \"SynthExchange\";\n    bytes32 public constant SECTION_SYNTH = \"Synth\";\n\n    Suspension public systemSuspension;\n\n    Suspension public issuanceSuspension;\n\n    Suspension public exchangeSuspension;\n\n    mapping(bytes32 => Suspension) public synthExchangeSuspension;\n\n    mapping(bytes32 => Suspension) public synthSuspension;\n\n    constructor(address _owner) public Owned(_owner) {}\n\n    /* ========== VIEWS ========== */\n    function requireSystemActive() external view {\n        _internalRequireSystemActive();\n    }\n\n    function requireIssuanceActive() external view {\n        // Issuance requires the system be active\n        _internalRequireSystemActive();\n\n        // and issuance itself of course\n        _internalRequireIssuanceActive();\n    }\n\n    function requireExchangeActive() external view {\n        // Exchanging requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging itself of course\n        _internalRequireExchangeActive();\n    }\n\n    function requireSynthExchangeActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthExchangeActive(currencyKey);\n    }\n\n    function requireSynthActive(bytes32 currencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(currencyKey);\n    }\n\n    function requireSynthsActive(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function requireExchangeBetweenSynthsAllowed(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey) external view {\n        // Synth exchange and transfer requires the system be active\n        _internalRequireSystemActive();\n\n        // and exchanging must be active\n        _internalRequireExchangeActive();\n\n        // and the synth exchanging between the synths must be active\n        _internalRequireSynthExchangeActive(sourceCurrencyKey);\n        _internalRequireSynthExchangeActive(destinationCurrencyKey);\n\n        // and finally, the synths cannot be suspended\n        _internalRequireSynthActive(sourceCurrencyKey);\n        _internalRequireSynthActive(destinationCurrencyKey);\n    }\n\n    function isSystemUpgrading() external view returns (bool) {\n        return systemSuspension.suspended && systemSuspension.reason == SUSPENSION_REASON_UPGRADE;\n    }\n\n    function getSynthExchangeSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory exchangeSuspensions, uint256[] memory reasons)\n    {\n        exchangeSuspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            exchangeSuspensions[i] = synthExchangeSuspension[synths[i]].suspended;\n            reasons[i] = synthExchangeSuspension[synths[i]].reason;\n        }\n    }\n\n    function getSynthSuspensions(bytes32[] calldata synths)\n        external\n        view\n        returns (bool[] memory suspensions, uint256[] memory reasons)\n    {\n        suspensions = new bool[](synths.length);\n        reasons = new uint256[](synths.length);\n\n        for (uint i = 0; i < synths.length; i++) {\n            suspensions[i] = synthSuspension[synths[i]].suspended;\n            reasons[i] = synthSuspension[synths[i]].reason;\n        }\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function updateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) external onlyOwner {\n        _internalUpdateAccessControl(section, account, canSuspend, canResume);\n    }\n\n    function updateAccessControls(\n        bytes32[] calldata sections,\n        address[] calldata accounts,\n        bool[] calldata canSuspends,\n        bool[] calldata canResumes\n    ) external onlyOwner {\n        require(\n            sections.length == accounts.length &&\n                accounts.length == canSuspends.length &&\n                canSuspends.length == canResumes.length,\n            \"Input array lengths must match\"\n        );\n        for (uint i = 0; i < sections.length; i++) {\n            _internalUpdateAccessControl(sections[i], accounts[i], canSuspends[i], canResumes[i]);\n        }\n    }\n\n    function suspendSystem(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_SYSTEM);\n        systemSuspension.suspended = true;\n        systemSuspension.reason = uint248(reason);\n        emit SystemSuspended(systemSuspension.reason);\n    }\n\n    function resumeSystem() external {\n        _requireAccessToResume(SECTION_SYSTEM);\n        systemSuspension.suspended = false;\n        emit SystemResumed(uint256(systemSuspension.reason));\n        systemSuspension.reason = 0;\n    }\n\n    function suspendIssuance(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = true;\n        issuanceSuspension.reason = uint248(reason);\n        emit IssuanceSuspended(reason);\n    }\n\n    function resumeIssuance() external {\n        _requireAccessToResume(SECTION_ISSUANCE);\n        issuanceSuspension.suspended = false;\n        emit IssuanceResumed(uint256(issuanceSuspension.reason));\n        issuanceSuspension.reason = 0;\n    }\n\n    function suspendExchange(uint256 reason) external {\n        _requireAccessToSuspend(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = true;\n        exchangeSuspension.reason = uint248(reason);\n        emit ExchangeSuspended(reason);\n    }\n\n    function resumeExchange() external {\n        _requireAccessToResume(SECTION_EXCHANGE);\n        exchangeSuspension.suspended = false;\n        emit ExchangeResumed(uint256(exchangeSuspension.reason));\n        exchangeSuspension.reason = 0;\n    }\n\n    function suspendSynthExchange(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function suspendSynthsExchange(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynthExchange(currencyKeys, reason);\n    }\n\n    function resumeSynthExchange(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function resumeSynthsExchange(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynthsExchange(currencyKeys);\n    }\n\n    function suspendSynth(bytes32 currencyKey, uint256 reason) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function suspendSynths(bytes32[] calldata currencyKeys, uint256 reason) external {\n        _internalSuspendSynths(currencyKeys, reason);\n    }\n\n    function resumeSynth(bytes32 currencyKey) external {\n        bytes32[] memory currencyKeys = new bytes32[](1);\n        currencyKeys[0] = currencyKey;\n        _internalResumeSynths(currencyKeys);\n    }\n\n    function resumeSynths(bytes32[] calldata currencyKeys) external {\n        _internalResumeSynths(currencyKeys);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _requireAccessToSuspend(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canSuspend, \"Restricted to access control list\");\n    }\n\n    function _requireAccessToResume(bytes32 section) internal view {\n        require(accessControl[section][msg.sender].canResume, \"Restricted to access control list\");\n    }\n\n    function _internalRequireSystemActive() internal view {\n        require(\n            !systemSuspension.suspended,\n            systemSuspension.reason == SUSPENSION_REASON_UPGRADE\n                ? \"Synthetix is suspended, upgrade in progress... please stand by\"\n                : \"Synthetix is suspended. Operation prohibited\"\n        );\n    }\n\n    function _internalRequireIssuanceActive() internal view {\n        require(!issuanceSuspension.suspended, \"Issuance is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireExchangeActive() internal view {\n        require(!exchangeSuspension.suspended, \"Exchange is suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthExchangeActive(bytes32 currencyKey) internal view {\n        require(!synthExchangeSuspension[currencyKey].suspended, \"Synth exchange suspended. Operation prohibited\");\n    }\n\n    function _internalRequireSynthActive(bytes32 currencyKey) internal view {\n        require(!synthSuspension[currencyKey].suspended, \"Synth is suspended. Operation prohibited\");\n    }\n\n    function _internalSuspendSynths(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthSuspension[currencyKey].suspended = true;\n            synthSuspension[currencyKey].reason = uint248(reason);\n            emit SynthSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynths(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthResumed(currencyKey, uint256(synthSuspension[currencyKey].reason));\n            delete synthSuspension[currencyKey];\n        }\n    }\n\n    function _internalSuspendSynthExchange(bytes32[] memory currencyKeys, uint256 reason) internal {\n        _requireAccessToSuspend(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            synthExchangeSuspension[currencyKey].suspended = true;\n            synthExchangeSuspension[currencyKey].reason = uint248(reason);\n            emit SynthExchangeSuspended(currencyKey, reason);\n        }\n    }\n\n    function _internalResumeSynthsExchange(bytes32[] memory currencyKeys) internal {\n        _requireAccessToResume(SECTION_SYNTH_EXCHANGE);\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            bytes32 currencyKey = currencyKeys[i];\n            emit SynthExchangeResumed(currencyKey, uint256(synthExchangeSuspension[currencyKey].reason));\n            delete synthExchangeSuspension[currencyKey];\n        }\n    }\n\n    function _internalUpdateAccessControl(\n        bytes32 section,\n        address account,\n        bool canSuspend,\n        bool canResume\n    ) internal {\n        require(\n            section == SECTION_SYSTEM ||\n                section == SECTION_ISSUANCE ||\n                section == SECTION_EXCHANGE ||\n                section == SECTION_SYNTH_EXCHANGE ||\n                section == SECTION_SYNTH,\n            \"Invalid section supplied\"\n        );\n        accessControl[section][account].canSuspend = canSuspend;\n        accessControl[section][account].canResume = canResume;\n        emit AccessControlUpdated(section, account, canSuspend, canResume);\n    }\n\n    /* ========== EVENTS ========== */\n\n    event SystemSuspended(uint256 reason);\n    event SystemResumed(uint256 reason);\n\n    event IssuanceSuspended(uint256 reason);\n    event IssuanceResumed(uint256 reason);\n\n    event ExchangeSuspended(uint256 reason);\n    event ExchangeResumed(uint256 reason);\n\n    event SynthExchangeSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthExchangeResumed(bytes32 currencyKey, uint256 reason);\n\n    event SynthSuspended(bytes32 currencyKey, uint256 reason);\n    event SynthResumed(bytes32 currencyKey, uint256 reason);\n\n    event AccessControlUpdated(bytes32 indexed section, address indexed account, bool canSuspend, bool canResume);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iflexiblestorage\ninterface IFlexibleStorage {\n    // Views\n    function getUIntValue(bytes32 contractName, bytes32 record) external view returns (uint);\n\n    function getUIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (uint[] memory);\n\n    function getIntValue(bytes32 contractName, bytes32 record) external view returns (int);\n\n    function getIntValues(bytes32 contractName, bytes32[] calldata records) external view returns (int[] memory);\n\n    function getAddressValue(bytes32 contractName, bytes32 record) external view returns (address);\n\n    function getAddressValues(bytes32 contractName, bytes32[] calldata records) external view returns (address[] memory);\n\n    function getBoolValue(bytes32 contractName, bytes32 record) external view returns (bool);\n\n    function getBoolValues(bytes32 contractName, bytes32[] calldata records) external view returns (bool[] memory);\n\n    function getBytes32Value(bytes32 contractName, bytes32 record) external view returns (bytes32);\n\n    function getBytes32Values(bytes32 contractName, bytes32[] calldata records) external view returns (bytes32[] memory);\n\n    // Mutative functions\n    function deleteUIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteIntValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteAddressValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBoolValue(bytes32 contractName, bytes32 record) external;\n\n    function deleteBytes32Value(bytes32 contractName, bytes32 record) external;\n\n    function setUIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        uint value\n    ) external;\n\n    function setUIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        uint[] calldata values\n    ) external;\n\n    function setIntValue(\n        bytes32 contractName,\n        bytes32 record,\n        int value\n    ) external;\n\n    function setIntValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        int[] calldata values\n    ) external;\n\n    function setAddressValue(\n        bytes32 contractName,\n        bytes32 record,\n        address value\n    ) external;\n\n    function setAddressValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        address[] calldata values\n    ) external;\n\n    function setBoolValue(\n        bytes32 contractName,\n        bytes32 record,\n        bool value\n    ) external;\n\n    function setBoolValues(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bool[] calldata values\n    ) external;\n\n    function setBytes32Value(\n        bytes32 contractName,\n        bytes32 record,\n        bytes32 value\n    ) external;\n\n    function setBytes32Values(\n        bytes32 contractName,\n        bytes32[] calldata records,\n        bytes32[] calldata values\n    ) external;\n}\n\n\n// Internal references\n\n\n// https://docs.synthetix.io/contracts/source/contracts/mixinsystemsettings\ncontract MixinSystemSettings is MixinResolver {\n    // must match the one defined SystemSettingsLib, defined in both places due to sol v0.5 limitations\n    bytes32 internal constant SETTING_CONTRACT_NAME = \"SystemSettings\";\n\n    bytes32 internal constant SETTING_WAITING_PERIOD_SECS = \"waitingPeriodSecs\";\n    bytes32 internal constant SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR = \"priceDeviationThresholdFactor\";\n    bytes32 internal constant SETTING_ISSUANCE_RATIO = \"issuanceRatio\";\n    bytes32 internal constant SETTING_FEE_PERIOD_DURATION = \"feePeriodDuration\";\n    bytes32 internal constant SETTING_TARGET_THRESHOLD = \"targetThreshold\";\n    bytes32 internal constant SETTING_LIQUIDATION_DELAY = \"liquidationDelay\";\n    bytes32 internal constant SETTING_LIQUIDATION_RATIO = \"liquidationRatio\";\n    bytes32 internal constant SETTING_LIQUIDATION_PENALTY = \"liquidationPenalty\";\n    bytes32 internal constant SETTING_RATE_STALE_PERIOD = \"rateStalePeriod\";\n    /* ========== Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_EXCHANGE_FEE_RATE = \"exchangeFeeRate\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD = \"exchangeDynamicFeeThreshold\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY = \"exchangeDynamicFeeWeightDecay\";\n    bytes32 internal constant SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS = \"exchangeDynamicFeeRounds\";\n    bytes32 internal constant SETTING_EXCHANGE_MAX_DYNAMIC_FEE = \"exchangeMaxDynamicFee\";\n    /* ========== End Exchange Fees Related ========== */\n    bytes32 internal constant SETTING_MINIMUM_STAKE_TIME = \"minimumStakeTime\";\n    bytes32 internal constant SETTING_AGGREGATOR_WARNING_FLAGS = \"aggregatorWarningFlags\";\n    bytes32 internal constant SETTING_TRADING_REWARDS_ENABLED = \"tradingRewardsEnabled\";\n    bytes32 internal constant SETTING_DEBT_SNAPSHOT_STALE_TIME = \"debtSnapshotStaleTime\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT = \"crossDomainDepositGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT = \"crossDomainEscrowGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT = \"crossDomainRewardGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT = \"crossDomainWithdrawalGasLimit\";\n    bytes32 internal constant SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT = \"crossDomainRelayGasLimit\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MAX_ETH = \"etherWrapperMaxETH\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_MINT_FEE_RATE = \"etherWrapperMintFeeRate\";\n    bytes32 internal constant SETTING_ETHER_WRAPPER_BURN_FEE_RATE = \"etherWrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_MAX_TOKEN_AMOUNT = \"wrapperMaxTokens\";\n    bytes32 internal constant SETTING_WRAPPER_MINT_FEE_RATE = \"wrapperMintFeeRate\";\n    bytes32 internal constant SETTING_WRAPPER_BURN_FEE_RATE = \"wrapperBurnFeeRate\";\n    bytes32 internal constant SETTING_INTERACTION_DELAY = \"interactionDelay\";\n    bytes32 internal constant SETTING_COLLAPSE_FEE_RATE = \"collapseFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK = \"atomicMaxVolumePerBlock\";\n    bytes32 internal constant SETTING_ATOMIC_TWAP_WINDOW = \"atomicTwapWindow\";\n    bytes32 internal constant SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING = \"atomicEquivalentForDexPricing\";\n    bytes32 internal constant SETTING_ATOMIC_EXCHANGE_FEE_RATE = \"atomicExchangeFeeRate\";\n    bytes32 internal constant SETTING_ATOMIC_PRICE_BUFFER = \"atomicPriceBuffer\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = \"atomicVolConsiderationWindow\";\n    bytes32 internal constant SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD = \"atomicVolUpdateThreshold\";\n\n    bytes32 internal constant CONTRACT_FLEXIBLESTORAGE = \"FlexibleStorage\";\n\n    enum CrossDomainMessageGasLimits {Deposit, Escrow, Reward, Withdrawal, Relay}\n\n    struct DynamicFeeConfig {\n        uint threshold;\n        uint weightDecay;\n        uint rounds;\n        uint maxFee;\n    }\n\n    constructor(address _resolver) internal MixinResolver(_resolver) {}\n\n    function resolverAddressesRequired() public view returns (bytes32[] memory addresses) {\n        addresses = new bytes32[](1);\n        addresses[0] = CONTRACT_FLEXIBLESTORAGE;\n    }\n\n    function flexibleStorage() internal view returns (IFlexibleStorage) {\n        return IFlexibleStorage(requireAndGetAddress(CONTRACT_FLEXIBLESTORAGE));\n    }\n\n    function _getGasLimitSetting(CrossDomainMessageGasLimits gasLimitType) internal pure returns (bytes32) {\n        if (gasLimitType == CrossDomainMessageGasLimits.Deposit) {\n            return SETTING_CROSS_DOMAIN_DEPOSIT_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Escrow) {\n            return SETTING_CROSS_DOMAIN_ESCROW_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Reward) {\n            return SETTING_CROSS_DOMAIN_REWARD_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Withdrawal) {\n            return SETTING_CROSS_DOMAIN_WITHDRAWAL_GAS_LIMIT;\n        } else if (gasLimitType == CrossDomainMessageGasLimits.Relay) {\n            return SETTING_CROSS_DOMAIN_RELAY_GAS_LIMIT;\n        } else {\n            revert(\"Unknown gas limit type\");\n        }\n    }\n\n    function getCrossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, _getGasLimitSetting(gasLimitType));\n    }\n\n    function getTradingRewardsEnabled() internal view returns (bool) {\n        return flexibleStorage().getBoolValue(SETTING_CONTRACT_NAME, SETTING_TRADING_REWARDS_ENABLED);\n    }\n\n    function getWaitingPeriodSecs() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_WAITING_PERIOD_SECS);\n    }\n\n    function getPriceDeviationThresholdFactor() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR);\n    }\n\n    function getIssuanceRatio() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ISSUANCE_RATIO);\n    }\n\n    function getFeePeriodDuration() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_FEE_PERIOD_DURATION);\n    }\n\n    function getTargetThreshold() internal view returns (uint) {\n        // lookup on flexible storage directly for gas savings (rather than via SystemSettings)\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_TARGET_THRESHOLD);\n    }\n\n    function getLiquidationDelay() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_DELAY);\n    }\n\n    function getLiquidationRatio() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_RATIO);\n    }\n\n    function getLiquidationPenalty() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_LIQUIDATION_PENALTY);\n    }\n\n    function getRateStalePeriod() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_RATE_STALE_PERIOD);\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function getExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    /// @notice Get exchange dynamic fee related keys\n    /// @return threshold, weight decay, rounds, and max fee\n    function getExchangeDynamicFeeConfig() internal view returns (DynamicFeeConfig memory) {\n        bytes32[] memory keys = new bytes32[](4);\n        keys[0] = SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD;\n        keys[1] = SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY;\n        keys[2] = SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS;\n        keys[3] = SETTING_EXCHANGE_MAX_DYNAMIC_FEE;\n        uint[] memory values = flexibleStorage().getUIntValues(SETTING_CONTRACT_NAME, keys);\n        return DynamicFeeConfig({threshold: values[0], weightDecay: values[1], rounds: values[2], maxFee: values[3]});\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function getMinimumStakeTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_MINIMUM_STAKE_TIME);\n    }\n\n    function getAggregatorWarningFlags() internal view returns (address) {\n        return flexibleStorage().getAddressValue(SETTING_CONTRACT_NAME, SETTING_AGGREGATOR_WARNING_FLAGS);\n    }\n\n    function getDebtSnapshotStaleTime() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_DEBT_SNAPSHOT_STALE_TIME);\n    }\n\n    function getEtherWrapperMaxETH() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MAX_ETH);\n    }\n\n    function getEtherWrapperMintFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_MINT_FEE_RATE);\n    }\n\n    function getEtherWrapperBurnFeeRate() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ETHER_WRAPPER_BURN_FEE_RATE);\n    }\n\n    function getWrapperMaxTokenAmount(address wrapper) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, wrapper))\n            );\n    }\n\n    function getWrapperMintFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_MINT_FEE_RATE, wrapper))\n            );\n    }\n\n    function getWrapperBurnFeeRate(address wrapper) internal view returns (int) {\n        return\n            flexibleStorage().getIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_WRAPPER_BURN_FEE_RATE, wrapper))\n            );\n    }\n\n    function getInteractionDelay(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_INTERACTION_DELAY, collateral))\n            );\n    }\n\n    function getCollapseFeeRate(address collateral) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_COLLAPSE_FEE_RATE, collateral))\n            );\n    }\n\n    function getAtomicMaxVolumePerBlock() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK);\n    }\n\n    function getAtomicTwapWindow() internal view returns (uint) {\n        return flexibleStorage().getUIntValue(SETTING_CONTRACT_NAME, SETTING_ATOMIC_TWAP_WINDOW);\n    }\n\n    function getAtomicEquivalentForDexPricing(bytes32 currencyKey) internal view returns (address) {\n        return\n            flexibleStorage().getAddressValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING, currencyKey))\n            );\n    }\n\n    function getAtomicExchangeFeeRate(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_EXCHANGE_FEE_RATE, currencyKey))\n            );\n    }\n\n    function getAtomicPriceBuffer(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_PRICE_BUFFER, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityConsiderationWindow(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW, currencyKey))\n            );\n    }\n\n    function getAtomicVolatilityUpdateThreshold(bytes32 currencyKey) internal view returns (uint) {\n        return\n            flexibleStorage().getUIntValue(\n                SETTING_CONTRACT_NAME,\n                keccak256(abi.encodePacked(SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD, currencyKey))\n            );\n    }\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/ierc20\ninterface IERC20 {\n    // ERC20 Optional Views\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    // Views\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(address owner, address spender) external view returns (uint);\n\n    // Mutative functions\n    function transfer(address to, uint value) external returns (bool);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchangerates\ninterface IExchangeRates {\n    // Structs\n    struct RateAndUpdatedTime {\n        uint216 rate;\n        uint40 time;\n    }\n\n    // Views\n    function aggregators(bytes32 currencyKey) external view returns (address);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool);\n\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds) external view returns (bool);\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory);\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value);\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        );\n\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        );\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint);\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint);\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256);\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time);\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time);\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid);\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint);\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times);\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid);\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory);\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool);\n}\n\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, \"SafeMath: division by zero\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n}\n\n\n// Libraries\n\n\n// https://docs.synthetix.io/contracts/source/libraries/safedecimalmath\nlibrary SafeDecimalMath {\n    using SafeMath for uint;\n\n    /* Number of decimal places in the representations. */\n    uint8 public constant decimals = 18;\n    uint8 public constant highPrecisionDecimals = 27;\n\n    /* The number representing 1.0. */\n    uint public constant UNIT = 10**uint(decimals);\n\n    /* The number representing 1.0 for higher fidelity numbers. */\n    uint public constant PRECISE_UNIT = 10**uint(highPrecisionDecimals);\n    uint private constant UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR = 10**uint(highPrecisionDecimals - decimals);\n\n    /**\n     * @return Provides an interface to UNIT.\n     */\n    function unit() external pure returns (uint) {\n        return UNIT;\n    }\n\n    /**\n     * @return Provides an interface to PRECISE_UNIT.\n     */\n    function preciseUnit() external pure returns (uint) {\n        return PRECISE_UNIT;\n    }\n\n    /**\n     * @return The result of multiplying x and y, interpreting the operands as fixed-point\n     * decimals.\n     *\n     * @dev A unit factor is divided out after the product of x and y is evaluated,\n     * so that product must be less than 2**256. As this is an integer division,\n     * the internal division always rounds down. This helps save on gas. Rounding\n     * is more expensive on gas.\n     */\n    function multiplyDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        return x.mul(y) / UNIT;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of the specified precision unit.\n     *\n     * @dev The operands should be in the form of a the specified unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function _multiplyDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        /* Divide by UNIT to remove the extra factor introduced by the product. */\n        uint quotientTimesTen = x.mul(y) / (precisionUnit / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a precise unit.\n     *\n     * @dev The operands should be in the precise unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @return The result of safely multiplying x and y, interpreting the operands\n     * as fixed-point decimals of a standard unit.\n     *\n     * @dev The operands should be in the standard unit factor which will be\n     * divided out after the product of x and y is evaluated, so that product must be\n     * less than 2**256.\n     *\n     * Unlike multiplyDecimal, this function rounds the result to the nearest increment.\n     * Rounding is useful when you need to retain fidelity for small decimal numbers\n     * (eg. small fractions or percentages).\n     */\n    function multiplyDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _multiplyDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is a high\n     * precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and UNIT must be less than 2**256. As\n     * this is an integer division, the result is always rounded down.\n     * This helps save on gas. Rounding is more expensive on gas.\n     */\n    function divideDecimal(uint x, uint y) internal pure returns (uint) {\n        /* Reintroduce the UNIT factor that will be divided out by y. */\n        return x.mul(UNIT).div(y);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * decimal in the precision unit specified in the parameter.\n     *\n     * @dev y is divided after the product of x and the specified precision unit\n     * is evaluated, so the product of x and the specified precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function _divideDecimalRound(\n        uint x,\n        uint y,\n        uint precisionUnit\n    ) private pure returns (uint) {\n        uint resultTimesTen = x.mul(precisionUnit * 10).div(y);\n\n        if (resultTimesTen % 10 >= 5) {\n            resultTimesTen += 10;\n        }\n\n        return resultTimesTen / 10;\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * standard precision decimal.\n     *\n     * @dev y is divided after the product of x and the standard precision unit\n     * is evaluated, so the product of x and the standard precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRound(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, UNIT);\n    }\n\n    /**\n     * @return The result of safely dividing x and y. The return value is as a rounded\n     * high precision decimal.\n     *\n     * @dev y is divided after the product of x and the high precision unit\n     * is evaluated, so the product of x and the high precision unit must\n     * be less than 2**256. The result is rounded to the nearest increment.\n     */\n    function divideDecimalRoundPrecise(uint x, uint y) internal pure returns (uint) {\n        return _divideDecimalRound(x, y, PRECISE_UNIT);\n    }\n\n    /**\n     * @dev Convert a standard decimal representation to a high precision one.\n     */\n    function decimalToPreciseDecimal(uint i) internal pure returns (uint) {\n        return i.mul(UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR);\n    }\n\n    /**\n     * @dev Convert a high precision decimal to a standard decimal representation.\n     */\n    function preciseDecimalToDecimal(uint i) internal pure returns (uint) {\n        uint quotientTimesTen = i / (UNIT_TO_HIGH_PRECISION_CONVERSION_FACTOR / 10);\n\n        if (quotientTimesTen % 10 >= 5) {\n            quotientTimesTen += 10;\n        }\n\n        return quotientTimesTen / 10;\n    }\n\n    // Computes `a - b`, setting the value to 0 if b > a.\n    function floorsub(uint a, uint b) internal pure returns (uint) {\n        return b >= a ? 0 : a - b;\n    }\n\n    /* ---------- Utilities ---------- */\n    /*\n     * Absolute value of the input, returned as a signed number.\n     */\n    function signedAbs(int x) internal pure returns (int) {\n        return x < 0 ? -x : x;\n    }\n\n    /*\n     * Absolute value of the input, returned as an unsigned number.\n     */\n    function abs(int x) internal pure returns (uint) {\n        return uint(signedAbs(x));\n    }\n}\n\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\n/**\n * @title The V2 & V3 Aggregator Interface\n * @notice Solidity V0.5 does not allow interfaces to inherit from other\n * interfaces so this contract is a combination of v0.5 AggregatorInterface.sol\n * and v0.5 AggregatorV3Interface.sol.\n */\ninterface AggregatorV2V3Interface {\n  //\n  // V2 Interface:\n  //\n  function latestAnswer() external view returns (int256);\n  function latestTimestamp() external view returns (uint256);\n  function latestRound() external view returns (uint256);\n  function getAnswer(uint256 roundId) external view returns (int256);\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 timestamp);\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n\n  //\n  // V3 Interface:\n  //\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n\n\ninterface FlagsInterface {\n  function getFlag(address) external view returns (bool);\n  function getFlags(address[] calldata) external view returns (bool[] memory);\n  function raiseFlag(address) external;\n  function raiseFlags(address[] calldata) external;\n  function lowerFlags(address[] calldata) external;\n  function setRaisingAccessController(address) external;\n}\n\n\ninterface IVirtualSynth {\n    // Views\n    function balanceOfUnderlying(address account) external view returns (uint);\n\n    function rate() external view returns (uint);\n\n    function readyToSettle() external view returns (bool);\n\n    function secsLeftInWaitingPeriod() external view returns (uint);\n\n    function settled() external view returns (bool);\n\n    function synth() external view returns (ISynth);\n\n    // Mutative functions\n    function settle(address account) external;\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/iexchanger\ninterface IExchanger {\n    struct ExchangeEntrySettlement {\n        bytes32 src;\n        uint amount;\n        bytes32 dest;\n        uint reclaim;\n        uint rebate;\n        uint srcRoundIdAtPeriodEnd;\n        uint destRoundIdAtPeriodEnd;\n        uint timestamp;\n    }\n\n    struct ExchangeEntry {\n        uint sourceRate;\n        uint destinationRate;\n        uint destinationAmount;\n        uint exchangeFeeRate;\n        uint exchangeDynamicFeeRate;\n        uint roundIdForSrc;\n        uint roundIdForDest;\n    }\n\n    // Views\n    function calculateAmountAfterSettlement(\n        address from,\n        bytes32 currencyKey,\n        uint amount,\n        uint refunded\n    ) external view returns (uint amountAfterSettlement);\n\n    function isSynthRateInvalid(bytes32 currencyKey) external view returns (bool);\n\n    function maxSecsLeftInWaitingPeriod(address account, bytes32 currencyKey) external view returns (uint);\n\n    function settlementOwing(address account, bytes32 currencyKey)\n        external\n        view\n        returns (\n            uint reclaimAmount,\n            uint rebateAmount,\n            uint numEntries\n        );\n\n    function hasWaitingPeriodOrSettlementOwing(address account, bytes32 currencyKey) external view returns (bool);\n\n    function feeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint exchangeFeeRate, bool tooVolatile);\n\n    function dynamicFeeRateForExchange(bytes32 sourceCurrencyKey, bytes32 destinationCurrencyKey)\n        external\n        view\n        returns (uint feeRate, bool tooVolatile);\n\n    function getAmountsForExchange(\n        uint sourceAmount,\n        bytes32 sourceCurrencyKey,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint amountReceived,\n            uint fee,\n            uint exchangeFeeRate\n        );\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function waitingPeriodSecs() external view returns (uint);\n\n    // Mutative functions\n    function exchange(\n        address exchangeForAddress,\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bool virtualSynth,\n        address rewardAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived, IVirtualSynth vSynth);\n\n    function exchangeAtomically(\n        address from,\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        address destinationAddress,\n        bytes32 trackingCode\n    ) external returns (uint amountReceived);\n\n    function settle(address from, bytes32 currencyKey)\n        external\n        returns (\n            uint reclaimed,\n            uint refunded,\n            uint numEntries\n        );\n\n    function resetLastExchangeRate(bytes32[] calldata currencyKeys) external;\n\n    function suspendSynthWithInvalidRate(bytes32 currencyKey) external;\n}\n\n\n// Inheritance\n\n\n// Libraries\n\n\n// Internal references\n// AggregatorInterface from Chainlink represents a decentralized pricing network for a single currency key\n\n// FlagsInterface from Chainlink addresses SIP-76\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerates\ncontract ExchangeRates is Owned, MixinSystemSettings, IExchangeRates {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRates\";\n    //slither-disable-next-line naming-convention\n    bytes32 internal constant sUSD = \"sUSD\";\n\n    // Decentralized oracle networks that feed into pricing aggregators\n    mapping(bytes32 => AggregatorV2V3Interface) public aggregators;\n\n    mapping(bytes32 => uint8) public currencyKeyDecimals;\n\n    // List of aggregator keys for convenient iteration\n    bytes32[] public aggregatorKeys;\n\n    // ========== CONSTRUCTOR ==========\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {}\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    function addAggregator(bytes32 currencyKey, address aggregatorAddress) external onlyOwner {\n        AggregatorV2V3Interface aggregator = AggregatorV2V3Interface(aggregatorAddress);\n        // This check tries to make sure that a valid aggregator is being added.\n        // It checks if the aggregator is an existing smart contract that has implemented `latestTimestamp` function.\n\n        require(aggregator.latestRound() >= 0, \"Given Aggregator is invalid\");\n        uint8 decimals = aggregator.decimals();\n        require(decimals <= 18, \"Aggregator decimals should be lower or equal to 18\");\n        if (address(aggregators[currencyKey]) == address(0)) {\n            aggregatorKeys.push(currencyKey);\n        }\n        aggregators[currencyKey] = aggregator;\n        currencyKeyDecimals[currencyKey] = decimals;\n        emit AggregatorAdded(currencyKey, address(aggregator));\n    }\n\n    function removeAggregator(bytes32 currencyKey) external onlyOwner {\n        address aggregator = address(aggregators[currencyKey]);\n        require(aggregator != address(0), \"No aggregator exists for key\");\n        delete aggregators[currencyKey];\n        delete currencyKeyDecimals[currencyKey];\n\n        bool wasRemoved = removeFromArray(currencyKey, aggregatorKeys);\n\n        if (wasRemoved) {\n            emit AggregatorRemoved(currencyKey, aggregator);\n        }\n    }\n\n    /* ========== VIEWS ========== */\n\n    function currenciesUsingAggregator(address aggregator) external view returns (bytes32[] memory currencies) {\n        uint count = 0;\n        currencies = new bytes32[](aggregatorKeys.length);\n        for (uint i = 0; i < aggregatorKeys.length; i++) {\n            bytes32 currencyKey = aggregatorKeys[i];\n            if (address(aggregators[currencyKey]) == aggregator) {\n                currencies[count++] = currencyKey;\n            }\n        }\n    }\n\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    function rateAndUpdatedTime(bytes32 currencyKey) external view returns (uint rate, uint time) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n        return (rateAndTime.rate, rateAndTime.time);\n    }\n\n    function getLastRoundIdBeforeElapsedSecs(\n        bytes32 currencyKey,\n        uint startingRoundId,\n        uint startingTimestamp,\n        uint timediff\n    ) external view returns (uint) {\n        uint roundId = startingRoundId;\n        uint nextTimestamp = 0;\n        while (true) {\n            (, nextTimestamp) = _getRateAndTimestampAtRound(currencyKey, roundId + 1);\n            // if there's no new round, then the previous roundId was the latest\n            if (nextTimestamp == 0 || nextTimestamp > startingTimestamp + timediff) {\n                return roundId;\n            }\n            roundId++;\n        }\n        return roundId;\n    }\n\n    function getCurrentRoundId(bytes32 currencyKey) external view returns (uint) {\n        return _getCurrentRoundId(currencyKey);\n    }\n\n    function effectiveValueAndRatesAtRound(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey,\n        uint roundIdForSrc,\n        uint roundIdForDest\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        (sourceRate, ) = _getRateAndTimestampAtRound(sourceCurrencyKey, roundIdForSrc);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            (destinationRate, ) = _getRateAndTimestampAtRound(destinationCurrencyKey, roundIdForDest);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                // Calculate the effective value by going from source -> USD -> destination\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function rateAndTimestampAtRound(bytes32 currencyKey, uint roundId) external view returns (uint rate, uint time) {\n        return _getRateAndTimestampAtRound(currencyKey, roundId);\n    }\n\n    function lastRateUpdateTimes(bytes32 currencyKey) external view returns (uint256) {\n        return _getUpdatedTime(currencyKey);\n    }\n\n    function lastRateUpdateTimesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory lastUpdateTimes = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            lastUpdateTimes[i] = _getUpdatedTime(currencyKeys[i]);\n        }\n\n        return lastUpdateTimes;\n    }\n\n    function effectiveValue(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    ) external view returns (uint value) {\n        (value, , ) = _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    function effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        return _effectiveValueAndRates(sourceCurrencyKey, sourceAmount, destinationCurrencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    function effectiveAtomicValueAndRates(\n        bytes32,\n        uint,\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint,\n            uint,\n            uint,\n            uint\n        )\n    {\n        _notImplemented();\n    }\n\n    function rateForCurrency(bytes32 currencyKey) external view returns (uint) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    /// @notice getting N rounds of rates for a currency at a specific round\n    /// @param currencyKey the currency key\n    /// @param numRounds the number of rounds to get\n    /// @param roundId the round id\n    /// @return a list of rates and a list of times\n    function ratesAndUpdatedTimeForCurrencyLastNRounds(\n        bytes32 currencyKey,\n        uint numRounds,\n        uint roundId\n    ) external view returns (uint[] memory rates, uint[] memory times) {\n        rates = new uint[](numRounds);\n        times = new uint[](numRounds);\n\n        roundId = roundId > 0 ? roundId : _getCurrentRoundId(currencyKey);\n        for (uint i = 0; i < numRounds; i++) {\n            // fetch the rate and treat is as current, so inverse limits if frozen will always be applied\n            // regardless of current rate\n            (rates[i], times[i]) = _getRateAndTimestampAtRound(currencyKey, roundId);\n\n            if (roundId == 0) {\n                // if we hit the last round, then return what we have\n                return (rates, times);\n            } else {\n                roundId--;\n            }\n        }\n    }\n\n    function ratesForCurrencies(bytes32[] calldata currencyKeys) external view returns (uint[] memory) {\n        uint[] memory _localRates = new uint[](currencyKeys.length);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            _localRates[i] = _getRate(currencyKeys[i]);\n        }\n\n        return _localRates;\n    }\n\n    function rateAndInvalid(bytes32 currencyKey) external view returns (uint rate, bool isInvalid) {\n        RateAndUpdatedTime memory rateAndTime = _getRateAndUpdatedTime(currencyKey);\n\n        if (currencyKey == sUSD) {\n            return (rateAndTime.rate, false);\n        }\n        return (\n            rateAndTime.rate,\n            _rateIsStaleWithTime(getRateStalePeriod(), rateAndTime.time) ||\n                _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()))\n        );\n    }\n\n    function ratesAndInvalidForCurrencies(bytes32[] calldata currencyKeys)\n        external\n        view\n        returns (uint[] memory rates, bool anyRateInvalid)\n    {\n        rates = new uint[](currencyKeys.length);\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n\n        // fetch all flags at once\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            // do one lookup of the rate & time to minimize gas\n            RateAndUpdatedTime memory rateEntry = _getRateAndUpdatedTime(currencyKeys[i]);\n            rates[i] = rateEntry.rate;\n            if (!anyRateInvalid && currencyKeys[i] != sUSD) {\n                anyRateInvalid = flagList[i] || _rateIsStaleWithTime(_rateStalePeriod, rateEntry.time);\n            }\n        }\n    }\n\n    function rateIsStale(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsStale(currencyKey, getRateStalePeriod());\n    }\n\n    function rateIsInvalid(bytes32 currencyKey) external view returns (bool) {\n        return\n            _rateIsStale(currencyKey, getRateStalePeriod()) ||\n            _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function rateIsFlagged(bytes32 currencyKey) external view returns (bool) {\n        return _rateIsFlagged(currencyKey, FlagsInterface(getAggregatorWarningFlags()));\n    }\n\n    function anyRateIsInvalid(bytes32[] calldata currencyKeys) external view returns (bool) {\n        // Loop through each key and check whether the data point is stale.\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStale(currencyKeys[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /// this method checks whether any rate is:\n    /// 1. flagged\n    /// 2. stale with respect to current time (now)\n    function anyRateIsInvalidAtRound(bytes32[] calldata currencyKeys, uint[] calldata roundIds)\n        external\n        view\n        returns (bool)\n    {\n        // Loop through each key and check whether the data point is stale.\n\n        require(roundIds.length == currencyKeys.length, \"roundIds must be the same length as currencyKeys\");\n\n        uint256 _rateStalePeriod = getRateStalePeriod();\n        bool[] memory flagList = getFlagsForRates(currencyKeys);\n\n        for (uint i = 0; i < currencyKeys.length; i++) {\n            if (flagList[i] || _rateIsStaleAtRound(currencyKeys[i], roundIds[i], _rateStalePeriod)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32) external view returns (bool) {\n        _notImplemented();\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function getFlagsForRates(bytes32[] memory currencyKeys) internal view returns (bool[] memory flagList) {\n        FlagsInterface _flags = FlagsInterface(getAggregatorWarningFlags());\n\n        // fetch all flags at once\n        if (_flags != FlagsInterface(0)) {\n            address[] memory _aggregators = new address[](currencyKeys.length);\n\n            for (uint i = 0; i < currencyKeys.length; i++) {\n                _aggregators[i] = address(aggregators[currencyKeys[i]]);\n            }\n\n            flagList = _flags.getFlags(_aggregators);\n        } else {\n            flagList = new bool[](currencyKeys.length);\n        }\n    }\n\n    function removeFromArray(bytes32 entry, bytes32[] storage array) internal returns (bool) {\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == entry) {\n                delete array[i];\n\n                // Copy the last key into the place of the one we just deleted\n                // If there's only one key, this is array[0] = array[0].\n                // If we're deleting the last one, it's also a NOOP in the same way.\n                array[i] = array[array.length - 1];\n\n                // Decrease the size of the array by one.\n                array.length--;\n\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function _formatAggregatorAnswer(bytes32 currencyKey, int256 rate) internal view returns (uint) {\n        require(rate >= 0, \"Negative rate not supported\");\n        if (currencyKeyDecimals[currencyKey] > 0) {\n            uint multiplier = 10**uint(SafeMath.sub(18, currencyKeyDecimals[currencyKey]));\n            return uint(uint(rate).mul(multiplier));\n        }\n        return uint(rate);\n    }\n\n    function _getRateAndUpdatedTime(bytes32 currencyKey) internal view returns (RateAndUpdatedTime memory) {\n        // sUSD rate is 1.0\n        if (currencyKey == sUSD) {\n            return RateAndUpdatedTime({rate: uint216(SafeDecimalMath.unit()), time: 0});\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"latestRoundData()\");\n                // solhint-disable avoid-low-level-calls\n                // slither-disable-next-line low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return\n                        RateAndUpdatedTime({\n                            rate: uint216(_formatAggregatorAnswer(currencyKey, answer)),\n                            time: uint40(updatedAt)\n                        });\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getCurrentRoundId(bytes32 currencyKey) internal view returns (uint) {\n        if (currencyKey == sUSD) {\n            return 0;\n        }\n        AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n        if (aggregator != AggregatorV2V3Interface(0)) {\n            return aggregator.latestRound();\n        } // else return defaults, to avoid reverting in views\n    }\n\n    function _getRateAndTimestampAtRound(bytes32 currencyKey, uint roundId) internal view returns (uint rate, uint time) {\n        // short circuit sUSD\n        if (currencyKey == sUSD) {\n            // sUSD has no rounds, and 0 time is preferrable for \"volatility\" heuristics\n            // which are used in atomic swaps and fee reclamation\n            return (SafeDecimalMath.unit(), 0);\n        } else {\n            AggregatorV2V3Interface aggregator = aggregators[currencyKey];\n            if (aggregator != AggregatorV2V3Interface(0)) {\n                // this view from the aggregator is the most gas efficient but it can throw when there's no data,\n                // so let's call it low-level to suppress any reverts\n                bytes memory payload = abi.encodeWithSignature(\"getRoundData(uint80)\", roundId);\n                // solhint-disable avoid-low-level-calls\n                (bool success, bytes memory returnData) = address(aggregator).staticcall(payload);\n\n                if (success) {\n                    (, int256 answer, , uint256 updatedAt, ) =\n                        abi.decode(returnData, (uint80, int256, uint256, uint256, uint80));\n                    return (_formatAggregatorAnswer(currencyKey, answer), updatedAt);\n                } // else return defaults, to avoid reverting in views\n            } // else return defaults, to avoid reverting in views\n        }\n    }\n\n    function _getRate(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).rate;\n    }\n\n    function _getUpdatedTime(bytes32 currencyKey) internal view returns (uint256) {\n        return _getRateAndUpdatedTime(currencyKey).time;\n    }\n\n    function _effectiveValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        internal\n        view\n        returns (\n            uint value,\n            uint sourceRate,\n            uint destinationRate\n        )\n    {\n        sourceRate = _getRate(sourceCurrencyKey);\n        // If there's no change in the currency, then just return the amount they gave us\n        if (sourceCurrencyKey == destinationCurrencyKey) {\n            destinationRate = sourceRate;\n            value = sourceAmount;\n        } else {\n            // Calculate the effective value by going from source -> USD -> destination\n            destinationRate = _getRate(destinationCurrencyKey);\n            // prevent divide-by 0 error (this happens if the dest is not a valid rate)\n            if (destinationRate > 0) {\n                value = sourceAmount.multiplyDecimalRound(sourceRate).divideDecimalRound(destinationRate);\n            }\n        }\n    }\n\n    function _rateIsStale(bytes32 currencyKey, uint _rateStalePeriod) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        return _rateIsStaleWithTime(_rateStalePeriod, _getUpdatedTime(currencyKey));\n    }\n\n    function _rateIsStaleAtRound(\n        bytes32 currencyKey,\n        uint roundId,\n        uint _rateStalePeriod\n    ) internal view returns (bool) {\n        // sUSD is a special case and is never stale (check before an SLOAD of getRateAndUpdatedTime)\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        (, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n        return _rateIsStaleWithTime(_rateStalePeriod, time);\n    }\n\n    function _rateIsStaleWithTime(uint _rateStalePeriod, uint _time) internal view returns (bool) {\n        return _time.add(_rateStalePeriod) < now;\n    }\n\n    function _rateIsFlagged(bytes32 currencyKey, FlagsInterface flags) internal view returns (bool) {\n        // sUSD is a special case and is never invalid\n        if (currencyKey == sUSD) {\n            return false;\n        }\n        address aggregator = address(aggregators[currencyKey]);\n        // when no aggregator or when the flags haven't been setup\n        if (aggregator == address(0) || flags == FlagsInterface(0)) {\n            return false;\n        }\n        return flags.getFlag(aggregator);\n    }\n\n    function _notImplemented() internal pure {\n        // slither-disable-next-line dead-code\n        revert(\"Cannot be run on this layer\");\n    }\n\n    /* ========== EVENTS ========== */\n\n    event AggregatorAdded(bytes32 currencyKey, address aggregator);\n    event AggregatorRemoved(bytes32 currencyKey, address aggregator);\n}\n\n\n// https://sips.synthetix.io/sips/sip-120/\n// Uniswap V3 based DecPriceAggregator (unaudited) e.g. https://etherscan.io/address/0xf120f029ac143633d1942e48ae2dfa2036c5786c#code\n// https://github.com/sohkai/uniswap-v3-spot-twap-oracle\n//  inteface: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/interfaces/IDexPriceAggregator.sol\n//  implementation: https://github.com/sohkai/uniswap-v3-spot-twap-oracle/blob/8f9777a6160a089c99f39f2ee297119ee293bc4b/contracts/DexPriceAggregatorUniswapV3.sol\ninterface IDexPriceAggregator {\n    function assetToAsset(\n        address tokenIn,\n        uint amountIn,\n        address tokenOut,\n        uint twapPeriod\n    ) external view returns (uint amountOut);\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/exchangerateswithdexpricing\ncontract ExchangeRatesWithDexPricing is ExchangeRates {\n    bytes32 public constant CONTRACT_NAME = \"ExchangeRatesWithDexPricing\";\n\n    bytes32 internal constant SETTING_DEX_PRICE_AGGREGATOR = \"dexPriceAggregator\";\n\n    constructor(address _owner, address _resolver) public ExchangeRates(_owner, _resolver) {}\n\n    /* ========== SETTERS ========== */\n\n    function setDexPriceAggregator(IDexPriceAggregator _dexPriceAggregator) external onlyOwner {\n        flexibleStorage().setAddressValue(\n            ExchangeRates.CONTRACT_NAME,\n            SETTING_DEX_PRICE_AGGREGATOR,\n            address(_dexPriceAggregator)\n        );\n        emit DexPriceAggregatorUpdated(address(_dexPriceAggregator));\n    }\n\n    /* ========== VIEWS ========== */\n\n    function dexPriceAggregator() public view returns (IDexPriceAggregator) {\n        return\n            IDexPriceAggregator(\n                flexibleStorage().getAddressValue(ExchangeRates.CONTRACT_NAME, SETTING_DEX_PRICE_AGGREGATOR)\n            );\n    }\n\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicPriceBuffer(currencyKey);\n    }\n\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // Note that the returned systemValue, systemSourceRate, and systemDestinationRate are based on\n    // the current system rate, which may not be the atomic rate derived from value / sourceAmount\n    function effectiveAtomicValueAndRates(\n        bytes32 sourceCurrencyKey,\n        uint sourceAmount,\n        bytes32 destinationCurrencyKey\n    )\n        external\n        view\n        returns (\n            uint value,\n            uint systemValue,\n            uint systemSourceRate,\n            uint systemDestinationRate\n        )\n    {\n        IERC20 sourceEquivalent = IERC20(getAtomicEquivalentForDexPricing(sourceCurrencyKey));\n        require(address(sourceEquivalent) != address(0), \"No atomic equivalent for src\");\n\n        IERC20 destEquivalent = IERC20(getAtomicEquivalentForDexPricing(destinationCurrencyKey));\n        require(address(destEquivalent) != address(0), \"No atomic equivalent for dest\");\n\n        (systemValue, systemSourceRate, systemDestinationRate) = _effectiveValueAndRates(\n            sourceCurrencyKey,\n            sourceAmount,\n            destinationCurrencyKey\n        );\n        // Derive P_CLBUF from highest configured buffer between source and destination synth\n        uint sourceBuffer = getAtomicPriceBuffer(sourceCurrencyKey);\n        uint destBuffer = getAtomicPriceBuffer(destinationCurrencyKey);\n        uint priceBuffer = sourceBuffer > destBuffer ? sourceBuffer : destBuffer; // max\n        uint pClbufValue = systemValue.multiplyDecimal(SafeDecimalMath.unit().sub(priceBuffer));\n\n        // refactired due to stack too deep\n        uint pDexValue = _dexPriceDestinationValue(sourceEquivalent, destEquivalent, sourceAmount);\n\n        // Final value is minimum output between P_CLBUF and P_TWAP\n        value = pClbufValue < pDexValue ? pClbufValue : pDexValue; // min\n    }\n\n    function _dexPriceDestinationValue(\n        IERC20 sourceEquivalent,\n        IERC20 destEquivalent,\n        uint sourceAmount\n    ) internal view returns (uint) {\n        // Normalize decimals in case equivalent asset uses different decimals from internal unit\n        uint sourceAmountInEquivalent =\n            (sourceAmount.mul(10**uint(sourceEquivalent.decimals()))).div(SafeDecimalMath.unit());\n\n        uint twapWindow = getAtomicTwapWindow();\n        require(twapWindow != 0, \"Uninitialized atomic twap window\");\n\n        uint twapValueInEquivalent =\n            dexPriceAggregator().assetToAsset(\n                address(sourceEquivalent),\n                sourceAmountInEquivalent,\n                address(destEquivalent),\n                twapWindow\n            );\n        require(twapValueInEquivalent > 0, \"dex price returned 0\");\n\n        // Similar to source amount, normalize decimals back to internal unit for output amount\n        return (twapValueInEquivalent.mul(SafeDecimalMath.unit())).div(10**uint(destEquivalent.decimals()));\n    }\n\n    function synthTooVolatileForAtomicExchange(bytes32 currencyKey) external view returns (bool) {\n        // sUSD is a special case and is never volatile\n        if (currencyKey == \"sUSD\") return false;\n\n        uint considerationWindow = getAtomicVolatilityConsiderationWindow(currencyKey);\n        uint updateThreshold = getAtomicVolatilityUpdateThreshold(currencyKey);\n\n        if (considerationWindow == 0 || updateThreshold == 0) {\n            // If either volatility setting is not set, never judge an asset to be volatile\n            return false;\n        }\n\n        // Go back through the historical oracle update rounds to see if there have been more\n        // updates in the consideration window than the allowed threshold.\n        // If there have, consider the asset volatile--by assumption that many close-by oracle\n        // updates is a good proxy for price volatility.\n        uint considerationWindowStart = block.timestamp.sub(considerationWindow);\n        uint roundId = _getCurrentRoundId(currencyKey);\n        for (updateThreshold; updateThreshold > 0; updateThreshold--) {\n            (uint rate, uint time) = _getRateAndTimestampAtRound(currencyKey, roundId);\n            if (time != 0 && time < considerationWindowStart) {\n                // Round was outside consideration window so we can stop querying further rounds\n                return false;\n            } else if (rate == 0 || time == 0) {\n                // Either entire round or a rate inside consideration window was not available\n                // Consider the asset volatile\n                break;\n            }\n\n            if (roundId == 0) {\n                // Not enough historical data to continue further\n                // Consider the asset volatile\n                break;\n            }\n            roundId--;\n        }\n\n        return true;\n    }\n\n    /* ========== EVENTS ========== */\n\n    event DexPriceAggregatorUpdated(address newDexPriceAggregator);\n}\n\n\n// https://docs.synthetix.io/contracts/source/interfaces/isystemsettings\ninterface ISystemSettings {\n    // Views\n    function waitingPeriodSecs() external view returns (uint);\n\n    function priceDeviationThresholdFactor() external view returns (uint);\n\n    function issuanceRatio() external view returns (uint);\n\n    function feePeriodDuration() external view returns (uint);\n\n    function targetThreshold() external view returns (uint);\n\n    function liquidationDelay() external view returns (uint);\n\n    function liquidationRatio() external view returns (uint);\n\n    function liquidationPenalty() external view returns (uint);\n\n    function rateStalePeriod() external view returns (uint);\n\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint);\n\n    function minimumStakeTime() external view returns (uint);\n\n    function debtSnapshotStaleTime() external view returns (uint);\n\n    function aggregatorWarningFlags() external view returns (address);\n\n    function tradingRewardsEnabled() external view returns (bool);\n\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint);\n\n    function wrapperMintFeeRate(address wrapper) external view returns (int);\n\n    function wrapperBurnFeeRate(address wrapper) external view returns (int);\n\n    function etherWrapperMaxETH() external view returns (uint);\n\n    function etherWrapperMintFeeRate() external view returns (uint);\n\n    function etherWrapperBurnFeeRate() external view returns (uint);\n\n    function interactionDelay(address collateral) external view returns (uint);\n\n    function atomicMaxVolumePerBlock() external view returns (uint);\n\n    function atomicTwapWindow() external view returns (uint);\n\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address);\n\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint);\n\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint);\n\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint);\n\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint);\n}\n\n\n// Internal references\n\n\n// Libraries\n\n\n/// This library is to reduce SystemSettings contract size only and is not really\n/// a proper library - so it shares knowledge of implementation details\n/// Some of the setters were refactored into this library, and some setters remain in the\n/// contract itself (SystemSettings)\nlibrary SystemSettingsLib {\n    using SafeMath for uint;\n    using SafeDecimalMath for uint;\n\n    bytes32 public constant SETTINGS_CONTRACT_NAME = \"SystemSettings\";\n\n    // No more synths may be issued than the value of SNX backing them.\n    uint public constant MAX_ISSUANCE_RATIO = 1e18;\n\n    // The fee period must be between 1 day and 60 days.\n    uint public constant MIN_FEE_PERIOD_DURATION = 1 days;\n    uint public constant MAX_FEE_PERIOD_DURATION = 60 days;\n\n    uint public constant MAX_TARGET_THRESHOLD = 50;\n\n    uint public constant MAX_LIQUIDATION_RATIO = 1e18; // 100% issuance ratio\n    uint public constant RATIO_FROM_TARGET_BUFFER = 2e18; // 200% - mininimum buffer between issuance ratio and liquidation ratio\n\n    uint public constant MAX_LIQUIDATION_PENALTY = 1e18 / 4; // Max 25% liquidation penalty / bonus\n\n    uint public constant MAX_LIQUIDATION_DELAY = 30 days;\n    uint public constant MIN_LIQUIDATION_DELAY = 1 days;\n\n    // Exchange fee may not exceed 10%.\n    uint public constant MAX_EXCHANGE_FEE_RATE = 1e18 / 10;\n\n    // Minimum Stake time may not exceed 1 weeks.\n    uint public constant MAX_MINIMUM_STAKE_TIME = 1 weeks;\n\n    uint public constant MAX_CROSS_DOMAIN_GAS_LIMIT = 8e6;\n    uint public constant MIN_CROSS_DOMAIN_GAS_LIMIT = 3e6;\n\n    int public constant MAX_WRAPPER_MINT_FEE_RATE = 1e18;\n\n    int public constant MAX_WRAPPER_BURN_FEE_RATE = 1e18;\n\n    // Atomic block volume limit is encoded as uint192.\n    uint public constant MAX_ATOMIC_VOLUME_PER_BLOCK = uint192(-1);\n\n    // TWAP window must be between 1 min and 1 day.\n    uint public constant MIN_ATOMIC_TWAP_WINDOW = 60;\n    uint public constant MAX_ATOMIC_TWAP_WINDOW = 86400;\n\n    // Volatility consideration window must be between 1 min and 1 day.\n    uint public constant MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 60;\n    uint public constant MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW = 86400;\n\n    // workaround for library not supporting public constants in sol v0.5\n    function contractName() external view returns (bytes32) {\n        return SETTINGS_CONTRACT_NAME;\n    }\n\n    function setCrossDomainMessageGasLimit(\n        IFlexibleStorage flexibleStorage,\n        bytes32 gasLimitSettings,\n        uint crossDomainMessageGasLimit\n    ) external {\n        require(\n            crossDomainMessageGasLimit >= MIN_CROSS_DOMAIN_GAS_LIMIT &&\n                crossDomainMessageGasLimit <= MAX_CROSS_DOMAIN_GAS_LIMIT,\n            \"Out of range xDomain gasLimit\"\n        );\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, gasLimitSettings, crossDomainMessageGasLimit);\n    }\n\n    function setIssuanceRatio(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint ratio\n    ) external {\n        require(ratio <= MAX_ISSUANCE_RATIO, \"New issuance ratio cannot exceed MAX_ISSUANCE_RATIO\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, ratio);\n    }\n\n    function setTradingRewardsEnabled(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bool _tradingRewardsEnabled\n    ) external {\n        flexibleStorage.setBoolValue(SETTINGS_CONTRACT_NAME, settingName, _tradingRewardsEnabled);\n    }\n\n    function setWaitingPeriodSecs(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _waitingPeriodSecs\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _waitingPeriodSecs);\n    }\n\n    function setPriceDeviationThresholdFactor(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _priceDeviationThresholdFactor\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _priceDeviationThresholdFactor);\n    }\n\n    function setFeePeriodDuration(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _feePeriodDuration\n    ) external {\n        require(_feePeriodDuration >= MIN_FEE_PERIOD_DURATION, \"value < MIN_FEE_PERIOD_DURATION\");\n        require(_feePeriodDuration <= MAX_FEE_PERIOD_DURATION, \"value > MAX_FEE_PERIOD_DURATION\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _feePeriodDuration);\n    }\n\n    function setTargetThreshold(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint percent\n    ) external returns (uint threshold) {\n        require(percent <= MAX_TARGET_THRESHOLD, \"Threshold too high\");\n        threshold = percent.mul(SafeDecimalMath.unit()).div(100);\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, threshold);\n    }\n\n    function setLiquidationDelay(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint time\n    ) external {\n        require(time <= MAX_LIQUIDATION_DELAY, \"Must be less than 30 days\");\n        require(time >= MIN_LIQUIDATION_DELAY, \"Must be greater than 1 day\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, time);\n    }\n\n    function setLiquidationRatio(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _liquidationRatio,\n        uint getLiquidationPenalty,\n        uint getIssuanceRatio\n    ) external {\n        require(\n            _liquidationRatio <= MAX_LIQUIDATION_RATIO.divideDecimal(SafeDecimalMath.unit().add(getLiquidationPenalty)),\n            \"liquidationRatio > MAX_LIQUIDATION_RATIO / (1 + penalty)\"\n        );\n\n        // MIN_LIQUIDATION_RATIO is a product of target issuance ratio * RATIO_FROM_TARGET_BUFFER\n        // Ensures that liquidation ratio is set so that there is a buffer between the issuance ratio and liquidation ratio.\n        uint MIN_LIQUIDATION_RATIO = getIssuanceRatio.multiplyDecimal(RATIO_FROM_TARGET_BUFFER);\n        require(_liquidationRatio >= MIN_LIQUIDATION_RATIO, \"liquidationRatio < MIN_LIQUIDATION_RATIO\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _liquidationRatio);\n    }\n\n    function setLiquidationPenalty(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint penalty\n    ) external {\n        require(penalty <= MAX_LIQUIDATION_PENALTY, \"penalty > MAX_LIQUIDATION_PENALTY\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, penalty);\n    }\n\n    function setRateStalePeriod(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint period\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, period);\n    }\n\n    function setExchangeFeeRateForSynths(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingExchangeFeeRate,\n        bytes32[] calldata synthKeys,\n        uint256[] calldata exchangeFeeRates\n    ) external {\n        require(synthKeys.length == exchangeFeeRates.length, \"Array lengths dont match\");\n        for (uint i = 0; i < synthKeys.length; i++) {\n            require(exchangeFeeRates[i] <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n            flexibleStorage.setUIntValue(\n                SETTINGS_CONTRACT_NAME,\n                keccak256(abi.encodePacked(settingExchangeFeeRate, synthKeys[i])),\n                exchangeFeeRates[i]\n            );\n        }\n    }\n\n    function setMinimumStakeTime(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _seconds\n    ) external {\n        require(_seconds <= MAX_MINIMUM_STAKE_TIME, \"stake time exceed maximum 1 week\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);\n    }\n\n    function setDebtSnapshotStaleTime(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _seconds\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _seconds);\n    }\n\n    function setAggregatorWarningFlags(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _flags\n    ) external {\n        require(_flags != address(0), \"Valid address must be given\");\n        flexibleStorage.setAddressValue(SETTINGS_CONTRACT_NAME, settingName, _flags);\n    }\n\n    function setEtherWrapperMaxETH(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _maxETH\n    ) external {\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxETH);\n    }\n\n    function setEtherWrapperMintFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _rate\n    ) external {\n        require(_rate <= uint(MAX_WRAPPER_MINT_FEE_RATE), \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _rate);\n    }\n\n    function setEtherWrapperBurnFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _rate\n    ) external {\n        require(_rate <= uint(MAX_WRAPPER_BURN_FEE_RATE), \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _rate);\n    }\n\n    function setWrapperMaxTokenAmount(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        uint _maxTokenAmount\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _wrapper)),\n            _maxTokenAmount\n        );\n    }\n\n    function setWrapperMintFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        int _rate,\n        int getWrapperBurnFeeRate\n    ) external {\n        require(_rate <= MAX_WRAPPER_MINT_FEE_RATE, \"rate > MAX_WRAPPER_MINT_FEE_RATE\");\n        require(_rate >= -MAX_WRAPPER_MINT_FEE_RATE, \"rate < -MAX_WRAPPER_MINT_FEE_RATE\");\n\n        // if mint rate is negative, burn fee rate should be positive and at least equal in magnitude\n        // otherwise risk of flash loan attack\n        if (_rate < 0) {\n            require(-_rate <= getWrapperBurnFeeRate, \"-rate > wrapperBurnFeeRate\");\n        }\n\n        flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _wrapper)), _rate);\n    }\n\n    function setWrapperBurnFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _wrapper,\n        int _rate,\n        int getWrapperMintFeeRate\n    ) external {\n        require(_rate <= MAX_WRAPPER_BURN_FEE_RATE, \"rate > MAX_WRAPPER_BURN_FEE_RATE\");\n        require(_rate >= -MAX_WRAPPER_BURN_FEE_RATE, \"rate < -MAX_WRAPPER_BURN_FEE_RATE\");\n\n        // if burn rate is negative, burn fee rate should be negative and at least equal in magnitude\n        // otherwise risk of flash loan attack\n        if (_rate < 0) {\n            require(-_rate <= getWrapperMintFeeRate, \"-rate > wrapperMintFeeRate\");\n        }\n\n        flexibleStorage.setIntValue(SETTINGS_CONTRACT_NAME, keccak256(abi.encodePacked(settingName, _wrapper)), _rate);\n    }\n\n    function setInteractionDelay(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _collateral,\n        uint _interactionDelay\n    ) external {\n        require(_interactionDelay <= SafeDecimalMath.unit() * 3600, \"Max 1 hour\");\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _collateral)),\n            _interactionDelay\n        );\n    }\n\n    function setCollapseFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        address _collateral,\n        uint _collapseFeeRate\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _collateral)),\n            _collapseFeeRate\n        );\n    }\n\n    function setAtomicMaxVolumePerBlock(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _maxVolume\n    ) external {\n        require(_maxVolume <= MAX_ATOMIC_VOLUME_PER_BLOCK, \"Atomic max volume exceed maximum uint192\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _maxVolume);\n    }\n\n    function setAtomicTwapWindow(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint _window\n    ) external {\n        require(_window >= MIN_ATOMIC_TWAP_WINDOW, \"Atomic twap window under minimum 1 min\");\n        require(_window <= MAX_ATOMIC_TWAP_WINDOW, \"Atomic twap window exceed maximum 1 day\");\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, _window);\n    }\n\n    function setAtomicEquivalentForDexPricing(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        address _equivalent\n    ) external {\n        require(_equivalent != address(0), \"Atomic equivalent is 0 address\");\n        flexibleStorage.setAddressValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _equivalent\n        );\n    }\n\n    function setAtomicExchangeFeeRate(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _exchangeFeeRate\n    ) external {\n        require(_exchangeFeeRate <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _exchangeFeeRate\n        );\n    }\n\n    function setAtomicPriceBuffer(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _buffer\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _buffer\n        );\n    }\n\n    function setAtomicVolatilityConsiderationWindow(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _window\n    ) external {\n        if (_window != 0) {\n            require(\n                _window >= MIN_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n                \"Atomic volatility consideration window under minimum 1 min\"\n            );\n            require(\n                _window <= MAX_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n                \"Atomic volatility consideration window exceed maximum 1 day\"\n            );\n        }\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _window\n        );\n    }\n\n    function setAtomicVolatilityUpdateThreshold(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        bytes32 _currencyKey,\n        uint _threshold\n    ) external {\n        flexibleStorage.setUIntValue(\n            SETTINGS_CONTRACT_NAME,\n            keccak256(abi.encodePacked(settingName, _currencyKey)),\n            _threshold\n        );\n    }\n\n    function setExchangeMaxDynamicFee(\n        IFlexibleStorage flexibleStorage,\n        bytes32 settingName,\n        uint maxFee\n    ) external {\n        require(maxFee != 0, \"Max dynamic fee cannot be 0\");\n        require(maxFee <= MAX_EXCHANGE_FEE_RATE, \"MAX_EXCHANGE_FEE_RATE exceeded\");\n\n        flexibleStorage.setUIntValue(SETTINGS_CONTRACT_NAME, settingName, maxFee);\n    }\n}\n\n\n// Inheritance\n\n\n// https://docs.synthetix.io/contracts/source/contracts/systemsettings\ncontract SystemSettings is Owned, MixinSystemSettings, ISystemSettings {\n    // SystemSettingsLib is a way to split out the setters to reduce contract size\n    using SystemSettingsLib for IFlexibleStorage;\n\n    constructor(address _owner, address _resolver) public Owned(_owner) MixinSystemSettings(_resolver) {\n        // SETTING_CONTRACT_NAME is defined for the getters in MixinSystemSettings and\n        // SystemSettingsLib.contractName() is a view into SystemSettingsLib of the contract name\n        // that's used by the setters. They have to be equal.\n        require(SETTING_CONTRACT_NAME == SystemSettingsLib.contractName(), \"read and write keys not equal\");\n    }\n\n    // ========== VIEWS ==========\n\n    // backwards compatibility to having CONTRACT_NAME public constant\n    // solhint-disable-next-line func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32) {\n        return SystemSettingsLib.contractName();\n    }\n\n    // SIP-37 Fee Reclamation\n    // The number of seconds after an exchange is executed that must be waited\n    // before settlement.\n    function waitingPeriodSecs() external view returns (uint) {\n        return getWaitingPeriodSecs();\n    }\n\n    // SIP-65 Decentralized Circuit Breaker\n    // The factor amount expressed in decimal format\n    // E.g. 3e18 = factor 3, meaning movement up to 3x and above or down to 1/3x and below\n    function priceDeviationThresholdFactor() external view returns (uint) {\n        return getPriceDeviationThresholdFactor();\n    }\n\n    // The raio of collateral\n    // Expressed in 18 decimals. So 800% cratio is 100/800 = 0.125 (0.125e18)\n    function issuanceRatio() external view returns (uint) {\n        return getIssuanceRatio();\n    }\n\n    // How long a fee period lasts at a minimum. It is required for\n    // anyone to roll over the periods, so they are not guaranteed\n    // to roll over at exactly this duration, but the contract enforces\n    // that they cannot roll over any quicker than this duration.\n    function feePeriodDuration() external view returns (uint) {\n        return getFeePeriodDuration();\n    }\n\n    // Users are unable to claim fees if their collateralisation ratio drifts out of target threshold\n    function targetThreshold() external view returns (uint) {\n        return getTargetThreshold();\n    }\n\n    // SIP-15 Liquidations\n    // liquidation time delay after address flagged (seconds)\n    function liquidationDelay() external view returns (uint) {\n        return getLiquidationDelay();\n    }\n\n    // SIP-15 Liquidations\n    // issuance ratio when account can be flagged for liquidation (with 18 decimals), e.g 0.5 issuance ratio\n    // when flag means 1/0.5 = 200% cratio\n    function liquidationRatio() external view returns (uint) {\n        return getLiquidationRatio();\n    }\n\n    // SIP-15 Liquidations\n    // penalty taken away from target of liquidation (with 18 decimals). E.g. 10% is 0.1e18\n    function liquidationPenalty() external view returns (uint) {\n        return getLiquidationPenalty();\n    }\n\n    // How long will the ExchangeRates contract assume the rate of any asset is correct\n    function rateStalePeriod() external view returns (uint) {\n        return getRateStalePeriod();\n    }\n\n    /* ========== Exchange Related Fees ========== */\n    function exchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-184 Dynamic Fee\n    /// @notice Get the dynamic fee threshold\n    /// @return The dynamic fee threshold\n    function exchangeDynamicFeeThreshold() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().threshold;\n    }\n\n    /// @notice Get the dynamic fee weight decay per round\n    /// @return The dynamic fee weight decay per round\n    function exchangeDynamicFeeWeightDecay() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().weightDecay;\n    }\n\n    /// @notice Get the dynamic fee total rounds for calculation\n    /// @return The dynamic fee total rounds for calculation\n    function exchangeDynamicFeeRounds() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().rounds;\n    }\n\n    /// @notice Get the max dynamic fee\n    /// @return The max dynamic fee\n    function exchangeMaxDynamicFee() external view returns (uint) {\n        return getExchangeDynamicFeeConfig().maxFee;\n    }\n\n    /* ========== End Exchange Related Fees ========== */\n\n    function minimumStakeTime() external view returns (uint) {\n        return getMinimumStakeTime();\n    }\n\n    function debtSnapshotStaleTime() external view returns (uint) {\n        return getDebtSnapshotStaleTime();\n    }\n\n    function aggregatorWarningFlags() external view returns (address) {\n        return getAggregatorWarningFlags();\n    }\n\n    // SIP-63 Trading incentives\n    // determines if Exchanger records fee entries in TradingRewards\n    function tradingRewardsEnabled() external view returns (bool) {\n        return getTradingRewardsEnabled();\n    }\n\n    function crossDomainMessageGasLimit(CrossDomainMessageGasLimits gasLimitType) external view returns (uint) {\n        return getCrossDomainMessageGasLimit(gasLimitType);\n    }\n\n    // SIP 112: ETH Wrappr\n    // The maximum amount of ETH held by the EtherWrapper.\n    function etherWrapperMaxETH() external view returns (uint) {\n        return getEtherWrapperMaxETH();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for depositing ETH into the EtherWrapper.\n    function etherWrapperMintFeeRate() external view returns (uint) {\n        return getEtherWrapperMintFeeRate();\n    }\n\n    // SIP 112: ETH Wrappr\n    // The fee for burning sETH and releasing ETH from the EtherWrapper.\n    function etherWrapperBurnFeeRate() external view returns (uint) {\n        return getEtherWrapperBurnFeeRate();\n    }\n\n    // SIP 182: Wrapper Factory\n    // The maximum amount of token held by the Wrapper.\n    function wrapperMaxTokenAmount(address wrapper) external view returns (uint) {\n        return getWrapperMaxTokenAmount(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for depositing token into the Wrapper.\n    function wrapperMintFeeRate(address wrapper) external view returns (int) {\n        return getWrapperMintFeeRate(wrapper);\n    }\n\n    // SIP 182: Wrapper Factory\n    // The fee for burning synth and releasing token from the Wrapper.\n    function wrapperBurnFeeRate(address wrapper) external view returns (int) {\n        return getWrapperBurnFeeRate(wrapper);\n    }\n\n    function interactionDelay(address collateral) external view returns (uint) {\n        return getInteractionDelay(collateral);\n    }\n\n    function collapseFeeRate(address collateral) external view returns (uint) {\n        return getCollapseFeeRate(collateral);\n    }\n\n    // SIP-120 Atomic exchanges\n    // max allowed volume per block for atomic exchanges\n    function atomicMaxVolumePerBlock() external view returns (uint) {\n        return getAtomicMaxVolumePerBlock();\n    }\n\n    // SIP-120 Atomic exchanges\n    // time window (in seconds) for TWAP prices when considered for atomic exchanges\n    function atomicTwapWindow() external view returns (uint) {\n        return getAtomicTwapWindow();\n    }\n\n    // SIP-120 Atomic exchanges\n    // equivalent asset to use for a synth when considering external prices for atomic exchanges\n    function atomicEquivalentForDexPricing(bytes32 currencyKey) external view returns (address) {\n        return getAtomicEquivalentForDexPricing(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // fee rate override for atomic exchanges into a synth\n    function atomicExchangeFeeRate(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicExchangeFeeRate(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // price dampener for chainlink prices when considered for atomic exchanges\n    function atomicPriceBuffer(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicPriceBuffer(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // consideration window for determining synth volatility\n    function atomicVolatilityConsiderationWindow(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityConsiderationWindow(currencyKey);\n    }\n\n    // SIP-120 Atomic exchanges\n    // update threshold for determining synth volatility\n    function atomicVolatilityUpdateThreshold(bytes32 currencyKey) external view returns (uint) {\n        return getAtomicVolatilityUpdateThreshold(currencyKey);\n    }\n\n    // ========== RESTRICTED ==========\n\n    function setCrossDomainMessageGasLimit(CrossDomainMessageGasLimits _gasLimitType, uint _crossDomainMessageGasLimit)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setCrossDomainMessageGasLimit(_getGasLimitSetting(_gasLimitType), _crossDomainMessageGasLimit);\n        emit CrossDomainMessageGasLimitChanged(_gasLimitType, _crossDomainMessageGasLimit);\n    }\n\n    function setIssuanceRatio(uint ratio) external onlyOwner {\n        flexibleStorage().setIssuanceRatio(SETTING_ISSUANCE_RATIO, ratio);\n        emit IssuanceRatioUpdated(ratio);\n    }\n\n    function setTradingRewardsEnabled(bool _tradingRewardsEnabled) external onlyOwner {\n        flexibleStorage().setTradingRewardsEnabled(SETTING_TRADING_REWARDS_ENABLED, _tradingRewardsEnabled);\n        emit TradingRewardsEnabled(_tradingRewardsEnabled);\n    }\n\n    function setWaitingPeriodSecs(uint _waitingPeriodSecs) external onlyOwner {\n        flexibleStorage().setWaitingPeriodSecs(SETTING_WAITING_PERIOD_SECS, _waitingPeriodSecs);\n        emit WaitingPeriodSecsUpdated(_waitingPeriodSecs);\n    }\n\n    function setPriceDeviationThresholdFactor(uint _priceDeviationThresholdFactor) external onlyOwner {\n        flexibleStorage().setPriceDeviationThresholdFactor(\n            SETTING_PRICE_DEVIATION_THRESHOLD_FACTOR,\n            _priceDeviationThresholdFactor\n        );\n        emit PriceDeviationThresholdUpdated(_priceDeviationThresholdFactor);\n    }\n\n    function setFeePeriodDuration(uint _feePeriodDuration) external onlyOwner {\n        flexibleStorage().setFeePeriodDuration(SETTING_FEE_PERIOD_DURATION, _feePeriodDuration);\n        emit FeePeriodDurationUpdated(_feePeriodDuration);\n    }\n\n    function setTargetThreshold(uint percent) external onlyOwner {\n        uint threshold = flexibleStorage().setTargetThreshold(SETTING_TARGET_THRESHOLD, percent);\n        emit TargetThresholdUpdated(threshold);\n    }\n\n    function setLiquidationDelay(uint time) external onlyOwner {\n        flexibleStorage().setLiquidationDelay(SETTING_LIQUIDATION_DELAY, time);\n        emit LiquidationDelayUpdated(time);\n    }\n\n    // The collateral / issuance ratio ( debt / collateral ) is higher when there is less collateral backing their debt\n    // Upper bound liquidationRatio is 1 + penalty (100% + 10% = 110%) to allow collateral value to cover debt and liquidation penalty\n    function setLiquidationRatio(uint _liquidationRatio) external onlyOwner {\n        flexibleStorage().setLiquidationRatio(\n            SETTING_LIQUIDATION_RATIO,\n            _liquidationRatio,\n            getLiquidationPenalty(),\n            getIssuanceRatio()\n        );\n        emit LiquidationRatioUpdated(_liquidationRatio);\n    }\n\n    function setLiquidationPenalty(uint penalty) external onlyOwner {\n        flexibleStorage().setLiquidationPenalty(SETTING_LIQUIDATION_PENALTY, penalty);\n        emit LiquidationPenaltyUpdated(penalty);\n    }\n\n    function setRateStalePeriod(uint period) external onlyOwner {\n        flexibleStorage().setRateStalePeriod(SETTING_RATE_STALE_PERIOD, period);\n        emit RateStalePeriodUpdated(period);\n    }\n\n    /* ========== Exchange Fees Related ========== */\n    function setExchangeFeeRateForSynths(bytes32[] calldata synthKeys, uint256[] calldata exchangeFeeRates)\n        external\n        onlyOwner\n    {\n        flexibleStorage().setExchangeFeeRateForSynths(SETTING_EXCHANGE_FEE_RATE, synthKeys, exchangeFeeRates);\n        for (uint i = 0; i < synthKeys.length; i++) {\n            emit ExchangeFeeUpdated(synthKeys[i], exchangeFeeRates[i]);\n        }\n    }\n\n    /// @notice Set exchange dynamic fee threshold constant in decimal ratio\n    /// @param threshold The exchange dynamic fee threshold\n    /// @return uint threshold constant\n    function setExchangeDynamicFeeThreshold(uint threshold) external onlyOwner {\n        require(threshold != 0, \"Threshold cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_THRESHOLD, threshold);\n\n        emit ExchangeDynamicFeeThresholdUpdated(threshold);\n    }\n\n    /// @notice Set exchange dynamic fee weight decay constant\n    /// @param weightDecay The exchange dynamic fee weight decay\n    /// @return uint weight decay constant\n    function setExchangeDynamicFeeWeightDecay(uint weightDecay) external onlyOwner {\n        require(weightDecay != 0, \"Weight decay cannot be 0\");\n\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_WEIGHT_DECAY, weightDecay);\n\n        emit ExchangeDynamicFeeWeightDecayUpdated(weightDecay);\n    }\n\n    /// @notice Set exchange dynamic fee last N rounds with minimum 2 rounds\n    /// @param rounds The exchange dynamic fee last N rounds\n    /// @return uint dynamic fee last N rounds\n    function setExchangeDynamicFeeRounds(uint rounds) external onlyOwner {\n        flexibleStorage().setUIntValue(SETTING_CONTRACT_NAME, SETTING_EXCHANGE_DYNAMIC_FEE_ROUNDS, rounds);\n\n        emit ExchangeDynamicFeeRoundsUpdated(rounds);\n    }\n\n    /// @notice Set max exchange dynamic fee\n    /// @param maxFee The max exchange dynamic fee\n    /// @return uint dynamic fee last N rounds\n    function setExchangeMaxDynamicFee(uint maxFee) external onlyOwner {\n        flexibleStorage().setExchangeMaxDynamicFee(SETTING_EXCHANGE_MAX_DYNAMIC_FEE, maxFee);\n        emit ExchangeMaxDynamicFeeUpdated(maxFee);\n    }\n\n    function setMinimumStakeTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setMinimumStakeTime(SETTING_MINIMUM_STAKE_TIME, _seconds);\n        emit MinimumStakeTimeUpdated(_seconds);\n    }\n\n    function setDebtSnapshotStaleTime(uint _seconds) external onlyOwner {\n        flexibleStorage().setDebtSnapshotStaleTime(SETTING_DEBT_SNAPSHOT_STALE_TIME, _seconds);\n        emit DebtSnapshotStaleTimeUpdated(_seconds);\n    }\n\n    function setAggregatorWarningFlags(address _flags) external onlyOwner {\n        flexibleStorage().setAggregatorWarningFlags(SETTING_AGGREGATOR_WARNING_FLAGS, _flags);\n        emit AggregatorWarningFlagsUpdated(_flags);\n    }\n\n    function setEtherWrapperMaxETH(uint _maxETH) external onlyOwner {\n        flexibleStorage().setEtherWrapperMaxETH(SETTING_ETHER_WRAPPER_MAX_ETH, _maxETH);\n        emit EtherWrapperMaxETHUpdated(_maxETH);\n    }\n\n    function setEtherWrapperMintFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperMintFeeRate(SETTING_ETHER_WRAPPER_MINT_FEE_RATE, _rate);\n        emit EtherWrapperMintFeeRateUpdated(_rate);\n    }\n\n    function setEtherWrapperBurnFeeRate(uint _rate) external onlyOwner {\n        flexibleStorage().setEtherWrapperBurnFeeRate(SETTING_ETHER_WRAPPER_BURN_FEE_RATE, _rate);\n        emit EtherWrapperBurnFeeRateUpdated(_rate);\n    }\n\n    function setWrapperMaxTokenAmount(address _wrapper, uint _maxTokenAmount) external onlyOwner {\n        flexibleStorage().setWrapperMaxTokenAmount(SETTING_WRAPPER_MAX_TOKEN_AMOUNT, _wrapper, _maxTokenAmount);\n        emit WrapperMaxTokenAmountUpdated(_wrapper, _maxTokenAmount);\n    }\n\n    function setWrapperMintFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperMintFeeRate(\n            SETTING_WRAPPER_MINT_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperBurnFeeRate(_wrapper)\n        );\n        emit WrapperMintFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setWrapperBurnFeeRate(address _wrapper, int _rate) external onlyOwner {\n        flexibleStorage().setWrapperBurnFeeRate(\n            SETTING_WRAPPER_BURN_FEE_RATE,\n            _wrapper,\n            _rate,\n            getWrapperMintFeeRate(_wrapper)\n        );\n        emit WrapperBurnFeeRateUpdated(_wrapper, _rate);\n    }\n\n    function setInteractionDelay(address _collateral, uint _interactionDelay) external onlyOwner {\n        flexibleStorage().setInteractionDelay(SETTING_INTERACTION_DELAY, _collateral, _interactionDelay);\n        emit InteractionDelayUpdated(_interactionDelay);\n    }\n\n    function setCollapseFeeRate(address _collateral, uint _collapseFeeRate) external onlyOwner {\n        flexibleStorage().setCollapseFeeRate(SETTING_COLLAPSE_FEE_RATE, _collateral, _collapseFeeRate);\n        emit CollapseFeeRateUpdated(_collapseFeeRate);\n    }\n\n    function setAtomicMaxVolumePerBlock(uint _maxVolume) external onlyOwner {\n        flexibleStorage().setAtomicMaxVolumePerBlock(SETTING_ATOMIC_MAX_VOLUME_PER_BLOCK, _maxVolume);\n        emit AtomicMaxVolumePerBlockUpdated(_maxVolume);\n    }\n\n    function setAtomicTwapWindow(uint _window) external onlyOwner {\n        flexibleStorage().setAtomicTwapWindow(SETTING_ATOMIC_TWAP_WINDOW, _window);\n        emit AtomicTwapWindowUpdated(_window);\n    }\n\n    function setAtomicEquivalentForDexPricing(bytes32 _currencyKey, address _equivalent) external onlyOwner {\n        flexibleStorage().setAtomicEquivalentForDexPricing(\n            SETTING_ATOMIC_EQUIVALENT_FOR_DEX_PRICING,\n            _currencyKey,\n            _equivalent\n        );\n        emit AtomicEquivalentForDexPricingUpdated(_currencyKey, _equivalent);\n    }\n\n    function setAtomicExchangeFeeRate(bytes32 _currencyKey, uint256 _exchangeFeeRate) external onlyOwner {\n        flexibleStorage().setAtomicExchangeFeeRate(SETTING_ATOMIC_EXCHANGE_FEE_RATE, _currencyKey, _exchangeFeeRate);\n        emit AtomicExchangeFeeUpdated(_currencyKey, _exchangeFeeRate);\n    }\n\n    function setAtomicPriceBuffer(bytes32 _currencyKey, uint _buffer) external onlyOwner {\n        flexibleStorage().setAtomicPriceBuffer(SETTING_ATOMIC_PRICE_BUFFER, _currencyKey, _buffer);\n        emit AtomicPriceBufferUpdated(_currencyKey, _buffer);\n    }\n\n    function setAtomicVolatilityConsiderationWindow(bytes32 _currencyKey, uint _window) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityConsiderationWindow(\n            SETTING_ATOMIC_VOLATILITY_CONSIDERATION_WINDOW,\n            _currencyKey,\n            _window\n        );\n        emit AtomicVolatilityConsiderationWindowUpdated(_currencyKey, _window);\n    }\n\n    function setAtomicVolatilityUpdateThreshold(bytes32 _currencyKey, uint _threshold) external onlyOwner {\n        flexibleStorage().setAtomicVolatilityUpdateThreshold(\n            SETTING_ATOMIC_VOLATILITY_UPDATE_THRESHOLD,\n            _currencyKey,\n            _threshold\n        );\n        emit AtomicVolatilityUpdateThresholdUpdated(_currencyKey, _threshold);\n    }\n\n    // ========== EVENTS ==========\n    event CrossDomainMessageGasLimitChanged(CrossDomainMessageGasLimits gasLimitType, uint newLimit);\n    event IssuanceRatioUpdated(uint newRatio);\n    event TradingRewardsEnabled(bool enabled);\n    event WaitingPeriodSecsUpdated(uint waitingPeriodSecs);\n    event PriceDeviationThresholdUpdated(uint threshold);\n    event FeePeriodDurationUpdated(uint newFeePeriodDuration);\n    event TargetThresholdUpdated(uint newTargetThreshold);\n    event LiquidationDelayUpdated(uint newDelay);\n    event LiquidationRatioUpdated(uint newRatio);\n    event LiquidationPenaltyUpdated(uint newPenalty);\n    event RateStalePeriodUpdated(uint rateStalePeriod);\n    /* ========== Exchange Fees Related ========== */\n    event ExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\n    event ExchangeDynamicFeeThresholdUpdated(uint dynamicFeeThreshold);\n    event ExchangeDynamicFeeWeightDecayUpdated(uint dynamicFeeWeightDecay);\n    event ExchangeDynamicFeeRoundsUpdated(uint dynamicFeeRounds);\n    event ExchangeMaxDynamicFeeUpdated(uint maxDynamicFee);\n    /* ========== End Exchange Fees Related ========== */\n    event MinimumStakeTimeUpdated(uint minimumStakeTime);\n    event DebtSnapshotStaleTimeUpdated(uint debtSnapshotStaleTime);\n    event AggregatorWarningFlagsUpdated(address flags);\n    event EtherWrapperMaxETHUpdated(uint maxETH);\n    event EtherWrapperMintFeeRateUpdated(uint rate);\n    event EtherWrapperBurnFeeRateUpdated(uint rate);\n    event WrapperMaxTokenAmountUpdated(address wrapper, uint maxTokenAmount);\n    event WrapperMintFeeRateUpdated(address wrapper, int rate);\n    event WrapperBurnFeeRateUpdated(address wrapper, int rate);\n    event InteractionDelayUpdated(uint interactionDelay);\n    event CollapseFeeRateUpdated(uint collapseFeeRate);\n    event AtomicMaxVolumePerBlockUpdated(uint newMaxVolume);\n    event AtomicTwapWindowUpdated(uint newWindow);\n    event AtomicEquivalentForDexPricingUpdated(bytes32 synthKey, address equivalent);\n    event AtomicExchangeFeeUpdated(bytes32 synthKey, uint newExchangeFeeRate);\n    event AtomicPriceBufferUpdated(bytes32 synthKey, uint newBuffer);\n    event AtomicVolatilityConsiderationWindowUpdated(bytes32 synthKey, uint newVolatilityConsiderationWindow);\n    event AtomicVolatilityUpdateThresholdUpdated(bytes32 synthKey, uint newVolatilityUpdateThreshold);\n}\n\n\ninterface ISynthetixNamedContract {\n    // solhint-disable func-name-mixedcase\n    function CONTRACT_NAME() external view returns (bytes32);\n}\n\n// solhint-disable contract-name-camelcase\ncontract Migration_Alsephina is BaseMigration {\n    // https://etherscan.io/address/0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n    address public constant OWNER = 0xEb3107117FEAd7de89Cd14D463D340A2E6917769;\n\n    // ----------------------------\n    // EXISTING SYNTHETIX CONTRACTS\n    // ----------------------------\n\n    // https://etherscan.io/address/0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83\n    AddressResolver public constant addressresolver_i = AddressResolver(0x823bE81bbF96BEc0e25CA13170F5AaCb5B79ba83);\n    // https://etherscan.io/address/0x545973f28950f50fc6c7F52AAb4Ad214A27C0564\n    ExchangeState public constant exchangestate_i = ExchangeState(0x545973f28950f50fc6c7F52AAb4Ad214A27C0564);\n    // https://etherscan.io/address/0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E\n    SystemStatus public constant systemstatus_i = SystemStatus(0x1c86B3CDF2a60Ae3a574f7f71d44E2C50BDdB87E);\n    // https://etherscan.io/address/0xF68ECd50de7733015318361295547D8E939F93E6\n    ExchangeRatesWithDexPricing public constant exchangerates_i =\n        ExchangeRatesWithDexPricing(0xF68ECd50de7733015318361295547D8E939F93E6);\n    // https://etherscan.io/address/0x80d65Bb7b9436A86c1928F93D6E7cc186987Ac54\n    SystemSettings public constant systemsettings_i = SystemSettings(0x80d65Bb7b9436A86c1928F93D6E7cc186987Ac54);\n\n    // ----------------------------------\n    // NEW CONTRACTS DEPLOYED TO BE ADDED\n    // ----------------------------------\n\n    // https://etherscan.io/address/0xa62F71D599Ec6179B4f6569adD69ffC7E1A7a1c5\n    address public constant new_SystemSettingsLib_contract = 0xa62F71D599Ec6179B4f6569adD69ffC7E1A7a1c5;\n    // https://etherscan.io/address/0x80d65Bb7b9436A86c1928F93D6E7cc186987Ac54\n    address public constant new_SystemSettings_contract = 0x80d65Bb7b9436A86c1928F93D6E7cc186987Ac54;\n    // https://etherscan.io/address/0xF68ECd50de7733015318361295547D8E939F93E6\n    address public constant new_ExchangeRates_contract = 0xF68ECd50de7733015318361295547D8E939F93E6;\n    // https://etherscan.io/address/0x3e343E89F4fF8057806F54F2208940B1Cd5C40ca\n    address public constant new_Exchanger_contract = 0x3e343E89F4fF8057806F54F2208940B1Cd5C40ca;\n\n    constructor() public BaseMigration(OWNER) {}\n\n    function contractsRequiringOwnership() public pure returns (address[] memory contracts) {\n        contracts = new address[](5);\n        contracts[0] = address(addressresolver_i);\n        contracts[1] = address(exchangestate_i);\n        contracts[2] = address(systemstatus_i);\n        contracts[3] = address(exchangerates_i);\n        contracts[4] = address(systemsettings_i);\n    }\n\n    function migrate(address currentOwner) external onlyOwner {\n        require(owner == currentOwner, \"Only the assigned owner can be re-assigned when complete\");\n\n        require(\n            ISynthetixNamedContract(new_SystemSettings_contract).CONTRACT_NAME() == \"SystemSettings\",\n            \"Invalid contract supplied for SystemSettings\"\n        );\n        require(\n            ISynthetixNamedContract(new_ExchangeRates_contract).CONTRACT_NAME() == \"ExchangeRatesWithDexPricing\",\n            \"Invalid contract supplied for ExchangeRates\"\n        );\n        require(\n            ISynthetixNamedContract(new_Exchanger_contract).CONTRACT_NAME() == \"ExchangerWithFeeRecAlternatives\",\n            \"Invalid contract supplied for Exchanger\"\n        );\n\n        // ACCEPT OWNERSHIP for all contracts that require ownership to make changes\n        acceptAll();\n\n        // MIGRATION\n        // Import all new contracts into the address resolver;\n        addressresolver_importAddresses_0();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 1;\n        addressresolver_rebuildCaches_1();\n        // Rebuild the resolver caches in all MixinResolver contracts - batch 2;\n        addressresolver_rebuildCaches_2();\n        // Ensure the Exchanger contract can write to its State;\n        exchangestate_i.setAssociatedContract(new_Exchanger_contract);\n        // Ensure the Exchanger contract can suspend synths - see SIP-65;\n        systemstatus_i.updateAccessControl(\"Synth\", new_Exchanger_contract, true, false);\n        // Ensure the ExchangeRates contract has the standalone feed for SNX;\n        exchangerates_i.addAggregator(\"SNX\", 0xDC3EA94CD0AC27d9A86C180091e7f78C683d3699);\n        // Ensure the ExchangeRates contract has the standalone feed for ETH;\n        exchangerates_i.addAggregator(\"ETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Ensure the ExchangeRates contract has the feed for sEUR;\n        exchangerates_i.addAggregator(\"sEUR\", 0xb49f677943BC038e9857d61E7d053CaA2C1734C1);\n        // Ensure the ExchangeRates contract has the feed for sJPY;\n        exchangerates_i.addAggregator(\"sJPY\", 0xBcE206caE7f0ec07b545EddE332A47C2F75bbeb3);\n        // Ensure the ExchangeRates contract has the feed for sAUD;\n        exchangerates_i.addAggregator(\"sAUD\", 0x77F9710E7d0A19669A13c055F62cd80d313dF022);\n        // Ensure the ExchangeRates contract has the feed for sGBP;\n        exchangerates_i.addAggregator(\"sGBP\", 0x5c0Ab2d9b5a7ed9f470386e82BB36A3613cDd4b5);\n        // Ensure the ExchangeRates contract has the feed for sCHF;\n        exchangerates_i.addAggregator(\"sCHF\", 0x449d117117838fFA61263B61dA6301AA2a88B13A);\n        // Ensure the ExchangeRates contract has the feed for sKRW;\n        exchangerates_i.addAggregator(\"sKRW\", 0x01435677FB11763550905594A16B645847C1d0F3);\n        // Ensure the ExchangeRates contract has the feed for sBTC;\n        exchangerates_i.addAggregator(\"sBTC\", 0xF4030086522a5bEEa4988F8cA5B36dbC97BeE88c);\n        // Ensure the ExchangeRates contract has the feed for sETH;\n        exchangerates_i.addAggregator(\"sETH\", 0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419);\n        // Ensure the ExchangeRates contract has the feed for sLINK;\n        exchangerates_i.addAggregator(\"sLINK\", 0x2c1d072e956AFFC0D435Cb7AC38EF18d24d9127c);\n        // Ensure the ExchangeRates contract has the feed for sADA;\n        exchangerates_i.addAggregator(\"sADA\", 0xAE48c91dF1fE419994FFDa27da09D5aC69c30f55);\n        // Ensure the ExchangeRates contract has the feed for sAAVE;\n        exchangerates_i.addAggregator(\"sAAVE\", 0x547a514d5e3769680Ce22B2361c10Ea13619e8a9);\n        // Ensure the ExchangeRates contract has the feed for sDOT;\n        exchangerates_i.addAggregator(\"sDOT\", 0x1C07AFb8E2B827c5A4739C6d59Ae3A5035f28734);\n        // Ensure the ExchangeRates contract has the feed for sETHBTC;\n        exchangerates_i.addAggregator(\"sETHBTC\", 0xAc559F25B1619171CbC396a50854A3240b6A4e99);\n        // Ensure the ExchangeRates contract has the feed for sDEFI;\n        exchangerates_i.addAggregator(\"sDEFI\", 0xa8E875F94138B0C5b51d1e1d5dE35bbDdd28EA87);\n        // Set exchange dynamic fee threshold (SIP-184);\n        systemsettings_i.setExchangeDynamicFeeThreshold(4000000000000000);\n        // Set exchange dynamic fee weight decay (SIP-184);\n        systemsettings_i.setExchangeDynamicFeeWeightDecay(900000000000000000);\n        // Set exchange dynamic fee rounds (SIP-184);\n        systemsettings_i.setExchangeDynamicFeeRounds(0);\n        // Set exchange max dynamic fee (SIP-184);\n        systemsettings_i.setExchangeMaxDynamicFee(50000000000000000);\n        // SIP-120 Set the DEX price aggregator (uniswap TWAP oracle reader);\n        exchangerates_i.setDexPriceAggregator(IDexPriceAggregator(0xf120F029Ac143633d1942e48aE2Dfa2036C5786c));\n\n        // NOMINATE OWNERSHIP back to owner for aforementioned contracts\n        nominateAll();\n    }\n\n    function acceptAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            Owned(contracts[i]).acceptOwnership();\n        }\n    }\n\n    function nominateAll() internal {\n        address[] memory contracts = contractsRequiringOwnership();\n        for (uint i = 0; i < contracts.length; i++) {\n            returnOwnership(contracts[i]);\n        }\n    }\n\n    function addressresolver_importAddresses_0() internal {\n        bytes32[] memory addressresolver_importAddresses_names_0_0 = new bytes32[](3);\n        addressresolver_importAddresses_names_0_0[0] = bytes32(\"SystemSettings\");\n        addressresolver_importAddresses_names_0_0[1] = bytes32(\"ExchangeRates\");\n        addressresolver_importAddresses_names_0_0[2] = bytes32(\"Exchanger\");\n        address[] memory addressresolver_importAddresses_destinations_0_1 = new address[](3);\n        addressresolver_importAddresses_destinations_0_1[0] = address(new_SystemSettings_contract);\n        addressresolver_importAddresses_destinations_0_1[1] = address(new_ExchangeRates_contract);\n        addressresolver_importAddresses_destinations_0_1[2] = address(new_Exchanger_contract);\n        addressresolver_i.importAddresses(\n            addressresolver_importAddresses_names_0_0,\n            addressresolver_importAddresses_destinations_0_1\n        );\n    }\n\n    function addressresolver_rebuildCaches_1() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_1_0 = new MixinResolver[](20);\n        addressresolver_rebuildCaches_destinations_1_0[0] = MixinResolver(new_SystemSettings_contract);\n        addressresolver_rebuildCaches_destinations_1_0[1] = MixinResolver(0xAD95C918af576c82Df740878C3E983CBD175daB6);\n        addressresolver_rebuildCaches_destinations_1_0[2] = MixinResolver(0x9D5551Cd3425Dd4585c3E7Eb7E4B98902222521E);\n        addressresolver_rebuildCaches_destinations_1_0[3] = MixinResolver(new_Exchanger_contract);\n        addressresolver_rebuildCaches_destinations_1_0[4] = MixinResolver(0xC2F1F551bfAd1E9A3b4816513bFd41d77f40F915);\n        addressresolver_rebuildCaches_destinations_1_0[5] = MixinResolver(0xC1AAE9d18bBe386B102435a8632C8063d31e747C);\n        addressresolver_rebuildCaches_destinations_1_0[6] = MixinResolver(0x067e398605E84F2D0aEEC1806e62768C5110DCc6);\n        addressresolver_rebuildCaches_destinations_1_0[7] = MixinResolver(0x5c8344bcdC38F1aB5EB5C1d4a35DdEeA522B5DfA);\n        addressresolver_rebuildCaches_destinations_1_0[8] = MixinResolver(0xaa03aB31b55DceEeF845C8d17890CC61cD98eD04);\n        addressresolver_rebuildCaches_destinations_1_0[9] = MixinResolver(0x1F2c3a1046c32729862fcB038369696e3273a516);\n        addressresolver_rebuildCaches_destinations_1_0[10] = MixinResolver(0x7C22547779c8aa41bAE79E03E8383a0BefBCecf0);\n        addressresolver_rebuildCaches_destinations_1_0[11] = MixinResolver(new_ExchangeRates_contract);\n        addressresolver_rebuildCaches_destinations_1_0[12] = MixinResolver(0xF66d34426C10CE91cDBcd86F8e9594AfB83049bd);\n        addressresolver_rebuildCaches_destinations_1_0[13] = MixinResolver(0xDC01020857afbaE65224CfCeDb265d1216064c59);\n        addressresolver_rebuildCaches_destinations_1_0[14] = MixinResolver(0x62922670313bf6b41C580143d1f6C173C5C20019);\n        addressresolver_rebuildCaches_destinations_1_0[15] = MixinResolver(0xAFDd6B5A8aB32156dBFb4060ff87F6d9E31191bA);\n        addressresolver_rebuildCaches_destinations_1_0[16] = MixinResolver(0xe301da3d2D3e96e57D05b8E557656629cDdbe7A0);\n        addressresolver_rebuildCaches_destinations_1_0[17] = MixinResolver(0x4ed5c5D5793f86c8a85E1a96E37b6d374DE0E85A);\n        addressresolver_rebuildCaches_destinations_1_0[18] = MixinResolver(0x005d19CA7ff9D79a5Bdf0805Fc01D9D7c53B6827);\n        addressresolver_rebuildCaches_destinations_1_0[19] = MixinResolver(0xde3892383965FBa6eC434bE6350F85f140098708);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_1_0);\n    }\n\n    function addressresolver_rebuildCaches_2() internal {\n        MixinResolver[] memory addressresolver_rebuildCaches_destinations_2_0 = new MixinResolver[](10);\n        addressresolver_rebuildCaches_destinations_2_0[0] = MixinResolver(0x39DDbbb113AF3434048b9d8018a3e99d67C6eE0D);\n        addressresolver_rebuildCaches_destinations_2_0[1] = MixinResolver(0xe2f532c389deb5E42DCe53e78A9762949A885455);\n        addressresolver_rebuildCaches_destinations_2_0[2] = MixinResolver(0x2B3eb5eF0EF06f2E02ef60B3F36Be4793d321353);\n        addressresolver_rebuildCaches_destinations_2_0[3] = MixinResolver(0xc70B42930BD8D30A79B55415deC3be60827559f7);\n        addressresolver_rebuildCaches_destinations_2_0[4] = MixinResolver(0x3FFE35c3d412150C3B91d3E22eBA60E16030C608);\n        addressresolver_rebuildCaches_destinations_2_0[5] = MixinResolver(0x8f9fa817200F5B95f9572c8Acf2b31410C00335a);\n        addressresolver_rebuildCaches_destinations_2_0[6] = MixinResolver(0x0705F0716b12a703d4F8832Ec7b97C61771f0361);\n        addressresolver_rebuildCaches_destinations_2_0[7] = MixinResolver(0xfA60918C4417b64E722ca15d79C751c1f24Ab995);\n        addressresolver_rebuildCaches_destinations_2_0[8] = MixinResolver(0xcc3aab773e2171b2E257Ee17001400eE378aa52B);\n        addressresolver_rebuildCaches_destinations_2_0[9] = MixinResolver(0xe59dFC746D566EB40F92ed0B162004e24E3AC932);\n        addressresolver_i.rebuildCaches(addressresolver_rebuildCaches_destinations_2_0);\n    }\n}\n\n    ", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerNominated\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressresolver_i\",\"outputs\":[{\"internalType\":\"contract AddressResolver\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractsRequiringOwnership\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangerates_i\",\"outputs\":[{\"internalType\":\"contract ExchangeRatesWithDexPricing\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangestate_i\",\"outputs\":[{\"internalType\":\"contract ExchangeState\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"currentOwner\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_ExchangeRates_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_Exchanger_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SystemSettingsLib_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"new_SystemSettings_contract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"nominateNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominatedOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"forContract\",\"type\":\"address\"}],\"name\":\"returnOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemsettings_i\",\"outputs\":[{\"internalType\":\"contract SystemSettings\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemstatus_i\",\"outputs\":[{\"internalType\":\"contract SystemStatus\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Migration_Alsephina", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}