{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/migration/LUSDSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity ^0.8.10;\\npragma abicoder v2;\\n\\nimport \\\"../libraries/SafeERC20.sol\\\";\\n\\nimport \\\"../interfaces/ITreasury.sol\\\";\\nimport \\\"../interfaces/ITreasuryV1.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nimport \\\"../types/OlympusAccessControlled.sol\\\";\\n\\ninterface ICurveFactory {\\n    function exchange_underlying(\\n        uint256 i,\\n        uint256 j,\\n        uint256 dx,\\n        uint256 min_dy\\n    ) external returns (uint256);\\n}\\n\\n/// @title   LUSD Swap Contract\\n/// @notice  Swaps LUSD from treasury v1 to DAI then sends to treasury v2\\n/// @author  JeffX\\ncontract LUSDSwapContract is OlympusAccessControlled {\\n    using SafeERC20 for IERC20;\\n\\n    /// ERRORS ///\\n\\n    /// @notice Error for if more DAI than 1:1 backing is attempted to be sent\\n    error OverOHMV1Backing();\\n\\n    /// STATE VARIABLES ///\\n\\n    /// @notice Curve Factory\\n    ICurveFactory internal immutable curveFactory = ICurveFactory(0xEd279fDD11cA84bEef15AF5D39BB4d4bEE23F0cA);\\n    /// @notice Olympus Treasury V1\\n    ITreasuryV1 internal immutable treasuryV1 = ITreasuryV1(0x31F8Cc382c9898b273eff4e0b7626a6987C846E8);\\n    /// @notice Olympus Treasury V2\\n    ITreasury internal immutable treasuryV2 = ITreasury(0x9A315BdF513367C0377FB36545857d12e85813Ef);\\n    /// @notice Olympus Token V1\\n    IERC20 internal immutable OHMV1 = IERC20(0x383518188C0C6d7730D91b2c03a03C837814a899);\\n    /// @notice LUSD\\n    address internal immutable LUSD = 0x5f98805A4E8be255a32880FDeC7F6728C6568bA0;\\n    /// @notice DAI\\n    address internal immutable DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\\n    /// @notice Remaining amount of DAI to have each OHM V1 backed by 1 DAI;\\n    uint256 public OHMV1BackingInDAIRemaining;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// @param _authority  Address of the Olympus Authority contract\\n    constructor(IOlympusAuthority _authority) OlympusAccessControlled(_authority) {\\n        OHMV1BackingInDAIRemaining = OHMV1.totalSupply() * 1e9;\\n    }\\n\\n    /// POLICY FUNCTIONS ///\\n\\n    /// @notice                        Manages LUSD from treasury V1 and swaps for LUSD\\n    /// @param _amountLUSD             Amount of LUSD that will be managed from treasury V1 and swapped\\n    /// @param _minAmountDAI           Minimum amount of DAI to receive\\n    /// @param _amountDAIToV1Treasury  Amount of DAI that was received from swap to be sent to V1 treasury\\n    function swapLUSDForDAI(\\n        uint256 _amountLUSD,\\n        uint256 _minAmountDAI,\\n        uint256 _amountDAIToV1Treasury\\n    ) external onlyGuardian {\\n        // Manage LUSD from v1 treasury\\n        treasuryV1.manage(LUSD, _amountLUSD);\\n\\n        // Approve LUSD to be spent by the  Curve pool\\n        IERC20(LUSD).approve(address(curveFactory), _amountLUSD);\\n\\n        // Swap specified LUSD for DAI\\n        uint256 daiReceived = curveFactory.exchange_underlying(0, 1, _amountLUSD, _minAmountDAI);\\n\\n        if (_amountDAIToV1Treasury > 0) {\\n            if (OHMV1BackingInDAIRemaining < _amountDAIToV1Treasury) revert OverOHMV1Backing();\\n            IERC20(DAI).safeTransfer(address(treasuryV1), _amountDAIToV1Treasury);\\n            OHMV1BackingInDAIRemaining -= _amountDAIToV1Treasury;\\n            daiReceived -= _amountDAIToV1Treasury;\\n        }\\n\\n        IERC20(DAI).approve(address(treasuryV2), daiReceived);\\n\\n        // Deposit DAI into v2 treasury, all as profit\\n        treasuryV2.deposit(daiReceived, DAI, treasuryV2.tokenValue(DAI, daiReceived));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport {IERC20} from \\\"../interfaces/IERC20.sol\\\";\\n\\n/// @notice Safe IERC20 and ETH transfer library that safely handles missing return values.\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/libraries/TransferHelper.sol)\\n/// Taken from Solmate\\nlibrary SafeERC20 {\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.transfer.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        (bool success, bytes memory data) = address(token).call(\\n            abi.encodeWithSelector(IERC20.approve.selector, to, amount)\\n        );\\n\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), \\\"APPROVE_FAILED\\\");\\n    }\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        (bool success, ) = to.call{value: amount}(new bytes(0));\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasury.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasury {\\n    function deposit(\\n        uint256 _amount,\\n        address _token,\\n        uint256 _profit\\n    ) external returns (uint256);\\n\\n    function withdraw(uint256 _amount, address _token) external;\\n\\n    function tokenValue(address _token, uint256 _amount) external view returns (uint256 value_);\\n\\n    function mint(address _recipient, uint256 _amount) external;\\n\\n    function manage(address _token, uint256 _amount) external;\\n\\n    function incurDebt(uint256 amount_, address token_) external;\\n\\n    function repayDebtWithReserve(uint256 amount_, address token_) external;\\n\\n    function excessReserves() external view returns (uint256);\\n\\n    function baseSupply() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITreasuryV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface ITreasuryV1 {\\n    function withdraw(uint256 amount, address token) external;\\n\\n    function manage(address token, uint256 amount) external;\\n\\n    function valueOf(address token, uint256 amount) external view returns (uint256);\\n\\n    function excessReserves() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IERC20 {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOlympusAuthority.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0\\npragma solidity >=0.7.5;\\n\\ninterface IOlympusAuthority {\\n    /* ========== EVENTS ========== */\\n\\n    event GovernorPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event GuardianPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event PolicyPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n    event VaultPushed(address indexed from, address indexed to, bool _effectiveImmediately);\\n\\n    event GovernorPulled(address indexed from, address indexed to);\\n    event GuardianPulled(address indexed from, address indexed to);\\n    event PolicyPulled(address indexed from, address indexed to);\\n    event VaultPulled(address indexed from, address indexed to);\\n\\n    /* ========== VIEW ========== */\\n\\n    function governor() external view returns (address);\\n\\n    function guardian() external view returns (address);\\n\\n    function policy() external view returns (address);\\n\\n    function vault() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/types/OlympusAccessControlled.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.7.5;\\n\\nimport \\\"../interfaces/IOlympusAuthority.sol\\\";\\n\\nabstract contract OlympusAccessControlled {\\n    /* ========== EVENTS ========== */\\n\\n    event AuthorityUpdated(IOlympusAuthority indexed authority);\\n\\n    string UNAUTHORIZED = \\\"UNAUTHORIZED\\\"; // save gas\\n\\n    /* ========== STATE VARIABLES ========== */\\n\\n    IOlympusAuthority public authority;\\n\\n    /* ========== Constructor ========== */\\n\\n    constructor(IOlympusAuthority _authority) {\\n        authority = _authority;\\n        emit AuthorityUpdated(_authority);\\n    }\\n\\n    /* ========== MODIFIERS ========== */\\n\\n    modifier onlyGovernor() {\\n        require(msg.sender == authority.governor(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyGuardian() {\\n        require(msg.sender == authority.guardian(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyPolicy() {\\n        require(msg.sender == authority.policy(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    modifier onlyVault() {\\n        require(msg.sender == authority.vault(), UNAUTHORIZED);\\n        _;\\n    }\\n\\n    /* ========== GOV ONLY ========== */\\n\\n    function setAuthority(IOlympusAuthority _newAuthority) external onlyGovernor {\\n        authority = _newAuthority;\\n        emit AuthorityUpdated(_newAuthority);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_authority\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OverOHMV1Backing\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract IOlympusAuthority\",\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"AuthorityUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OHMV1BackingInDAIRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IOlympusAuthority\",\"name\":\"_newAuthority\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amountLUSD\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minAmountDAI\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amountDAIToV1Treasury\",\"type\":\"uint256\"}],\"name\":\"swapLUSDForDAI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LUSDSwapContract", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000001c21f8ea7e39e2ba00bc12d2968d63f4acb38b7a", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}