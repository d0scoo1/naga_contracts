{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/libraries/WithdrawHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './Orders.sol';\\n\\nlibrary WithdrawHelper {\\n    using SafeMath for uint256;\\n\\n    function _transferToken(\\n        uint256 balanceBefore,\\n        address token,\\n        address to\\n    ) internal {\\n        uint256 tokenAmount = IERC20(token).balanceOf(address(this)).sub(balanceBefore);\\n        TransferHelper.safeTransfer(token, to, tokenAmount);\\n    }\\n\\n    function _unwrapWeth(\\n        uint256 ethAmount,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    ) internal returns (bool) {\\n        IWETH(weth).withdraw(ethAmount);\\n        (bool success, ) = to.call{ value: ethAmount, gas: gasLimit }('');\\n        return success;\\n    }\\n\\n    function withdrawAndUnwrap(\\n        address token0,\\n        address token1,\\n        address pair,\\n        address weth,\\n        address to,\\n        uint256 gasLimit\\n    )\\n        external\\n        returns (\\n            bool,\\n            uint256,\\n            uint256,\\n            uint256\\n        )\\n    {\\n        bool isToken0Weth = token0 == weth;\\n        address otherToken = isToken0Weth ? token1 : token0;\\n\\n        uint256 balanceBefore = IERC20(otherToken).balanceOf(address(this));\\n        (uint256 amount0, uint256 amount1) = ITwapPair(pair).burn(address(this));\\n        _transferToken(balanceBefore, otherToken, to);\\n\\n        bool success = _unwrapWeth(isToken0Weth ? amount0 : amount1, weth, to, gasLimit);\\n\\n        return (success, isToken0Weth ? amount0 : amount1, amount0, amount1);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './ITwapERC20.sol';\\nimport './IReserves.sol';\\n\\ninterface ITwapPair is ITwapERC20, IReserves {\\n    event Mint(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 liquidityOut, address indexed to);\\n    event Burn(address indexed sender, uint256 amount0Out, uint256 amount1Out, uint256 liquidityIn, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    event SetMintFee(uint256 fee);\\n    event SetBurnFee(uint256 fee);\\n    event SetSwapFee(uint256 fee);\\n    event SetOracle(address account);\\n    event SetTrader(address trader);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\\n\\n    function factory() external view returns (address);\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function oracle() external view returns (address);\\n\\n    function trader() external view returns (address);\\n\\n    function mintFee() external view returns (uint256);\\n\\n    function setMintFee(uint256 fee) external;\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burnFee() external view returns (uint256);\\n\\n    function setBurnFee(uint256 fee) external;\\n\\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function setSwapFee(uint256 fee) external;\\n\\n    function setOracle(address account) external;\\n\\n    function setTrader(address account) external;\\n\\n    function collect(address to) external;\\n\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to,\\n        bytes calldata data\\n    ) external;\\n\\n    function sync() external;\\n\\n    function initialize(\\n        address _token0,\\n        address _token1,\\n        address _oracle,\\n        address _trader\\n    ) external;\\n\\n    function getSwapAmount0In(uint256 amount1Out, bytes calldata data) external view returns (uint256 swapAmount0In);\\n\\n    function getSwapAmount1In(uint256 amount0Out, bytes calldata data) external view returns (uint256 swapAmount1In);\\n\\n    function getSwapAmount0Out(uint256 amount1In, bytes calldata data) external view returns (uint256 swapAmount0Out);\\n\\n    function getSwapAmount1Out(uint256 amount0In, bytes calldata data) external view returns (uint256 swapAmount1Out);\\n\\n    function getDepositAmount0In(uint256 amount0, bytes calldata data) external view returns (uint256 depositAmount0In);\\n\\n    function getDepositAmount1In(uint256 amount1, bytes calldata data) external view returns (uint256 depositAmount1In);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IWETH.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Orders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\npragma abicoder v2;\\n\\nimport './SafeMath.sol';\\nimport '../libraries/Math.sol';\\nimport '../interfaces/ITwapFactory.sol';\\nimport '../interfaces/ITwapPair.sol';\\nimport '../interfaces/ITwapOracle.sol';\\nimport '../libraries/TokenShares.sol';\\n\\nlibrary Orders {\\n    using SafeMath for uint256;\\n    using TokenShares for TokenShares.Data;\\n    using TransferHelper for address;\\n\\n    enum OrderType {\\n        Empty,\\n        Deposit,\\n        Withdraw,\\n        Sell,\\n        Buy\\n    }\\n    enum OrderStatus {\\n        NonExistent,\\n        EnqueuedWaiting,\\n        EnqueuedReady,\\n        ExecutedSucceeded,\\n        ExecutedFailed,\\n        Canceled\\n    }\\n\\n    event MaxGasLimitSet(uint256 maxGasLimit);\\n    event GasPriceInertiaSet(uint256 gasPriceInertia);\\n    event MaxGasPriceImpactSet(uint256 maxGasPriceImpact);\\n    event TransferGasCostSet(address token, uint256 gasCost);\\n\\n    event DepositEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event WithdrawEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event SellEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n    event BuyEnqueued(uint256 indexed orderId, uint32 validAfterTimestamp, uint256 gasPrice);\\n\\n    event OrderDisabled(address pair, Orders.OrderType orderType, bool disabled);\\n\\n    uint8 private constant DEPOSIT_TYPE = 1;\\n    uint8 private constant WITHDRAW_TYPE = 2;\\n    uint8 private constant BUY_TYPE = 3;\\n    uint8 private constant BUY_INVERTED_TYPE = 4;\\n    uint8 private constant SELL_TYPE = 5;\\n    uint8 private constant SELL_INVERTED_TYPE = 6;\\n\\n    uint8 private constant UNWRAP_NOT_FAILED = 0;\\n    uint8 private constant KEEP_NOT_FAILED = 1;\\n    uint8 private constant UNWRAP_FAILED = 2;\\n    uint8 private constant KEEP_FAILED = 3;\\n\\n    uint256 private constant ETHER_TRANSFER_COST = 2600 + 1504; // EIP-2929 acct access cost + Gnosis Safe receive ETH cost\\n    uint256 private constant BUFFER_COST = 10000;\\n    uint256 private constant ORDER_EXECUTED_EVENT_COST = 3700;\\n    uint256 private constant EXECUTE_PREPARATION_COST = 55000; // dequeue + getPair in execute\\n\\n    uint256 public constant ETHER_TRANSFER_CALL_COST = 10000;\\n    uint256 public constant PAIR_TRANSFER_COST = 55000;\\n    uint256 public constant REFUND_BASE_COST = 2 * ETHER_TRANSFER_COST + BUFFER_COST + ORDER_EXECUTED_EVENT_COST;\\n    uint256 public constant ORDER_BASE_COST = EXECUTE_PREPARATION_COST + REFUND_BASE_COST;\\n\\n    // Masks used for setting order disabled\\n    // Different bits represent different order types\\n    uint8 private constant DEPOSIT_MASK = uint8(1) << uint8(OrderType.Deposit); //   00000010\\n    uint8 private constant WITHDRAW_MASK = uint8(1) << uint8(OrderType.Withdraw); // 00000100\\n    uint8 private constant SELL_MASK = uint8(1) << uint8(OrderType.Sell); //         00001000\\n    uint8 private constant BUY_MASK = uint8(1) << uint8(OrderType.Buy); //           00010000\\n\\n    struct PairInfo {\\n        address pair;\\n        address token0;\\n        address token1;\\n    }\\n\\n    struct Data {\\n        uint32 delay;\\n        uint256 newestOrderId;\\n        uint256 lastProcessedOrderId;\\n        mapping(uint256 => StoredOrder) orderQueue;\\n        address factory;\\n        uint256 maxGasLimit;\\n        uint256 gasPrice;\\n        uint256 gasPriceInertia;\\n        uint256 maxGasPriceImpact;\\n        mapping(uint32 => PairInfo) pairs;\\n        mapping(address => uint256) transferGasCosts;\\n        mapping(uint256 => bool) canceled;\\n        // Bit on specific positions indicates whether order type is disabled (1) or enabled (0) on specific pair\\n        mapping(address => uint8) orderDisabled;\\n    }\\n\\n    struct StoredOrder {\\n        // slot 0\\n        uint8 orderType;\\n        uint32 validAfterTimestamp;\\n        uint8 unwrapAndFailure;\\n        uint32 timestamp;\\n        uint32 gasLimit;\\n        uint32 gasPrice;\\n        uint112 liquidity;\\n        // slot 1\\n        uint112 value0;\\n        uint112 value1;\\n        uint32 pairId;\\n        // slot2\\n        address to;\\n        uint32 minSwapPrice;\\n        uint32 maxSwapPrice;\\n        bool swap;\\n        // slot3\\n        uint256 priceAccumulator;\\n    }\\n\\n    struct DepositOrder {\\n        uint32 pairId;\\n        uint256 share0;\\n        uint256 share1;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool unwrap;\\n        bool swap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    struct WithdrawOrder {\\n        uint32 pairId;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n    }\\n\\n    struct SellOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareIn;\\n        uint256 amountOutMin;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    struct BuyOrder {\\n        uint32 pairId;\\n        bool inverse;\\n        uint256 shareInMax;\\n        uint256 amountOut;\\n        bool unwrap;\\n        address to;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        uint32 validAfterTimestamp;\\n        uint256 priceAccumulator;\\n        uint32 timestamp;\\n    }\\n\\n    function decodeType(uint256 internalType) internal pure returns (OrderType orderType) {\\n        if (internalType == DEPOSIT_TYPE) {\\n            orderType = OrderType.Deposit;\\n        } else if (internalType == WITHDRAW_TYPE) {\\n            orderType = OrderType.Withdraw;\\n        } else if (internalType == BUY_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == BUY_INVERTED_TYPE) {\\n            orderType = OrderType.Buy;\\n        } else if (internalType == SELL_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else if (internalType == SELL_INVERTED_TYPE) {\\n            orderType = OrderType.Sell;\\n        } else {\\n            orderType = OrderType.Empty;\\n        }\\n    }\\n\\n    function getOrder(Data storage data, uint256 orderId)\\n        public\\n        view\\n        returns (OrderType orderType, uint32 validAfterTimestamp)\\n    {\\n        StoredOrder storage order = data.orderQueue[orderId];\\n        uint8 internalType = order.orderType;\\n        validAfterTimestamp = order.validAfterTimestamp;\\n        orderType = decodeType(internalType);\\n    }\\n\\n    function getOrderStatus(Data storage data, uint256 orderId) external view returns (OrderStatus orderStatus) {\\n        if (orderId > data.newestOrderId) {\\n            return OrderStatus.NonExistent;\\n        }\\n        if (data.canceled[orderId]) {\\n            return OrderStatus.Canceled;\\n        }\\n        if (isRefundFailed(data, orderId)) {\\n            return OrderStatus.ExecutedFailed;\\n        }\\n        (OrderType orderType, uint32 validAfterTimestamp) = getOrder(data, orderId);\\n        if (orderType == OrderType.Empty) {\\n            return OrderStatus.ExecutedSucceeded;\\n        }\\n        if (validAfterTimestamp >= block.timestamp) {\\n            return OrderStatus.EnqueuedWaiting;\\n        }\\n        return OrderStatus.EnqueuedReady;\\n    }\\n\\n    function getPair(\\n        Data storage data,\\n        address tokenA,\\n        address tokenB\\n    )\\n        internal\\n        returns (\\n            address pair,\\n            uint32 pairId,\\n            bool inverted\\n        )\\n    {\\n        inverted = tokenA > tokenB;\\n        (address token0, address token1) = inverted ? (tokenB, tokenA) : (tokenA, tokenB);\\n        pair = ITwapFactory(data.factory).getPair(token0, token1);\\n        require(pair != address(0), 'OS17');\\n        pairId = uint32(bytes4(keccak256(abi.encodePacked(pair))));\\n        if (data.pairs[pairId].pair == address(0)) {\\n            data.pairs[pairId] = PairInfo(pair, token0, token1);\\n        }\\n    }\\n\\n    function getPairInfo(Data storage data, uint32 pairId)\\n        external\\n        view\\n        returns (\\n            address pair,\\n            address token0,\\n            address token1\\n        )\\n    {\\n        PairInfo storage info = data.pairs[pairId];\\n        pair = info.pair;\\n        token0 = info.token0;\\n        token1 = info.token1;\\n    }\\n\\n    function getDepositDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & DEPOSIT_MASK != 0;\\n    }\\n\\n    function getWithdrawDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & WITHDRAW_MASK != 0;\\n    }\\n\\n    function getSellDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & SELL_MASK != 0;\\n    }\\n\\n    function getBuyDisabled(Data storage data, address pair) public view returns (bool) {\\n        return data.orderDisabled[pair] & BUY_MASK != 0;\\n    }\\n\\n    function getDepositOrder(Data storage data, uint256 index) public view returns (DepositOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == DEPOSIT_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.share0 = stored.value0;\\n        order.share1 = stored.value1;\\n        order.minSwapPrice = float32ToUint(stored.minSwapPrice);\\n        order.maxSwapPrice = float32ToUint(stored.maxSwapPrice);\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.swap = stored.swap;\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n        order.timestamp = stored.timestamp;\\n    }\\n\\n    function getWithdrawOrder(Data storage data, uint256 index) public view returns (WithdrawOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == WITHDRAW_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.liquidity = stored.liquidity;\\n        order.amount0Min = stored.value0;\\n        order.amount1Min = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n    }\\n\\n    function getSellOrder(Data storage data, uint256 index) public view returns (SellOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == SELL_TYPE || stored.orderType == SELL_INVERTED_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == SELL_INVERTED_TYPE;\\n        order.shareIn = stored.value0;\\n        order.amountOutMin = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n        order.timestamp = stored.timestamp;\\n    }\\n\\n    function getBuyOrder(Data storage data, uint256 index) public view returns (BuyOrder memory order) {\\n        StoredOrder memory stored = data.orderQueue[index];\\n        require(stored.orderType == BUY_TYPE || stored.orderType == BUY_INVERTED_TYPE, 'OS32');\\n        order.pairId = stored.pairId;\\n        order.inverse = stored.orderType == BUY_INVERTED_TYPE;\\n        order.shareInMax = stored.value0;\\n        order.amountOut = stored.value1;\\n        order.unwrap = getUnwrap(stored.unwrapAndFailure);\\n        order.to = stored.to;\\n        order.gasPrice = uint32ToGasPrice(stored.gasPrice);\\n        order.gasLimit = stored.gasLimit;\\n        order.validAfterTimestamp = stored.validAfterTimestamp;\\n        order.timestamp = stored.timestamp;\\n        order.priceAccumulator = stored.priceAccumulator;\\n    }\\n\\n    function getFailedOrderType(Data storage data, uint256 orderId)\\n        external\\n        view\\n        returns (OrderType orderType, uint32 validAfterTimestamp)\\n    {\\n        require(isRefundFailed(data, orderId), 'OS21');\\n        (orderType, validAfterTimestamp) = getOrder(data, orderId);\\n    }\\n\\n    function getUnwrap(uint8 unwrapAndFailure) private pure returns (bool) {\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == UNWRAP_NOT_FAILED;\\n    }\\n\\n    function getUnwrapAndFailure(bool unwrap) private pure returns (uint8) {\\n        return unwrap ? UNWRAP_NOT_FAILED : KEEP_NOT_FAILED;\\n    }\\n\\n    function timestampToUint32(uint256 timestamp) private pure returns (uint32 timestamp32) {\\n        if (timestamp == type(uint256).max) {\\n            return type(uint32).max;\\n        }\\n        timestamp32 = timestamp.toUint32();\\n    }\\n\\n    function gasPriceToUint32(uint256 gasPrice) private pure returns (uint32 gasPrice32) {\\n        require((gasPrice / 1e6) * 1e6 == gasPrice, 'OS3C');\\n        gasPrice32 = (gasPrice / 1e6).toUint32();\\n    }\\n\\n    function uint32ToGasPrice(uint32 gasPrice32) public pure returns (uint256 gasPrice) {\\n        gasPrice = uint256(gasPrice32) * 1e6;\\n    }\\n\\n    function uintToFloat32(uint256 number) internal pure returns (uint32 float32) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // If the number fits in the mantissa we set the exponent to zero and return.\\n        if (number < 2 << 24) {\\n            return uint32(number << 8);\\n        }\\n        // We find the exponent by counting the number of trailing zeroes.\\n        // Simultaneously we remove those zeroes from the number.\\n        uint32 exponent;\\n        for (exponent = 0; exponent < 256 - 24; exponent++) {\\n            // Last bit is one.\\n            if (number & 1 == 1) {\\n                break;\\n            }\\n            number = number >> 1;\\n        }\\n        // The number must fit in the mantissa.\\n        require(number < 2 << 24, 'OS1A');\\n        // Set the first three bytes to the number and the fourth to the exponent.\\n        float32 = uint32(number << 8) | exponent;\\n    }\\n\\n    function float32ToUint(uint32 float32) internal pure returns (uint256 number) {\\n        // Number is encoded on 4 bytes. 3 bytes for mantissa and 1 for exponent.\\n        // We get the exponent by extracting the last byte.\\n        uint256 exponent = float32 & 0xFF;\\n        // Sanity check. Only triggered for values not encoded with uintToFloat32.\\n        require(exponent <= 256 - 24, 'OS1B');\\n        // We get the mantissa by extracting the first three bytes and removing the fourth.\\n        uint256 mantissa = (float32 & 0xFFFFFF00) >> 8;\\n        // We add exponent number zeroes after the mantissa.\\n        number = mantissa << exponent;\\n    }\\n\\n    function setOrderDisabled(\\n        Data storage data,\\n        address pair,\\n        Orders.OrderType orderType,\\n        bool disabled\\n    ) external {\\n        require(orderType != Orders.OrderType.Empty, 'OS32');\\n        uint8 currentSettings = data.orderDisabled[pair];\\n\\n        // zeros with 1 bit set at position specified by orderType\\n        uint8 mask = uint8(1) << uint8(orderType);\\n\\n        // set/unset a bit accordingly to 'disabled' value\\n        if (disabled) {\\n            // OR operation to disable order\\n            // e.g. for disable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // mask for DEPOSIT  = 00000010\\n            // the result of OR  = 00010110\\n            currentSettings = currentSettings | mask;\\n        } else {\\n            // AND operation with a mask negation to enable order\\n            // e.g. for enable DEPOSIT\\n            // currentSettings   = 00010100 (BUY and WITHDRAW disabled)\\n            // 0xff              = 11111111\\n            // mask for Deposit  = 00000010\\n            // mask negation     = 11111101\\n            // the result of AND = 00010100\\n            currentSettings = currentSettings & (mask ^ 0xff);\\n        }\\n        require(currentSettings != data.orderDisabled[pair], 'OS01');\\n        data.orderDisabled[pair] = currentSettings;\\n\\n        emit OrderDisabled(pair, orderType, disabled);\\n    }\\n\\n    function enqueueDepositOrder(Data storage data, DepositOrder memory depositOrder) internal {\\n        data.newestOrderId++;\\n        emit DepositEnqueued(data.newestOrderId, depositOrder.validAfterTimestamp, depositOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            DEPOSIT_TYPE,\\n            depositOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(depositOrder.unwrap),\\n            depositOrder.timestamp,\\n            depositOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(depositOrder.gasPrice),\\n            0, // liquidity\\n            depositOrder.share0.toUint112(),\\n            depositOrder.share1.toUint112(),\\n            depositOrder.pairId,\\n            depositOrder.to,\\n            uintToFloat32(depositOrder.minSwapPrice),\\n            uintToFloat32(depositOrder.maxSwapPrice),\\n            depositOrder.swap,\\n            depositOrder.priceAccumulator\\n        );\\n    }\\n\\n    function enqueueWithdrawOrder(Data storage data, WithdrawOrder memory withdrawOrder) internal {\\n        data.newestOrderId++;\\n        emit WithdrawEnqueued(data.newestOrderId, withdrawOrder.validAfterTimestamp, withdrawOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            WITHDRAW_TYPE,\\n            withdrawOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(withdrawOrder.unwrap),\\n            0, // timestamp\\n            withdrawOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(withdrawOrder.gasPrice),\\n            withdrawOrder.liquidity.toUint112(),\\n            withdrawOrder.amount0Min.toUint112(),\\n            withdrawOrder.amount1Min.toUint112(),\\n            withdrawOrder.pairId,\\n            withdrawOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            0 // priceAccumulator\\n        );\\n    }\\n\\n    function enqueueSellOrder(Data storage data, SellOrder memory sellOrder) internal {\\n        data.newestOrderId++;\\n        emit SellEnqueued(data.newestOrderId, sellOrder.validAfterTimestamp, sellOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            sellOrder.inverse ? SELL_INVERTED_TYPE : SELL_TYPE,\\n            sellOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(sellOrder.unwrap),\\n            sellOrder.timestamp,\\n            sellOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(sellOrder.gasPrice),\\n            0, // liquidity\\n            sellOrder.shareIn.toUint112(),\\n            sellOrder.amountOutMin.toUint112(),\\n            sellOrder.pairId,\\n            sellOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            sellOrder.priceAccumulator\\n        );\\n    }\\n\\n    function enqueueBuyOrder(Data storage data, BuyOrder memory buyOrder) internal {\\n        data.newestOrderId++;\\n        emit BuyEnqueued(data.newestOrderId, buyOrder.validAfterTimestamp, buyOrder.gasPrice);\\n        data.orderQueue[data.newestOrderId] = StoredOrder(\\n            buyOrder.inverse ? BUY_INVERTED_TYPE : BUY_TYPE,\\n            buyOrder.validAfterTimestamp,\\n            getUnwrapAndFailure(buyOrder.unwrap),\\n            buyOrder.timestamp,\\n            buyOrder.gasLimit.toUint32(),\\n            gasPriceToUint32(buyOrder.gasPrice),\\n            0, // liquidity\\n            buyOrder.shareInMax.toUint112(),\\n            buyOrder.amountOut.toUint112(),\\n            buyOrder.pairId,\\n            buyOrder.to,\\n            0, // minSwapPrice\\n            0, // maxSwapPrice\\n            false, // swap\\n            buyOrder.priceAccumulator\\n        );\\n    }\\n\\n    function isRefundFailed(Data storage data, uint256 index) internal view returns (bool) {\\n        uint8 unwrapAndFailure = data.orderQueue[index].unwrapAndFailure;\\n        return unwrapAndFailure == UNWRAP_FAILED || unwrapAndFailure == KEEP_FAILED;\\n    }\\n\\n    function markRefundFailed(Data storage data) internal {\\n        StoredOrder storage stored = data.orderQueue[data.lastProcessedOrderId];\\n        stored.unwrapAndFailure = stored.unwrapAndFailure == UNWRAP_NOT_FAILED ? UNWRAP_FAILED : KEEP_FAILED;\\n    }\\n\\n    function getNextOrder(Data storage data) internal view returns (OrderType orderType, uint256 validAfterTimestamp) {\\n        return getOrder(data, data.lastProcessedOrderId + 1);\\n    }\\n\\n    function dequeueCanceledOrder(Data storage data) external {\\n        data.lastProcessedOrderId++;\\n    }\\n\\n    function dequeueDepositOrder(Data storage data) external returns (DepositOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getDepositOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueWithdrawOrder(Data storage data) external returns (WithdrawOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getWithdrawOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueSellOrder(Data storage data) external returns (SellOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getSellOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function dequeueBuyOrder(Data storage data) external returns (BuyOrder memory order) {\\n        data.lastProcessedOrderId++;\\n        order = getBuyOrder(data, data.lastProcessedOrderId);\\n    }\\n\\n    function forgetOrder(Data storage data, uint256 orderId) internal {\\n        delete data.orderQueue[orderId];\\n    }\\n\\n    function forgetLastProcessedOrder(Data storage data) internal {\\n        delete data.orderQueue[data.lastProcessedOrderId];\\n    }\\n\\n    struct DepositParams {\\n        address token0;\\n        address token1;\\n        uint256 amount0;\\n        uint256 amount1;\\n        uint256 minSwapPrice;\\n        uint256 maxSwapPrice;\\n        bool wrap;\\n        bool swap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function deposit(\\n        Data storage data,\\n        DepositParams calldata depositParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 token0TransferCost = data.transferGasCosts[depositParams.token0];\\n        uint256 token1TransferCost = data.transferGasCosts[depositParams.token1];\\n        require(token0TransferCost != 0 && token1TransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            depositParams.to,\\n            depositParams.gasLimit,\\n            depositParams.submitDeadline,\\n            ORDER_BASE_COST.add(token0TransferCost).add(token1TransferCost)\\n        );\\n        require(depositParams.amount0 != 0 || depositParams.amount1 != 0, 'OS25');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, depositParams.token0, depositParams.token1);\\n        require(!getDepositDisabled(data, pairAddress), 'OS46');\\n        {\\n            // scope for value, avoids stack too deep errors\\n            uint256 value = msg.value;\\n\\n            // allocate gas refund\\n            if (depositParams.wrap) {\\n                if (depositParams.token0 == tokenShares.weth) {\\n                    value = value.sub(depositParams.amount0, 'OS1E');\\n                } else if (depositParams.token1 == tokenShares.weth) {\\n                    value = value.sub(depositParams.amount1, 'OS1E');\\n                }\\n            }\\n            allocateGasRefund(data, value, depositParams.gasLimit);\\n        }\\n\\n        uint256 shares0 = tokenShares.amountToShares(depositParams.token0, depositParams.amount0, depositParams.wrap);\\n        uint256 shares1 = tokenShares.amountToShares(depositParams.token1, depositParams.amount1, depositParams.wrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueDepositOrder(\\n            data,\\n            DepositOrder(\\n                pairId,\\n                inverted ? shares1 : shares0,\\n                inverted ? shares0 : shares1,\\n                depositParams.minSwapPrice,\\n                depositParams.maxSwapPrice,\\n                depositParams.wrap,\\n                depositParams.swap,\\n                depositParams.to,\\n                data.gasPrice,\\n                depositParams.gasLimit,\\n                timestamp + data.delay, // validAfterTimestamp\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    struct WithdrawParams {\\n        address token0;\\n        address token1;\\n        uint256 liquidity;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        bool unwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function withdraw(Data storage data, WithdrawParams calldata withdrawParams) external {\\n        (address pair, uint32 pairId, bool inverted) = getPair(data, withdrawParams.token0, withdrawParams.token1);\\n        require(!getWithdrawDisabled(data, pair), 'OS0A');\\n        checkOrderParams(\\n            data,\\n            withdrawParams.to,\\n            withdrawParams.gasLimit,\\n            withdrawParams.submitDeadline,\\n            ORDER_BASE_COST.add(PAIR_TRANSFER_COST)\\n        );\\n        require(withdrawParams.liquidity != 0, 'OS22');\\n\\n        allocateGasRefund(data, msg.value, withdrawParams.gasLimit);\\n        pair.safeTransferFrom(msg.sender, address(this), withdrawParams.liquidity);\\n        enqueueWithdrawOrder(\\n            data,\\n            WithdrawOrder(\\n                pairId,\\n                withdrawParams.liquidity,\\n                inverted ? withdrawParams.amount1Min : withdrawParams.amount0Min,\\n                inverted ? withdrawParams.amount0Min : withdrawParams.amount1Min,\\n                withdrawParams.unwrap,\\n                withdrawParams.to,\\n                data.gasPrice,\\n                withdrawParams.gasLimit,\\n                timestampToUint32(block.timestamp) + data.delay\\n            )\\n        );\\n    }\\n\\n    struct SellParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountIn;\\n        uint256 amountOutMin;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function sell(\\n        Data storage data,\\n        SellParams calldata sellParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = data.transferGasCosts[sellParams.tokenIn];\\n        require(tokenTransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            sellParams.to,\\n            sellParams.gasLimit,\\n            sellParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n        require(sellParams.amountIn != 0, 'OS24');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, sellParams.tokenIn, sellParams.tokenOut);\\n        require(!getSellDisabled(data, pairAddress), 'OS13');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (sellParams.tokenIn == tokenShares.weth && sellParams.wrapUnwrap) {\\n            value = value.sub(sellParams.amountIn, 'OS1E');\\n        }\\n        allocateGasRefund(data, value, sellParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(sellParams.tokenIn, sellParams.amountIn, sellParams.wrapUnwrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueSellOrder(\\n            data,\\n            SellOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                sellParams.amountOutMin,\\n                sellParams.wrapUnwrap,\\n                sellParams.to,\\n                data.gasPrice,\\n                sellParams.gasLimit,\\n                timestamp + data.delay,\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    struct BuyParams {\\n        address tokenIn;\\n        address tokenOut;\\n        uint256 amountInMax;\\n        uint256 amountOut;\\n        bool wrapUnwrap;\\n        address to;\\n        uint256 gasLimit;\\n        uint32 submitDeadline;\\n    }\\n\\n    function buy(\\n        Data storage data,\\n        BuyParams calldata buyParams,\\n        TokenShares.Data storage tokenShares\\n    ) external {\\n        uint256 tokenTransferCost = data.transferGasCosts[buyParams.tokenIn];\\n        require(tokenTransferCost != 0, 'OS0F');\\n        checkOrderParams(\\n            data,\\n            buyParams.to,\\n            buyParams.gasLimit,\\n            buyParams.submitDeadline,\\n            ORDER_BASE_COST.add(tokenTransferCost)\\n        );\\n        require(buyParams.amountOut != 0, 'OS23');\\n        (address pairAddress, uint32 pairId, bool inverted) = getPair(data, buyParams.tokenIn, buyParams.tokenOut);\\n        require(!getBuyDisabled(data, pairAddress), 'OS49');\\n        uint256 value = msg.value;\\n\\n        // allocate gas refund\\n        if (buyParams.tokenIn == tokenShares.weth && buyParams.wrapUnwrap) {\\n            value = value.sub(buyParams.amountInMax, 'OS1E');\\n        }\\n        allocateGasRefund(data, value, buyParams.gasLimit);\\n\\n        uint256 shares = tokenShares.amountToShares(buyParams.tokenIn, buyParams.amountInMax, buyParams.wrapUnwrap);\\n\\n        (uint256 priceAccumulator, uint32 timestamp) = ITwapOracle(ITwapPair(pairAddress).oracle()).getPriceInfo();\\n        enqueueBuyOrder(\\n            data,\\n            BuyOrder(\\n                pairId,\\n                inverted,\\n                shares,\\n                buyParams.amountOut,\\n                buyParams.wrapUnwrap,\\n                buyParams.to,\\n                data.gasPrice,\\n                buyParams.gasLimit,\\n                timestamp + data.delay,\\n                priceAccumulator,\\n                timestamp\\n            )\\n        );\\n    }\\n\\n    function checkOrderParams(\\n        Data storage data,\\n        address to,\\n        uint256 gasLimit,\\n        uint32 submitDeadline,\\n        uint256 minGasLimit\\n    ) private view {\\n        require(submitDeadline >= block.timestamp, 'OS04');\\n        require(gasLimit <= data.maxGasLimit, 'OS3E');\\n        require(gasLimit >= minGasLimit, 'OS3D');\\n        require(to != address(0), 'OS26');\\n    }\\n\\n    function allocateGasRefund(\\n        Data storage data,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) private returns (uint256 futureFee) {\\n        futureFee = data.gasPrice.mul(gasLimit);\\n        require(value >= futureFee, 'OS1E');\\n        if (value > futureFee) {\\n            TransferHelper.safeTransferETH(msg.sender, value.sub(futureFee), data.transferGasCosts[address(0)]);\\n        }\\n    }\\n\\n    function updateGasPrice(Data storage data, uint256 gasUsed) external {\\n        uint256 scale = Math.min(gasUsed, data.maxGasPriceImpact);\\n        uint256 updated = data.gasPrice.mul(data.gasPriceInertia.sub(scale)).add(tx.gasprice.mul(scale)).div(\\n            data.gasPriceInertia\\n        );\\n        // we lower the precision for gas savings in order queue\\n        data.gasPrice = updated - (updated % 1e6);\\n    }\\n\\n    function setMaxGasLimit(Data storage data, uint256 _maxGasLimit) external {\\n        require(_maxGasLimit != data.maxGasLimit, 'OS01');\\n        require(_maxGasLimit <= 10000000, 'OS2B');\\n        data.maxGasLimit = _maxGasLimit;\\n        emit MaxGasLimitSet(_maxGasLimit);\\n    }\\n\\n    function setGasPriceInertia(Data storage data, uint256 _gasPriceInertia) external {\\n        require(_gasPriceInertia != data.gasPriceInertia, 'OS01');\\n        require(_gasPriceInertia >= 1, 'OS35');\\n        data.gasPriceInertia = _gasPriceInertia;\\n        emit GasPriceInertiaSet(_gasPriceInertia);\\n    }\\n\\n    function setMaxGasPriceImpact(Data storage data, uint256 _maxGasPriceImpact) external {\\n        require(_maxGasPriceImpact != data.maxGasPriceImpact, 'OS01');\\n        require(_maxGasPriceImpact <= data.gasPriceInertia, 'OS33');\\n        data.maxGasPriceImpact = _maxGasPriceImpact;\\n        emit MaxGasPriceImpactSet(_maxGasPriceImpact);\\n    }\\n\\n    function setTransferGasCost(\\n        Data storage data,\\n        address token,\\n        uint256 gasCost\\n    ) external {\\n        require(gasCost != data.transferGasCosts[token], 'OS01');\\n        data.transferGasCosts[token] = gasCost;\\n        emit TransferGasCostSet(token, gasCost);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport './IERC20.sol';\\n\\ninterface ITwapERC20 is IERC20 {\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\\n\\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IReserves.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IReserves {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1);\\n\\n    function getFees() external view returns (uint256 fee0, uint256 fee1);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\\n\\nlibrary SafeMath {\\n    int256 private constant _INT256_MIN = -2**255;\\n\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, 'SM4E');\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = sub(x, y, 'SM12');\\n    }\\n\\n    function sub(\\n        uint256 x,\\n        uint256 y,\\n        string memory message\\n    ) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, message);\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, 'SM2A');\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, 'SM43');\\n        uint256 c = a / b;\\n        return c;\\n    }\\n\\n    function ceil_div(uint256 a, uint256 b) internal pure returns (uint256 c) {\\n        c = div(a, b);\\n        if (c == mul(a, b)) {\\n            return c;\\n        } else {\\n            return add(c, 1);\\n        }\\n    }\\n\\n    function toUint32(uint256 n) internal pure returns (uint32) {\\n        require(n <= type(uint32).max, 'SM50');\\n        return uint32(n);\\n    }\\n\\n    function toUint112(uint256 n) internal pure returns (uint112) {\\n        require(n <= type(uint112).max, 'SM51');\\n        return uint112(n);\\n    }\\n\\n    function toInt256(uint256 unsigned) internal pure returns (int256 signed) {\\n        require(unsigned <= uint256(type(int256).max), 'SM34');\\n        signed = int256(unsigned);\\n    }\\n\\n    // int256\\n\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), 'SM4D');\\n\\n        return c;\\n    }\\n\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), 'SM11');\\n\\n        return c;\\n    }\\n\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), 'SM29');\\n\\n        int256 c = a * b;\\n        require(c / a == b, 'SM29');\\n\\n        return c;\\n    }\\n\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, 'SM43');\\n        require(!(b == -1 && a == _INT256_MIN), 'SM42');\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x > y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface ITwapFactory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\\n    event OwnerSet(address owner);\\n\\n    function owner() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n\\n    function allPairs(uint256) external view returns (address pair);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB,\\n        address oracle,\\n        address trader\\n    ) external returns (address pair);\\n\\n    function setOwner(address) external;\\n\\n    function setMintFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setBurnFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setSwapFee(\\n        address tokenA,\\n        address tokenB,\\n        uint256 fee\\n    ) external;\\n\\n    function setOracle(\\n        address tokenA,\\n        address tokenB,\\n        address oracle\\n    ) external;\\n\\n    function setTrader(\\n        address tokenA,\\n        address tokenB,\\n        address trader\\n    ) external;\\n\\n    function collect(\\n        address tokenA,\\n        address tokenB,\\n        address to\\n    ) external;\\n\\n    function withdraw(\\n        address tokenA,\\n        address tokenB,\\n        uint256 amount,\\n        address to\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITwapOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\ninterface ITwapOracle {\\n    event OwnerSet(address owner);\\n    event UniswapPairSet(address uniswapPair);\\n\\n    function decimalsConverter() external view returns (int256);\\n\\n    function xDecimals() external view returns (uint8);\\n\\n    function yDecimals() external view returns (uint8);\\n\\n    function owner() external view returns (address);\\n\\n    function uniswapPair() external view returns (address);\\n\\n    function getPriceInfo() external view returns (uint256 priceAccumulator, uint32 priceTimestamp);\\n\\n    function getSpotPrice() external view returns (uint256);\\n\\n    function getAveragePrice(uint256 priceAccumulator, uint32 priceTimestamp) external view returns (uint256);\\n\\n    function setOwner(address _owner) external;\\n\\n    function setUniswapPair(address _uniswapPair) external;\\n\\n    function tradeX(\\n        uint256 xAfter,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yAfter);\\n\\n    function tradeY(\\n        uint256 yAfter,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xAfter);\\n\\n    function depositTradeXIn(\\n        uint256 xLeft,\\n        uint256 xBefore,\\n        uint256 yBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 xIn);\\n\\n    function depositTradeYIn(\\n        uint256 yLeft,\\n        uint256 yBefore,\\n        uint256 xBefore,\\n        bytes calldata data\\n    ) external view returns (uint256 yIn);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TokenShares.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\nimport '../interfaces/IERC20.sol';\\nimport '../interfaces/IWETH.sol';\\nimport './SafeMath.sol';\\nimport './TransferHelper.sol';\\n\\nlibrary TokenShares {\\n    using SafeMath for uint256;\\n    using TransferHelper for address;\\n\\n    event UnwrapFailed(address to, uint256 amount);\\n\\n    struct Data {\\n        mapping(address => uint256) totalShares;\\n        address weth;\\n    }\\n\\n    function setWeth(Data storage data, address _weth) internal {\\n        data.weth = _weth;\\n    }\\n\\n    function sharesToAmount(\\n        Data storage data,\\n        address token,\\n        uint256 share\\n    ) external returns (uint256) {\\n        if (share == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            return share;\\n        }\\n        uint256 totalTokenShares = data.totalShares[token];\\n        require(totalTokenShares >= share, 'TS3A');\\n        uint256 balance = IERC20(token).balanceOf(address(this));\\n        uint256 value = balance.mul(share).div(totalTokenShares);\\n        data.totalShares[token] = totalTokenShares.sub(share);\\n        return value;\\n    }\\n\\n    function amountToShares(\\n        Data storage data,\\n        address token,\\n        uint256 amount,\\n        bool wrap\\n    ) external returns (uint256) {\\n        if (amount == 0) {\\n            return 0;\\n        }\\n        if (token == data.weth) {\\n            if (wrap) {\\n                require(msg.value >= amount, 'TS03');\\n                IWETH(token).deposit{ value: amount }();\\n            } else {\\n                token.safeTransferFrom(msg.sender, address(this), amount);\\n            }\\n            return amount;\\n        } else {\\n            uint256 balanceBefore = IERC20(token).balanceOf(address(this));\\n            uint256 totalTokenShares = data.totalShares[token];\\n            require(balanceBefore > 0 || totalTokenShares == 0, 'TS30');\\n            if (totalTokenShares == 0) {\\n                totalTokenShares = balanceBefore;\\n            }\\n            token.safeTransferFrom(msg.sender, address(this), amount);\\n            uint256 balanceAfter = IERC20(token).balanceOf(address(this));\\n            require(balanceAfter > balanceBefore, 'TS2C');\\n            if (balanceBefore > 0) {\\n                uint256 newShares = totalTokenShares.mul(balanceAfter).div(balanceBefore);\\n                data.totalShares[token] = newShares;\\n                return newShares - totalTokenShares;\\n            } else {\\n                data.totalShares[token] = balanceAfter;\\n                return balanceAfter;\\n            }\\n        }\\n    }\\n\\n    function onUnwrapFailed(\\n        Data storage data,\\n        address to,\\n        uint256 amount\\n    ) external {\\n        emit UnwrapFailed(to, amount);\\n        IWETH(data.weth).deposit{ value: amount }();\\n        TransferHelper.safeTransfer(data.weth, to, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n// Deployed with donations via Gitcoin GR9\\n\\npragma solidity 0.7.6;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH4B');\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH05');\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TH0E');\\n    }\\n\\n    function safeTransferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal {\\n        (bool success, ) = to.call{ value: value, gas: gasLimit }('');\\n        require(success, 'TH3F');\\n    }\\n\\n    function transferETH(\\n        address to,\\n        uint256 value,\\n        uint256 gasLimit\\n    ) internal returns (bool success) {\\n        (success, ) = to.call{ value: value, gas: gasLimit }('');\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[]", "ContractName": "WithdrawHelper", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}