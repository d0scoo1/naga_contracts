{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.6.0 <0.8.2;\r\n\r\n\r\n//import \"hardhat/console.sol\";\r\n\r\nabstract contract ERC20 {\r\n  function balanceOf(address a) public view virtual returns (uint256);  \r\n}\r\n\r\ncontract Vinyl {\r\n  address admin_address;\r\n  uint256 public totalEarned; //amount due to store owner\r\n  uint256 public numOrders; //max order num\r\n  uint256 public startOrderNum; //max order num  \r\n  uint32 public numProducts; //max products\r\n  bool public purchasesDisabled;\r\n\r\n  uint256 public refund_percent; //percentage to refund when leaving the queue\r\n  \r\n  event ePurchased(uint256 oid);\r\n  event eRefund(uint256 oid, uint256 amount);\r\n  event eBoost(uint256 oid);  \r\n  event eShipped(uint256 oid);\r\n  \r\n  struct ProductStruct {\r\n    uint256 price;\r\n    uint256 supply;\r\n  }\r\n\r\n  struct AccessStruct {\r\n    ERC20 econtract;\r\n    uint256 minRequired;\r\n    bool enabled;\r\n  }\r\n    \r\n  ProductStruct[32] public products;\r\n  AccessStruct[16] public accessProfiles;\r\n  \r\n  struct OrderStruct {\r\n    uint32 state; //0 pending, 1 in progress, 2 filled, 3 refunded\r\n    uint32 pid; //product id    \r\n    uint256 boostAmount; //premium staked for order queue\r\n    uint256 paidAmount; //amount paid for order\r\n    address owner;\r\n  }\r\n  \r\n  mapping(uint256 => OrderStruct) orders;\r\n\r\n  modifier requireAdmin() {\r\n    require(admin_address == msg.sender,\"Requires admin privileges\");\r\n    _;\r\n  }\r\n\r\n  modifier requireOwner(uint256 oid) {\r\n    if (oid >= numOrders) {\r\n      revert(\"Order ID out of range\");\r\n    }\r\n    \r\n    require(msg.sender == orders[oid].owner,\"Not owner of order\");\r\n    _;\r\n  }\r\n\r\n  modifier requireOwnerOrAdmin(uint256 oid) {\r\n    if (oid >= numOrders) {\r\n      revert(\"Order ID out of range\");\r\n    }\r\n    \r\n    require(msg.sender == orders[oid].owner ||\r\n\t    admin_address == msg.sender,\"Not owner or admin\");\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    startOrderNum = 0;  //ethereum        \r\n    //startOrderNum = 10000;  //arbitrum    \r\n    //startOrderNum = 20000;  //polygon\r\n\r\n    numOrders = startOrderNum;\r\n    \r\n    admin_address = msg.sender;\r\n    refund_percent = 100;\r\n  }\r\n\r\n  function numOrdersByAddress(address a) public view returns (uint32) {\r\n    uint32 n = 0;\r\n    for (uint256 i = startOrderNum; i<numOrders;i++) {\r\n      if (orders[i].owner == a) {\r\n\tn++;\r\n      }\r\n    }\r\n    return n;\r\n  }\r\n  \r\n  function orderByAddress(address a,uint32 j) public view returns(uint256) {\r\n    if (j >= numOrdersByAddress(a)) {\r\n      revert(\"Order index out of range\");\r\n    }\r\n    \r\n    uint32 n = 0;\r\n    uint256 oid = 0;\r\n    \r\n    for (uint256 i = startOrderNum;i<numOrders;i++) {\r\n      if (orders[i].owner == a) {\r\n\tif (j==n) {\r\n\t  oid = i;\r\n\t  break;\r\n\t}\r\n\tn++;\r\n      }\r\n    }\r\n    return oid;\r\n  }  \r\n  \r\n  function orderDetails(uint256 oid) public view returns (uint32 state, uint32 pid, uint256 boostAmount, uint256 paidAmount, address owner) {\r\n    require(oid < numOrders,\"Order id not in range\");\r\n    state = orders[oid].state;\r\n    pid = orders[oid].pid;\r\n    boostAmount = orders[oid].boostAmount;\r\n    paidAmount = orders[oid].paidAmount;\r\n    owner = orders[oid].owner;\r\n\r\n    //TODO get place in queue\r\n  }\r\n\r\n  /* only allow access to addresses holding a minimum\r\n     number of ERC20 or ERC721 token */\r\n  function check_elligible(address a) public view returns (bool) {\r\n    bool flag = true;\r\n    for (uint256 i = 0;i<16;i++) {\r\n      if (!accessProfiles[i].enabled) continue;\r\n      if (accessProfiles[i].econtract.balanceOf(a) >=\r\n\t  accessProfiles[i].minRequired) {\r\n\treturn true;\r\n      } else {\r\n\tflag = false;\r\n      }\r\n    }\r\n    return flag;\r\n  }\r\n  \r\n  function purchase(uint32 pid) public payable returns(uint256) {\r\n    require(pid < numProducts, \"Invalid product id\");\r\n    require(products[pid].supply > 0, \"Sold Out\");\r\n    \r\n    require(!purchasesDisabled,\"Purchases disabled\");\r\n    require(msg.value>=products[pid].price, \"Must send minimum value to purchase!\");\r\n    if (!check_elligible(msg.sender)) {\r\n      revert(\"Not elligible.\");\r\n    }\r\n\r\n    //i\r\n    //send change if too much was sent\r\n    if (msg.value > 0) {\r\n      uint256 diff = msg.value - products[pid].price;\r\n      if (diff > 0) {\r\n\tpayable(msg.sender).transfer(diff);\r\n      }\r\n    }\r\n    \r\n    //create an order for address together with 'pid'\r\n    orders[numOrders].paidAmount = products[pid].price;\r\n    orders[numOrders].pid = pid;\r\n    orders[numOrders].owner = msg.sender;\r\n\r\n    if (msg.value > 0) {\r\n      uint256 diff = msg.value - products[pid].price;\r\n      if (diff > 0) {\r\n\torders[numOrders].boostAmount = diff;\r\n      }\r\n    }\r\n    \r\n    uint256 oid = numOrders;\r\n    numOrders++;\r\n    products[pid].supply--;\r\n    \r\n    emit ePurchased(oid);\r\n    return oid;\r\n  }\r\n\r\n  function refund(uint32 oid) public payable requireOwnerOrAdmin(oid) {\r\n    require(orders[oid].state==0, \"Order not in refundable state\");\r\n\r\n    //sets order state to refunded    \r\n    orders[oid].state = 3; \r\n\r\n    // refund 95 percent of initial purchase price\r\n    // as well as any premium payed for order queue\r\n    \r\n    uint256 amount_to_refund = orders[oid].paidAmount;\r\n    if (msg.sender != admin_address) {\r\n      // if admin is forcing refund, refund 100% rather than 95%\r\n      if (refund_percent < 100) {\r\n\tamount_to_refund /= 100;\r\n\tamount_to_refund *= refund_percent;\r\n      }\r\n    }\r\n    \r\n    //keep refund_percent% cancellation fee\r\n    totalEarned += (orders[oid].paidAmount - amount_to_refund);\r\n//  console.log(\"Keeping %d\",totalEarned);\r\n\r\n//  console.log(\"Refunding %d\",amount_to_refund);    \r\n    amount_to_refund += orders[oid].boostAmount;\r\n\r\n//    console.log(\"Refunding total: %d\",amount_to_refund);\r\n\r\n    emit eRefund(oid,amount_to_refund);\r\n    \r\n    payable(orders[oid].owner).transfer(amount_to_refund);\r\n  }\r\n\r\n  function boost(uint32 oid) public payable requireOwner(oid) {\r\n    require(orders[oid].state==0, \"Order must be in pending state\");    \r\n    //store ether in contract for order 'oid', to determine\r\n    //place in queue\r\n    orders[oid].boostAmount += msg.value;\r\n\r\n    emit eBoost(oid);\r\n  }\r\n\r\n  function unboost(uint32 oid, uint256 amount) public payable requireOwner(oid) {\r\n    require(orders[oid].state==0, \"Order must be in pending state\");\r\n    require(amount <= orders[oid].boostAmount,\"Limit exceeded\");\r\n    require(amount > 0,\"Amount must be more than 0\");\r\n    \r\n    orders[oid].boostAmount -= amount;\r\n    payable(msg.sender).transfer(amount); //refund boosted amount\r\n\r\n    emit eBoost(oid);    \r\n  }\r\n\r\n  //check what address owns orderID  \r\n  function ownerOf(uint256 oid) public view returns(address) {\r\n    return orders[oid].owner;\r\n  }\r\n\r\n  //returns all orders numbers for a particular owner;\r\n  function ordersByOwner(address a) public view returns (uint256[] memory) {\r\n    uint256 [] memory q;\r\n\r\n    uint256 num;\r\n    for (uint256 i = startOrderNum; i<numOrders;i++) {\r\n      if (orders[i].owner != a) continue;\r\n      num++;\r\n    }\r\n    q = new uint256[](num);\r\n    \r\n    uint256 k = 0;\r\n    for (uint256 i = startOrderNum;i<numOrders;i++) {\r\n      if (orders[i].owner != a) continue;      \r\n      q[k] = i;\r\n      k++;\r\n    }\r\n\r\n    return q;\r\n  }\r\n  \r\n  //return sorted by boost amount queue of pending orders\r\n  function queue() public view returns (uint256[] memory) {\r\n    uint256 [] memory q;\r\n    \r\n    uint256 numPending;\r\n    for (uint256 i = startOrderNum;i<numOrders;i++) {\r\n      if (orders[i].state != 0) continue;\r\n      numPending++;\r\n    }\r\n    q = new uint256[](numPending);\r\n    \r\n    uint256 k = 0;\r\n    for (uint256 i = startOrderNum;i<numOrders;i++) {\r\n      if (orders[i].state != 0) continue;\r\n      q[k] = i;\r\n      k++;\r\n    }\r\n    \r\n    //sort in place based on boost value\r\n\r\n    if (numPending > 1) {\r\n      bool flag;    \r\n      do {\r\n\tflag = false;\r\n\tfor (uint256 i = 0;i<numPending-1;i++) {\r\n\t  if (orders[q[i]].boostAmount < orders[q[i+1]].boostAmount) {\r\n\t    uint256 tmp = q[i];\r\n\t    q[i] = q[i+1];\r\n\t    q[i+1] = tmp;\r\n\t    flag = true;\r\n\t  }\r\n\t}\r\n      } while (flag==true);\r\n    }\r\n    \r\n    return q;\r\n  }\r\n  \r\n  //get order ids and staked amounts for top 2 active queue positions\r\n  function topQueue() public view returns(uint256 oid1, uint256 oid2, uint256 amount1, uint256 amount2) {\r\n    uint256 m1 = 0; //largest boost\r\n    uint256 m2 = 0;    \r\n    uint256 mi1 = 0; // largest boost index\r\n    uint256 mi2 = 0;    \r\n\r\n    //if only 1 order, premium paid is 0\r\n    if (numOrders >= 2) {\r\n      for (uint256 i = startOrderNum;i<numOrders;i++) {\r\n\tif (orders[i].state != 0) continue;\r\n      \r\n\tif (orders[i].boostAmount > m1) {\r\n\t  m2 = m1;\r\n\t  mi2 = mi1;\r\n\t  m1 = orders[i].boostAmount;\r\n\t  mi1 = i;\r\n\t} else if (orders[i].boostAmount > m2) {\r\n\t  m2 = orders[i].boostAmount;\r\n\t  mi2 = i;\r\n\t}\r\n      }\r\n    }\r\n    \r\n    oid1 = mi1;\r\n    oid2 = mi2;\r\n    amount1 = m1;\r\n    amount2 = m2;\r\n  }\r\n\r\n  \r\n  function setAccessProfileEnabled(uint32 oid, bool enabled) public requireAdmin {\r\n    require(oid < 16,\"Index out of range\");\r\n    accessProfiles[oid].enabled = enabled;\r\n  }\r\n\r\n  function setStoreEnabled(bool enabled) public requireAdmin {\r\n    purchasesDisabled = !enabled;\r\n  }\r\n\r\n  function setRefundPercent(uint256 rp) public requireAdmin {\r\n    refund_percent = rp;\r\n  }\r\n\r\n  function setAccessProfile(uint32 oid, address a, uint256 minRequired, bool enabled) public requireAdmin {\r\n    accessProfiles[oid].econtract = ERC20(a);\r\n    accessProfiles[oid].minRequired = minRequired;\r\n    accessProfiles[oid].enabled = enabled;\r\n  }\r\n\r\n  //change an order to in progress, taking payment\r\n  function setShipped(uint32[] memory oids) public requireAdmin {\r\n    for (uint i=0;i<oids.length;i++) {\r\n      uint32 oid = oids[i];\r\n      if (oid >= numOrders) continue;\r\n      if(orders[oid].state != 0) continue;\r\n\r\n      //add amount paid plus differential boost amount to earned stack\r\n      totalEarned += orders[oid].paidAmount;\r\n      totalEarned += orders[oid].boostAmount;\r\n\r\n      orders[oid].state = 2; //finalize order\r\n      emit eShipped(oid);\r\n    }\r\n  }\r\n  \r\n  function setNumProducts(uint32 n) public requireAdmin {\r\n    numProducts = n;\r\n  }\r\n\r\n  /* sets details of a product (currently only price is stored on-chain) */\r\n  function setProduct(uint32 pid,uint256 price,uint256 supply) public requireAdmin {\r\n    require(pid<numProducts,\"Product ID out of range\");\r\n    products[pid].price = price;\r\n    products[pid].supply = supply;\r\n  }\r\n\r\n  /* Shop owner can only withdraw from the stack 'totalEarned',\r\n     which tracks the value of orders that have gone into the 'in progress' state */\r\n  \r\n  function withdraw(uint256 amount) public payable requireAdmin {\r\n    require(amount <= totalEarned,\"Earned limit exceeded\");\r\n    require(amount <= address(this).balance,\"Insufficient funds to withdraw\");\r\n    totalEarned -= amount;\r\n    payable(msg.sender).transfer(amount);\r\n  }\r\n\r\n  //in case of screw up, allow totalEarned to be adjusted,\r\n  // but only DOWNWARD \r\n  function adjustTotalEarned(uint256 t) public requireAdmin {\r\n    require (t < totalEarned,\"Can only adjust down\");\r\n    totalEarned = t;\r\n  }\r\n  \r\n  /* All showopner to make deposits in case of screw up to allow\r\n     those in queue to refund themselves */\r\n  \r\n  function deposit() public payable requireAdmin {\r\n  }\r\n  \r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"eBoost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"ePurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"eRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"eShipped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"accessProfiles\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"econtract\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minRequired\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"adjustTotalEarned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"oid\",\"type\":\"uint32\"}],\"name\":\"boost\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"check_elligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"numOrdersByAddress\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numProducts\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"j\",\"type\":\"uint32\"}],\"name\":\"orderByAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"orderDetails\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"state\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"pid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"boostAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paidAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"ordersByOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"oid\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"products\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"pid\",\"type\":\"uint32\"}],\"name\":\"purchase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"purchasesDisabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queue\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"oid\",\"type\":\"uint32\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refund_percent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"oid\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minRequired\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAccessProfile\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"oid\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setAccessProfileEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"n\",\"type\":\"uint32\"}],\"name\":\"setNumProducts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"pid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"}],\"name\":\"setProduct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"rp\",\"type\":\"uint256\"}],\"name\":\"setRefundPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32[]\",\"name\":\"oids\",\"type\":\"uint32[]\"}],\"name\":\"setShipped\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setStoreEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startOrderNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"topQueue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"oid1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oid2\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount2\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"oid\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unboost\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Vinyl", "CompilerVersion": "v0.7.3+commit.9bfce1f6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://977c1903d47bf9137e930055af7a7069c2f301153f003401334ad32a1a41894a"}]}