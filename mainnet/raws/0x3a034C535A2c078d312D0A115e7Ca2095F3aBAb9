{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/SuperglyphsRoyaltiesOverride.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title SuperglyphsRoyaltiesOverride\\n/// @author Simon Fremaux (@dievardump)\\ncontract SuperglyphsRoyaltiesOverride {\\n    address public immutable nftContract;\\n    address public immutable moduleContract;\\n\\n    constructor(address nftContract_, address moduleContract_) {\\n        nftContract = nftContract_;\\n        moduleContract = moduleContract_;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public pure returns (bool) {\\n        return\\n            interfaceId == this.royaltyInfo.selector ||\\n            interfaceId == this.supportsInterface.selector;\\n    }\\n\\n    function royaltyInfo(uint256 tokenId, uint256 value)\\n        public\\n        view\\n        returns (address recipient, uint256 amount)\\n    {\\n        // first get royalties info from the nft contract\\n        (recipient, amount) = SuperglyphsRoyaltiesOverride(nftContract)\\n            .royaltyInfo(tokenId, value);\\n\\n        // if the recipient is the SuperglyphModule itself, this means the token hasn't been frozen\\n        // so we must return the contract owner instead of the contract address\\n        //\\n        // because I have been dumb enough to forget to add withdraw for ERC20 in the contract itself\\n        // meaning: royalties paid in ERC20 (or others) and not in ETH will be locked forever in the contract\\n        //\\n        // I'm hoping to save some of them by creating this override.\\n        // Marketplaces using the RoyaltyRegistry will work\\n        if (recipient == moduleContract) {\\n            recipient = IOwnable(moduleContract).owner();\\n        }\\n    }\\n}\\n\\ninterface IOwnable {\\n    function owner() external view returns (address);\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftContract_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"moduleContract_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"moduleContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}]", "ContractName": "SuperglyphsRoyaltiesOverride", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004d15d2aaa891bfae0824f227f1ef1489cb4191ff00000000000000000000000075fece331197d646aa8aa7094f605083225f87f6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}