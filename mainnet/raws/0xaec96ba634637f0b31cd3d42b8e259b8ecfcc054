{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ChonkyNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {ERC721} from \\\"@solidstate/contracts/token/ERC721/ERC721.sol\\\";\\nimport {ERC721BaseStorage} from \\\"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\\\";\\nimport {OwnableInternal} from \\\"@solidstate/contracts/access/OwnableInternal.sol\\\";\\n\\nimport {VRFConsumerBase} from \\\"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\\\";\\n\\nimport {ChonkyGenomeLib} from \\\"./lib/ChonkyGenomeLib.sol\\\";\\nimport {ChonkyMetadata} from \\\"./ChonkyMetadata.sol\\\";\\nimport {ChonkyNFTStorage} from \\\"./ChonkyNFTStorage.sol\\\";\\nimport {IChonkyNFT} from \\\"./interface/IChonkyNFT.sol\\\";\\n\\ncontract ChonkyNFT is IChonkyNFT, ERC721, VRFConsumerBase, OwnableInternal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n\\n    uint256 internal constant MAX_ELEMENTS = 7777;\\n\\n    // Price per unit if buying < AMOUNT_DISCOUNT_ONE\\n    uint256 internal constant PRICE = 70 * 10**15;\\n    // Price per unit if buying >= AMOUNT_DISCOUNT_ONE\\n    uint256 internal constant PRICE_DISCOUNT_ONE = 65 * 10**15;\\n    // Price per unit if buying MAX_AMOUNT\\n    uint256 internal constant PRICE_DISCOUNT_MAX = 60 * 10**15;\\n\\n    uint256 internal constant AMOUNT_DISCOUNT_ONE = 10;\\n    uint256 internal constant MAX_AMOUNT = 20;\\n\\n    uint256 internal constant RESERVED_AMOUNT = 16;\\n\\n    uint256 internal constant BITS_PER_GENOME = 58;\\n\\n    string internal constant CID =\\n        \\\"QmdafmnRuwqdnYGpVstF6raAqW64AD4i4maDAyvbeVDTGe\\\";\\n\\n    // Chainlink VRF\\n    bytes32 private immutable VRF_KEY_HASH;\\n    uint256 private immutable VRF_FEE;\\n\\n    event CreateChonky(uint256 indexed id);\\n    event RevealInitiated(bytes32 indexed requestId);\\n    event Reveal(uint256 offset);\\n\\n    constructor(\\n        address _vrfCoordinator,\\n        address _link,\\n        bytes32 _vrfKeyHash,\\n        uint256 _vrfFee\\n    ) VRFConsumerBase(_vrfCoordinator, _link) {\\n        VRF_KEY_HASH = _vrfKeyHash;\\n        VRF_FEE = _vrfFee;\\n    }\\n\\n    function mintReserved(uint256 amount) external onlyOwner {\\n        // Mint reserved chonky\\n        for (uint256 i = 0; i < amount; i++) {\\n            _mintChonky(msg.sender);\\n        }\\n    }\\n\\n    function setStartTimestamp(uint256 timestamp) external onlyOwner {\\n        ChonkyNFTStorage.layout().startTimestamp = timestamp;\\n    }\\n\\n    function reveal() external onlyOwner returns (bytes32 requestId) {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        require(l.offset == 0, \\\"Already revealed\\\");\\n\\n        requestId = requestRandomness(VRF_KEY_HASH, VRF_FEE);\\n\\n        emit RevealInitiated(requestId);\\n    }\\n\\n    function fulfillRandomness(bytes32, uint256 randomness) internal override {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        // Set  offset, which reveals the NFTs\\n        l.offset = (randomness % (MAX_ELEMENTS - RESERVED_AMOUNT)) + 1; // We add 1 to ensure offset is not 0 (unrevealed)\\n\\n        emit Reveal(l.offset);\\n    }\\n\\n    function mint() external payable {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        require(\\n            l.startTimestamp > 0 && block.timestamp > l.startTimestamp,\\n            \\\"Minting not started\\\"\\n        );\\n        require(l.currentId < MAX_ELEMENTS, \\\"Sale ended\\\");\\n        require(msg.value <= MAX_AMOUNT * PRICE_DISCOUNT_MAX, \\\"> Max amount\\\");\\n\\n        uint256 count;\\n        if (msg.value >= MAX_AMOUNT * PRICE_DISCOUNT_MAX) {\\n            count = MAX_AMOUNT;\\n        } else if (msg.value >= PRICE_DISCOUNT_ONE * AMOUNT_DISCOUNT_ONE) {\\n            count = msg.value / PRICE_DISCOUNT_ONE;\\n        } else {\\n            count = msg.value / PRICE;\\n        }\\n\\n        require(l.currentId + count <= MAX_ELEMENTS, \\\"Max limit\\\");\\n\\n        for (uint256 i = 0; i < count; i++) {\\n            _mintChonky(msg.sender);\\n        }\\n    }\\n\\n    function _mintChonky(address _to) private {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        uint256 id = l.currentId;\\n        _safeMint(_to, id);\\n        l.currentId += 1;\\n        emit CreateChonky(id);\\n    }\\n\\n    function withdraw(address[] memory _addresses, uint256[] memory _amounts)\\n        public\\n        onlyOwner\\n    {\\n        for (uint256 i = 0; i < _addresses.length; i++) {\\n            _withdraw(_addresses[i], _amounts[i]);\\n        }\\n    }\\n\\n    function parseGenome(uint256 _genome)\\n        external\\n        pure\\n        returns (uint256[12] memory result)\\n    {\\n        return ChonkyGenomeLib.parseGenome(_genome);\\n    }\\n\\n    function formatGenome(uint256[12] memory _attributes)\\n        external\\n        pure\\n        returns (uint256 genome)\\n    {\\n        return ChonkyGenomeLib.formatGenome(_attributes);\\n    }\\n\\n    function getGenome(uint256 _id) external view returns (uint256) {\\n        return _getGenome(_id);\\n    }\\n\\n    function _getGenome(uint256 _id) internal view returns (uint256) {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        uint256 startBit = BITS_PER_GENOME * _id;\\n        uint256 genomeIndex = startBit / 256;\\n\\n        uint256 genome = l.genomes[genomeIndex] >> (startBit % 256);\\n\\n        if ((startBit % 256) + BITS_PER_GENOME <= 256) {\\n            uint256 mask = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff >>\\n                    (256 - BITS_PER_GENOME);\\n            genome &= mask;\\n        } else {\\n            uint256 remainingBits = 256 - (startBit % 256);\\n            uint256 missingBits = BITS_PER_GENOME - remainingBits;\\n            uint256 genomeNext = (l.genomes[genomeIndex + 1] <<\\n                (256 - missingBits)) >> (256 - missingBits - remainingBits);\\n\\n            genome += genomeNext;\\n        }\\n\\n        return genome;\\n    }\\n\\n    function addPackedGenomes(uint256[] memory _genomes) external onlyOwner {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        for (uint256 i = 0; i < _genomes.length; i++) {\\n            l.genomes.push(_genomes[i]);\\n        }\\n    }\\n\\n    function _getGenomeId(uint256 _tokenId) internal view returns (uint256) {\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        // 10000 = Unrevealed\\n        uint256 finalId = 10000;\\n\\n        if (_tokenId < RESERVED_AMOUNT) {\\n            finalId = _tokenId;\\n        } else if (l.offset > 0) {\\n            finalId =\\n                ((_tokenId + l.offset) % (MAX_ELEMENTS - RESERVED_AMOUNT)) +\\n                RESERVED_AMOUNT;\\n        }\\n\\n        return finalId;\\n    }\\n\\n    function tokenURI(uint256 _tokenId)\\n        public\\n        view\\n        override\\n        returns (string memory)\\n    {\\n        require(\\n            ERC721BaseStorage.layout().exists(_tokenId),\\n            \\\"ERC721Metadata: URI query for nonexistent token\\\"\\n        );\\n\\n        ChonkyNFTStorage.Layout storage l = ChonkyNFTStorage.layout();\\n\\n        uint256 genomeId = _getGenomeId(_tokenId);\\n        return\\n            ChonkyMetadata(l.chonkyMetadata).buildTokenURI(\\n                _tokenId,\\n                genomeId,\\n                genomeId == 10000 ? 0 : _getGenome(genomeId),\\n                CID,\\n                l.chonkyAttributes,\\n                l.chonkySet\\n            );\\n    }\\n\\n    function _withdraw(address _address, uint256 _amount) private {\\n        (bool success, ) = _address.call{value: _amount}(\\\"\\\");\\n        require(success, \\\"Transfer failed.\\\");\\n    }\\n\\n    function getChonkyAttributesAddress() external view returns (address) {\\n        return ChonkyNFTStorage.layout().chonkyAttributes;\\n    }\\n\\n    function getChonkyMetadataAddress() external view returns (address) {\\n        return ChonkyNFTStorage.layout().chonkyMetadata;\\n    }\\n\\n    function getChonkySetAddress() external view returns (address) {\\n        return ChonkyNFTStorage.layout().chonkySet;\\n    }\\n\\n    function getCID() external pure returns (string memory) {\\n        return CID;\\n    }\\n\\n    function getStartTimestamp() external view returns (uint256) {\\n        return ChonkyNFTStorage.layout().startTimestamp;\\n    }\\n\\n    function getOffset() external view returns (uint256) {\\n        return ChonkyNFTStorage.layout().offset;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721Base, ERC721BaseInternal } from './base/ERC721Base.sol';\\nimport { ERC721Enumerable } from './enumerable/ERC721Enumerable.sol';\\nimport { ERC721Metadata } from './metadata/ERC721Metadata.sol';\\nimport { ERC165 } from '../../introspection/ERC165.sol';\\n\\n/**\\n * @notice SolidState ERC721 implementation, including recommended extensions\\n */\\nabstract contract ERC721 is\\n    ERC721Base,\\n    ERC721Enumerable,\\n    ERC721Metadata,\\n    ERC165\\n{\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external approve function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override {\\n        require(value == 0, 'ERC721: payable approve calls not supported');\\n        super._handleApproveMessageValue(operator, tokenId, value);\\n    }\\n\\n    /**\\n     * @notice ERC721 hook: revert if value is included in external transfer function call\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual override {\\n        require(value == 0, 'ERC721: payable transfer calls not supported');\\n        super._handleTransferMessageValue(from, to, tokenId, value);\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override(ERC721BaseInternal, ERC721Metadata) {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\n\\nlibrary ERC721BaseStorage {\\n    using EnumerableSet for EnumerableSet.UintSet;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Base');\\n\\n    struct Layout {\\n        EnumerableMap.UintToAddressMap tokenOwners;\\n        mapping(address => EnumerableSet.UintSet) holderTokens;\\n        mapping(uint256 => address) tokenApprovals;\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function exists(Layout storage l, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return l.tokenOwners.contains(tokenId);\\n    }\\n\\n    function totalSupply(Layout storage l) internal view returns (uint256) {\\n        return l.tokenOwners.length();\\n    }\\n\\n    function tokenOfOwnerByIndex(\\n        Layout storage l,\\n        address owner,\\n        uint256 index\\n    ) internal view returns (uint256) {\\n        return l.holderTokens[owner].at(index);\\n    }\\n\\n    function tokenByIndex(Layout storage l, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        (uint256 tokenId, ) = l.tokenOwners.at(index);\\n        return tokenId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { OwnableStorage } from './OwnableStorage.sol';\\n\\nabstract contract OwnableInternal {\\n    using OwnableStorage for OwnableStorage.Layout;\\n\\n    modifier onlyOwner() {\\n        require(\\n            msg.sender == OwnableStorage.layout().owner,\\n            'Ownable: sender must be owner'\\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/LinkTokenInterface.sol\\\";\\n\\nimport \\\"./VRFRequestIDBase.sol\\\";\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\\n * @dev want to generate randomness from.\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomness method.\\n *\\n * @dev The randomness argument to fulfillRandomness is the actual random value\\n * @dev generated from your seed.\\n *\\n * @dev The requestId argument is generated from the keyHash and the seed by\\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\\n * @dev requests open, you can use the requestId to track which seed is\\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\\n * @dev details. (See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.)\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ. (Which is critical to making unpredictable randomness! See the\\n * @dev next section.)\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the ultimate input to the VRF is mixed with the block hash of the\\n * @dev block in which the request is made, user-provided seeds have no impact\\n * @dev on its economic security properties. They are only included for API\\n * @dev compatability with previous versions of this contract.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request.\\n */\\nabstract contract VRFConsumerBase is VRFRequestIDBase {\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBase expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomness the VRF output\\n   */\\n  function fulfillRandomness(bytes32 requestId, uint256 randomness) internal virtual;\\n\\n  /**\\n   * @dev In order to keep backwards compatibility we have kept the user\\n   * seed field around. We remove the use of it because given that the blockhash\\n   * enters later, it overrides whatever randomness the used seed provides.\\n   * Given that it adds no security, and can easily lead to misunderstandings,\\n   * we have removed it from usage and can now provide a simpler API.\\n   */\\n  uint256 private constant USER_SEED_PLACEHOLDER = 0;\\n\\n  /**\\n   * @notice requestRandomness initiates a request for VRF output given _seed\\n   *\\n   * @dev The fulfillRandomness method receives the output, once it's provided\\n   * @dev by the Oracle, and verified by the vrfCoordinator.\\n   *\\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\\n   * @dev the _fee must exceed the fee specified during registration of the\\n   * @dev _keyHash.\\n   *\\n   * @dev The _seed parameter is vestigial, and is kept only for API\\n   * @dev compatibility with older versions. It can't *hurt* to mix in some of\\n   * @dev your own randomness, here, but it's not necessary because the VRF\\n   * @dev oracle will mix the hash of the block containing your request into the\\n   * @dev VRF seed it ultimately uses.\\n   *\\n   * @param _keyHash ID of public key against which randomness is generated\\n   * @param _fee The amount of LINK to send with the request\\n   *\\n   * @return requestId unique ID for this request\\n   *\\n   * @dev The returned requestId can be used to distinguish responses to\\n   * @dev concurrent requests. It is passed as the first argument to\\n   * @dev fulfillRandomness.\\n   */\\n  function requestRandomness(bytes32 _keyHash, uint256 _fee) internal returns (bytes32 requestId) {\\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\\n    // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n    // the hash of the block containing this request to obtain the seed/input\\n    // which is finally passed to the VRF cryptographic machinery.\\n    uint256 vRFSeed = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\\n    // nonces[_keyHash] must stay in sync with\\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\\n    // This provides protection against the user repeating their input seed,\\n    // which would result in a predictable/duplicate output, if multiple such\\n    // requests appeared in the same block.\\n    nonces[_keyHash] = nonces[_keyHash] + 1;\\n    return makeRequestId(_keyHash, vRFSeed);\\n  }\\n\\n  LinkTokenInterface internal immutable LINK;\\n  address private immutable vrfCoordinator;\\n\\n  // Nonces for each VRF key from which randomness has been requested.\\n  //\\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\\n  mapping(bytes32 => uint256) /* keyHash */ /* nonce */\\n    private nonces;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   * @param _link address of LINK token contract\\n   *\\n   * @dev https://docs.chain.link/docs/link-token-contracts\\n   */\\n  constructor(address _vrfCoordinator, address _link) {\\n    vrfCoordinator = _vrfCoordinator;\\n    LINK = LinkTokenInterface(_link);\\n  }\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomness(bytes32 requestId, uint256 randomness) external {\\n    require(msg.sender == vrfCoordinator, \\\"Only VRFCoordinator can fulfill\\\");\\n    fulfillRandomness(requestId, randomness);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/ChonkyGenomeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ChonkyGenomeLib {\\n    function parseGenome(uint256 _genome)\\n        internal\\n        pure\\n        returns (uint256[12] memory result)\\n    {\\n        assembly {\\n            mstore(result, sub(_genome, shl(5, shr(5, _genome))))\\n\\n            mstore(\\n                add(result, 0x20),\\n                sub(shr(5, _genome), shl(3, shr(8, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x40),\\n                sub(shr(8, _genome), shl(4, shr(12, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x60),\\n                sub(shr(12, _genome), shl(5, shr(17, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x80),\\n                sub(shr(17, _genome), shl(4, shr(21, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0xA0),\\n                sub(shr(21, _genome), shl(4, shr(25, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0xC0),\\n                sub(shr(25, _genome), shl(7, shr(32, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0xE0),\\n                sub(shr(32, _genome), shl(6, shr(38, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x100),\\n                sub(shr(38, _genome), shl(6, shr(44, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x120),\\n                sub(shr(44, _genome), shl(7, shr(51, _genome)))\\n            )\\n\\n            mstore(\\n                add(result, 0x140),\\n                sub(shr(51, _genome), shl(3, shr(54, _genome)))\\n            )\\n\\n            mstore(add(result, 0x160), shr(54, _genome))\\n        }\\n    }\\n\\n    function formatGenome(uint256[12] memory _attributes)\\n        internal\\n        pure\\n        returns (uint256 genome)\\n    {\\n        genome =\\n            (_attributes[0]) +\\n            (_attributes[1] << 5) +\\n            (_attributes[2] << 8) +\\n            (_attributes[3] << 12) +\\n            (_attributes[4] << 17) +\\n            (_attributes[5] << 21) +\\n            (_attributes[6] << 25) +\\n            (_attributes[7] << 32) +\\n            (_attributes[8] << 38) +\\n            (_attributes[9] << 44) +\\n            (_attributes[10] << 51) +\\n            (_attributes[11] << 54);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChonkyMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {UintUtils} from \\\"@solidstate/contracts/utils/UintUtils.sol\\\";\\nimport {Base64} from \\\"base64-sol/base64.sol\\\";\\nimport {ChonkyGenomeLib} from \\\"./lib/ChonkyGenomeLib.sol\\\";\\nimport {ChonkyAttributes} from \\\"./ChonkyAttributes.sol\\\";\\nimport {ChonkySet} from \\\"./ChonkySet.sol\\\";\\n\\nimport {IChonkyMetadata} from \\\"./interface/IChonkyMetadata.sol\\\";\\nimport {IChonkySet} from \\\"./interface/IChonkySet.sol\\\";\\n\\ncontract ChonkyMetadata is IChonkyMetadata {\\n    using UintUtils for uint256;\\n\\n    function buildTokenURI(\\n        uint256 id,\\n        uint256 genomeId,\\n        uint256 genome,\\n        string memory CID,\\n        address chonkyAttributes,\\n        address chonkySet\\n    ) public pure returns (string memory) {\\n        string\\n            memory description = \\\"A collection of 7777 mischievous Chonky's ready to wreak havoc on the ETH blockchain.\\\";\\n        string memory attributes = _buildAttributes(\\n            genome,\\n            chonkyAttributes,\\n            chonkySet\\n        );\\n\\n        return\\n            string(\\n                abi.encodePacked(\\n                    \\\"data:application/json;base64,\\\",\\n                    Base64.encode(\\n                        bytes(\\n                            abi.encodePacked(\\n                                \\\"{\\\",\\n                                '\\\"image\\\":\\\"ipfs://',\\n                                CID,\\n                                \\\"/\\\",\\n                                _buildPaddedID(genomeId),\\n                                '.png\\\",',\\n                                '\\\"description\\\":\\\"',\\n                                description,\\n                                '\\\",',\\n                                '\\\"name\\\":\\\"Chonky',\\n                                \\\"'s #\\\",\\n                                _buildPaddedID(id),\\n                                '\\\",',\\n                                attributes,\\n                                \\\"}\\\"\\n                            )\\n                        )\\n                    )\\n                )\\n            );\\n    }\\n\\n    function _buildPaddedID(uint256 id) internal pure returns (string memory) {\\n        if (id == 0) return \\\"0000\\\";\\n        if (id < 10) return string(abi.encodePacked(\\\"000\\\", id.toString()));\\n        if (id < 100) return string(abi.encodePacked(\\\"00\\\", id.toString()));\\n        if (id < 1000) return string(abi.encodePacked(\\\"0\\\", id.toString()));\\n\\n        return id.toString();\\n    }\\n\\n    ////\\n\\n    function _getBGBase(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Aqua\\\";\\n        if (id == 2) return \\\"Black\\\";\\n        if (id == 3) return \\\"Brown\\\";\\n        if (id == 4) return \\\"Dark Purple\\\";\\n        if (id == 5) return \\\"Dark Red\\\";\\n        if (id == 6) return \\\"Gold\\\";\\n        if (id == 7) return \\\"Green\\\";\\n        if (id == 8) return \\\"Green Apple\\\";\\n        if (id == 9) return \\\"Grey\\\";\\n        if (id == 10) return \\\"Ice Blue\\\";\\n        if (id == 11) return \\\"Kaki\\\";\\n        if (id == 12) return \\\"Orange\\\";\\n        if (id == 13) return \\\"Pink\\\";\\n        if (id == 14) return \\\"Purple\\\";\\n        if (id == 15) return \\\"Rainbow\\\";\\n        if (id == 16) return \\\"Red\\\";\\n        if (id == 17) return \\\"Sky Blue\\\";\\n        if (id == 18) return \\\"Yellow\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getBGRare(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"HamHam\\\";\\n        if (id == 2) return \\\"Japan\\\";\\n        if (id == 3) return \\\"Skulls\\\";\\n        if (id == 4) return \\\"Stars\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getWings(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Angel\\\";\\n        if (id == 2) return \\\"Bat\\\";\\n        if (id == 3) return \\\"Bee\\\";\\n        if (id == 4) return \\\"Crystal\\\";\\n        if (id == 5) return \\\"Devil\\\";\\n        if (id == 6) return \\\"Dragon\\\";\\n        if (id == 7) return \\\"Fairy\\\";\\n        if (id == 8) return \\\"Plant\\\";\\n        if (id == 9) return \\\"Robot\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getSkin(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Almond\\\";\\n        if (id == 2) return \\\"Aqua\\\";\\n        if (id == 3) return \\\"Blue\\\";\\n        if (id == 4) return \\\"Brown\\\";\\n        if (id == 5) return \\\"Cream\\\";\\n        if (id == 6) return \\\"Dark\\\";\\n        if (id == 7) return \\\"Dark Blue\\\";\\n        if (id == 8) return \\\"Gold\\\";\\n        if (id == 9) return \\\"Green\\\";\\n        if (id == 10) return \\\"Grey\\\";\\n        if (id == 11) return \\\"Ice\\\";\\n        if (id == 12) return \\\"Indigo\\\";\\n        if (id == 13) return \\\"Light Brown\\\";\\n        if (id == 14) return \\\"Light Purple\\\";\\n        if (id == 15) return \\\"Neon Blue\\\";\\n        if (id == 16) return \\\"Orange\\\";\\n        if (id == 17) return \\\"Pink\\\";\\n        if (id == 18) return \\\"Purple\\\";\\n        if (id == 19) return \\\"Rose White\\\";\\n        if (id == 20) return \\\"Salmon\\\";\\n        if (id == 21) return \\\"Skye Blue\\\";\\n        if (id == 22) return \\\"Special Red\\\";\\n        if (id == 23) return \\\"White\\\";\\n        if (id == 24) return \\\"Yellow\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getPattern(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"3 Dots\\\";\\n        if (id == 2) return \\\"3 Triangles\\\";\\n        if (id == 3) return \\\"Corner\\\";\\n        if (id == 4) return \\\"Dalmatian\\\";\\n        if (id == 5) return \\\"Half\\\";\\n        if (id == 6) return \\\"Tiger Stripes\\\";\\n        if (id == 7) return \\\"Triangle\\\";\\n        if (id == 8) return \\\"White Reversed V\\\";\\n        if (id == 9) return \\\"Zombie\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getPaint(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Beard\\\";\\n        if (id == 2) return \\\"Board\\\";\\n        if (id == 3) return \\\"Earrings\\\";\\n        if (id == 4) return \\\"Face Tattoo\\\";\\n        if (id == 5) return \\\"Happy Cheeks\\\";\\n        if (id == 6) return \\\"Pink Star\\\";\\n        if (id == 7) return \\\"Purple Star\\\";\\n        if (id == 8) return \\\"Scar\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getBody(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Retro Shirt\\\";\\n        if (id == 2) return \\\"Angel Wings\\\";\\n        if (id == 3) return \\\"Aqua Monster\\\";\\n        if (id == 4) return \\\"Astronaut\\\";\\n        if (id == 5) return \\\"Bag\\\";\\n        if (id == 6) return \\\"Baron Samedi\\\";\\n        if (id == 7) return \\\"Bee\\\";\\n        if (id == 8) return \\\"Black Samurai\\\";\\n        if (id == 9) return \\\"Black Wizard\\\";\\n        if (id == 10) return \\\"Blue Football\\\";\\n        if (id == 11) return \\\"Blue Parka\\\";\\n        if (id == 12) return \\\"Blue Kimono\\\";\\n        if (id == 13) return \\\"Blue Hoodie\\\";\\n        if (id == 14) return \\\"Blue Wizard\\\";\\n        if (id == 15) return \\\"Jester\\\";\\n        if (id == 16) return \\\"Bubble Tea\\\";\\n        if (id == 17) return \\\"Captain\\\";\\n        if (id == 18) return \\\"Caveman\\\";\\n        if (id == 19) return \\\"Chef\\\";\\n        if (id == 20) return \\\"Chinese Shirt\\\";\\n        if (id == 21) return \\\"Cloth Monster\\\";\\n        if (id == 22) return \\\"Color Shirt\\\";\\n        if (id == 23) return \\\"Cowboy Shirt\\\";\\n        if (id == 24) return \\\"Cyber Assassin\\\";\\n        if (id == 25) return \\\"Devil Wings\\\";\\n        if (id == 26) return \\\"Scuba\\\";\\n        if (id == 27) return \\\"Doreamon\\\";\\n        if (id == 28) return \\\"Dracula\\\";\\n        if (id == 29) return \\\"Gold Chain\\\";\\n        if (id == 30) return \\\"Green Cyber\\\";\\n        if (id == 31) return \\\"Green Parka\\\";\\n        if (id == 32) return \\\"Green Kimono\\\";\\n        if (id == 33) return \\\"Green Hoodie\\\";\\n        if (id == 34) return \\\"Hamsterdam Shirt\\\";\\n        if (id == 35) return \\\"Hazard\\\";\\n        if (id == 36) return \\\"Hiding Hamster\\\";\\n        if (id == 37) return \\\"Pink Punk Girl\\\";\\n        if (id == 38) return \\\"Japanese Worker\\\";\\n        if (id == 39) return \\\"King\\\";\\n        if (id == 40) return \\\"Leather Jacket\\\";\\n        if (id == 41) return \\\"Leaves\\\";\\n        if (id == 42) return \\\"Lobster\\\";\\n        if (id == 43) return \\\"Luffy\\\";\\n        if (id == 44) return \\\"Magenta Cyber\\\";\\n        if (id == 45) return \\\"Sailor\\\";\\n        if (id == 46) return \\\"Mario Pipe\\\";\\n        if (id == 47) return \\\"Mommy\\\";\\n        if (id == 48) return \\\"Ninja\\\";\\n        if (id == 49) return \\\"Old Grandma\\\";\\n        if (id == 50) return \\\"Orange Jumpsuit\\\";\\n        if (id == 51) return \\\"Chili\\\";\\n        if (id == 52) return \\\"Chili Fire\\\";\\n        if (id == 53) return \\\"Pharaoh\\\";\\n        if (id == 54) return \\\"Pink Football\\\";\\n        if (id == 55) return \\\"Pink Ruff\\\";\\n        if (id == 56) return \\\"Pink Jumpsuit\\\";\\n        if (id == 57) return \\\"Pink Kimono\\\";\\n        if (id == 58) return \\\"Pink Polo\\\";\\n        if (id == 59) return \\\"Pirate\\\";\\n        if (id == 60) return \\\"Plague Doctor\\\";\\n        if (id == 61) return \\\"Poncho\\\";\\n        if (id == 62) return \\\"Purple Cyber\\\";\\n        if (id == 63) return \\\"Purple Polo\\\";\\n        if (id == 64) return \\\"Mystery Hoodie\\\";\\n        if (id == 65) return \\\"Rainbow Snake\\\";\\n        if (id == 66) return \\\"Red Ruff\\\";\\n        if (id == 67) return \\\"Red Punk Girl\\\";\\n        if (id == 68) return \\\"Red Samurai\\\";\\n        if (id == 69) return \\\"Referee\\\";\\n        if (id == 70) return \\\"Robotbod\\\";\\n        if (id == 71) return \\\"Robot Cyber\\\";\\n        if (id == 72) return \\\"Rocker\\\";\\n        if (id == 73) return \\\"Roman Legionary\\\";\\n        if (id == 74) return \\\"Safari\\\";\\n        if (id == 75) return \\\"Scout\\\";\\n        if (id == 76) return \\\"Sherlock\\\";\\n        if (id == 77) return \\\"Shirt\\\";\\n        if (id == 78) return \\\"Snow Coat\\\";\\n        if (id == 79) return \\\"Sparta\\\";\\n        if (id == 80) return \\\"Steampunk\\\";\\n        if (id == 81) return \\\"Suit\\\";\\n        if (id == 82) return \\\"Tie\\\";\\n        if (id == 83) return \\\"Tire\\\";\\n        if (id == 84) return \\\"Toga\\\";\\n        if (id == 85) return \\\"Tron\\\";\\n        if (id == 86) return \\\"Valkyrie\\\";\\n        if (id == 87) return \\\"Viking\\\";\\n        if (id == 88) return \\\"Wereham\\\";\\n        if (id == 89) return \\\"White Cloak\\\";\\n        if (id == 90) return \\\"Yellow Jumpsuit\\\";\\n        if (id == 91) return \\\"Zombie\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getMouth(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Black Gas Mask Ninja\\\";\\n        if (id == 2) return \\\"Black Ninja Mask\\\";\\n        if (id == 3) return \\\"Shocked\\\";\\n        if (id == 4) return \\\"Creepy\\\";\\n        if (id == 5) return \\\"=D\\\";\\n        if (id == 6) return \\\"Drawing\\\";\\n        if (id == 7) return \\\"Duck\\\";\\n        if (id == 8) return \\\"Elegant Moustache\\\";\\n        if (id == 9) return \\\"Fire\\\";\\n        if (id == 10) return \\\"Gold Teeth\\\";\\n        if (id == 11) return \\\"Grey Futuristic Gas Mask\\\";\\n        if (id == 12) return \\\"Happy Open\\\";\\n        if (id == 13) return \\\"Goatee\\\";\\n        if (id == 14) return \\\"Honey\\\";\\n        if (id == 15) return \\\"Jack-O-Lantern\\\";\\n        if (id == 16) return \\\"Lipstick\\\";\\n        if (id == 17) return \\\"Little Moustache\\\";\\n        if (id == 18) return \\\"Luffy Smile\\\";\\n        if (id == 19) return \\\"Sanitary Mask\\\";\\n        if (id == 20) return \\\"Robot Mask\\\";\\n        if (id == 21) return \\\"Mega Happy\\\";\\n        if (id == 22) return \\\"Mega Tongue Out\\\";\\n        if (id == 23) return \\\"Meh\\\";\\n        if (id == 24) return \\\"Mexican Moustache\\\";\\n        if (id == 25) return \\\"Monster\\\";\\n        if (id == 26) return \\\"Moustache\\\";\\n        if (id == 27) return \\\"Drunk\\\";\\n        if (id == 28) return \\\"Fake Moustache\\\";\\n        if (id == 29) return \\\"Full\\\";\\n        if (id == 30) return \\\"Piece\\\";\\n        if (id == 31) return \\\"Stretch\\\";\\n        if (id == 32) return \\\"Ninja\\\";\\n        if (id == 33) return \\\"Normal\\\";\\n        if (id == 34) return \\\"Ohhhh\\\";\\n        if (id == 35) return \\\"Chili\\\";\\n        if (id == 36) return \\\"Purple Futuristic Gas Mask\\\";\\n        if (id == 37) return \\\"Red Gas Mask Ninja\\\";\\n        if (id == 38) return \\\"Red Ninja Mask\\\";\\n        if (id == 39) return \\\"Robot Mouth\\\";\\n        if (id == 40) return \\\"Scream\\\";\\n        if (id == 41) return \\\"Cigarette\\\";\\n        if (id == 42) return \\\"Smoking Pipe\\\";\\n        if (id == 43) return \\\"Square\\\";\\n        if (id == 44) return \\\"Steampunk\\\";\\n        if (id == 45) return \\\"Stitch\\\";\\n        if (id == 46) return \\\"Super Sad\\\";\\n        if (id == 47) return \\\"Thick Moustache\\\";\\n        if (id == 48) return \\\"Tongue\\\";\\n        if (id == 49) return \\\"Tongue Out\\\";\\n        if (id == 50) return \\\"Triangle\\\";\\n        if (id == 51) return \\\"Vampire\\\";\\n        if (id == 52) return \\\"Wave\\\";\\n        if (id == 53) return \\\"What\\\";\\n        if (id == 54) return \\\"YKWIM\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getEyes(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"^_^\\\";\\n        if (id == 2) return \\\">_<\\\";\\n        if (id == 3) return \\\"=_=\\\";\\n        if (id == 4) return \\\"3D\\\";\\n        if (id == 5) return \\\"Angry\\\";\\n        if (id == 6) return \\\"Button\\\";\\n        if (id == 7) return \\\"Confused\\\";\\n        if (id == 8) return \\\"Crazy\\\";\\n        if (id == 9) return \\\"Cute\\\";\\n        if (id == 10) return \\\"Cyber Glasses\\\";\\n        if (id == 11) return \\\"Cyclops\\\";\\n        if (id == 12) return \\\"Depressed\\\";\\n        if (id == 13) return \\\"Determined\\\";\\n        if (id == 14) return \\\"Diving Mask\\\";\\n        if (id == 15) return \\\"Drawing\\\";\\n        if (id == 16) return \\\"Morty\\\";\\n        if (id == 17) return \\\"Eyepatch\\\";\\n        if (id == 18) return \\\"Fake Moustache\\\";\\n        if (id == 19) return \\\"Flower Glasses\\\";\\n        if (id == 20) return \\\"Frozen\\\";\\n        if (id == 21) return \\\"Furious\\\";\\n        if (id == 22) return \\\"Gengar\\\";\\n        if (id == 23) return \\\"Glasses Depressed\\\";\\n        if (id == 24) return \\\"Goku\\\";\\n        if (id == 25) return \\\"Green Underwear\\\";\\n        if (id == 26) return \\\"Hippie\\\";\\n        if (id == 27) return \\\"Kawaii\\\";\\n        if (id == 28) return \\\"Line Glasses\\\";\\n        if (id == 29) return \\\"Looking Up\\\";\\n        if (id == 30) return \\\"Looking Up Happy\\\";\\n        if (id == 31) return \\\"Mini Sunglasses\\\";\\n        if (id == 32) return \\\"Monocle\\\";\\n        if (id == 33) return \\\"Monster\\\";\\n        if (id == 34) return \\\"Ninja\\\";\\n        if (id == 35) return \\\"Normal\\\";\\n        if (id == 36) return \\\"Not Impressed\\\";\\n        if (id == 37) return \\\"o_o\\\";\\n        if (id == 38) return \\\"Orange Underwear\\\";\\n        if (id == 39) return \\\"Pink Star Sunglasses\\\";\\n        if (id == 40) return \\\"Pissed\\\";\\n        if (id == 41) return \\\"Pixel Glasses\\\";\\n        if (id == 42) return \\\"Plague Doctor Mask\\\";\\n        if (id == 43) return \\\"Proud\\\";\\n        if (id == 44) return \\\"Raccoon\\\";\\n        if (id == 45) return \\\"Red Dot\\\";\\n        if (id == 46) return \\\"Red Star Sunglasses\\\";\\n        if (id == 47) return \\\"Robot Eyes\\\";\\n        if (id == 48) return \\\"Scared Eyes\\\";\\n        if (id == 49) return \\\"Snorkel\\\";\\n        if (id == 50) return \\\"Serious Japan\\\";\\n        if (id == 51) return \\\"Seriously\\\";\\n        if (id == 52) return \\\"Star\\\";\\n        if (id == 53) return \\\"Steampunk Glasses\\\";\\n        if (id == 54) return \\\"Sunglasses\\\";\\n        if (id == 55) return \\\"Sunglasses Triangle\\\";\\n        if (id == 56) return \\\"Surprised\\\";\\n        if (id == 57) return \\\"Thick Eyebrows\\\";\\n        if (id == 58) return \\\"Troubled\\\";\\n        if (id == 59) return \\\"UniBrow\\\";\\n        if (id == 60) return \\\"Weird\\\";\\n        if (id == 61) return \\\"X_X\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getLostKing(uint256 _id) internal pure returns (string memory) {\\n        if (_id == 1) return \\\"The Glitch King\\\";\\n        if (_id == 2) return \\\"The Gummy King\\\";\\n        if (_id == 3) return \\\"King Diamond\\\";\\n        if (_id == 4) return \\\"The King of Gold\\\";\\n        if (_id == 5) return \\\"King Unicorn\\\";\\n        if (_id == 6) return \\\"The Last King\\\";\\n        if (_id == 7) return \\\"The Monkey King\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getHonorary(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Crunchies\\\";\\n        if (id == 2) return \\\"Chuckle\\\";\\n        if (id == 3) return \\\"ChainLinkGod\\\";\\n        if (id == 4) return \\\"Crypt0n1c\\\";\\n        if (id == 5) return \\\"Bigdham\\\";\\n        if (id == 6) return \\\"Cyclopeape\\\";\\n        if (id == 7) return \\\"Elmo\\\";\\n        if (id == 8) return \\\"Caustik\\\";\\n        if (id == 9) return \\\"Churby\\\";\\n        if (id == 10) return \\\"Chonko\\\";\\n        if (id == 11) return \\\"Hamham\\\";\\n        if (id == 12) return \\\"Icebergy\\\";\\n        if (id == 13) return \\\"IronHam\\\";\\n        if (id == 14) return \\\"RatWell\\\";\\n        if (id == 15) return \\\"VangogHam\\\";\\n        if (id == 16) return \\\"Boneham\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    function _getHat(uint256 id) internal pure returns (string memory) {\\n        if (id == 1) return \\\"Retro\\\";\\n        if (id == 2) return \\\"Aqua Monster\\\";\\n        if (id == 3) return \\\"Astronaut\\\";\\n        if (id == 4) return \\\"Baby Hamster\\\";\\n        if (id == 5) return \\\"Baron Samedi\\\";\\n        if (id == 6) return \\\"Bear Skin\\\";\\n        if (id == 7) return \\\"Bee\\\";\\n        if (id == 8) return \\\"Beanie\\\";\\n        if (id == 9) return \\\"Beret\\\";\\n        if (id == 10) return \\\"Biker Helmet\\\";\\n        if (id == 11) return \\\"Black Afro\\\";\\n        if (id == 12) return \\\"Black Hair JB\\\";\\n        if (id == 13) return \\\"Black Kabuki Mask\\\";\\n        if (id == 14) return \\\"Black Kabuto\\\";\\n        if (id == 15) return \\\"Black Magician\\\";\\n        if (id == 16) return \\\"Black Toupee\\\";\\n        if (id == 17) return \\\"Bolts\\\";\\n        if (id == 18) return \\\"Jester\\\";\\n        if (id == 19) return \\\"Brain\\\";\\n        if (id == 20) return \\\"Brown Hair JB\\\";\\n        if (id == 21) return \\\"Candle\\\";\\n        if (id == 22) return \\\"Captain\\\";\\n        if (id == 23) return \\\"Cheese\\\";\\n        if (id == 24) return \\\"Chef\\\";\\n        if (id == 25) return \\\"Cloth Monster\\\";\\n        if (id == 26) return \\\"Cone\\\";\\n        if (id == 27) return \\\"Cowboy\\\";\\n        if (id == 28) return \\\"Crown\\\";\\n        if (id == 29) return \\\"Devil Horns\\\";\\n        if (id == 30) return \\\"Dracula\\\";\\n        if (id == 31) return \\\"Duck\\\";\\n        if (id == 32) return \\\"Elvis\\\";\\n        if (id == 33) return \\\"Fish\\\";\\n        if (id == 34) return \\\"Fan\\\";\\n        if (id == 35) return \\\"Fire\\\";\\n        if (id == 36) return \\\"Fluffy Beanie\\\";\\n        if (id == 37) return \\\"Pigskin\\\";\\n        if (id == 38) return \\\"Futuristic Crown\\\";\\n        if (id == 39) return \\\"Golden Horns\\\";\\n        if (id == 40) return \\\"Green Fire\\\";\\n        if (id == 41) return \\\"Green Knot\\\";\\n        if (id == 42) return \\\"Green Punk\\\";\\n        if (id == 43) return \\\"Green Visor\\\";\\n        if (id == 44) return \\\"Halo\\\";\\n        if (id == 45) return \\\"Headband\\\";\\n        if (id == 46) return \\\"Ice\\\";\\n        if (id == 47) return \\\"Injury\\\";\\n        if (id == 48) return \\\"Kabuto\\\";\\n        if (id == 49) return \\\"Leaf\\\";\\n        if (id == 50) return \\\"Lion Head\\\";\\n        if (id == 51) return \\\"Long Hair Front\\\";\\n        if (id == 52) return \\\"Magician\\\";\\n        if (id == 53) return \\\"Mario Flower\\\";\\n        if (id == 54) return \\\"Mini Cap\\\";\\n        if (id == 55) return \\\"Ninja Band\\\";\\n        if (id == 56) return \\\"Mushroom\\\";\\n        if (id == 57) return \\\"Ninja\\\";\\n        if (id == 58) return \\\"Noodle Cup\\\";\\n        if (id == 59) return \\\"Octopus\\\";\\n        if (id == 60) return \\\"Old Lady\\\";\\n        if (id == 61) return \\\"Pancakes\\\";\\n        if (id == 62) return \\\"Paper Hat\\\";\\n        if (id == 63) return \\\"Pharaoh\\\";\\n        if (id == 64) return \\\"Pink Exploding Hair\\\";\\n        if (id == 65) return \\\"Pink Hair Girl\\\";\\n        if (id == 66) return \\\"Pink Mini Cap\\\";\\n        if (id == 67) return \\\"Pink Punk\\\";\\n        if (id == 68) return \\\"Pink Visor\\\";\\n        if (id == 69) return \\\"Pirate\\\";\\n        if (id == 70) return \\\"Plague Doctor\\\";\\n        if (id == 71) return \\\"Plant\\\";\\n        if (id == 72) return \\\"Punk Helmet\\\";\\n        if (id == 73) return \\\"Purple Mini Cap\\\";\\n        if (id == 74) return \\\"Purple Top Hat\\\";\\n        if (id == 75) return \\\"Rainbow Afro\\\";\\n        if (id == 76) return \\\"Rainbow Ice Cream\\\";\\n        if (id == 77) return \\\"Red Black Hair Girl\\\";\\n        if (id == 78) return \\\"Red Knot\\\";\\n        if (id == 79) return \\\"Red Punk\\\";\\n        if (id == 80) return \\\"Red Top Hat\\\";\\n        if (id == 81) return \\\"Robot Head\\\";\\n        if (id == 82) return \\\"Roman Legionary\\\";\\n        if (id == 83) return \\\"Safari\\\";\\n        if (id == 84) return \\\"Sherlock\\\";\\n        if (id == 85) return \\\"Sombrero\\\";\\n        if (id == 86) return \\\"Sparta\\\";\\n        if (id == 87) return \\\"Steampunk\\\";\\n        if (id == 88) return \\\"Straw\\\";\\n        if (id == 89) return \\\"Straw Hat\\\";\\n        if (id == 90) return \\\"Teapot\\\";\\n        if (id == 91) return \\\"Tin Hat\\\";\\n        if (id == 92) return \\\"Toupee\\\";\\n        if (id == 93) return \\\"Valkyrie\\\";\\n        if (id == 94) return \\\"Viking\\\";\\n        if (id == 95) return \\\"White Kabuki Mask\\\";\\n        if (id == 96) return \\\"Yellow Exploding Hair\\\";\\n\\n        return \\\"\\\";\\n    }\\n\\n    ////\\n\\n    function _buildAttributes(\\n        uint256 genome,\\n        address chonkyAttributes,\\n        address chonkySet\\n    ) internal pure returns (string memory result) {\\n        uint256[12] memory attributes = ChonkyGenomeLib.parseGenome(genome);\\n\\n        bytes memory buffer = abi.encodePacked(\\n            '\\\"attributes\\\":[',\\n            '{\\\"trait_type\\\":\\\"Background\\\",',\\n            '\\\"value\\\":\\\"',\\n            _getBGBase(attributes[0]),\\n            '\\\"}'\\n        );\\n\\n        if (attributes[1] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ', {\\\"trait_type\\\":\\\"Rare Background\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getBGRare(attributes[1]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[2] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Wings\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getWings(attributes[2]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[3] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Skin\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getSkin(attributes[3]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[4] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Pattern\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getPattern(attributes[4]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[5] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Paint\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getPaint(attributes[5]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[6] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Body\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getBody(attributes[6]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[7] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Mouth\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getMouth(attributes[7]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[8] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Eyes\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getEyes(attributes[8]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[9] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Hat\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getHat(attributes[9]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[10] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Lost King\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getLostKing(attributes[10]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        if (attributes[11] > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Honorary\\\",',\\n                '\\\"value\\\":\\\"',\\n                _getHonorary(attributes[11]),\\n                '\\\"}'\\n            );\\n        }\\n\\n        uint256 setId = IChonkySet(chonkySet).getSetId(genome);\\n\\n        if (setId > 0) {\\n            buffer = abi.encodePacked(\\n                buffer,\\n                ',{\\\"trait_type\\\":\\\"Full Set\\\",',\\n                '\\\"value\\\":\\\"',\\n                IChonkySet(chonkySet).getSetFromId(setId),\\n                '\\\"}'\\n            );\\n        }\\n\\n        uint256[4] memory attributeValues = ChonkyAttributes(chonkyAttributes)\\n            .getAttributeValues(attributes, setId);\\n\\n        buffer = abi.encodePacked(\\n            buffer,\\n            ',{\\\"trait_type\\\":\\\"Brain\\\",',\\n            '\\\"value\\\":',\\n            attributeValues[0].toString(),\\n            \\\"}\\\"\\n        );\\n\\n        buffer = abi.encodePacked(\\n            buffer,\\n            ',{\\\"trait_type\\\":\\\"Cute\\\",',\\n            '\\\"value\\\":',\\n            attributeValues[1].toString(),\\n            \\\"}\\\"\\n        );\\n\\n        buffer = abi.encodePacked(\\n            buffer,\\n            ',{\\\"trait_type\\\":\\\"Power\\\",',\\n            '\\\"value\\\":',\\n            attributeValues[2].toString(),\\n            \\\"}\\\"\\n        );\\n\\n        buffer = abi.encodePacked(\\n            buffer,\\n            ',{\\\"trait_type\\\":\\\"Wicked\\\",',\\n            '\\\"value\\\":',\\n            attributeValues[3].toString(),\\n            \\\"}\\\"\\n        );\\n\\n        return string(abi.encodePacked(buffer, \\\"]\\\"));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChonkyNFTStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {EnumerableSet} from \\\"@solidstate/contracts/utils/EnumerableSet.sol\\\";\\n\\nlibrary ChonkyNFTStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256(\\\"chonky.contracts.storage.ChonkyNFT\\\");\\n\\n    struct Layout {\\n        address implementation;\\n        uint256 currentId;\\n        uint256[] genomes;\\n        // Offset IDs to randomize distribution when revealing\\n        uint256 offset;\\n        // Address of chonkyAttributes contract\\n        address chonkyAttributes;\\n        // Address of chonkyMetadata contract\\n        address chonkyMetadata;\\n        // Address of chonkySet contract\\n        address chonkySet;\\n        // Timestamp at which minting starts\\n        uint256 startTimestamp;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IChonkyNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IERC721} from \\\"@solidstate/contracts/token/ERC721/IERC721.sol\\\";\\nimport {IERC721Enumerable} from \\\"@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol\\\";\\n\\ninterface IChonkyNFT is IERC721, IERC721Enumerable {\\n    function mint() external payable;\\n\\n    function parseGenome(uint256 _genome)\\n        external\\n        pure\\n        returns (uint256[12] memory result);\\n\\n    function formatGenome(uint256[12] memory _attributes)\\n        external\\n        pure\\n        returns (uint256 genome);\\n\\n    function getGenome(uint256 _id) external view returns (uint256);\\n\\n    function getChonkyAttributesAddress() external view returns (address);\\n\\n    function getChonkyMetadataAddress() external view returns (address);\\n\\n    function getChonkySetAddress() external view returns (address);\\n\\n    function getCID() external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721Base.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { IERC721 } from '../IERC721.sol';\\nimport { IERC721Receiver } from '../IERC721Receiver.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\nimport { ERC721BaseInternal } from './ERC721BaseInternal.sol';\\n\\n/**\\n * @notice Base ERC721 implementation, excluding optional extensions\\n */\\nabstract contract ERC721Base is IERC721, ERC721BaseInternal {\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function balanceOf(address account) public view override returns (uint256) {\\n        return _balanceOf(account);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        return _ownerOf(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function getApproved(uint256 tokenId)\\n        public\\n        view\\n        override\\n        returns (address)\\n    {\\n        return _getApproved(tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return _isApprovedForAll(account, operator);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            'ERC721: transfer caller is not owner or approved'\\n        );\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public payable override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public payable override {\\n        _handleTransferMessageValue(from, to, tokenId, msg.value);\\n        require(\\n            _isApprovedOrOwner(msg.sender, tokenId),\\n            'ERC721: transfer caller is not owner or approved'\\n        );\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function approve(address operator, uint256 tokenId)\\n        public\\n        payable\\n        override\\n    {\\n        _handleApproveMessageValue(operator, tokenId, msg.value);\\n        address owner = ownerOf(tokenId);\\n        require(operator != owner, 'ERC721: approval to current owner');\\n        require(\\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\\n            'ERC721: approve caller is not owner nor approved for all'\\n        );\\n        _approve(operator, tokenId);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721\\n     */\\n    function setApprovalForAll(address operator, bool status) public override {\\n        require(operator != msg.sender, 'ERC721: approve to caller');\\n        ERC721BaseStorage.layout().operatorApprovals[msg.sender][\\n            operator\\n        ] = status;\\n        emit ApprovalForAll(msg.sender, operator, status);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\nimport { IERC721Enumerable } from './IERC721Enumerable.sol';\\nimport { ERC721EnumerableInternal } from './ERC721EnumerableInternal.sol';\\n\\nabstract contract ERC721Enumerable is\\n    IERC721Enumerable,\\n    ERC721EnumerableInternal\\n{\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function totalSupply() public view override returns (uint256) {\\n        return _totalSupply();\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _tokenOfOwnerByIndex(owner, index);\\n    }\\n\\n    /**\\n     * @inheritdoc IERC721Enumerable\\n     */\\n    function tokenByIndex(uint256 index)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return _tokenByIndex(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { UintUtils } from '../../../utils/UintUtils.sol';\\nimport { ERC721BaseInternal, ERC721BaseStorage } from '../base/ERC721Base.sol';\\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\\nimport { ERC721MetadataInternal } from './ERC721MetadataInternal.sol';\\nimport { IERC721Metadata } from './IERC721Metadata.sol';\\n\\n/**\\n * @notice ERC721 metadata extensions\\n */\\nabstract contract ERC721Metadata is IERC721Metadata, ERC721MetadataInternal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n    using UintUtils for uint256;\\n\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return ERC721MetadataStorage.layout().name;\\n    }\\n\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return ERC721MetadataStorage.layout().symbol;\\n    }\\n\\n    /**\\n     * @notice inheritdoc IERC721Metadata\\n     */\\n    function tokenURI(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        require(\\n            ERC721BaseStorage.layout().exists(tokenId),\\n            'ERC721Metadata: URI query for nonexistent token'\\n        );\\n\\n        ERC721MetadataStorage.Layout storage l = ERC721MetadataStorage.layout();\\n\\n        string memory tokenIdURI = l.tokenURIs[tokenId];\\n        string memory baseURI = l.baseURI;\\n\\n        if (bytes(baseURI).length == 0) {\\n            return tokenIdURI;\\n        } else if (bytes(tokenIdURI).length > 0) {\\n            return string(abi.encodePacked(baseURI, tokenIdURI));\\n        } else {\\n            return string(abi.encodePacked(baseURI, tokenId.toString()));\\n        }\\n    }\\n\\n    /**\\n     * @inheritdoc ERC721MetadataInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from './IERC165.sol';\\nimport { ERC165Storage } from './ERC165Storage.sol';\\n\\n/**\\n * @title ERC165 implementation\\n */\\nabstract contract ERC165 is IERC165 {\\n    using ERC165Storage for ERC165Storage.Layout;\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        override\\n        returns (bool)\\n    {\\n        return ERC165Storage.layout().isSupportedInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary AddressUtils {\\n    function toString(address account) internal pure returns (string memory) {\\n        bytes32 value = bytes32(uint256(uint160(account)));\\n        bytes memory alphabet = '0123456789abcdef';\\n        bytes memory chars = new bytes(42);\\n\\n        chars[0] = '0';\\n        chars[1] = 'x';\\n\\n        for (uint256 i = 0; i < 20; i++) {\\n            chars[2 + i * 2] = alphabet[uint8(value[i + 12] >> 4)];\\n            chars[3 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\\n        }\\n\\n        return string(chars);\\n    }\\n\\n    function isContract(address account) internal view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    function sendValue(address payable account, uint256 amount) internal {\\n        (bool success, ) = account.call{ value: amount }('');\\n        require(success, 'AddressUtils: failed to send value');\\n    }\\n\\n    function functionCall(address target, bytes memory data)\\n        internal\\n        returns (bytes memory)\\n    {\\n        return\\n            functionCall(target, data, 'AddressUtils: failed low-level call');\\n    }\\n\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        return _functionCallWithValue(target, data, 0, error);\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return\\n            functionCallWithValue(\\n                target,\\n                data,\\n                value,\\n                'AddressUtils: failed low-level call with value'\\n            );\\n    }\\n\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) internal returns (bytes memory) {\\n        require(\\n            address(this).balance >= value,\\n            'AddressUtils: insufficient balance for call'\\n        );\\n        return _functionCallWithValue(target, data, value, error);\\n    }\\n\\n    function _functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory error\\n    ) private returns (bytes memory) {\\n        require(\\n            isContract(target),\\n            'AddressUtils: function call to non-contract'\\n        );\\n\\n        (bool success, bytes memory returnData) = target.call{ value: value }(\\n            data\\n        );\\n\\n        if (success) {\\n            return returnData;\\n        } else if (returnData.length > 0) {\\n            assembly {\\n                let returnData_size := mload(returnData)\\n                revert(add(32, returnData), returnData_size)\\n            }\\n        } else {\\n            revert(error);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Map implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableMap {\\n    struct MapEntry {\\n        bytes32 _key;\\n        bytes32 _value;\\n    }\\n\\n    struct Map {\\n        MapEntry[] _entries;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct AddressToAddressMap {\\n        Map _inner;\\n    }\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    function at(AddressToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (address, address)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        address addressKey;\\n        assembly {\\n            addressKey := mload(add(key, 20))\\n        }\\n        return (addressKey, address(uint160(uint256(value))));\\n    }\\n\\n    function at(UintToAddressMap storage map, uint256 index)\\n        internal\\n        view\\n        returns (uint256, address)\\n    {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    function contains(AddressToAddressMap storage map, address key)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function contains(UintToAddressMap storage map, uint256 key)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    function length(AddressToAddressMap storage map)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _length(map._inner);\\n    }\\n\\n    function length(UintToAddressMap storage map)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _length(map._inner);\\n    }\\n\\n    function get(AddressToAddressMap storage map, address key)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return\\n            address(\\n                uint160(\\n                    uint256(_get(map._inner, bytes32(uint256(uint160(key)))))\\n                )\\n            );\\n    }\\n\\n    function get(UintToAddressMap storage map, uint256 key)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    function set(\\n        AddressToAddressMap storage map,\\n        address key,\\n        address value\\n    ) internal returns (bool) {\\n        return\\n            _set(\\n                map._inner,\\n                bytes32(uint256(uint160(key))),\\n                bytes32(uint256(uint160(value)))\\n            );\\n    }\\n\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(AddressToAddressMap storage map, address key)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    function remove(UintToAddressMap storage map, uint256 key)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    function _at(Map storage map, uint256 index)\\n        private\\n        view\\n        returns (bytes32, bytes32)\\n    {\\n        require(\\n            map._entries.length > index,\\n            'EnumerableMap: index out of bounds'\\n        );\\n\\n        MapEntry storage entry = map._entries[index];\\n        return (entry._key, entry._value);\\n    }\\n\\n    function _contains(Map storage map, bytes32 key)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return map._indexes[key] != 0;\\n    }\\n\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._entries.length;\\n    }\\n\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        uint256 keyIndex = map._indexes[key];\\n        require(keyIndex != 0, 'EnumerableMap: nonexistent key');\\n        return map._entries[keyIndex - 1]._value;\\n    }\\n\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex == 0) {\\n            map._entries.push(MapEntry({ _key: key, _value: value }));\\n            map._indexes[key] = map._entries.length;\\n            return true;\\n        } else {\\n            map._entries[keyIndex - 1]._value = value;\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        uint256 keyIndex = map._indexes[key];\\n\\n        if (keyIndex != 0) {\\n            uint256 index = keyIndex - 1;\\n            MapEntry storage last = map._entries[map._entries.length - 1];\\n\\n            // move last entry to now-vacant index\\n\\n            map._entries[index] = last;\\n            map._indexes[last._key] = index + 1;\\n\\n            // clear last index\\n\\n            map._entries.pop();\\n            delete map._indexes[key];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Set implementation with enumeration functions\\n * @dev derived from https://github.com/OpenZeppelin/openzeppelin-contracts (MIT license)\\n */\\nlibrary EnumerableSet {\\n    struct Set {\\n        bytes32[] _values;\\n        // 1-indexed to allow 0 to signify nonexistence\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    function at(Bytes32Set storage set, uint256 index)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        return _at(set._inner, index);\\n    }\\n\\n    function at(AddressSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (address)\\n    {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    function at(UintSet storage set, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    function contains(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, value);\\n    }\\n\\n    function contains(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function contains(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    function indexOf(Bytes32Set storage set, bytes32 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, value);\\n    }\\n\\n    function indexOf(AddressSet storage set, address value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function indexOf(UintSet storage set, uint256 value)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return _indexOf(set._inner, bytes32(value));\\n    }\\n\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    function add(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, value);\\n    }\\n\\n    function add(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    function remove(Bytes32Set storage set, bytes32 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, value);\\n    }\\n\\n    function remove(AddressSet storage set, address value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    function remove(UintSet storage set, uint256 value)\\n        internal\\n        returns (bool)\\n    {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    function _at(Set storage set, uint256 index)\\n        private\\n        view\\n        returns (bytes32)\\n    {\\n        require(\\n            set._values.length > index,\\n            'EnumerableSet: index out of bounds'\\n        );\\n        return set._values[index];\\n    }\\n\\n    function _contains(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (bool)\\n    {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    function _indexOf(Set storage set, bytes32 value)\\n        private\\n        view\\n        returns (uint256)\\n    {\\n        unchecked {\\n            return set._indexes[value] - 1;\\n        }\\n    }\\n\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            uint256 index = valueIndex - 1;\\n            bytes32 last = set._values[set._values.length - 1];\\n\\n            // move last value to now-vacant index\\n\\n            set._values[index] = last;\\n            set._indexes[last] = index + 1;\\n\\n            // clear last index\\n\\n            set._values.pop();\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IERC165 } from '../../introspection/IERC165.sol';\\nimport { IERC721Internal } from './IERC721Internal.sol';\\n\\n/**\\n * @notice ERC721 interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721 is IERC721Internal, IERC165 {\\n    /**\\n     * @notice query the balance of given address\\n     * @return balance quantity of tokens held\\n     */\\n    function balanceOf(address account) external view returns (uint256 balance);\\n\\n    /**\\n     * @notice query the owner of given token\\n     * @param tokenId token to query\\n     * @return owner token owner\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     * @param data data payload\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external payable;\\n\\n    /**\\n     * @notice transfer token between given addresses, without checking for ERC721Receiver implementation if applicable\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId token id\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external payable;\\n\\n    /**\\n     * @notice grant approval to given account to spend token\\n     * @param operator address to be approved\\n     * @param tokenId token to approve\\n     */\\n    function approve(address operator, uint256 tokenId) external payable;\\n\\n    /**\\n     * @notice get approval status for given token\\n     * @param tokenId token to query\\n     * @return operator address approved to spend token\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @notice grant approval to or revoke approval from given account to spend all tokens held by sender\\n     * @param operator address to be approved\\n     * @param status approval status\\n     */\\n    function setApprovalForAll(address operator, bool status) external;\\n\\n    /**\\n     * @notice query approval status of given operator with respect to given address\\n     * @param account address to query for approval granted\\n     * @param operator address to query for approval received\\n     * @return status whether operator is approved to spend tokens held by account\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool status);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Receiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/base/ERC721BaseInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { AddressUtils } from '../../../utils/AddressUtils.sol';\\nimport { EnumerableMap } from '../../../utils/EnumerableMap.sol';\\nimport { EnumerableSet } from '../../../utils/EnumerableSet.sol';\\nimport { IERC721Internal } from '../IERC721Internal.sol';\\nimport { IERC721Receiver } from '../IERC721Receiver.sol';\\nimport { ERC721BaseStorage } from './ERC721BaseStorage.sol';\\n\\n/**\\n * @notice Base ERC721 internal functions\\n */\\nabstract contract ERC721BaseInternal is IERC721Internal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n    using AddressUtils for address;\\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\\n    using EnumerableSet for EnumerableSet.UintSet;\\n\\n    function _balanceOf(address account) internal view returns (uint256) {\\n        require(\\n            account != address(0),\\n            'ERC721: balance query for the zero address'\\n        );\\n        return ERC721BaseStorage.layout().holderTokens[account].length();\\n    }\\n\\n    function _ownerOf(uint256 tokenId) internal view returns (address) {\\n        address owner = ERC721BaseStorage.layout().tokenOwners.get(tokenId);\\n        require(owner != address(0), 'ERC721: invalid owner');\\n        return owner;\\n    }\\n\\n    function _getApproved(uint256 tokenId) internal view returns (address) {\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        require(\\n            l.exists(tokenId),\\n            'ERC721: approved query for nonexistent token'\\n        );\\n\\n        return l.tokenApprovals[tokenId];\\n    }\\n\\n    function _isApprovedForAll(address account, address operator)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return ERC721BaseStorage.layout().operatorApprovals[account][operator];\\n    }\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            ERC721BaseStorage.layout().exists(tokenId),\\n            'ERC721: query for nonexistent token'\\n        );\\n\\n        address owner = _ownerOf(tokenId);\\n\\n        return (spender == owner ||\\n            _getApproved(tokenId) == spender ||\\n            _isApprovedForAll(owner, spender));\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), 'ERC721: mint to the zero address');\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n\\n        require(!l.exists(tokenId), 'ERC721: token already minted');\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    function _safeMint(address to, uint256 tokenId) internal {\\n        _safeMint(to, tokenId, '');\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner = _ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        _approve(address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n        l.holderTokens[owner].remove(tokenId);\\n        l.tokenOwners.remove(tokenId);\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            _ownerOf(tokenId) == from,\\n            'ERC721: transfer of token that is not own'\\n        );\\n        require(to != address(0), 'ERC721: transfer to the zero address');\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        _approve(address(0), tokenId);\\n\\n        ERC721BaseStorage.Layout storage l = ERC721BaseStorage.layout();\\n        l.holderTokens[from].remove(tokenId);\\n        l.holderTokens[to].add(tokenId);\\n        l.tokenOwners.set(tokenId, to);\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    function _approve(address operator, uint256 tokenId) internal {\\n        ERC721BaseStorage.layout().tokenApprovals[tokenId] = operator;\\n        emit Approval(_ownerOf(tokenId), operator, tokenId);\\n    }\\n\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal returns (bool) {\\n        if (!to.isContract()) {\\n            return true;\\n        }\\n\\n        bytes memory returnData = to.functionCall(\\n            abi.encodeWithSelector(\\n                IERC721Receiver(to).onERC721Received.selector,\\n                msg.sender,\\n                from,\\n                tokenId,\\n                data\\n            ),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n\\n        bytes4 returnValue = abi.decode(returnData, (bytes4));\\n        return returnValue == type(IERC721Receiver).interfaceId;\\n    }\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called approvals for processing of included message value\\n     * @param operator beneficiary of approval\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleApproveMessageValue(\\n        address operator,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before externally called transfers for processing of included message value\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     * @param value message value\\n     */\\n    function _handleTransferMessageValue(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        uint256 value\\n    ) internal virtual {}\\n\\n    /**\\n     * @notice ERC721 hook, called before all transfers including mint and burn\\n     * @dev function should be overridden and new implementation must call super\\n     * @param from sender of token\\n     * @param to receiver of token\\n     * @param tokenId id of transferred token\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC165 interface registration interface\\n * @dev see https://eips.ethereum.org/EIPS/eip-165\\n */\\ninterface IERC165 {\\n    /**\\n     * @notice query whether contract has registered support for given interface\\n     * @param interfaceId interface id\\n     * @return bool whether interface is supported\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/IERC721Internal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Partial ERC721 interface needed by internal functions\\n */\\ninterface IERC721Internal {\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed operator,\\n        uint256 indexed tokenId\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IERC721Enumerable {\\n    /**\\n     * @notice get total token supply\\n     * @return total supply\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @notice get token of given owner at given internal storage index\\n     * @param owner token holder to query\\n     * @param index position in owner's token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        external\\n        view\\n        returns (uint256 tokenId);\\n\\n    /**\\n     * @notice get token at given internal storage index\\n     * @param index position in global token list to query\\n     * @return tokenId id of retrieved token\\n     */\\n    function tokenByIndex(uint256 index)\\n        external\\n        view\\n        returns (uint256 tokenId);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/enumerable/ERC721EnumerableInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721BaseStorage } from '../base/ERC721BaseStorage.sol';\\n\\nabstract contract ERC721EnumerableInternal {\\n    using ERC721BaseStorage for ERC721BaseStorage.Layout;\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _totalSupply() internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().totalSupply();\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenOfOwnerByIndex(address owner, uint256 index)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        return ERC721BaseStorage.layout().tokenOfOwnerByIndex(owner, index);\\n    }\\n\\n    /**\\n     * @notice TODO\\n     */\\n    function _tokenByIndex(uint256 index) internal view returns (uint256) {\\n        return ERC721BaseStorage.layout().tokenByIndex(index);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/utils/UintUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary UintUtils {\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return '0';\\n        }\\n\\n        uint256 temp = value;\\n        uint256 digits;\\n\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n\\n        bytes memory buffer = new bytes(digits);\\n\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC721MetadataStorage {\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC721Metadata');\\n\\n    struct Layout {\\n        string name;\\n        string symbol;\\n        string baseURI;\\n        mapping(uint256 => string) tokenURIs;\\n    }\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/ERC721MetadataInternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { ERC721BaseInternal } from '../base/ERC721Base.sol';\\nimport { ERC721MetadataStorage } from './ERC721MetadataStorage.sol';\\n\\n/**\\n * @notice ERC721Metadata internal functions\\n */\\nabstract contract ERC721MetadataInternal is ERC721BaseInternal {\\n    /**\\n     * @notice ERC721 hook: clear per-token URI data on burn\\n     * @inheritdoc ERC721BaseInternal\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (to == address(0)) {\\n            delete ERC721MetadataStorage.layout().tokenURIs[tokenId];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/token/ERC721/metadata/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721Metadata interface\\n */\\ninterface IERC721Metadata {\\n    /**\\n     * @notice get token name\\n     * @return token name\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @notice get token symbol\\n     * @return token symbol\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @notice get generated URI for given token\\n     * @return token URI\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary ERC165Storage {\\n    struct Layout {\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.ERC165');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function isSupportedInterface(Layout storage l, bytes4 interfaceId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return l.supportedInterfaces[interfaceId];\\n    }\\n\\n    function setSupportedInterface(\\n        Layout storage l,\\n        bytes4 interfaceId,\\n        bool status\\n    ) internal {\\n        require(interfaceId != 0xffffffff, 'ERC165: invalid interface id');\\n        l.supportedInterfaces[interfaceId] = status;\\n    }\\n}\\n\"\r\n    },\r\n    \"@solidstate/contracts/access/OwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary OwnableStorage {\\n    struct Layout {\\n        address owner;\\n    }\\n\\n    bytes32 internal constant STORAGE_SLOT =\\n        keccak256('solidstate.contracts.storage.Ownable');\\n\\n    function layout() internal pure returns (Layout storage l) {\\n        bytes32 slot = STORAGE_SLOT;\\n        assembly {\\n            l.slot := slot\\n        }\\n    }\\n\\n    function setOwner(Layout storage l, address owner) internal {\\n        l.owner = owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFRequestIDBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract VRFRequestIDBase {\\n  /**\\n   * @notice returns the seed which is actually input to the VRF coordinator\\n   *\\n   * @dev To prevent repetition of VRF output due to repetition of the\\n   * @dev user-supplied seed, that seed is combined in a hash with the\\n   * @dev user-specific nonce, and the address of the consuming contract. The\\n   * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\\n   * @dev the final seed, but the nonce does protect against repetition in\\n   * @dev requests which are included in a single block.\\n   *\\n   * @param _userSeed VRF seed input provided by user\\n   * @param _requester Address of the requesting contract\\n   * @param _nonce User-specific nonce at the time of the request\\n   */\\n  function makeVRFInputSeed(\\n    bytes32 _keyHash,\\n    uint256 _userSeed,\\n    address _requester,\\n    uint256 _nonce\\n  ) internal pure returns (uint256) {\\n    return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n  }\\n\\n  /**\\n   * @notice Returns the id for this request\\n   * @param _keyHash The serviceAgreement ID to be used for this request\\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\\n   * @return The id for this request\\n   *\\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\\n   * @dev contract, but the one generated by makeVRFInputSeed\\n   */\\n  function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n  }\\n}\\n\"\r\n    },\r\n    \"base64-sol/base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0;\\n\\n/// @title Base64\\n/// @author Brecht Devos - <brecht@loopring.org>\\n/// @notice Provides functions for encoding/decoding base64\\nlibrary Base64 {\\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\\n    bytes  internal constant TABLE_DECODE = hex\\\"0000000000000000000000000000000000000000000000000000000000000000\\\"\\n                                            hex\\\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\\\"\\n                                            hex\\\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\\\"\\n                                            hex\\\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\\\";\\n\\n    function encode(bytes memory data) internal pure returns (string memory) {\\n        if (data.length == 0) return '';\\n\\n        // load the table into memory\\n        string memory table = TABLE_ENCODE;\\n\\n        // multiply by 4/3 rounded up\\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\\n\\n        // add some extra buffer at the end required for the writing\\n        string memory result = new string(encodedLen + 32);\\n\\n        assembly {\\n            // set the actual output length\\n            mstore(result, encodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 3 bytes at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n                // read 3 bytes\\n                dataPtr := add(dataPtr, 3)\\n                let input := mload(dataPtr)\\n\\n                // write 4 characters\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\\n                resultPtr := add(resultPtr, 1)\\n            }\\n\\n            // padding with '='\\n            switch mod(mload(data), 3)\\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\\n        }\\n\\n        return result;\\n    }\\n\\n    function decode(string memory _data) internal pure returns (bytes memory) {\\n        bytes memory data = bytes(_data);\\n\\n        if (data.length == 0) return new bytes(0);\\n        require(data.length % 4 == 0, \\\"invalid base64 decoder input\\\");\\n\\n        // load the table into memory\\n        bytes memory table = TABLE_DECODE;\\n\\n        // every 4 characters represent 3 bytes\\n        uint256 decodedLen = (data.length / 4) * 3;\\n\\n        // add some extra buffer at the end required for the writing\\n        bytes memory result = new bytes(decodedLen + 32);\\n\\n        assembly {\\n            // padding with '='\\n            let lastBytes := mload(add(data, mload(data)))\\n            if eq(and(lastBytes, 0xFF), 0x3d) {\\n                decodedLen := sub(decodedLen, 1)\\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\\n                    decodedLen := sub(decodedLen, 1)\\n                }\\n            }\\n\\n            // set the actual output length\\n            mstore(result, decodedLen)\\n\\n            // prepare the lookup table\\n            let tablePtr := add(table, 1)\\n\\n            // input ptr\\n            let dataPtr := data\\n            let endPtr := add(dataPtr, mload(data))\\n\\n            // result ptr, jump over length\\n            let resultPtr := add(result, 32)\\n\\n            // run over the input, 4 characters at a time\\n            for {} lt(dataPtr, endPtr) {}\\n            {\\n               // read 4 characters\\n               dataPtr := add(dataPtr, 4)\\n               let input := mload(dataPtr)\\n\\n               // write 3 bytes\\n               let output := add(\\n                   add(\\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\\n                   add(\\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\\n                    )\\n                )\\n                mstore(resultPtr, shl(232, output))\\n                resultPtr := add(resultPtr, 3)\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChonkyAttributes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IChonkyAttributes} from \\\"./interface/IChonkyAttributes.sol\\\";\\n\\ncontract ChonkyAttributes is IChonkyAttributes {\\n    function _getBodyAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.WICKED, 10);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.CUTE, 9);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.POWER, 10);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 10) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 11) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 12) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 13) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 14) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 15) return (IChonkyAttributes.AttributeType.BRAIN, 6);\\n        if (_id == 16) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 17) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 18) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 19) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 20) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 21) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 22) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 23) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 24) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 25) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 26) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 27) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 28) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 29) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 30) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 31) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 32) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 33) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 34) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 35) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 36) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 37) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 38) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 39) return (IChonkyAttributes.AttributeType.POWER, 10);\\n        if (_id == 40) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 41) return (IChonkyAttributes.AttributeType.WICKED, 7);\\n        if (_id == 42) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 43) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 44) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 45) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 46) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 47) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 48) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 49) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 50) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 51) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 52) return (IChonkyAttributes.AttributeType.WICKED, 7);\\n        if (_id == 53) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 54) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 55) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 56) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 57) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 58) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 59) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 60) return (IChonkyAttributes.AttributeType.WICKED, 9);\\n        if (_id == 61) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 62) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 63) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 64) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 65) return (IChonkyAttributes.AttributeType.CUTE, 10);\\n        if (_id == 66) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 67) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 68) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 69) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 70) return (IChonkyAttributes.AttributeType.BRAIN, 10);\\n        if (_id == 71) return (IChonkyAttributes.AttributeType.BRAIN, 7);\\n        if (_id == 72) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 73) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 74) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 75) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 76) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 77) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 78) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 79) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 80) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 81) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 82) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 83) return (IChonkyAttributes.AttributeType.CUTE, 8);\\n        if (_id == 84) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 85) return (IChonkyAttributes.AttributeType.BRAIN, 7);\\n        if (_id == 86) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 87) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 88) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 89) return (IChonkyAttributes.AttributeType.BRAIN, 4);\\n        if (_id == 90) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 91) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _getEyesAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.WICKED, 7);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 10) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 11) return (IChonkyAttributes.AttributeType.WICKED, 10);\\n        if (_id == 12) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 13) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 14) return (IChonkyAttributes.AttributeType.CUTE, 8);\\n        if (_id == 15) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 16) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 17) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 18) return (IChonkyAttributes.AttributeType.BRAIN, 6);\\n        if (_id == 19) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 20) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 21) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 22) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 23) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 24) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 25) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 26) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 27) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 28) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 29) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 30) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 31) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 32) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 33) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 34) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 35) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 36) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 37) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 38) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 39) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 40) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 41) return (IChonkyAttributes.AttributeType.BRAIN, 7);\\n        if (_id == 42) return (IChonkyAttributes.AttributeType.WICKED, 10);\\n        if (_id == 43) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 44) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 45) return (IChonkyAttributes.AttributeType.WICKED, 9);\\n        if (_id == 46) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 47) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 48) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 49) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 50) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 51) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 52) return (IChonkyAttributes.AttributeType.BRAIN, 4);\\n        if (_id == 53) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 54) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 55) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 56) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 57) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 58) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 59) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 60) return (IChonkyAttributes.AttributeType.WICKED, 1);\\n        if (_id == 61) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _getMouthAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.CUTE, 8);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 10) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 11) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 12) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 13) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 14) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 15) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 16) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 17) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 18) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 19) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 20) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 21) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 22) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 23) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 24) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 25) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 26) return (IChonkyAttributes.AttributeType.BRAIN, 6);\\n        if (_id == 27) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 28) return (IChonkyAttributes.AttributeType.BRAIN, 4);\\n        if (_id == 29) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 30) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 31) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 32) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 33) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 34) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 35) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 36) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 37) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 38) return (IChonkyAttributes.AttributeType.WICKED, 7);\\n        if (_id == 39) return (IChonkyAttributes.AttributeType.BRAIN, 6);\\n        if (_id == 40) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 41) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 42) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 43) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 44) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 45) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 46) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 47) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 48) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 49) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 50) return (IChonkyAttributes.AttributeType.WICKED, 1);\\n        if (_id == 51) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 52) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 53) return (IChonkyAttributes.AttributeType.NONE, 0);\\n        if (_id == 54) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _getHatAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.CUTE, 8);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.WICKED, 9);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 10) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 11) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 12) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 13) return (IChonkyAttributes.AttributeType.WICKED, 10);\\n        if (_id == 14) return (IChonkyAttributes.AttributeType.POWER, 10);\\n        if (_id == 15) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 16) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 17) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 18) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 19) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 20) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 21) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 22) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 23) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 24) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 25) return (IChonkyAttributes.AttributeType.WICKED, 7);\\n        if (_id == 26) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 27) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 28) return (IChonkyAttributes.AttributeType.POWER, 10);\\n        if (_id == 29) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 30) return (IChonkyAttributes.AttributeType.WICKED, 6);\\n        if (_id == 31) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 32) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 33) return (IChonkyAttributes.AttributeType.CUTE, 9);\\n        if (_id == 34) return (IChonkyAttributes.AttributeType.BRAIN, 7);\\n        if (_id == 35) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 36) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 37) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 38) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 39) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 40) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 41) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 42) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 43) return (IChonkyAttributes.AttributeType.BRAIN, 7);\\n        if (_id == 44) return (IChonkyAttributes.AttributeType.CUTE, 9);\\n        if (_id == 45) return (IChonkyAttributes.AttributeType.BRAIN, 4);\\n        if (_id == 46) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 47) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 48) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 49) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 50) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 51) return (IChonkyAttributes.AttributeType.WICKED, 1);\\n        if (_id == 52) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 53) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 54) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 55) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 56) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 57) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 58) return (IChonkyAttributes.AttributeType.CUTE, 8);\\n        if (_id == 59) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 60) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 61) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 62) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 63) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 64) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 65) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 66) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 67) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 68) return (IChonkyAttributes.AttributeType.BRAIN, 6);\\n        if (_id == 69) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 70) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 71) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 72) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 73) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 74) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 75) return (IChonkyAttributes.AttributeType.CUTE, 10);\\n        if (_id == 76) return (IChonkyAttributes.AttributeType.CUTE, 9);\\n        if (_id == 77) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 78) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 79) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 80) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 81) return (IChonkyAttributes.AttributeType.BRAIN, 10);\\n        if (_id == 82) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 83) return (IChonkyAttributes.AttributeType.POWER, 8);\\n        if (_id == 84) return (IChonkyAttributes.AttributeType.BRAIN, 8);\\n        if (_id == 85) return (IChonkyAttributes.AttributeType.POWER, 6);\\n        if (_id == 86) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 87) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n        if (_id == 88) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 89) return (IChonkyAttributes.AttributeType.POWER, 7);\\n        if (_id == 90) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 91) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 92) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 93) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 94) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 95) return (IChonkyAttributes.AttributeType.CUTE, 10);\\n        if (_id == 96) return (IChonkyAttributes.AttributeType.POWER, 2);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _getWingsAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.CUTE, 6);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.WICKED, 8);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.CUTE, 4);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.POWER, 9);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.WICKED, 4);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.POWER, 4);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.CUTE, 7);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.BRAIN, 9);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _getSetAttribute(uint256 _id)\\n        internal\\n        pure\\n        returns (IChonkyAttributes.AttributeType, uint256)\\n    {\\n        if (_id == 0) return (IChonkyAttributes.AttributeType.NONE, 0);\\n\\n        if (_id == 1) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 2) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 3) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 4) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 5) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 6) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 7) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 8) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 9) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 10) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 11) return (IChonkyAttributes.AttributeType.BRAIN, 1);\\n        if (_id == 12) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 13) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 14) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 15) return (IChonkyAttributes.AttributeType.BRAIN, 2);\\n        if (_id == 16) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 17) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 18) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 19) return (IChonkyAttributes.AttributeType.WICKED, 1);\\n        if (_id == 20) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 21) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 22) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 23) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 24) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 25) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 26) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 27) return (IChonkyAttributes.AttributeType.WICKED, 2);\\n        if (_id == 28) return (IChonkyAttributes.AttributeType.CUTE, 2);\\n        if (_id == 29) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 30) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 31) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 32) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 33) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 34) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 35) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 36) return (IChonkyAttributes.AttributeType.POWER, 1);\\n        if (_id == 37) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 38) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 39) return (IChonkyAttributes.AttributeType.WICKED, 5);\\n        if (_id == 40) return (IChonkyAttributes.AttributeType.CUTE, 5);\\n        if (_id == 41) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 42) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 43) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 44) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 45) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 46) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 47) return (IChonkyAttributes.AttributeType.POWER, 5);\\n        if (_id == 48) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 49) return (IChonkyAttributes.AttributeType.BRAIN, 5);\\n        if (_id == 50) return (IChonkyAttributes.AttributeType.CUTE, 3);\\n        if (_id == 51) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 52) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 53) return (IChonkyAttributes.AttributeType.CUTE, 1);\\n        if (_id == 54) return (IChonkyAttributes.AttributeType.BRAIN, 3);\\n        if (_id == 55) return (IChonkyAttributes.AttributeType.POWER, 3);\\n        if (_id == 56) return (IChonkyAttributes.AttributeType.POWER, 2);\\n        if (_id == 57) return (IChonkyAttributes.AttributeType.WICKED, 3);\\n        if (_id == 58) return (IChonkyAttributes.AttributeType.CUTE, 0);\\n\\n        return (IChonkyAttributes.AttributeType.NONE, 0);\\n    }\\n\\n    function _addAttributeValue(\\n        uint256[4] memory _array,\\n        uint256 _value,\\n        IChonkyAttributes.AttributeType _valueType\\n    ) internal pure returns (uint256[4] memory) {\\n        if (_valueType != IChonkyAttributes.AttributeType.NONE) {\\n            _array[uint256(_valueType) - 1] += _value;\\n        }\\n\\n        return _array;\\n    }\\n\\n    function getAttributeValues(uint256[12] memory _attributes, uint256 _setId)\\n        public\\n        pure\\n        returns (uint256[4] memory result)\\n    {\\n        uint256 value;\\n        IChonkyAttributes.AttributeType valueType;\\n\\n        (valueType, value) = _getWingsAttribute(_attributes[2]);\\n        result = _addAttributeValue(result, value, valueType);\\n\\n        (valueType, value) = _getBodyAttribute(_attributes[6]);\\n        result = _addAttributeValue(result, value, valueType);\\n\\n        (valueType, value) = _getMouthAttribute(_attributes[7]);\\n        result = _addAttributeValue(result, value, valueType);\\n\\n        (valueType, value) = _getEyesAttribute(_attributes[8]);\\n        result = _addAttributeValue(result, value, valueType);\\n\\n        (valueType, value) = _getHatAttribute(_attributes[9]);\\n        result = _addAttributeValue(result, value, valueType);\\n\\n        (valueType, value) = _getSetAttribute(_setId);\\n        result = _addAttributeValue(result, value, valueType);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ChonkySet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport {IChonkySet} from \\\"./interface/IChonkySet.sol\\\";\\n\\ncontract ChonkySet is IChonkySet {\\n    function getSetId(uint256 _genome) external pure returns (uint256) {\\n        return _getSetId(_genome);\\n    }\\n\\n    function getSetFromGenome(uint256 _genome)\\n        external\\n        pure\\n        returns (string memory)\\n    {\\n        return _getSetFromId(_getSetId(_genome));\\n    }\\n\\n    function getSetFromId(uint256 _setId)\\n        external\\n        pure\\n        returns (string memory)\\n    {\\n        return _getSetFromId(_setId);\\n    }\\n\\n    function _getSetId(uint256 _genome) internal pure returns (uint256) {\\n        if (_genome == 0x025e716c06d02c) return 1;\\n        if (_genome == 0x02c8cca802518f) return 2;\\n        if (_genome == 0x38e108027089) return 3;\\n        if (_genome == 0x51ad0c0d7065) return 4;\\n        if (_genome == 0x704e0ea50332) return 5;\\n        if (_genome == 0xec821004d052) return 6;\\n        if (_genome == 0x0398a060045048) return 7;\\n        if (_genome == 0x05836b2008d04c) return 8;\\n        if (_genome == 0x016daf22043029) return 9;\\n        if (_genome == 0x635b242d4063) return 10;\\n        if (_genome == 0x018ac826022089) return 11;\\n        if (_genome == 0x035edd5c064089) return 12;\\n        if (_genome == 0x0190002a000049) return 13;\\n        if (_genome == 0x01bcda2e0e8083) return 14;\\n        if (_genome == 0x028e4d4608d068) return 15;\\n        if (_genome == 0x0402a45842e02c) return 16;\\n        if (_genome == 0x04f16530657022) return 17;\\n        if (_genome == 0x013bd48e40f02e) return 18;\\n        if (_genome == 0xf15712212084) return 19;\\n        if (_genome == 0x01de0966016582) return 20;\\n        if (_genome == 0x03b39e3407208f) return 21;\\n        if (_genome == 0x0228cc3608304a) return 22;\\n        if (_genome == 0x01eb7338017065) return 23;\\n        if (_genome == 0x055e587a084032) return 24;\\n        if (_genome == 0x04a81aa20e3029) return 25;\\n        if (_genome == 0x8dca3a044022) return 26;\\n        if (_genome == 0x01504f2c07006c) return 27;\\n        if (_genome == 0x02d6224c10304a) return 28;\\n        if (_genome == 0x012d101e0b2084) return 29;\\n        if (_genome == 0x01c7954e028086) return 30;\\n        if (_genome == 0x251906042067) return 31;\\n        if (_genome == 0x059e125704d065) return 32;\\n        if (_genome == 0x0510008c000049) return 33;\\n        if (_genome == 0x038974520c408b) return 34;\\n        if (_genome == 0x0326df280cd086) return 35;\\n        if (_genome == 0x03ca296204d050) return 36;\\n        if (_genome == 0x03ff216a058092) return 37;\\n        if (_genome == 0x04545a76104062) return 38;\\n        if (_genome == 0x046a8078041067) return 39;\\n        if (_genome == 0x04b6d18200508f) return 40;\\n        if (_genome == 0x030ca68808d042) return 41;\\n        if (_genome == 0x168502c5802f) return 42;\\n        if (_genome == 0x052e28920ea089) return 43;\\n        if (_genome == 0x05380894022085) return 44;\\n        if (_genome == 0x054cea9808d023) return 45;\\n        if (_genome == 0x02ea56160eb08a) return 46;\\n        if (_genome == 0x0560009e02a082) return 47;\\n        if (_genome == 0x023f63680b0090) return 48;\\n        if (_genome == 0x057d6ca0044983) return 49;\\n        if (_genome == 0x01fc6ba6aa502d) return 50;\\n        if (_genome == 0x031b320a00104b) return 51;\\n        if (_genome == 0x05bd27480ea089) return 52;\\n        if (_genome == 0x40db5e110028) return 53;\\n        if (_genome == 0x02b157aa0eb021) return 54;\\n        if (_genome == 0x05dae8aca25192) return 55;\\n        if (_genome == 0x05e568ae048023) return 56;\\n        if (_genome == 0x011875b6129067) return 57;\\n\\n        return 0;\\n    }\\n\\n    function _getSetFromId(uint256 _id) internal pure returns (string memory) {\\n        if (_id == 1) return \\\"American Football\\\";\\n        if (_id == 2) return \\\"Angel\\\";\\n        if (_id == 3) return \\\"Astronaut\\\";\\n        if (_id == 4) return \\\"Baron Samedi\\\";\\n        if (_id == 5) return \\\"Bee\\\";\\n        if (_id == 6) return \\\"Black Kabuto\\\";\\n        if (_id == 7) return \\\"Blue Ninja\\\";\\n        if (_id == 8) return \\\"Bubble Tea\\\";\\n        if (_id == 9) return \\\"Captain\\\";\\n        if (_id == 10) return \\\"Caveman\\\";\\n        if (_id == 11) return \\\"Chef\\\";\\n        if (_id == 12) return \\\"Chonky Plant\\\";\\n        if (_id == 13) return \\\"Cloth Monster\\\";\\n        if (_id == 14) return \\\"Cowboy\\\";\\n        if (_id == 15) return \\\"Crazy Scientist\\\";\\n        if (_id == 16) return \\\"Cyber Hacker\\\";\\n        if (_id == 17) return \\\"Cyberpunk\\\";\\n        if (_id == 18) return \\\"Cyborg\\\";\\n        if (_id == 19) return \\\"Dark Magician\\\";\\n        if (_id == 20) return \\\"Devil\\\";\\n        if (_id == 21) return \\\"Diver\\\";\\n        if (_id == 22) return \\\"Doraemon\\\";\\n        if (_id == 23) return \\\"Dracula\\\";\\n        if (_id == 24) return \\\"Ese Sombrero\\\";\\n        if (_id == 25) return \\\"Gentleman\\\";\\n        if (_id == 26) return \\\"Golden Tooth\\\";\\n        if (_id == 27) return \\\"Jack-O-Lantern\\\";\\n        if (_id == 28) return \\\"Japanese Drummer\\\";\\n        if (_id == 29) return \\\"Jester\\\";\\n        if (_id == 30) return \\\"King\\\";\\n        if (_id == 31) return \\\"Lake Monster\\\";\\n        if (_id == 32) return \\\"Luffy\\\";\\n        if (_id == 33) return \\\"Mr Roboto\\\";\\n        if (_id == 34) return \\\"Mushroom Guy\\\";\\n        if (_id == 35) return \\\"New Year Outfit\\\";\\n        if (_id == 36) return \\\"Old Lady\\\";\\n        if (_id == 37) return \\\"Pharaoh\\\";\\n        if (_id == 38) return \\\"Pirate\\\";\\n        if (_id == 39) return \\\"Plague Doctor\\\";\\n        if (_id == 40) return \\\"Rainbow Love\\\";\\n        if (_id == 41) return \\\"Red Samurai\\\";\\n        if (_id == 42) return \\\"Retro\\\";\\n        if (_id == 43) return \\\"Roman\\\";\\n        if (_id == 44) return \\\"Safari Hunter\\\";\\n        if (_id == 45) return \\\"Sherlock\\\";\\n        if (_id == 46) return \\\"Snow Dude\\\";\\n        if (_id == 47) return \\\"Sparta\\\";\\n        if (_id == 48) return \\\"Spicy Man\\\";\\n        if (_id == 49) return \\\"Steampunk\\\";\\n        if (_id == 50) return \\\"Swimmer\\\";\\n        if (_id == 51) return \\\"Tanuki\\\";\\n        if (_id == 52) return \\\"Tin Man\\\";\\n        if (_id == 53) return \\\"Tired Dad\\\";\\n        if (_id == 54) return \\\"Tron Boy\\\";\\n        if (_id == 55) return \\\"Valkyrie\\\";\\n        if (_id == 56) return \\\"Viking\\\";\\n        if (_id == 57) return \\\"Zombie\\\";\\n\\n        return \\\"\\\";\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IChonkyMetadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChonkyMetadata {\\n    function buildTokenURI(\\n        uint256 id,\\n        uint256 genomeId,\\n        uint256 genome,\\n        string memory CID,\\n        address chonkySet,\\n        address chonkyAttributes\\n    ) external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IChonkySet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChonkySet {\\n    function getSetId(uint256 _genome) external pure returns (uint256);\\n\\n    function getSetFromGenome(uint256 _genome)\\n        external\\n        pure\\n        returns (string memory);\\n\\n    function getSetFromId(uint256 _setId) external pure returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/IChonkyAttributes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IChonkyAttributes {\\n    enum AttributeType {\\n        NONE,\\n        BRAIN,\\n        CUTE,\\n        POWER,\\n        WICKED\\n    }\\n\\n    function getAttributeValues(uint256[12] memory _attributes, uint256 _setId)\\n        external\\n        pure\\n        returns (uint256[4] memory result);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_vrfKeyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_vrfFee\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"CreateChonky\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"Reveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"name\":\"RevealInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_genomes\",\"type\":\"uint256[]\"}],\"name\":\"addPackedGenomes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"_attributes\",\"type\":\"uint256[12]\"}],\"name\":\"formatGenome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"genome\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCID\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChonkyAttributesAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChonkyMetadataAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChonkySetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getGenome\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOffset\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStartTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mintReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_genome\",\"type\":\"uint256\"}],\"name\":\"parseGenome\",\"outputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"result\",\"type\":\"uint256[12]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reveal\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setStartTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ChonkyNFT", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f0d54349addcf704f77ae15b96510dea15cb7952000000000000000000000000514910771af9ca656af840dff83e8264ecf986caaa77729d3466ca35ae8d28b3bbac7cc36a5031efdc430821c02bc31a238af4450000000000000000000000000000000000000000000000001bc16d674ec80000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}