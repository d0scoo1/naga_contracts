{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/verifier/TurboVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Bn254Crypto} from './cryptography/Bn254Crypto.sol';\\nimport {PolynomialEval} from './cryptography/PolynomialEval.sol';\\nimport {Types} from './cryptography/Types.sol';\\nimport {VerificationKeys} from './keys/VerificationKeys.sol';\\nimport {Transcript} from './cryptography/Transcript.sol';\\nimport {IVerifier} from '../interfaces/IVerifier.sol';\\n\\n/**\\n * @title Turbo Plonk proof verification contract\\n * @dev Top level Plonk proof verification contract, which allows Plonk proof to be verified\\n *\\n * Copyright 2020 Spilsbury Holdings Ltd\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\ncontract TurboVerifier is IVerifier {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n    using Transcript for Transcript.TranscriptData;\\n\\n    /**\\n     * @dev Verify a Plonk proof\\n     * @param - array of serialized proof data\\n     * @param rollup_size - number of transactions in the rollup\\n     */\\n    function verify(bytes calldata, uint256 rollup_size) external override {\\n        // extract the correct rollup verification key\\n        Types.VerificationKey memory vk = VerificationKeys.getKeyById(rollup_size);\\n        uint256 num_public_inputs = vk.num_inputs;\\n\\n        // parse the input calldata and construct a Proof object\\n        Types.Proof memory decoded_proof = deserialize_proof(num_public_inputs, vk);\\n\\n        Transcript.TranscriptData memory transcript;\\n        transcript.generate_initial_challenge(vk.circuit_size, vk.num_inputs);\\n\\n        // reconstruct the beta, gamma, alpha and zeta challenges\\n        Types.ChallengeTranscript memory challenges;\\n        transcript.generate_beta_gamma_challenges(challenges, vk.num_inputs);\\n        transcript.generate_alpha_challenge(challenges, decoded_proof.Z);\\n        transcript.generate_zeta_challenge(challenges, decoded_proof.T1, decoded_proof.T2, decoded_proof.T3, decoded_proof.T4);\\n\\n        /**\\n         * Compute all inverses that will be needed throughout the program here.\\n         *\\n         * This is an efficiency improvement - it allows us to make use of the batch inversion Montgomery trick,\\n         * which allows all inversions to be replaced with one inversion operation, at the expense of a few\\n         * additional multiplications\\n         **/\\n        (uint256 quotient_eval, uint256 L1) = evalaute_field_operations(decoded_proof, vk, challenges);\\n        decoded_proof.quotient_polynomial_eval = quotient_eval;\\n\\n        // reconstruct the nu and u challenges\\n        transcript.generate_nu_challenges(challenges, decoded_proof.quotient_polynomial_eval, vk.num_inputs);\\n        transcript.generate_separator_challenge(challenges, decoded_proof.PI_Z, decoded_proof.PI_Z_OMEGA);\\n\\n        //reset 'alpha base'\\n        challenges.alpha_base = challenges.alpha;\\n\\n        Types.G1Point memory linearised_contribution = PolynomialEval.compute_linearised_opening_terms(\\n            challenges,\\n            L1,\\n            vk,\\n            decoded_proof\\n        );\\n\\n        Types.G1Point memory batch_opening_commitment = PolynomialEval.compute_batch_opening_commitment(\\n            challenges,\\n            vk,\\n            linearised_contribution,\\n            decoded_proof\\n        );\\n\\n        uint256 batch_evaluation_g1_scalar = PolynomialEval.compute_batch_evaluation_scalar_multiplier(\\n            decoded_proof,\\n            challenges\\n        );\\n\\n        bool result = perform_pairing(\\n            batch_opening_commitment,\\n            batch_evaluation_g1_scalar,\\n            challenges,\\n            decoded_proof,\\n            vk\\n        );\\n        require(result, 'Proof failed');\\n    }\\n\\n\\n    /**\\n     * @dev Compute partial state of the verifier, specifically: public input delta evaluation, zero polynomial\\n     * evaluation, the lagrange evaluations and the quotient polynomial evaluations\\n     *\\n     * Note: This uses the batch inversion Montgomery trick to reduce the number of\\n     * inversions, and therefore the number of calls to the bn128 modular exponentiation\\n     * precompile.\\n     *\\n     * Specifically, each function call: compute_public_input_delta() etc. at some point needs to invert a\\n     * value to calculate a denominator in a fraction. Instead of performing this inversion as it is needed, we\\n     * instead 'save up' the denominator calculations. The inputs to this are returned from the various functions\\n     * and then we perform all necessary inversions in one go at the end of `evalaute_field_operations()`. This\\n     * gives us the various variables that need to be returned.\\n     *\\n     * @param decoded_proof - deserialised proof\\n     * @param vk - verification key\\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\\n     * ChallengeTranscript struct form\\n     * @return quotient polynomial evaluation (field element) and lagrange 1 evaluation (field element)\\n     */\\n    function evalaute_field_operations(\\n        Types.Proof memory decoded_proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal view returns (uint256, uint256) {\\n        uint256 public_input_delta;\\n        uint256 zero_polynomial_eval;\\n        uint256 l_start;\\n        uint256 l_end;\\n        {\\n            (uint256 public_input_numerator, uint256 public_input_denominator) = PolynomialEval.compute_public_input_delta(\\n                challenges,\\n                vk\\n            );\\n\\n            (\\n                uint256 vanishing_numerator,\\n                uint256 vanishing_denominator,\\n                uint256 lagrange_numerator,\\n                uint256 l_start_denominator,\\n                uint256 l_end_denominator\\n            ) = PolynomialEval.compute_lagrange_and_vanishing_fractions(vk, challenges.zeta);\\n\\n\\n            (zero_polynomial_eval, public_input_delta, l_start, l_end) = PolynomialEval.compute_batch_inversions(\\n                public_input_numerator,\\n                public_input_denominator,\\n                vanishing_numerator,\\n                vanishing_denominator,\\n                lagrange_numerator,\\n                l_start_denominator,\\n                l_end_denominator\\n            );\\n        }\\n\\n        uint256 quotient_eval = PolynomialEval.compute_quotient_polynomial(\\n            zero_polynomial_eval,\\n            public_input_delta,\\n            challenges,\\n            l_start,\\n            l_end,\\n            decoded_proof\\n        );\\n\\n        return (quotient_eval, l_start);\\n    }\\n\\n\\n    /**\\n     * @dev Perform the pairing check\\n     * @param batch_opening_commitment - G1 point representing the calculated batch opening commitment\\n     * @param batch_evaluation_g1_scalar - uint256 representing the batch evaluation scalar multiplier to be applied to the G1 generator point\\n     * @param challenges - all challenges (alpha, beta, gamma, zeta, nu[NUM_NU_CHALLENGES], u) stored in\\n     * ChallengeTranscript struct form\\n     * @param vk - verification key\\n     * @param decoded_proof - deserialised proof\\n     * @return bool specifying whether the pairing check was successful\\n     */\\n    function perform_pairing(\\n        Types.G1Point memory batch_opening_commitment,\\n        uint256 batch_evaluation_g1_scalar,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory decoded_proof,\\n        Types.VerificationKey memory vk\\n    ) internal view returns (bool) {\\n\\n        uint256 u = challenges.u;\\n        bool success;\\n        uint256 p = Bn254Crypto.r_mod;\\n        Types.G1Point memory rhs;     \\n        Types.G1Point memory PI_Z_OMEGA = decoded_proof.PI_Z_OMEGA;\\n        Types.G1Point memory PI_Z = decoded_proof.PI_Z;\\n        PI_Z.validateG1Point();\\n        PI_Z_OMEGA.validateG1Point();\\n    \\n        // rhs = zeta.[PI_Z] + u.zeta.omega.[PI_Z_OMEGA] + [batch_opening_commitment] - batch_evaluation_g1_scalar.[1]\\n        // scope this block to prevent stack depth errors\\n        {\\n            uint256 zeta = challenges.zeta;\\n            uint256 pi_z_omega_scalar = vk.work_root;\\n            assembly {\\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, zeta, p)\\n                pi_z_omega_scalar := mulmod(pi_z_omega_scalar, u, p)\\n                batch_evaluation_g1_scalar := sub(p, batch_evaluation_g1_scalar)\\n\\n                // store accumulator point at mptr\\n                let mPtr := mload(0x40)\\n\\n                // set accumulator = batch_opening_commitment\\n                mstore(mPtr, mload(batch_opening_commitment))\\n                mstore(add(mPtr, 0x20), mload(add(batch_opening_commitment, 0x20)))\\n\\n                // compute zeta.[PI_Z] and add into accumulator\\n                mstore(add(mPtr, 0x40), mload(PI_Z))\\n                mstore(add(mPtr, 0x60), mload(add(PI_Z, 0x20)))\\n                mstore(add(mPtr, 0x80), zeta)\\n                success := staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40)\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n                // compute u.zeta.omega.[PI_Z_OMEGA] and add into accumulator\\n                mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\\n                mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n                mstore(add(mPtr, 0x80), pi_z_omega_scalar)\\n                success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n                // compute -batch_evaluation_g1_scalar.[1]\\n                mstore(add(mPtr, 0x40), 0x01) // hardcoded generator point (1, 2)\\n                mstore(add(mPtr, 0x60), 0x02)\\n                mstore(add(mPtr, 0x80), batch_evaluation_g1_scalar)\\n                success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n\\n                // add -batch_evaluation_g1_scalar.[1] and the accumulator point, write result into rhs\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, rhs, 0x40))\\n            }\\n        }\\n\\n        Types.G1Point memory lhs;   \\n        assembly {\\n            // store accumulator point at mptr\\n            let mPtr := mload(0x40)\\n\\n            // copy [PI_Z] into mPtr\\n            mstore(mPtr, mload(PI_Z))\\n            mstore(add(mPtr, 0x20), mload(add(PI_Z, 0x20)))\\n\\n            // compute u.[PI_Z_OMEGA] and write to (mPtr + 0x40)\\n            mstore(add(mPtr, 0x40), mload(PI_Z_OMEGA))\\n            mstore(add(mPtr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n            mstore(add(mPtr, 0x80), u)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n            \\n            // add [PI_Z] + u.[PI_Z_OMEGA] and write result into lhs\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40))\\n        }\\n\\n        // negate lhs y-coordinate\\n        uint256 q = Bn254Crypto.p_mod;\\n        assembly {\\n            mstore(add(lhs, 0x20), sub(q, mload(add(lhs, 0x20))))\\n        }\\n\\n        if (vk.contains_recursive_proof)\\n        {\\n            // If the proof itself contains an accumulated proof,\\n            // we will have extracted two G1 elements `recursive_P1`, `recursive_p2` from the public inputs\\n\\n            // We need to evaluate that e(recursive_P1, [x]_2) == e(recursive_P2, [1]_2) to finish verifying the inner proof\\n            // We do this by creating a random linear combination between (lhs, recursive_P1) and (rhs, recursivee_P2)\\n            // That way we still only need to evaluate one pairing product\\n\\n            // We use `challenge.u * challenge.u` as the randomness to create a linear combination\\n            // challenge.u is produced by hashing the entire transcript, which contains the public inputs (and by extension the recursive proof)\\n\\n            // i.e. [lhs] = [lhs] + u.u.[recursive_P1]\\n            //      [rhs] = [rhs] + u.u.[recursive_P2]\\n            Types.G1Point memory recursive_P1 = decoded_proof.recursive_P1;\\n            Types.G1Point memory recursive_P2 = decoded_proof.recursive_P2;\\n            recursive_P1.validateG1Point();\\n            recursive_P2.validateG1Point();\\n            assembly {\\n                let mPtr := mload(0x40)\\n\\n                // compute u.u.[recursive_P1]\\n                mstore(mPtr, mload(recursive_P1))\\n                mstore(add(mPtr, 0x20), mload(add(recursive_P1, 0x20)))\\n                mstore(add(mPtr, 0x40), mulmod(u, u, p)) // separator_challenge = u * u\\n                success := and(success, staticcall(gas(), 7, mPtr, 0x60, add(mPtr, 0x60), 0x40))\\n\\n                // compute u.u.[recursive_P2] (u*u is still in memory at (mPtr + 0x40), no need to re-write it)\\n                mstore(mPtr, mload(recursive_P2))\\n                mstore(add(mPtr, 0x20), mload(add(recursive_P2, 0x20)))\\n                success := and(success, staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40))\\n\\n                // compute u.u.[recursiveP2] + rhs and write into rhs\\n                mstore(add(mPtr, 0xa0), mload(rhs))\\n                mstore(add(mPtr, 0xc0), mload(add(rhs, 0x20)))\\n                success := and(success, staticcall(gas(), 6, add(mPtr, 0x60), 0x80, rhs, 0x40))\\n\\n                // compute u.u.[recursiveP1] + lhs and write into lhs\\n                mstore(add(mPtr, 0x40), mload(lhs))\\n                mstore(add(mPtr, 0x60), mload(add(lhs, 0x20)))\\n                success := and(success, staticcall(gas(), 6, mPtr, 0x80, lhs, 0x40))\\n            }\\n        }\\n\\n        require(success, \\\"perform_pairing G1 operations preamble fail\\\");\\n\\n        return Bn254Crypto.pairingProd2(rhs, Bn254Crypto.P2(), lhs, vk.g2_x);\\n    }\\n\\n    /**\\n     * @dev Deserialize a proof into a Proof struct\\n     * @param num_public_inputs - number of public inputs in the proof. Taken from verification key\\n     * @return proof - proof deserialized into the proof struct\\n     */\\n    function deserialize_proof(uint256 num_public_inputs, Types.VerificationKey memory vk)\\n        internal\\n        pure\\n        returns (Types.Proof memory proof)\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 q = Bn254Crypto.p_mod;\\n        uint256 data_ptr;\\n        uint256 proof_ptr;\\n        // first 32 bytes of bytes array contains length, skip it\\n        assembly {\\n            data_ptr := add(calldataload(0x04), 0x24)\\n            proof_ptr := proof\\n        }\\n\\n        if (vk.contains_recursive_proof) {\\n            uint256 index_counter = vk.recursive_proof_indices * 32;\\n            uint256 x0 = 0;\\n            uint256 y0 = 0;\\n            uint256 x1 = 0;\\n            uint256 y1 = 0;\\n            assembly {\\n                index_counter := add(index_counter, data_ptr)\\n                x0 := calldataload(index_counter)\\n                x0 := add(x0, shl(68, calldataload(add(index_counter, 0x20))))\\n                x0 := add(x0, shl(136, calldataload(add(index_counter, 0x40))))\\n                x0 := add(x0, shl(204, calldataload(add(index_counter, 0x60))))\\n                y0 := calldataload(add(index_counter, 0x80))\\n                y0 := add(y0, shl(68, calldataload(add(index_counter, 0xa0))))\\n                y0 := add(y0, shl(136, calldataload(add(index_counter, 0xc0))))\\n                y0 := add(y0, shl(204, calldataload(add(index_counter, 0xe0))))\\n                x1 := calldataload(add(index_counter, 0x100))\\n                x1 := add(x1, shl(68, calldataload(add(index_counter, 0x120))))\\n                x1 := add(x1, shl(136, calldataload(add(index_counter, 0x140))))\\n                x1 := add(x1, shl(204, calldataload(add(index_counter, 0x160))))\\n                y1 := calldataload(add(index_counter, 0x180))\\n                y1 := add(y1, shl(68, calldataload(add(index_counter, 0x1a0))))\\n                y1 := add(y1, shl(136, calldataload(add(index_counter, 0x1c0))))\\n                y1 := add(y1, shl(204, calldataload(add(index_counter, 0x1e0))))\\n            }\\n\\n            proof.recursive_P1 = Bn254Crypto.new_g1(x0, y0);\\n            proof.recursive_P2 = Bn254Crypto.new_g1(x1, y1);\\n        }\\n\\n        assembly {\\n            let public_input_byte_length := mul(num_public_inputs, 0x20)\\n            data_ptr := add(data_ptr, public_input_byte_length)\\n  \\n            // proof.W1\\n            mstore(mload(proof_ptr), mod(calldataload(add(data_ptr, 0x20)), q))\\n            mstore(add(mload(proof_ptr), 0x20), mod(calldataload(data_ptr), q))\\n\\n            // proof.W2\\n            mstore(mload(add(proof_ptr, 0x20)), mod(calldataload(add(data_ptr, 0x60)), q))\\n            mstore(add(mload(add(proof_ptr, 0x20)), 0x20), mod(calldataload(add(data_ptr, 0x40)), q))\\n \\n            // proof.W3\\n            mstore(mload(add(proof_ptr, 0x40)), mod(calldataload(add(data_ptr, 0xa0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x40)), 0x20), mod(calldataload(add(data_ptr, 0x80)), q))\\n\\n            // proof.W4\\n            mstore(mload(add(proof_ptr, 0x60)), mod(calldataload(add(data_ptr, 0xe0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x60)), 0x20), mod(calldataload(add(data_ptr, 0xc0)), q))\\n  \\n            // proof.Z\\n            mstore(mload(add(proof_ptr, 0x80)), mod(calldataload(add(data_ptr, 0x120)), q))\\n            mstore(add(mload(add(proof_ptr, 0x80)), 0x20), mod(calldataload(add(data_ptr, 0x100)), q))\\n  \\n            // proof.T1\\n            mstore(mload(add(proof_ptr, 0xa0)), mod(calldataload(add(data_ptr, 0x160)), q))\\n            mstore(add(mload(add(proof_ptr, 0xa0)), 0x20), mod(calldataload(add(data_ptr, 0x140)), q))\\n\\n            // proof.T2\\n            mstore(mload(add(proof_ptr, 0xc0)), mod(calldataload(add(data_ptr, 0x1a0)), q))\\n            mstore(add(mload(add(proof_ptr, 0xc0)), 0x20), mod(calldataload(add(data_ptr, 0x180)), q))\\n\\n            // proof.T3\\n            mstore(mload(add(proof_ptr, 0xe0)), mod(calldataload(add(data_ptr, 0x1e0)), q))\\n            mstore(add(mload(add(proof_ptr, 0xe0)), 0x20), mod(calldataload(add(data_ptr, 0x1c0)), q))\\n\\n            // proof.T4\\n            mstore(mload(add(proof_ptr, 0x100)), mod(calldataload(add(data_ptr, 0x220)), q))\\n            mstore(add(mload(add(proof_ptr, 0x100)), 0x20), mod(calldataload(add(data_ptr, 0x200)), q))\\n  \\n            // proof.w1 to proof.w4\\n            mstore(add(proof_ptr, 0x120), mod(calldataload(add(data_ptr, 0x240)), p))\\n            mstore(add(proof_ptr, 0x140), mod(calldataload(add(data_ptr, 0x260)), p))\\n            mstore(add(proof_ptr, 0x160), mod(calldataload(add(data_ptr, 0x280)), p))\\n            mstore(add(proof_ptr, 0x180), mod(calldataload(add(data_ptr, 0x2a0)), p))\\n \\n            // proof.sigma1\\n            mstore(add(proof_ptr, 0x1a0), mod(calldataload(add(data_ptr, 0x2c0)), p))\\n\\n            // proof.sigma2\\n            mstore(add(proof_ptr, 0x1c0), mod(calldataload(add(data_ptr, 0x2e0)), p))\\n\\n            // proof.sigma3\\n            mstore(add(proof_ptr, 0x1e0), mod(calldataload(add(data_ptr, 0x300)), p))\\n\\n            // proof.q_arith\\n            mstore(add(proof_ptr, 0x200), mod(calldataload(add(data_ptr, 0x320)), p))\\n\\n            // proof.q_ecc\\n            mstore(add(proof_ptr, 0x220), mod(calldataload(add(data_ptr, 0x340)), p))\\n\\n            // proof.q_c\\n            mstore(add(proof_ptr, 0x240), mod(calldataload(add(data_ptr, 0x360)), p))\\n \\n            // proof.linearization_polynomial\\n            mstore(add(proof_ptr, 0x260), mod(calldataload(add(data_ptr, 0x380)), p))\\n\\n            // proof.grand_product_at_z_omega\\n            mstore(add(proof_ptr, 0x280), mod(calldataload(add(data_ptr, 0x3a0)), p))\\n\\n            // proof.w1_omega to proof.w4_omega\\n            mstore(add(proof_ptr, 0x2a0), mod(calldataload(add(data_ptr, 0x3c0)), p))\\n            mstore(add(proof_ptr, 0x2c0), mod(calldataload(add(data_ptr, 0x3e0)), p))\\n            mstore(add(proof_ptr, 0x2e0), mod(calldataload(add(data_ptr, 0x400)), p))\\n            mstore(add(proof_ptr, 0x300), mod(calldataload(add(data_ptr, 0x420)), p))\\n  \\n            // proof.PI_Z\\n            mstore(mload(add(proof_ptr, 0x320)), mod(calldataload(add(data_ptr, 0x460)), q))\\n            mstore(add(mload(add(proof_ptr, 0x320)), 0x20), mod(calldataload(add(data_ptr, 0x440)), q))\\n\\n            // proof.PI_Z_OMEGA\\n            mstore(mload(add(proof_ptr, 0x340)), mod(calldataload(add(data_ptr, 0x4a0)), q))\\n            mstore(add(mload(add(proof_ptr, 0x340)), 0x20), mod(calldataload(add(data_ptr, 0x480)), q))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Bn254Crypto.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from \\\"./Types.sol\\\";\\n\\n/**\\n * @title Bn254 elliptic curve crypto\\n * @dev Provides some basic methods to compute bilinear pairings, construct group elements and misc numerical methods\\n */\\nlibrary Bn254Crypto {\\n    uint256 constant p_mod = 21888242871839275222246405745257275088696311157297823662689037894645226208583;\\n    uint256 constant r_mod = 21888242871839275222246405745257275088548364400416034343698204186575808495617;\\n\\n    // Perform a modular exponentiation. This method is ideal for small exponents (~64 bits or less), as\\n    // it is cheaper than using the pow precompile\\n    function pow_small(\\n        uint256 base,\\n        uint256 exponent,\\n        uint256 modulus\\n    ) internal pure returns (uint256) {\\n        uint256 result = 1;\\n        uint256 input = base;\\n        uint256 count = 1;\\n\\n        assembly {\\n            let endpoint := add(exponent, 0x01)\\n            for {} lt(count, endpoint) { count := add(count, count) }\\n            {\\n                if and(exponent, count) {\\n                    result := mulmod(result, input, modulus)\\n                }\\n                input := mulmod(input, input, modulus)\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    function invert(uint256 fr) internal view returns (uint256)\\n    {\\n        uint256 output;\\n        bool success;\\n        uint256 p = r_mod;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, 0x20)\\n            mstore(add(mPtr, 0x20), 0x20)\\n            mstore(add(mPtr, 0x40), 0x20)\\n            mstore(add(mPtr, 0x60), fr)\\n            mstore(add(mPtr, 0x80), sub(p, 2))\\n            mstore(add(mPtr, 0xa0), p)\\n            success := staticcall(gas(), 0x05, mPtr, 0xc0, 0x00, 0x20)\\n            output := mload(0x00)\\n        }\\n        require(success, \\\"pow precompile call failed!\\\");\\n        return output;\\n    }\\n\\n    function new_g1(uint256 x, uint256 y)\\n        internal\\n        pure\\n        returns (Types.G1Point memory)\\n    {\\n        uint256 xValue;\\n        uint256 yValue;\\n        assembly {\\n            xValue := mod(x, r_mod)\\n            yValue := mod(y, r_mod)\\n        }\\n        return Types.G1Point(xValue, yValue);\\n    }\\n\\n    function new_g2(uint256 x0, uint256 x1, uint256 y0, uint256 y1)\\n        internal\\n        pure\\n        returns (Types.G2Point memory)\\n    {\\n        return Types.G2Point(x0, x1, y0, y1);\\n    }\\n\\n    function P1() internal pure returns (Types.G1Point memory) {\\n        return Types.G1Point(1, 2);\\n    }\\n\\n    function P2() internal pure returns (Types.G2Point memory) {\\n        return Types.G2Point({\\n            x0: 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2,\\n            x1: 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed,\\n            y0: 0x090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b,\\n            y1: 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa\\n        });\\n    }\\n\\n\\n    /// Evaluate the following pairing product:\\n    /// e(a1, a2).e(-b1, b2) == 1\\n    function pairingProd2(\\n        Types.G1Point memory a1,\\n        Types.G2Point memory a2,\\n        Types.G1Point memory b1,\\n        Types.G2Point memory b2\\n    ) internal view returns (bool) {\\n        validateG1Point(a1);\\n        validateG1Point(b1);\\n        bool success;\\n        uint256 out;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(a1))\\n            mstore(add(mPtr, 0x20), mload(add(a1, 0x20)))\\n            mstore(add(mPtr, 0x40), mload(a2))\\n            mstore(add(mPtr, 0x60), mload(add(a2, 0x20)))\\n            mstore(add(mPtr, 0x80), mload(add(a2, 0x40)))\\n            mstore(add(mPtr, 0xa0), mload(add(a2, 0x60)))\\n\\n            mstore(add(mPtr, 0xc0), mload(b1))\\n            mstore(add(mPtr, 0xe0), mload(add(b1, 0x20)))\\n            mstore(add(mPtr, 0x100), mload(b2))\\n            mstore(add(mPtr, 0x120), mload(add(b2, 0x20)))\\n            mstore(add(mPtr, 0x140), mload(add(b2, 0x40)))\\n            mstore(add(mPtr, 0x160), mload(add(b2, 0x60)))\\n            success := staticcall(\\n                gas(),\\n                8,\\n                mPtr,\\n                0x180,\\n                0x00,\\n                0x20\\n            )\\n            out := mload(0x00)\\n        }\\n        require(success, \\\"Pairing check failed!\\\");\\n        return (out != 0);\\n    }\\n\\n    /**\\n    * validate the following:\\n    *   x != 0\\n    *   y != 0\\n    *   x < p\\n    *   y < p\\n    *   y^2 = x^3 + 3 mod p\\n    */\\n    function validateG1Point(Types.G1Point memory point) internal pure {\\n        bool is_well_formed;\\n        uint256 p = p_mod;\\n        assembly {\\n            let x := mload(point)\\n            let y := mload(add(point, 0x20))\\n\\n            is_well_formed := and(\\n                and(\\n                    and(lt(x, p), lt(y, p)),\\n                    not(or(iszero(x), iszero(y)))\\n                ),\\n                eq(mulmod(y, y, p), addmod(mulmod(x, mulmod(x, x, p), p), 3, p))\\n            )\\n        }\\n        require(is_well_formed, \\\"Bn254: G1 point not on curve, or is malformed\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/verifier/cryptography/PolynomialEval.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Bn254Crypto} from './Bn254Crypto.sol';\\nimport {Types} from './Types.sol';\\n\\n/**\\n * @title Turbo Plonk polynomial evaluation\\n * @dev Implementation of Turbo Plonk's polynomial evaluation algorithms\\n *\\n * Expected to be inherited by `TurboPlonk.sol`\\n *\\n * Copyright 2020 Spilsbury Holdings Ltd\\n *\\n * Licensed under the GNU General Public License, Version 2.0 (the \\\"License\\\");\\n * you may not use this file except in compliance with the License.\\n *\\n * This program is distributed in the hope that it will be useful,\\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n * GNU General Public License for more details.\\n *\\n * You should have received a copy of the GNU General Public License\\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n */\\nlibrary PolynomialEval {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    /**\\n     * @dev Use batch inversion (so called Montgomery's trick). Circuit size is the domain\\n     * Allows multiple inversions to be performed in one inversion, at the expense of additional multiplications\\n     *\\n     * Returns a struct containing the inverted elements\\n     */\\n    function compute_batch_inversions(\\n        uint256 public_input_delta_numerator,\\n        uint256 public_input_delta_denominator,\\n        uint256 vanishing_numerator,\\n        uint256 vanishing_denominator,\\n        uint256 lagrange_numerator,\\n        uint256 l_start_denominator,\\n        uint256 l_end_denominator\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 zero_polynomial_eval,\\n            uint256 public_input_delta,\\n            uint256 l_start,\\n            uint256 l_end\\n        )\\n    {\\n        uint256 mPtr;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 accumulator = 1;\\n        assembly {\\n            mPtr := mload(0x40)\\n            mstore(0x40, add(mPtr, 0x200))\\n        }\\n    \\n        // store denominators in mPtr -> mPtr + 0x80\\n        assembly {\\n            mstore(mPtr, public_input_delta_denominator) // store denominator\\n            mstore(add(mPtr, 0x20), vanishing_numerator) // store numerator, because we want the inverse of the zero poly\\n            mstore(add(mPtr, 0x40), l_start_denominator) // store denominator\\n            mstore(add(mPtr, 0x60), l_end_denominator) // store denominator\\n\\n            // store temporary product terms at mPtr + 0x80 -> mPtr + 0x100\\n            mstore(add(mPtr, 0x80), accumulator)\\n            accumulator := mulmod(accumulator, mload(mPtr), p)\\n            mstore(add(mPtr, 0xa0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\\n            mstore(add(mPtr, 0xc0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\\n            mstore(add(mPtr, 0xe0), accumulator)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\\n        }\\n\\n        accumulator = Bn254Crypto.invert(accumulator);\\n        assembly {\\n            let intermediate := mulmod(accumulator, mload(add(mPtr, 0xe0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x60)), p)\\n            mstore(add(mPtr, 0x60), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0xc0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x40)), p)\\n            mstore(add(mPtr, 0x40), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0xa0)), p)\\n            accumulator := mulmod(accumulator, mload(add(mPtr, 0x20)), p)\\n            mstore(add(mPtr, 0x20), intermediate)\\n\\n            intermediate := mulmod(accumulator, mload(add(mPtr, 0x80)), p)\\n            accumulator := mulmod(accumulator, mload(mPtr), p)\\n            mstore(mPtr, intermediate)\\n\\n            public_input_delta := mulmod(public_input_delta_numerator, mload(mPtr), p)\\n\\n            zero_polynomial_eval := mulmod(vanishing_denominator, mload(add(mPtr, 0x20)), p)\\n    \\n            l_start := mulmod(lagrange_numerator, mload(add(mPtr, 0x40)), p)\\n\\n            l_end := mulmod(lagrange_numerator, mload(add(mPtr, 0x60)), p)\\n        }\\n    }\\n\\n    function compute_public_input_delta(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.VerificationKey memory vk\\n    ) internal pure returns (uint256, uint256) {\\n        uint256 gamma = challenges.gamma;\\n        uint256 work_root = vk.work_root;\\n\\n        uint256 endpoint = (vk.num_inputs * 0x20) - 0x20;\\n        uint256 public_inputs;\\n        uint256 root_1 = challenges.beta;\\n        uint256 root_2 = challenges.beta;\\n        uint256 numerator_value = 1;\\n        uint256 denominator_value = 1;\\n\\n        // we multiply length by 0x20 because our loop step size is 0x20 not 0x01\\n        // we subtract 0x20 because our loop is unrolled 2 times an we don't want to overshoot\\n\\n        // perform this computation in assembly to improve efficiency. We are sensitive to the cost of this loop as\\n        // it scales with the number of public inputs\\n        uint256 p = Bn254Crypto.r_mod;\\n        bool valid = true;\\n        assembly {\\n            root_1 := mulmod(root_1, 0x05, p)\\n            root_2 := mulmod(root_2, 0x07, p)\\n            public_inputs := add(calldataload(0x04), 0x24)\\n\\n            // get public inputs from calldata. N.B. If Contract ABI Changes this code will need to be updated!\\n            endpoint := add(endpoint, public_inputs)\\n            // Do some loop unrolling to reduce number of conditional jump operations\\n            for {} lt(public_inputs, endpoint) {}\\n            {\\n                let input0 := calldataload(public_inputs)\\n                let N0 := add(root_1, add(input0, gamma))\\n                let D0 := add(root_2, N0) // 4x overloaded\\n\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n\\n                let input1 := calldataload(add(public_inputs, 0x20))\\n                let N1 := add(root_1, add(input1, gamma))\\n\\n                denominator_value := mulmod(mulmod(D0, denominator_value, p), add(N1, root_2), p)\\n                numerator_value := mulmod(mulmod(N1, N0, p), numerator_value, p)\\n\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n\\n                valid := and(valid, and(lt(input0, p), lt(input1, p)))\\n                public_inputs := add(public_inputs, 0x40)\\n            }\\n\\n            endpoint := add(endpoint, 0x20)\\n            for {} lt(public_inputs, endpoint) { public_inputs := add(public_inputs, 0x20) }\\n            {\\n                let input0 := calldataload(public_inputs)\\n                valid := and(valid, lt(input0, p))\\n                let T0 := addmod(input0, gamma, p)\\n                numerator_value := mulmod(\\n                    numerator_value,\\n                    add(root_1, T0), // 0x05 = coset_generator0\\n                    p\\n                )\\n                denominator_value := mulmod(\\n                    denominator_value,\\n                    add(add(root_1, root_2), T0), // 0x0c = coset_generator7\\n                    p\\n                )\\n                root_1 := mulmod(root_1, work_root, p)\\n                root_2 := mulmod(root_2, work_root, p)\\n            }\\n        }\\n        require(valid, \\\"public inputs are greater than circuit modulus\\\");\\n        return (numerator_value, denominator_value);\\n    }\\n\\n    /**\\n     * @dev Computes the vanishing polynoimal and lagrange evaluations L1 and Ln.\\n     * @return Returns fractions as numerators and denominators. We combine with the public input fraction and compute inverses as a batch\\n     */\\n    function compute_lagrange_and_vanishing_fractions(Types.VerificationKey memory vk, uint256 zeta\\n    ) internal pure returns (uint256, uint256, uint256, uint256, uint256) {\\n\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 vanishing_numerator = Bn254Crypto.pow_small(zeta, vk.circuit_size, p);\\n        vk.zeta_pow_n = vanishing_numerator;\\n        assembly {\\n            vanishing_numerator := addmod(vanishing_numerator, sub(p, 1), p)\\n        }\\n\\n        uint256 accumulating_root = vk.work_root_inverse;\\n        uint256 work_root = vk.work_root_inverse;\\n        uint256 vanishing_denominator;\\n        uint256 domain_inverse = vk.domain_inverse;\\n        uint256 l_start_denominator;\\n        uint256 l_end_denominator;\\n        uint256 z = zeta; // copy input var to prevent stack depth errors\\n        assembly {\\n\\n            // vanishing_denominator = (z - w^{n-1})(z - w^{n-2})(z - w^{n-3})(z - w^{n-4})\\n            // we need to cut 4 roots of unity out of the vanishing poly, the last 4 constraints are not satisfied due to randomness\\n            // added to ensure the proving system is zero-knowledge\\n            vanishing_denominator := addmod(z, sub(p, work_root), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n            work_root := mulmod(work_root, accumulating_root, p)\\n            vanishing_denominator := mulmod(vanishing_denominator, addmod(z, sub(p, work_root), p), p)\\n        }\\n        \\n        work_root = vk.work_root;\\n        uint256 lagrange_numerator;\\n        assembly {\\n            lagrange_numerator := mulmod(vanishing_numerator, domain_inverse, p)\\n            // l_start_denominator = z - 1\\n            // l_end_denominator = z * \\\\omega^5 - 1\\n            l_start_denominator := addmod(z, sub(p, 1), p)\\n\\n            accumulating_root := mulmod(work_root, work_root, p)\\n            accumulating_root := mulmod(accumulating_root, accumulating_root, p)\\n            accumulating_root := mulmod(accumulating_root, work_root, p)\\n\\n            l_end_denominator := addmod(mulmod(accumulating_root, z, p), sub(p, 1), p)\\n        }\\n\\n        return (vanishing_numerator, vanishing_denominator, lagrange_numerator, l_start_denominator, l_end_denominator);\\n    }\\n\\n    function compute_arithmetic_gate_quotient_contribution(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n        uint256 q_arith = proof.q_arith;\\n        uint256 wire3 = proof.w3;\\n        uint256 wire4 = proof.w4;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        uint256 t1;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            t1 := addmod(mulmod(q_arith, q_arith, p), sub(p, q_arith), p)\\n\\n            let t2 := addmod(sub(p, mulmod(wire4, 0x04, p)), wire3, p)\\n\\n            let t3 := mulmod(mulmod(t2, t2, p), 0x02, p)\\n\\n            let t4 := mulmod(t2, 0x09, p)\\n            t4 := addmod(t4, addmod(sub(p, t3), sub(p, 0x07), p), p)\\n\\n            t2 := mulmod(t2, t4, p)\\n\\n            t1 := mulmod(mulmod(t1, t2, p), alpha_base, p)\\n\\n\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n\\n        return t1;\\n    }\\n\\n    function compute_pedersen_gate_quotient_contribution(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n\\n        uint256 alpha = challenges.alpha;\\n        uint256 gate_id = 0;\\n        uint256 alpha_base = challenges.alpha_base;\\n\\n        {\\n            uint256 p = Bn254Crypto.r_mod;\\n            uint256 delta = 0;\\n\\n            uint256 wire_t0 = proof.w4; // w4\\n            uint256 wire_t1 = proof.w4_omega; // w4_omega\\n            uint256 wire_t2 = proof.w3_omega; // w3_omega\\n            assembly {\\n                let wire4_neg := sub(p, wire_t0)\\n                delta := addmod(wire_t1, mulmod(wire4_neg, 0x04, p), p)\\n\\n                gate_id :=\\n                mulmod(\\n                    mulmod(\\n                        mulmod(\\n                            mulmod(\\n                                add(delta, 0x01),\\n                                add(delta, 0x03),\\n                                p\\n                            ),\\n                            add(delta, sub(p, 0x01)),\\n                            p\\n                        ),\\n                        add(delta, sub(p, 0x03)),\\n                        p\\n                    ),\\n                    alpha_base,\\n                    p\\n                )\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n        \\n                gate_id := addmod(gate_id, sub(p, mulmod(wire_t2, alpha_base, p)), p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            uint256 selector_value = proof.q_ecc;\\n\\n            wire_t0 = proof.w1; // w1\\n            wire_t1 = proof.w1_omega; // w1_omega\\n            wire_t2 = proof.w2; // w2\\n            uint256 wire_t3 = proof.w3_omega; // w3_omega\\n            uint256 t0;\\n            uint256 t1;\\n            uint256 t2;\\n            assembly {\\n                t0 := addmod(wire_t1, addmod(wire_t0, wire_t3, p), p)\\n\\n                t1 := addmod(wire_t3, sub(p, wire_t0), p)\\n                t1 := mulmod(t1, t1, p)\\n\\n                t0 := mulmod(t0, t1, p)\\n\\n                t1 := mulmod(wire_t3, mulmod(wire_t3, wire_t3, p), p)\\n\\n                t2 := mulmod(wire_t2, wire_t2, p)\\n\\n                t1 := sub(p, addmod(addmod(t1, t2, p), sub(p, 17), p))\\n\\n                t2 := mulmod(mulmod(delta, wire_t2, p), selector_value, p)\\n                t2 := addmod(t2, t2, p)\\n\\n                t0 := \\n                    mulmod(\\n                        addmod(t0, addmod(t1, t2, p), p),\\n                        alpha_base,\\n                        p\\n                    )\\n                gate_id := addmod(gate_id, t0, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            wire_t0 = proof.w1; // w1\\n            wire_t1 = proof.w2_omega; // w2_omega\\n            wire_t2 = proof.w2; // w2\\n            wire_t3 = proof.w3_omega; // w3_omega\\n            uint256 wire_t4 = proof.w1_omega; // w1_omega\\n            assembly {\\n                t0 := mulmod(\\n                    addmod(wire_t1, wire_t2, p),\\n                    addmod(wire_t3, sub(p, wire_t0), p),\\n                    p\\n                )\\n\\n                t1 := addmod(wire_t0, sub(p, wire_t4), p)\\n\\n                t2 := addmod(\\n                        sub(p, mulmod(selector_value, delta, p)),\\n                        wire_t2,\\n                        p\\n                )\\n\\n                gate_id := addmod(gate_id, mulmod(add(t0, mulmod(t1, t2, p)), alpha_base, p), p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            selector_value = proof.q_c;\\n        \\n            wire_t1 = proof.w4; // w4\\n            wire_t2 = proof.w3; // w3\\n            assembly {\\n                let acc_init_id := addmod(wire_t1, sub(p, 0x01), p)\\n\\n                t1 := addmod(acc_init_id, sub(p, wire_t2), p)\\n\\n                acc_init_id := mulmod(acc_init_id, mulmod(t1, alpha_base, p), p)\\n                acc_init_id := mulmod(acc_init_id, selector_value, p)\\n\\n                gate_id := addmod(gate_id, acc_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n        \\n            assembly {\\n                let x_init_id := sub(p, mulmod(mulmod(wire_t0, selector_value, p), mulmod(wire_t2, alpha_base, p), p))\\n\\n                gate_id := addmod(gate_id, x_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n\\n            wire_t0 = proof.w2; // w2\\n            wire_t1 = proof.w3; // w3\\n            wire_t2 = proof.w4; // w4\\n            assembly {\\n                let y_init_id := mulmod(add(0x01, sub(p, wire_t2)), selector_value, p)\\n\\n                t1 := sub(p, mulmod(wire_t0, wire_t1, p))\\n\\n                y_init_id := mulmod(add(y_init_id, t1), mulmod(alpha_base, selector_value, p), p)\\n\\n                gate_id := addmod(gate_id, y_init_id, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            }\\n            selector_value = proof.q_ecc;\\n            assembly {\\n                gate_id := mulmod(gate_id, selector_value, p)\\n            }\\n        }\\n        challenges.alpha_base = alpha_base;\\n        return gate_id;\\n    }\\n\\n    function compute_permutation_quotient_contribution(\\n        uint256 public_input_delta,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 lagrange_start,\\n        uint256 lagrange_end,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n\\n        uint256 numerator_collector;\\n        uint256 alpha = challenges.alpha;\\n        uint256 beta = challenges.beta;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 grand_product = proof.grand_product_at_z_omega;\\n        {\\n            uint256 gamma = challenges.gamma;\\n            uint256 wire1 = proof.w1;\\n            uint256 wire2 = proof.w2;\\n            uint256 wire3 = proof.w3;\\n            uint256 wire4 = proof.w4;\\n            uint256 sigma1 = proof.sigma1;\\n            uint256 sigma2 = proof.sigma2;\\n            uint256 sigma3 = proof.sigma3;\\n            assembly {\\n\\n                let t0 := add(\\n                    add(wire1, gamma),\\n                    mulmod(beta, sigma1, p)\\n                )\\n\\n                let t1 := add(\\n                    add(wire2, gamma),\\n                    mulmod(beta, sigma2, p)\\n                )\\n\\n                let t2 := add(\\n                    add(wire3, gamma),\\n                    mulmod(beta, sigma3, p)\\n                )\\n\\n                t0 := mulmod(t0, mulmod(t1, t2, p), p)\\n\\n                t0 := mulmod(\\n                    t0,\\n                    add(wire4, gamma),\\n                    p\\n                )\\n\\n                t0 := mulmod(\\n                    t0,\\n                    grand_product,\\n                    p\\n                )\\n\\n                t0 := mulmod(\\n                    t0,\\n                    alpha,\\n                    p\\n                )\\n\\n                numerator_collector := sub(p, t0)\\n            }\\n        }\\n\\n\\n        uint256 alpha_base = challenges.alpha_base;\\n        {\\n            uint256 lstart = lagrange_start;\\n            uint256 lend = lagrange_end;\\n            uint256 public_delta = public_input_delta;\\n            uint256 linearization_poly = proof.linearization_polynomial;\\n            assembly {\\n                let alpha_squared := mulmod(alpha, alpha, p)\\n                let alpha_cubed := mulmod(alpha, alpha_squared, p)\\n\\n                let t0 := mulmod(lstart, alpha_cubed, p)\\n                let t1 := mulmod(lend, alpha_squared, p)\\n                let t2 := addmod(grand_product, sub(p, public_delta), p)\\n                t1 := mulmod(t1, t2, p)\\n\\n                numerator_collector := addmod(numerator_collector, sub(p, t0), p)\\n                numerator_collector := addmod(numerator_collector, t1, p)\\n                numerator_collector := addmod(numerator_collector, linearization_poly, p)\\n                alpha_base := mulmod(alpha_base, alpha_cubed, p)\\n            }\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n\\n        return numerator_collector;\\n    }\\n\\n    function compute_quotient_polynomial(\\n        uint256 zero_poly_inverse,\\n        uint256 public_input_delta,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 lagrange_start,\\n        uint256 lagrange_end,\\n        Types.Proof memory proof\\n    ) internal pure returns (uint256) {\\n        uint256 t0 = compute_permutation_quotient_contribution(\\n            public_input_delta,\\n            challenges,\\n            lagrange_start,\\n            lagrange_end,\\n            proof\\n        );\\n\\n        uint256 t1 = compute_arithmetic_gate_quotient_contribution(challenges, proof);\\n\\n        uint256 t2 = compute_pedersen_gate_quotient_contribution(challenges, proof);\\n\\n        uint256 quotient_eval;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            quotient_eval := addmod(t0, addmod(t1, t2, p), p)\\n            quotient_eval := mulmod(quotient_eval, zero_poly_inverse, p)\\n        }\\n        return quotient_eval;\\n    }\\n\\n    function compute_linearised_opening_terms(\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 L1_fr,\\n        Types.VerificationKey memory vk,\\n        Types.Proof memory proof\\n    ) internal view returns (Types.G1Point memory) {\\n        Types.G1Point memory accumulator = compute_grand_product_opening_group_element(proof, vk, challenges, L1_fr);\\n        Types.G1Point memory arithmetic_term = compute_arithmetic_selector_opening_group_element(proof, vk, challenges);\\n        uint256 range_multiplier = compute_range_gate_opening_scalar(proof, challenges);\\n        uint256 logic_multiplier = compute_logic_gate_opening_scalar(proof, challenges);\\n\\n        Types.G1Point memory QRANGE = vk.QRANGE;\\n        Types.G1Point memory QLOGIC = vk.QLOGIC;\\n        QRANGE.validateG1Point();\\n        QLOGIC.validateG1Point();\\n\\n        // compute range_multiplier.[QRANGE] + logic_multiplier.[QLOGIC] + [accumulator] + [grand_product_term]\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n\\n            // range_multiplier.[QRANGE]\\n            mstore(mPtr, mload(QRANGE))\\n            mstore(add(mPtr, 0x20), mload(add(QRANGE, 0x20)))\\n            mstore(add(mPtr, 0x40), range_multiplier)\\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n\\n            // add scalar mul output into accumulator\\n            // we use mPtr to store accumulated point\\n            mstore(add(mPtr, 0x40), mload(accumulator))\\n            mstore(add(mPtr, 0x60), mload(add(accumulator, 0x20)))\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n            // logic_multiplier.[QLOGIC]\\n            mstore(add(mPtr, 0x40), mload(QLOGIC))\\n            mstore(add(mPtr, 0x60), mload(add(QLOGIC, 0x20)))\\n            mstore(add(mPtr, 0x80), logic_multiplier)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n\\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, mPtr, 0x40))\\n\\n            // add arithmetic into accumulator\\n            mstore(add(mPtr, 0x40), mload(arithmetic_term))\\n            mstore(add(mPtr, 0x60), mload(add(arithmetic_term, 0x20)))\\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40))\\n        }\\n        require(success, \\\"compute_linearised_opening_terms group operations fail\\\");\\n    \\n        return accumulator;\\n    }\\n\\n    function compute_batch_opening_commitment(\\n        Types.ChallengeTranscript memory challenges,\\n        Types.VerificationKey memory vk,\\n        Types.G1Point memory partial_opening_commitment,\\n        Types.Proof memory proof\\n    ) internal view returns (Types.G1Point memory) {\\n        // Computes the Kate opening proof group operations, for commitments that are not linearised\\n        bool success;\\n        // Reserve 0xa0 bytes of memory to perform group operations\\n        uint256 accumulator_ptr;\\n        uint256 p = Bn254Crypto.r_mod;\\n        assembly {\\n            accumulator_ptr := mload(0x40)\\n            mstore(0x40, add(accumulator_ptr, 0xa0))\\n        }\\n\\n        // first term\\n        Types.G1Point memory work_point = proof.T1;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(accumulator_ptr, mload(work_point))\\n            mstore(add(accumulator_ptr, 0x20), mload(add(work_point, 0x20)))\\n        }\\n\\n        // second term\\n        uint256 scalar_multiplier = vk.zeta_pow_n; // zeta_pow_n is computed in compute_lagrange_and_vanishing_fractions\\n        uint256 zeta_n = scalar_multiplier;\\n        work_point = proof.T2;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n.[T2]\\n            success := staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40)\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // third term\\n        work_point = proof.T3;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(scalar_multiplier, scalar_multiplier, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n^2.[T3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n\\n        }\\n\\n        // fourth term\\n        work_point = proof.T4;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(scalar_multiplier, zeta_n, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute zeta_n^3.[T4]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // fifth term\\n        work_point = partial_opening_commitment;\\n        work_point.validateG1Point();\\n        assembly {            \\n            // add partial opening commitment into accumulator\\n            mstore(add(accumulator_ptr, 0x40), mload(partial_opening_commitment))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(partial_opening_commitment, 0x20)))\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        uint256 u_plus_one = challenges.u;\\n        uint256 v_challenge = challenges.v0;\\n\\n        // W1\\n        work_point = proof.W1;\\n        work_point.validateG1Point();\\n        assembly {\\n            u_plus_one := addmod(u_plus_one, 0x01, p)\\n\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v0(u + 1).[W1]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // W2\\n        v_challenge = challenges.v1;\\n        work_point = proof.W2;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v1(u + 1).[W2]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // W3\\n        v_challenge = challenges.v2;\\n        work_point = proof.W3;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v2(u + 1).[W3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n\\n        // W4\\n        v_challenge = challenges.v3;\\n        work_point = proof.W4;\\n        work_point.validateG1Point();\\n        assembly {\\n            scalar_multiplier := mulmod(v_challenge, u_plus_one, p)\\n\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v3(u + 1).[W4]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA1\\n        scalar_multiplier = challenges.v4;\\n        work_point = vk.SIGMA1;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v4.[SIGMA1]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA2\\n        scalar_multiplier = challenges.v5;\\n        work_point = vk.SIGMA2;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v5.[SIGMA2]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // SIGMA3\\n        scalar_multiplier = challenges.v6;\\n        work_point = vk.SIGMA3;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v6.[SIGMA3]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        // QARITH\\n        scalar_multiplier = challenges.v7;\\n        work_point = vk.QARITH;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v7.[QARITH]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into accumulator\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n        }\\n\\n        Types.G1Point memory output;\\n        // QECC\\n        scalar_multiplier = challenges.v8;\\n        work_point = vk.QECC;\\n        work_point.validateG1Point();\\n        assembly {\\n            mstore(add(accumulator_ptr, 0x40), mload(work_point))\\n            mstore(add(accumulator_ptr, 0x60), mload(add(work_point, 0x20)))\\n            mstore(add(accumulator_ptr, 0x80), scalar_multiplier)\\n\\n            // compute v8.[QECC]\\n            success := and(success, staticcall(gas(), 7, add(accumulator_ptr, 0x40), 0x60, add(accumulator_ptr, 0x40), 0x40))\\n            \\n            // add scalar mul output into output point\\n            success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40))\\n        }\\n        \\n        require(success, \\\"compute_batch_opening_commitment group operations error\\\");\\n\\n        return output;\\n    }\\n\\n    function compute_batch_evaluation_scalar_multiplier(Types.Proof memory proof, Types.ChallengeTranscript memory challenges)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 opening_scalar;\\n        uint256 lhs;\\n        uint256 rhs;\\n\\n        lhs = challenges.v0;\\n        rhs = proof.w1;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v1;\\n        rhs = proof.w2;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v2;\\n        rhs = proof.w3;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v3;\\n        rhs = proof.w4;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v4;\\n        rhs = proof.sigma1;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v5;\\n        rhs = proof.sigma2;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v6;\\n        rhs = proof.sigma3;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v7;\\n        rhs = proof.q_arith;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v8;\\n        rhs = proof.q_ecc;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v9;\\n        rhs = proof.q_c;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n    \\n        lhs = challenges.v10;\\n        rhs = proof.linearization_polynomial;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n    \\n        lhs = proof.quotient_polynomial_eval;\\n        assembly {\\n            opening_scalar := addmod(opening_scalar, lhs, p)\\n        }\\n\\n        lhs = challenges.v0;\\n        rhs = proof.w1_omega;\\n        uint256 shifted_opening_scalar;\\n        assembly {\\n            shifted_opening_scalar := mulmod(lhs, rhs, p)\\n        }\\n    \\n        lhs = challenges.v1;\\n        rhs = proof.w2_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v2;\\n        rhs = proof.w3_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = challenges.v3;\\n        rhs = proof.w4_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, mulmod(lhs, rhs, p), p)\\n        }\\n\\n        lhs = proof.grand_product_at_z_omega;\\n        assembly {\\n            shifted_opening_scalar := addmod(shifted_opening_scalar, lhs, p)\\n        }\\n\\n        lhs = challenges.u;\\n        assembly {\\n            shifted_opening_scalar := mulmod(shifted_opening_scalar, lhs, p)\\n\\n            opening_scalar := addmod(opening_scalar, shifted_opening_scalar, p)\\n        }\\n\\n        return opening_scalar;\\n    }\\n\\n    // Compute kate opening scalar for arithmetic gate selectors and pedersen gate selectors\\n    // (both the arithmetic gate and pedersen hash gate reuse the same selectors)\\n    function compute_arithmetic_selector_opening_group_element(\\n        Types.Proof memory proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal view returns (Types.G1Point memory) {\\n\\n        uint256 q_arith = proof.q_arith;\\n        uint256 q_ecc = proof.q_ecc;\\n        uint256 linear_challenge = challenges.v10;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 scaling_alpha = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 scalar_multiplier;\\n        uint256 accumulator_ptr; // reserve 0xa0 bytes of memory to multiply and add points\\n        assembly {\\n            accumulator_ptr := mload(0x40)\\n            mstore(0x40, add(accumulator_ptr, 0xa0))\\n        }\\n        {\\n            uint256 delta;\\n            // Q1 Selector\\n            {\\n                {\\n                    uint256 w4 = proof.w4;\\n                    uint256 w4_omega = proof.w4_omega;\\n                    assembly {\\n                        delta := addmod(w4_omega, sub(p, mulmod(w4, 0x04, p)), p)\\n                    }\\n                }\\n                uint256 w1 = proof.w1;\\n\\n                assembly {\\n                    scalar_multiplier := mulmod(w1, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                    let t0 := mulmod(delta, delta, p)\\n                    t0 := mulmod(t0, q_ecc, p)\\n                    t0 := mulmod(t0, scaling_alpha, p)\\n\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n                Types.G1Point memory Q1 = vk.Q1;\\n                Q1.validateG1Point();\\n                bool success;\\n                assembly {\\n                    let mPtr := mload(0x40)\\n                    mstore(mPtr, mload(Q1))\\n                    mstore(add(mPtr, 0x20), mload(add(Q1, 0x20)))\\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\\n                    success := staticcall(gas(), 7, mPtr, 0x60, accumulator_ptr, 0x40)\\n                }\\n                require(success, \\\"G1 point multiplication failed!\\\");\\n            }\\n\\n            // Q2 Selector\\n            {\\n                uint256 w2 = proof.w2;\\n                assembly {\\n                    scalar_multiplier := mulmod(w2, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                    let t0 := mulmod(scaling_alpha, q_ecc, p)\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n\\n                Types.G1Point memory Q2 = vk.Q2;\\n                Q2.validateG1Point();\\n                bool success;\\n                assembly {\\n                    let mPtr := mload(0x40)\\n                    mstore(mPtr, mload(Q2))\\n                    mstore(add(mPtr, 0x20), mload(add(Q2, 0x20)))\\n                    mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                    // write scalar mul output 0x40 bytes ahead of accumulator\\n                    success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                    // add scalar mul output into accumulator\\n                    success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n                }\\n                require(success, \\\"G1 point multiplication failed!\\\");\\n            }\\n\\n            // Q3 Selector\\n            {\\n                {\\n                    uint256 w3 = proof.w3;\\n                    assembly {\\n                        scalar_multiplier := mulmod(w3, linear_challenge, p)\\n                        scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                        scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                    }\\n                }\\n                {\\n                    uint256 t1;\\n                    {\\n                        uint256 w3_omega = proof.w3_omega;\\n                        assembly {\\n                            t1 := mulmod(delta, w3_omega, p)\\n                        }\\n                    }\\n                    {\\n                        uint256 w2 = proof.w2;\\n                        assembly {\\n                            scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n\\n                            t1 := mulmod(t1, w2, p)\\n                            t1 := mulmod(t1, scaling_alpha, p)\\n                            t1 := addmod(t1, t1, p)\\n                            t1 := mulmod(t1, q_ecc, p)\\n\\n                        scalar_multiplier := addmod(scalar_multiplier, mulmod(t1, linear_challenge, p), p)\\n                        }\\n                    }\\n                }\\n                uint256 t0 = proof.w1_omega;\\n                {\\n                    uint256 w1 = proof.w1;\\n                    assembly {\\n                        scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                        t0 := addmod(t0, sub(p, w1), p)\\n                        t0 := mulmod(t0, delta, p)\\n                    }\\n                }\\n                uint256 w3_omega = proof.w3_omega;\\n                assembly {\\n\\n                    t0 := mulmod(t0, w3_omega, p)\\n                    t0 := mulmod(t0, scaling_alpha, p)\\n\\n                    t0 := mulmod(t0, q_ecc, p)\\n\\n                    scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n                }\\n            }\\n\\n            Types.G1Point memory Q3 = vk.Q3;\\n            Q3.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q3))\\n                mstore(add(mPtr, 0x20), mload(add(Q3, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        // Q4 Selector\\n        {\\n            uint256 w3 = proof.w3;\\n            uint256 w4 = proof.w4;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n                scalar_multiplier := mulmod(w4, linear_challenge, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                scaling_alpha := mulmod(scaling_alpha, mulmod(alpha, alpha, p), p)\\n                let t0 := mulmod(w3, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory Q4 = vk.Q4;\\n            Q4.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q4))\\n                mstore(add(mPtr, 0x20), mload(add(Q4, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        // Q5 Selector\\n        {\\n            uint256 w4 = proof.w4;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n                let neg_w4 := sub(p, w4)\\n                scalar_multiplier := mulmod(w4, w4, p)\\n                scalar_multiplier := addmod(scalar_multiplier, neg_w4, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, addmod(w4, sub(p, 2), p), p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, alpha, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, linear_challenge, p)\\n\\n                let t0 := addmod(0x01, neg_w4, p)\\n                t0 := mulmod(t0, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory Q5 = vk.Q5;\\n            Q5.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(Q5))\\n                mstore(add(mPtr, 0x20), mload(add(Q5, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n    \\n        // QM Selector\\n        {\\n            {\\n                uint256 w1 = proof.w1;\\n                uint256 w2 = proof.w2;\\n\\n                assembly {\\n                    scalar_multiplier := mulmod(w1, w2, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, linear_challenge, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, alpha_base, p)\\n                    scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n                }\\n            }\\n            uint256 w3 = proof.w3;\\n            uint256 q_c = proof.q_c;\\n            assembly {\\n\\n                scaling_alpha := mulmod(scaling_alpha, alpha, p)\\n                let t0 := mulmod(w3, q_ecc, p)\\n                t0 := mulmod(t0, q_c, p)\\n                t0 := mulmod(t0, scaling_alpha, p)\\n\\n                scalar_multiplier := addmod(scalar_multiplier, mulmod(t0, linear_challenge, p), p)\\n            }\\n\\n            Types.G1Point memory QM = vk.QM;\\n            QM.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(QM))\\n                mstore(add(mPtr, 0x20), mload(add(QM, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into accumulator\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, accumulator_ptr, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n        }\\n\\n        Types.G1Point memory output;\\n        // QC Selector\\n        {\\n            uint256 q_c_challenge = challenges.v9;\\n            assembly {\\n                scalar_multiplier := mulmod(linear_challenge, alpha_base, p)\\n                scalar_multiplier := mulmod(scalar_multiplier, q_arith, p)\\n\\n                // TurboPlonk requires an explicit evaluation of q_c\\n                scalar_multiplier := addmod(scalar_multiplier, q_c_challenge, p)\\n\\n                alpha_base := mulmod(scaling_alpha, alpha, p)\\n            }\\n\\n            Types.G1Point memory QC = vk.QC;\\n            QC.validateG1Point();\\n            bool success;\\n            assembly {\\n                let mPtr := mload(0x40)\\n                mstore(mPtr, mload(QC))\\n                mstore(add(mPtr, 0x20), mload(add(QC, 0x20)))\\n                mstore(add(mPtr, 0x40), scalar_multiplier)\\n\\n                // write scalar mul output 0x40 bytes ahead of accumulator\\n                success := staticcall(gas(), 7, mPtr, 0x60, add(accumulator_ptr, 0x40), 0x40)\\n\\n                // add scalar mul output into output point\\n                success := and(success, staticcall(gas(), 6, accumulator_ptr, 0x80, output, 0x40))\\n            }\\n            require(success, \\\"G1 point multiplication failed!\\\");\\n\\n        }\\n        challenges.alpha_base = alpha_base;\\n\\n        return output;\\n    }\\n\\n\\n    // Compute kate opening scalar for logic gate opening scalars\\n    // This method evalautes the polynomial identity used to evaluate either\\n    // a 2-bit AND or XOR operation in a single constraint\\n    function compute_logic_gate_opening_scalar(\\n        Types.Proof memory proof,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal pure returns (uint256) {\\n        uint256 identity = 0;\\n        uint256 p = Bn254Crypto.r_mod;\\n        {\\n            uint256 delta_sum = 0;\\n            uint256 delta_squared_sum = 0;\\n            uint256 t0 = 0;\\n            uint256 t1 = 0;\\n            uint256 t2 = 0;\\n            uint256 t3 = 0;\\n            {\\n                uint256 wire1_omega = proof.w1_omega;\\n                uint256 wire1 = proof.w1;\\n                assembly {\\n                    t0 := addmod(wire1_omega, sub(p, mulmod(wire1, 0x04, p)), p)\\n                }\\n            }\\n\\n            {\\n                uint256 wire2_omega = proof.w2_omega;\\n                uint256 wire2 = proof.w2;\\n                assembly {\\n                    t1 := addmod(wire2_omega, sub(p, mulmod(wire2, 0x04, p)), p)\\n\\n                    delta_sum := addmod(t0, t1, p)\\n                    t2 := mulmod(t0, t0, p)\\n                    t3 := mulmod(t1, t1, p)\\n                    delta_squared_sum := addmod(t2, t3, p)\\n                    identity := mulmod(delta_sum, delta_sum, p)\\n                    identity := addmod(identity, sub(p, delta_squared_sum), p)\\n                }\\n            }\\n\\n            uint256 t4 = 0;\\n            uint256 alpha = challenges.alpha;\\n\\n            {\\n                uint256 wire3 = proof.w3;\\n                assembly{\\n                    t4 := mulmod(wire3, 0x02, p)\\n                    identity := addmod(identity, sub(p, t4), p)\\n                    identity := mulmod(identity, alpha, p)\\n                }\\n            }\\n\\n            assembly {\\n                t4 := addmod(t4, t4, p)\\n                t2 := addmod(t2, sub(p, t0), p)\\n                t0 := mulmod(t0, 0x04, p)\\n                t0 := addmod(t2, sub(p, t0), p)\\n                t0 := addmod(t0, 0x06, p)\\n\\n                t0 := mulmod(t0, t2, p)\\n                identity := addmod(identity, t0, p)\\n                identity := mulmod(identity, alpha, p)\\n\\n                t3 := addmod(t3, sub(p, t1), p)\\n                t1 := mulmod(t1, 0x04, p)\\n                t1 := addmod(t3, sub(p, t1), p)\\n                t1 := addmod(t1, 0x06, p)\\n\\n                t1 := mulmod(t1, t3, p)\\n                identity := addmod(identity, t1, p)\\n                identity := mulmod(identity, alpha, p)\\n\\n                t0 := mulmod(delta_sum, 0x03, p)\\n\\n                t1 := mulmod(t0, 0x03, p)\\n\\n                delta_sum := addmod(t1, t1, p)\\n\\n                t2 := mulmod(delta_sum, 0x04, p)\\n                t1 := addmod(t1, t2, p)\\n\\n                t2 := mulmod(delta_squared_sum, 0x03, p)\\n\\n                delta_squared_sum := mulmod(t2, 0x06, p)\\n\\n                delta_sum := addmod(t4, sub(p, delta_sum), p)\\n                delta_sum := addmod(delta_sum, 81, p)\\n\\n                t1 := addmod(delta_squared_sum, sub(p, t1), p)\\n                t1 := addmod(t1, 83, p)\\n            }\\n\\n            {\\n                uint256 wire3 = proof.w3;\\n                assembly {\\n                    delta_sum := mulmod(delta_sum, wire3, p)\\n\\n                    delta_sum := addmod(delta_sum, t1, p)\\n                    delta_sum := mulmod(delta_sum, wire3, p)\\n                }\\n            }\\n            {\\n                uint256 wire4 = proof.w4;\\n                assembly {\\n                    t2 := mulmod(wire4, 0x04, p)\\n                }\\n            }\\n            {\\n                uint256 wire4_omega = proof.w4_omega;\\n                assembly {\\n                    t2 := addmod(wire4_omega, sub(p, t2), p)\\n                }\\n            }\\n            {\\n                uint256 q_c = proof.q_c;\\n                assembly {\\n                    t3 := addmod(t2, t2, p)\\n                    t2 := addmod(t2, t3, p)\\n\\n                    t3 := addmod(t2, t2, p)\\n                    t3 := addmod(t3, t2, p)\\n\\n                    t3 := addmod(t3, sub(p, t0), p)\\n                    t3 := mulmod(t3, q_c, p)\\n\\n                    t2 := addmod(t2, t0, p)\\n                    delta_sum := addmod(delta_sum, delta_sum, p)\\n                    t2 := addmod(t2, sub(p, delta_sum), p)\\n\\n                    t2 := addmod(t2, t3, p)\\n\\n                    identity := addmod(identity, t2, p)\\n                }\\n            }\\n            uint256 linear_nu = challenges.v10;\\n            uint256 alpha_base = challenges.alpha_base;\\n\\n            assembly {\\n                identity := mulmod(identity, alpha_base, p)\\n                identity := mulmod(identity, linear_nu, p)\\n            }\\n        }\\n        // update alpha\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 alpha = challenges.alpha;\\n        assembly {\\n            alpha := mulmod(alpha, alpha, p)\\n            alpha := mulmod(alpha, alpha, p)\\n            alpha_base := mulmod(alpha_base, alpha, p) \\n        }\\n        challenges.alpha_base = alpha_base;\\n\\n        return identity;\\n    }\\n\\n    // Compute kate opening scalar for arithmetic gate selectors\\n    function compute_range_gate_opening_scalar(\\n        Types.Proof memory proof,\\n        Types.ChallengeTranscript memory challenges\\n    ) internal pure returns (uint256) {\\n        uint256 wire1 = proof.w1;\\n        uint256 wire2 = proof.w2;\\n        uint256 wire3 = proof.w3;\\n        uint256 wire4 = proof.w4;\\n        uint256 wire4_omega = proof.w4_omega;\\n        uint256 alpha = challenges.alpha;\\n        uint256 alpha_base = challenges.alpha_base;\\n        uint256 range_acc;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 linear_challenge = challenges.v10;\\n        assembly {\\n            let delta_1 := addmod(wire3, sub(p, mulmod(wire4, 0x04, p)), p)\\n            let delta_2 := addmod(wire2, sub(p, mulmod(wire3, 0x04, p)), p)\\n            let delta_3 := addmod(wire1, sub(p, mulmod(wire2, 0x04, p)), p)\\n            let delta_4 := addmod(wire4_omega, sub(p, mulmod(wire1, 0x04, p)), p)\\n\\n\\n            let t0 := mulmod(delta_1, delta_1, p)\\n            t0 := addmod(t0, sub(p, delta_1), p)\\n            let t1 := addmod(delta_1, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_1, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n\\n            range_acc := t0\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_2, delta_2, p)\\n            t0 := addmod(t0, sub(p, delta_2), p)\\n            t1 := addmod(delta_2, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_2, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_3, delta_3, p)\\n            t0 := addmod(t0, sub(p, delta_3), p)\\n            t1 := addmod(delta_3, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_3, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            t0 := mulmod(delta_4, delta_4, p)\\n            t0 := addmod(t0, sub(p, delta_4), p)\\n            t1 := addmod(delta_4, sub(p, 2), p)\\n            t0 := mulmod(t0, t1, p)\\n            t1 := addmod(delta_4, sub(p, 3), p)\\n            t0 := mulmod(t0, t1, p)\\n            t0 := mulmod(t0, alpha_base, p)\\n            range_acc := addmod(range_acc, t0, p)\\n            alpha_base := mulmod(alpha_base, alpha, p)\\n\\n            range_acc := mulmod(range_acc, linear_challenge, p)\\n        }\\n\\n        challenges.alpha_base = alpha_base;\\n        return range_acc;\\n    }\\n\\n    // Compute grand product opening scalar and perform kate verification scalar multiplication\\n    function compute_grand_product_opening_group_element(\\n        Types.Proof memory proof,\\n        Types.VerificationKey memory vk,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 L1_fr\\n    ) internal view returns (Types.G1Point memory) {\\n        uint256 beta = challenges.beta;\\n        uint256 zeta = challenges.zeta;\\n        uint256 gamma = challenges.gamma;\\n        uint256 p = Bn254Crypto.r_mod;\\n        \\n        uint256 partial_grand_product;\\n        uint256 sigma_multiplier;\\n\\n        {\\n            uint256 w1 = proof.w1;\\n            uint256 sigma1 = proof.sigma1;\\n            assembly {\\n                let witness_term := addmod(w1, gamma, p)\\n                partial_grand_product := addmod(mulmod(beta, zeta, p), witness_term, p)\\n                sigma_multiplier := addmod(mulmod(sigma1, beta, p), witness_term, p)\\n            }\\n        }\\n        {\\n            uint256 w2 = proof.w2;\\n            uint256 sigma2 = proof.sigma2;\\n            assembly {\\n                let witness_term := addmod(w2, gamma, p)\\n                partial_grand_product := mulmod(partial_grand_product, addmod(mulmod(mulmod(zeta, 0x05, p), beta, p), witness_term, p), p)\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(sigma2, beta, p), witness_term, p), p)\\n            }\\n        }\\n        {\\n            uint256 w3 = proof.w3;\\n            uint256 sigma3 = proof.sigma3;\\n            assembly {\\n                let witness_term := addmod(w3, gamma, p)\\n                partial_grand_product := mulmod(partial_grand_product, addmod(mulmod(mulmod(zeta, 0x06, p), beta, p), witness_term, p), p)\\n\\n                sigma_multiplier := mulmod(sigma_multiplier, addmod(mulmod(sigma3, beta, p), witness_term, p), p)\\n            }\\n        }\\n        {\\n            uint256 w4 = proof.w4;\\n            assembly {\\n                partial_grand_product := mulmod(partial_grand_product, addmod(addmod(mulmod(mulmod(zeta, 0x07, p), beta, p), gamma, p), w4, p), p)\\n            }\\n        }\\n        {\\n            uint256 linear_challenge = challenges.v10;\\n            uint256 alpha_base = challenges.alpha_base;\\n            uint256 alpha = challenges.alpha;\\n            uint256 separator_challenge = challenges.u;\\n            uint256 grand_product_at_z_omega = proof.grand_product_at_z_omega;\\n            uint256 l_start = L1_fr;\\n            assembly {\\n                partial_grand_product := mulmod(partial_grand_product, alpha_base, p)\\n\\n                sigma_multiplier := mulmod(mulmod(sub(p, mulmod(mulmod(sigma_multiplier, grand_product_at_z_omega, p), alpha_base, p)), beta, p), linear_challenge, p)\\n\\n                alpha_base := mulmod(mulmod(alpha_base, alpha, p), alpha, p)\\n\\n                partial_grand_product := addmod(mulmod(addmod(partial_grand_product, mulmod(l_start, alpha_base, p), p), linear_challenge, p), separator_challenge, p)\\n\\n                alpha_base := mulmod(alpha_base, alpha, p)\\n            }\\n            challenges.alpha_base = alpha_base;\\n        }\\n\\n        Types.G1Point memory Z = proof.Z;\\n        Types.G1Point memory SIGMA4 = vk.SIGMA4;\\n        Types.G1Point memory accumulator;\\n        Z.validateG1Point();\\n        SIGMA4.validateG1Point();\\n        bool success;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore(mPtr, mload(Z))\\n            mstore(add(mPtr, 0x20), mload(add(Z, 0x20)))\\n            mstore(add(mPtr, 0x40), partial_grand_product)\\n            success := staticcall(gas(), 7, mPtr, 0x60, mPtr, 0x40)\\n\\n            mstore(add(mPtr, 0x40), mload(SIGMA4))\\n            mstore(add(mPtr, 0x60), mload(add(SIGMA4, 0x20)))\\n            mstore(add(mPtr, 0x80), sigma_multiplier)\\n            success := and(success, staticcall(gas(), 7, add(mPtr, 0x40), 0x60, add(mPtr, 0x40), 0x40))\\n            \\n            success := and(success, staticcall(gas(), 6, mPtr, 0x80, accumulator, 0x40))\\n        }\\n\\n        require(success, \\\"compute_grand_product_opening_scalar group operations failure\\\");\\n        return accumulator;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/**\\n * @title Bn254Crypto library used for the fr, g1 and g2 point types\\n * @dev Used to manipulate fr, g1, g2 types, perform modular arithmetic on them and call\\n * the precompiles add, scalar mul and pairing\\n *\\n * Notes on optimisations\\n * 1) Perform addmod, mulmod etc. in assembly - removes the check that Solidity performs to confirm that\\n * the supplied modulus is not 0. This is safe as the modulus's used (r_mod, q_mod) are hard coded\\n * inside the contract and not supplied by the user\\n */\\nlibrary Types {\\n    uint256 constant PROGRAM_WIDTH = 4;\\n    uint256 constant NUM_NU_CHALLENGES = 11;\\n\\n    uint256 constant coset_generator0 = 0x0000000000000000000000000000000000000000000000000000000000000005;\\n    uint256 constant coset_generator1 = 0x0000000000000000000000000000000000000000000000000000000000000006;\\n    uint256 constant coset_generator2 = 0x0000000000000000000000000000000000000000000000000000000000000007;\\n\\n    // TODO: add external_coset_generator() method to compute this\\n    uint256 constant coset_generator7 = 0x000000000000000000000000000000000000000000000000000000000000000c;\\n\\n    struct G1Point {\\n        uint256 x;\\n        uint256 y;\\n    }\\n\\n    // G2 group element where x \\\\in Fq2 = x0 * z + x1\\n    struct G2Point {\\n        uint256 x0;\\n        uint256 x1;\\n        uint256 y0;\\n        uint256 y1;\\n    }\\n\\n    // N>B. Do not re-order these fields! They must appear in the same order as they\\n    // appear in the proof data\\n    struct Proof {\\n        G1Point W1;\\n        G1Point W2;\\n        G1Point W3;\\n        G1Point W4;\\n        G1Point Z;\\n        G1Point T1;\\n        G1Point T2;\\n        G1Point T3;\\n        G1Point T4;\\n        uint256 w1;\\n        uint256 w2;\\n        uint256 w3;\\n        uint256 w4;\\n        uint256 sigma1;\\n        uint256 sigma2;\\n        uint256 sigma3;\\n        uint256 q_arith;\\n        uint256 q_ecc;\\n        uint256 q_c;\\n        uint256 linearization_polynomial;\\n        uint256 grand_product_at_z_omega;\\n        uint256 w1_omega;\\n        uint256 w2_omega;\\n        uint256 w3_omega;\\n        uint256 w4_omega;\\n        G1Point PI_Z;\\n        G1Point PI_Z_OMEGA;\\n        G1Point recursive_P1;\\n        G1Point recursive_P2;\\n        uint256 quotient_polynomial_eval;\\n    }\\n\\n    struct ChallengeTranscript {\\n        uint256 alpha_base;\\n        uint256 alpha;\\n        uint256 zeta;\\n        uint256 beta;\\n        uint256 gamma;\\n        uint256 u;\\n        uint256 v0;\\n        uint256 v1;\\n        uint256 v2;\\n        uint256 v3;\\n        uint256 v4;\\n        uint256 v5;\\n        uint256 v6;\\n        uint256 v7;\\n        uint256 v8;\\n        uint256 v9;\\n        uint256 v10;\\n    }\\n\\n    struct VerificationKey {\\n        uint256 circuit_size;\\n        uint256 num_inputs;\\n        uint256 work_root;\\n        uint256 domain_inverse;\\n        uint256 work_root_inverse;\\n        G1Point Q1;\\n        G1Point Q2;\\n        G1Point Q3;\\n        G1Point Q4;\\n        G1Point Q5;\\n        G1Point QM;\\n        G1Point QC;\\n        G1Point QARITH;\\n        G1Point QECC;\\n        G1Point QRANGE;\\n        G1Point QLOGIC;\\n        G1Point SIGMA1;\\n        G1Point SIGMA2;\\n        G1Point SIGMA3;\\n        G1Point SIGMA4;\\n        bool contains_recursive_proof;\\n        uint256 recursive_proof_indices;\\n        G2Point g2_x;\\n\\n        // zeta challenge raised to the power of the circuit size.\\n        // Not actually part of the verification key, but we put it here to prevent stack depth errors\\n        uint256 zeta_pow_n;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/VerificationKeys.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\n\\nimport {Rollup1x1Vk} from '../keys/Rollup1x1Vk.sol';\\nimport {Rollup1x2Vk} from '../keys/Rollup1x2Vk.sol';\\nimport {Rollup1x4Vk} from '../keys/Rollup1x4Vk.sol';\\n\\nimport {Rollup28x1Vk} from '../keys/Rollup28x1Vk.sol';\\nimport {Rollup28x2Vk} from '../keys/Rollup28x2Vk.sol';\\nimport {Rollup28x4Vk} from '../keys/Rollup28x4Vk.sol';\\n// import {Rollup28x8Vk} from '../keys/Rollup28x8Vk.sol';\\n// import {Rollup28x16Vk} from '../keys/Rollup28x16Vk.sol';\\n// import {Rollup28x32Vk} from '../keys/Rollup28x32Vk.sol';\\n\\nimport {EscapeHatchVk} from '../keys/EscapeHatchVk.sol';\\n\\n/**\\n * @title Verification keys library\\n * @dev Used to select the appropriate verification key for the proof in question\\n */\\nlibrary VerificationKeys {\\n    /**\\n     * @param _keyId - verification key identifier used to select the appropriate proof's key\\n     * @return Verification key\\n     */\\n    function getKeyById(uint256 _keyId) external pure returns (Types.VerificationKey memory) {\\n        // added in order: qL, qR, qO, qC, qM. x coord first, followed by y coord\\n        Types.VerificationKey memory vk;\\n\\n        if (_keyId == 0) {\\n            vk = EscapeHatchVk.get_verification_key();\\n        } else if (_keyId == 1) {\\n            vk = Rollup1x1Vk.get_verification_key();\\n        } else if (_keyId == 2) {\\n            vk = Rollup1x2Vk.get_verification_key();\\n        } else if (_keyId == 4) {\\n            vk = Rollup1x4Vk.get_verification_key();\\n        } else if (_keyId == 32) {\\n            vk = Rollup28x1Vk.get_verification_key();\\n        } else if (_keyId == 64) {\\n            vk = Rollup28x2Vk.get_verification_key();\\n        } else if (_keyId == 128) {\\n            vk = Rollup28x4Vk.get_verification_key();\\n            // } else if (_keyId == 256) {\\n            //     vk = Rollup28x8Vk.get_verification_key();\\n            // } else if (_keyId == 512) {\\n            //     vk = Rollup28x16Vk.get_verification_key();\\n            // } else if (_keyId == 1024) {\\n            //     vk = Rollup28x32Vk.get_verification_key();\\n        } else {\\n            require(false, 'UNKNOWN_KEY_ID');\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/cryptography/Transcript.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from './Types.sol';\\nimport {Bn254Crypto} from './Bn254Crypto.sol';\\n\\n/**\\n * @title Transcript library\\n * @dev Generates Plonk random challenges\\n */\\nlibrary Transcript {\\n\\n    struct TranscriptData {\\n        bytes32 current_challenge;\\n    }\\n    \\n    /**\\n     * Compute keccak256 hash of 2 4-byte variables (circuit_size, num_public_inputs)\\n     */\\n    function generate_initial_challenge(\\n                TranscriptData memory self,\\n                uint256 circuit_size,\\n                uint256 num_public_inputs\\n    ) internal pure {\\n        bytes32 challenge;\\n        assembly {\\n            let mPtr := mload(0x40)\\n            mstore8(add(mPtr, 0x20), shr(24, circuit_size))\\n            mstore8(add(mPtr, 0x21), shr(16, circuit_size))\\n            mstore8(add(mPtr, 0x22), shr(8, circuit_size))\\n            mstore8(add(mPtr, 0x23), circuit_size)           \\n            mstore8(add(mPtr, 0x24), shr(24, num_public_inputs))\\n            mstore8(add(mPtr, 0x25), shr(16, num_public_inputs))\\n            mstore8(add(mPtr, 0x26), shr(8, num_public_inputs))\\n            mstore8(add(mPtr, 0x27), num_public_inputs)\\n            challenge := keccak256(add(mPtr, 0x20), 0x08)\\n        }\\n        self.current_challenge = challenge;\\n    }\\n\\n    /**\\n     * We treat the beta challenge as a special case, because it includes the public inputs.\\n     * The number of public inputs can be extremely large for rollups and we want to minimize mem consumption.\\n     * => we directly allocate memory to hash the public inputs, in order to prevent the global memory pointer from increasing\\n     */\\n    function generate_beta_gamma_challenges(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        uint256 num_public_inputs\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            // N.B. If the calldata ABI changes this code will need to change!\\n            // We can copy all of the public inputs, followed by the wire commitments, into memory\\n            // using calldatacopy\\n            mstore(m_ptr, old_challenge)\\n            m_ptr := add(m_ptr, 0x20)\\n            let inputs_start := add(calldataload(0x04), 0x24)\\n            // num_calldata_bytes = public input size + 256 bytes for the 4 wire commitments\\n            let num_calldata_bytes := add(0x100, mul(num_public_inputs, 0x20))\\n            calldatacopy(m_ptr, inputs_start, num_calldata_bytes)\\n\\n            let start := mload(0x40)\\n            let length := add(num_calldata_bytes, 0x20)\\n\\n            challenge := keccak256(start, length)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.beta = reduced_challenge;\\n\\n        // get gamma challenge by appending 1 to the beta challenge and hash\\n        assembly {\\n            mstore(0x00, challenge)\\n            mstore8(0x20, 0x01)\\n            challenge := keccak256(0, 0x21)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.gamma = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_alpha_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory Z\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(Z, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(Z))\\n            challenge := keccak256(m_ptr, 0x60)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.alpha = reduced_challenge;\\n        challenges.alpha_base = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_zeta_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory T1,\\n        Types.G1Point memory T2,\\n        Types.G1Point memory T3,\\n        Types.G1Point memory T4\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(T1, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(T1))\\n            mstore(add(m_ptr, 0x60), mload(add(T2, 0x20)))\\n            mstore(add(m_ptr, 0x80), mload(T2))\\n            mstore(add(m_ptr, 0xa0), mload(add(T3, 0x20)))\\n            mstore(add(m_ptr, 0xc0), mload(T3))\\n            mstore(add(m_ptr, 0xe0), mload(add(T4, 0x20)))\\n            mstore(add(m_ptr, 0x100), mload(T4))\\n            challenge := keccak256(m_ptr, 0x120)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.zeta = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n\\n    /**\\n     * We compute our initial nu challenge by hashing the following proof elements (with the current challenge):\\n     *\\n     * w1, w2, w3, w4, sigma1, sigma2, sigma3, q_arith, q_ecc, q_c, linearization_poly, grand_product_at_z_omega,\\n     * w1_omega, w2_omega, w3_omega, w4_omega\\n     *\\n     * These values are placed linearly in the proofData, we can extract them with a calldatacopy call\\n     *\\n     */\\n    function generate_nu_challenges(TranscriptData memory self, Types.ChallengeTranscript memory challenges, uint256 quotient_poly_eval, uint256 num_public_inputs) internal pure\\n    {\\n        uint256 p = Bn254Crypto.r_mod;\\n        bytes32 current_challenge = self.current_challenge;\\n        uint256 base_v_challenge;\\n        uint256 updated_v;\\n\\n        // We want to copy SIXTEEN field elements from calldata into memory to hash\\n        // But we start by adding the quotient poly evaluation to the hash transcript\\n        assembly {\\n            // get a calldata pointer that points to the start of the data we want to copy\\n            let calldata_ptr := add(calldataload(0x04), 0x24)\\n            // skip over the public inputs\\n            calldata_ptr := add(calldata_ptr, mul(num_public_inputs, 0x20))\\n            // There are NINE G1 group elements added into the transcript in the `beta` round, that we need to skip over\\n            calldata_ptr := add(calldata_ptr, 0x240) // 9 * 0x40 = 0x240\\n\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, current_challenge)\\n            mstore(add(m_ptr, 0x20), quotient_poly_eval)\\n            calldatacopy(add(m_ptr, 0x40), calldata_ptr, 0x200) // 16 * 0x20 = 0x200\\n            base_v_challenge := keccak256(m_ptr, 0x240) // hash length = 0x240, we include the previous challenge in the hash\\n            updated_v := mod(base_v_challenge, p)\\n        }\\n\\n        // assign the first challenge value\\n        challenges.v0 = updated_v;\\n\\n        // for subsequent challenges we iterate 10 times.\\n        // At each iteration i \\\\in [1, 10] we compute challenges.vi = keccak256(base_v_challenge, byte(i))\\n        assembly {\\n            mstore(0x00, base_v_challenge)\\n            mstore8(0x20, 0x01)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v1 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x02)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v2 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x03)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v3 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x04)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v4 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x05)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v5 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x06)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v6 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x07)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v7 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x08)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v8 = updated_v;\\n        assembly {\\n            mstore8(0x20, 0x09)\\n            updated_v := mod(keccak256(0x00, 0x21), p)\\n        }\\n        challenges.v9 = updated_v;\\n\\n        // update the current challenge when computing the final nu challenge\\n        bytes32 challenge;\\n        assembly {\\n            mstore8(0x20, 0x0a)\\n            challenge := keccak256(0x00, 0x21)\\n            updated_v := mod(challenge, p)\\n        }\\n        challenges.v10 = updated_v;\\n\\n        self.current_challenge = challenge;\\n    }\\n\\n    function generate_separator_challenge(\\n        TranscriptData memory self,\\n        Types.ChallengeTranscript memory challenges,\\n        Types.G1Point memory PI_Z,\\n        Types.G1Point memory PI_Z_OMEGA\\n    ) internal pure  {\\n        bytes32 challenge;\\n        bytes32 old_challenge = self.current_challenge;\\n        uint256 p = Bn254Crypto.r_mod;\\n        uint256 reduced_challenge;\\n        assembly {\\n            let m_ptr := mload(0x40)\\n            mstore(m_ptr, old_challenge)\\n            mstore(add(m_ptr, 0x20), mload(add(PI_Z, 0x20)))\\n            mstore(add(m_ptr, 0x40), mload(PI_Z))\\n            mstore(add(m_ptr, 0x60), mload(add(PI_Z_OMEGA, 0x20)))\\n            mstore(add(m_ptr, 0x80), mload(PI_Z_OMEGA))\\n            challenge := keccak256(m_ptr, 0xa0)\\n            reduced_challenge := mod(challenge, p)\\n        }\\n        challenges.u = reduced_challenge;\\n        self.current_challenge = challenge;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVerifier.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\npragma solidity >=0.6.10 <0.8.0;\\n\\ninterface IVerifier {\\n    function verify(bytes memory serialized_proof, uint256 _keyId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x1Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x1Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 1048576) // vk.circuit_size\\n            mstore(add(vk, 0x20), 42) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x26125da10a0ed06327508aba06d1e303ac616632dbed349f53422da953337857) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644b6c9c4a72169e4daa317d25f04512ae15c53b34e8f5acd8e155d0a6c101) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x100c332d2100895fab6473bc2c51bfca521f45cb3baca6260852a8fde26c91f3) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x25390913c5974bef766a8a0a5af782fd039ea5a9d4aede2817f02e14ab4114fc)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x29c5965cb93f7aa8643c83a476e1749cdc4c85c341985dd0d54fcd5dc8398dd7)\\n            mstore(mload(add(vk, 0xc0)), 0x1ed06fb9a009077b7c15c493e8f9162358315fbe652eeec9e6988502a3b288bb)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x1f0b1a5f5aaa31de8ae34f347dac987223c6a44864f661da2ff2af14b4a1633e)\\n            mstore(mload(add(vk, 0xe0)), 0x23afd4cdb91cad9f2e429746bcff16aab228215dfa9ccc5d88c50c0bed5b9cc2)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x1ef69796c6c4fd141a2d530ee25cb1fe131f41077ec6f0fa0235f09db131faa5)\\n            mstore(mload(add(vk, 0x100)), 0x0553053cf7758173616ce52d05ec4066641460c1066b4c7e3672afe4fd4c46c8)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x1e749f044086c2c3e7120c55ffb60f0a6fb5ad673d5eb6b7d73d4e76d26be615)\\n            mstore(mload(add(vk, 0x120)), 0x0556c56f8fe9d1ef2c2853af88e15d4953cda8df68e52cb9f2938ebf8bde2386)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x2593139c74bf4bb4c619a4a33bd0bf08157b74e580402a2c6a1da77655e83f9c)\\n            mstore(mload(add(vk, 0x140)), 0x12cf6657075c75a14a946b9d425ccd820559880ae0206021bf4abb3f1f5e0a17)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x0afd2353a51dbdf875b309a60abec2e7d2a9a12e51940c7183439a499a677cab)\\n            mstore(mload(add(vk, 0x160)), 0x16a4029e1e2e59bc439be2a4a4c6cd7dbc6eaded01ad77e927473da544334d4b)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x1341ff4007a01fa22fee33bed0eb97fb9c0134c46af0beb0d346bcb64c995552)\\n            mstore(mload(add(vk, 0x180)), 0x0c49ae172cde337f14194fb4212e6323f3db82f072dc45d8a450f6daa7d3e28d)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2feeed427a0e59d56eac80d43d9301e991d452843830e72daf74d3d2fbe62896)\\n            mstore(mload(add(vk, 0x1a0)), 0x0c3aad92b1b550f3463bd61fbb53b170e29d11fcf3860d951b28cc8de2a35492)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x2bad1fa40eea00506addb334f7f7e43878973bfdee9b2bf456728194b788560f)\\n            mstore(mload(add(vk, 0x1c0)), 0x0b93e156f18ebfb463fce04e6ba1453678ab69d9884f45c813fa22767795ef14)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x112fa28bc39356ab856101e2b0df0174431760ae68f1f70400988c9fbad95695)\\n            mstore(mload(add(vk, 0x1e0)), 0x2b3f5a828b5461b20bca52d88120c7ea369b6668ff3e1147f7fd1a757c023acb)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x1fa613eadf21d222bf645feaf9725ddf7b3d8cfc159d93b34eab566ec434ee75)\\n            mstore(mload(add(vk, 0x200)), 0x09efeb79dc4e5bef5049cd5277ba72c70c3c031dc3be10b9e14d7c7cbe892c09)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x25f642d818e63e3995b648fafc0bb3dd2262dffa2df84d812a19f961cfc32499)\\n            mstore(mload(add(vk, 0x220)), 0x253bf04a86bdd932ad28a4bfcd24c12a6e323e062fb2da87fcb27cc5f4749d6e)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x041257f354014c3bce8c9ed77cc59ed5dc3255968c1e3429f8df3739830fb0d3)\\n            mstore(mload(add(vk, 0x240)), 0x07a6273dc71e924da1df2ddc8ad9d2c4443e6ad2993577d5c80e75be552054dc)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x2a49f5d39753cd4802085148daf223255aadfe1bd2a49e066068e1f8821222bc)\\n            mstore(mload(add(vk, 0x260)), 0x13d877bb601c49c90ed7307af3f44c2efc044d9646e3693445dbfc64ab2d592b)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x06626487231796f1a9461d540c3fcb0bd58cf426c05e440af81392f15e180ee6)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 26) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x2Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x2Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 2097152) // vk.circuit_size\\n            mstore(add(vk, 0x20), 54) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ded8980ae2bdd1a4222150e8598fc8c58f50577ca5a5ce3b2c87885fcd0b523) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644cefbebe09202b4ef7f3ff53a4511d70ff06da772cc3785d6b74e0536081) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x19c6dfb841091b14ab14ecc1145f527850fd246e940797d3f5fac783a376d0f0) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x23b18f118d2ef765ccfa0a5812bd14cdf7b87118c2af484bdf130029a003a0a5)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x2c9e42fcfa56de2ab6e6daacbb80c74410c862e0cb6d44e242cc30cd5f27bdf7)\\n            mstore(mload(add(vk, 0xc0)), 0x0e4dc6a44d20baf5e5de2d9afc679424e3c241ac839eb2e2d6f1e4078a94b567)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x27f968689ec1fa94d4927417b80d04636fc29d98454f5feee43d9c804fddd8de)\\n            mstore(mload(add(vk, 0xe0)), 0x115e8204fb6002583e9789ab4311ef3d23b72feeeb89e70351fab189822a73ea)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x2c1a9ed72e58ed72346aa7a4fdad90ad27ea5dc4aaa4a026e82619f52f8f1630)\\n            mstore(mload(add(vk, 0x100)), 0x0097d095d906a325f5c55f76509799978cc1085354831e36e52e44994d863dbe)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x03eccbbe0316541ee1193b7d6a59cf0cc8ffd136fa0094e26dad4c2d37abc46a)\\n            mstore(mload(add(vk, 0x120)), 0x1382dde7b35afbd2c6977acec5f2780f3c9824d53e7625e0f7c4c82552aceb2b)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x0077895d92313fe4d94434a9a256924e02755faeea085baaeca822f1ff3b72ff)\\n            mstore(mload(add(vk, 0x140)), 0x15d84e93edf3bef23ef2595a9d1cf9a39b66ad7356c744bd46fb8af6988f014f)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x04a4a7cc4a1a8bbccb449c3ca568efa2e6dfd331ca81021ad94fbcd539b0180a)\\n            mstore(mload(add(vk, 0x160)), 0x06b8a1b17cea2b870c6675cd767f05bc4135398bbc6df67cfc7d44b782451906)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x1d6445659ac7a3829146adb820757d70d77d97bca056223bea7834b548c49cf2)\\n            mstore(mload(add(vk, 0x180)), 0x15349076a8245067cb48dbb42d991ad5d818107c4db91488b3a660b883bb5ef8)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2cb0c46dcbe4d299f149cd0dffea61f2c24509d0e3d5f4dea32edb47c720ba63)\\n            mstore(mload(add(vk, 0x1a0)), 0x16f07bf189dba77a9e5704294e0a19a2ff17466de784b1a68e0b46592ed397d0)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x1e2ae5ef84c0f59ef1b6584b6ae4ad58e8f9d6a2d6b40950436140381d80a24f)\\n            mstore(mload(add(vk, 0x1c0)), 0x0a3114789cb047c7d2f3ac3b3d388ce4716994b3f5a29a6110e2501702b28693)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x0abecbbe4e0ecc895f0d9685b7c474db481a51dea9ed2891bd5447a4c59543b0)\\n            mstore(mload(add(vk, 0x1e0)), 0x1e029cb97dbf87a2b9481e09b2473619e9ab1527792d4829f70c4ac465ff5675)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x26b72df0bd74390e3381fd07a784d4a0573ee7a2d9facbb43cea8ff77c27b5b3)\\n            mstore(mload(add(vk, 0x200)), 0x27fe2743ae56746b442911cfc9724c2990520bf7ea24ce6f34a1756b578c0f0b)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x1ffbee2320167e7271b408a2ae45d807681e54b16fcdf108a5699bffe174399b)\\n            mstore(mload(add(vk, 0x220)), 0x07ea6f90f32b9cc82599c222799758502cff4979ab8b58a315df578024cb8887)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x0aa4856710d0463f8dde53e6ae60e229294247c1b2dc3ae0fb1b733097b71a29)\\n            mstore(mload(add(vk, 0x240)), 0x2083ea49d5a291e2e4080f6bc47e524da357c2e66a2992097a1c28370aa8ec95)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x0addf3187fadf8ceedb571ec1ce443f1bb88938eb7d5238ecec921db26d9068b)\\n            mstore(mload(add(vk, 0x260)), 0x12a5226bd23b425c150584ee6227037d214859ac0394009b883e3994d1a7e8ee)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x14f5e7b1f11c8b3693e6f80efdf6fcdedc8980be06c3ec9502a6e80ec6f5e2be)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 38) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup1x4Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup1x4Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 4194304) // vk.circuit_size\\n            mstore(add(vk, 0x20), 78) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ad92f46b1f8d9a7cda0ceb68be08215ec1a1f05359eebbba76dde56a219447e) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644db14ff7d4a4f1cf9ed5406a7e5722d273a7aa184eaa5e1fb0846829b041) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x2eb584390c74a876ecc11e9c6d3c38c3d437be9d4beced2343dc52e27faa1396) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x0ed021ab3dea29e98ed85f24aa9ababbf5d9b238b35881f67e5a7aa8e1c71066)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x144b423d5bc9e43c5c7a4ca9a8d01189291f9a9cbd28dcbf354091bfe5a35baa)\\n            mstore(mload(add(vk, 0xc0)), 0x29e3cc9f176a2d860ddfcb6bae60377708e2eb37d7d885988c1e8b6d55ec4493)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x18d5daaf59c77f53eff3a08fe0a42d20ac4fb454b40e09593437505f75fbe119)\\n            mstore(mload(add(vk, 0xe0)), 0x2f8506e26ed387a5b9e4efd8740091b5359b8395ab5ae9ecee5b0f055e54ec94)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x2faa158af12b620c0a4e700ae6ee1bdfcfb6dc18ad13669dbf682da9c0e6be2b)\\n            mstore(mload(add(vk, 0x100)), 0x2fa760fc1f22dd4ddeded0de4fa1583c4a07e8a75408cb0ef82acad1f0b944f4)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x14939eb8544b267ba56418f13037baeda119c7ad3d755adccdf749bbbfb64fdd)\\n            mstore(mload(add(vk, 0x120)), 0x12bc548020f5c62776903c212b5fa4fb3f45913ea4f5f574dded11cb874232c1)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x1f7008d3734759230d9c766e2b96b3bf78aa16f8250baedb0449943d910fe422)\\n            mstore(mload(add(vk, 0x140)), 0x205179393446c2c31c1857dc83a83328f9e497c10dc41dc7a9cb01663839baa8)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x0521129ae5b7e06fd9dc8920514a1aab95a3aac63a185cc2a3739b094dc92f33)\\n            mstore(mload(add(vk, 0x160)), 0x05df62d41e85edb98d278100e569de5e7d11b20c2f4dccc1f30aeaff05ec594e)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x09842b41f1c42dd514348aa40dc87898af9b59567fc38d40e224ba10c93f7849)\\n            mstore(mload(add(vk, 0x180)), 0x033f2d3a75d0ad536533f2ed78975d303359a3f06cc3de95c04e2658c14c6e71)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2ff32f8002a37d230d705d1de15a9131fbbc99f64ad27d9794f8ac99d0aa3cbe)\\n            mstore(mload(add(vk, 0x1a0)), 0x1add2c3d44c4a72cfe07d898a44eee527b2b3bf384a619e2b595585cb4a4f7ac)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x2ed61a90fd7cc96eae92b9f1eced79a8d2222febe5a91aeb2c26e8dc3f19311d)\\n            mstore(mload(add(vk, 0x1c0)), 0x101f90828e51262448cf1e7270ad0cd43898c7058a407c84c714eafae496310d)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x2c157732042d89ac2727e882dc68a149243e470b823250530461256f8258e592)\\n            mstore(mload(add(vk, 0x1e0)), 0x11aff31b1da1fbb3d8ae090ce00085de4673b4c1ca5c45f5c13f23ef00ee2d98)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x12e4d1363e3b7a4c73424b51b05009c24b646044f807367ecf77b28b4e5aa259)\\n            mstore(mload(add(vk, 0x200)), 0x087be8860385e0dd844820fa5950df81c018e4a7ede654437c5b7e06755a46ac)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x185b5541f0702802a78ae4ff30c267541177662fecfc4124a58edeb580d3945d)\\n            mstore(mload(add(vk, 0x220)), 0x26ebe4dc163030178ace75e723f6a0e5e2faed1a4c507945704a4e4c62c2df24)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x0ff9ad1cb34f0b5c83aec890fe37fde9b8c45800466622e99a90019e9f2b650b)\\n            mstore(mload(add(vk, 0x240)), 0x1c26ef44451575098e3829fa64a7ffaa0ffa788a8bdab825ea6b5069cb9d213c)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x02b61d5e296349b10b8393dfe85440139eefae5f9565760c58d7621c37627308)\\n            mstore(mload(add(vk, 0x260)), 0x21e92d332387e853889b36ce394f3e2d1d392b0c4736227774b557e08b9a4132)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x1136b489b5e13b32bc8e0c9fd0853f66f69db643641e29a8f2d7d5d395868192)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 62) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x1Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x1Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 1048576) // vk.circuit_size\\n            mstore(add(vk, 0x20), 414) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x26125da10a0ed06327508aba06d1e303ac616632dbed349f53422da953337857) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644b6c9c4a72169e4daa317d25f04512ae15c53b34e8f5acd8e155d0a6c101) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x100c332d2100895fab6473bc2c51bfca521f45cb3baca6260852a8fde26c91f3) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x0751c67ecac7630a454686c1e54d2fb210880eb514a8e04ab68978c29e81b63e)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x229073c6c73d1fe0146728ffa776eedba952df17e36b4dcc7d2c68e796700202)\\n            mstore(mload(add(vk, 0xc0)), 0x2c006b7cd574e2315daf5f7f85f76dcb5d207dd85f29cfef533c373133a074bb)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x026ea93a619a0065e76790e2a2ad3ad1f0622587cdd1d16231e647d4a9829131)\\n            mstore(mload(add(vk, 0xe0)), 0x1d836b3fc13b60528d821bc84eaeab2b9ac5709bf4486f176d14b728f72e8f92)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x2479b155d25d75fadd33d5a222d2bc78a95edac75d82356456f922b11abc0c74)\\n            mstore(mload(add(vk, 0x100)), 0x112739abf96fa79269e3f7a5ebe9fdac18fa8348607512a8daf50482900e2f71)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x0a00a416def762930f47389664ad263caeec3c5de87a0f3542a9032d00168da2)\\n            mstore(mload(add(vk, 0x120)), 0x20a5dc08944e7d234cfa2b44a017176ea71530a6121382d2f7a7f4754c4a2278)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x258fe4c31ae2e285fa0f58a1510c562c50d01c4258bd6f2e5f4e3171c6e1944c)\\n            mstore(mload(add(vk, 0x140)), 0x2b01a26299cfa17da8198035e62e67e305515d3ec3391daa7200aa64fd0d7a36)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x3000d28c6608d2698782234a1603bf41b8a355f635aab5906eaacefc7a2003b8)\\n            mstore(mload(add(vk, 0x160)), 0x286a29d8f6494b29dccc4ea3c4528ae03f656b06027c0d86ff58655192fc2f6f)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x095233e57d3feadb033abe1346412880387f44668a853e43b542193d4016ae55)\\n            mstore(mload(add(vk, 0x180)), 0x06442ed9ed579f0f8b28f49662ab0e2b250b0f3f4a3e6ba6d2598518fd4fb859)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2afa59017b5c64caab8c2f24044d3daaf4788ef7a969501add766b713320f755)\\n            mstore(mload(add(vk, 0x1a0)), 0x0d2385327495b57f93ab894a1283b858851bd59a7f52939bbe41f1a69fc0ce7f)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x0df576d367982f76746d342891035efef57dc0bc3210796f944b1ee75366d452)\\n            mstore(mload(add(vk, 0x1c0)), 0x15cdeffede1717b81a6b908fb7e73c7c566b41ec9e7a5cf9122a00833a7198c6)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x0e3e9328db1a3a30c06f71a4610f74b0a83eef8423a687a53d5aec0a889c810a)\\n            mstore(mload(add(vk, 0x1e0)), 0x109b01ea2bfde695e0ba94225224af50d06e907206c1d7990447716b5e4a743e)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x2c3564edafae943b8b3bc7cd9e7a14ef02d605725bbbdc11d43c78265f920f2d)\\n            mstore(mload(add(vk, 0x200)), 0x143bb1fe980ed9a77d8371b6781a11e15ed50f7fa55ff0f87ea39383535bd070)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x040ea0b6f74d815e74c42df01e4a20bb25cb961af713dbd953061fb111167123)\\n            mstore(mload(add(vk, 0x220)), 0x0d6e6bc16cad2acedb3c9d6d920ca52c6c6780faede65716de23501401cdb348)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x2340d2bdfc9ca0323980c879e7c85d2ceb2cd0177c5cf8a87e288bfdb4e291e3)\\n            mstore(mload(add(vk, 0x240)), 0x26ec64d303278dd874f42cd80d80c1482dbf9443189ea2cc8e66a42c6d59956d)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x08b0ec54ae3f12dc56da1602c213be21877da32aac204c171b3ee80be6586533)\\n            mstore(mload(add(vk, 0x260)), 0x1d8d66c676adf883f520fffed1e3ee6401a05aab3b3a426f76a82412c8cc81cf)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x04b8bf99240e447613a05b88e13c49bbc9fc997d90319f7b25025eec4feefefd)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 398) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x2Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x2Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 2097152) // vk.circuit_size\\n            mstore(add(vk, 0x20), 798) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ded8980ae2bdd1a4222150e8598fc8c58f50577ca5a5ce3b2c87885fcd0b523) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644cefbebe09202b4ef7f3ff53a4511d70ff06da772cc3785d6b74e0536081) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x19c6dfb841091b14ab14ecc1145f527850fd246e940797d3f5fac783a376d0f0) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x128ecc5bb1da7fd8a68aa5c7e72cfe3b42aabce313d1d6645fe4055a7b49ac0c)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x01c53dddbed7239dfa98090722b3bbebab0fb95b075e051f64203f07a29a31f7)\\n            mstore(mload(add(vk, 0xc0)), 0x14dcc8cbd9d47735859662164fc78f4493fc44cd2f3dfe77463a76499612bb0a)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x2416a3c737e905ddb9b40ca1bf0f7d07d18c5b37e74df33beab4f91f4f8a745a)\\n            mstore(mload(add(vk, 0xe0)), 0x1ec0bc5717c0a1e598f5112a3e495c8ba16be8c5b1f3f541d455291f1ef9145a)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x2b335e8cfd27683a04d5150d1d58cd2ac9bd7acd492822913e6c879796d27087)\\n            mstore(mload(add(vk, 0x100)), 0x18da028ce6a296d6a00118efafc33cdb7e8e502e5e091e2541f092ccf827924d)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x15c369108fd2252737b1de1711f63967069540c5e7ba3103d67d6f71a120f02e)\\n            mstore(mload(add(vk, 0x120)), 0x2b1bbd130ad99391dc200c7bcfbe0b372e4b8793a873349b0725ebf92caeda37)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x096e6e9b8217692ae77c3a9a67fa2cea4a1c2cef667f263bf00fcb7f8c936404)\\n            mstore(mload(add(vk, 0x140)), 0x07f37f32204c913a18d8ed73676b5adb693c9c112a6fc62189faf2258be58e1d)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x2571fb2b82ecbc30c04e00f0933f9ceb8aedd71fb2c80d9f42f016296d59d89f)\\n            mstore(mload(add(vk, 0x160)), 0x18e6b1da800602780582e885f7dd27e8f8f9577c278747d3372d9a928ae016e9)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x01f0ed702cf9fca094120d6f3c1bb12a4e8c06c8a3056ab97ed1379e320b94f1)\\n            mstore(mload(add(vk, 0x180)), 0x063b49beebe109a37261cc9ce1dd0d28dce4521a695969eb8dbc37bb53602c82)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x23e13a5eebd3ca90ce15a71410d8242ee114addc99c25ac0567d72e3630ea7cf)\\n            mstore(mload(add(vk, 0x1a0)), 0x2c26d6ac4b98e625cf31fd0332f8b9e8d69ace15e6d513bfa275ce0045066ff9)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x24596feb9933bb3403eb00429c1bf6519dd7e2dfae4823e0239c02de0ddd3211)\\n            mstore(mload(add(vk, 0x1c0)), 0x1a4c9bbea280067967f4685cc2ef1eead93ffd01b39133e0791a788fdcd07d22)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x04ebabd89e28b86e67627ea2950dfcd85e40b79561d1717b2654e7d0b5b8dc19)\\n            mstore(mload(add(vk, 0x1e0)), 0x0c64d466e69580885346203e51b6609e482a61fd1730d672d5bbf04d8aae271a)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x29d0a21cc1b3157ef4cdecace69fb7fa568d06cdba742c38b99ceffe55e197ac)\\n            mstore(mload(add(vk, 0x200)), 0x0ff79f24d2374bb54f69884e0d61211f743020bbdc49311b8735295729b55aef)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x2cc9bb4ae2006f624fa856b71ff39e99d04471080904905b79a3560d7bd8b0c1)\\n            mstore(mload(add(vk, 0x220)), 0x09cc281203ae2f68a664fd11de2acd7e54bfde8715b0744fb2b670179836339f)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x16ca2c9a40d67b32770be2e4e6c0f8c8e6e4f0e04d9aca70f54c96f87a818278)\\n            mstore(mload(add(vk, 0x240)), 0x2c92afbb51fcb9478f6c2cd28501a0cac267096799f9b49aa77a5c5043205365)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x168e95ca6e96a656c3ff7c296957c59ba6fc2b0980d3ef5f7d4384ff16a96639)\\n            mstore(mload(add(vk, 0x260)), 0x1f3ea8f987822139bdc9ebfa6d9768762075c72c67a87235422ba5efbc708314)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x12b2e1e2b10c55c832e2b0a1a699f3ea48ae4085238616997d460b382003c00e)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 782) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/Rollup28x4Vk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary Rollup28x4Vk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 4194304) // vk.circuit_size\\n            mstore(add(vk, 0x20), 1566) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x1ad92f46b1f8d9a7cda0ceb68be08215ec1a1f05359eebbba76dde56a219447e) // vk.work_root\\n            mstore(add(vk, 0x60),0x30644db14ff7d4a4f1cf9ed5406a7e5722d273a7aa184eaa5e1fb0846829b041) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x2eb584390c74a876ecc11e9c6d3c38c3d437be9d4beced2343dc52e27faa1396) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x00aedfd3673713c0e4185928880c2259b050bafa390dad1f5c7162296b77d309)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x1d851124257daa8f8673424e3ef4908664e6a5f147a734a2a16aa4b134eb848e)\\n            mstore(mload(add(vk, 0xc0)), 0x16a847ea6a828a8d4ac9006dfb7cb6a8d3cf6256168baa82b49a4d15afbf88e9)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x2686e71565f5ae835322b874dd4cfcd41690e76b1602a77a7b9643e0676e59a3)\\n            mstore(mload(add(vk, 0xe0)), 0x156e27ef850efff2fd85a0a08614a782dca765399e9415de201bbcf49a7d8842)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x039c03a3bc6147c0e44cdc6476ac26ec2832fd5c300ff2211d8f298c3403594a)\\n            mstore(mload(add(vk, 0x100)), 0x101c63ecb0e31f417551439fa5cf944905f857e85b8d8652a394e8247f06e5db)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x08b51a9d5878908c2ecf9b614abc2db76eba9e2fd744e1bf950f2085e48db650)\\n            mstore(mload(add(vk, 0x120)), 0x007b962b89d5c95d05f5e289b70c94638ee91f00639859122c5d306b6fab5b43)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x1d9b4ce5d6111f2b6617afc15158713ccc5f7b473e3bcf5f81e739e1c1f6e5dc)\\n            mstore(mload(add(vk, 0x140)), 0x303ecd0abd791231be3c46932023d628854098599af5964744a0abbc34ab66b8)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x27a6a54866e70e5b26e9aa83b7a336ec496f234803fd4373f171fe2a47623db2)\\n            mstore(mload(add(vk, 0x160)), 0x0a8a5d12269ad92086c027b3b44f91077e950c281ae74e740c24a30a83f7f47d)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x2b2189f1114cc98d1a49ed3989ace09ae0a639ec87eed20081e9170d36a650b6)\\n            mstore(mload(add(vk, 0x180)), 0x2046de2ec2d235b1eabe00f8efbb457d04cb397c3d08bd989a8b3d241e3ca34b)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x2fcbe115a306ff18b86b237d2d42f9bddfd0576fa469d0ff4a4ce4d26081a466)\\n            mstore(mload(add(vk, 0x1a0)), 0x049a2e40de309bda195b9a9f4a75df8112b272f465c6e44b83fe8d715efeaac9)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x1a6994863a80b388bd025afd8250ec18490b4f0e448ac2efe9e277bf57e4bd63)\\n            mstore(mload(add(vk, 0x1c0)), 0x0b2b5bf773e1e5e762227bb903da156673155f745a9c07e11b40042572a6ca14)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x2f867fbe12bb998b8b6189123ace71d46d4ff5a5194fc4da0fddc188e16303c3)\\n            mstore(mload(add(vk, 0x1e0)), 0x2e4ef6c2eecabb86bd7420c3950c5537bd7e17ef76bd42b113f6af434d9042e7)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x11f5685959f6eff605dbcbd761de75d091a23aa24409edd48aca175ffd16ba05)\\n            mstore(mload(add(vk, 0x200)), 0x2cb9e48a5c313e4dd3b5b1e43aa43b1ab0a44a6f683fbc7698628f29106f4e3d)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x0f4cd5c520af036ce10120dd52bd7979cf1e536d1b29b15c97a40a05b760b355)\\n            mstore(mload(add(vk, 0x220)), 0x034fce2e99be9afb219bbe2f7fd802d4cb40c9053415e71fe70ca3bcebbbfc1d)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x25cbb3eaea6d4324155a8ecad62347b7790fd1fa14c552931d8a6eb9bc18a364)\\n            mstore(mload(add(vk, 0x240)), 0x0c684132b19adc0370df75fc86235d3810e9bd70d5bc7f2f56c2e8ba6823d35d)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x07cfd8ca9c1946c6854882bb3af06445fede3ec3abc983b43d05415aa65ea830)\\n            mstore(mload(add(vk, 0x260)), 0x185a6bd652174af82c3b8db6f2ff319396e9924284321c113d0afe21dd6844d8)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x084362cf6768135357ecb9b3f1d113ecde4811079d98e4c1ae35cb989063fb7f)\\n            mstore(add(vk, 0x280), 0x01) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 1550) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/verifier/keys/EscapeHatchVk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-only\\n// Copyright 2020 Spilsbury Holdings Ltd\\n\\npragma solidity >=0.6.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\nimport {Types} from '../cryptography/Types.sol';\\nimport {Bn254Crypto} from '../cryptography/Bn254Crypto.sol';\\n\\nlibrary EscapeHatchVk {\\n    using Bn254Crypto for Types.G1Point;\\n    using Bn254Crypto for Types.G2Point;\\n\\n    function get_verification_key() internal pure returns (Types.VerificationKey memory) {\\n        Types.VerificationKey memory vk;\\n\\n        assembly {\\n            mstore(add(vk, 0x00), 524288) // vk.circuit_size\\n            mstore(add(vk, 0x20), 26) // vk.num_inputs\\n            mstore(add(vk, 0x40),0x2260e724844bca5251829353968e4915305258418357473a5c1d597f613f6cbd) // vk.work_root\\n            mstore(add(vk, 0x60),0x3064486657634403844b0eac78ca882cfd284341fcb0615a15cfcd17b14d8201) // vk.domain_inverse\\n            mstore(add(vk, 0x80),0x06e402c0a314fb67a15cf806664ae1b722dbc0efe66e6c81d98f9924ca535321) // vk.work_root_inverse\\n            mstore(mload(add(vk, 0xa0)), 0x290b8d025ef832ba1c15c0147293e992410787d68e5f80959e676822934cf4c5)//vk.Q1\\n            mstore(add(mload(add(vk, 0xa0)), 0x20), 0x1204d8e89851a0fcca9b613cdc0d0163b69d93f70664706febe77a56abc5c4f2)\\n            mstore(mload(add(vk, 0xc0)), 0x188b98c9109cb663f5636202c43dad3c3826381a7c95c13441548817261520ac)//vk.Q2\\n            mstore(add(mload(add(vk, 0xc0)), 0x20), 0x2ccf54971527f9c47165b2bcf5325954b0e455157a96a4a894994fe8af9c5b1d)\\n            mstore(mload(add(vk, 0xe0)), 0x0d58c89aa3b5bfe281de252714bd760e7d694660ca471669aa400564afa878b2)//vk.Q3\\n            mstore(add(mload(add(vk, 0xe0)), 0x20), 0x05d811ce51898ba9c3a01eadae0728dfd322bb19f7d57cbc48fbec3ac6b10aec)\\n            mstore(mload(add(vk, 0x100)), 0x2e7dc6adeb3b3f62d0fac3b2b0c3b726f7f93dbac39fa9f58c7535e54f88377d)//vk.Q4\\n            mstore(add(mload(add(vk, 0x100)), 0x20), 0x206226c72bfe3fc476dc92470311ab6006a67503ff6217f134747ce1ea330236)\\n            mstore(mload(add(vk, 0x120)), 0x24b65466c31f22eacf5eeaa821b61b966dad4c77991d13dd22d1e61efa0bd544)//vk.Q5\\n            mstore(add(mload(add(vk, 0x120)), 0x20), 0x0e1410a41b907eece55b710e79c97c511fd0890f66b6a192697c047cd0e9d326)\\n            mstore(mload(add(vk, 0x140)), 0x222b2d5b093b2a779e7b35382ef96999ecc0a0e52939809989aef89986feea78)//vk.QM\\n            mstore(add(mload(add(vk, 0x140)), 0x20), 0x128b78cc42bbd421b7f6f1469bfe5fb7eff2d14ec2707154920463bd09ec64da)\\n            mstore(mload(add(vk, 0x160)), 0x158dabf7d828c19c0dbf6f8c45b84a4977ae5248ea6e990e61b8c2951f6a8412)//vk.QC\\n            mstore(add(mload(add(vk, 0x160)), 0x20), 0x07478fc30cf185888b86c61792dc9353e370678ca7c30ea50dfadbf75af51e1a)\\n            mstore(mload(add(vk, 0x180)), 0x1376ac7861b0588c613d38f43f5853ef05a6bc8588f5b6a2129ed595ad0f8212)//vk.QARITH\\n            mstore(add(mload(add(vk, 0x180)), 0x20), 0x0399440aa8aac234a1c646e599c1c61111365dc9f59554fb851625182bc7fb3e)\\n            mstore(mload(add(vk, 0x1a0)), 0x24ddb45521cac4b1b7a82d08c999ef50f2724c3b7bf5360e627e9539cb5739e2)//vk.QECC\\n            mstore(add(mload(add(vk, 0x1a0)), 0x20), 0x0003e99bcc497f0cfbe5a31732f7748b68f99925a6764f682a71d33517574de9)\\n            mstore(mload(add(vk, 0x1c0)), 0x20d2bb06ac7c559a383cb3837d1f012629658488ddb34e1df1d6697d51e767f1)//vk.QRANGE\\n            mstore(add(mload(add(vk, 0x1c0)), 0x20), 0x0a810c61487cf79c19511179a69fc15905a96c87d359c189f46017d1d026bde6)\\n            mstore(mload(add(vk, 0x1e0)), 0x21a152ca3054255176f3f5800fee75d8f269e9e271a7f1bb5f3c90db09beacc2)//vk.QLOGIC\\n            mstore(add(mload(add(vk, 0x1e0)), 0x20), 0x2b5804d78be43843e7e73e8dde54537f865dc4827a0f9ce6e0c18dd95d8f2cb6)\\n            mstore(mload(add(vk, 0x200)), 0x1394f7edd7fb557ea04c2178fe79964bad3fcf27c2c6a870f58e795c9220a797)//vk.SIGMA1\\n            mstore(add(mload(add(vk, 0x200)), 0x20), 0x23375c4a1a9a89d05088a6ac8236c3d41e831bd6ec6365f320cad8c3dfdd2535)\\n            mstore(mload(add(vk, 0x220)), 0x27df75ef4c0f777dac6620d9861f75c668f110ef8f2b956991e5fb29983e0132)//vk.SIGMA2\\n            mstore(add(mload(add(vk, 0x220)), 0x20), 0x1575139bb2e106ddb5eaffdd4a7921bd1cbaf468c23929968d89c188831d3818)\\n            mstore(mload(add(vk, 0x240)), 0x0fa93fb9f82f7afebc381eb8ea34a3b345ba681bd46fdd1b6bdcd67f3cc36ec3)//vk.SIGMA3\\n            mstore(add(mload(add(vk, 0x240)), 0x20), 0x0efd9f1464d650e3d7497fa22d69d413e37258ddf906c16486b9f757da4b27da)\\n            mstore(mload(add(vk, 0x260)), 0x23f4dc16cf2932b87003ab768dee4e1efe679737a34e6a6d7007dbaaed4647ca)//vk.SIGMA4\\n            mstore(add(mload(add(vk, 0x260)), 0x20), 0x2540d52263daa3452d423c991db42df442b14eacad06fad9afafe0029af3c873)\\n            mstore(add(vk, 0x280), 0x00) // vk.contains_recursive_proof\\n            mstore(add(vk, 0x2a0), 0) // vk.recursive_proof_public_input_indices\\n            mstore(mload(add(vk, 0x2c0)), 0x260e01b251f6f1c7e7ff4e580791dee8ea51d87a358e038b4efe30fac09383c1) // vk.g2_x.X.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x20), 0x0118c4d5b837bcc2bc89b5b398b5974e9f5944073b32078b7e231fec938883b0) // vk.g2_x.X.c0\\n            mstore(add(mload(add(vk, 0x2c0)), 0x40), 0x04fc6369f7110fe3d25156c1bb9a72859cf2a04641f99ba4ee413c80da6a5fe4) // vk.g2_x.Y.c1\\n            mstore(add(mload(add(vk, 0x2c0)), 0x60), 0x22febda3c0c0632a56475b4214e5615e11e6dd3f96e6cea2854a87d4dacc5e55) // vk.g2_x.Y.c0\\n        }\\n        return vk;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/verifier/keys/VerificationKeys.sol\": {\r\n        \"VerificationKeys\": \"0x7fae73be814d94318fa0756a5d73ae9cf3ba7530\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"rollup_size\",\"type\":\"uint256\"}],\"name\":\"verify\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TurboVerifier", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}