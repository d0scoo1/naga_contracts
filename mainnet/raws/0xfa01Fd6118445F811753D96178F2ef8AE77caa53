{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/helpers/OnChainPositionsLens.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\n\\nimport \\\"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"../libs/LibPosition.sol\\\";\\nimport \\\"../interfaces/IRegistry.sol\\\";\\nimport \\\"../interfaces/IOpiumProxyFactory.sol\\\";\\nimport \\\"../interfaces/IOpiumPositionToken.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n}\\n\\nstruct PositionData {\\n    address positionAddress;\\n    string name;\\n    string symbol;\\n    uint256 totalSupply;\\n    LibDerivative.Derivative derivative;\\n    bool isLong;\\n}\\n\\ncontract OnChainPositionsLens {\\n    using LibDerivative for LibDerivative.Derivative;\\n    using LibPosition for bytes32;\\n\\n    IRegistry public immutable registry;\\n\\n    constructor(address _registry) {\\n        registry = IRegistry(_registry);\\n    }\\n\\n    function predictPositionsAddressesByDerivative(LibDerivative.Derivative calldata _derivative)\\n        external\\n        view\\n        returns (address, address)\\n    {\\n        bytes32 derivativeHash = _derivative.getDerivativeHash();\\n        return _predictPositionsAddressesByDerivativeHash(derivativeHash);\\n    }\\n\\n    function predictPositionsAddressesByDerivativeHash(bytes32 _derivativeHash)\\n        external\\n        view\\n        returns (address, address)\\n    {\\n        return _predictPositionsAddressesByDerivativeHash(_derivativeHash);\\n    }\\n\\n    function getDerivativePositionsData(bytes32 _derivativeHash) external view returns (PositionData[2] memory) {\\n        return _getDerivativePositionsData(_derivativeHash);\\n    }\\n\\n    function getDerivativesPositionsData(bytes32[] calldata _derivativesHash)\\n        external\\n        view\\n        returns (PositionData[2][] memory)\\n    {\\n        PositionData[2][] memory positionsData = new PositionData[2][](_derivativesHash.length);\\n        for (uint256 i = 0; i < _derivativesHash.length; i++) {\\n            positionsData[i] = _getDerivativePositionsData(_derivativesHash[i]);\\n        }\\n        return positionsData;\\n    }\\n\\n    function _getDerivativePositionsData(bytes32 _derivativeHash) private view returns (PositionData[2] memory) {\\n        IOpiumProxyFactory opiumProxyFactory = IOpiumProxyFactory(registry.getProtocolAddresses().opiumProxyFactory);\\n\\n        address longPositionAddress = _derivativeHash.predictDeterministicAddress(\\n            true,\\n            opiumProxyFactory.getImplementationAddress(),\\n            address(opiumProxyFactory)\\n        );\\n        address shortPositionAddress = _derivativeHash.predictDeterministicAddress(\\n            false,\\n            opiumProxyFactory.getImplementationAddress(),\\n            address(opiumProxyFactory)\\n        );\\n\\n        return [\\n            PositionData({\\n                positionAddress: longPositionAddress,\\n                name: IERC20Extended(longPositionAddress).name(),\\n                symbol: IERC20Extended(longPositionAddress).symbol(),\\n                totalSupply: IERC20Extended(longPositionAddress).totalSupply(),\\n                derivative: IOpiumPositionToken(longPositionAddress).getPositionTokenData().derivative,\\n                isLong: true\\n            }),\\n            PositionData({\\n                positionAddress: shortPositionAddress,\\n                name: IERC20Extended(shortPositionAddress).name(),\\n                symbol: IERC20Extended(shortPositionAddress).symbol(),\\n                totalSupply: IERC20Extended(shortPositionAddress).totalSupply(),\\n                derivative: IOpiumPositionToken(shortPositionAddress).getPositionTokenData().derivative,\\n                isLong: false\\n            })\\n        ];\\n    }\\n\\n    function _predictPositionsAddressesByDerivativeHash(bytes32 _derivativeHash)\\n        private\\n        view\\n        returns (address, address)\\n    {\\n        address longPositionAddress = _derivativeHash.predictDeterministicAddress(\\n            true,\\n            IOpiumProxyFactory(registry.getProtocolAddresses().opiumProxyFactory).getImplementationAddress(),\\n            registry.getProtocolAddresses().opiumProxyFactory\\n        );\\n        (\\n            true,\\n            IOpiumProxyFactory(registry.getProtocolAddresses().opiumProxyFactory).getImplementationAddress(),\\n            registry.getProtocolAddresses().opiumProxyFactory\\n        );\\n        address shortPositionAddress = _derivativeHash.predictDeterministicAddress(\\n            false,\\n            IOpiumProxyFactory(registry.getProtocolAddresses().opiumProxyFactory).getImplementationAddress(),\\n            registry.getProtocolAddresses().opiumProxyFactory\\n        );\\n        return (longPositionAddress, shortPositionAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibPosition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity ^0.8.5;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\\\";\\n\\nlibrary LibPosition {\\n    function predictDeterministicAddress(\\n        bytes32 _derivativeHash,\\n        bool _isLong,\\n        address _positionImplementationAddress,\\n        address _factoryAddress\\n    ) internal pure returns (address) {\\n        return _predictDeterministicAddress(_derivativeHash, _isLong, _positionImplementationAddress, _factoryAddress);\\n    }\\n\\n    function predictAndCheckDeterministicAddress(\\n        bytes32 _derivativeHash,\\n        bool _isLong,\\n        address _positionImplementationAddress,\\n        address _factoryAddress\\n    ) internal view returns (address, bool) {\\n        address predicted = _predictDeterministicAddress(\\n            _derivativeHash,\\n            _isLong,\\n            _positionImplementationAddress,\\n            _factoryAddress\\n        );\\n        bool isDeployed = _isContract(predicted);\\n        return (predicted, isDeployed);\\n    }\\n\\n    function deployOpiumPosition(\\n        bytes32 _derivativeHash,\\n        bool _isLong,\\n        address _positionImplementationAddress\\n    ) internal returns (address) {\\n        bytes32 salt = keccak256(abi.encodePacked(_derivativeHash, _isLong ? \\\"L\\\" : \\\"S\\\"));\\n        return ClonesUpgradeable.cloneDeterministic(_positionImplementationAddress, salt);\\n    }\\n\\n    function _predictDeterministicAddress(\\n        bytes32 _derivativeHash,\\n        bool _isLong,\\n        address _positionImplementationAddress,\\n        address _factoryAddress\\n    ) private pure returns (address) {\\n        bytes32 salt = keccak256(abi.encodePacked(_derivativeHash, _isLong ? \\\"L\\\" : \\\"S\\\"));\\n        return ClonesUpgradeable.predictDeterministicAddress(_positionImplementationAddress, salt, _factoryAddress);\\n    }\\n\\n    /// @notice checks whether a contract has already been deployed at a specific address\\n    /// @return bool true if a contract has been deployed at a specific address and false otherwise\\n    function _isContract(address _address) private view returns (bool) {\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(_address)\\n        }\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\nimport \\\"../core/registry/RegistryEntities.sol\\\";\\n\\ninterface IRegistry {\\n    function initialize(address _governor) external;\\n\\n    function setProtocolAddresses(\\n        address _opiumProxyFactory,\\n        address _core,\\n        address _oracleAggregator,\\n        address _syntheticAggregator,\\n        address _tokenSpender\\n    ) external;\\n\\n    function setNoDataCancellationPeriod(uint32 _noDataCancellationPeriod) external;\\n\\n    function addToWhitelist(address _whitelisted) external;\\n\\n    function removeFromWhitelist(address _whitelisted) external;\\n\\n    function setProtocolExecutionReserveClaimer(address _protocolExecutionReserveClaimer) external;\\n\\n    function setProtocolRedemptionReserveClaimer(address _protocolRedemptionReserveClaimer) external;\\n\\n    function setProtocolExecutionReservePart(uint32 _protocolExecutionReservePart) external;\\n\\n    function setDerivativeAuthorExecutionFeeCap(uint32 _derivativeAuthorExecutionFeeCap) external;\\n\\n    function setProtocolRedemptionReservePart(uint32 _protocolRedemptionReservePart) external;\\n\\n    function setDerivativeAuthorRedemptionReservePart(uint32 _derivativeAuthorRedemptionReservePart) external;\\n\\n    function pause() external;\\n\\n    function pauseProtocolPositionCreation() external;\\n\\n    function pauseProtocolPositionMinting() external;\\n\\n    function pauseProtocolPositionRedemption() external;\\n\\n    function pauseProtocolPositionExecution() external;\\n\\n    function pauseProtocolPositionCancellation() external;\\n\\n    function pauseProtocolReserveClaim() external;\\n\\n    function unpause() external;\\n\\n    function getProtocolParameters() external view returns (RegistryEntities.ProtocolParametersArgs memory);\\n\\n    function getProtocolAddresses() external view returns (RegistryEntities.ProtocolAddressesArgs memory);\\n\\n    function isRegistryManager(address _address) external view returns (bool);\\n\\n    function isCoreConfigurationUpdater(address _address) external view returns (bool);\\n\\n    function getCore() external view returns (address);\\n\\n    function isCoreSpenderWhitelisted(address _address) external view returns (bool);\\n\\n    function isProtocolPaused() external view returns (bool);\\n\\n    function isProtocolPositionCreationPaused() external view returns (bool);\\n\\n    function isProtocolPositionMintingPaused() external view returns (bool);\\n\\n    function isProtocolPositionRedemptionPaused() external view returns (bool);\\n\\n    function isProtocolPositionExecutionPaused() external view returns (bool);\\n\\n    function isProtocolPositionCancellationPaused() external view returns (bool);\\n\\n    function isProtocolReserveClaimPaused() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOpiumProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\nimport \\\"../libs/LibDerivative.sol\\\";\\n\\ninterface IOpiumProxyFactory {\\n    function getImplementationAddress() external view returns (address);\\n\\n    function initialize(address _registry) external;\\n\\n    function create(\\n        address _buyer,\\n        address _seller,\\n        uint256 _amount,\\n        bytes32 _derivativeHash,\\n        LibDerivative.Derivative calldata _derivative\\n    ) external;\\n\\n    function mintPair(\\n        address _buyer,\\n        address _seller,\\n        address _longPositionAddress,\\n        address _shortPositionAddress,\\n        uint256 _amount\\n    ) external;\\n\\n    function burn(\\n        address _positionOwner,\\n        address _positionAddress,\\n        uint256 _amount\\n    ) external;\\n\\n    function burnPair(\\n        address _positionOwner,\\n        address _longPositionAddress,\\n        address _shortPositionAddress,\\n        uint256 _amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOpiumPositionToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"../libs/LibDerivative.sol\\\";\\n\\ninterface IOpiumPositionToken is IERC20PermitUpgradeable, IERC20Upgradeable {\\n    struct OpiumPositionTokenParams {\\n        LibDerivative.Derivative derivative;\\n        LibDerivative.PositionType positionType;\\n        bytes32 derivativeHash;\\n    }\\n\\n    function initialize(\\n        bytes32 _derivativeHash,\\n        LibDerivative.PositionType _positionType,\\n        LibDerivative.Derivative calldata _derivative\\n    ) external;\\n\\n    function mint(address _positionOwner, uint256 _amount) external;\\n\\n    function burn(address _positionOwner, uint256 _amount) external;\\n\\n    function getFactoryAddress() external view returns (address);\\n\\n    function getPositionTokenData() external view returns (OpiumPositionTokenParams memory opiumPositionTokenParams);\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) external;\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ClonesUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary ClonesUpgradeable {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/registry/RegistryEntities.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\n\\nlibrary RegistryEntities {\\n    struct ProtocolParametersArgs {\\n        // Period of time after which ticker could be canceled if no data was provided to the `oracleId`\\n        uint32 noDataCancellationPeriod;\\n        // Max fee that derivative author can set\\n        // it works as an upper bound for when the derivative authors set their synthetic's fee\\n        uint32 derivativeAuthorExecutionFeeCap;\\n        // Fixed part (percentage) that the derivative author receives for each redemption of market neutral positions\\n        // It is not set by the derivative authors themselves\\n        uint32 derivativeAuthorRedemptionReservePart;\\n        // Represents which part of derivative author reserves originated from derivative executions go to the protocol reserves\\n        uint32 protocolExecutionReservePart;\\n        // Represents which part of derivative author reserves originated from redemption of market neutral positions go to the protocol reserves\\n        uint32 protocolRedemptionReservePart;\\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\\n        uint32 __gapOne;\\n        uint32 __gapTwo;\\n        uint32 __gapThree;\\n    }\\n\\n    struct ProtocolAddressesArgs {\\n        // Address of Opium.Core contract\\n        address core;\\n        // Address of Opium.OpiumProxyFactory contract\\n        address opiumProxyFactory;\\n        // Address of Opium.OracleAggregator contract\\n        address oracleAggregator;\\n        // Address of Opium.SyntheticAggregator contract\\n        address syntheticAggregator;\\n        // Address of Opium.TokenSpender contract\\n        address tokenSpender;\\n        // Address of the recipient of execution protocol reserves\\n        address protocolExecutionReserveClaimer;\\n        // Address of the recipient of redemption protocol reserves\\n        address protocolRedemptionReserveClaimer;\\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\\n        uint32 __gapOne;\\n        uint32 __gapTwo;\\n    }\\n\\n    struct ProtocolPausabilityArgs {\\n        // if true, all the protocol's entry-points are paused\\n        bool protocolGlobal;\\n        // if true, no new positions can be created\\n        bool protocolPositionCreation;\\n        // if true, no new positions can be minted\\n        bool protocolPositionMinting;\\n        // if true, no new positions can be redeemed\\n        bool protocolPositionRedemption;\\n        // if true, no new positions can be executed\\n        bool protocolPositionExecution;\\n        // if true, no new positions can be cancelled\\n        bool protocolPositionCancellation;\\n        // if true, no reserves can be claimed\\n        bool protocolReserveClaim;\\n        /// Initially uninitialized variables to allow some flexibility in case of future changes and upgradeability\\n        bool __gapOne;\\n        bool __gapTwo;\\n        bool __gapThree;\\n        bool __gapFour;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libs/LibDerivative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: agpl-3.0\\npragma solidity 0.8.5;\\n\\n/// @title Opium.Lib.LibDerivative contract should be inherited by contracts that use Derivative structure and calculate derivativeHash\\nlibrary LibDerivative {\\n    enum PositionType {\\n        SHORT,\\n        LONG\\n    }\\n\\n    // Opium derivative structure (ticker) definition\\n    struct Derivative {\\n        // Margin parameter for syntheticId\\n        uint256 margin;\\n        // Maturity of derivative\\n        uint256 endTime;\\n        // Additional parameters for syntheticId\\n        uint256[] params;\\n        // oracleId of derivative\\n        address oracleId;\\n        // Margin token address of derivative\\n        address token;\\n        // syntheticId of derivative\\n        address syntheticId;\\n    }\\n\\n    /// @notice Calculates hash of provided Derivative\\n    /// @param _derivative Derivative Instance of derivative to hash\\n    /// @return derivativeHash bytes32 Derivative hash\\n    function getDerivativeHash(Derivative memory _derivative) internal pure returns (bytes32 derivativeHash) {\\n        derivativeHash = keccak256(\\n            abi.encodePacked(\\n                _derivative.margin,\\n                _derivative.endTime,\\n                _derivative.params,\\n                _derivative.oracleId,\\n                _derivative.token,\\n                _derivative.syntheticId\\n            )\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_registry\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"}],\"name\":\"getDerivativePositionsData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"positionAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"derivative\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"}],\"internalType\":\"struct PositionData[2]\",\"name\":\"\",\"type\":\"tuple[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"_derivativesHash\",\"type\":\"bytes32[]\"}],\"name\":\"getDerivativesPositionsData\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"positionAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"derivative\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isLong\",\"type\":\"bool\"}],\"internalType\":\"struct PositionData[2][]\",\"name\":\"\",\"type\":\"tuple[2][]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"margin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"params\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"oracleId\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"syntheticId\",\"type\":\"address\"}],\"internalType\":\"struct LibDerivative.Derivative\",\"name\":\"_derivative\",\"type\":\"tuple\"}],\"name\":\"predictPositionsAddressesByDerivative\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_derivativeHash\",\"type\":\"bytes32\"}],\"name\":\"predictPositionsAddressesByDerivativeHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"internalType\":\"contract IRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OnChainPositionsLens", "CompilerVersion": "v0.8.5+commit.a4f2e591", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "000000000000000000000000bd0e3097f47ceca12407bac42cdd574cf3072f23", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}