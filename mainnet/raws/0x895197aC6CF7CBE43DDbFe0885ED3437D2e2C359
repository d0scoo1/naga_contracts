{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/royalties/RoyaltiesRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"../interfaces/IRoyaltiesProvider.sol\\\";\\nimport \\\"../interfaces/IRoyaltiesProviderExternal.sol\\\";\\nimport \\\"./HasSecondarySaleFees.sol\\\";\\nimport \\\"./ERC2981Royalties.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\n\\ncontract RoyaltiesRegistry is IRoyaltiesProvider, OwnableUpgradeable {\\n\\n    event RoyaltiesSetForToken(address indexed token, uint indexed tokenId, LibPart.Part[] royalties);\\n    event RoyaltiesSetForContract(address indexed token, LibPart.Part[] royalties);\\n\\n    struct RoyaltiesSet {\\n        bool initialized;\\n        LibPart.Part[] royalties;\\n    }\\n\\n    mapping(bytes32 => RoyaltiesSet) public royaltiesByTokenAndTokenId;\\n    mapping(address => RoyaltiesSet) public royaltiesByToken;\\n    mapping(address => address) public royaltiesProviders;\\n\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n\\n    function __RoyaltiesRegistry_init() external initializer {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function setProviderByToken(address token, address provider) external {\\n        checkOwner(token);\\n        royaltiesProviders[token] = provider;\\n    }\\n\\n    function setRoyaltiesByToken(address token, LibPart.Part[] memory royalties) external {\\n        checkOwner(token);\\n        uint sumRoyalties = 0;\\n        delete royaltiesByToken[token];\\n        for (uint i = 0; i < royalties.length; i++) {\\n            require(royalties[i].account != address(0x0), \\\"RoyaltiesByToken recipient should be present\\\");\\n            require(royalties[i].value != 0, \\\"Royalty value for RoyaltiesByToken should be > 0\\\");\\n            royaltiesByToken[token].royalties.push(royalties[i]);\\n            sumRoyalties += royalties[i].value;\\n        }\\n        require(sumRoyalties < 10000, \\\"Set by token royalties sum more, than 100%\\\");\\n        royaltiesByToken[token].initialized = true;\\n        emit RoyaltiesSetForContract(token, royalties);\\n    }\\n\\n    function setRoyaltiesByTokenAndTokenId(address token, uint tokenId, LibPart.Part[] memory royalties) external {\\n        checkOwner(token);\\n        setRoyaltiesCacheByTokenAndTokenId(token, tokenId, royalties);\\n    }\\n\\n    function checkOwner(address token) internal view {\\n        if ((owner() != _msgSender()) && (OwnableUpgradeable(token).owner() != _msgSender())) {\\n            revert(\\\"Token owner not detected\\\");\\n        }\\n    }\\n\\n    function getRoyalties(address token, uint tokenId) override external returns (LibPart.Part[] memory nftRoyalties, LibPart.Part[] memory collectionRoyalties) {\\n        RoyaltiesSet memory royaltiesSetCollection = royaltiesByToken[token];\\n        RoyaltiesSet memory royaltiesSetNFT = royaltiesByTokenAndTokenId[keccak256(abi.encode(token, tokenId))];\\n\\n        if (royaltiesSetCollection.initialized) {\\n            collectionRoyalties = royaltiesSetCollection.royalties;\\n        }\\n\\n        if (royaltiesSetNFT.initialized) {\\n            nftRoyalties = royaltiesSetNFT.royalties;\\n            return (nftRoyalties, collectionRoyalties);\\n        }\\n\\n        (bool result, LibPart.Part[] memory resultRoyalties) = providerExtractor(token, tokenId);\\n        if (result == false) {\\n            resultRoyalties = royaltiesFromContract(token, tokenId);\\n        }\\n        setRoyaltiesCacheByTokenAndTokenId(token, tokenId, resultRoyalties);\\n\\n        nftRoyalties = resultRoyalties;\\n\\n        return (nftRoyalties, collectionRoyalties);\\n    }\\n\\n    function setRoyaltiesCacheByTokenAndTokenId(address token, uint tokenId, LibPart.Part[] memory royalties) internal {\\n        uint sumRoyalties = 0;\\n        bytes32 key = keccak256(abi.encode(token, tokenId));\\n        delete royaltiesByTokenAndTokenId[key].royalties;\\n        for (uint i = 0; i < royalties.length; i++) {\\n            require(royalties[i].account != address(0x0), \\\"RoyaltiesByTokenAndTokenId recipient should be present\\\");\\n            require(royalties[i].value != 0, \\\"Royalty value for RoyaltiesByTokenAndTokenId should be > 0\\\");\\n            royaltiesByTokenAndTokenId[key].royalties.push(royalties[i]);\\n            sumRoyalties += royalties[i].value;\\n        }\\n        require(sumRoyalties < 10000, \\\"Set by token and tokenId royalties sum more, than 100%\\\");\\n        royaltiesByTokenAndTokenId[key].initialized = true;\\n        emit RoyaltiesSetForToken(token, tokenId, royalties);\\n    }\\n\\n    function royaltiesFromContract(address token, uint tokenId) internal view returns (LibPart.Part[] memory) {\\n        if (IERC165Upgradeable(token).supportsInterface(_INTERFACE_ID_FEES)) {\\n            HasSecondarySaleFees hasFees = HasSecondarySaleFees(token);\\n            address payable[] memory recipients;\\n            try hasFees.getFeeRecipients(tokenId) returns (address payable[] memory recipientsResult) {\\n                recipients = recipientsResult;\\n            } catch {\\n                return new LibPart.Part[](0);\\n            }\\n            uint[] memory values;\\n            try hasFees.getFeeBps(tokenId) returns (uint[] memory feesResult) {\\n                values = feesResult;\\n            } catch {\\n                return new LibPart.Part[](0);\\n            }\\n            if (values.length != recipients.length) {\\n                return new LibPart.Part[](0);\\n            }\\n            LibPart.Part[] memory result = new LibPart.Part[](values.length);\\n            for (uint256 i = 0; i < values.length; i++) {\\n                result[i].value = uint96(values[i]);\\n                result[i].account = recipients[i];\\n            }\\n            return result;\\n        }\\n        if (IERC165Upgradeable(token).supportsInterface(_INTERFACE_ID_ERC2981)) {  \\n            ERC2981Royalties erc2981Royalties = ERC2981Royalties(token);\\n\\n            address payable royaltyRecipient;\\n            uint96 royaltyValue;\\n\\n            // As ERC2981Royalties returns the calculated royalty amount in wei, we call the royaltyInfo func with value 10000, so we get the actual percentage\\n            try erc2981Royalties.royaltyInfo(tokenId, 10000) returns (address recipient, uint256 value) {\\n                royaltyRecipient = payable(recipient);\\n                royaltyValue = uint96(value);\\n            } catch {\\n                return new LibPart.Part[](0);\\n            }\\n\\n            if (royaltyRecipient == payable(address(0))) {\\n                return new LibPart.Part[](0);\\n            }\\n\\n            // ERC2981 Supports only one royalty recipient\\n            LibPart.Part[] memory result = new LibPart.Part[](1);\\n            result[0].value = royaltyValue;\\n            result[0].account = royaltyRecipient;\\n\\n            return result;\\n        }\\n        return new LibPart.Part[](0);\\n    }\\n\\n    function providerExtractor(address token, uint tokenId) internal returns (bool result, LibPart.Part[] memory royalties) {\\n        result = false;\\n        address providerAddress = royaltiesProviders[token];\\n        if (providerAddress != address(0x0)) {\\n            IRoyaltiesProviderExternal provider = IRoyaltiesProviderExternal(providerAddress);\\n            try provider.getRoyalties(token, tokenId) returns (LibPart.Part[] memory royaltiesByProvider) {\\n                royalties = royaltiesByProvider;\\n                result = true;\\n            } catch {}\\n        }\\n    }\\n\\n    function readCollectionRoyalties(address token) external view returns (LibPart.Part[] memory collectionRoyalties) {\\n        RoyaltiesSet memory royaltiesSetCollection = royaltiesByToken[token];\\n\\n        if (royaltiesSetCollection.initialized) {\\n            collectionRoyalties = royaltiesSetCollection.royalties;\\n        }\\n\\n        return collectionRoyalties;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoyaltiesProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"../lib/LibPart.sol\\\";\\n\\ninterface IRoyaltiesProvider {\\n    function getRoyalties(address token, uint tokenId) external returns (LibPart.Part[] memory, LibPart.Part[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRoyaltiesProviderExternal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"../lib/LibPart.sol\\\";\\n\\ninterface IRoyaltiesProviderExternal {\\n    function getRoyalties(address token, uint tokenId) external returns (LibPart.Part[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/royalties/HasSecondarySaleFees.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\n\\nabstract contract HasSecondarySaleFees is ERC165Storage {\\n    struct Fee {\\n        address payable recipient;\\n        uint256 value;\\n    }\\n\\n    // id => fees\\n    mapping (uint256 => Fee[]) public fees;\\n    event SecondarySaleFees(uint256 tokenId, address[] recipients, uint[] bps);\\n\\n    /*\\n     * bytes4(keccak256('getFeeBps(uint256)')) == 0x0ebd4c7f\\n     * bytes4(keccak256('getFeeRecipients(uint256)')) == 0xb9c4d9fb\\n     *\\n     * => 0x0ebd4c7f ^ 0xb9c4d9fb == 0xb7799584\\n     */\\n    bytes4 private constant _INTERFACE_ID_FEES = 0xb7799584;\\n    constructor() {\\n        _registerInterface(_INTERFACE_ID_FEES);\\n    }\\n\\n    function getFeeRecipients(uint256 id) external view returns (address payable[] memory) {\\n        Fee[] memory _fees = fees[id];\\n        address payable[] memory result = new address payable[](_fees.length);\\n        for (uint i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].recipient;\\n        }\\n        return result;\\n    }\\n\\n    function getFeeBps(uint256 id) external view returns (uint[] memory) {\\n        Fee[] memory _fees = fees[id];\\n        uint[] memory result = new uint[](_fees.length);\\n        for (uint i = 0; i < _fees.length; i++) {\\n            result[i] = _fees[i].value;\\n        }\\n        return result;\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/royalties/ERC2981Royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport \\\"../interfaces/IERC2981Royalties.sol\\\";\\n\\n/// @dev This is a contract used to add ERC2981 support to ERC721 and 1155\\nabstract contract ERC2981Royalties is ERC165Storage, IERC2981Royalties {\\n    struct RoyaltyInfo {\\n        address recipient;\\n        uint24 amount;\\n    }\\n\\n    mapping(uint256 => RoyaltyInfo) internal _royalties;\\n\\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\\n\\n    constructor() {\\n        _registerInterface(_INTERFACE_ID_ERC2981);\\n    }\\n\\n    /// @dev Sets token royalties\\n    /// @param tokenId the token id fir which we register the royalties\\n    /// @param recipient recipient of the royalties\\n    /// @param value percentage (using 2 decimals - 10000 = 100, 0 = 0)\\n    function _setTokenRoyalty(\\n        uint256 tokenId,\\n        address recipient,\\n        uint256 value\\n    ) internal {\\n        require(value <= 10000, \\\"ERC2981Royalties: Too high\\\");\\n        _royalties[tokenId] = RoyaltyInfo(recipient, uint24(value));\\n    }\\n\\n    function royaltyInfo(uint256 tokenId, uint256 value)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        RoyaltyInfo memory royalties = _royalties[tokenId];\\n        receiver = royalties.recipient;\\n        royaltyAmount = (value * royalties.amount) / 10000;\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal initializer {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"contracts/lib/LibPart.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\nlibrary LibPart {\\n    bytes32 public constant TYPE_HASH = keccak256(\\\"Part(address account,uint96 value)\\\");\\n\\n    struct Part {\\n        address payable account;\\n        uint96 value;\\n    }\\n\\n    function hash(Part memory part) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(TYPE_HASH, part.account, part.value));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC2981Royalties.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.11;\\n\\n/// @title IERC2981Royalties\\n/// @dev Interface for the ERC2981 - Token Royalty standard\\ninterface IERC2981Royalties {\\n    /// @notice Called with the sale price to determine how much royalty\\n    //          is owed and to whom.\\n    /// @param _tokenId - the NFT asset queried for royalty information\\n    /// @param _value - the sale price of the NFT asset specified by _tokenId\\n    /// @return _receiver - address of who should be sent the royalty payment\\n    /// @return _royaltyAmount - the royalty payment amount for value sale price\\n    function royaltyInfo(uint256 _tokenId, uint256 _value)\\n        external\\n        view\\n        returns (address _receiver, uint256 _royaltyAmount);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.0 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"indexed\":false,\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"RoyaltiesSetForContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"indexed\":false,\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"RoyaltiesSetForToken\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"__RoyaltiesRegistry_init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getRoyalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"nftRoyalties\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"collectionRoyalties\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"readCollectionRoyalties\",\"outputs\":[{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"collectionRoyalties\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"royaltiesByToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"royaltiesByTokenAndTokenId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"royaltiesProviders\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"provider\",\"type\":\"address\"}],\"name\":\"setProviderByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"setRoyaltiesByToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address payable\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"value\",\"type\":\"uint96\"}],\"internalType\":\"struct LibPart.Part[]\",\"name\":\"royalties\",\"type\":\"tuple[]\"}],\"name\":\"setRoyaltiesByTokenAndTokenId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RoyaltiesRegistry", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}