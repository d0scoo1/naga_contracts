{"status": "1", "message": "OK", "result": [{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/resolvers/mainnet/v2/main.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./helpers.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ncontract InstaVaultResolver is Helpers {\\n    struct VaultInfo {\\n        address token;\\n        uint8 decimals;\\n        uint256 tokenMinLimit;\\n        address atoken;\\n        address vaultDsa;\\n        VaultInterface.Ratios ratios;\\n        uint256 exchangePrice;\\n        uint256 lastRevenueExchangePrice;\\n        uint256 revenueFee;\\n        uint256 revenue;\\n        uint256 revenueEth;\\n        uint256 withdrawalFee;\\n        uint256 idealExcessAmt;\\n        uint256 swapFee;\\n        uint256 deleverageFee;\\n        uint256 saveSlippage;\\n        uint256 vTokenTotalSupply;\\n        uint256 tokenCollateralAmt;\\n        uint256 tokenVaultBal;\\n        uint256 tokenDSABal;\\n        uint256 netTokenBal;\\n        uint256 stethCollateralAmt;\\n        uint256 stethVaultBal;\\n        uint256 stethDSABal;\\n        uint256 wethDebtAmt;\\n        uint256 wethVaultBal;\\n        uint256 wethDSABal;\\n        uint256 tokenPriceInEth;\\n        uint256 currentRatioMax;\\n        uint256 currentRatioMin;\\n        uint256 availableWithdraw;\\n    }\\n\\n    function getVaultInfo(address vaultAddr_)\\n        public\\n        view\\n        returns (VaultInfo memory vaultInfo_)\\n    {\\n        VaultInterface vault = VaultInterface(vaultAddr_);\\n        vaultInfo_.token = vault.token();\\n        vaultInfo_.decimals = vault.decimals();\\n        vaultInfo_.tokenMinLimit = vault.tokenMinLimit();\\n        vaultInfo_.atoken = vault.atoken();\\n        vaultInfo_.vaultDsa = vault.vaultDsa();\\n        vaultInfo_.ratios = vault.ratios();\\n        (vaultInfo_.exchangePrice, ) = vault.getCurrentExchangePrice();\\n        vaultInfo_.lastRevenueExchangePrice = vault.lastRevenueExchangePrice();\\n        vaultInfo_.revenueFee = vault.revenueFee();\\n        vaultInfo_.revenue = vault.revenue();\\n        vaultInfo_.revenueEth = vault.revenueEth();\\n        vaultInfo_.withdrawalFee = vault.withdrawalFee();\\n        vaultInfo_.idealExcessAmt = vault.idealExcessAmt();\\n        vaultInfo_.swapFee = vault.swapFee();\\n        vaultInfo_.deleverageFee = vault.deleverageFee();\\n        vaultInfo_.saveSlippage = vault.saveSlippage();\\n        vaultInfo_.vTokenTotalSupply = vault.totalSupply();\\n        (\\n            vaultInfo_.tokenCollateralAmt,\\n            vaultInfo_.stethCollateralAmt,\\n            vaultInfo_.wethDebtAmt,\\n            vaultInfo_.tokenVaultBal,\\n            vaultInfo_.tokenDSABal,\\n            vaultInfo_.netTokenBal\\n        ) = vault.getVaultBalances();\\n        vaultInfo_.stethVaultBal = IERC20(stEthAddr).balanceOf(vaultAddr_);\\n        vaultInfo_.stethDSABal = IERC20(stEthAddr).balanceOf(\\n            vaultInfo_.vaultDsa\\n        );\\n        vaultInfo_.wethVaultBal = IERC20(wethAddr).balanceOf(vaultAddr_);\\n        vaultInfo_.wethDSABal = IERC20(wethAddr).balanceOf(vaultInfo_.vaultDsa);\\n\\n        vaultInfo_.tokenPriceInEth = IAavePriceOracle(\\n            aaveAddressProvider.getPriceOracle()\\n        ).getAssetPrice(vaultInfo_.token);\\n        uint256 netTokenColInEth_ = (vaultInfo_.tokenCollateralAmt *\\n            vaultInfo_.tokenPriceInEth) / (10**vaultInfo_.decimals);\\n        uint256 netTokenSupplyInEth_ = (vaultInfo_.netTokenBal *\\n            vaultInfo_.tokenPriceInEth) / (10**vaultInfo_.decimals);\\n        uint256 ethCoveringDebt_ = (vaultInfo_.stethCollateralAmt *\\n            vaultInfo_.ratios.stEthLimit) / 10000;\\n        uint256 excessDebt_ = ethCoveringDebt_ < vaultInfo_.wethDebtAmt\\n            ? vaultInfo_.wethDebtAmt - ethCoveringDebt_\\n            : 0;\\n        vaultInfo_.currentRatioMax = netTokenColInEth_ == 0\\n            ? 0\\n            : (excessDebt_ * 10000) / netTokenColInEth_;\\n        vaultInfo_.currentRatioMin = netTokenSupplyInEth_ == 0\\n            ? 0\\n            : (excessDebt_ * 10000) / netTokenSupplyInEth_;\\n        vaultInfo_.availableWithdraw =\\n            vaultInfo_.tokenVaultBal +\\n            vaultInfo_.tokenDSABal;\\n        uint256 maxLimitThreshold = vaultInfo_.ratios.maxLimit - 100; // keeping 1% margin\\n        if (vaultInfo_.currentRatioMax < maxLimitThreshold) {\\n            vaultInfo_.availableWithdraw += (((maxLimitThreshold -\\n                vaultInfo_.currentRatioMax) * vaultInfo_.tokenCollateralAmt) /\\n                maxLimitThreshold);\\n        }\\n    }\\n\\n    struct UserInfo {\\n        address vaultAddr;\\n        VaultInfo vaultInfo;\\n        uint256 tokenBal;\\n        uint256 vtokenBal;\\n        uint256 withdrawAmount;\\n    }\\n\\n    function getUserInfo(address[] memory vaults_, address user_)\\n        public\\n        view\\n        returns (UserInfo[] memory userInfos_)\\n    {\\n        userInfos_ = new UserInfo[](vaults_.length);\\n        for (uint256 i = 0; i < vaults_.length; i++) {\\n            VaultInterface vault = VaultInterface(vaults_[i]);\\n            userInfos_[i].vaultAddr = vaults_[i];\\n            userInfos_[i].vaultInfo = getVaultInfo(vaults_[i]);\\n            userInfos_[i].tokenBal = IERC20(userInfos_[i].vaultInfo.token)\\n                .balanceOf(user_);\\n            userInfos_[i].vtokenBal = vault.balanceOf(user_);\\n            userInfos_[i].withdrawAmount =\\n                (userInfos_[i].vtokenBal *\\n                    userInfos_[i].vaultInfo.exchangePrice) /\\n                1e18;\\n        }\\n    }\\n\\n    function collectProfitData(address vaultAddr_)\\n        public\\n        view\\n        returns (bool isEth_, uint256 withdrawAmt_, uint256 amt_)\\n    {\\n        VaultInterface vault = VaultInterface(vaultAddr_);\\n        address vaultDsaAddr_ = vault.vaultDsa();\\n        uint256 profits_ = (vault.getNewProfits() * 99) / 100; // keeping 1% margin\\n        uint256 vaultDsaWethBal_ = IERC20(wethAddr).balanceOf(vaultDsaAddr_);\\n        uint256 vaultDsaStethBal_ = IERC20(stEthAddr).balanceOf(vaultDsaAddr_);\\n\\n        if (profits_ > vaultDsaWethBal_ && profits_ > vaultDsaStethBal_) {\\n            (, uint256 stethCollateralAmt_, , , , ) = vault.getVaultBalances();\\n            uint256 maxAmt_ = (stethCollateralAmt_ * vault.idealExcessAmt()) /\\n                10000;\\n            maxAmt_ = (maxAmt_ * 99) / 100; // keeping 1% margin\\n            uint256 wethBorrowAmt_ = maxAmt_ + profits_ - vaultDsaWethBal_;\\n            uint256 stethWithdrawAmt_ = maxAmt_ + profits_ - vaultDsaStethBal_;\\n            if (checkIfBorrowAllowed(vaultDsaAddr_, wethBorrowAmt_)) {\\n                withdrawAmt_ = wethBorrowAmt_;\\n                isEth_ = true;\\n            } else {\\n                withdrawAmt_ = stethWithdrawAmt_;\\n            }\\n        } else if (profits_ <= vaultDsaWethBal_) isEth_ = true;\\n        amt_ = profits_;\\n    }\\n\\n    struct RebalanceOneVariables {\\n        address tokenAddr;\\n        uint256 tokenDecimals;\\n        uint256 tokenMinLimit;\\n        uint256 tokenVaultBal;\\n        uint256 netTokenBal;\\n        VaultInterface.Ratios ratios;\\n        uint256 stethCollateral;\\n        uint256 wethDebt;\\n        uint256 ethCoveringDebt;\\n        uint256 excessDebt;\\n        uint256 tokenPriceInEth;\\n        uint256 netTokenSupplyInEth;\\n        uint256 currentRatioMin;\\n        uint256[] deleverageAmts;\\n    }\\n\\n    function rebalanceOneData(\\n        address vaultAddr_,\\n        address[] memory vaultsToCheck_\\n    )\\n        public\\n        view\\n        returns (\\n            address flashTkn_, // currently its always weth addr\\n            uint256 flashAmt_,\\n            uint256 route_,\\n            address[] memory vaults_,\\n            uint256[] memory amts_,\\n            uint256 leverageAmt_,\\n            uint256 swapAmt_,\\n            uint256 tokenSupplyAmt_,\\n            uint256 tokenWithdrawAmt_ // currently always returned zero\\n        )\\n    {\\n        RebalanceOneVariables memory v_;\\n        VaultInterface vault_ = VaultInterface(vaultAddr_);\\n        v_.tokenAddr = vault_.token();\\n        v_.tokenDecimals = vault_.decimals();\\n        v_.tokenMinLimit = vault_.tokenMinLimit();\\n        (\\n            ,\\n            v_.stethCollateral,\\n            v_.wethDebt,\\n            v_.tokenVaultBal,\\n            ,\\n            v_.netTokenBal\\n        ) = vault_.getVaultBalances();\\n        if (v_.tokenVaultBal > v_.tokenMinLimit)\\n            tokenSupplyAmt_ = v_.tokenVaultBal;\\n        v_.ratios = vault_.ratios();\\n        v_.ethCoveringDebt =\\n            (v_.stethCollateral * v_.ratios.stEthLimit) /\\n            10000;\\n        v_.excessDebt = v_.ethCoveringDebt < v_.wethDebt\\n            ? v_.wethDebt - v_.ethCoveringDebt\\n            : 0;\\n        v_.tokenPriceInEth = IAavePriceOracle(\\n            aaveAddressProvider.getPriceOracle()\\n        ).getAssetPrice(v_.tokenAddr);\\n        v_.netTokenSupplyInEth =\\n            (v_.netTokenBal * v_.tokenPriceInEth) /\\n            (10**v_.tokenDecimals);\\n        v_.currentRatioMin = v_.netTokenSupplyInEth == 0\\n            ? 0\\n            : (v_.excessDebt * 10000) / v_.netTokenSupplyInEth;\\n        if (v_.currentRatioMin < v_.ratios.minLimitGap) {\\n            // keeping 0.1% margin for final ratio\\n            leverageAmt_ =\\n                (((v_.ratios.minLimit - 10) - v_.currentRatioMin) *\\n                    v_.netTokenSupplyInEth) /\\n                (10000 - v_.ratios.stEthLimit);\\n            flashTkn_ = wethAddr;\\n            // TODO: dont take flashloan if not needed\\n            flashAmt_ =\\n                (v_.netTokenSupplyInEth / 10) +\\n                ((leverageAmt_ * 10) / 8); // 10% of current collateral(in eth) + leverageAmt_ / 0.8\\n            route_ = 5;\\n            v_.deleverageAmts = getMaxDeleverageAmts(vaultsToCheck_);\\n            (vaults_, amts_, swapAmt_) = getVaultsToUse(\\n                vaultsToCheck_,\\n                v_.deleverageAmts,\\n                leverageAmt_\\n            );\\n        }\\n    }\\n\\n    struct RebalanceTwoVariables {\\n        address tokenAddr;\\n        uint256 tokenDecimals;\\n        uint256 tokenMinLimit;\\n        uint256 stethCollateral;\\n        uint256 wethDebt;\\n        uint256 tokenVaultBal;\\n        uint256 netTokenBal;\\n        VaultInterface.Ratios ratios;\\n        uint256 ethCoveringDebt;\\n        uint256 excessDebt;\\n        uint256 tokenPriceInEth;\\n        uint256 netTokenCollateralInEth;\\n        uint256 currentRatioMax;\\n    }\\n\\n    function rebalanceTwoData(address vaultAddr_)\\n        public\\n        view\\n        returns (\\n            address flashTkn_,\\n            uint256 flashAmt_,\\n            uint256 route_,\\n            uint256 saveAmt_,\\n            uint256 tokenSupplyAmt_\\n        )\\n    {\\n        VaultInterface vault_ = VaultInterface(vaultAddr_);\\n        RebalanceTwoVariables memory v_;\\n        v_.tokenAddr = vault_.token();\\n        v_.tokenDecimals = vault_.decimals();\\n        v_.tokenMinLimit = vault_.tokenMinLimit();\\n        (\\n            ,\\n            v_.stethCollateral,\\n            v_.wethDebt,\\n            v_.tokenVaultBal,\\n            ,\\n            v_.netTokenBal\\n        ) = vault_.getVaultBalances();\\n        if (v_.tokenVaultBal > v_.tokenMinLimit)\\n            tokenSupplyAmt_ = v_.tokenVaultBal;\\n        VaultInterface.Ratios memory ratios_ = vault_.ratios();\\n        v_.ethCoveringDebt = (v_.stethCollateral * ratios_.stEthLimit) / 10000;\\n        v_.excessDebt = v_.ethCoveringDebt < v_.wethDebt\\n            ? v_.wethDebt - v_.ethCoveringDebt\\n            : 0;\\n        v_.tokenPriceInEth = IAavePriceOracle(\\n            aaveAddressProvider.getPriceOracle()\\n        ).getAssetPrice(v_.tokenAddr);\\n        v_.netTokenCollateralInEth =\\n            (v_.netTokenBal * v_.tokenPriceInEth) /\\n            (10**v_.tokenDecimals);\\n        v_.currentRatioMax = v_.netTokenCollateralInEth == 0\\n            ? 0\\n            : (v_.excessDebt * 10000) / v_.netTokenCollateralInEth;\\n        if (v_.currentRatioMax > ratios_.maxLimit) {\\n            saveAmt_ =\\n                ((v_.currentRatioMax - (ratios_.maxLimitGap + 10)) *\\n                    v_.netTokenCollateralInEth) /\\n                (10000 - ratios_.stEthLimit);\\n            flashTkn_ = wethAddr;\\n            // TODO: dont take flashloan if not needed\\n            flashAmt_ =\\n                (v_.netTokenCollateralInEth / 10) +\\n                ((saveAmt_ * 10) / 8); // 10% of current collateral(in eth) + (leverageAmt_ / 0.8)\\n            route_ = 5;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v2/helpers.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces.sol\\\";\\n\\ncontract Helpers {\\n    IAaveAddressProvider internal constant aaveAddressProvider =\\n        IAaveAddressProvider(0xB53C1a33016B2DC2fF3653530bfF1848a515c8c5);\\n    address internal constant wethAddr =\\n        0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\\n    address internal constant stEthAddr =\\n        0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84;\\n\\n    function checkIfBorrowAllowed(address vaultDsaAddr_, uint256 wethBorrowAmt_) internal view returns (bool) {\\n        (,, uint256 availableBorrowsETH,,,) = IAaveLendingPool(aaveAddressProvider.getLendingPool()).getUserAccountData(vaultDsaAddr_);\\n        return wethBorrowAmt_ >= availableBorrowsETH;\\n    }\\n\\n    function getMaxDeleverageAmt(address vaultAddr_)\\n        internal\\n        view\\n        returns (uint256 amount_)\\n    {\\n        VaultInterface vault_ = VaultInterface(vaultAddr_);\\n        address tokenAddr_ = vault_.token();\\n        uint256 tokenDecimals_ = vault_.decimals();\\n        (\\n            ,\\n            uint256 stethCollateral_,\\n            uint256 wethDebt_,\\n            ,\\n            ,\\n            uint256 netTokenBal_\\n        ) = vault_.getVaultBalances();\\n        VaultInterface.Ratios memory ratios_ = vault_.ratios();\\n        uint256 ethCoveringDebt_ = (stethCollateral_ * ratios_.stEthLimit) /\\n            10000;\\n        uint256 excessDebt_ = ethCoveringDebt_ < wethDebt_\\n            ? wethDebt_ - ethCoveringDebt_\\n            : 0;\\n        uint256 tokenPriceInEth_ = IAavePriceOracle(\\n            aaveAddressProvider.getPriceOracle()\\n        ).getAssetPrice(tokenAddr_);\\n        uint256 netTokenSupplyInEth_ = (netTokenBal_ * tokenPriceInEth_) /\\n            (10**tokenDecimals_);\\n        uint256 currentRatioMin_ = netTokenSupplyInEth_ == 0\\n            ? 0\\n            : (excessDebt_ * 10000) / netTokenSupplyInEth_;\\n        if (currentRatioMin_ > ratios_.minLimit) {\\n            // keeping 0.1% margin for final ratio\\n            amount_ =\\n                ((currentRatioMin_ - (ratios_.minLimitGap + 10)) *\\n                    netTokenSupplyInEth_) /\\n                (10000 + ratios_.stEthLimit);\\n        }\\n    }\\n\\n    function getMaxDeleverageAmts(address[] memory vaults_)\\n        internal\\n        view\\n        returns (uint256[] memory amounts_)\\n    {\\n        amounts_ = new uint256[](vaults_.length);\\n        for (uint256 i = 0; i < vaults_.length; i++) {\\n            amounts_[i] = getMaxDeleverageAmt(vaults_[i]);\\n        }\\n    }\\n\\n    function bubbleSort(address[] memory vaults_, uint256[] memory amounts_)\\n        internal\\n        pure\\n        returns (address[] memory, uint256[] memory)\\n    {\\n        for (uint256 i = 0; i < amounts_.length - 1; i++) {\\n            for (uint256 j = 0; j < amounts_.length - i - 1; j++) {\\n                if (amounts_[j] < amounts_[j + 1]) {\\n                    (\\n                        vaults_[j],\\n                        vaults_[j + 1],\\n                        amounts_[j],\\n                        amounts_[j + 1]\\n                    ) = (\\n                        vaults_[j + 1],\\n                        vaults_[j],\\n                        amounts_[j + 1],\\n                        amounts_[j]\\n                    );\\n                }\\n            }\\n        }\\n        return (vaults_, amounts_);\\n    }\\n\\n    function getTrimmedArrays(\\n        address[] memory vaults_,\\n        uint256[] memory amounts_,\\n        uint256 length_\\n    )\\n        internal\\n        pure\\n        returns (address[] memory finalVaults_, uint256[] memory finalAmts_)\\n    {\\n        finalVaults_ = new address[](length_);\\n        finalAmts_ = new uint256[](length_);\\n        for (uint256 i = 0; i < length_; i++) {\\n            finalVaults_[i] = vaults_[i];\\n            finalAmts_[i] = amounts_[i];\\n        }\\n    }\\n\\n    function getVaultsToUse(\\n        address[] memory vaultsToCheck_,\\n        uint256[] memory deleverageAmts_,\\n        uint256 leverageAmt_\\n    )\\n        internal\\n        pure\\n        returns (\\n            address[] memory vaults_,\\n            uint256[] memory amounts_,\\n            uint256 swapAmt_\\n        )\\n    {\\n        (vaults_, amounts_) = bubbleSort(vaultsToCheck_, deleverageAmts_);\\n        swapAmt_ = leverageAmt_;\\n        uint256 i;\\n        while (swapAmt_ > 0 && i < vaults_.length && amounts_[i] > 0) {\\n            if (amounts_[i] > swapAmt_) amounts_[i] = swapAmt_;\\n            swapAmt_ -= amounts_[i];\\n            i++;\\n        }\\n        if (i != vaults_.length)\\n            (vaults_, amounts_) = getTrimmedArrays(vaults_, amounts_, i);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/resolvers/mainnet/v2/interfaces.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface IAaveAddressProvider {\\n    function getPriceOracle() external view returns (address);\\n\\n    function getLendingPool() external view returns (address);\\n}\\n\\ninterface IAavePriceOracle {\\n    function getAssetPrice(address _asset) external view returns (uint256);\\n}\\n\\ninterface IAaveLendingPool {\\n    function getUserAccountData(address user)\\n        external\\n        view\\n        returns (\\n            uint256 totalCollateralETH,\\n            uint256 totalDebtETH,\\n            uint256 availableBorrowsETH,\\n            uint256 currentLiquidationThreshold,\\n            uint256 ltv,\\n            uint256 healthFactor\\n        );\\n}\\n\\ninterface VaultInterface {\\n    function token() external view returns (address);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function tokenMinLimit() external view returns (uint256);\\n\\n    function atoken() external view returns (address);\\n\\n    function vaultDsa() external view returns (address);\\n\\n    struct Ratios {\\n        uint16 maxLimit; // Above this withdrawals are not allowed\\n        uint16 maxLimitGap;\\n        uint16 minLimit; // After leverage the ratio should be below minLimit & above minLimitGap\\n        uint16 minLimitGap;\\n        uint16 stEthLimit; // if 7500. Meaning stETH collateral covers 75% of the ETH debt. Excess ETH will be covered by token limit.\\n        // send borrow rate in 4 decimals from UI. In the smart contract it'll convert to 27 decimals which where is 100%\\n        uint128 maxBorrowRate; // maximum borrow rate above this leveraging should not happen\\n    }\\n\\n    function ratios() external view returns (Ratios memory);\\n\\n    function getCurrentExchangePrice()\\n        external\\n        view\\n        returns (uint256 exchangePrice_, uint256 newRevenue_);\\n\\n    function lastRevenueExchangePrice() external view returns (uint256);\\n\\n    function revenueFee() external view returns (uint256);\\n\\n    function revenue() external view returns (uint256);\\n\\n    function revenueEth() external view returns (uint256);\\n\\n    function withdrawalFee() external view returns (uint256);\\n\\n    function idealExcessAmt() external view returns (uint256);\\n\\n    function swapFee() external view returns (uint256);\\n\\n    function deleverageFee() external view returns (uint256);\\n\\n    function saveSlippage() external view returns (uint256);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function getVaultBalances()\\n        external\\n        view\\n        returns (\\n            uint256 tokenCollateralAmt_,\\n            uint256 stethCollateralAmt_,\\n            uint256 wethDebtAmt_,\\n            uint256 tokenVaultBal_,\\n            uint256 tokenDSABal_,\\n            uint256 netTokenBal_\\n        );\\n\\n    function getNewProfits() external view returns (uint256 profits_);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"}],\"name\":\"collectProfitData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEth_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amt_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user_\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"vaultAddr\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenMinLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stEthLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idealExcessAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deleverageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vTokenTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCollateralAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethCollateralAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDebtAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRatioMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRatioMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableWithdraw\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"tokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vtokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.UserInfo[]\",\"name\":\"userInfos_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"}],\"name\":\"getVaultInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"tokenMinLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"atoken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultDsa\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"maxLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minLimitGap\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"stEthLimit\",\"type\":\"uint16\"},{\"internalType\":\"uint128\",\"name\":\"maxBorrowRate\",\"type\":\"uint128\"}],\"internalType\":\"struct VaultInterface.Ratios\",\"name\":\"ratios\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"exchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRevenueExchangePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"revenueEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"idealExcessAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deleverageFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveSlippage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vTokenTotalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenCollateralAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"netTokenBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethCollateralAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stethDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDebtAmt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethVaultBal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wethDSABal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPriceInEth\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRatioMax\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentRatioMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"availableWithdraw\",\"type\":\"uint256\"}],\"internalType\":\"struct InstaVaultResolver.VaultInfo\",\"name\":\"vaultInfo_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"vaultsToCheck_\",\"type\":\"address[]\"}],\"name\":\"rebalanceOneData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"flashTkn_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"route_\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"vaults_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amts_\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"leverageAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupplyAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenWithdrawAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"vaultAddr_\",\"type\":\"address\"}],\"name\":\"rebalanceTwoData\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"flashTkn_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"flashAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"route_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"saveAmt_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenSupplyAmt_\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "InstaVaultResolver", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}]}