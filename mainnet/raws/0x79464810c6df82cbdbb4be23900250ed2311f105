{"status": "1", "message": "OK", "result": [{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.4;\r\n\r\n/**\r\n                ,oo\r\n               (  ^)\r\n                \" \"\r\n                             ,oo\r\n                            (  ^)\r\n                             \" \"\r\n       ,oo        \u250c \u2500 \u2500 \u2500 \u2500 \u2500 \u2500           \r\n      (  ^)        I <3 Uniswap\u2502    ,oo\r\n       \" \"        \u2514 \u2500 \u2500 \u2500 \u2500 \u2500 \u2500    (  ^)\r\n                             /      \" \"\r\n                   (\\___/)  /\r\n        ,oo        \\ (- -)       ,oo\r\n       (  ^)       c\\   >'      (  ^)\r\n        \" \"          )D_/        \" \"\r\n         \\\\|,    ____| |__    ,|//\r\n           \\ )  (  `  ~   )  ( /\r\n            #\\ / /| . ' .) \\ /#\r\n            | \\ / )   , / \\ / |\r\n             \\,/ ;;,,;,;   \\,/\r\n              _,#;,;;,;,\r\n             /,i;;;,,;#,;\r\n            //  %;;,;,;;,;\r\n           ((    ;#;,;%;;,,\r\n          _//     ;,;; ,#;,\r\n         /_)      #,;    ))\r\n                 //      \\|_\r\n                 \\|_      |#\\\r\n                  |#\\      -\"\r\n                   -\"\r\n */\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                keccak256(\r\n                                    \"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\r\n                                ),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\r\nlibrary SafeTransferLib {\r\n    event Debug(bool one, bool two, uint256 retsize);\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            success := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(success, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), from) // Append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool success;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\r\n            mstore(add(freeMemoryPointer, 4), to) // Append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \"amount\" argument.\r\n\r\n            success := and(\r\n                // Set success to whether the call reverted, if not we check it either\r\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\r\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\r\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\r\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\r\n                // Counterintuitively, this call must be positioned second to the or() call in the\r\n                // surrounding and() call or else returndatasize() will be zero during the computation.\r\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\r\n            )\r\n        }\r\n\r\n        require(success, \"APPROVE_FAILED\");\r\n    }\r\n}\r\n\r\n/// @notice Arithmetic library with operations for fixed-point numbers.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\r\nlibrary FixedPointMathLib {\r\n    /*//////////////////////////////////////////////////////////////\r\n                    SIMPLIFIED FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\r\n\r\n    function mulWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, y, WAD); // Equivalent to (x * y) / WAD rounded down.\r\n    }\r\n\r\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, y, WAD); // Equivalent to (x * y) / WAD rounded up.\r\n    }\r\n\r\n    function divWadDown(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivDown(x, WAD, y); // Equivalent to (x * WAD) / y rounded down.\r\n    }\r\n\r\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        return mulDivUp(x, WAD, y); // Equivalent to (x * WAD) / y rounded up.\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                    LOW LEVEL FIXED POINT OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function mulDivDown(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // Divide z by the denominator.\r\n            z := div(z, denominator)\r\n        }\r\n    }\r\n\r\n    function mulDivUp(\r\n        uint256 x,\r\n        uint256 y,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Store x * y in z for now.\r\n            z := mul(x, y)\r\n\r\n            // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\r\n            if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\r\n                revert(0, 0)\r\n            }\r\n\r\n            // First, divide z - 1 by the denominator and add 1.\r\n            // We allow z - 1 to underflow if z is 0, because we multiply the\r\n            // end result by 0 if z is zero, ensuring we return 0 if z is zero.\r\n            z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\r\n        }\r\n    }\r\n\r\n    function rpow(\r\n        uint256 x,\r\n        uint256 n,\r\n        uint256 scalar\r\n    ) internal pure returns (uint256 z) {\r\n        assembly {\r\n            switch x\r\n            case 0 {\r\n                switch n\r\n                case 0 {\r\n                    // 0 ** 0 = 1\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // 0 ** n = 0\r\n                    z := 0\r\n                }\r\n            }\r\n            default {\r\n                switch mod(n, 2)\r\n                case 0 {\r\n                    // If n is even, store scalar in z for now.\r\n                    z := scalar\r\n                }\r\n                default {\r\n                    // If n is odd, store x in z for now.\r\n                    z := x\r\n                }\r\n\r\n                // Shifting right by 1 is like dividing by 2.\r\n                let half := shr(1, scalar)\r\n\r\n                for {\r\n                    // Shift n right by 1 before looping to halve it.\r\n                    n := shr(1, n)\r\n                } n {\r\n                    // Shift n right by 1 each iteration to halve it.\r\n                    n := shr(1, n)\r\n                } {\r\n                    // Revert immediately if x ** 2 would overflow.\r\n                    // Equivalent to iszero(eq(div(xx, x), x)) here.\r\n                    if shr(128, x) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Store x squared.\r\n                    let xx := mul(x, x)\r\n\r\n                    // Round to the nearest number.\r\n                    let xxRound := add(xx, half)\r\n\r\n                    // Revert if xx + half overflowed.\r\n                    if lt(xxRound, xx) {\r\n                        revert(0, 0)\r\n                    }\r\n\r\n                    // Set x to scaled xxRound.\r\n                    x := div(xxRound, scalar)\r\n\r\n                    // If n is even:\r\n                    if mod(n, 2) {\r\n                        // Compute z * x.\r\n                        let zx := mul(z, x)\r\n\r\n                        // If z * x overflowed:\r\n                        if iszero(eq(div(zx, x), z)) {\r\n                            // Revert if x is non-zero.\r\n                            if iszero(iszero(x)) {\r\n                                revert(0, 0)\r\n                            }\r\n                        }\r\n\r\n                        // Round to the nearest number.\r\n                        let zxRound := add(zx, half)\r\n\r\n                        // Revert if zx + half overflowed.\r\n                        if lt(zxRound, zx) {\r\n                            revert(0, 0)\r\n                        }\r\n\r\n                        // Return properly scaled zxRound.\r\n                        z := div(zxRound, scalar)\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        GENERAL NUMBER UTILITIES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z) // Like multiplying by 2 ** 64.\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z) // Like multiplying by 2 ** 32.\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z) // Like multiplying by 2 ** 16.\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z) // Like multiplying by 2 ** 8.\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z) // Like multiplying by 2 ** 4.\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z) // Like multiplying by 2 ** 2.\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice Minimal ERC4626 tokenized Vault implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\r\nabstract contract ERC4626 is ERC20 {\r\n    using SafeTransferLib for ERC20;\r\n    using FixedPointMathLib for uint256;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);\r\n\r\n    event Withdraw(\r\n        address indexed caller,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                               IMMUTABLES\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    ERC20 public immutable asset;\r\n\r\n    constructor(\r\n        ERC20 _asset,\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) ERC20(_name, _symbol, _asset.decimals()) {\r\n        asset = _asset;\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                        DEPOSIT/WITHDRAWAL LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function deposit(uint256 assets, address receiver) public virtual returns (uint256 shares) {\r\n        // Check for rounding error since we round down in previewDeposit.\r\n        require((shares = previewDeposit(assets)) != 0, \"ZERO_SHARES\");\r\n\r\n        // Need to transfer before minting or ERC777s could reenter.\r\n        asset.safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        afterDeposit(assets, shares);\r\n    }\r\n\r\n    function mint(uint256 shares, address receiver) public virtual returns (uint256 assets) {\r\n        assets = previewMint(shares); // No need to check for rounding error, previewMint rounds up.\r\n\r\n        // Need to transfer before minting or ERC777s could reenter.\r\n        asset.safeTransferFrom(msg.sender, address(this), assets);\r\n\r\n        _mint(receiver, shares);\r\n\r\n        emit Deposit(msg.sender, receiver, assets, shares);\r\n\r\n        afterDeposit(assets, shares);\r\n    }\r\n\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual returns (uint256 shares) {\r\n        shares = previewWithdraw(assets); // No need to check for rounding error, previewWithdraw rounds up.\r\n\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n\r\n        beforeWithdraw(assets, shares);\r\n\r\n        _burn(owner, shares);\r\n\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        asset.safeTransfer(receiver, assets);\r\n    }\r\n\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) public virtual returns (uint256 assets) {\r\n        if (msg.sender != owner) {\r\n            uint256 allowed = allowance[owner][msg.sender]; // Saves gas for limited approvals.\r\n\r\n            if (allowed != type(uint256).max) allowance[owner][msg.sender] = allowed - shares;\r\n        }\r\n\r\n        // Check for rounding error since we round down in previewRedeem.\r\n        require((assets = previewRedeem(shares)) != 0, \"ZERO_ASSETS\");\r\n\r\n        beforeWithdraw(assets, shares);\r\n\r\n        _burn(owner, shares);\r\n\r\n        emit Withdraw(msg.sender, receiver, owner, assets, shares);\r\n\r\n        asset.safeTransfer(receiver, assets);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                            ACCOUNTING LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function totalAssets() public view virtual returns (uint256);\r\n\r\n    function convertToShares(uint256 assets) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\r\n    }\r\n\r\n    function convertToAssets(uint256 shares) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\r\n    }\r\n\r\n    function previewDeposit(uint256 assets) public view virtual returns (uint256) {\r\n        return convertToShares(assets);\r\n    }\r\n\r\n    function previewMint(uint256 shares) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\r\n    }\r\n\r\n    function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\r\n        uint256 supply = totalSupply; // Saves an extra SLOAD if totalSupply is non-zero.\r\n\r\n        return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\r\n    }\r\n\r\n    function previewRedeem(uint256 shares) public view virtual returns (uint256) {\r\n        return convertToAssets(shares);\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                     DEPOSIT/WITHDRAWAL LIMIT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function maxDeposit(address) public view virtual returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    function maxMint(address) public view virtual returns (uint256) {\r\n        return type(uint256).max;\r\n    }\r\n\r\n    function maxWithdraw(address owner) public view virtual returns (uint256) {\r\n        return convertToAssets(balanceOf[owner]);\r\n    }\r\n\r\n    function maxRedeem(address owner) public view virtual returns (uint256) {\r\n        return balanceOf[owner];\r\n    }\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                          INTERNAL HOOKS LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function beforeWithdraw(uint256 assets, uint256 shares) internal virtual {}\r\n\r\n    function afterDeposit(uint256 assets, uint256 shares) internal virtual {}\r\n}\r\n\r\n/// @title Contains 512-bit math functions\r\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\r\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\r\nlibrary FullMath {\r\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\r\n    function mulDiv(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = a * b\r\n            // Compute the product mod 2**256 and mod 2**256 - 1\r\n            // then use the Chinese Remainder Theorem to reconstruct\r\n            // the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2**256 + prod0\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(a, b, not(0))\r\n                prod0 := mul(a, b)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division\r\n            if (prod1 == 0) {\r\n                require(denominator > 0);\r\n                assembly {\r\n                    result := div(prod0, denominator)\r\n                }\r\n                return result;\r\n            }\r\n\r\n            // Make sure the result is less than 2**256.\r\n            // Also prevents denominator == 0\r\n            require(denominator > prod1);\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0]\r\n            // Compute remainder using mulmod\r\n            uint256 remainder;\r\n            assembly {\r\n                remainder := mulmod(a, b, denominator)\r\n            }\r\n            // Subtract 256 bit number from 512 bit number\r\n            assembly {\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator\r\n            // Compute largest power of two divisor of denominator.\r\n            // Always >= 1.\r\n            uint256 twos = (0 - denominator) & denominator;\r\n            // Divide denominator by power of two\r\n            assembly {\r\n                denominator := div(denominator, twos)\r\n            }\r\n\r\n            // Divide [prod1 prod0] by the factors of two\r\n            assembly {\r\n                prod0 := div(prod0, twos)\r\n            }\r\n            // Shift in bits from prod1 into prod0. For this we need\r\n            // to flip `twos` such that it is 2**256 / twos.\r\n            // If twos is zero, then it becomes one\r\n            assembly {\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2**256\r\n            // Now that denominator is an odd number, it has an inverse\r\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\r\n            // Compute the inverse by starting with a seed that is correct\r\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\r\n            uint256 inv = (3 * denominator) ^ 2;\r\n            // Now use Newton-Raphson iteration to improve the precision.\r\n            // Thanks to Hensel's lifting lemma, this also works in modular\r\n            // arithmetic, doubling the correct bits in each step.\r\n            inv *= 2 - denominator * inv; // inverse mod 2**8\r\n            inv *= 2 - denominator * inv; // inverse mod 2**16\r\n            inv *= 2 - denominator * inv; // inverse mod 2**32\r\n            inv *= 2 - denominator * inv; // inverse mod 2**64\r\n            inv *= 2 - denominator * inv; // inverse mod 2**128\r\n            inv *= 2 - denominator * inv; // inverse mod 2**256\r\n\r\n            // Because the division is now exact we can divide by multiplying\r\n            // with the modular inverse of denominator. This will give us the\r\n            // correct result modulo 2**256. Since the precoditions guarantee\r\n            // that the outcome is less than 2**256, this is the final result.\r\n            // We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inv;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n    /// @param a The multiplicand\r\n    /// @param b The multiplier\r\n    /// @param denominator The divisor\r\n    /// @return result The 256-bit result\r\n    function mulDivRoundingUp(\r\n        uint256 a,\r\n        uint256 b,\r\n        uint256 denominator\r\n    ) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            result = mulDiv(a, b, denominator);\r\n            if (mulmod(a, b, denominator) > 0) {\r\n                require(result < type(uint256).max);\r\n                result++;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\npragma abicoder v2;\r\n\r\n/// @title Quoter Interface\r\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\r\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\r\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\r\ninterface IQuoter {\r\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\r\n    /// @param amountIn The amount of the first token to swap\r\n    /// @return amountOut The amount of the last token that would be received\r\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\r\n\r\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param fee The fee of the token pool to consider for the pair\r\n    /// @param amountIn The desired input amount\r\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountOut The amount of `tokenOut` that would be received\r\n    function quoteExactInputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountIn,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountOut);\r\n\r\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\r\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\r\n    /// @param amountOut The amount of the last token to receive\r\n    /// @return amountIn The amount of first token required to be paid\r\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\r\n\r\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\r\n    /// @param tokenIn The token being swapped in\r\n    /// @param tokenOut The token being swapped out\r\n    /// @param fee The fee of the token pool to consider for the pair\r\n    /// @param amountOut The desired output amount\r\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\r\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\r\n    function quoteExactOutputSingle(\r\n        address tokenIn,\r\n        address tokenOut,\r\n        uint24 fee,\r\n        uint256 amountOut,\r\n        uint160 sqrtPriceLimitX96\r\n    ) external returns (uint256 amountIn);\r\n}\r\n\r\n/// @title UniswapV3Juggler\r\n/// @author zefram.eth\r\n/// @notice Given xPYT/NYT input, computes how much to swap to result in\r\n/// an equal amount of PYT & NYT.\r\n/// @dev Used in conjunction with UniswapV3Swapper::swapNytToUnderlying() and\r\n/// UniswapV3Swapper::swapXpytToUnderlying(). Should only be called offchain since\r\n/// the gas cost is too high to be called onchain.\r\ncontract UniswapV3Juggler {\r\n    /// -----------------------------------------------------------------------\r\n    /// Constants\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick + 1. Equivalent to getSqrtRatioAtTick(MIN_TICK) + 1\r\n    /// Copied from v3-core/libraries/TickMath.sol\r\n    uint160 internal constant MIN_SQRT_RATIO_PLUS_ONE = 4295128740;\r\n\r\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick - 1. Equivalent to getSqrtRatioAtTick(MAX_TICK) - 1\r\n    /// Copied from v3-core/libraries/TickMath.sol\r\n    uint160 internal constant MAX_SQRT_RATIO_MINUS_ONE =\r\n        1461446703485210103287273052203988822378723970341;\r\n\r\n    /// @dev The maximum number of binary search iterations to find swapAmountIn\r\n    uint256 internal constant MAX_BINARY_SEARCH_ITERATIONS = 256;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Immutable parameters\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice The official Uniswap V3 factory address\r\n    address public immutable factory;\r\n\r\n    /// @notice The Uniswap V3 Quoter deployment\r\n    IQuoter public immutable quoter;\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Constructor\r\n    /// -----------------------------------------------------------------------\r\n\r\n    constructor(address factory_, IQuoter quoter_) {\r\n        factory = factory_;\r\n        quoter = quoter_;\r\n    }\r\n\r\n    /// -----------------------------------------------------------------------\r\n    /// Juggle token inputs\r\n    /// -----------------------------------------------------------------------\r\n\r\n    /// @notice Given xPYT input, compute how much xPYT to swap into NYT to result in\r\n    /// an equal amount of PYT & NYT.\r\n    /// @param nyt The NYT contract\r\n    /// @param xPYT The xPYT contract\r\n    /// @param fee The fee tier of the Uniswap V3 pool to use\r\n    /// @param tokenAmountIn The amount of token input\r\n    /// @param maxError The maximum acceptable difference between the resulting PYT & NYT balances.\r\n    /// Might not be achieved if MAX_BINARY_SEARCH_ITERATIONS is reached.\r\n    /// @return swapAmountIn The amount of xPYT to swap into NYT\r\n    function juggleXpytInput(\r\n        ERC20 nyt,\r\n        ERC4626 xPYT,\r\n        uint24 fee,\r\n        uint256 tokenAmountIn,\r\n        uint256 maxError\r\n    ) external returns (uint256 swapAmountIn) {\r\n        bool zeroForOne = address(xPYT) < address(nyt);\r\n\r\n        // do binary search to find swapAmountIn that balances the end state PYT/NYT amounts\r\n        (uint256 lo, uint256 hi) = (0, tokenAmountIn);\r\n        swapAmountIn = tokenAmountIn >> 1; // take initial guess\r\n        uint256 i;\r\n        while (i < MAX_BINARY_SEARCH_ITERATIONS) {\r\n            uint256 endStateNYTBalance = quoter.quoteExactInputSingle(\r\n                address(xPYT),\r\n                address(nyt),\r\n                fee,\r\n                swapAmountIn,\r\n                zeroForOne ? MIN_SQRT_RATIO_PLUS_ONE : MAX_SQRT_RATIO_MINUS_ONE\r\n            );\r\n            uint256 endStatePYTBalance = xPYT.convertToAssets(\r\n                tokenAmountIn - swapAmountIn\r\n            );\r\n            if (endStatePYTBalance > endStateNYTBalance + maxError) {\r\n                // end up with more PYT than NYT\r\n                // swap more\r\n                (lo, swapAmountIn, hi) = (\r\n                    swapAmountIn,\r\n                    (swapAmountIn + hi) >> 1,\r\n                    hi\r\n                );\r\n            } else if (endStatePYTBalance + maxError < endStateNYTBalance) {\r\n                // end up with more NYT than PYT\r\n                // swap less\r\n                (lo, swapAmountIn, hi) = (\r\n                    lo,\r\n                    (lo + swapAmountIn) >> 1,\r\n                    swapAmountIn\r\n                );\r\n            } else {\r\n                // end up with the same amount of NYT and NYT\r\n                // return result\r\n                return swapAmountIn;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Given NYT input, compute how much NYT to swap into xPYT to result in\r\n    /// an equal amount of PYT & NYT.\r\n    /// @param nyt The NYT contract\r\n    /// @param xPYT The xPYT contract\r\n    /// @param fee The fee tier of the Uniswap V3 pool to use\r\n    /// @param tokenAmountIn The amount of token input\r\n    /// @param maxError The maximum acceptable difference between the resulting PYT & NYT balances.\r\n    /// Might not be achieved if MAX_BINARY_SEARCH_ITERATIONS is reached.\r\n    /// @return swapAmountIn The amount of NYT to swap into xPYT\r\n    function juggleNytInput(\r\n        ERC20 nyt,\r\n        ERC4626 xPYT,\r\n        uint24 fee,\r\n        uint256 tokenAmountIn,\r\n        uint256 maxError\r\n    ) external returns (uint256 swapAmountIn) {\r\n        bool zeroForOne = address(nyt) < address(xPYT);\r\n\r\n        // do binary search to find swapAmountIn that balances the end state PYT/NYT amounts\r\n        (uint256 lo, uint256 hi) = (0, tokenAmountIn);\r\n        swapAmountIn = tokenAmountIn >> 1; // take initial guess\r\n        uint256 i;\r\n        while (i < MAX_BINARY_SEARCH_ITERATIONS) {\r\n            uint256 tokenAmountOut = quoter.quoteExactInputSingle(\r\n                address(nyt),\r\n                address(xPYT),\r\n                fee,\r\n                swapAmountIn,\r\n                zeroForOne ? MIN_SQRT_RATIO_PLUS_ONE : MAX_SQRT_RATIO_MINUS_ONE\r\n            );\r\n            uint256 endStateNYTBalance = tokenAmountIn - swapAmountIn;\r\n            uint256 endStatePYTBalance = xPYT.convertToAssets(tokenAmountOut);\r\n            if (endStatePYTBalance > endStateNYTBalance + maxError) {\r\n                // end up with more PYT than NYT\r\n                // swap less\r\n                (lo, swapAmountIn, hi) = (\r\n                    lo,\r\n                    (lo + swapAmountIn) >> 1,\r\n                    swapAmountIn\r\n                );\r\n            } else if (endStatePYTBalance + maxError < endStateNYTBalance) {\r\n                // end up with more NYT than PYT\r\n                // swap more\r\n                (lo, swapAmountIn, hi) = (\r\n                    swapAmountIn,\r\n                    (swapAmountIn + hi) >> 1,\r\n                    hi\r\n                );\r\n            } else {\r\n                // end up with the same amount of NYT and NYT\r\n                // return result\r\n                return swapAmountIn;\r\n            }\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"},{\"internalType\":\"contract IQuoter\",\"name\":\"quoter_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"nyt\",\"type\":\"address\"},{\"internalType\":\"contract ERC4626\",\"name\":\"xPYT\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxError\",\"type\":\"uint256\"}],\"name\":\"juggleNytInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"nyt\",\"type\":\"address\"},{\"internalType\":\"contract ERC4626\",\"name\":\"xPYT\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxError\",\"type\":\"uint256\"}],\"name\":\"juggleXpytInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"swapAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoter\",\"outputs\":[{\"internalType\":\"contract IQuoter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "UniswapV3Juggler", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f984000000000000000000000000b27308f9f90d607463bb33ea1bebb41c27ce5ab6", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3f565b93531bd78752e7a8839ee9b218cfd8eaa89747572c0b16c225c0aebc96"}]}